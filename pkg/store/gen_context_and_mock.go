// +build ignore

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/build"
	"go/format"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"sort"
	"strings"

	"sourcegraph.com/sourcegraph/sourcegraph/pkg/gen"
)

var (
	storesFile     = flag.String("o1", "", "stores output file (default: stdout)")
	mockstoresFile = flag.String("o2", "", "mock stores output file (default: stdout)")

	fset = token.NewFileSet()
)

func main() {
	flag.Parse()
	log.SetFlags(0)

	bpkg, err := build.ImportDir(".", 0)
	if err != nil {
		log.Fatal(err)
	}
	goFilesOnly := func(fi os.FileInfo) bool {
		for _, f := range bpkg.GoFiles {
			if fi.Name() == f {
				return true
			}
		}
		return false
	}

	astPkgs, err := parser.ParseDir(fset, ".", goFilesOnly, parser.AllErrors)
	if err != nil {
		log.Fatal(err)
	}

	var astPkg *ast.Package
	for _, p := range astPkgs {
		astPkg = p
	}
	if astPkg == nil {
		log.Fatal("Error: no AST packages found in the current directory.")
	}

	ifaces := gen.Types(astPkg, func(tspec *ast.TypeSpec) bool {
		_, ok := tspec.Type.(*ast.InterfaceType)
		return ok && ast.IsExported(tspec.Name.Name)
	})
	if len(ifaces) == 0 {
		log.Println("warning: package has no interface types")
	}

	// Add
	ifaces = append(ifaces, &ast.TypeSpec{
		Name: ast.NewIdent("Graph"),
	})

	// Sort for determinism.
	sort.Sort(sortableIfaces(ifaces))

	src, err := writeStores(ifaces, astPkg.Name)
	if err != nil {
		log.Fatal(err)
	}
	writeFile(*storesFile, src)

	src, err = writeMockStores(ifaces, "mockstore")
	if err != nil {
		log.Fatal(err)
	}
	writeFile(*mockstoresFile, src)
}

func writeFile(file string, src []byte) {
	var w io.Writer
	if file == "" {
		w = os.Stdout
	} else {
		f, err := os.Create(file)
		if err != nil {
			log.Fatal(err)
		}
		defer f.Close()
		w = f
	}
	if _, err := w.Write(src); err != nil {
		log.Fatal(err)
	}
}

func contextKey(iface *ast.TypeSpec) string {
	return "_" + name(iface) + "Key"
}

func name(iface *ast.TypeSpec) string {
	return iface.Name.Name
}

func typeName(iface *ast.TypeSpec) string {
	name := name(iface)
	if name == "Graph" {
		return "srcstore.MultiRepoStoreImporterIndexer"
	}
	return name
}

func mockTypeName(iface *ast.TypeSpec) string {
	name := name(iface)
	if name == "Graph" {
		return "srcstore.MockMultiRepoStore"
	}
	return name
}

type sortableIfaces []*ast.TypeSpec

func (v sortableIfaces) Len() int           { return len(v) }
func (v sortableIfaces) Less(i, j int) bool { return v[i].Name.Name < v[j].Name.Name }
func (v sortableIfaces) Swap(i, j int)      { v[i], v[j] = v[j], v[i] }

func writeStores(ifaces []*ast.TypeSpec, outPkgName string) ([]byte, error) {
	var w bytes.Buffer

	fmt.Fprintln(&w, "// GENERATED CODE - DO NOT EDIT!")
	fmt.Fprintln(&w, "// \x40generated")
	fmt.Fprintln(&w, "//")
	fmt.Fprintln(&w, "// Generated by:")
	fmt.Fprintln(&w, "//")
	fmt.Fprintf(&w, "//   go run gen_context_and_mock.go %s\n", strings.Join(os.Args[1:], " "))
	fmt.Fprintln(&w, "//")
	fmt.Fprintln(&w, "// Called via:")
	fmt.Fprintln(&w, "//")
	fmt.Fprintln(&w, "//   go generate")
	fmt.Fprintln(&w, "//")
	fmt.Fprintln(&w)
	fmt.Fprint(&w, "package ", outPkgName, "\n")
	fmt.Fprintln(&w)
	fmt.Fprintln(&w, "import (")
	fmt.Fprint(&w, "\t", `"golang.org/x/net/context"`, "\n")
	fmt.Fprint(&w, "\t", `srcstore "sourcegraph.com/sourcegraph/srclib/store"`, "\n")
	fmt.Fprintln(&w, ")")
	fmt.Fprintln(&w)

	fmt.Fprintln(&w, "// Stores has a field for each store interface.")
	fmt.Fprintln(&w, "type Stores struct {")
	for _, iface := range ifaces {
		fmt.Fprintf(&w, "\t%s %s\n", name(iface), typeName(iface))
	}
	fmt.Fprintln(&w, "}")
	fmt.Fprintln(&w)

	fmt.Fprintln(&w, "type contextKey int")
	fmt.Fprintln(&w)
	fmt.Fprintln(&w, "const (")
	for i, iface := range ifaces {
		fmt.Fprint(&w, "\t", contextKey(iface))
		if i == 0 {
			fmt.Fprint(&w, " contextKey = iota")
		}
		fmt.Fprintln(&w)
	}
	fmt.Fprintln(&w, ")")
	fmt.Fprintln(&w)

	// WithStores
	fmt.Fprintln(&w, "// WithStores returns a copy of parent with the given stores. If a store's field value is nil, its previous value is inherited from parent in the new context.")
	fmt.Fprintln(&w, "func WithStores(ctx context.Context, s Stores) context.Context {")
	for _, iface := range ifaces {
		fmt.Fprintf(&w, "\tif s.%s != nil {\n", name(iface))
		fmt.Fprintf(&w, "\t\tctx = With%s(ctx, s.%s)\n", name(iface), name(iface))
		fmt.Fprintln(&w, "\t}")
	}
	fmt.Fprintln(&w, "\treturn ctx")
	fmt.Fprintln(&w, "}")

	for _, iface := range ifaces {
		fmt.Fprintf(&w, "// With%s returns a copy of parent with the given %s store.\n", name(iface), name(iface))
		fmt.Fprintf(&w, "func With%s(parent context.Context, s %s) context.Context {\n", name(iface), typeName(iface))
		fmt.Fprintf(&w, "\treturn context.WithValue(parent, %s, s)\n", contextKey(iface))
		fmt.Fprintln(&w, "}")
		fmt.Fprintln(&w)
		fmt.Fprintf(&w, "// %sFromContext gets the context's %s store. If the store is not present, it panics.\n", name(iface), name(iface))
		fmt.Fprintf(&w, "func %sFromContext(ctx context.Context) %s {\n", name(iface), typeName(iface))
		fmt.Fprintf(&w, "\ts, ok := ctx.Value(%s).(%s)\n", contextKey(iface), typeName(iface))
		fmt.Fprintln(&w, "\tif !ok || s == nil {")
		fmt.Fprintf(&w, "\t\tpanic(\"no %s set in context\")\n", name(iface))
		fmt.Fprintln(&w, "\t}")
		fmt.Fprintln(&w, "\treturn s")
		fmt.Fprintln(&w, "}")
	}

	return format.Source(w.Bytes())
}

func writeMockStores(ifaces []*ast.TypeSpec, outPkgName string) ([]byte, error) {
	var w bytes.Buffer

	fmt.Fprintln(&w, "// GENERATED CODE - DO NOT EDIT!")
	fmt.Fprintln(&w, "//")
	fmt.Fprintln(&w, "// Generated by:")
	fmt.Fprintln(&w, "//")
	fmt.Fprintf(&w, "//   go run gen_context_and_mock.go %s\n", strings.Join(os.Args[1:], " "))
	fmt.Fprintln(&w, "//")
	fmt.Fprintln(&w, "// Called via:")
	fmt.Fprintln(&w, "//")
	fmt.Fprintln(&w, "//   go generate")
	fmt.Fprintln(&w, "//")
	fmt.Fprintln(&w)
	fmt.Fprint(&w, "package ", outPkgName, "\n")
	fmt.Fprintln(&w)
	fmt.Fprintln(&w, "import (")
	fmt.Fprint(&w, "\t", `srcstore "sourcegraph.com/sourcegraph/srclib/store"`, "\n")
	fmt.Fprint(&w, "\t", `"sourcegraph.com/sourcegraph/sourcegraph/pkg/store"`, "\n")
	fmt.Fprintln(&w, ")")
	fmt.Fprintln(&w)

	fmt.Fprintln(&w, "// Stores has a field for each store interface with the concrete mock type (to obviate the need for tedious type assertions in test code).")
	fmt.Fprintln(&w, "type Stores struct {")
	for _, iface := range ifaces {
		fmt.Fprintf(&w, "\t%s %s\n", name(iface), mockTypeName(iface))
	}
	fmt.Fprintln(&w, "}")

	fmt.Fprintln(&w)
	fmt.Fprintln(&w, "func (s *Stores) Stores() store.Stores {")
	fmt.Fprintln(&w, "\t return store.Stores{")
	for _, iface := range ifaces {
		fmt.Fprintf(&w, "\t%s: &s.%s,\n", name(iface), name(iface))
	}
	fmt.Fprintln(&w, "\t}")
	fmt.Fprintln(&w, "}")

	return format.Source(w.Bytes())
}
