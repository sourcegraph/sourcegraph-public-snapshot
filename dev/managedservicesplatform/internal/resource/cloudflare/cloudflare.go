package cloudflare

import (
	"github.com/aws/constructs-go/constructs/v10"
	"github.com/sourcegraph/managed-services-platform-cdktf/gen/cloudflare/datacloudflarezones"
	"github.com/sourcegraph/managed-services-platform-cdktf/gen/cloudflare/record"

	"github.com/sourcegraph/sourcegraph/dev/managedservicesplatform/internal/resource/loadbalancer"
	"github.com/sourcegraph/sourcegraph/dev/managedservicesplatform/internal/resourceid"
	"github.com/sourcegraph/sourcegraph/dev/managedservicesplatform/spec"
	"github.com/sourcegraph/sourcegraph/lib/pointers"
)

type Output struct {
}

type Config struct {
	Spec spec.EnvironmentDomainCloudflareSpec

	// Target load balancer setup for Cloudflare to route requests to
	Target loadbalancer.Output
}

// New sets up an external Cloudflare frontend for a load balancer target:
//
//	Cloudflare -> LoadBalancer
//
// This is partly based on the infrastructure generated by the Cloud Run Integration
// Custom Domains - Google Cloud Load Balancing and this old blog post:
// https://cloud.google.com/blog/topics/developers-practitioners/serverless-load-balancing-terraform-hard-way
func New(scope constructs.Construct, id resourceid.ID, config Config) (*Output, error) {
	// Get the Cloudflare zone requested in configuration, and create a Cloudflare
	// record that points to our external address
	cfZone := datacloudflarezones.NewDataCloudflareZones(scope,
		id.TerraformID("domain"),
		&datacloudflarezones.DataCloudflareZonesConfig{
			Filter: &datacloudflarezones.DataCloudflareZonesFilter{
				Name: pointers.Ptr(config.Spec.Zone),
			},
		})
	_ = record.NewRecord(scope,
		id.TerraformID("record"),
		&record.RecordConfig{
			ZoneId:  cfZone.Zones().Get(pointers.Float64(0)).Id(),
			Name:    &config.Spec.Subdomain,
			Type:    pointers.Ptr("A"),
			Value:   config.Target.ExternalAddress.Address(),
			Proxied: pointers.Ptr(config.Spec.Proxied),
			Comment: pointers.Ptr("Managed Services Platform service"),
			Tags:    pointers.Ptr(pointers.Slice([]string{"msp"})),
		})
	return &Output{}, nil
}
