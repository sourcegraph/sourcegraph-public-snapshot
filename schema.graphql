# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"A changeset on a codehost."
interface Changeset {
    "The batch changes that contain this changeset."
    batchChanges(
        "Opaque pagination cursor."
        after: String
        "Returns the first n batch changes from the list."
        first: Int = 50
        "Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`."
        state: BatchChangeState
        "Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it."
        states: [BatchChangeState!]
        "Only include batch changes that the viewer can administer."
        viewerCanAdminister: Boolean
    ): BatchChangeConnection!
    "The date and time when the changeset was created."
    createdAt: DateTime!
    "The external state of the changeset, or null when not yet published to the code host."
    externalState: ChangesetExternalState
        @deprecated(reason: "Use state instead. This field is deprecated and will be removed in a future release.")
    "The unique ID for the changeset."
    id: ID!
    "The date and time when the next changeset sync is scheduled, or null if none is scheduled."
    nextSyncAt: DateTime
    "The publication state of the changeset."
    publicationState: ChangesetPublicationState!
        @deprecated(reason: "Use state instead. This field is deprecated and will be removed in a future release.")
    "The reconciler state of the changeset."
    reconcilerState: ChangesetReconcilerState!
        @deprecated(reason: "Use state instead. This field is deprecated and will be removed in a future release.")
    "The state of the changeset."
    state: ChangesetState!
    "The date and time when the changeset was updated."
    updatedAt: DateTime!
}

"""
A changeset spec is an immutable description of the desired state of a changeset in a batch change. To
create a changeset spec, use the createChangesetSpec mutation.
"""
interface ChangesetSpec {
    """
    The date, if any, when this changeset spec expires and is automatically purged. A changeset
    spec never expires (and this field is null) if its batch spec has been applied.
    """
    expiresAt: DateTime
    """
    The unique ID for a changeset spec.

    The ID is unguessable (i.e., long and randomly generated, not sequential). This is important
    even though repository permissions also apply to viewers of changeset specs, because being
    allowed to view a repository should not entitle a person to view all not-yet-published
    changesets for that repository. Consider a batch change to fix a security vulnerability: the
    batch change author may prefer to prepare all of the changesets in private so that the window
    between revealing the problem and merging the fixes is as short as possible.
    """
    id: ID!
    "The type of changeset spec."
    type: ChangesetSpecType!
}

"""
A file.
In a future version of Sourcegraph, a repository's files may be distinct from a repository's blobs
(for example, to support searching/browsing generated files that aren't committed and don't exist
as Git blobs). Clients should generally use the GitBlob concrete type and GitCommit.blobs (not
GitCommit.files), unless they explicitly want to opt-in to different behavior in the future.
INTERNAL: This is temporarily named File2 during a migration. Do not refer to the name File2 in
any API clients as the name will change soon.
"""
interface File2 {
    "Whether or not it is binary."
    binary: Boolean!
    "The file size in bytes."
    byteSize: Int!
    "The canonical URL to this file (using an immutable revision specifier)."
    canonicalURL: String!
    "The content of this file."
    content: String!
    "The URLs to this file on external services."
    externalURLs: [ExternalLink!]!
    "Highlight the file."
    highlight(
        disableTimeout: Boolean!
        """
        If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.
        2000 bytes is enabled. This may produce a significant amount of HTML
        which some browsers (such as Chrome, but not Firefox) may have trouble
        rendering efficiently.
        """
        highlightLongLines: Boolean = false
        isLightTheme: Boolean
    ): HighlightedFile!
    "False because this is a file, not a directory."
    isDirectory: Boolean!
    "The base name (i.e., file name only) of this file."
    name: String!
    "The full path (relative to the root) of this file."
    path: String!
    """
    The file rendered as rich HTML, or an empty string if it is not a supported
    rich file type.
    This HTML string is already escaped and thus is always safe to render.
    """
    richHTML: String!
    "The URL to this file (using the input revision specifier, which may not be immutable)."
    url: String!
}

"A search result. Every type of search result, except FileMatch, must implement this interface."
interface GenericSearchResultInterface {
    "A markdown string that is rendered less prominently."
    detail: Markdown!
    "A markdown string that is rendered prominently."
    label: Markdown!
    "A list of matches in this search result."
    matches: [SearchResultMatch!]!
    "The URL of the result."
    url: String!
}

"A namespace is a container for certain types of data and settings, such as a user or organization."
interface Namespace {
    "The globally unique ID of this namespace."
    id: ID!
    """
    The name of this namespace's component. For a user, this is the username. For an organization,
    this is the organization name.
    """
    namespaceName: String!
    "The URL to this namespace."
    url: String!
}

"An object with an ID."
interface Node {
    "The ID of the node."
    id: ID!
}

"""
SettingsSubject is something that can have settings: a site ("global settings", which is different from "site
configuration"), an organization, or a user.
"""
interface SettingsSubject {
    "DEPRECATED"
    configurationCascade: ConfigurationCascade!
        @deprecated(
            reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release."
        )
    "The ID."
    id: ID!
    "The latest settings."
    latestSettings: Settings
    """
    All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
    that were merged to produce the final merged settings.
    """
    settingsCascade: SettingsCascade!
    "The URL to the settings."
    settingsURL: String
    "Whether the viewer can modify the subject's settings."
    viewerCanAdminister: Boolean!
}

"A file, directory, or other tree entry."
interface TreeEntry {
    "The canonical URL to this tree entry (using an immutable revision specifier)."
    canonicalURL: String!
    "The URLs to this tree entry on external services."
    externalURLs: [ExternalLink!]!
    "Whether this tree entry is a directory."
    isDirectory: Boolean!
    "Whether this tree entry is a single child"
    isSingleChild(
        "Returns the first n files in the tree."
        first: Int
        "Recurse into sub-trees."
        recursive: Boolean = false
        "Recurse into sub-trees of single-child directories"
        recursiveSingleChild: Boolean = false
    ): Boolean!
    "LSIF data for this tree entry."
    lsif(
        "An optional filter for the name of the tool that produced the upload data."
        toolName: String
    ): TreeEntryLSIFData
    "The base name (i.e., file name only) of this tree entry."
    name: String!
    "The full path (relative to the repository root) of this tree entry."
    path: String!
    "Submodule metadata if this tree points to a submodule"
    submodule: Submodule
    "Symbols defined in this file or directory."
    symbols(
        "Returns the first n symbols from the list."
        first: Int
        "Return symbols matching the query."
        query: String
    ): SymbolConnection!
    "The URL to this tree entry (using the input revision specifier, which may not be immutable)."
    url: String!
}

"""
LSIF data available for a tree entry (file OR directory, see GitBlobLSIFData for file-specific
resolvers and GitTreeLSIFData for directory-specific resolvers.)
"""
interface TreeEntryLSIFData {
    "Code diagnostics provided through LSIF."
    diagnostics(first: Int): DiagnosticConnection!
    "A list of definitions of the symbol described by the given documentation path ID, if any."
    documentationDefinitions(pathID: String!): LocationConnection!
    """
    Returns the documentation page corresponding to the given path ID, where the empty string "/"
    refers to the current tree entry and can be used to walk all documentation below this tree entry.

    Currently this method is only supported on the root tree entry of a repository.

    A pathID refers to all the structured documentation slugs emitted by the LSIF indexer joined together
    with a slash, starting at the slug corresponding to this tree entry filepath. A pathID and filepath may
    sometimes look similar, but are not equal. Some examples include:

    * A documentation page under filepath `internal/pkg/mux` with pathID `/Router/ServeHTTP/examples`.
    * A documentation page under filepath `/` (repository root) with pathID `/internal/pkg/mux/Router/ServeHTTP/examples`

    In other words, a path ID is said to be the path to the page, relative to the tree entry
    filepath.

    The components of the pathID are chosen solely by the LSIF indexer, and may vary over time or
    even dynamically based on e.g. project size. The same is true of pages, e.g. an LSIF indexer
    may choose to create new pages if an API surface exceeds some threshold size.
    """
    documentationPage(pathID: String!): DocumentationPage!
    """
    Returns the documentation pth info corresponding to the given path ID, where the empty string "/"
    refers to the current tree entry and can be used to walk all documentation below this tree entry.

    Currently this method is only supported on the root tree entry of a repository.

    See @documentationPage for information about what a pathID refers to.

    This method is optimal for e.g. walking the entire documentation path structure of a repository,
    whereas documentationPage would require you to fetch the content for all pages you walk (not true
    of path info.)

    If maxDepth is specified, pages will be recursively returned up to that depth. Default max depth
    is one (immediate child pages only.)

    If ignoreIndex is true, empty index pages (pages whose only purpose is to describe pages below
    them) will not qualify as a page in relation to the maxDepth property: index pages will be
    recursively followed and included until a page with actual content is found, and only then will
    the depth be considered to increment. Default is false.

    This returns a JSON value because GraphQL has terrible support for recursive data structures: https://github.com/graphql/graphql-spec/issues/91

    The exact structure of the return value is documented here:
    https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/sourcegraph/sourcegraph%24+type+DocumentationPathInfoResult+struct&patternType=literal&case=yes
    """
    documentationPathInfo(ignoreIndex: Boolean, maxDepth: Int, pathID: String!): JSONValue!
    "A list of references of the symbol under the given document position."
    documentationReferences(
        """
        When specified, indicates that this request should be paginated and
        to fetch results starting at this cursor.
        A future request can be made for more results by passing in the
        'LocationConnection.pageInfo.endCursor' that is returned.
        """
        after: String
        """
        When specified, indicates that this request should be paginated and
        the first N results (relative to the cursor) should be returned. i.e.
        how many results to return per page.
        """
        first: Int
        "The documentation path ID, e.g. from the documentationPage return value."
        pathID: String!
    ): LocationConnection!
    "The list of LSIF uploads that may be used to service code-intel requests for this TreeEntry."
    lsifUploads: [LSIFUpload!]!
}

"A HTTP message (request or response) within a webhook log."
interface WebhookLogMessage {
    "The body content of the HTTP message."
    body: String!
    "The headers in the HTTP message."
    headers: [WebhookLogHeader!]!
}

"A preview for which actions applyBatchChange would result in when called at the point of time this preview was created at."
union ChangesetApplyPreview = HiddenChangesetApplyPreview | VisibleChangesetApplyPreview

"All possible types of changesets that can be specified in a changeset spec."
union ChangesetDescription = ExistingChangesetReference | GitBranchChangesetDescription

"A compute operation result."
union ComputeResult = ComputeMatchContext | ComputeText

"A feature flag is either a static boolean feature flag or a rollout feature flag"
union FeatureFlag = FeatureFlagBoolean | FeatureFlagRollout

"A Git revspec."
union GitRevSpec = GitObject | GitRef | GitRevSpecExpr

"Either a git tree or blob."
union GitTreeOrBlob = GitBlob | GitTree

"A preview entry to a repository to which the user has no access."
union HiddenApplyPreviewTargets =
      HiddenApplyPreviewTargetsAttach
    | HiddenApplyPreviewTargetsDetach
    | HiddenApplyPreviewTargetsUpdate

"Defines how the data series is generated."
union InsightDataSeriesDefinition = SearchInsightDataSeriesDefinition

"Defines presentation options for the insight."
union InsightPresentation = LineChartInsightViewPresentation | PieChartInsightViewPresentation

"Defines a scope of time for which the insight data is generated."
union InsightTimeScope = InsightIntervalTimeScope

"Supported actions for code monitors."
union MonitorAction = MonitorEmail | MonitorSlackWebhook | MonitorWebhook

"Supported triggers for code monitors."
union MonitorTrigger = MonitorQuery

"Notebook blocks are a union of distinct block types: Markdown, Query, File, Symbol, and Compute."
union NotebookBlock = ComputeBlock | FileBlock | MarkdownBlock | QueryBlock | SymbolBlock

"A publisher of a registry extension."
union RegistryPublisher = Org | User

"Either a preview or an actual repository comparison."
union RepositoryComparisonInterface = PreviewRepositoryComparison | RepositoryComparison

"A repository or a link to another Sourcegraph instance location where this repository may be located."
union RepositoryRedirect = Redirect | Repository

"A search result."
union SearchResult = CommitSearchResult | FileMatch | Repository

"FOR INTERNAL USE ONLY: A status message"
union StatusMessage = CloningProgress | ExternalServiceSyncError | IndexingError | IndexingProgress | SyncError

"A preview entry to a repository to which the user has access."
union VisibleApplyPreviewTargets =
      VisibleApplyPreviewTargetsAttach
    | VisibleApplyPreviewTargetsDetach
    | VisibleApplyPreviewTargetsUpdate

"An access token that grants to the holder the privileges of the user who created it."
type AccessToken implements Node {
    "The date when the access token was created."
    createdAt: DateTime!
    """
    The user who created the access token. This is either the subject user (if the access token
    was created by the same user) or a site admin (who can create access tokens for any user).
    """
    creator: User!
    "The unique ID for the access token."
    id: ID!
    "The date when the access token was last used to authenticate a request."
    lastUsedAt: DateTime
    "A user-supplied descriptive note for the access token."
    note: String!
    "The scopes that define the allowed set of operations that can be performed using this access token."
    scopes: [String!]!
    "The user whose privileges the access token grants."
    subject: User!
}

"A list of access tokens."
type AccessTokenConnection {
    "A list of access tokens."
    nodes: [AccessToken!]!
    "Pagination information."
    pageInfo: PageInfo!
    """
    The total count of access tokens in the connection. This total count may be larger than the number of nodes
    in this object when the result is paginated.
    """
    totalCount: Int!
}

"An alert message shown to the viewer."
type Alert {
    """
    If set, this alert is dismissible. After being dismissed, no other alerts with the same
    isDismissibleWithKey value will be shown. If null, this alert is not dismissible.
    """
    isDismissibleWithKey: String
    "The message body of this alert. Markdown is supported."
    message: String!
    "The type of this alert."
    type: AlertType!
}

"""
A provider of user authentication, such as an external single-sign-on service (e.g., using OpenID Connect or
SAML). The provider information in this type is visible to all viewers and does not contain any secret values.
"""
type AuthProvider {
    "A URL that, when visited, initiates the authentication process for this auth provider."
    authenticationURL: String
    "An identifier for the client of the service that the auth provider represents."
    clientID: String!
    "The human-readable name of the provider."
    displayName: String!
    "Whether this auth provider is the builtin username-password auth provider."
    isBuiltin: Boolean!
    "An identifier for the service that the auth provider represents."
    serviceID: String!
    "The type of the auth provider."
    serviceType: String!
}

"A list of authentication providers."
type AuthProviderConnection {
    "A list of authentication providers."
    nodes: [AuthProvider!]!
    "Pagination information."
    pageInfo: PageInfo!
    """
    The total count of authentication providers in the connection. This total count may be larger than the number of nodes
    in this object when the result is paginated.
    """
    totalCount: Int!
}

"Result user returned by invite members autocomplete search."
type AutocompleteMemberSearchItem {
    "The URL of the user's avatar image."
    avatarURL: String
    "The display name chosen by the user."
    displayName: String
    "The unique ID for the user."
    id: ID!
    "If the user belongs to current Organization."
    inOrg: Boolean
    "The user's username."
    username: String!
}

"A batch change is a set of related changes to apply to code across one or more repositories."
type BatchChange implements Node {
    """
    The batch specs that have been running on this batch change.

    Site-admins can see all of them, non admins can only see batch specs that they
    created.
    """
    batchSpecs(
        "Opaque pagination cursor."
        after: String
        "Returns the first n entries from the list."
        first: Int = 50
    ): BatchSpecConnection!
    "The bulk operations that have been run over this batch change."
    bulkOperations(
        "Opaque pagination cursor."
        after: String
        "Filter by createdAt value."
        createdAfter: DateTime
        "Returns the first n entries from the list."
        first: Int = 50
    ): BulkOperationConnection!
    """
    The changeset counts over time, in 1-day intervals backwards from the point in time given in
    the "to" parameter.
    """
    changesetCountsOverTime(
        "Only include changeset counts up to this point in time (inclusive). Defaults to BatchChange.createdAt."
        from: DateTime
        "Include archived changesets in the calculation."
        includeArchived: Boolean = false
        """
        Only include changeset counts up to this point in time (inclusive). Defaults to the
        current time.
        """
        to: DateTime
    ): [ChangesetCounts!]!
    "The changesets in this batch change that already exist on the code host."
    changesets(
        "Opaque pagination cursor."
        after: String
        "Only include changesets with the given check state."
        checkState: ChangesetCheckState
        "Only include changesets with the given external state."
        externalState: ChangesetExternalState
        first: Int = 50
        "Only return changesets that are archived in this batch change."
        onlyArchived: Boolean = false
        """
        Query only changesets that are either open or draft. This is used on the close page to list changesets that remain open.
        When set, passing state is not allowed.
        """
        onlyClosable: Boolean
        "Only return changesets that have been published by this batch change. Imported changesets will be omitted."
        onlyPublishedByThisBatchChange: Boolean
        "Only include changesets with the given publication state."
        publicationState: ChangesetPublicationState
        "Only include changesets with any of the given reconciler states."
        reconcilerState: [ChangesetReconcilerState!]
        "Only include changesets belonging to the given repository."
        repo: ID
        "Only include changesets with the given review state."
        reviewState: ChangesetReviewState
        "Search for changesets matching this query. Queries may include quoted substrings to match phrases, and words may be preceded by - to negate them."
        search: String
        "Only include changesets with the given state."
        state: ChangesetState
    ): ChangesetConnection!
    "Stats on all the changesets that are tracked in this batch change."
    changesetsStats: ChangesetsStats!
    "The date and time when the batch change was closed. If set, applying a spec for this batch change will fail with an error."
    closedAt: DateTime
    "The date and time when the batch change was created."
    createdAt: DateTime!
    "The user who created the batch change, or null if the user was deleted."
    creator: User
    """
    The last batch spec applied to this batch change, or an "empty" spec if the batch
    change has never had a spec applied.
    """
    currentSpec: BatchSpec!
    "The description (as Markdown)."
    description: String
    "The diff stat for all the changesets in the batch change."
    diffStat: DiffStat!
    "The unique ID for the batch change."
    id: ID!
    """
    The user who created the batch change initially by applying the spec for the first time, or null if the user was deleted.

    This is an alias of BatchChange.creator.
    """
    initialApplier: User
        @deprecated(reason: "Use creator instead. This field is deprecated and will be removed in a future release.")
    """
    The date and time when the batch change was last updated with a new spec. Null, if a batch spec has never been
    applied yet.
    """
    lastAppliedAt: DateTime
    """
    The user who last updated the batch change by applying a spec to this batch change.
    If the batch change hasn't been updated, the lastApplier is the initialApplier, or null if the user was deleted.
    """
    lastApplier: User
    "The name of the batch change."
    name: String!
    "The namespace where this batch change is defined."
    namespace: Namespace!
    "The user that created the initial spec. In an org, this will be different from the namespace, or null if the user was deleted."
    specCreator: User
        @deprecated(
            reason: "Unused. This always incorrectly returned the current batch specs creator, not the intial one. This field is deprecated and will be removed in a future release."
        )
    "The state of the batch change."
    state: BatchChangeState!
    """
    The date and time when the batch change was updated. That can be by applying a spec, or by an internal process.
    For reading the time the batch change spec was changed last, see lastAppliedAt.
    """
    updatedAt: DateTime!
    "The URL to this batch change."
    url: String!
    "Whether the current user can edit or delete this batch change."
    viewerCanAdminister: Boolean!
}

"A list of batch changes."
type BatchChangeConnection {
    "A list of batch changes."
    nodes: [BatchChange!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of batch changes in the connection."
    totalCount: Int!
}

"A BatchChangeDescription describes a batch change."
type BatchChangeDescription {
    "The description as parsed from the input."
    description: String!
    "The name as parsed from the input."
    name: String!
}

"A code host usable with batch changes. This service is accessible by the user it belongs to."
type BatchChangesCodeHost {
    "The configured credential, if any."
    credential: BatchChangesCredential
    "The kind of external service."
    externalServiceKind: ExternalServiceKind!
    "The URL of the external service."
    externalServiceURL: String!
    "If true, the code host has webhooks configured."
    hasWebhooks: Boolean!
    """
    If true, some of the repositories on this code host require
    an SSH key to be configured.
    """
    requiresSSH: Boolean!
}

"""
A connection of all code hosts usable with batch changes and accessible by the user
this is requested on.
"""
type BatchChangesCodeHostConnection {
    "A list of code hosts."
    nodes: [BatchChangesCodeHost!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of configured external services in the connection."
    totalCount: Int!
}

"A user token configured for batch changes use on the specified code host."
type BatchChangesCredential implements Node {
    "The date and time this token has been created at."
    createdAt: DateTime!
    "The kind of external service."
    externalServiceKind: ExternalServiceKind!
    "The URL of the external service."
    externalServiceURL: String!
    "A globally unique identifier."
    id: ID!
    "Whether the configured credential is a site credential, that is available globally."
    isSiteCredential: Boolean!
    """
    The public key to use on the external service for SSH keypair authentication.
    Not set if the credential doesn't support SSH access.
    """
    sshPublicKey: String
}

"""
A batch spec is an immutable description of the desired state of a batch change. To create a
batch spec, use the createBatchSpec mutation.
"""
type BatchSpec implements Node {
    """
    If true, repos with a .batchignore file will still be included in the
    execution.

    Null, if not created through createBatchSpecFromRaw.
    """
    allowIgnored: Boolean
    """
    If true, repos on unsupported codehosts will be included in the execution.
    These cannot be published.

    Null, if not created through createBatchSpecFromRaw.
    """
    allowUnsupported: Boolean
    """
    The batch change this spec will update when applied. If it's null, the
    batch change doesn't yet exist.
    """
    appliesToBatchChange: BatchChange
    """
    Generates a preview showing the operations that would be performed if the
    batch spec was applied. This preview is not a guarantee, since the state
    of the changesets can change between the time the preview is generated and
    when the batch spec is applied.
    """
    applyPreview(
        "Search for changesets that will have the given action performed."
        action: ChangesetSpecOperation
        "Opaque pagination cursor."
        after: String
        "Search for changesets that are currently in this state."
        currentState: ChangesetState
        "Returns the first n entries from the list."
        first: Int = 50
        """
        If set, it will be assumed that these changeset specs will have their
        UI publication states set to the given values when the batch spec is
        applied.

        An error will be returned if the same changeset spec ID is included
        more than once in the array, or if a changeset spec ID returned within
        this page has a publication state set in its spec.

        Note: Unlike createBatchChange(), this query will not validate that all
        changeset specs in the array correspond to valid changeset specs within
        the batch spec, as they may not all be loaded on the current page.
        """
        publicationStates: [ChangesetSpecPublicationStateInput!]
        "Search for changesets matching this query. Queries may include quoted substrings to match phrases, and words may be preceded by - to negate them."
        search: String
    ): ChangesetApplyPreviewConnection!
    """
    The URL of a web page that allows applying this batch spec and
    displays a preview of which changesets will be created by applying it.
    Null, if the execution has not finished yet.
    """
    applyURL: String
    """
    Future: Flag that calls applyBatchChange automatically when this execution completes.
    Useful for integrations with code monitoring etc.

    TODO: Not implemented yet.
    """
    autoApplyEnabled: Boolean!
    "The specs for changesets associated with this batch spec."
    changesetSpecs(after: String, first: Int = 50): ChangesetSpecConnection!
    """
    The time when the batch spec was created at. At this time, it is also added to
    the queue for execution, if created from raw.
    """
    createdAt: DateTime!
    """
    The user who created this batch spec. Their permissions will be honored when
    executing the batch spec. Null, if the user has been deleted.
    """
    creator: User
    "The BatchChangeDescription that describes this batch change."
    description: BatchChangeDescription!
    """
    The diff stat for all the changeset specs in the batch spec. Null if state is
    not COMPLETED.
    """
    diffStat: DiffStat
    """
    The date, if any, when this batch spec expires and is automatically purged. A batch spec
    never expires if it has been applied.
    """
    expiresAt: DateTime
    """
    Set when something about this batch spec is not right. For example, the input spec
    is invalid, or if ValidateChangesetSpecs throws an error when the last job completes.
    """
    failureMessage: String
    """
    The time when the execution finished. Null, if the execution hasn't finished
    yet, or if the batch spec was created in COMPLETED state.
    This value is the time of when the batch spec has been sealed.
    """
    finishedAt: DateTime
    """
    The unique ID for a batch spec.

    The ID is unguessable (i.e., long and randomly generated, not sequential).
    Consider a batch change to fix a security vulnerability: the batch change author may prefer
    to prepare the batch change, including the description in private so that the window
    between revealing the problem and merging the fixes is as short as possible.
    """
    id: ID!
    """
    The set of changeset specs for importing changesets, as determined from the
    raw spec.
    Null, if not created through createBatchSpecFromRaw.
    """
    importingChangesets(after: String, first: Int = 50, search: String): ChangesetSpecConnection
    "The namespace (either a user or organization) of the batch spec."
    namespace: Namespace!
    "The original YAML or JSON input that was used to create this batch spec."
    originalInput: String!
    """
    The parsed JSON value of the original input. If the original input was YAML, the YAML is
    converted to the equivalent JSON.
    """
    parsedInput: JSONValue!
    """
    The time when the execution started. Null, if the execution hasn't started
    yet, or if the batch spec was created in COMPLETED state.
    """
    startedAt: DateTime
    """
    The current execution state of the batch spec. For manually created ones (src-cli workflow),
    this will always be COMPLETED. This is an accumulated state over all the associated
    workspaces for convenience.
    """
    state: BatchSpecState!
    """
    The newest version of this batch spec, as identified by its namespace
    and name. If this is the newest version, this field will be null.
    """
    supersedingBatchSpec: BatchSpec
    """
    The code host connections required for applying this spec. Includes the credentials of the current user.
    Only returns useful information if state is COMPLETED.
    """
    viewerBatchChangesCodeHosts(
        "Opaque pagination cursor."
        after: String
        "Returns the first n code hosts from the list."
        first: Int = 50
        "Only returns the code hosts for which the viewer doesn't have credentials."
        onlyWithoutCredential: Boolean = false
        "Only returns code hosts that don't have webhooks configured."
        onlyWithoutWebhooks: Boolean = false
    ): BatchChangesCodeHostConnection!
    "When true, the viewing user can apply this spec."
    viewerCanAdminister: Boolean!
    """
    If true, viewer can retry the batch spec execution by calling
    retryBatchSpecExecution.
    """
    viewerCanRetry: Boolean!
    """
    A wrapper for the workspace resolution on this batch spec. Contains access to
    all workspaces that have been resolved, as well as insight into the state of
    the resolution.
    Null, if the batch spec was created in COMPLETED state.
    """
    workspaceResolution: BatchSpecWorkspaceResolution
}

"A list of batch specs."
type BatchSpecConnection {
    "A list of batch specs."
    nodes: [BatchSpec!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of batch specs in the connection."
    totalCount: Int!
}

"A workspace in Batch Changes to run in."
type BatchSpecWorkspace implements Node {
    "Used for reverse querying."
    batchSpec: BatchSpec!
    "The branch to run over."
    branch: GitRef!
    """
    Whether we found a task cache result.

    TODO: Not implemented yet.
    """
    cachedResultFound: Boolean!
    """
    Populated, when the execution is finished. This is where you get the combined
    diffs.
    """
    changesetSpecs: [ChangesetSpec!]
    """
    The diff stat over all created changeset specs. Null, if not yet finished or
    failed.
    """
    diffStat: DiffStat
    """
    The executor that picked up this job. Null, if the executor has been pruned
    from the data set or if the job has not started yet.
    Only available to site-admins.
    """
    executor: Executor
    "Optional failure message, set when the execution failed."
    failureMessage: String
    "The time when the workspace finished processing. Null, if not yet finished."
    finishedAt: DateTime
    "The unique ID for the workspace."
    id: ID!
    """
    If true, this workspace has been skipped, because some rule forced this.
    For now, the only one is a .batchignore file existing in the repository.
    """
    ignored: Boolean!
    "If true, only the files within the workspace will be fetched."
    onlyFetchWorkspace: Boolean!
    "The path to run in."
    path: String!
    """
    The rank of this execution in the queue. The value of this field is null if the
    execution has started.
    """
    placeInQueue: Int
    "The time when the workspace was enqueued for processing. Null, if not yet enqueued."
    queuedAt: DateTime
    "The repository to run over."
    repository: Repository!
    """
    If this workspace was resolved based on a search, this is the list of paths
    to files that have been included in the search results.
    """
    searchResultPaths: [String!]!
    """
    Executor stages of running in this workspace. Null, if the execution hasn't
    started yet.
    """
    stages: BatchSpecWorkspaceStages
    "The time when the workspace started processing. Null, if not yet started."
    startedAt: DateTime
    "The current state the workspace is in."
    state: BatchSpecWorkspaceState!
    "Get a specific step by its index. Index is 1-based."
    step(index: Int!): BatchSpecWorkspaceStep
    "List of steps that will need to run over this workspace."
    steps: [BatchSpecWorkspaceStep!]!
    """
    If true, this workspace has been skipped, because the code host on which
    the repository is hosted is not supported.
    """
    unsupported: Boolean!
}

"A list of workspaces."
type BatchSpecWorkspaceConnection {
    "A list of workspaces."
    nodes: [BatchSpecWorkspace!]!
    "Pagination information."
    pageInfo: PageInfo!
    "Statistics on the workspaces in this connection."
    stats: BatchSpecWorkspacesStats!
    "The total number of workspaces in the connection."
    totalCount: Int!
}

"An enviroment variable passed to a command in a step."
type BatchSpecWorkspaceEnvironmentVariable {
    "The variable name."
    name: String!
    "The variable value."
    value: String!
}

"An output variable in a step."
type BatchSpecWorkspaceOutputVariable {
    "The variable name."
    name: String!
    "The variable value."
    value: JSONValue!
}

"A bag for all info around resolving workspaces."
type BatchSpecWorkspaceResolution {
    "Error message, if the evaluation failed."
    failureMessage: String
    "Set when evaluating workspaces finished."
    finishedAt: DateTime
    "Returns the workspaces where most recently a step completed that yielded a diff."
    recentlyCompleted(after: String, first: Int = 50): BatchSpecWorkspaceConnection!
    "Returns the most recently failed workspace executions."
    recentlyErrored(after: String, first: Int = 50): BatchSpecWorkspaceConnection!
    "Set when evaluating workspaces begins."
    startedAt: DateTime
    "State of evaluating the workspaces."
    state: BatchSpecWorkspaceResolutionState!
    "The actual list of determined workspaces."
    workspaces(
        after: String
        first: Int = 50
        "Not implemented."
        orderBy: WorkspacesSortOrder
        """
        Search for workspaces matching this query. Queries may include quoted substrings
        to match phrases, and words may be preceded by - to negate them.
        Currently, this supports searching repository names only.
        """
        search: String
        "Filter workspaces by given state."
        state: BatchSpecWorkspaceState
    ): BatchSpecWorkspaceConnection!
}

"""
Configuration and execution summary of a batch spec execution. This is mostly
meant for internal consumption, for the timeline view.
"""
type BatchSpecWorkspaceStages {
    "Execution log entries related to setting up the workspace."
    setup: [ExecutionLogEntry!]!
    """
    Execution log entry related to running src batch exec.
    This field is null, if the step had not been executed.
    """
    srcExec: ExecutionLogEntry
    "Execution log entries related to tearing down the workspace."
    teardown: [ExecutionLogEntry!]!
}

"Description of one step in the execution of a workspace."
type BatchSpecWorkspaceStep {
    """
    True, if a cached result has been found.

    TODO: Not yet implemented.
    """
    cachedResultFound: Boolean!
    "The docker container image to use to run this command."
    container: String!
    "The generated diff from this step. Null, if not yet finished."
    diff: PreviewRepositoryComparison
    "The diff stat of the step result. Null, if not yet finished."
    diffStat: DiffStat
    "The environment variables passed to this step."
    environment: [BatchSpecWorkspaceEnvironmentVariable!]!
    "The exit code of the command. Null, if not yet finished."
    exitCode: Int
    "The time when the step finished processing. Null, if not yet finished."
    finishedAt: DateTime
    "The if condition, under which the step is executed. Null, if not set."
    ifCondition: String
    "The number of the step."
    number: Int!
    """
    The output logs, prefixed with either "stdout " or "stderr ". Null, if the
    step has not run yet.
    """
    outputLines(
        "Return the log lines after N lines."
        after: Int
        "Return the first N lines of logs."
        first: Int = 500
    ): [String!]
    "The output variables the step produced. Null, if not yet finished."
    outputVariables: [BatchSpecWorkspaceOutputVariable!]
    "The command to run."
    run: String!
    "True, when the `if` condition evaluated that this step doesn't need to run."
    skipped: Boolean!
    "The time when the step started processing. Null, if not yet started."
    startedAt: DateTime
}

"Statistics on all workspaces in a connection."
type BatchSpecWorkspacesStats {
    "Number of completed workspaces."
    completed: Int!
    "Number of errored workspaces."
    errored: Int!
    "Number of ignored workspaces."
    ignored: Int!
    "Number of processing workspaces."
    processing: Int!
    "Number of queued workspaces."
    queued: Int!
}

"A set of Git behind/ahead counts for one commit relative to another."
type BehindAheadCounts {
    "The number of commits ahead of the other commit."
    ahead: Int!
    "The number of commits behind the other commit."
    behind: Int!
}

"A bulk operation represents a group of jobs run over a set of changesets in a batch change."
type BulkOperation implements Node {
    "The number of changesets involved in this bulk operation."
    changesetCount: Int!
    "The time the bulk operation was created at."
    createdAt: DateTime!
    "The list of all errors that occured while processing the bulk action."
    errors: [ChangesetJobError!]!
    """
    The time the bulk operation finished. Also set, when some operations failed. Null,
    when some operations are still processing.
    """
    finishedAt: DateTime
    "The unique ID for the bulk operation."
    id: ID!
    "The user who triggered this bulk operation."
    initiator: User!
    """
    The progress to completion of all executions involved in this bulk operation. Value
    ranges from 0.0 to 1.0.
    """
    progress: Float!
    "The current state of the bulk operation."
    state: BulkOperationState!
    "The type of task that is run."
    type: BulkOperationType!
}

"A list of bulk operations."
type BulkOperationConnection {
    "A list of bulk operations."
    nodes: [BulkOperation!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of bulk operations in the connection."
    totalCount: Int!
}

"A list of preview entries."
type ChangesetApplyPreviewConnection {
    "A list of preview entries."
    nodes: [ChangesetApplyPreview!]!
    "Pagination information."
    pageInfo: PageInfo!
    "Stats on the elements in this connnection. Does not respect pagination parameters."
    stats: ChangesetApplyPreviewConnectionStats!
    "The total number of entries in the connection."
    totalCount: Int!
}

"Aggregated stats on nodes in this connection."
type ChangesetApplyPreviewConnectionStats {
    "The amount of changesets that are added to the batch change in this operation."
    added: Int!
    "The changeset will still be attached to the batch change but marked as archived."
    archive: Int!
    "Close the changeset on the codehost."
    close: Int!
    "The changeset is removed from some of the associated batch changes."
    detach: Int!
    "Import an existing changeset from the code host with the ExternalID from the spec."
    import: Int!
    "The amount of changesets that are already attached to the batch change and modified in this operation."
    modified: Int!
    "Publish a changeset to the codehost."
    publish: Int!
    "Publish a changeset to the codehost as a draft changeset. (Only on supported code hosts)."
    publishDraft: Int!
    "Push a new commit to the code host."
    push: Int!
    "The amount of changesets that are disassociated from the batch change in this operation."
    removed: Int!
    "Reopen the changeset on the codehost."
    reopen: Int!
    "Internal operation to get around slow code host updates."
    sleep: Int!
    "Sync the changeset with the current state on the codehost."
    sync: Int!
    "Move the existing changeset out of being a draft."
    undraft: Int!
    """
    Update the existing changeset on the codehost. This is purely the changeset resource on the code host,
    not the git commit. For updates to the commit, see 'PUSH'.
    """
    update: Int!
}

"A list of changesets."
type ChangesetConnection {
    "A list of changesets."
    nodes: [Changeset!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of changesets in the connection."
    totalCount: Int!
}

"The counts of changesets in certain states at a specific point in time."
type ChangesetCounts {
    "The number of closed changesets."
    closed: Int!
    "The point in time these counts were recorded."
    date: DateTime!
    "The number of draft changesets (independent of review state)."
    draft: Int!
    "The number of merged changesets."
    merged: Int!
    "The number of open changesets (independent of review state)."
    open: Int!
    "The number of changesets that are both open and approved."
    openApproved: Int!
    "The number of changesets that are both open and have requested changes."
    openChangesRequested: Int!
    "The number of changesets that are both open and are pending review."
    openPending: Int!
    "The total number of changesets."
    total: Int!
}

"A changeset event in a code host (e.g., a comment on a pull request on GitHub)."
type ChangesetEvent implements Node {
    "The changeset this event belongs to."
    changeset: ExternalChangeset!
    "The date and time when the changeset was created."
    createdAt: DateTime!
    "The unique ID for the changeset event."
    id: ID!
}

"A list of changeset events."
type ChangesetEventConnection {
    "A list of changeset events."
    nodes: [ChangesetEvent!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of changeset events in the connection."
    totalCount: Int!
}

"A reported error on a changeset in a bulk operation."
type ChangesetJobError {
    "The changeset this error is related to."
    changeset: Changeset!
    """
    The error message. Null, if the changeset is not accessible by the requesting
    user.
    """
    error: String
}

"A label attached to a changeset on a code host."
type ChangesetLabel {
    "The label's color, as a hex color code without the . For example: \"93ba13\"."
    color: String!
    "An optional description of the label."
    description: String
    "The label's text."
    text: String!
}

"A list of changeset specs."
type ChangesetSpecConnection {
    "A list of changeset specs."
    nodes: [ChangesetSpec!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of changeset specs in the connection."
    totalCount: Int!
}

"Description of the current changeset state vs the changeset spec desired state."
type ChangesetSpecDelta {
    "When run, a new commit in the name of the specified author will be created on the branch of the changeset."
    authorEmailChanged: Boolean!
    "When run, a new commit in the name of the specified author will be created on the branch of the changeset."
    authorNameChanged: Boolean!
    "When run, the target branch of the changeset will be updated."
    baseRefChanged: Boolean!
    "When run, the body of the changeset will be updated."
    bodyChanged: Boolean!
    "When run, a new commit will be created on the branch of the changeset."
    commitMessageChanged: Boolean!
    "When run, a new commit will be created on the branch of the changeset."
    diffChanged: Boolean!
    "When run, the title of the changeset will be updated."
    titleChanged: Boolean!
    "When run, the changeset will be taken out of draft mode."
    undraft: Boolean!
}

"Used in the batch change page for the overview component."
type ChangesetsStats {
    "The count of archived changesets."
    archived: Int!
    "The count of closed changesets."
    closed: Int!
    "The count of deleted changesets."
    deleted: Int!
    "The count of draft changesets."
    draft: Int!
    "The count of changesets in failed state."
    failed: Int!
    "The count of merged changesets."
    merged: Int!
    "The count of open changesets."
    open: Int!
    "The count of changesets that are currently processing or enqueued to be."
    processing: Int!
    "The count of changesets in retrying state."
    retrying: Int!
    "The count of changesets in the scheduled state."
    scheduled: Int!
    "The count of all changesets."
    total: Int!
    "The count of unpublished changesets."
    unpublished: Int!
}

"The result for Mutation.checkMirrorRepositoryConnection."
type CheckMirrorRepositoryConnectionResult {
    """
    The error message encountered during the update operation, if any. If null, then
    the connection check succeeded.
    """
    error: String
}

"Configuration details for the browser extension, editor extensions, etc."
type ClientConfigurationDetails {
    "The list of phabricator/gitlab/bitbucket/etc instance URLs that specifies which pages the content script will be injected into."
    contentScriptUrls: [String!]!
    "Returns details about the parent Sourcegraph instance."
    parentSourcegraph: ParentSourcegraphDetails!
}

"""
FOR INTERNAL USE ONLY: A status message produced when repositories are being
cloned
"""
type CloningProgress {
    "The message of this status message"
    message: String!
}

"A repository returned directly from a code host"
type CodeHostRepository {
    "The code host the repo came from"
    codeHost: ExternalService
    "The Name \"owner/reponame\" of the repo"
    name: String!
    "Is the repo private"
    private: Boolean!
}

"A list of code host repositories"
type CodeHostRepositoryConnection {
    "Errors returned from the code host."
    codeHostErrors: [String!]!
    "A list of repositories affiliated with a code host."
    nodes: [CodeHostRepository!]!
}

"Describes a precise code-intel indexer."
type CodeIntelIndexer {
    "Name of the precise code-intel indexer."
    name: String!
    "URL to the source of the indexer e.g. https://github.com/sourcegraph/lsif-go"
    url: String!
}

"A summary of the most reecent upload and index status."
type CodeIntelRepositorySummary {
    "The last time this repository was considered for auto-indexing job scheduling."
    lastIndexScan: DateTime
    "The last time uploads of this repository were checked against data retention policies."
    lastUploadRetentionScan: DateTime
    """
    A list of recent indexes for a specific repository. This list contains processing,
    recently queued, and the most recently processed indexes for each distinct indexer
    and root.
    """
    recentIndexes: [LSIFIndexesWithRepositoryNamespace!]!
    """
    A list of recent uploads for a specific repository. This list contains processing,
    recently queued, and the most recently processed uploads for each distinct indexer
    and root.
    """
    recentUploads: [LSIFUploadsWithRepositoryNamespace!]!
}

"Details the types, tools and levels of code-intel support."
type CodeIntelSupport {
    "Precise code-intel support overview."
    preciseSupport: PreciseCodeIntelSupport
    "Search-based code-intel support overview."
    searchBasedSupport: SearchBasedCodeIntelSupport
}

"""
Information and status related to the commit graph of this repository calculated
for use by code intelligence features.
"""
type CodeIntelligenceCommitGraph {
    "Whether or not the commit graph needs to be updated."
    stale: Boolean!
    "When, if ever, the commit graph was last refreshed."
    updatedAt: DateTime
}

"""
A configuration policy that applies to a set of Git objects matching an associated
pattern. Each policy has optional data retention and auto-indexing schedule configuration
attached. A policy can be applied globally or on a per-repository basis.
"""
type CodeIntelligenceConfigurationPolicy implements Node {
    "The ID."
    id: ID!
    "The max age of commits indexed by this configuration policy."
    indexCommitMaxAgeHours: Int
    """
    If the matching Git object is a branch, setting this value to true will also
    index all commits on the matching branches. Setting this value to false will
    only consider the tip of the branch.
    """
    indexIntermediateCommits: Boolean!
    "Whether or not this configuration policy affects auto-indexing schedules."
    indexingEnabled: Boolean!
    "A description of the configuration policy."
    name: String!
    "A pattern matching the name of the matching Git object."
    pattern: String!
    "Protected policies may not be deleted (or created directly by users)."
    protected: Boolean!
    "The repository to which this configuration policy applies."
    repository: Repository
    "The set of name patterns matching repositories to which this configuration policy applies."
    repositoryPatterns: [String!]
    """
    If the matching Git object is a branch, setting this value to true will also
    retain all data used to resolve queries for any commit on the matching branches.
    Setting this value to false will only consider the tip of the branch.
    """
    retainIntermediateCommits: Boolean!
    "The max age of data retained by this configuration policy."
    retentionDurationHours: Int
    "Whether or not this configuration policy affects data retention rules."
    retentionEnabled: Boolean!
    "The type of Git object described by the configuration policy."
    type: GitObjectType!
}

"A list of code intelligence configuration policies."
type CodeIntelligenceConfigurationPolicyConnection {
    "A list of code intelligence configuration policies."
    nodes: [CodeIntelligenceConfigurationPolicy!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of policies in this result set."
    totalCount: Int
}

"Aggregate code intelligence for a particular range within a document."
type CodeIntelligenceRange {
    "A list of definitions of the symbol occurring within the range."
    definitions: LocationConnection!
    "The documentation result of the symbol occurring within the range, if any."
    documentation: Documentation
    "The hover result of the symbol occurring within the range."
    hover: Hover
    "A list of implementations of the symbol occurring within the range."
    implementations: LocationConnection!
    "The range this code intelligence applies to."
    range: Range!
    "A list of references of the symbol occurring within the range."
    references: LocationConnection!
}

"Aggregate local code intelligence for all ranges that fall between a window of lines in a document."
type CodeIntelligenceRangeConnection {
    "Aggregate local code intelligence grouped by range."
    nodes: [CodeIntelligenceRange!]!
}

"A retention policy match candidate."
type CodeIntelligenceRetentionPolicyMatch {
    "The actual retention policy."
    configurationPolicy: CodeIntelligenceConfigurationPolicy
    """
    Whether the retention policy matches the upload or not. False values may be returned
    if non-matching policies are requested for inclusion.
    """
    matches: Boolean!
    """
    A list of commits that are visible to this upload for which this retention policy applies.
    It is empty if the policy applies directly to the commit associated with the upload.
    """
    protectingCommits: [String!]
}

"A list of code intelligence retention policy match candidates."
type CodeIntelligenceRetentionPolicyMatchesConnection {
    "A list of code intelligence retention policies matches."
    nodes: [CodeIntelligenceRetentionPolicyMatch!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of policies in this result set."
    totalCount: Int
}

"A search result that is a Git commit."
type CommitSearchResult implements GenericSearchResultInterface {
    "The commit that matched the search query."
    commit: GitCommit!
    "A markdown string of that is rendered less prominently."
    detail: Markdown!
    "The matching portion of the diff, if any."
    diffPreview: HighlightedString
    "A markdown string that is rendered prominently."
    label: Markdown!
    "The result previews of the result."
    matches: [SearchResultMatch!]!
    "The matching portion of the commit message, if any."
    messagePreview: HighlightedString
    "The ref names of the commit."
    refs: [GitRef!]!
    "The refs by which this commit was reached."
    sourceRefs: [GitRef!]!
    "The URL of the result."
    url: String!
}

"Compute block runs compute queries in a notebook."
type ComputeBlock {
    "An value encoding compute inputs."
    computeInput: String!
    "ID of the block."
    id: String!
}

"""
An entry in match environment is a variable with a value spanning a range. Variable names correspond to
a variable names in a pattern metasyntax. For regular expression patterns, named capture groups will use the variable
specified. For unnamed capture groups, variable names correspond to capture '1', '2', etc.
"""
type ComputeEnvironmentEntry {
    "The absolute range spanned by this value in the input."
    range: Range!
    "The value associated with this variable."
    value: String!
    "The variable name."
    variable: String!
}

"Represents a value matched within file content, and an environment of submatches within this value corresponding to an input pattern (e.g., regular expression capture groups)."
type ComputeMatch {
    "The environment of submatches within value."
    environment: [ComputeEnvironmentEntry]!
    "The range of this value within the file."
    range: Range!
    "The string value"
    value: String!
}

"The result of matching data that satisfy a search pattern, including an environment of submatches."
type ComputeMatchContext {
    "The commit."
    commit: String!
    "Computed match results"
    matches: [ComputeMatch]!
    "The file path."
    path: String!
    "The repository."
    repository: Repository!
}

"A general computed result for arbitrary textual data. A result optionally specifies a related repository, commit, file path, or the kind of textual data."
type ComputeText {
    "The commit."
    commit: String
    "An arbitrary label communicating the kind of data the value represents."
    kind: String
    "The file path."
    path: String
    "The repository."
    repository: Repository
    "The computed value."
    value: String!
}

"DEPRECATED: Use the contents field on the parent type instead. This type will be removed in a future release."
type Configuration {
    """
    DEPRECATED: This field will be removed in a future release.
    The raw JSON contents, encoded as a string.
    """
    contents: JSONCString! @deprecated(reason: "use the contents field on the parent type instead")
    "DEPRECATED: This field is always empty. It will be removed in a future release."
    messages: [String!]! @deprecated(reason: "use client-side JSON Schema validation instead")
}

"DEPRECATED: Renamed to SettingsCascade."
type ConfigurationCascade {
    "DEPRECATED"
    merged: Configuration! @deprecated(reason: "use SettingsCascade.final instead")
    "DEPRECATED"
    subjects: [SettingsSubject!]! @deprecated(reason: "use SettingsCascade.subjects instead")
}

"The result for Mutation.createAccessToken."
type CreateAccessTokenResult {
    "The ID of the newly created access token."
    id: ID!
    """
    The secret token value that is used to authenticate API clients. The caller is responsible for storing this
    value.
    """
    token: String!
}

"The result for Mutation.createUser."
type CreateUserResult {
    """
    The reset password URL that the new user must visit to sign into their account. If the builtin
    username-password authentication provider is not enabled, this field's value is null.
    """
    resetPasswordURL: String
    "The new user."
    user: User!
}

"""
The default settings for the Sourcegraph instance. This is hardcoded in
Sourcegraph, but may change from release to release.
"""
type DefaultSettings implements SettingsSubject {
    "DEPRECATED"
    configurationCascade: ConfigurationCascade!
        @deprecated(
            reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release."
        )
    "The opaque GraphQL ID."
    id: ID!
    "The latest default settings (this never changes)."
    latestSettings: Settings
    """
    The default settings, and the final merged settings.
    All viewers can access this field.
    """
    settingsCascade: SettingsCascade!
    """
    The URL to the default settings. This URL does not exist because you
    cannot edit or directly view default settings.
    """
    settingsURL: String
    """
    Whether the viewer can modify the subject's settings. Always false for
    default settings.
    """
    viewerCanAdminister: Boolean!
}

"Represents a diagnostic, such as a compiler error or warning."
type Diagnostic {
    "The diagnostic's code as provided by the tool."
    code: String
    "The location at which the message applies."
    location: Location!
    "The diagnostic's message."
    message: String
    "The diagnostic's severity."
    severity: DiagnosticSeverity
    """
    A human-readable string describing the source of this
    diagnostic, e.g. "typescript" or "super lint".
    """
    source: String
}

"A list of diagnostics."
type DiagnosticConnection {
    "A list of diagnostics."
    nodes: [Diagnostic!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total count of diagnostics (which may be larger than nodes.length if the connection is paginated)."
    totalCount: Int!
}

"A diff between two diffable Git objects."
type Diff {
    "The revision range of the diff."
    range: GitRevisionRange!
    "The diff's repository."
    repository: Repository!
}

"Statistics about a diff."
type DiffStat {
    "Number of additions."
    added: Int!
    "Number of changes."
    changed: Int!
    "Number of deletions."
    deleted: Int!
}

"Documentation at some position in a file."
type Documentation {
    """
    The path ID of the documentation, which can be used to build a link to the documentation or
    (after trimming the URL hash) passed to documentationPage or documentationPathInfo.
    """
    pathID: String!
}

"Describes a single page of documentation."
type DocumentationPage {
    """
    The tree of documentation nodes describing this page's hierarchy. It is a JSON value because
    GraphQL has terrible support for recursive data structures: https://github.com/graphql/graphql-spec/issues/91

    The exact structure of this value is documented here:
    https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/sourcegraph/sourcegraph%24+type+DocumentationNode+struct&patternType=literal&case=yes
    """
    tree: JSONValue!
}

"A documentation search result."
type DocumentationSearchResult {
    "Markdown detail string (e.g. the full function signature and its docs). See protocol/documentation.go:Documentation"
    detail: String!
    "Markdown label string, e.g. a one-line function signature. See protocol/documentation.go:Documentation"
    label: String!
    "The lowercase language name (go, java, etc.) OR, if unknown, the LSIF indexer name."
    language: String!
    """
    The fully qualified documentation page path ID, e.g. including "#section". See the documentationPage
    type for what this is.
    """
    pathID: String!
    "RepoName is the name of the repository containing this search key."
    repoName: String!
    """
    The search key generated by the indexer, e.g. mux.Router.ServeHTTP. It is language-specific,
    and likely unique within a repository (but not always.) See protocol/documentation.go:Documentation.SearchKey
    """
    searchKey: String!
    "Tags for the documentation node. See protocol/documentation.go:Documentation"
    tags: [String!]!
}

"Search results over documentation."
type DocumentationSearchResults {
    "The results."
    results: [DocumentationSearchResult!]!
}

"Represents a null return value."
type EmptyResponse {
    "A dummy null value."
    alwaysNil: String
}

"""
This type is not returned by any resolver, but serves to document what an error
response will look like.
"""
type Error {
    "Optional additional context on the error."
    extensions: ErrorExtensions
    "A string giving more context about the error that ocurred."
    message: String!
    """
    The GraphQL path to where the error happened. For an error in the query
    query {
    user {
    externalID # This is a nullable field that failed computing.
    }
    }
    the path would be ["user", "externalID"].
    """
    path: [String!]!
}

"""
Optional additional context on an error returned from a resolver.
It may also contain more properties, which aren't strictly typed here.
"""
type ErrorExtensions {
    """
    An error code, which can be asserted on.
    Possible error codes are communicated in the doc string of the field.
    """
    code: String
}

"""
An evaluated feature flag is any feature flag (static or random) that has been evaluated to
a concrete value for a given viewer.
"""
type EvaluatedFeatureFlag {
    "The name of the feature flag"
    name: String!
    "The concrete evaluated value of the feature flag"
    value: Boolean!
}

"A single user event that has been logged."
type EventLog {
    "The randomly generated unique user ID stored in a browser cookie."
    anonymousUserID: String!
    "The additional argument information."
    argument: String
    "The name of the event."
    name: String!
    "The source of the event."
    source: EventSource!
    "The timestamp when the event was logged."
    timestamp: DateTime!
    "The URL when the event was logged."
    url: String!
    "The user who executed the event, if one exists."
    user: User
    "The Sourcegraph version when the event was logged."
    version: String!
}

"A list of event logs."
type EventLogsConnection {
    "A list of event logs."
    nodes: [EventLog!]!
    "Pagination information."
    pageInfo: PageInfo!
    """
    The total count of event logs in the connection. This total count may be larger than the number of nodes
    in this object when the result is paginated.
    """
    totalCount: Int!
}

"A description of a command run inside the executor to during processing of the parent record."
type ExecutionLogEntry {
    "The arguments of the command run inside the executor."
    command: [String!]!
    "The duration in milliseconds of the command. Null, if the command has not finished yet."
    durationMilliseconds: Int
    "The exit code of the command. Null, if the command has not finished yet."
    exitCode: Int
    "An internal tag used to correlate this log entry with other records."
    key: String!
    "The combined stdout and stderr logs of the command."
    out: String!
    "The date when this command started."
    startTime: DateTime!
}

"An active executor compute instance."
type Executor implements Node {
    "Active is true, if a heartbeat from the executor has been received at most three heartbeat intervals ago."
    active: Boolean!
    "The machine architure running the executor."
    architecture: String!
    "The version of Git used by the executor."
    dockerVersion: String!
    "The version of the executor."
    executorVersion: String!
    "The first time the executor sent a heartbeat to the Sourcegraph instance."
    firstSeenAt: DateTime!
    "The version of Docker used by the executor."
    gitVersion: String!
    "The hostname of the executor instance."
    hostname: String!
    "The unique identifier of this executor."
    id: ID!
    "The version of Ignite used by the executor."
    igniteVersion: String!
    "The last time the executor sent a heartbeat to the Sourcegraph instance."
    lastSeenAt: DateTime!
    "The operating system running the executor."
    os: String!
    "The queue name that the executor polls for work."
    queueName: String!
    "The version of src-cli used by the executor."
    srcCliVersion: String!
}

"A list of active executors compute instances."
type ExecutorConnection {
    "A list of executors."
    nodes: [Executor!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of executors in this result set."
    totalCount: Int!
}

"""
A reference to a changeset that already exists on a code host (and was not created by the
batch change).
"""
type ExistingChangesetReference {
    "The repository that contains the existing changeset on the code host."
    baseRepository: Repository!
    """
    The ID that uniquely identifies the existing changeset on the code host.

    For GitHub and Bitbucket Server, this is the pull request number (as a string) in the
    base repository. For example, "1234" for PR 1234.
    """
    externalID: String!
}

"A description of the extension, how to run or access it, and when to activate it."
type ExtensionManifest {
    "The URL to the bundled JavaScript source code for the extension, if any."
    bundleURL: String
    "The description specified in the manifest, if any."
    description: String
    """
    The manifest as JSON (not JSONC, even if the raw manifest is JSONC) with only the
    specified fields. This is useful for callers that only need certain fields and want
    to avoid fetching a large amount of data (because many manifests contain README
    and icon data).
    """
    jsonFields(fields: [String!]!): JSONValue!
    """
    The raw JSON (or JSONC) contents of the manifest. This value may be large (because many
    manifests contain README and icon data), and it is JSONC (not strict JSON), which means
    it must be parsed with a JSON parser that supports trailing commas and comments. Consider
    using jsonFields instead.
    """
    raw: String!
}

"An extension registry."
type ExtensionRegistry {
    """
    Find an extension by its extension ID (which is the concatenation of the publisher name, a slash ("/"), and the
    extension name).
    To find an extension by its GraphQL ID, use Query.node.
    """
    extension(extensionID: String!): RegistryExtension
    "A list of extensions published in the extension registry."
    extensions(
        "Returns only extensions with the given IDs."
        extensionIDs: [String!]
        "Returns the first n extensions from the list."
        first: Int
        "Include extensions from the local registry."
        local: Boolean = true
        "Sorts the list of extension results such that the extensions with these IDs are first in the result set."
        prioritizeExtensionIDs: [String!]
        "Returns only extensions from this publisher."
        publisher: ID
        """
        Returns only extensions matching the query.
        The following keywords are supported:
        - category:"C" - include only extensions in the given category.
        - tag:"T" - include only extensions in the given tag.
        The following keywords are ignored by the server (so that the frontend can post-process the result set to
        implement the keywords):
        - installed - include only installed extensions.
        - enabled - include only enabled extensions.
        - disabled - include only disabled extensions.
        """
        query: String
        "Include extensions from remote registries."
        remote: Boolean = true
    ): RegistryExtensionConnection!
    "A list of featured extensions in the registry."
    featuredExtensions: FeaturedExtensionsConnection
    """
    The extension ID prefix for extensions that are published in the local extension registry. This is the
    hostname (and port, if non-default HTTP/HTTPS) of the Sourcegraph "externalURL" site configuration property.
    It is null if extensions published on this Sourcegraph site do not have an extension ID prefix.
    Examples: "sourcegraph.example.com/", "sourcegraph.example.com:1234/"
    """
    localExtensionIDPrefix: String
    "A list of publishers with at least 1 extension in the registry."
    publishers("Return the first n publishers from the list." first: Int): RegistryPublisherConnection!
    "A list of publishers that the viewer may publish extensions as."
    viewerPublishers: [RegistryPublisher!]!
}

"The result of Mutation.extensionRegistry.createExtension."
type ExtensionRegistryCreateExtensionResult {
    "The newly created extension."
    extension: RegistryExtension!
}

"Mutations for the extension registry."
type ExtensionRegistryMutation {
    "Create a new extension in the extension registry."
    createExtension(
        "The name of the extension."
        name: String!
        "The ID of the extension's publisher (a user or organization)."
        publisher: ID!
    ): ExtensionRegistryCreateExtensionResult!
    """
    Delete an extension from the extension registry.
    Only authorized extension publishers may perform this mutation.
    """
    deleteExtension("The ID of the extension to delete." extension: ID!): EmptyResponse!
    """
    Publish an extension in the extension registry, creating it (if it doesn't yet exist) or updating it (if it
    does).
    This is a helper that wraps multiple other GraphQL mutations to expose a single API for publishing an
    extension.
    """
    publishExtension(
        "The bundled JavaScript source of the extension."
        bundle: String
        """
        The extension ID of the extension to publish. If a host prefix (e.g., "sourcegraph.example.com/") is
        needed and it is not included, it is automatically prepended.
        Examples: "alice/myextension", "acmecorp/myextension"
        """
        extensionID: String!
        "Force publish even if there are warnings (such as invalid JSON warnings)."
        force: Boolean = false
        "The extension manifest (as JSON)."
        manifest: String!
        """
        The source map of the extension's JavaScript bundle, if any.
        The JavaScript bundle's "//# sourceMappingURL=" directive, if any, is ignored. When the bundle is served,
        the source map provided here is referenced instead.
        """
        sourceMap: String
    ): ExtensionRegistryPublishExtensionResult!
    """
    Update an extension in the extension registry.
    Only authorized extension publishers may perform this mutation.
    """
    updateExtension(
        "The extension to update."
        extension: ID!
        "The new name for the extension, or null to leave unchanged."
        name: String
    ): ExtensionRegistryUpdateExtensionResult!
}

"The result of Mutation.extensionRegistry.publishExtension."
type ExtensionRegistryPublishExtensionResult {
    "The extension that was just published."
    extension: RegistryExtension!
}

"The result of Mutation.extensionRegistry.updateExtension."
type ExtensionRegistryUpdateExtensionResult {
    "The newly updated extension."
    extension: RegistryExtension!
}

"An external account associated with a user."
type ExternalAccount implements Node {
    """
    Provider-specific data about the external account.
    Only site admins may query this field.
    """
    accountData: JSONValue
    "An identifier for the external account (typically equal to or derived from the ID on the external service)."
    accountID: String!
    """
    An identifier for the client of the external service where the external account resides. This distinguishes
    among multiple authentication providers that access the same service with different parameters.
    """
    clientID: String!
    "The creation date of this external account on Sourcegraph."
    createdAt: DateTime!
    "The unique ID for the external account."
    id: ID!
    "A URL that, when visited, re-initiates the authentication process."
    refreshURL: String
    "An identifier for the external service where the external account resides."
    serviceID: String!
    "The type of the external service where the external account resides."
    serviceType: String!
    "The last-updated date of this external account on Sourcegraph."
    updatedAt: DateTime!
    "The user on Sourcegraph."
    user: User!
}

"A list of external accounts."
type ExternalAccountConnection {
    "A list of external accounts."
    nodes: [ExternalAccount!]!
    "Pagination information."
    pageInfo: PageInfo!
    """
    The total count of external accounts in the connection. This total count may be larger than the number of nodes
    in this object when the result is paginated.
    """
    totalCount: Int!
}

"A changeset on a code host (e.g., a pull request on GitHub)."
type ExternalChangeset implements Changeset & Node {
    """
    The author of the changeset, or null if the data hasn't been synced from the code host yet,
    or the changeset has not yet been published.
    """
    author: Person
    "The batch changes that contain this changeset."
    batchChanges(
        "Opaque pagination cursor."
        after: String
        "Returns the first n batch changes from the list."
        first: Int = 50
        "Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`."
        state: BatchChangeState
        "Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it."
        states: [BatchChangeState!]
        "Only include batch changes that the viewer can administer."
        viewerCanAdminister: Boolean
    ): BatchChangeConnection!
    "The body of the changeset, or null if the data hasn't been synced from the code host yet."
    body: String
    """
    The state of the checks (e.g., for continuous integration) on this changeset, or null if no
    checks have been configured.
    """
    checkState: ChangesetCheckState
    "The date and time when the changeset was created."
    createdAt: DateTime!
    """
    The current changeset spec for this changeset. Use this to get access to the
    workspace execution that generated this changeset.

    Null if the changeset was only imported.
    """
    currentSpec: VisibleChangesetSpec
    "The diff of this changeset, or null if the changeset is closed (without merging) or is already merged."
    diff: RepositoryComparisonInterface
    """
    The diffstat of this changeset, or null if the changeset is closed
    (without merging) or is already merged. This data is also available
    indirectly through the diff field above, but if only the diffStat is
    required, this field is cheaper to access.
    """
    diffStat: DiffStat
    "An error that has occurred when publishing or updating the changeset. This is only set when the changeset state is ERRORED and the viewer can administer this changeset."
    error: String
    "The events belonging to this changeset."
    events(after: String, first: Int = 50): ChangesetEventConnection!
    """
    The external ID that uniquely identifies this ExternalChangeset on the
    code host. For example, on GitHub this is the pull request number. This is only set once the changeset is published on the code host.
    """
    externalID: String
    "The external state of the changeset, or null when not yet published to the code host."
    externalState: ChangesetExternalState
        @deprecated(reason: "Use state instead. This field is deprecated and will be removed in a future release.")
    "The external URL of the changeset on the code host. Not set when changeset state is UNPUBLISHED, externalState is DELETED, or the changeset's data hasn't been synced yet."
    externalURL: ExternalLink
    """
    If the changeset was opened from a fork, this is the namespace of the fork
    (which will generally correspond to a user or organisation name on the code
    host).
    """
    forkNamespace: String
    "The unique ID for the changeset."
    id: ID!
    "The labels attached to the changeset on the code host."
    labels: [ChangesetLabel!]!
    "The date and time when the next changeset sync is scheduled, or null if none is scheduled or when the initial sync hasn't happened."
    nextSyncAt: DateTime
    "The publication state of the changeset."
    publicationState: ChangesetPublicationState!
        @deprecated(reason: "Use state instead. This field is deprecated and will be removed in a future release.")
    "The reconciler state of the changeset."
    reconcilerState: ChangesetReconcilerState!
        @deprecated(reason: "Use state instead. This field is deprecated and will be removed in a future release.")
    "The repository changed by this changeset."
    repository: Repository!
    "The review state of this changeset. This is only set once the changeset is published on the code host."
    reviewState: ChangesetReviewState
    """
    The time the changeset is expected to be enqueued at. This is an estimate, and may change depending on other code host and Batch Changes activity.

    Null if the changeset is not currently scheduled.
    """
    scheduleEstimateAt: DateTime
    "The state of the changeset."
    state: ChangesetState!
    "An error that has occured during the last sync of the changeset. Null, if was successful."
    syncerError: String
    "The title of the changeset, or null if the data hasn't been synced from the code host yet."
    title: String
    "The date and time when the changeset was updated."
    updatedAt: DateTime!
}

"A URL to a resource on an external service, such as the URL to a repository on its external (origin) code host."
type ExternalLink {
    """
    The kind of external service, such as "GITHUB", or null if unknown/unrecognized. This is used solely for
    displaying an icon that represents the service.
    """
    serviceKind: ExternalServiceKind
    """
    The type of external service, such as "github", or null if unknown/unrecognized. This is used solely for
    displaying an icon that represents the service.
    """
    serviceType: String @deprecated(reason: "use name serviceKind instead")
    "The URL to the resource."
    url: String!
}

"A repository on an external service (such as GitHub, GitLab, Phabricator, etc.)."
type ExternalRepository {
    """
    The repository's ID on the external service.
    Example: For GitHub, this is the GitHub GraphQL API's node ID for the repository.
    """
    id: String!
    """
    The particular instance of the external service where this repository resides. Its value is
    opaque but typically consists of the canonical base URL to the service.
    Example: For GitHub.com, this is "https://github.com/".
    """
    serviceID: String!
    """
    The type of external service where this repository resides.
    Example: "github", "gitlab", etc.
    """
    serviceType: String!
}

"A configured external service."
type ExternalService implements Node {
    "The JSON configuration of the external service."
    config: JSONCString!
    "When the external service was created."
    createdAt: DateTime!
    "The display name of the external service."
    displayName: String!
    """
    Returns a list of scopes granted by the code host. It is based on the token used
    when configuring the external service.
    NOTE: Currently only GitHub is supported and the request consumes rate limit tokens
    so it should be used sparingly.
    """
    grantedScopes: [String!]
    "The external service's unique ID."
    id: ID!
    """
    EXPERIMENTAL: Collaborators who can be invited to Sourcegraph. This typically comes from a few
    repositories included by this external service, and is derived from commit history (because that
    for example gives more accurate collaborator work email addresses than the contributors API which
    often returns personal emails.

    Importantly, this API works when repositories are not cloned on Sourcegraph yet so as to allow
    inviting collaborators while repositories are cloning.

    In general, this API should NOT be used once repositories are cloned on to Sourcegraph as it
    reaches out to the code host directly which is wasteful if repositories are already cloned.
    """
    invitableCollaborators: [Person!]!
    "The kind of external service."
    kind: ExternalServiceKind!
    """
    LastSyncAt is the time the last sync job was run for this code host. Null if it
    has never been synced so far.
    """
    lastSyncAt: DateTime
    """
    External services are synced with code hosts in the background. This optional field
    will contain any errors that occured during the most recent completed sync.
    """
    lastSyncError: String
    "The namespace this external service belongs to."
    namespace: Namespace
    "The timestamp of the next sync job. Null if not scheduled for a re-sync."
    nextSyncAt: DateTime
    "The number of repos synced by the external service."
    repoCount: Int!
    "When the external service was last updated."
    updatedAt: DateTime!
    """
    This is an optional field that's populated when we ran into errors on the
    backend side when trying to create/update an ExternalService, but the
    create/update still succeeded.
    It is a field on ExternalService instead of a separate thing in order to
    not break the API and stay backwards compatible.
    """
    warning: String
    """
    Returns recently received webhooks on this external service.

    Only site admins may access this field.
    """
    webhookLogs(
        "Opaque pagination cursor."
        after: String
        "Returns the first n webhook logs."
        first: Int
        "Only include webhook logs that resulted in errors."
        onlyErrors: Boolean
        "Only include webhook logs on or after this time."
        since: DateTime
        "Only include webhook logs on or before this time."
        until: DateTime
    ): WebhookLogConnection!
    "An optional URL that will be populated when webhooks have been configured for the external service."
    webhookURL: String
}

"A list of external services."
type ExternalServiceConnection {
    "A list of external services."
    nodes: [ExternalService!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of external services in the connection."
    totalCount: Int!
}

"""
FOR INTERNAL USE ONLY: A status message produced when repositories could not
be synced from an external service
"""
type ExternalServiceSyncError {
    "The external service that failed to sync"
    externalService: ExternalService!
    "The message of this status message"
    message: String!
}

"A feature flag that has a statically configured value"
type FeatureFlagBoolean {
    "The name of the feature flag"
    name: String!
    "Overrides that apply to the feature flag"
    overrides: [FeatureFlagOverride!]!
    "The static value of the feature flag"
    value: Boolean!
}

"A feature flag override is an override of a feature flag's value for a specific org or user"
type FeatureFlagOverride {
    "A unique ID for this feature flag override"
    id: ID!
    "The namespace for this override. Will always be a user or org."
    namespace: Namespace!
    "The name of the feature flag being overridden"
    targetFlag: FeatureFlag!
    "The overriden value of the feature flag"
    value: Boolean!
}

"A feature flag that is randomly evaluated to a boolean based on the rollout parameter"
type FeatureFlagRollout {
    "The name of the feature flag"
    name: String!
    "Overrides that apply to the feature flag"
    overrides: [FeatureFlagOverride!]!
    """
    The ratio of users that will be assigned this this feature flag, expressed in
    basis points (0.01%).
    """
    rolloutBasisPoints: Int!
}

"A list of featured extensions in the registry."
type FeaturedExtensionsConnection {
    """
    Errors that occurred while communicating with remote registries to obtain the list of extensions.
    In order to be able to return local extensions even when the remote registry is unreachable, errors are
    recorded here instead of in the top-level GraphQL errors list.
    """
    error: String
    "A list of featured registry extensions."
    nodes: [RegistryExtension!]!
}

"File is temporarily preserved for backcompat with browser extension search API client code."
type File {
    "Whether this is a directory."
    isDirectory: Boolean!
    "The base name (i.e., file name only) of this file's path."
    name: String!
    "The full path (relative to the repository root) of this file."
    path: String!
    "The repository that contains this file."
    repository: Repository!
    "The URL to this file on Sourcegraph."
    url: String!
}

"FileBlock specifies a file (or part of a file) to display within the block."
type FileBlock {
    "File block input."
    fileInput: FileBlockInput!
    "ID of the block."
    id: String!
}

"FileBlockInput contains the information necessary to fetch the file."
type FileBlockInput {
    "Path within the repository, e.g. \"client/web/file.tsx\"."
    filePath: String!
    "An optional line range. If omitted, we display the entire file."
    lineRange: FileBlockLineRange
    "Name of the repository, e.g. \"github.com/sourcegraph/sourcegraph\"."
    repositoryName: String!
    """
    An optional revision, e.g. "pr/feature-1", "a9505a2947d3df53558e8c88ff8bcef390fc4e3e".
    If omitted, we use the latest revision (HEAD).
    """
    revision: String
}

"A line range inside a file."
type FileBlockLineRange {
    "The last line to fetch (0-indexed, exclusive)."
    endLine: Int!
    "The first line to fetch (0-indexed, inclusive)."
    startLine: Int!
}

"A diff for a single file."
type FileDiff {
    "Hunks that were changed from old to new."
    hunks: [FileDiffHunk!]!
    """
    FOR INTERNAL USE ONLY.
    An identifier for the file diff that is unique among all other file diffs in the list that
    contains it.
    """
    internalID: String!
    """
    The old file (if the file was deleted) and otherwise the new file. This file field is typically used by
    clients that want to show a "View" link to the file.
    """
    mostRelevantFile: File2!
    "The new file, or null if the file was deleted (newFile.path == newPath)."
    newFile: File2
    "The new (changed) path of the file, or null if the file was deleted."
    newPath: String
    "The old file, or null if the file was created (oldFile.path == oldPath)."
    oldFile: File2
    "The old (original) path of the file, or null if the file was added."
    oldPath: String
    "The diff stat for the whole file."
    stat: DiffStat!
}

"A list of file diffs."
type FileDiffConnection {
    """
    The diff stat for the file diffs in this object, which may be a subset of the entire diff if the result is
    paginated.
    """
    diffStat: DiffStat!
    "A list of file diffs."
    nodes: [FileDiff!]!
    "Pagination information."
    pageInfo: PageInfo!
    """
    The raw diff for the file diffs in this object, which may be a subset of the entire diff if the result is
    paginated.
    """
    rawDiff: String!
    """
    The total count of file diffs in the connection, if available. This total count may be larger than the number
    of nodes in this object when the result is paginated.
    """
    totalCount: Int
}

"A changed region (\"hunk\") in a file diff."
type FileDiffHunk {
    "The hunk body, with lines prefixed with '-', '+', or ' '."
    body: String!
    "Highlight the hunk."
    highlight(
        disableTimeout: Boolean!
        """
        If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.
        2000 bytes is enabled. This may produce a significant amount of HTML
        which some browsers (such as Chrome, but not Firefox) may have trouble
        rendering efficiently.
        """
        highlightLongLines: Boolean = false
        isLightTheme: Boolean
    ): HighlightedDiffHunkBody!
    "The range of the new file that the hunk applies to."
    newRange: FileDiffHunkRange!
    "Whether the old file had a trailing newline."
    oldNoNewlineAt: Boolean!
    "The range of the old file that the hunk applies to."
    oldRange: FileDiffHunkRange!
    "The diff hunk section heading, if any."
    section: String
}

"A hunk range in one side (old/new) of a diff."
type FileDiffHunkRange {
    "The number of lines that the hunk applies to."
    lines: Int!
    "The first line that the hunk applies to."
    startLine: Int!
}

"A file match."
type FileMatch {
    """
    The file containing the match.
    KNOWN ISSUE: This file's "commit" field contains incomplete data.
    KNOWN ISSUE: This field's type should be File! not GitBlob!.
    """
    file: GitBlob!
    "Whether or not the limit was hit."
    limitHit: Boolean!
    "The line matches."
    lineMatches: [LineMatch!]!
    "The repository containing the file match."
    repository: Repository!
    """
    The revspec of the revision that contains this match. If no revspec was given (such as when no
    repository filter or revspec is specified in the search query), it is null.
    """
    revSpec: GitRevSpec
    "The symbols found in this file that match the query."
    symbols: [Symbol!]!
}

"""
The target repository that a changeset will be pushed to, if it's not the origin
repository.
"""
type ForkTarget {
    "The specific named fork that the changeset will be pushed to."
    namespace: String
    """
    True if the remote target is a fork in the user namespace associated with
    the credential used to push the changeset.
    """
    pushUser: Boolean!
}

"A Git blob in a repository."
type GitBlob implements File2 & TreeEntry {
    "Whether or not it is binary."
    binary: Boolean!
    "Blame the blob."
    blame(endLine: Int!, startLine: Int!): [Hunk!]!
    "The file size in bytes."
    byteSize: Int!
    "The canonical URL to this blob (using an immutable revision specifier)."
    canonicalURL: String!
    "Provides info on the level of code-intel support for this git blob."
    codeIntelSupport: CodeIntelSupport!
    "The Git commit containing this blob."
    commit: GitCommit!
    "The content of this blob."
    content: String!
    "The URLs to this blob on its repository's external services."
    externalURLs: [ExternalLink!]!
    "Highlight the blob contents."
    highlight(
        disableTimeout: Boolean!
        """
        If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.
        2000 bytes is enabled. This may produce a significant amount of HTML
        which some browsers (such as Chrome, but not Firefox) may have trouble
        rendering efficiently.
        """
        highlightLongLines: Boolean = false
        isLightTheme: Boolean
    ): HighlightedFile!
    "False because this is a blob (file), not a directory."
    isDirectory: Boolean!
    "Always false, since a blob is a file, not directory."
    isSingleChild(
        "Returns the first n files in the tree."
        first: Int
        "Recurse into sub-trees."
        recursive: Boolean = false
        "Recurse into sub-trees of single-child directories"
        recursiveSingleChild: Boolean = false
    ): Boolean!
    """
    Provides code intelligence within the file.

    Experimental: This API is likely to change in the future.
    """
    localCodeIntel: JSONValue
    """
    A wrapper around LSIF query methods. If no LSIF upload can be used to answer code
    intelligence queries for this path-at-revision, this resolves to null.
    """
    lsif("An optional filter for the name of the tool that produced the upload data." toolName: String): GitBlobLSIFData
    "The base name (i.e., file name only) of this blob's path."
    name: String!
    "The full path (relative to the repository root) of this blob."
    path: String!
    "The repository containing this Git blob."
    repository: Repository!
    """
    The blob contents rendered as rich HTML, or an empty string if it is not a supported
    rich file type.
    This HTML string is already escaped and thus is always safe to render.
    """
    richHTML: String!
    "Submodule metadata if this tree points to a submodule"
    submodule: Submodule
    "(Experimental) Symbol defined in this blob at the specfic line number and character offset."
    symbol(
        "The character offset (0-based). The offset is measured in characters, not bytes."
        character: Int!
        "The line number (0-based)."
        line: Int!
    ): Symbol
    "Symbols defined in this blob."
    symbols(
        "Returns the first n symbols from the list."
        first: Int
        "Return symbols matching the query."
        query: String
    ): SymbolConnection!
    "The URL to this blob (using the input revision specifier, which may not be immutable)."
    url: String!
}

"""
A wrapper object around LSIF query methods for a particular git-blob-at-revision. When this node is
null, no LSIF data is available for the git blob in question.
"""
type GitBlobLSIFData implements TreeEntryLSIFData {
    "A list of definitions of the symbol under the given document position."
    definitions(
        "The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive)."
        character: Int!
        "When specified, it filters references by filename."
        filter: String
        "The line on which the symbol occurs (zero-based, inclusive)."
        line: Int!
    ): LocationConnection!
    "Code diagnostics provided through LSIF."
    diagnostics(first: Int): DiagnosticConnection!
    "The documentation of the symbol under the given document position, if any."
    documentation(
        "The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive)."
        character: Int!
        "The line on which the symbol occurs (zero-based, inclusive)."
        line: Int!
    ): Documentation
    "A list of definitions of the symbol described by the given documentation path ID, if any."
    documentationDefinitions(pathID: String!): LocationConnection!
    """
    Returns the documentation page corresponding to the given path ID, where the path ID "/"
    refers to the current git blob and can be used to walk all documentation below this git blob.

    Currently this method is only supported on the root git blob of a repository.

    A pathID refers to all the structured documentation slugs emitted by the LSIF indexer joined together
    with a slash, starting at the slug corresponding to this git blob filepath. A pathID and filepath may
    sometimes look similar, but are not equal. Some examples include:

    * A documentation page under filepath `internal/pkg/mux` with pathID `/Router/ServeHTTP/examples`.
    * A documentation page under filepath `/` (repository root) with pathID `/internal/pkg/mux/Router/ServeHTTP/examples`

    In other words, a path ID is said to be the path to the page, relative to the git blob
    filepath.

    The components of the pathID are chosen solely by the LSIF indexer, and may vary over time or
    even dynamically based on e.g. project size. The same is true of pages, e.g. an LSIF indexer
    may choose to create new pages if an API surface exceeds some threshold size.
    """
    documentationPage(pathID: String!): DocumentationPage!
    """
    Returns the documentation pth info corresponding to the given path ID, where the empty string "/"
    refers to the current tree entry and can be used to walk all documentation below this tree entry.

    Currently this method is only supported on the root tree entry of a repository.

    See @documentationPage for information about what a pathID refers to.

    This method is optimal for e.g. walking the entire documentation path structure of a repository,
    whereas documentationPage would require you to fetch the content for all pages you walk (not true
    of path info.)

    If maxDepth is specified, pages will be recursively returned up to that depth. Default max depth
    is one (immediate child pages only.)

    If ignoreIndex is true, empty index pages (pages whose only purpose is to describe pages below
    them) will not qualify as a page in relation to the maxDepth property: index pages will be
    recursively followed and included until a page with actual content is found, and only then will
    the depth be considered to increment. Default is false.

    This returns a JSON value because GraphQL has terrible support for recursive data structures: https://github.com/graphql/graphql-spec/issues/91

    The exact structure of the return value is documented here:
    https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/sourcegraph/sourcegraph%24+type+DocumentationPathInfoResult+struct&patternType=literal&case=yes
    """
    documentationPathInfo(ignoreIndex: Boolean, maxDepth: Int, pathID: String!): JSONValue!
    "A list of references of the symbol under the given document position."
    documentationReferences(
        """
        When specified, indicates that this request should be paginated and
        to fetch results starting at this cursor.
        A future request can be made for more results by passing in the
        'LocationConnection.pageInfo.endCursor' that is returned.
        """
        after: String
        """
        When specified, indicates that this request should be paginated and
        the first N results (relative to the cursor) should be returned. i.e.
        how many results to return per page.
        """
        first: Int
        "The documentation path ID, e.g. from the documentationPage return value."
        pathID: String!
    ): LocationConnection!
    "The hover result of the symbol under the given document position."
    hover(
        "The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive)."
        character: Int!
        "The line on which the symbol occurs (zero-based, inclusive)."
        line: Int!
    ): Hover
    "A list of implementations of the symbol under the given document position."
    implementations(
        """
        When specified, indicates that this request should be paginated and
        to fetch results starting at this cursor.
        A future request can be made for more results by passing in the
        'LocationConnection.pageInfo.endCursor' that is returned.
        """
        after: String
        "The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive)."
        character: Int!
        "When specified, it filters immplementations by filename."
        filter: String
        """
        When specified, indicates that this request should be paginated and
        the first N results (relative to the cursor) should be returned. i.e.
        how many results to return per page.
        """
        first: Int
        "The line on which the symbol occurs (zero-based, inclusive)."
        line: Int!
    ): LocationConnection!
    "The list of LSIF uploads that may be used to service code-intel requests for this GitBlob."
    lsifUploads: [LSIFUpload!]!
    """
    Get aggregated local code intelligence for all ranges that fall in the window
    indicated by the given zero-based start (inclusive) and end (exclusive) lines.
    The associated data for each range is "local", in that the locations and hover
    must also be defined in the same index as the source range. To get cross-repository
    and cross-bundle results, you must query the definitions, references, and hovers
    of that range explicitly.
    """
    ranges(endLine: Int!, startLine: Int!): CodeIntelligenceRangeConnection
    "A list of references of the symbol under the given document position."
    references(
        """
        When specified, indicates that this request should be paginated and
        to fetch results starting at this cursor.
        A future request can be made for more results by passing in the
        'LocationConnection.pageInfo.endCursor' that is returned.
        """
        after: String
        "The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive)."
        character: Int!
        "When specified, it filters references by filename."
        filter: String
        """
        When specified, indicates that this request should be paginated and
        the first N results (relative to the cursor) should be returned. i.e.
        how many results to return per page.
        """
        first: Int
        "The line on which the symbol occurs (zero-based, inclusive)."
        line: Int!
    ): LocationConnection!
    "Return a flat list of all ranges in the document that have code intelligence."
    stencil: [Range!]!
}

"""
A description of a changeset that represents the proposal to merge one branch into another.
This is used to describe a pull request (on GitHub and Bitbucket Server).
"""
type GitBranchChangesetDescription {
    """
    The full name of the Git ref in the base repository that this changeset is based on (and is
    proposing to be merged into). This ref must exist on the base repository. For example,
    "refs/heads/master" or "refs/heads/main".
    """
    baseRef: String!
    "The repository that this changeset spec is proposing to change."
    baseRepository: Repository!
    """
    The base revision this changeset is based on. It is the latest commit in
    baseRef at the time when the changeset spec was created.
    For example: "4095572721c6234cd72013fd49dff4fb48f0f8a4"
    """
    baseRev: String!
    """
    The body of the changeset on the code host.

    On Bitbucket Server or GitHub this is the body/description of the pull request.
    """
    body: String!
    """
    The Git commits with the proposed changes. These commits are pushed to the head ref.

    Only 1 commit is supported.
    """
    commits: [GitCommitDescription!]!
    "The total diff of the changeset diff."
    diff: PreviewRepositoryComparison!
    """
    The diffstat of this changeset spec. This data is also available
    indirectly through the diff field above, but if only the diffStat is
    required, this field is cheaper to access.
    """
    diffStat: DiffStat!
    """
    The full name of the Git ref that holds the changes proposed by this changeset. This ref will
    be created or updated with the commits. For example, "refs/heads/fix-foo" (for
    the Git branch "fix-foo").
    """
    headRef: String!
    "The repository that contains the branch with this changeset's changes."
    headRepository: Repository!
        @deprecated(
            reason: "Unused. Sourcegraph does not populate a full repository when creating a changeset on a fork. Use VisibleChangesetSpec.fork or ExternalChangeset.forkNamespace instead."
        )
    """
    Whether or not the changeset described here should be created right after
    applying the ChangesetSpec this description belongs to.

    If this is false, the changeset will only be created on Sourcegraph and
    can be previewed.

    Another ChangesetSpec with the same description, but "published: true",
    can later be applied to publish the changeset.
    """
    published: PublishedValue
    """
    The title of the changeset on the code host.

    On Bitbucket Server or GitHub this is the title of the pull request.
    """
    title: String!
}

"A Git commit."
type GitCommit implements Node {
    "The abbreviated form of this commit's OID."
    abbreviatedOID: String!
    "The log of commits consisting of this commit and its ancestors."
    ancestors(
        "Return commits more recent than the specified date."
        after: String
        "Returns the first n commits from the list."
        first: Int
        "Return commits that affect the path."
        path: String
        "Return commits that match the query."
        query: String
    ): GitCommitConnection!
    "This commit's author."
    author: Signature!
    "Returns the number of commits that this commit is behind and ahead of revspec."
    behindAhead(revspec: String!): BehindAheadCounts!
    "The Git blob in this commit at the given path."
    blob(path: String!): GitBlob
    "The contents of the commit message after the first line."
    body: String
    "The canonical URL to this commit (using an immutable revision specifier)."
    canonicalURL: String!
    "This commit's committer, if any."
    committer: Signature
    "The URLs to this commit on its repository's external services."
    externalURLs: [ExternalLink!]!
    """
    The file at the given path for this commit.
    See "File" documentation for the difference between this field and the "blob" field.
    """
    file(path: String!): File2
    "A list of file names in this repository."
    fileNames: [String!]!
    "The globally addressable ID for this commit."
    id: ID!
    "List statistics for each language present in the repository."
    languageStatistics: [LanguageStatistics!]!
    "Lists the programming languages present in the tree at this commit."
    languages: [String!]!
    "The full commit message."
    message: String!
    "This commit's Git object ID (OID), a 40-character SHA-1 hash."
    oid: GitObjectID!
    "Parent commits of this commit."
    parents: [GitCommit!]!
    "The Git tree or blob in this commit at the given path."
    path("The path of the tree or blob." path: String = ""): GitTreeOrBlob
    "The repository that contains this commit."
    repository: Repository!
    "The first line of the commit message."
    subject: String!
    "Symbols defined as of this commit. (All symbols, not just symbols that were newly defined in this commit.)"
    symbols(
        "Returns the first n symbols from the list."
        first: Int
        """
        A list of regular expressions, all of which must match all
        file paths returned in the list.
        """
        includePatterns: [String!]
        "Return symbols matching the query."
        query: String
    ): SymbolConnection!
    "The Git tree in this commit at the given path."
    tree(
        "The path of the tree."
        path: String = ""
        """
        Whether to recurse into sub-trees. If true, it overrides the value of the "recursive" parameter on all of
        GitTree's fields.
        DEPRECATED: Use the "recursive" parameter on GitTree's fields instead.
        """
        recursive: Boolean = false
    ): GitTree
    "The URL to this commit (using the input revision specifier, which may not be immutable)."
    url: String!
}

"A list of Git commits."
type GitCommitConnection {
    "A list of Git commits."
    nodes: [GitCommit!]!
    "Pagination information."
    pageInfo: PageInfo!
    """
    The total number of Git commits in the connection. If the GitCommitConnection is paginated
    (e.g., because a "first" parameter was provided to the field that produced it), this field is
    null to avoid it taking unexpectedly long to compute the total count. Remove the pagination
    parameters to obtain a non-null value for this field.
    """
    totalCount: Int
}

"A description of a Git commit."
type GitCommitDescription {
    "The Git commit author."
    author: Person!
    "The contents of the commit message after the first line."
    body: String
    """
    The commit diff (in unified diff format).

    The filenames must not be prefixed (e.g., with 'a/' and 'b/'). Tip: use 'git diff --no-prefix'
    to omit the prefix.
    """
    diff: String!
    "The full commit message."
    message: String!
    "The first line of the commit message."
    subject: String!
}

"A Git object."
type GitObject {
    "The abbreviated form of this object's OID."
    abbreviatedOID: String!
    "The commit object, if it is a commit and it exists; otherwise null."
    commit: GitCommit
    "This object's OID."
    oid: GitObjectID!
    "The Git object's type."
    type: GitObjectType!
}

"""
A git object that matches a git object type and glob pattern. This type is used by
the UI to preview what names match a code intelligence policy in a given repository.
"""
type GitObjectFilterPreview {
    "The relevant branch or tag name."
    name: String!
    "The full 40-char revhash."
    rev: String!
}

"A Git ref."
type GitRef implements Node {
    "An unambiguous short name for the ref."
    abbrevName: String!
    """
    The display name of the ref. For branches ("refs/heads/foo"), this is the branch
    name ("foo").
    As a special case, for GitHub pull request refs of the form refs/pull/NUMBER/head,
    this is "NUMBER".
    """
    displayName: String!
    "The globally addressable ID for the Git ref."
    id: ID!
    "The full ref name (e.g., \"refs/heads/mybranch\" or \"refs/tags/mytag\")."
    name: String!
    """
    The prefix of the ref, either "", "refs/", "refs/heads/", "refs/pull/", or
    "refs/tags/". This prefix is always a prefix of the ref's name.
    """
    prefix: String!
    "The associated repository."
    repository: Repository!
    "The object that the ref points to."
    target: GitObject!
    "The type of this Git ref."
    type: GitRefType!
    "The URL to this Git ref."
    url: String!
}

"A list of Git refs."
type GitRefConnection {
    "A list of Git refs."
    nodes: [GitRef!]!
    "Pagination information."
    pageInfo: PageInfo!
    """
    The total count of Git refs in the connection. This total count may be larger
    than the number of nodes in this object when the result is paginated.
    """
    totalCount: Int!
}

"A Git revspec expression that (possibly) resolves to a Git revision."
type GitRevSpecExpr {
    "The original Git revspec expression."
    expr: String!
    "The Git object that the revspec resolves to, or null otherwise."
    object: GitObject
}

"""
A Git revision range of the form "base..head" or "base...head". Other revision
range formats are not supported.
"""
type GitRevisionRange {
    "The base (left-hand side) of the range."
    base: GitRevSpec!
    "The base's revspec as an expression."
    baseRevSpec: GitRevSpecExpr!
    "The Git revision range expression of the form \"base..head\" or \"base...head\"."
    expr: String!
    "The head (right-hand side) of the range."
    head: GitRevSpec!
    "The head's revspec as an expression."
    headRevSpec: GitRevSpecExpr!
    """
    The merge-base of the base and head revisions, if this is a "base...head"
    revision range. If this is a "base..head" revision range, then this field is null.
    """
    mergeBase: GitObject
}

"A Git tree in a repository."
type GitTree implements TreeEntry {
    "The canonical URL to this tree (using an immutable revision specifier)."
    canonicalURL: String!
    "Provides info on the level of code-intel support for the direct children of this git tree."
    codeIntelInfo: GitTreeCodeIntelInfo
    "The Git commit containing this tree."
    commit: GitCommit!
    "A list of directories in this tree."
    directories(
        "Returns the first n files in the tree."
        first: Int
        "Recurse into sub-trees."
        recursive: Boolean = false
    ): [GitTree!]!
    "A list of entries in this tree."
    entries(
        "Returns the first n files in the tree."
        first: Int
        "Recurse into sub-trees. If true, implies recursiveSingleChild."
        recursive: Boolean = false
        """
        Recurse into sub-trees of single-child directories. If true, we return a flat list of
        every directory that is a single child, and any directories or files that are
        nested in a single child.
        """
        recursiveSingleChild: Boolean = false
    ): [TreeEntry!]!
    "The URLs to this tree on external services."
    externalURLs: [ExternalLink!]!
    "A list of files in this tree."
    files(
        "Returns the first n files in the tree."
        first: Int
        "Recurse into sub-trees."
        recursive: Boolean = false
    ): [File!]!
    """
    True because this is a directory. (The value differs for other TreeEntry interface implementations, such as
    File.)
    """
    isDirectory: Boolean!
    "Whether this tree is the root (top-level) tree."
    isRoot: Boolean!
    "Whether this tree entry is a single child"
    isSingleChild(
        "Returns the first n files in the tree."
        first: Int
        "Recurse into sub-trees."
        recursive: Boolean = false
        "Recurse into sub-trees of single-child directories"
        recursiveSingleChild: Boolean = false
    ): Boolean!
    "LSIF data for this tree entry."
    lsif("An optional filter for the name of the tool that produced the upload data." toolName: String): GitTreeLSIFData
    "The base name (i.e., last path component only) of this tree."
    name: String!
    "The full path (relative to the root) of this tree."
    path: String!
    "The URL to this entry's raw contents as a Zip archive."
    rawZipArchiveURL: String!
    "The repository containing this tree."
    repository: Repository!
    "Submodule metadata if this tree points to a submodule"
    submodule: Submodule
    "Symbols defined in this tree."
    symbols(
        "Returns the first n symbols from the list."
        first: Int
        "Return symbols matching the query."
        query: String
    ): SymbolConnection!
    "The URL to this tree (using the input revision specifier, which may not be immutable)."
    url: String!
}

"Details code-intel support for a group of files rooted at a tree."
type GitTreeCodeIntelInfo {
    """
    Precise coverage based on inference derived from the directory
    structure and its files.
    """
    preciseSupport: [GitTreePreciseCoverage!]
    "Search-based coverage grouped by language."
    searchBasedSupport: [GitTreeSearchBasedCoverage!]
}

"""
A wrapper object around LSIF query methods for a particular git-tree-at-revision. When this node is
null, no LSIF data is available for the git tree in question.
"""
type GitTreeLSIFData implements TreeEntryLSIFData {
    "Code diagnostics provided through LSIF."
    diagnostics(first: Int): DiagnosticConnection!
    "A list of definitions of the symbol described by the given documentation path ID, if any."
    documentationDefinitions(pathID: String!): LocationConnection!
    """
    Returns the documentation page corresponding to the given path ID, where the empty string "/"
    refers to the current tree entry and can be used to walk all documentation below this tree entry.

    Currently this method is only supported on the root tree entry of a repository.

    A pathID refers to all the structured documentation slugs emitted by the LSIF indexer joined together
    with a slash, starting at the slug corresponding to this tree entry filepath. A pathID and filepath may
    sometimes look similar, but are not equal. Some examples include:

    * A documentation page under filepath `internal/pkg/mux` with pathID `/Router/ServeHTTP/examples`.
    * A documentation page under filepath `/` (repository root) with pathID `/internal/pkg/mux/Router/ServeHTTP/examples`

    In other words, a path ID is said to be the path to the page, relative to the tree entry
    filepath.

    The components of the pathID are chosen solely by the LSIF indexer, and may vary over time or
    even dynamically based on e.g. project size. The same is true of pages, e.g. an LSIF indexer
    may choose to create new pages if an API surface exceeds some threshold size.
    """
    documentationPage(pathID: String!): DocumentationPage!
    """
    Returns the documentation pth info corresponding to the given path ID, where the empty string "/"
    refers to the current tree entry and can be used to walk all documentation below this tree entry.

    Currently this method is only supported on the root tree entry of a repository.

    See @documentationPage for information about what a pathID refers to.

    This method is optimal for e.g. walking the entire documentation path structure of a repository,
    whereas documentationPage would require you to fetch the content for all pages you walk (not true
    of path info.)

    If maxDepth is specified, pages will be recursively returned up to that depth. Default max depth
    is one (immediate child pages only.)

    If ignoreIndex is true, empty index pages (pages whose only purpose is to describe pages below
    them) will not qualify as a page in relation to the maxDepth property: index pages will be
    recursively followed and included until a page with actual content is found, and only then will
    the depth be considered to increment. Default is false.

    This returns a JSON value because GraphQL has terrible support for recursive data structures: https://github.com/graphql/graphql-spec/issues/91

    The exact structure of the return value is documented here:
    https://sourcegraph.com/search?q=repo:%5Egithub%5C.com/sourcegraph/sourcegraph%24+type+DocumentationPathInfoResult+struct&patternType=literal&case=yes
    """
    documentationPathInfo(ignoreIndex: Boolean, maxDepth: Int, pathID: String!): JSONValue!
    "A list of references of the symbol under the given document position."
    documentationReferences(
        """
        When specified, indicates that this request should be paginated and
        to fetch results starting at this cursor.
        A future request can be made for more results by passing in the
        'LocationConnection.pageInfo.endCursor' that is returned.
        """
        after: String
        """
        When specified, indicates that this request should be paginated and
        the first N results (relative to the cursor) should be returned. i.e.
        how many results to return per page.
        """
        first: Int
        "The documentation path ID, e.g. from the documentationPage return value."
        pathID: String!
    ): LocationConnection!
    "The list of LSIF uploads that may be used to service code-intel requests for this TreeEntry."
    lsifUploads: [LSIFUpload!]!
}

"""
Precise code-intel support coverage grouped by LSIF indexer language
support for a group of files.
"""
type GitTreePreciseCoverage {
    "Level of confidence in the inference of an indexing target suggestion."
    confidence: InferedPreciseSupportLevel!
    "Overview of the level of support for this group of files."
    support: PreciseCodeIntelSupport!
}

"Search-based code-intel support coverage grouped by related files."
type GitTreeSearchBasedCoverage {
    """
    The files comprising this grouping of search-based support.
    Each grouping consists of all the files of the same langauge e.g.
    all .go files in one group, all .kt and .kts files in another.
    """
    coveredPaths: [String!]!
    "Overview of the level of support for this group of files."
    support: SearchBasedCodeIntelSupport!
}

"A preview entry where no changeset existed before matching the changeset spec."
type HiddenApplyPreviewTargetsAttach {
    "The changeset spec from this entry."
    changesetSpec: HiddenChangesetSpec!
}

"""
A preview entry where no changeset spec exists for the changeset currently in
the target batch change.
"""
type HiddenApplyPreviewTargetsDetach {
    "The changeset from this entry."
    changeset: HiddenExternalChangeset!
}

"A preview entry where a changeset matches the changeset spec."
type HiddenApplyPreviewTargetsUpdate {
    "The changeset from this entry."
    changeset: HiddenExternalChangeset!
    "The changeset spec from this entry."
    changesetSpec: HiddenChangesetSpec!
}

"""
One preview entry in the list of all previews against a batch spec. Each mapping
between changeset specs and current changesets yields one of these. It describes
which operations are taken against which changeset spec and changeset to ensure the
desired state is met.
"""
type HiddenChangesetApplyPreview {
    """
    The delta between the current changeset state and what the new changeset spec
    envisions the changeset to look like.
    """
    delta: ChangesetSpecDelta!
    "The operations to take to achieve the desired state."
    operations: [ChangesetSpecOperation!]!
    "The target entities in this preview entry."
    targets: HiddenApplyPreviewTargets!
}

"""
A changeset spec is an immutable description of the desired state of a changeset in a batch change. To
create a changeset spec, use the createChangesetSpec mutation.
"""
type HiddenChangesetSpec implements ChangesetSpec & Node {
    """
    The date, if any, when this changeset spec expires and is automatically purged. A changeset
    spec never expires (and this field is null) if its batch spec has been applied.
    """
    expiresAt: DateTime
    """
    The unique ID for a changeset spec.

    The ID is unguessable (i.e., long and randomly generated, not sequential). This is important
    even though repository permissions also apply to viewers of changeset specs, because being
    allowed to view a repository should not entitle a person to view all not-yet-published
    changesets for that repository. Consider a batch change to fix a security vulnerability: the
    batch change author may prefer to prepare all of the changesets in private so that the window
    between revealing the problem and merging the fixes is as short as possible.
    """
    id: ID!
    "The type of changeset spec."
    type: ChangesetSpecType!
}

"A changeset on a code host that the user does not have access to."
type HiddenExternalChangeset implements Changeset & Node {
    "The batch changes that contain this changeset."
    batchChanges(
        "Opaque pagination cursor."
        after: String
        "Returns the first n batch changes from the list."
        first: Int = 50
        "Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`."
        state: BatchChangeState
        "Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it."
        states: [BatchChangeState!]
        "Only include batch changes that the viewer can administer."
        viewerCanAdminister: Boolean
    ): BatchChangeConnection!
    "The date and time when the changeset was created."
    createdAt: DateTime!
    "The external state of the changeset, or null when not yet published to the code host."
    externalState: ChangesetExternalState
        @deprecated(reason: "Use state instead. This field is deprecated and will be removed in a future release.")
    "The unique ID for the changeset."
    id: ID!
    "The date and time when the next changeset sync is scheduled, or null if none is scheduled."
    nextSyncAt: DateTime
    "The publication state of the changeset."
    publicationState: ChangesetPublicationState!
        @deprecated(reason: "Use state instead. This field is deprecated and will be removed in a future release.")
    "The reconciler state of the changeset."
    reconcilerState: ChangesetReconcilerState!
        @deprecated(reason: "Use state instead. This field is deprecated and will be removed in a future release.")
    "The state of the changeset."
    state: ChangesetState!
    "The date and time when the changeset was updated."
    updatedAt: DateTime!
}

"A highlighted region in a string (e.g., matched by a query)."
type Highlight {
    "The 1-indexed character on the line."
    character: Int!
    "The length of the highlight, in characters (on the same line)."
    length: Int!
    "The 1-indexed line number."
    line: Int!
}

"A highlighted hunk, consisting of all its lines."
type HighlightedDiffHunkBody {
    "Whether highlighting was aborted."
    aborted: Boolean!
    "The highlighted lines."
    lines: [HighlightedDiffHunkLine!]!
}

"A single highlighted line, including the kind of line."
type HighlightedDiffHunkLine {
    "The HTML containing the syntax-highlighted line of code."
    html: String!
    """
    The operation that happened on this line, in patches it is prefixed with '+', '-', ' '.
    Can be either add, delete, or no change.
    """
    kind: DiffHunkLineType!
}

"A highlighted file."
type HighlightedFile {
    "Whether or not it was aborted."
    aborted: Boolean!
    "The HTML table that can be used to display the highlighted file."
    html: String!
    """
    A list of the desired line ranges. Each list is a list of lines, where each element is an HTML
    table row '<tr>...</tr>' string. This is useful if you only need to display specific subsets of
    the file.
    """
    lineRanges(ranges: [HighlightLineRange!]!): [[String!]!]!
    "Base64 encoded JSON payload of LSIF Typed with syntax highlighting data."
    lsif: String!
}

"A string that has highlights (e.g, query matches)."
type HighlightedString {
    "Highlighted matches of the query in the preview string."
    highlights: [Highlight!]!
    "The full contents of the string."
    value: String!
}

"Hover range and markdown content."
type Hover {
    "A markdown string containing the contents of the hover."
    markdown: Markdown!
    "The range to highlight."
    range: Range!
}

"A hunk."
type Hunk {
    "The author."
    author: Signature!
    "The commit that contains the hunk."
    commit: GitCommit!
    "The endByte."
    endByte: Int!
    "The endLine."
    endLine: Int!
    """
    The original filename at the commit. Use this filename if you're reading the
    text contents of the file at the `commit` field of this hunk. The file may
    have been renamed after the commit so name of file where this hunk got computed
    may not exist.
    """
    filename: String!
    "The message."
    message: String!
    "The rev."
    rev: String!
    "The startByte."
    startByte: Int!
    "The startLine."
    startLine: Int!
}

"Explicit configuration for indexing a repository."
type IndexConfiguration {
    "The raw JSON-encoded index configuration."
    configuration: String
    "The raw JSON-encoded index configuration as infered by the auto-indexer."
    inferredConfiguration: String
}

"The configuration and execution summary of the indexer."
type IndexStep {
    "The arguments to supply to the indexer container."
    indexerArgs: [String!]!
    "The execution summary (if completed or errored) of the index command."
    logEntry: ExecutionLogEntry
    "The path to the index file relative to the root directory (dump.lsif by default)."
    outfile: String
}

"Configuration and execution summary of an index job."
type IndexSteps {
    "Configuration and execution summary (if completed or errored) of the indexer."
    index: IndexStep!
    "Configuration and execution summary (if completed or errored) of steps to be performed prior to indexing."
    preIndex: [PreIndexStep!]!
    "Execution log entries related to setting up the indexing workspace."
    setup: [ExecutionLogEntry!]!
    "Execution log entries related to tearing down the indexing workspace."
    teardown: [ExecutionLogEntry!]!
    """
    Execution log entry related to uploading the dump produced by the indexing step.
    This field be missing if the upload step had not been executed.
    """
    upload: ExecutionLogEntry
}

"""
FOR INTERNAL USE ONLY: A status message produced when repositories could not
be indexed
"""
type IndexingError {
    "The message of this status message"
    message: String!
}

"FOR INTERNAL USE ONLY: A status message produced when repositories are being indexed"
type IndexingProgress {
    "The message of this status message"
    message: String!
}

"An insight about code."
type Insight {
    "The description of the insight."
    description: String!
    "Unique identifier for this insight."
    id: String!
    "Data points over a time range (inclusive)"
    series: [InsightsSeries!]!
    "The short title of the insight."
    title: String!
}

"A list of insights."
type InsightConnection {
    "A list of insights."
    nodes: [Insight!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of insights in the connection."
    totalCount: Int!
}

"A code insight data point."
type InsightDataPoint {
    "The time of this data point."
    dateTime: DateTime!
    "The value of the insight at this point in time."
    value: Float!
}

"An insight query that has been marked dirty (some form of partially or wholly unsuccessful state)."
type InsightDirtyQueryMetadata {
    "The number of dirty queries for this data point and reason combination."
    count: Int!
    "The reason the query was marked dirty."
    reason: String!
    "The time in the data series that is marked dirty."
    time: DateTime!
}

"Defines a time scope using an interval of time"
type InsightIntervalTimeScope {
    "The unit of time."
    unit: TimeIntervalStepUnit!
    "The value of time."
    value: Int!
}

"A custom repository scope for an insight. A scope with all empty fields implies a global scope."
type InsightRepositoryScope {
    "The list of repositories in the scope."
    repositories: [String!]!
}

"Metadata about a specific data series for an insight."
type InsightSeriesMetadata {
    "Current status of the series."
    enabled: Boolean!
    "Sourcegraph query string used to generate the series."
    query: String!
    "Unique ID for the series."
    seriesId: String!
}

"Wrapper payload object for insight series metadata."
type InsightSeriesMetadataPayload {
    "The series metadata."
    series: InsightSeriesMetadata!
}

"Information about queue status for insight series queries."
type InsightSeriesQueryStatus {
    """
    The number of queries belonging to the series that are successfully completed.
    This count only represents the queries that have yet to be pruned by the background maintenance workers.
    """
    completed: Int!
    "The current activity status for this series."
    enabled: Boolean!
    """
    The number of queries belonging to the series with errored status. Errored is a transient state representing a retryable error that has not
    yet exceeded the max retry count. This count only represents the queries that have yet to be pruned by the background maintenance workers.
    """
    errored: Int!
    """
    The number of queries belonging to the series that are terminally failed. These have either been marked as non-retryable or exceeded
    the max retry limit. This count only represents the queries that have yet to be pruned by the background maintenance workers.
    """
    failed: Int!
    """
    The number of queries belonging to the series that are currently processing.
    This count only represents the queries that have yet to be pruned by the background maintenance workers.
    """
    processing: Int!
    """
    Sourcegraph query string used to generate the series. This is the base query string that was input by the user,
    and does not include each repository specific query that would be generated to backfill an entire series.
    """
    query: String!
    """
    The number of queries belonging to the series that are queued for processing.
    This count only represents the queries that have yet to be pruned by the background maintenance workers.
    """
    queued: Int!
    "Unique ID for the series."
    seriesId: String!
}

"Status indicators for a specific series of insight data."
type InsightSeriesStatus {
    """
    The time that the insight series completed a full iteration and queued up records for processing. This can
    effectively be used as a status that the insight is still processing if returned null.
    """
    backfillQueuedAt: DateTime
    """
    The total number of jobs completed for this series. Note that since pendingJobs will
    go up/down over time, you CANNOT divide these two numbers to get a percentage as it
    would be nonsense ("it says 90% complete but has been like that for a really long
    time!").

    Does not include 'failedJobs'.

    Why its useful: gives an indication of "how much work has been done?"
    """
    completedJobs: Int!
    """
    The total number of jobs that were tried multiple times and outright failed. They will
    not be retried again, and indicates the series has incomplete data.

    Use ((failedJobs / completedJobs) * 100.0) to get an approximate percentage of how
    much data the series data may be missing (e.g. ((30 / 150)*100.0) == 20% of the series
    data is incomplete (rough approximation, not precise).

    Why its useful: signals if there are problems, and how severe they are.
    """
    failedJobs: Int!
    """
    The total number of jobs currently pending to add new data points for this series.

    Each job may create multiple data points (e.g. a job may create one data point per
    repo, or language, etc.) This number will go up and down over time until all work
    is completed (discovering work takes almost as long as doing the work.)

    Why its useful: signals "amount of work still to be done."
    """
    pendingJobs: Int!
    """
    The total number of points stored for this series, at the finest level
    (e.g. per repository, or per-repository-per-language) Has no strict relation
    to the data points shown in the web UI or returned by `points()`, because those
    are aggregated and this number _can_ report some duplicates points which get
    stored but removed at query time for the web UI.

    Why its useful: an insight may look like "it is doing nothing" but in reality
    this number will be increasing by e.g. several thousands of points rapidly.
    """
    totalPoints: Int!
}

"An Insight View is a lens to view insight data series. In most cases this corresponds to a visualization of an insight, containing multiple series."
type InsightView implements Node {
    "The filters currently applied to the insight and the data."
    appliedFilters: InsightViewFilters!
    "The total number of dashboards on which this insight is referenced. The count is global and disregards permissions."
    dashboardReferenceCount: Int!
    "The time series data for this insight."
    dataSeries: [InsightsSeries!]!
    "Information on how each data series was generated"
    dataSeriesDefinitions: [InsightDataSeriesDefinition!]!
    "The default filters saved on the insight. This will differ from the applied filters if they are overwritten but not saved."
    defaultFilters: InsightViewFilters!
    "The View ID."
    id: ID!
    "Represents if this insight is in a frozen state or not. A frozen state is relevant when a license is downgraded and the number of insights exceed the free plan limits."
    isFrozen: Boolean!
    "Presentation options for the insight."
    presentation: InsightPresentation!
}

"A dashboard of insight views."
type InsightViewConnection {
    "A list of insights."
    nodes: [InsightView!]!
    "Pagination information."
    pageInfo: PageInfo!
}

"The fields and values for which the insight is filtered."
type InsightViewFilters {
    "A regex string for which to exclude repositories from a filter."
    excludeRepoRegex: String
    "A regex string for which to include repositories in a filter."
    includeRepoRegex: String
}

"Response wrapper object for insight view mutations."
type InsightViewPayload {
    "The resulting view."
    view: InsightView!
}

"A dashboard of insights."
type InsightsDashboard implements Node {
    "The permission grants assossiated with the dashboard."
    grants: InsightsPermissionGrants!
    "The Dashboard ID."
    id: ID!
    "The Dashboard Title."
    title: String!
    "The list of associated insights to the dashboard."
    views(after: ID, first: Int): InsightViewConnection
}

"A paginated list of dashboards."
type InsightsDashboardConnection {
    "A list of dashboards."
    nodes: [InsightsDashboard!]!
    "Pagination information."
    pageInfo: PageInfo!
}

"Response wrapper object for insight dashboard mutations."
type InsightsDashboardPayload {
    "The result dashboard after mutation."
    dashboard: InsightsDashboard!
}

"Permissions object. Note: only organizations the user has access to will be included."
type InsightsPermissionGrants {
    "True if the permission is set to global."
    global: Boolean!
    "Organizations that have permission."
    organizations: [ID!]!
    "Specific users that have permission."
    users: [ID!]!
}

"A series of data about a code insight."
type InsightsSeries {
    "Metadata for any data points that are flagged as dirty due to partially or wholly unsuccessfully queries."
    dirtyMetadata: [InsightDirtyQueryMetadata!]!
    "The label used to describe this series of data points."
    label: String!
    """
    Data points over a time range (inclusive)

    If no 'from' time range is specified, the last 90 days of data is assumed.

    If no 'to' time range is specified, the current point in time is assumed.

    includeRepoRegex will include in the aggregation any repository names that match the provided regex

    excludeRepoRegex will exclude in the aggregation any repository names that match the provided regex
    """
    points(excludeRepoRegex: String, from: DateTime, includeRepoRegex: String, to: DateTime): [InsightDataPoint!]!
    "Unique ID for the series."
    seriesId: String!
    "The status of this series of data, e.g. progress collecting it."
    status: InsightSeriesStatus!
}

"The result of Mutation.inviteUserToOrganization."
type InviteUserToOrganizationResult {
    "The URL that the invited user can visit to accept or reject the invitation."
    invitationURL: String!
    """
    Whether an invitation email was sent. If emails are not enabled on this site or if the user has no verified
    email address, an email will not be sent.
    """
    sentInvitationEmail: Boolean!
}

"Metadata and status about an LSIF index."
type LSIFIndex implements Node {
    "The LSIF upload created as part of this indexing job."
    associatedUpload: LSIFUpload
    "The processing error message (not set if state is not ERRORED)."
    failure: String
    "The time the index completed or errored."
    finishedAt: DateTime
    "The ID."
    id: ID!
    "The indexer used to produce the index artifact."
    indexer: CodeIntelIndexer
    "The original 40-character commit commit supplied at index time."
    inputCommit: String!
    "The name of the target indexer Docker image (e.g., sourcegraph/lsif-go@sha256:...)."
    inputIndexer: String!
    "The original root supplied at index schedule time."
    inputRoot: String!
    "The rank of this index in the queue. The value of this field is null if the index has been processed."
    placeInQueue: Int
    "The project for which this upload provides code intelligence."
    projectRoot: GitTree
    "The time the index was queued."
    queuedAt: DateTime!
    "The time the index was processed."
    startedAt: DateTime
    "The index's current state."
    state: LSIFIndexState!
    "The configuration and execution summary (if completed or errored) of this index job."
    steps: IndexSteps!
}

"A list of LSIF indexes."
type LSIFIndexConnection {
    "A list of LSIF indexes."
    nodes: [LSIFIndex!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of indexes in this result set."
    totalCount: Int
}

"A group of indexes that share the same root and indexer values."
type LSIFIndexesWithRepositoryNamespace {
    "The configured indexer of each index in the associated connection."
    indexer: CodeIntelIndexer!
    "A list of indexes."
    indexes: [LSIFIndex!]!
    "The root of all indexes in the associated connection."
    root: String!
}

"Metadata and status about an LSIF upload."
type LSIFUpload implements Node {
    "The LSIF indexing job that created this upload record."
    associatedIndex: LSIFIndex
    "The processing error message (not set if state is not ERRORED)."
    failure: String
    "The time the upload completed or errored."
    finishedAt: DateTime
    "The ID."
    id: ID!
    "The indexer used to produce this index."
    indexer: CodeIntelIndexer
    "The original 40-character commit commit supplied at upload time."
    inputCommit: String!
    "The original indexer name supplied at upload time."
    inputIndexer: String!
    "The original root supplied at upload time."
    inputRoot: String!
    """
    Whether or not this upload provides intelligence for the tip of the default branch. Find reference
    queries will return symbols from remote repositories only when this property is true. This property
    is updated asynchronously and is eventually consistent with the git data known by the Sourcegraph
    instance.
    """
    isLatestForRepo: Boolean!
    "The rank of this upload in the queue. The value of this field is null if the upload has been processed."
    placeInQueue: Int
    "The project for which this upload provides code intelligence."
    projectRoot: GitTree
    """
    The list of retention policies, optionally filtered by only ones that match/apply to this upload and/or
    by name substring match.
    """
    retentionPolicyOverview(
        """
        When specified, indicates that this request should be paginated and
        to fetch results starting at this cursor.
        A future request can be made for more results by passing in the
        'CodeIntelligenceRetentionPolicyMatchesConnection.pageInfo.endCursor' that is returned.
        """
        after: String
        """
        When specified, indicates that this request should be paginated and
        the first N results (relative to the cursor) should be returned. i.e.
        how many results to return per page.
        """
        first: Int
        matchesOnly: Boolean!
        "An (optional) search query that searches over the name property."
        query: String
    ): CodeIntelligenceRetentionPolicyMatchesConnection!
    "The time the upload was processed."
    startedAt: DateTime
    "The upload's current state."
    state: LSIFUploadState!
    "The time the upload was uploaded."
    uploadedAt: DateTime!
}

"A list of LSIF uploads."
type LSIFUploadConnection {
    "A list of LSIF uploads."
    nodes: [LSIFUpload!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of uploads in this result set."
    totalCount: Int
}

"A group of uploads that share the same root and indexer values."
type LSIFUploadsWithRepositoryNamespace {
    "The indexer used to produce the each upload in the associated connection."
    indexer: CodeIntelIndexer!
    "The root of all uploads in the associated connection."
    root: String!
    "A list of uploads."
    uploads: [LSIFUpload!]!
}

"A programming language."
type Language {
    "Name of the programming language."
    name: String!
}

"Statistics about a language's usage."
type LanguageStatistics {
    "The name of the language."
    name: String!
    "The total bytes in the language."
    totalBytes: Float!
    "The total number of lines in the language."
    totalLines: Int!
}

"View presentation for a single insight line chart data series"
type LineChartDataSeriesPresentation {
    "The color for the series."
    color: String!
    "The label for the series."
    label: String!
    "Unique ID for the series."
    seriesId: String!
}

"View presentation for a line chart insight"
type LineChartInsightViewPresentation {
    "The presentation options for the line chart."
    seriesPresentation: [LineChartDataSeriesPresentation!]!
    "The title for the line chart."
    title: String!
}

"A line match."
type LineMatch {
    "Whether or not the limit was hit."
    limitHit: Boolean! @deprecated(reason: "will always be false")
    """
    The line number. 0-based. The first line will have lineNumber 0. Note: A
    UI will normally display line numbers 1-based.
    """
    lineNumber: Int!
    "Tuples of [offset, length] measured in characters (not bytes)."
    offsetAndLengths: [[Int!]!]!
    "The preview."
    preview: String!
}

"A location inside a resource (in a repository at a specific commit)."
type Location {
    "The canonical URL to this location (using an immutable revision specifier)."
    canonicalURL: String!
    "The range inside the file that this location refers to."
    range: Range
    "The file that this location refers to."
    resource: GitBlob!
    "The URL to this location (using the input revision specifier, which may not be immutable)."
    url: String!
}

"A list of locations within a file."
type LocationConnection {
    "A list of locations within a file."
    nodes: [Location!]!
    "Pagination information."
    pageInfo: PageInfo!
}

"An object representing a markdown string."
type Markdown {
    """
    HTML for the rendered markdown string, or null if there is no HTML representation provided.
    If specified, clients should render this directly.
    """
    html: String!
    "The raw markdown string."
    text: String!
}

"Markdown block renders the Markdown formatted input string into HTML."
type MarkdownBlock {
    "ID of the block."
    id: String!
    "Markdown formatted input string."
    markdownInput: String!
}

"""
Information and status about the mirroring of a repository. In this case, the remote source repository
is external to Sourcegraph and the mirror is maintained by the Sourcegraph site (not the other way
around).
"""
type MirrorRepositoryInfo {
    "Whether the clone of the repository has begun but not yet completed."
    cloneInProgress: Boolean!
    """
    A single line of text that contains progress information for the running clone command.
    The format of the progress text is not specified.
    It is intended to be displayed directly to a user.
    e.g.
    "Receiving objects:  95% (2041/2148), 292.01 KiB | 515.00 KiB/s"
    "Resolving deltas:   9% (117/1263)"
    """
    cloneProgress: String
    "Whether the repository has ever been successfully cloned."
    cloned: Boolean!
    "The URL of the remote source repository."
    remoteURL: String!
    "The state of this repository in the update queue."
    updateQueue: UpdateQueue
    "The state of this repository in the update schedule."
    updateSchedule: UpdateSchedule
    "When the repository was last successfully updated from the remote source repository.."
    updatedAt: DateTime
}

"A code monitor with one trigger and possibly many actions."
type Monitor implements Node {
    "One or more actions that are triggered by the trigger."
    actions(
        "Opaque pagination cursor."
        after: String
        "Returns the first n actions from the list."
        first: Int = 50
    ): MonitorActionConnection!
    "The time at which the code monitor was created."
    createdAt: DateTime!
    "The user who created the code monitor."
    createdBy: User!
    "A meaningful description of the code monitor."
    description: String!
    "Whether the code monitor is currently enabled."
    enabled: Boolean!
    "The code monitor's unique ID."
    id: ID!
    "Owners can edit the code monitor."
    owner: Namespace!
    "Triggers trigger actions. There can only be one trigger per monitor."
    trigger: MonitorTrigger!
}

"A list of actions."
type MonitorActionConnection {
    "A list of actions."
    nodes: [MonitorAction!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of actions in the connection."
    totalCount: Int!
}

"A list of events."
type MonitorActionEmailRecipientsConnection {
    "A list of recipients."
    nodes: [Namespace!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of recipients in the connection."
    totalCount: Int!
}

"An event documents the result of a trigger or an execution of an action."
type MonitorActionEvent implements Node {
    "The unique id of an event."
    id: ID!
    "A message with details regarding the status of the event."
    message: String
    "The status of an event."
    status: EventStatus!
    "The time and date of the event."
    timestamp: DateTime!
}

"A list of events."
type MonitorActionEventConnection {
    "A list of events."
    nodes: [MonitorActionEvent!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of events in the connection."
    totalCount: Int!
}

"A list of code monitors"
type MonitorConnection {
    "A list of monitors."
    nodes: [Monitor!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of monitors in the connection."
    totalCount: Int!
}

"Email is one of the supported actions of code monitors."
type MonitorEmail implements Node {
    "Whether the email action is enabled or not."
    enabled: Boolean!
    "A list of events."
    events(
        "Opaque pagination cursor."
        after: String
        "Returns the first n events from the list."
        first: Int = 50
    ): MonitorActionEventConnection!
    "Use header to automatically approve the message in a read-only or moderated mailing list."
    header: String!
    "The unique id of an email action."
    id: ID!
    "Whether to include the result contents in the email message"
    includeResults: Boolean!
    "The priority of the email action."
    priority: MonitorEmailPriority!
    "A list of recipients of the email."
    recipients(
        "Opaque pagination cursor."
        after: String
        "Returns the first n recipients from the list."
        first: Int = 50
    ): MonitorActionEmailRecipientsConnection!
}

"A query that can serve as a trigger for code monitors."
type MonitorQuery implements Node {
    "A list of events."
    events(
        "Opaque pagination cursor."
        after: String
        "Returns the first n events from the list."
        first: Int = 50
    ): MonitorTriggerEventConnection!
    "The unique id of a trigger query."
    id: ID!
    "A query."
    query: String!
}

"SlackWebhook is one of the supported actions of code monitors."
type MonitorSlackWebhook implements Node {
    "Whether the Slack webhook action is enabled or not."
    enabled: Boolean!
    "A list of events."
    events(
        "Opaque pagination cursor."
        after: String
        "Returns the first n events from the list."
        first: Int = 50
    ): MonitorActionEventConnection!
    "The unique id of an Slack webhook action."
    id: ID!
    "Whether to include the result contents in Slack notification message."
    includeResults: Boolean!
    "The endpoint the Slack webhook event will be sent to"
    url: String!
}

"A trigger event is an event together with a list of associated actions."
type MonitorTriggerEvent implements Node {
    "A list of actions."
    actions(
        "Opaque pagination cursor."
        after: String
        "Returns the first n events from the list."
        first: Int = 50
    ): MonitorActionConnection!
    "The unique id of an event."
    id: ID!
    "A message with details regarding the status of the event."
    message: String
    """
    The query (with after filter) that provides an approximation of the
    set of results associated with this trigger run. Will always be empty
    while status is PENDING.
    """
    query: String
    """
    The number of results recorded for this trigger run. Will always be
    zero until status is SUCCESS.
    """
    resultCount: Int!
    "The status of an event."
    status: EventStatus!
    "The time and date of the event."
    timestamp: DateTime!
}

"A list of trigger events."
type MonitorTriggerEventConnection {
    "A list of events."
    nodes: [MonitorTriggerEvent!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of events in the connection."
    totalCount: Int!
}

"Webhook is one of the supported actions of code monitors."
type MonitorWebhook implements Node {
    "Whether the webhook action is enabled or not."
    enabled: Boolean!
    "A list of events."
    events(
        "Opaque pagination cursor."
        after: String
        "Returns the first n events from the list."
        first: Int = 50
    ): MonitorActionEventConnection!
    "The unique id of a webhook action."
    id: ID!
    "Whether to include the result contents in webhook payload."
    includeResults: Boolean!
    "The endpoint the webhook event will be sent to"
    url: String!
}

"A high-level monitoring alert, for details see https://docs.sourcegraph.com/admin/observability/metrics#high-level-alerting-metrics"
type MonitoringAlert {
    """
    Average percentage of time (between [0, 1]) that the event was firing over the 12h of recorded data. e.g.
    1.0 if it was firing 100% of the time on average during that 12h window, 0.5 if it was firing 50% of the
    time on average, etc.
    """
    average: Float!
    "Name of alert that the service fired."
    name: String!
    "Owner of the fired alert."
    owner: String!
    "Name of the service that fired the alert."
    serviceName: String!
    "End time of this event, which describes the past 12h of recorded data."
    timestamp: DateTime!
}

"Monitoring overview."
type MonitoringStatistics {
    "Alerts fired in this time span."
    alerts: [MonitoringAlert!]!
}

"A mutation."
type Mutation {
    """
    Updates an out-of-band migration to run in a particular direction.

    Applied in the forward direction, an out-of-band migration migrates data into a format that
    is readable by newer Sourcegraph instances. This may be destructive or non-destructive process,
    depending on the nature and implementation of the migration.

    Applied in the reverse direction, an out-of-band migration ensures that data is moved back into
    a format that is readable by the previous Sourcegraph instance. Recently introduced migrations
    should be applied in reverse prior to downgrading the instance.
    """
    SetMigrationDirection(applyReverse: Boolean!, id: ID!): EmptyResponse!
    """
    SetUserPublicRepos sets the list of public repos for a user's search context, ensuring those repos
    exist and are cloned
    """
    SetUserPublicRepos(repoURIs: [String!]!, userID: ID!): EmptyResponse!
    "Adds a external service. Only site admins may perform this mutation."
    addExternalService(input: AddExternalServiceInput!): ExternalService!
    "Associate an existing insight view with this dashboard."
    addInsightViewToDashboard(input: AddInsightViewToDashboardInput!): InsightsDashboardPayload!
    """
    Collects the stats users enter when accessing organizations open beta on Cloud

    Only authenticated users are able to perform this operation.

    Only possible to execute on Cloud deployment.
    """
    addOrgsOpenBetaStats(stats: JSONCString!): ID
    "Adds a Phabricator repository to Sourcegraph."
    addPhabricatorRepo(
        "The callsign, for example \"MUX\"."
        callsign: String!
        "The name, for example \"github.com/gorilla/mux\"."
        name: String
        "An alias for name. DEPRECATED: use name instead."
        uri: String
        "The URL to the phabricator instance (e.g. http://phabricator.sgdev.org)."
        url: String!
    ): EmptyResponse
    """
    Adds an email address to the user's account. The email address will be marked as unverified until the user
    has followed the email verification process.

    Only the user and site admins may perform this mutation.
    """
    addUserEmail(email: String!, user: ID!): EmptyResponse!
    """
    Immediately add a user as a member to the organization, without sending an invitation email.

    Only site admins may perform this mutation. Organization members may use the inviteUserToOrganization
    mutation to invite users.
    """
    addUserToOrganization(organization: ID!, username: String!): EmptyResponse!
    """
    Create or update a batch change from a batch spec and locally computed changeset specs. If no
    batch change exists in the namespace with the name given in the batch spec, a batch change will be
    created. Otherwise, the existing batch change will be updated. The batch change is returned.
    Closed batch changes cannot be applied to. In that case, an error with the error code ErrApplyClosedbatch change
    will be returned.
    """
    applyBatchChange(
        """
        The batch spec that describes the new desired state of the batch change.
        It must be in COMPLETED state.
        """
        batchSpec: ID!
        """
        If set, return an error if the batch change identified using the namespace and batch changeSpec
        parameters does not match the batch change with this ID. This lets callers use a stable ID
        that refers to a specific batch change during an edit session (and is not susceptible to
        conflicts if the underlying batch change is moved to a different namespace, renamed, or
        deleted). The returned error has the error code ErrEnsureBatchChangeFailed.
        """
        ensureBatchChange: ID
        """
        If set, these changeset specs will have their UI publication states set
        to the given values. This will overwrite any existing UI publication
        states on the changesets.

        An error will be returned if the same changeset spec ID is included
        more than once in the array, or if a changeset spec ID is included with
        a publication state set in its spec.
        """
        publicationStates: [ChangesetSpecPublicationStateInput!]
    ): BatchChange!
    """
    Attempts to cancel the execution of the given batch spec. All workspace jobs
    that are QUEUED or PROCESSING will be cancelled. The execution must not have completed yet.
    """
    cancelBatchSpecExecution(batchSpec: ID!): BatchSpec!
    """
    Cancel a single workspace execution. Mostly useful in the "try out" UI, but
    can also be used at later stages. Must be in PROCESSING or QUEUED state.
    """
    cancelBatchSpecWorkspaceExecution(batchSpecWorkspaces: [ID!]!): EmptyResponse!
    """
    Tests the connection to a mirror repository's original source repository. This is an
    expensive and slow operation, so it should only be used for interactive diagnostics.

    Only site admins may perform this mutation.
    """
    checkMirrorRepositoryConnection(
        """
        The name of a repository whose mirror to check. If the name is provided, the repository need not be added
        to the site (but the site configuration must define a code host that knows how to handle the name).
        """
        name: String
        "The ID of the existing repository whose mirror to check."
        repository: ID
    ): CheckMirrorRepositoryConnectionResult!
    "Close a batch change."
    closeBatchChange(
        batchChange: ID!
        """
        Whether to close the changesets associated with this batch change on their respective code
        hosts. "Close" means the appropriate final state on the code host (e.g., "closed" on
        GitHub and "declined" on Bitbucket Server).
        """
        closeChangesets: Boolean = false
    ): BatchChange!
    """
    Close multiple changesets.

    Experimental: This API is likely to change in the future.
    """
    closeChangesets(batchChange: ID!, changesets: [ID!]!): BulkOperation!
    """
    DEPRECATED: Use settingsMutation instead. This field is a deprecated alias for settingsMutation and will be
    removed in a future release.
    """
    configurationMutation(input: SettingsMutationGroupInput!): SettingsMutation
        @deprecated(reason: "use settingsMutation instead")
    """
    Creates an access token that grants the privileges of the specified user (referred to as the access token's
    "subject" user after token creation). The result is the access token value, which the caller is responsible
    for storing (it is not accessible by Sourcegraph after creation).

    The supported scopes are:

    - "user:all": Full control of all resources accessible to the user account.
    - "site-admin:sudo": Ability to perform any action as any other user. (Only site admins may create tokens
    with this scope.)

    Only the user or site admins may perform this mutation.
    """
    createAccessToken(note: String!, scopes: [String!]!, user: ID!): CreateAccessTokenResult!
    """
    Create a batch change from a batch spec and locally computed changeset specs. The newly created
    batch change is returned.
    If a batch change in the same namespace with the same name already exists,
    an error with the error code ErrMatchingBatchChangeExists is returned.
    """
    createBatchChange(
        """
        The batch spec that describes the desired state of the batch change.
        It must be in COMPLETED state.
        """
        batchSpec: ID!
        """
        If set, these changeset specs will have their UI publication states set
        to the given values.

        An error will be returned if the same changeset spec ID is included
        more than once in the array, or if a changeset spec ID is included with
        a publication state set in its spec.
        """
        publicationStates: [ChangesetSpecPublicationStateInput!]
    ): BatchChange!
    """
    Create a new credential for the given user for the given code host.
    If another token for that code host already exists, an error with the error code
    ErrDuplicateCredential is returned.
    """
    createBatchChangesCredential(
        "The credential to be stored. This can never be retrieved through the API and will be stored encrypted."
        credential: String!
        "The kind of external service being configured."
        externalServiceKind: ExternalServiceKind!
        "The URL of the external service being configured."
        externalServiceURL: String!
        "The user for which to create the credential. If null is provided, a site-wide credential is created."
        user: ID
    ): BatchChangesCredential!
    """
    Create a batch spec that will be used to create a batch change (with the createBatchChange
    mutation), or to update an existing batch change (with the applyBatchChange mutation).

    The returned BatchSpec is immutable and expires after a certain period of time (if not used
    in a call to applyBatchChange), which can be queried on BatchSpec.expiresAt.

    If batch changes are unlicensed and the number of changesetSpecIDs is higher than what's allowed in
    the free tier, an error with the error code ErrBatchChangesUnlicensed is returned.
    """
    createBatchSpec(
        """
        The batch spec as YAML (or the equivalent JSON). See
        https://sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/schema/batch_spec.schema.json
        for the JSON Schema that describes the structure of this input.
        """
        batchSpec: String!
        "Changeset specs that were locally computed and then uploaded using createChangesetSpec."
        changesetSpecs: [ID!]!
        """
        The namespace (either a user or organization). A batch spec can only be applied to (or
        used to create) batch changes in this namespace.
        """
        namespace: ID!
    ): BatchSpec!
    """
    Creates a batch spec and triggers a job to evaluate the workspaces. Consumers need to
    poll the batch spec until the resolution is completed to get a full list of all
    workspaces. This might become streaming so the results will come in over time.

    This mutation should be used when updating an existing batch change whose previous
    batch spec was already applied. When the previous batch spec was not yet applied, you
    can use `replaceBatchSpecInput` instead.
    """
    createBatchSpecFromRaw(
        "If true, repos with a .batchignore file will still be included."
        allowIgnored: Boolean = false
        """
        If true, repos on unsupported codehosts will be included. Resulting changesets in these repos cannot
        be published.
        """
        allowUnsupported: Boolean = false
        """
        The raw batch spec as YAML (or the equivalent JSON). See
        https://sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/schema/batch_spec.schema.json
        for the JSON Schema that describes the structure of this input.
        """
        batchSpec: String!
        """
        Right away set the execute flag.

        TODO: Not implemented yet.
        """
        execute: Boolean = false
        """
        The namespace (either a user or organization). A batch spec can only be applied to (or
        used to create) batch changes in this namespace.
        """
        namespace: ID!
        """
        Don't use cache entries.

        TODO: Not implemented yet.
        """
        noCache: Boolean = false
    ): BatchSpec!
    """
    Comment on multiple changesets from a batch change.

    Experimental: This API is likely to change in the future.
    """
    createChangesetComments(batchChange: ID!, body: String!, changesets: [ID!]!): BulkOperation!
    """
    Upload a changeset spec that will be used in a future update to a batch change. The changeset spec
    is stored and can be referenced by its ID in the applyBatchChange mutation. Just uploading the
    changeset spec does not result in changes to the batch change or any of its changesets; you need
    to call applyBatchChange to use it.

    You can use this mutation to upload large changeset specs (e.g., containing large diffs) in
    individual HTTP requests. Then, in the eventual applyBatchChange call, you just refer to the
    changeset specs by their IDs. This lets you avoid problems when updating large batch changes where
    a large HTTP request body (e.g., with many large diffs in the changeset specs) would be
    rejected by the web server/proxy or would be very slow.

    The returned ChangesetSpec is immutable and expires after a certain period of time (if not
    used in a call to applyBatchChange), which can be queried on ChangesetSpec.expiresAt.
    """
    createChangesetSpec(
        """
        The raw changeset spec (as JSON). See
        https://sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/schema/changeset_spec.schema.json
        for the JSON Schema that describes the structure of this input.
        """
        changesetSpec: String!
    ): ChangesetSpec!
    "Creates a new configuration policy with the given attributes."
    createCodeIntelligenceConfigurationPolicy(
        indexCommitMaxAgeHours: Int
        indexIntermediateCommits: Boolean!
        indexingEnabled: Boolean!
        name: String!
        pattern: String!
        """
        If supplied, the repository to which this configuration policy applies. If not supplied,
        this configuration policy is applied to all repositories.
        """
        repository: ID
        """
        If supplied, the name patterns matching repositories to which this configuration policy
        applies. This option is mutually exclusive with an explicit repository.
        """
        repositoryPatterns: [String!]
        retainIntermediateCommits: Boolean!
        retentionDurationHours: Int
        retentionEnabled: Boolean!
        type: GitObjectType!
    ): CodeIntelligenceConfigurationPolicy!
    "Create a code monitor."
    createCodeMonitor(
        "A list of actions."
        actions: [MonitorActionInput!]!
        "A monitor."
        monitor: MonitorInput!
        "A trigger."
        trigger: MonitorTriggerInput!
    ): Monitor!
    """
    Creates a batch change with an empty batch spec, such as for drafting a new batch
    change. The user creating the batch change must have permission to create it in the
    namespace provided. Use `createBatchSpecFromRaw` and `replaceBatchSpecInput` to update
    the input batch spec after creating.
    """
    createEmptyBatchChange(
        "The (unique) name to identify the batch change by in its namespace."
        name: String!
        "The namespace (either a user or organization) that this batch change should belong to."
        namespace: ID!
    ): BatchChange!
    "(experimental) Create a new feature flag"
    createFeatureFlag(
        "The name of the feature flag"
        name: String!
        """
        The ratio of users the feature flag will apply to, expressed in basis points (0.01%).
        Only set if the new feature flag will be a rollout flag.
        Mutually exclusive with value.
        """
        rolloutBasisPoints: Int
        """
        The value of the feature flag. Only set if the new feature flag
        will be a concrete boolean flag. Mutually exclusive with rolloutBasisPoints.
        """
        value: Boolean
    ): FeatureFlag!
    "(experimental) Create a new feature flag override for the given org or user"
    createFeatureFlagOverride(
        "The name of the feature flag this override applies to"
        flagName: String!
        "The namespace for this feature flag. Must be either a user ID or an org ID."
        namespace: ID!
        "The overridden value"
        value: Boolean!
    ): FeatureFlagOverride!
    "Create a new dashboard."
    createInsightsDashboard(input: CreateInsightsDashboardInput!): InsightsDashboardPayload!
    "Create a line chart backed by search insights."
    createLineChartSearchInsight(input: LineChartSearchInsightInput!): InsightViewPayload!
    "Create a notebook."
    createNotebook("Notebook input." notebook: NotebookInput!): Notebook!
    """
    Create a notebook star for the current user.
    Only one star can be created per notebook and user pair.
    """
    createNotebookStar(notebookID: ID!): NotebookStar!
    """
    Creates an organization. The caller is added as a member of the newly created organization.

    Only authenticated users may perform this mutation.
    """
    createOrganization(displayName: String, name: String!, statsID: ID): Org!
    """
    Creates a password for the current user. It is only permitted if the user does not have a password and
    they don't have any login connections.
    """
    createPassword(newPassword: String!): EmptyResponse
    "Create a pie chart backed by search insights."
    createPieChartSearchInsight(input: PieChartSearchInsightInput!): InsightViewPayload!
    "Creates a saved search."
    createSavedSearch(
        description: String!
        notifyOwner: Boolean!
        notifySlack: Boolean!
        orgID: ID
        query: String!
        userID: ID
    ): SavedSearch!
    "Create search context."
    createSearchContext(
        "List of search context repository revisions."
        repositories: [SearchContextRepositoryRevisionsInput!]!
        "Search context input."
        searchContext: SearchContextInput!
    ): SearchContext!
    """
    Creates a new user account.

    Only site admins may perform this mutation.
    """
    createUser(
        "The new user's optional email address. If given, it is marked as verified."
        email: String
        "The new user's username."
        username: String!
    ): CreateUserResult!
    """
    Deletes and immediately revokes the specified access token, specified by either its ID or by the token
    itself.

    Only site admins or the user who owns the token may perform this mutation.
    """
    deleteAccessToken(byID: ID, byToken: String): EmptyResponse!
    """
    Delete a batch change. A deleted batch change is completely removed and can't be un-deleted. The
    batch change's changesets are kept as-is; to close them, use the closeBatchChange mutation first.
    """
    deleteBatchChange(batchChange: ID!): EmptyResponse
    "Hard-deletes a given credential."
    deleteBatchChangesCredential(batchChangesCredential: ID!): EmptyResponse!
    """
    Deletes the batch spec. All associated jobs will be canceled, if still running.
    This is called by the client, whenever a new run is triggered, to support
    faster cleanups. We will also purge these in the background, but this'll be
    faster.
    """
    deleteBatchSpec(batchSpec: ID!): EmptyResponse!
    "Deletes the configuration policy with the given identifier."
    deleteCodeIntelligenceConfigurationPolicy(policy: ID!): EmptyResponse
    "Delete a code monitor."
    deleteCodeMonitor("The id of a code monitor." id: ID!): EmptyResponse!
    """
    Deletes the association between an external account and its Sourcegraph user. It does NOT delete the external
    account on the external service where it resides.

    Only site admins or the user who is associated with the external account may perform this mutation.
    """
    deleteExternalAccount(externalAccount: ID!): EmptyResponse!
    "Delete an external service. Only site admins may perform this mutation."
    deleteExternalService(externalService: ID!): EmptyResponse!
    "(experimental) Delete a feature flag"
    deleteFeatureFlag("The name of the feature flag" name: String!): EmptyResponse!
    "Delete a feature flag override"
    deleteFeatureFlagOverride("The ID of the feature flag override to delete" id: ID!): EmptyResponse!
    "Delete an insight view given the graphql ID."
    deleteInsightView(id: ID!): EmptyResponse!
    "Delete a dashboard."
    deleteInsightsDashboard(id: ID!): EmptyResponse!
    "Deletes an LSIF index."
    deleteLSIFIndex(id: ID!): EmptyResponse
    "Deletes an LSIF upload."
    deleteLSIFUpload(id: ID!): EmptyResponse
    "Delete a notebook. Only the owner can delete it."
    deleteNotebook(id: ID!): EmptyResponse!
    "Delete the notebook star for the current user, if exists."
    deleteNotebookStar(notebookID: ID!): EmptyResponse!
    """
    Soft or hard deletes an organization.
    - When the second argument is not provided, it soft deletes an organization, marking it as deleted.
    Only site admins may perform this mutation.
    - When the second argument is true, it hard deletes an organization and its associated resources.
    Hard deletion is currently only supported on cloud. Only org members may perform this mutation
    """
    deleteOrganization(hard: Boolean, organization: ID!): EmptyResponse
    "Deletes a saved search"
    deleteSavedSearch(id: ID!): EmptyResponse
    "Delete search context."
    deleteSearchContext(id: ID!): EmptyResponse!
    """
    Deletes a user account. Only site admins may perform this mutation.

    If hard == true, a hard delete is performed. By default, deletes are
    'soft deletes' and could theoretically be undone with manual DB commands.
    If a hard delete is performed, the data is truly removed from the
    database and deletion can NEVER be undone.

    Data that is deleted as part of this operation:

    - All user data (access tokens, email addresses, external account info, survey responses, etc)
    - Organization membership information (which organizations the user is a part of, any invitations created by or targeting the user).
    - Sourcegraph extensions published by the user.
    - User, Organization, or Global settings authored by the user.
    """
    deleteUser(hard: Boolean, user: ID!): EmptyResponse
    """
    Detach archived changesets from a batch change.

    Experimental: This API is likely to change in the future.
    """
    detachChangesets(batchChange: ID!, changesets: [ID!]!): BulkOperation!
    """
    Merges the given settings edit with the current temporary settings for the current user.
    Keys in the given edit take priority over key in the temporary settings. The merge is
    not recursive.
    If temporary settings for the user do not exist, they are created.
    """
    editTemporarySettings(
        "The settings to merge with the current temporary settings for the current user, as a JSON string."
        settingsToEdit: String!
    ): EmptyResponse!
    """
    Enqueue the workspace for execution. The workspace must not be running, and
    not be in a final state. This can be used for running single workspaces before
    running the full set.
    """
    enqueueBatchSpecWorkspaceExecution(batchSpecWorkspaces: [ID!]!): EmptyResponse!
    """
    Enqueue the workspaces that resulted from evaluation in
    `createBatchSpecFromRaw`to be executed. These will eventually be moved into
    running state. resolution is done, to support fast edits.
    Once the workspace resolution is done, workspace jobs are move to state QUEUED.
    If resolving is already done by the time this mutation is called, they are
    enqueued immediately.

    Must be invoked by the _same_ user that called createBatchSpecFromRaw before.
    Can only be invoked once.
    If workspace resolution fails, the running flag should be reset to false. API
    consumers can find this state by looking at BatchSpecWorkspaceResolution.failureMessage.

    TODO: This might be blocking with an error for now.
    """
    executeBatchSpec(
        """
        Right away set the autoApplyEnabled flag on the batch spec.

        TODO: Not implemented yet.
        """
        autoApply: Boolean = false
        "The ID of the batch spec."
        batchSpec: ID!
        """
        Don't use cache entries.

        TODO: Not implemented yet.
        """
        noCache: Boolean = false
    ): BatchSpec!
    "Manages the extension registry."
    extensionRegistry: ExtensionRegistryMutation!
    """
    Invalidates all sessions belonging to a user.

    Only site admins may perform this mutation.
    """
    invalidateSessionsByID(userID: ID!): EmptyResponse
    """
    Sends an invitation to join Sourcegraph to the given email address.

    Returns instantly regardless of whether or not an invitation email was actually sent. For example, the email
    may fail to send if there is a typo or it is invalid, or Sourcegraph may refuse to send it due to spam concerns
    or if the user has been invited too recently.
    """
    inviteEmailToSourcegraph(email: String!): EmptyResponse!
    """
    Invite the user with the given username to join the organization. The invited user account must already
    exist.

    Only site admins and any organization member may perform this mutation.
    """
    inviteUserToOrganization(email: String, organization: ID!, username: String): InviteUserToOrganizationResult!
    "Logs an event."
    logEvent(
        "The additional argument information."
        argument: String
        """
        An optional cohort ID to identify the user as part of a specific A/B test.
        The cohort ID is expected to be a date in the form YYYY-MM-DD
        """
        cohortID: String
        "Device ID used for Amplitude analytics. Used on Sourcegraph Cloud only."
        deviceID: String
        "The name of the event."
        event: String!
        """
        Event ID used to deduplicate events that occur simultaneously in Amplitude analytics.
        See https://developers.amplitude.com/docs/http-api-v2#optional-keys. Used on Sourcegraph Cloud only.
        """
        eventID: Int
        "The first sourcegraph URL visited by the user, stored in a browser cookie."
        firstSourceURL: String
        """
        Insert ID used to deduplicate events that re-occur in the event of retries or
        backfills in Amplitude analytics. See https://developers.amplitude.com/docs/http-api-v2#optional-keys.
        Used on Sourcegraph Cloud only.
        """
        insertID: String
        "The last sourcegraph URL visited by the user, stored in a browser cookie."
        lastSourceURL: String
        """
        Public argument information. PRIVACY: Do NOT include any potentially private information in this field.
        These properties get sent to our analytics tools for Cloud, so must not include private information,
        such as search queries or repository names.
        """
        publicArgument: String
        """
        An optional referrer parameter for the user's current session.
        Only captured and stored on Sourcegraph Cloud.
        """
        referrer: String
        "The source of the event."
        source: EventSource!
        "The URL when the event was logged."
        url: String!
        "The randomly generated unique user ID stored in a browser cookie."
        userCookieID: String!
    ): EmptyResponse
    "Logs a batch of events."
    logEvents(events: [Event!]): EmptyResponse
    "Logs a user event."
    logUserEvent(event: UserEvent!, userCookieID: String!): EmptyResponse @deprecated(reason: "use logEvent instead")
    """
    Merge multiple changesets. If squash is true, the commits will be squashed
    into a single commit on code hosts that support squash-and-merge.

    Experimental: This API is likely to change in the future.
    """
    mergeChangesets(batchChange: ID!, changesets: [ID!]!, squash: Boolean = false): BulkOperation!
    "Move a batch change to a different namespace, or rename it in the current namespace."
    moveBatchChange(batchChange: ID!, newName: String, newNamespace: ID): BatchChange!
    """
    Overwrites and saves the temporary settings for the current user.
    If temporary settings for the user do not exist, they are created.
    """
    overwriteTemporarySettings(
        "The new temporary settings for the current user, as a JSON string."
        contents: String!
    ): EmptyResponse!
    """
    Set the UI publication state for multiple changesets. If draft is true, the
    changesets are published as drafts, provided the code host supports it.

    Experimental: This API is likely to change in the future.
    """
    publishChangesets(batchChange: ID!, changesets: [ID!]!, draft: Boolean = false): BulkOperation!
    """
    Queues the index jobs for a repository for execution. An optional resolvable revhash
    (commit, branch name, or tag name) can be specified; by default the tip of the default
    branch will be used.

    If a configuration is supplied, that configuration is used to determine what jobs to
    schedule. If no configuration is supplied, it will go through the regular index scheduling
    rules: first read any in-repo configuration (e.g., sourcegraph.yaml), then look for any
    existing in-database configuration, finally falling back to the automatically infered
    connfiguration based on the repo contents at the target commit.
    """
    queueAutoIndexJobsForRepo(configuration: String, repository: ID!, rev: String): [LSIFIndex!]!
    """
    Randomize a user's password so that they need to reset it before they can sign in again.

    Only site admins may perform this mutation.
    """
    randomizeUserPassword(user: ID!): RandomizeUserPasswordResult!
    "Re-enqueue the changeset for processing by the reconciler. The changeset must be in FAILED state."
    reenqueueChangeset(changeset: ID!): Changeset!
    """
    Reenqueue multiple changesets for processing.

    Experimental: This API is likely to change in the future.
    """
    reenqueueChangesets(batchChange: ID!, changesets: [ID!]!): BulkOperation!
    """
    Reloads the site by restarting the server. This is not supported for all deployment
    types. This may cause downtime.

    Only site admins may perform this mutation.
    """
    reloadSite: EmptyResponse
    "Remove an insight view from a dashboard."
    removeInsightViewFromDashboard(input: RemoveInsightViewFromDashboardInput!): InsightsDashboardPayload!
    """
    Removes an email address from the user's account.

    Only the user and site admins may perform this mutation.
    """
    removeUserEmail(email: String!, user: ID!): EmptyResponse!
    """
    Removes a user as a member from an organization.

    Only site admins and any member of the organization may perform this mutation.
    """
    removeUserFromOrganization(organization: ID!, user: ID!): EmptyResponse
    """
    Replaces the original input of the batch spec. All existing resolution jobs and
    workspaces are deleted and recreated in the background as the `on` section is
    evaluated. This mutation is used for overwriting existing resolutions on unapplied
    batch specs, so after typing in the editor, we don't create 10s of batch specs. The ID
    of the batch spec to update should NEVER be that of a batch spec that was already
    applied to a batch change, or it will be lost.

    For creating a new batch spec for a batch change whose previous spec was already
    applied, use `createBatchSpecFromRaw` instead.
    """
    replaceBatchSpecInput(
        "If true, repos with a .batchignore file will still be included."
        allowIgnored: Boolean = false
        """
        If true, repos on unsupported codehosts will be included. Resulting changesets in these repos cannot
        be published.
        """
        allowUnsupported: Boolean = false
        """
        The raw batch spec as YAML (or the equivalent JSON). See
        https://sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/schema/batch_spec.schema.json
        for the JSON Schema that describes the structure of this input.
        """
        batchSpec: String!
        """
        Right away set the execute flag.

        TODO: Not implemented yet.
        """
        execute: Boolean = false
        """
        Don't use cache entries.

        TODO: Not implemented yet.
        """
        noCache: Boolean = false
        "The ID of the batch spec resource to update."
        previousSpec: ID!
    ): BatchSpec!
    "Submits a request for a Sourcegraph Enterprise trial license."
    requestTrial(email: String!): EmptyResponse
    """
    Resend the notification about an organization invitation to the recipient.

    Only site admins and any member of the organization may perform this mutation.
    """
    resendOrganizationInvitationNotification("The organization invitation." organizationInvitation: ID!): EmptyResponse!
    """
    Resend a verification email, no op if the email is already verified.

    Only the user and site admins may perform this mutation.
    """
    resendVerificationEmail(email: String!, user: ID!): EmptyResponse!
    """
    Reset the timestamps of a trigger query. The query will be queued immediately and return
    all results without a limit on the timeframe. Only site admins may perform this mutation.
    """
    resetTriggerQueryTimestamps("The id of the trigger query." id: ID!): EmptyResponse!
    "Resolves a revision for a given diff from Phabricator."
    resolvePhabricatorDiff(
        "The author's email."
        authorEmail: String
        "The name of author of the diff."
        authorName: String
        "The base revision this diff is based on."
        baseRev: String!
        "When the diff was created."
        date: String
        "The description of the diff. This will be used as the commit message."
        description: String
        "The ID of the diff on Phabricator."
        diffID: ID!
        """
        The raw contents of the diff from Phabricator.
        Required if Sourcegraph doesn't have a Conduit API token.
        """
        patch: String
        "The name of the repository that the diff is based on."
        repoName: String!
    ): GitCommit
    """
    Accept or reject an existing organization invitation.

    Only the recipient of the invitation may perform this mutation.
    """
    respondToOrganizationInvitation(
        "The organization invitation."
        organizationInvitation: ID!
        "The response to the invitation."
        responseType: OrganizationInvitationResponseType!
    ): EmptyResponse!
    """
    Requeue all workspaces in the batch spec for execution. Previous results and
    logs will be deleted and the executions are _replaced_. The workspaces must be in
    a final state (COMPLETED, FAILED, CANCELED) to be retryable.

    If includeCompleted is set, then workspaces that successfully completed
    execution will also be retried and their changeset specs deleted.
    """
    retryBatchSpecExecution(batchSpec: ID!, includeCompleted: Boolean = false): BatchSpec!
    """
    Requeue the workspaces for execution. Previous results and logs will be deleted and
    the executions are _replaced_. The workspaces must be in a final state (COMPLETED, FAILED)
    to be retryable.
    """
    retryBatchSpecWorkspaceExecution(batchSpecWorkspaces: [ID!]!): EmptyResponse!
    """
    Revoke an existing organization invitation.

    If the invitation has been accepted or rejected, it may no longer be revoked. After an
    invitation is revoked, the recipient may not accept or reject it. Both cases yield an error.

    Only site admins and any member of the organization may perform this mutation.
    """
    revokeOrganizationInvitation("The organization invitation." organizationInvitation: ID!): EmptyResponse!
    """
    Schedule a permissions sync for given repository. This queries the repository's code host for
    all users' permissions associated with the repository, so that the current permissions apply
    to all users' operations on that repository on Sourcegraph.
    """
    scheduleRepositoryPermissionsSync(repository: ID!): EmptyResponse!
    """
    Schedule a permissions sync for given user. This queries all code hosts for the user's current
    repository permissions and syncs them to Sourcegraph, so that the current permissions apply to
    the user's operations on Sourcegraph.
    """
    scheduleUserPermissionsSync(
        "Additional options when performing a sync."
        options: FetchPermissionsOptions
        "User to schedule a sync for."
        user: ID!
    ): EmptyResponse!
    """
    Sends an email for testing Sourcegraph's email configuration.

    Only administrators can use this API.
    """
    sendTestEmail(to: String!): String!
    "Set the repos synced by an external service"
    setExternalServiceRepos(allRepos: Boolean!, id: ID!, repos: [String!]): EmptyResponse!
    """
    Set the permissions of a repository (i.e., which users may view it on Sourcegraph). This
    operation overwrites the previous permissions for the repository.
    """
    setRepositoryPermissionsForUsers(
        "The repository whose permissions to set."
        repository: ID!
        """
        A list of user identifiers and their repository permissions, which defines the set of
        users who may view the repository. All users not included in the list will not be
        permitted to view the repository on Sourcegraph.
        """
        userPermissions: [UserPermission!]!
    ): EmptyResponse!
    "Current user opt in/out from being searchable in the users picker."
    setSearchable(searchable: Boolean!): EmptyResponse!
    """
    Set the sub-repo permissions of a repository (i.e., which paths are allowed or disallowed for
    a particular user). This operation overwrites the previous sub-repo permissions for the
    repository.
    """
    setSubRepositoryPermissionsForUsers(
        "The repository whose permissions to set."
        repository: ID!
        """
        A list of user identifiers and their sub-repository permissions, which defines the set of
        paths within the repository they can access.
        """
        userPermissions: [UserSubRepoPermission!]!
    ): EmptyResponse!
    """
    Adds or removes a tag on a user.

    Tags are used internally by Sourcegraph as feature flags for experimental features.

    Only site admins may perform this mutation.
    """
    setTag(
        """
        The ID of the user whose tags to set.

        (This parameter is named "node" to make it easy to support tagging other types of nodes
        other than users in the future.)
        """
        node: ID!
        """
        The desired state of the tag on the user (whether to add or remove): true to add, false to
        remove.
        """
        present: Boolean!
        "The tag to set."
        tag: String!
    ): EmptyResponse!
    """
    Sets the user to accept the site's Terms of Service and Privacy Policy.
    If the ID is ommitted, the current user is assumed.

    Only the user or site admins may perform this mutation.
    """
    setTosAccepted(userID: ID): EmptyResponse!
    """
    Set an email address as the user's primary.

    Only the user and site admins may perform this mutation.
    """
    setUserEmailPrimary(email: String!, user: ID!): EmptyResponse!
    """
    Manually set the verification status of a user's email, without going through the normal verification process
    (of clicking on a link in the email with a verification code).

    Only site admins may perform this mutation.
    """
    setUserEmailVerified(email: String!, user: ID!, verified: Boolean!): EmptyResponse!
    """
    Sets whether the user with the specified user ID is a site admin.

    Only site admins may perform this mutation.
    """
    setUserIsSiteAdmin(siteAdmin: Boolean!, userID: ID!): EmptyResponse
    """
    All mutations that update settings (global, organization, and user settings) are under this field.

    Only the settings subject whose settings are being mutated (and site admins) may perform this mutation.

    This mutation only affects global, organization, and user settings, not site configuration. For site
    configuration (which is a separate set of configuration properties from global/organization/user settings),
    use updateSiteConfiguration.
    """
    settingsMutation(input: SettingsMutationGroupInput!): SettingsMutation
    "Submits happiness feedback."
    submitHappinessFeedback(input: HappinessFeedbackSubmissionInput!): EmptyResponse
    "Submits a user satisfaction (NPS) survey."
    submitSurvey(input: SurveySubmissionInput!): EmptyResponse
    "Enqueue the given changeset for high-priority syncing."
    syncChangeset(changeset: ID!): EmptyResponse!
    """
    Sets the autoApplyEnabled on the given batch spec. Must be in PROCESSING state.

    TODO: Not implemented yet.
    """
    toggleBatchSpecAutoApply(batchSpec: ID!, value: Boolean!): BatchSpec!
    "Set a code monitor to active/inactive."
    toggleCodeMonitor(
        "Whether the code monitor should be enabled or not."
        enabled: Boolean!
        "The id of a code monitor."
        id: ID!
    ): Monitor!
    """
    OBSERVABILITY

    Set the status of a test alert of the specified parameters - useful for validating
    'observability.alerts' configuration. Alerts may take up to a minute to fire.
    """
    triggerObservabilityTestAlert("Level of alert to test - either warning or critical." level: String!): EmptyResponse!
    "Triggers a test email for a code monitor action."
    triggerTestEmailAction(description: String!, email: MonitorEmailInput!, namespace: ID!): EmptyResponse!
    "Triggers a test Slack webhook message for a code monitor action."
    triggerTestSlackWebhookAction(
        description: String!
        namespace: ID!
        slackWebhook: MonitorSlackWebhookInput!
    ): EmptyResponse!
    "Triggers a test webhook call for a code monitor action."
    triggerTestWebhookAction(description: String!, namespace: ID!, webhook: MonitorWebhookInput!): EmptyResponse!
    "Updates the attributes configuration policy with the given identifier."
    updateCodeIntelligenceConfigurationPolicy(
        id: ID!
        indexCommitMaxAgeHours: Int
        indexIntermediateCommits: Boolean!
        indexingEnabled: Boolean!
        name: String!
        pattern: String!
        repositoryPatterns: [String!]
        retainIntermediateCommits: Boolean!
        retentionDurationHours: Int
        retentionEnabled: Boolean!
        type: GitObjectType!
    ): EmptyResponse
    """
    Update a code monitor. We assume that the request contains a complete code monitor,
    including its trigger and all actions. Actions which are stored in the database,
    but are missing from the request will be deleted from the database. Actions with id=null
    will be created.
    """
    updateCodeMonitor(
        """
        The input required to edit the actions of a monitor. You can only edit actions that are
        associated with the monitor (value of field monitor).
        """
        actions: [MonitorEditActionInput!]!
        "The input required to edit a monitor."
        monitor: MonitorEditInput!
        """
        The input required to edit the trigger of a monitor. You can only edit triggers that are
        associated with the monitor (value of field monitor).
        """
        trigger: MonitorEditTriggerInput!
    ): Monitor!
    "Updates a external service. Only site admins may perform this mutation."
    updateExternalService(input: UpdateExternalServiceInput!): ExternalService!
    "(experimental) Update a feature flag"
    updateFeatureFlag(
        "The name of the feature flag"
        name: String!
        """
        The ratio of users the feature flag will apply to, expressed in basis points (0.01%).
        Mutually exclusive with value.
        """
        rolloutBasisPoints: Int
        """
        The value of the feature flag. Only set if the new feature flag
        will be a concrete boolean flag. Mutually exclusive with rollout.
        """
        value: Boolean
    ): FeatureFlag!
    "Update a feature flag override"
    updateFeatureFlagOverride(
        "The ID of the feature flag override to update"
        id: ID!
        "The updated value of the feature flag override"
        value: Boolean!
    ): FeatureFlagOverride!
    "Update an insight series. Restricted to admins only."
    updateInsightSeries(input: UpdateInsightSeriesInput!): InsightSeriesMetadataPayload
    "Edit an existing dashboard."
    updateInsightsDashboard(id: ID!, input: UpdateInsightsDashboardInput!): InsightsDashboardPayload!
    "Update a line chart backed by search insights."
    updateLineChartSearchInsight(id: ID!, input: UpdateLineChartSearchInsightInput!): InsightViewPayload!
    """
    Schedule the mirror repository to be updated from its original source repository. Updating
    occurs automatically, so this should not normally be needed.

    Only site admins may perform this mutation.
    """
    updateMirrorRepository("The mirror repository to update." repository: ID!): EmptyResponse!
    "Update a notebook. Only the owner can update it."
    updateNotebook("Notebook ID." id: ID!, "Notebook input." notebook: NotebookInput!): Notebook!
    """
    Updates an organization.

    Only site admins and any member of the organization may perform this mutation.
    """
    updateOrganization(displayName: String, id: ID!): Org!
    "Updates the current user's password. The oldPassword arg must match the user's current password."
    updatePassword(newPassword: String!, oldPassword: String!): EmptyResponse
    "Update a pie chart backed by search insights."
    updatePieChartSearchInsight(id: ID!, input: UpdatePieChartSearchInsightInput!): InsightViewPayload!
    "Updates the indexing configuration associated with a repository."
    updateRepositoryIndexConfiguration(configuration: String!, repository: ID!): EmptyResponse
    "Updates a saved search"
    updateSavedSearch(
        description: String!
        id: ID!
        notifyOwner: Boolean!
        notifySlack: Boolean!
        orgID: ID
        query: String!
        userID: ID
    ): SavedSearch!
    "Update search context."
    updateSearchContext(
        "Search context ID."
        id: ID!
        "List of search context repository revisions."
        repositories: [SearchContextRepositoryRevisionsInput!]!
        "Search context input."
        searchContext: SearchContextEditInput!
    ): SearchContext!
    """
    Updates the site configuration. Returns whether or not a restart is required for the update to be applied.

    Only site admins may perform this mutation.
    """
    updateSiteConfiguration(
        """
        A JSON object containing the entire site configuration. The previous site configuration will be replaced
        with this new value.
        """
        input: String!
        """
        The last ID of the site configuration that is known by the client, to
        prevent race conditions. An error will be returned if someone else
        has already written a new update.
        """
        lastID: Int!
    ): Boolean!
    """
    Updates the user profile information for the user with the given ID.

    Only the user and site admins may perform this mutation.
    """
    updateUser(avatarURL: String, displayName: String, user: ID!, username: String): User!
    """
    Creates or updates a batch spec based on the given namespace and name, then
    triggers a job to evaluate the workspaces.

    This is essentially a wrapper for `createBatchSpecFromRaw` and
    `replaceBatchSpecInput` to facilitate src-cli, and should not be used
    otherwise.
    """
    upsertBatchSpecInput(
        "If true, repos with a .batchignore file will still be included."
        allowIgnored: Boolean = false
        """
        If true, repos on unsupported codehosts will be included. Resulting changesets in these repos cannot
        be published.
        """
        allowUnsupported: Boolean = false
        """
        The raw batch spec as YAML (or the equivalent JSON). See
        https://sourcegraph.com/github.com/sourcegraph/sourcegraph/-/blob/schema/batch_spec.schema.json
        for the JSON Schema that describes the structure of this input.
        """
        batchSpec: String!
        """
        Right away set the execute flag.

        TODO: Not implemented yet.
        """
        execute: Boolean = false
        """
        The namespace (either a user or organization). A batch spec can only be applied to (or
        used to create) batch changes in this namespace.
        """
        namespace: ID!
        """
        Don't use cache entries.

        TODO: Not implemented yet.
        """
        noCache: Boolean = false
    ): BatchSpec!
}

"A notebook with an array of blocks."
type Notebook implements Node {
    "Array of notebook blocks."
    blocks: [NotebookBlock!]!
    "Date and time the notebook was created."
    createdAt: DateTime!
    "User that created the notebook or null if the user was removed."
    creator: User
    "The unique id of the notebook."
    id: ID!
    "Notebook namespace or null if the namespace (user or org) was removed."
    namespace: Namespace
    """
    Public property controls the visibility of the notebook. A public notebook is available to
    any user on the instance. Private notebooks are only available to their creators.
    """
    public: Boolean!
    "Notebook stars."
    stars(
        "Opaque pagination cursor."
        after: String
        "Returns the first n notebook stars from the list."
        first: Int = 50
    ): NotebookStarConnection!
    "The title of the notebook."
    title: String!
    "Date and time the notebook was last updated."
    updatedAt: DateTime!
    "User that last updated the notebook or null if that user was removed."
    updater: User
    "If current viewer can manage (edit, delete) the notebook."
    viewerCanManage: Boolean!
    "If current viewer has starred the notebook."
    viewerHasStarred: Boolean!
}

"A paginated list of notebooks."
type NotebookConnection {
    "A list of notebooks."
    nodes: [Notebook!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of notebooks in the connection."
    totalCount: Int!
}

"A notebook star."
type NotebookStar {
    "Date and time the notebook star was created."
    createdAt: DateTime!
    "User that starred the notebook."
    user: User!
}

"A paginated list of notebook stars."
type NotebookStarConnection {
    "A list of notebook stars."
    nodes: [NotebookStar!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of notebook stars in the connection."
    totalCount: Int!
}

"An organization, which is a group of users."
type Org implements Namespace & Node & SettingsSubject {
    "A list of batch changes initially applied in this organization."
    batchChanges(
        "Opaque pagination cursor."
        after: String
        "Returns the first n batch changes from the list."
        first: Int = 50
        "Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`."
        state: BatchChangeState
        "Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it."
        states: [BatchChangeState!]
        "Only include batch changes that the viewer can administer."
        viewerCanAdminister: Boolean
    ): BatchChangeConnection!
    "DEPRECATED"
    configurationCascade: ConfigurationCascade!
        @deprecated(
            reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release."
        )
    "The date when the organization was created."
    createdAt: DateTime!
    "The organization's chosen display name."
    displayName: String
    "The unique ID for the organization."
    id: ID!
    """
    The latest settings for the organization.
    Only organization members and site admins can access this field.
    """
    latestSettings: Settings
    "A list of users who are members of this organization."
    members: UserConnection!
    "The organization's name. This is unique among all organizations on this Sourcegraph site."
    name: String!
    "The name of this user namespace's component. For organizations, this is the organization's name."
    namespaceName: String!
    "Repositories from external services owned by this organization."
    repositories(
        "An opaque cursor that is used for pagination."
        after: String
        "Include cloned repositories."
        cloned: Boolean = true
        "Only include repositories from these external services."
        externalServiceIDs: [ID]
        "Returns the first n repositories from the list."
        first: Int
        "Include repositories that have a text search index."
        indexed: Boolean = true
        "Include repositories that are not yet cloned and for which cloning is not in progress."
        notCloned: Boolean = true
        "Include repositories that do not have a text search index."
        notIndexed: Boolean = true
        "Return repositories whose names match the query."
        query: String
    ): RepositoryConnection!
    """
    All settings for this organization, and the individual levels in the settings cascade (global > organization)
    that were merged to produce the final merged settings.
    Only organization members and site admins can access this field.
    """
    settingsCascade: SettingsCascade!
    "The URL to the organization's settings."
    settingsURL: String
    "The URL to the organization."
    url: String!
    """
    Whether the viewer has admin privileges on this organization. Currently, all of an organization's members
    have admin privileges on the organization.
    """
    viewerCanAdminister: Boolean!
    "Whether the viewer is a member of this organization."
    viewerIsMember: Boolean!
    "Whether the viewer needs to update their code host connection."
    viewerNeedsCodeHostUpdate: Boolean!
    """
    DEPRECATED
    A pending invitation for the viewer to join this organization, if any.
    """
    viewerPendingInvitation: OrganizationInvitation
        @deprecated(
            reason: "Use invitationByToken operation instead. This field is deprecated and will be removed in a future release."
        )
}

"A list of organizations."
type OrgConnection {
    "A list of organizations."
    nodes: [Org!]!
    """
    The total count of organizations in the connection. This total count may be larger
    than the number of nodes in this object when the result is paginated.
    """
    totalCount: Int!
}

"Result organization members count and pending invitations count."
type OrgMembersSummary {
    "The unique ID for the Org."
    id: ID!
    "Total number of pending invites for the org."
    invitesCount: Int!
    "Total number of members for the org."
    membersCount: Int!
}

"An invitation to join an organization as a member."
type OrganizationInvitation implements Node {
    "The date when this invitation was created."
    createdAt: DateTime!
    "The date when this invitation is going to expire."
    expiresAt: DateTime
    "The ID of the invitation."
    id: ID!
    "Boolean flag which returns true if the email on the invite matches a verified email of the user"
    isVerifiedEmail: Boolean
    "The most recent date when a notification was sent to the recipient about this invitation."
    notifiedAt: DateTime
    "The organization that the invitation is for."
    organization: Org!
    "The user who received the invitation."
    recipient: User
    "The email address that the invitation was sent to."
    recipientEmail: String
    "The URL where the recipient can respond to the invitation when pending, or null if not pending."
    respondURL: String
    "The date when this invitation was responded to by the recipient."
    respondedAt: DateTime
    "The recipient's response to this invitation, or no response (null)."
    responseType: OrganizationInvitationResponseType
    "The date when this invitation was revoked."
    revokedAt: DateTime
    "The user who sent the invitation."
    sender: User!
}

"An organization membership."
type OrganizationMembership {
    "The time when this was created."
    createdAt: DateTime!
    "The organization."
    organization: Org!
    "The time when this was updated."
    updatedAt: DateTime!
    "The user."
    user: User!
}

"A list of organization memberships."
type OrganizationMembershipConnection {
    "A list of organization memberships."
    nodes: [OrganizationMembership!]!
    """
    The total count of organization memberships in the connection. This total count may be larger than the number
    of nodes in this object when the result is paginated.
    """
    totalCount: Int!
}

"""
An out-of-band migration is a process that runs in the background of the instance that moves
data from one format into another format. Out-of-band migrations
"""
type OutOfBandMigration implements Node {
    "If true, the migration will run in reverse."
    applyReverse: Boolean!
    "The component this migration affects (e.g., codeintel-db.lsif_data_documents)."
    component: String!
    "The time the migration record was inserted."
    created: DateTime!
    """
    The Sourcegraph version by which this migration is assumed to have completed. The format of
    this version mirrors introduced and includes only major and minor parts separated by a dot.

    It is necessary to have completed this migration before upgrading to or past this version.
    Otherwsie, the next instance version will no longer be aware of the old data format.
    """
    deprecated: String
    "A human-readable summary of the migration."
    description: String!
    """
    A list of errors that have occurred while performing this migration (in either direction).
    This list is bounded by a maximum size, and older errors will replaced by newer errors as
    the list capacity is reached.
    """
    errors: [OutOfBandMigrationError!]!
    "The unique identifier of this migration."
    id: ID!
    """
    The Sourcegraph version in which this migration was introduced. The format of this version
    includes only major and minor parts separated by a dot. The patch version can always be assumed
    to be zero as we'll never introduce or deprecate an out-of-band migration within a patch release.

    It is necessary to completely this migration in reverse (if destructive) before downgrading
    to or past this version. Otherwise, the previous instance version will not be aware of the
    new data format.
    """
    introduced: String!
    "The last time the migration progress or error list was updated."
    lastUpdated: DateTime
    """
    If false, the migration moves data destructively, and a previous version of Sourcegraph
    will encounter errors when interfacing with the target data unless the migration is first
    run in reverse prior to a downgrade.
    """
    nonDestructive: Boolean!
    "The progress of the migration (in the forward direction). In the range [0, 1]."
    progress: Float!
    "The team that owns this migration (e.g., code-intelligence)."
    team: String!
}

"An error that occurred while performing an out-of-band migration."
type OutOfBandMigrationError {
    "The time the error occurred."
    created: DateTime!
    "The error message."
    message: String!
}

"Pagination information. See https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
}

"Parent Sourcegraph instance"
type ParentSourcegraphDetails {
    "Sourcegraph instance URL."
    url: String!
}

"Permissions information of a repository or a user."
type PermissionsInfo {
    "The permission levels that a user has on the repository."
    permissions: [RepositoryPermission!]!
    """
    The last complete synced time, the value is updated only after a user- or repo-
    centric sync of permissions. It is null when the complete sync never happened.
    """
    syncedAt: DateTime
    """
    The last updated time of permissions, the value is updated whenever there is a
    change to the database row (i.e. incremental update).
    """
    updatedAt: DateTime!
}

"A person."
type Person {
    "The avatar URL, if known."
    avatarURL: String
    "The name if set; otherwise the email username."
    displayName: String!
    "The email."
    email: String!
    "The name."
    name: String!
    "The corresponding user account for this person, if one exists."
    user: User
}

"A Phabricator repository."
type PhabricatorRepo {
    "The unique Phabricator identifier for the repo, like \"MUX\""
    callsign: String!
    "The canonical repo name (e.g. \"github.com/gorilla/mux\")."
    name: String!
    "An alias for name."
    uri: String! @deprecated(reason: "use name instead")
    "The URL to the phabricator instance (e.g. http://phabricator.sgdev.org)"
    url: String!
}

"View presentation for an insight pie chart."
type PieChartInsightViewPresentation {
    """
    The threshold for which groups fall into the "other category". Only categories with a percentage greater than
    this value will be separately rendered.
    """
    otherThreshold: Float!
    "The title for the pie chart."
    title: String!
}

"A zero-based position inside a file."
type Position {
    "The character offset (zero-based) in the line of the position."
    character: Int!
    "The line number (zero-based) of the position."
    line: Int!
}

"The configuration and execution summary of a step to be performed prior to indexing."
type PreIndexStep {
    "The arguments to supply to the Docker container's entrypoint."
    commands: [String!]!
    "The name of the Docker image to run."
    image: String!
    "The execution summary (if completed or errored) of the docker command."
    logEntry: ExecutionLogEntry
    "The working directory relative to the cloned repository root."
    root: String!
}

"Details precise code-intel support overview."
type PreciseCodeIntelSupport {
    """
    List of indexers in subjective order of recommendation, from most to least recommended
    (not an indication of absolute quality, rather relative).
    """
    indexers: [CodeIntelIndexer!]
    """
    Level of support/ownership for the most complete/accurate precise code-intel indexer.
    This may be THIRD_PARTY even where a by us indexer exists, where the third-party indexer is
    more maintained/accurate/complete etc such as with the Dart indexer, where the Workiva one
    should be used over our own.
    """
    supportLevel: PreciseSupportLevel!
}

"A not-yet-committed preview of a diff on a repository."
type PreviewRepositoryComparison {
    "The repository that is the base (left-hand side) of this comparison."
    baseRepository: Repository!
    "The file diffs for each changed file."
    fileDiffs(
        "Return file diffs after the given cursor."
        after: String
        "Return the first n file diffs from the list."
        first: Int
    ): FileDiffConnection!
}

"Information about this site's product license (which activates certain Sourcegraph features)."
type ProductLicenseInfo {
    "The date when this license expires."
    expiresAt: DateTime!
    """
    The full name of the product that this license is for. To get the product name for the current
    Sourcegraph site, use ProductSubscriptionStatus.productNameWithBrand instead (to handle cases where there is
    no license).
    """
    productNameWithBrand: String!
    "Tags indicating the product plan and features activated by this license."
    tags: [String!]!
    "The number of users allowed by this license."
    userCount: Int!
}

"Information about this site's product subscription (which enables access to and renewals of a product license)."
type ProductSubscriptionStatus {
    """
    The max number of user accounts that have been active on this Sourcegraph site for the current license.
    If no license is in use, returns zero.
    """
    actualUserCount: Int!
    """
    The date and time when the max number of user accounts that have been active on this Sourcegraph site for
    the current license was reached. If no license is in use, returns an empty string.
    """
    actualUserCountDate: String!
    "The product license associated with this subscription, if any."
    license: ProductLicenseInfo
    """
    The number of users allowed. If there is a license, this is equal to ProductLicenseInfo.userCount. Otherwise,
    it is the user limit for instances without a license, or null if there is no limit.
    """
    maximumAllowedUserCount: Int
    """
    The number of free users allowed on a site without a license before a warning is shown to all users, or null
    if a valid license is in use.
    """
    noLicenseWarningUserCount: Int
    "The full name of the product in use, such as \"Sourcegraph Enterprise\"."
    productNameWithBrand: String!
}

"A query."
type Query {
    """
    Repos affiliated with the namespace (a user or an organization) & code hosts, these repos are not necessarily synced,
    but ones that the configured code hosts are able to see.
    """
    affiliatedRepositories(codeHost: ID, namespace: ID!, query: String): CodeHostRepositoryConnection!
    """
    The repositories a user is authorized to access with the given permission.
    This isnt defined in the User type because we store permissions for users
    that dont yet exist (i.e. late binding). Only one of "username" or "email"
    is required to identify a user.
    """
    authorizedUserRepositories(
        "Opaque pagination cursor."
        after: String
        "One of the email addresses."
        email: String
        "Number of repositories to return after the given cursor."
        first: Int!
        "Permission that the user has on the repositories."
        perm: RepositoryPermission = READ
        "The username."
        username: String
    ): RepositoryConnection!
    "Auto-defined search contexts available to the current user."
    autoDefinedSearchContexts: [SearchContext!]!
    "Search for users that opt-in to search autocomplete."
    autocompleteMembersSearch(
        "The organization ID"
        organization: ID!
        "Return users whose usernames or display names match the query."
        query: String!
    ): [AutocompleteMemberSearchItem!]!
    "Returns a list of available bulk operations for changesets belonging to a batch change."
    availableBulkOperations(
        "The batch change the selected changesets belong to."
        batchChange: ID!
        "The changesets to query for bulk operations applicable to."
        changesets: [ID!]!
    ): [BulkOperationType!]!
    "Looks up a batch change by namespace and name."
    batchChange(
        "The batch changes name."
        name: String!
        "The namespace where the batch change lives."
        namespace: ID!
    ): BatchChange
    "A list of batch changes."
    batchChanges(
        "Opaque pagination cursor."
        after: String
        "Returns the first n batch changes from the list."
        first: Int = 50
        "Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`."
        state: BatchChangeState
        "Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it."
        states: [BatchChangeState!]
        "Only include batch changes that the viewer can administer."
        viewerCanAdminister: Boolean
    ): BatchChangeConnection!
    "All globally configured code hosts usable with Batch Changes."
    batchChangesCodeHosts(
        "Opaque pagination cursor."
        after: String
        "Returns the first n code hosts from the list."
        first: Int = 50
    ): BatchChangesCodeHostConnection!
    """
    A list of batch specs.


    Site-admin only.

    Experimental: This API is likely to change in the future.
    """
    batchSpecs(
        "Opaque pagination cursor."
        after: String
        "Returns the first n batch specs from the list."
        first: Int = 50
    ): BatchSpecConnection!
    "The configuration for clients."
    clientConfiguration: ClientConfigurationDetails!
    "Returns true if any of the code hosts supplied are syncing now or within \"seconds\" from now."
    codeHostSyncDue(ids: [ID!]!, seconds: Int!): Boolean!
    """
    Returns precise code intelligence configuration policies that control data retention
    and (if enabled) auto-indexing behavior.
    """
    codeIntelligenceConfigurationPolicies(
        """
        When specified, indicates that this request should be paginated and
        to fetch results starting at this cursor.

        A future request can be made for more results by passing in the
        'CodeIntelligenceConfigurationPolicyConnection.pageInfo.endCursor'
        that is returned.
        """
        after: String
        """
        When specified, indicates that this request should be paginated and
        the first N results (relative to the cursor) should be returned. i.e.
        how many results to return per page.
        """
        first: Int
        "If set to true, then only configuration policies with data retention enabled are returned."
        forDataRetention: Boolean
        "If set to true, then only configuration policies with indexing enabled are returned."
        forIndexing: Boolean
        "An (optional) search query that searches over the name property."
        query: String
        """
        If repository is supplied, then only the configuration policies that apply to
        repository are returned. If repository is not supplied, then all policies are
        returned.
        """
        repository: ID
    ): CodeIntelligenceConfigurationPolicyConnection!
    "Computes valus from search results."
    compute("The search query." query: String = ""): [ComputeResult!]!
    "The current user."
    currentUser: User
    "Search over documentation"
    documentationSearch(
        "The search query."
        query: String!
        "A list of names of repositories to limit the search to (all by default)"
        repos: [String!]
    ): DocumentationSearchResults!
    "Checks whether the given feature is enabled on Sourcegraph."
    enterpriseLicenseHasFeature(feature: String!): Boolean!
    "Retrieve active executor compute instances."
    executors(
        "Whether to show only executors that have sent a heartbeat in the last fifteen minutes."
        active: Boolean
        "Opaque pagination cursor."
        after: String
        "Returns the first n executors."
        first: Int
        """
        An (optional) search query that searches over the hostname, queue name, os, architecture, and
        version properties.
        """
        query: String
    ): ExecutorConnection!
    "The extension registry."
    extensionRegistry: ExtensionRegistry!
    """
    Lists external services under given namespace.
    If no namespace is given, it returns all external services.
    """
    externalServices(
        "Opaque pagination cursor."
        after: String
        "Returns the first n external services from the list."
        first: Int
        """
        The namespace to scope returned external services.
        Currently, this can only be used for a user.
        """
        namespace: ID
    ): ExternalServiceConnection!
    "Retrieve the list of defined feature flags"
    featureFlags: [FeatureFlag!]!
    "EXPERIMENTAL: Syntax highlights a code string."
    highlightCode(code: String!, disableTimeout: Boolean!, fuzzyLanguage: String!, isLightTheme: Boolean): String!
    "Retrieve information about queued insights series and their breakout by status. Restricted to admins only."
    insightSeriesQueryStatus: [InsightSeriesQueryStatus!]!
    "Return all insight views visible to the authenticated user."
    insightViews(after: String, filters: InsightViewFiltersInput, first: Int, id: ID): InsightViewConnection!
    "[Experimental] Query for all insights and return their aggregations."
    insights(
        "An (optional) array of insight unique ids that will filter the results by the provided values. If omitted, all available insights will return."
        ids: [ID!]
    ): InsightConnection
    "Return dashboards visible to the authenticated user."
    insightsDashboards(after: String, first: Int, id: ID): InsightsDashboardConnection!
    """
    (experimental)
    Get invitation based on the JWT in the invitation URL
    """
    invitationByToken("The token that uniquely identifies the invitation" token: String!): OrganizationInvitation!
    """
    Determines whether the search context is within the set of search contexts available to the current user.
    The set consists of contexts created by the user, contexts created by the users' organizations, and instance-level contexts.
    """
    isSearchContextAvailable(spec: String!): Boolean!
    "The repository's LSIF uploads."
    lsifIndexes(
        """
        When specified, indicates that this request should be paginated and
        to fetch results starting at this cursor.
        A future request can be made for more results by passing in the
        'LSIFIndexConnection.pageInfo.endCursor' that is returned.
        """
        after: String
        """
        When specified, indicates that this request should be paginated and
        the first N results (relative to the cursor) should be returned. i.e.
        how many results to return per page.
        """
        first: Int
        """
        An (optional) search query that searches over the state, repository name,
        and commit properties.
        """
        query: String
        "The state of returned uploads."
        state: LSIFIndexState
    ): LSIFIndexConnection!
    "The repository's LSIF uploads."
    lsifUploads(
        """
        When specified, indicates that this request should be paginated and
        to fetch results starting at this cursor.

        A future request can be made for more results by passing in the
        'LSIFUploadConnection.pageInfo.endCursor' that is returned.
        """
        after: String
        "When specified, shows only uploads that are a dependency of the specified upload."
        dependencyOf: ID
        "When specified, shows only uploads that are a dependent of the specified upload."
        dependentOf: ID
        """
        When specified, indicates that this request should be paginated and
        the first N results (relative to the cursor) should be returned. i.e.
        how many results to return per page.
        """
        first: Int
        "When specified, shows only uploads that are latest for the given repository."
        isLatestForRepo: Boolean
        """
        An (optional) search query that searches over the state, repository name,
        commit, root, and indexer properties.
        """
        query: String
        "The state of returned uploads."
        state: LSIFUploadState
    ): LSIFUploadConnection!
    "Look up a namespace by ID."
    namespace(id: ID!): Namespace
    "Look up a namespace by name, which is a username or organization name."
    namespaceByName("The name of the namespace." name: String!): Namespace
    "Looks up a node by ID."
    node(id: ID!): Node
    "All available notebooks."
    notebooks(
        "Opaque pagination cursor."
        after: String
        "Filter to notebooks made by a single creator."
        creatorUserID: ID
        "Sort direction."
        descending: Boolean = false
        "Returns the first n notebooks from the list."
        first: Int = 50
        "Filter to notebooks associated with a specific namespace (user or org)."
        namespace: ID
        "Sort field."
        orderBy: NotebooksOrderBy = NOTEBOOK_UPDATED_AT
        "Query to filter notebooks by title and blocks content."
        query: String
        "Filter to notebooks that were starred by the user."
        starredByUserID: ID
    ): NotebookConnection!
    "Get started organization summary"
    orgMembersSummary("The organization ID" organization: ID!): OrgMembersSummary!
    "Looks up an organization by name."
    organization(name: String!): Org
    "Retrieve all organization feature flag overrides for the current user"
    organizationFeatureFlagOverrides: [FeatureFlagOverride!]!
    "Retrieve the value of a feature flag for the organization"
    organizationFeatureFlagValue(flagName: String!, orgID: ID!): Boolean!
    "List all organizations."
    organizations(
        "Returns the first n organizations from the list."
        first: Int
        "Return organizations whose names or display names match the query."
        query: String
    ): OrgConnection!
    "Retrieve all registered out-of-band migrations."
    outOfBandMigrations: [OutOfBandMigration!]!
    "(experimental) Return the parse tree of a search query."
    parseSearchQuery(
        "The parser to use for this query."
        patternType: SearchPatternType = literal
        "The search query (such as \"repo:myrepo foo\")."
        query: String = ""
    ): JSONValue
    "Get pending invitations for the specific organization"
    pendingInvitations("The organization ID" organization: ID!): [OrganizationInvitation!]!
    "Looks up a Phabricator repository by name."
    phabricatorRepo(
        "The name, for example \"github.com/gorilla/mux\"."
        name: String
        "An alias for name. DEPRECATED: use name instead."
        uri: String
    ): PhabricatorRepo
    """
    The set of repositories that match the given glob pattern. This resolver is used by the UI to
    preview what repositories match a code intelligence policy in a given repository.
    """
    previewRepositoryFilter(
        """
        When specified, indicates that this request should be paginated and
        to fetch results starting at this cursor.
        A future request can be made for more results by passing in the
        'RepositoryFilterPreview.pageInfo.endCursor' that is returned.
        """
        after: String
        """
        When specified, indicates that this request should be paginated and
        the first N results (relative to the cursor) should be returned. i.e.
        how many results to return per page.
        """
        first: Int
        "A set of patterns matching the name of the matching repository."
        patterns: [String!]!
    ): RepositoryFilterPreview!
    """
    Renders Markdown to HTML. The returned HTML is already sanitized and
    escaped and thus is always safe to render.
    """
    renderMarkdown(markdown: String!, options: MarkdownOptions): String!
    "List all repositories."
    repositories(
        "An opaque cursor that is used for pagination."
        after: String
        "Include cloned repositories."
        cloned: Boolean = true
        "Sort direction."
        descending: Boolean = false
        "Include repositories that have encountered errors when cloning or fetching"
        failedFetch: Boolean = false
        "Returns the first n repositories from the list."
        first: Int
        "Include repositories that have a text search index."
        indexed: Boolean = true
        "Return repositories whose names are in the list."
        names: [String!]
        "Include repositories that are not yet cloned and for which cloning is not in progress."
        notCloned: Boolean = true
        "Include repositories that do not have a text search index."
        notIndexed: Boolean = true
        "Sort field."
        orderBy: RepositoryOrderBy = REPOSITORY_NAME
        "Return repositories whose names match the query."
        query: String
    ): RepositoryConnection!
    "Looks up a repository by either name or cloneURL."
    repository(
        """
        Query the repository by a Git clone URL (format documented here: https://git-scm.com/docs/git-clone_git_urls_a_id_urls_a)
        by checking for a code host configuration that matches the clone URL.
        Will not actually check the code host to see if the repository actually exists.
        """
        cloneURL: String
        "Query the repository by name, for example \"github.com/gorilla/mux\"."
        name: String
        "An alias for name. DEPRECATED: use name instead."
        uri: String
    ): Repository
    """
    Looks up a repository by either name or cloneURL or hashedName. When the repository does not exist on the server
    and "disablePublicRepoRedirects" is "false" in the site configuration, it returns a Redirect to
    an external Sourcegraph URL that may have this repository instead. Otherwise, this query returns
    null.
    """
    repositoryRedirect(
        """
        Query the repository by a Git clone URL (format documented here: https://git-scm.com/docs/git-clone_git_urls_a_id_urls_a)
        by checking for a code host configuration that matches the clone URL.
        Will not actually check the code host to see if the repository actually exists.
        """
        cloneURL: String
        """
        Query the repository by hashed name.
        Hashed name is a SHA256 checksum of the absolute repo name in lower case,
        for example "github.com/sourcegraph/sourcegraph" -> "a6c905ceb7dec9a565945ceded8c7fa4154250df8b928fb40673b535d9a24c2f"
        """
        hashedName: String
        "Query the repository by name, for example \"github.com/gorilla/mux\"."
        name: String
    ): RepositoryRedirect
    "FOR INTERNAL USE ONLY: Query repository statistics for the site."
    repositoryStats: RepositoryStats!
    "The root of the query."
    root: Query! @deprecated(reason: "this will be removed.")
    "All saved searches configured for the current user, merged from all configurations."
    savedSearches: [SavedSearch!]!
    "Runs a search."
    search(
        """
        PatternType controls the search pattern type, if and only if it is not specified in the query string using
        the patternType: field.
        """
        patternType: SearchPatternType
        "The search query (such as \"foo\" or \"repo:myrepo foo\")."
        query: String = ""
        """
        The version of the search syntax being used.
        All new clients should use the latest version.
        """
        version: SearchVersion = V1
    ): Search
    "Fetch search context by spec (global, @username, @username/ctx, etc.)."
    searchContextBySpec(spec: String!): SearchContext
    "All available user-defined search contexts. Excludes auto-defined contexts."
    searchContexts(
        "Opaque pagination cursor."
        after: String
        "Sort direction."
        descending: Boolean = false
        "Returns the first n search contexts from the list."
        first: Int = 50
        """
        Include search contexts matching the provided namespaces. A union of all matching search contexts is returned.
        ID can either be a user ID, org ID, or nil to match instance-level contexts. Empty namespaces list
        defaults to returning all available search contexts.
        Example: `namespaces: [user1, org1, org2, nil]` will return search contexts created by user1 + contexts
        created by org1 + contexts created by org2 + all instance-level contexts.
        """
        namespaces: [ID] = []
        "Sort field."
        orderBy: SearchContextsOrderBy = SEARCH_CONTEXT_SPEC
        "Query to filter the search contexts by spec."
        query: String
    ): SearchContextConnection!
    "Generate an ephemeral time series for a Search based code insight, generally for the purposes of live preview."
    searchInsightLivePreview(input: SearchInsightLivePreviewInput!): [SearchInsightLivePreviewSeries!]!
    """
    Looks up an instance of a type that implements SettingsSubject (i.e., something that has settings). This can
    be a site (which has global settings), an organization, or a user.
    """
    settingsSubject(id: ID!): SettingsSubject
    "The current site."
    site: Site!
    "FOR INTERNAL USE ONLY: Lists all status messages"
    statusMessages: [StatusMessage!]!
    "Retrieve responses to surveys."
    surveyResponses("Returns the first n survey responses from the list." first: Int): SurveyResponseConnection!
    "Retrieves the temporary settings for the current user."
    temporarySettings: TemporarySettings!
    "Looks up a user by username or email address."
    user(
        "Query the user by verified email address."
        email: String
        "Query the user by username."
        username: String
    ): User
    "List all users."
    users(
        "Returns users who have been active in a given period of time."
        activePeriod: UserActivePeriod
        "Returns the first n users from the list."
        first: Int
        "Return users whose usernames or display names match the query."
        query: String
        "Return only users with the given tag."
        tag: String
    ): UserConnection!
    """
    Returns a list of usernames or emails that have associated pending permissions.
    The returned list can be used to query authorizedUserRepositories for pending permissions.
    """
    usersWithPendingPermissions: [String!]!
    "DEPRECATED"
    viewerConfiguration: ConfigurationCascade! @deprecated(reason: "use viewerSettings instead")
    "Retrieve the values of all feature flags for the current user"
    viewerFeatureFlags: [EvaluatedFeatureFlag!]!
    """
    The settings for the viewer. The viewer is either an anonymous visitor (in which case viewer settings is
    global settings) or an authenticated user (in which case viewer settings are the user's settings).
    """
    viewerSettings: SettingsCascade!
    """
    Returns recently received webhooks across all external services, optionally
    limiting the returned values to only those that didn't match any external
    service.

    Only site admins can access this field.
    """
    webhookLogs(
        "Opaque pagination cursor."
        after: String
        "Returns the first n webhook logs."
        first: Int
        "Only include webhook logs that resulted in errors."
        onlyErrors: Boolean
        "Only include webhook logs that were not matched to an external service."
        onlyUnmatched: Boolean
        "Only include webhook logs on or after this time."
        since: DateTime
        "Only include webhook logs on or before this time."
        until: DateTime
    ): WebhookLogConnection!
}

"Query block allows performing inline search queries within a notebook."
type QueryBlock {
    "ID of the block."
    id: String!
    "A Sourcegraph search query string."
    queryInput: String!
}

"The result for Mutation.randomizeUserPassword."
type RandomizeUserPasswordResult {
    """
    The reset password URL that the user must visit to sign into their account again. If the builtin
    username-password authentication provider is not enabled, this field's value is null.
    """
    resetPasswordURL: String
}

"A range inside a file. The start position is inclusive, and the end position is exclusive."
type Range {
    "The end position of the range (exclusive)."
    end: Position!
    "The start position of the range (inclusive)."
    start: Position!
}

"A reference to another Sourcegraph instance."
type Redirect {
    "The URL of the other Sourcegraph instance."
    url: String!
}

"An extension's listing in the extension registry."
type RegistryExtension implements Node {
    "The date when this extension was created on the registry."
    createdAt: DateTime
    """
    The qualified, unique name that refers to this extension, consisting of the registry name (if non-default),
    publisher's name, and the extension's name, all joined by "/" (for example, "acme-corp/my-extension-name").
    """
    extensionID: String!
    "The extension ID without the registry name."
    extensionIDWithoutRegistry: String!
    """
    The unique, opaque, permanent ID of the extension. Do not display this ID to the user; display
    RegistryExtension.extensionID instead (it is friendlier and still unique, but it can be renamed).
    """
    id: ID!
    "Whether the registry extension is published on this Sourcegraph site."
    isLocal: Boolean!
    "Whether the extension is marked as a work-in-progress extension by the extension author."
    isWorkInProgress: Boolean!
    "The extension manifest, or null if none is set."
    manifest: ExtensionManifest
    "The name of the extension (not including the publisher's name)."
    name: String!
    "The date when a release of this extension was most recently published, or null if there are no releases."
    publishedAt: DateTime
    "The publisher of the extension. If this extension is from a remote registry, the publisher may be null."
    publisher: RegistryPublisher
    "The name of this extension's registry."
    registryName: String!
    """
    The URL to the extension on the extension registry where it lives (if this is a remote
    extension). If this extension is local, then this field's value is null.
    """
    remoteURL: String
    """
    The date when this extension was last updated on the registry (including updates to its metadata only, not
    publishing new releases).
    """
    updatedAt: DateTime
    "The URL to the extension on this Sourcegraph site."
    url: String!
    """
    The UUID of the extension. This identifies the extension externally (along with the origin). The UUID maps
    1-to-1 to RegistryExtension.id.
    """
    uuid: String!
    "Whether the viewer has admin privileges on this registry extension."
    viewerCanAdminister: Boolean!
}

"A list of registry extensions."
type RegistryExtensionConnection {
    """
    Errors that occurred while communicating with remote registries to obtain the list of extensions.
    In order to be able to return local extensions even when the remote registry is unreachable, errors are
    recorded here instead of in the top-level GraphQL errors list.
    """
    error: String
    "A list of registry extensions."
    nodes: [RegistryExtension!]!
    "Pagination information."
    pageInfo: PageInfo!
    """
    The total count of registry extensions in the connection. This total count may be larger than the number of
    nodes in this object when the result is paginated.
    """
    totalCount: Int!
    "The URL to this list, or null if none exists."
    url: String
}

"A list of publishers of extensions in the registry."
type RegistryPublisherConnection {
    "A list of publishers."
    nodes: [RegistryPublisher!]!
    "Pagination information."
    pageInfo: PageInfo!
    """
    The total count of publishers in the connection. This total count may be larger than the number of
    nodes in this object when the result is paginated.
    """
    totalCount: Int!
}

"Stats on all the changesets that have been applied to this repository by batch changes."
type RepoChangesetsStats {
    "The count of closed changesets."
    closed: Int!
    "The count of draft changesets."
    draft: Int!
    "The count of merged changesets."
    merged: Int!
    "The count of open changesets."
    open: Int!
    "The count of all changesets."
    total: Int!
    "The count of unpublished changesets."
    unpublished: Int!
}

"A repository is a Git source control repository that is mirrored from some origin code host."
type Repository implements GenericSearchResultInterface & Node {
    """
    A list of authorized users to access this repository with the given permission.
    This API currently only returns permissions from the Sourcegraph provider, i.e.
    "permissions.userMapping" in site configuration.
    """
    authorizedUsers(
        "Opaque pagination cursor."
        after: String
        "Number of users to return after the given cursor."
        first: Int!
        "Permission that the user has on this repository."
        permission: RepositoryPermission = READ
    ): UserConnection!
    "A list of batch changes that have applied a changeset to this repository."
    batchChanges(
        "Opaque pagination cursor."
        after: String
        "Returns the first n batch changes from the list."
        first: Int = 50
        "Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`."
        state: BatchChangeState
        "Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it."
        states: [BatchChangeState!]
        "Only include batch changes that the viewer can administer."
        viewerCanAdminister: Boolean
    ): BatchChangeConnection!
    """
    A diff stat for all the changesets that have been applied to this repository
    by batch changes.
    """
    batchChangesDiffStat: DiffStat!
    "The repository's Git branches."
    branches(
        "Returns the first n Git branches from the list."
        first: Int
        """
        Ordering is an expensive operation that doesn't scale for lots of
        references. If this is true we fallback on not ordering. This should
        never be false in interactive API requests.
        """
        interactive: Boolean = true
        "Ordering for Git branches in the list."
        orderBy: GitRefOrder
        "Return Git branches whose names match the query."
        query: String
    ): GitRefConnection!
    """
    Stats on all the changesets that have been created in this repository by batch
    changes.
    """
    changesetsStats: RepoChangesetsStats!
    "Whether the repository is currently being cloned."
    cloneInProgress: Boolean! @deprecated(reason: "use Repository.mirrorInfo.cloneInProgress instead")
    "Provides a summary of the most reecent upload and index status."
    codeIntelSummary: CodeIntelRepositorySummary!
    """
    Information and status related to the commit graph of this repository calculated
    for use by code intelligence features.
    """
    codeIntelligenceCommitGraph: CodeIntelligenceCommitGraph!
    "Returns information about the given commit in the repository, or null if no commit exists with the given rev."
    commit(
        """
        Optional input revspec used to construct non-canonical URLs and other "friendly" field values. Used by
        clients that must ensure consistency of revision resolution within a session/request (so they use full
        SHAs) but also preserve the user input rev (for user friendliness).
        """
        inputRevspec: String
        "The Git revision specifier (revspec) for the commit."
        rev: String!
    ): GitCommit
    "A Git comparison in this repository between a base and head commit."
    comparison(
        "The base of the diff (\"old\" or \"left-hand side\"), or \"HEAD\" if not specified."
        base: String
        "Attempt to fetch missing revisions from remote if they are not found"
        fetchMissing: Boolean = true
        "The head of the diff (\"new\" or \"right-hand side\"), or \"HEAD\" if not specified."
        head: String
    ): RepositoryComparison!
    "The repository's contributors."
    contributors(
        "The date after which to count contributions."
        after: String
        "Returns the first n contributors from the list."
        first: Int
        "Return contributors to files in this path."
        path: String
        "The Git revision range to compute contributors in."
        revisionRange: String
    ): RepositoryContributorConnection!
    """
    DEPRECATED: This field is unused in known clients.
    The date when this repository was created on Sourcegraph.
    """
    createdAt: DateTime!
    """
    The repository's default Git branch (HEAD symbolic ref). If the repository is currently being cloned or is
    empty, this field will be null.
    """
    defaultBranch: GitRef
    "The repository's description."
    description: String!
    "A markdown string of that is rendered less prominently."
    detail: Markdown!
    """
    Information about this repository from the external service that it originates from (such as GitHub, GitLab,
    Phabricator, etc.).
    """
    externalRepository: ExternalRepository!
    "Lists all external services which yield this repository."
    externalServices("Returns the first n external services from the list." first: Int): ExternalServiceConnection!
    "The URLs to this repository on external services associated with it."
    externalURLs: [ExternalLink!]!
    "The repository's Git refs."
    gitRefs(
        "Returns the first n Git refs from the list."
        first: Int
        """
        Ordering is an expensive operation that doesn't scale for lots of
        references. If this is true we fallback on not ordering. This should
        never be false in interactive API requests.
        """
        interactive: Boolean = true
        "Ordering for Git refs in the list."
        orderBy: GitRefOrder
        "Return Git refs whose names match the query."
        query: String
        """
        Return only Git refs of the given type.
        Known issue: It is only supported to retrieve Git branch and tag refs, not
        other Git refs.
        """
        type: GitRefType
    ): GitRefConnection!
    "The repository's unique ID."
    id: ID!
    "Gets the indexing configuration associated with the repository."
    indexConfiguration: IndexConfiguration
    "Whether the repository has been archived."
    isArchived: Boolean!
    "Whether the repository is a fork."
    isFork: Boolean!
    "Whether the repository is private."
    isPrivate: Boolean!
    "A markdown string that is rendered prominently."
    label: Markdown!
    "The primary programming language in the repository."
    language: String!
    "The repository's LSIF uploads."
    lsifIndexes(
        """
        When specified, indicates that this request should be paginated and
        to fetch results starting at this cursor.
        A future request can be made for more results by passing in the
        'LSIFIndexConnection.pageInfo.endCursor' that is returned.
        """
        after: String
        """
        When specified, indicates that this request should be paginated and
        the first N results (relative to the cursor) should be returned. i.e.
        how many results to return per page.
        """
        first: Int
        """
        An (optional) search query that searches over the state, repository name,
        and commit properties.
        """
        query: String
        "The state of returned uploads."
        state: LSIFIndexState
    ): LSIFIndexConnection!
    "The repository's LSIF uploads."
    lsifUploads(
        """
        When specified, indicates that this request should be paginated and
        to fetch results starting at this cursor.
        A future request can be made for more results by passing in the
        'LSIFUploadConnection.pageInfo.endCursor' that is returned.
        """
        after: String
        "When specified, shows only uploads that are a dependency of the specified upload."
        dependencyOf: ID
        "When specified, shows only uploads that are a dependent of the specified upload."
        dependentOf: ID
        """
        When specified, indicates that this request should be paginated and
        the first N results (relative to the cursor) should be returned. i.e.
        how many results to return per page.
        """
        first: Int
        "When specified, shows only uploads that are latest for the given repository."
        isLatestForRepo: Boolean
        """
        An (optional) search query that searches over the state, repository name,
        commit, root, and indexer properties.
        """
        query: String
        "The state of returned uploads."
        state: LSIFUploadState
    ): LSIFUploadConnection!
    "The result previews of the result."
    matches: [SearchResultMatch!]!
    """
    Information and status related to mirroring, if this repository is a mirror of another repository (e.g., on
    some code host). In this case, the remote source repository is external to Sourcegraph and the mirror is
    maintained by the Sourcegraph site (not the other way around).
    """
    mirrorInfo: MirrorRepositoryInfo!
    """
    The repository's name, as a path with one or more components. It conventionally consists of
    the repository's hostname and path (joined by "/"), minus any suffixes (such as ".git").
    Examples:
    - github.com/foo/bar
    - my-code-host.example.com/myrepo
    - myrepo
    """
    name: String!
    """
    The permissions information of the repository for the authenticated user.
    It is null when there is no permissions data stored for the repository.
    """
    permissionsInfo: PermissionsInfo
    """
    The set of git objects that match the given git object type and glob pattern.
    This resolver is used by the UI to preview what names match a code intelligence
    policy in a given repository.
    """
    previewGitObjectFilter(
        "A pattern matching the name of the matching Git object."
        pattern: String!
        "The type of Git object described by the configuration policy."
        type: GitObjectType!
    ): [GitObjectFilterPreview!]!
    "The star count the repository has in the code host."
    stars: Int!
    "The repository's Git tags."
    tags(
        "Returns the first n Git tags from the list."
        first: Int
        "Return Git tags whose names match the query."
        query: String
    ): GitRefConnection!
    """
    Information about the text search index for this repository, or null if text search indexing
    is not enabled or supported for this repository.
    """
    textSearchIndex: RepositoryTextSearchIndex
    """
    DEPRECATED: This field is unused in known clients.
    The date when this repository's metadata was last updated on Sourcegraph.
    """
    updatedAt: DateTime
    "DEPRECATED: Use name."
    uri: String! @deprecated(reason: "Use name.")
    "The URL to this repository."
    url: String!
    "Whether the viewer has admin privileges on this repository."
    viewerCanAdminister: Boolean!
}

"The differences between two concrete Git commits in a repository."
type RepositoryComparison {
    "The repository that is the base (left-hand side) of this comparison."
    baseRepository: Repository!
    "The commits in the comparison range, excluding the base and including the head."
    commits("Return the first n commits from the list." first: Int): GitCommitConnection!
    "The file diffs for each changed file."
    fileDiffs(
        "Return file diffs after the given cursor."
        after: String
        "Return the first n file diffs from the list."
        first: Int
    ): FileDiffConnection!
    """
    The repository that is the head (right-hand side) of this comparison. Cross-repository
    comparisons are not yet supported, so this is always equal to
    RepositoryComparison.baseRepository.
    """
    headRepository: Repository!
    "The range that this comparison represents."
    range: GitRevisionRange!
}

"A list of repositories."
type RepositoryConnection {
    "A list of repositories."
    nodes: [Repository!]!
    "Pagination information."
    pageInfo: PageInfo!
    """
    The total count of repositories in the connection. This total count may be larger
    than the number of nodes in this object when the result is paginated.
    This requires admin permissions and will return null for all non-admin users.
    In some cases, the total count can't be computed quickly; if so, it is null. Pass
    precise: true to always compute total counts even if it takes a while.
    """
    totalCount(precise: Boolean = false): Int
}

"A contributor to a repository."
type RepositoryContributor {
    "Commits by the contributor."
    commits("Return the first n commits." first: Int): GitCommitConnection!
    "The number of contributions made by this contributor."
    count: Int!
    "The personal information for the contributor."
    person: Person!
    "The repository in which the contributions occurred."
    repository: Repository!
}

"A list of contributors to a repository."
type RepositoryContributorConnection {
    "A list of contributors to a repository."
    nodes: [RepositoryContributor!]!
    "Pagination information."
    pageInfo: PageInfo!
    """
    The total count of contributors in the connection, if available. This total count may be larger than the
    number of nodes in this object when the result is paginated.
    """
    totalCount: Int!
}

"A decorated connection of repositories resulting from 'previewRepositoryFilter'."
type RepositoryFilterPreview {
    "The maximum number of repository matches a single policy can make."
    limit: Int
    "A list of repositories composing the current page."
    nodes: [Repository!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of repositories in this result set."
    totalCount: Int!
    """
    The number of repositories matching the given filter. This value exceeds the
    value of totalCount of the result when totalMatches > limit.
    """
    totalMatches: Int!
}

"FOR INTERNAL USE ONLY: A repository statistic"
type RepositoryStats {
    "The amount of bytes stored in .git directories"
    gitDirBytes: BigInt!
    "The number of lines indexed"
    indexedLinesCount: BigInt!
}

"Information about a repository's text search index."
type RepositoryTextSearchIndex {
    "Git refs in the repository that are configured for text search indexing."
    refs: [RepositoryTextSearchIndexedRef!]!
    "The indexed repository."
    repository: Repository!
    "The status of the text search index, if available."
    status: RepositoryTextSearchIndexStatus
}

"The status of a repository's text search index."
type RepositoryTextSearchIndexStatus {
    "The byte size of the original content."
    contentByteSize: BigInt!
    "The number of files in the original content."
    contentFilesCount: Int!
    "EXPERIMENTAL: The number of newlines in the default branch."
    defaultBranchNewLinesCount: Int!
    "The byte size of the index."
    indexByteSize: Int!
    "The number of index shards."
    indexShardsCount: Int!
    "EXPERIMENTAL: The number of newlines appearing in the index."
    newLinesCount: Int!
    "EXPERIMENTAL: The number of newlines in the other branches."
    otherBranchesNewLinesCount: Int!
    "The date that the index was last updated."
    updatedAt: DateTime!
}

"A Git ref (usually a branch) in a repository that is configured to be indexed for text search."
type RepositoryTextSearchIndexedRef {
    "Whether the text search index is of the current commit for the Git ref. If false, the index is stale."
    current: Boolean!
    "Whether a text search index exists for this ref."
    indexed: Boolean!
    """
    The indexed Git commit (which may differ from the ref's current target if the index is out of date). If
    indexed is false, this field's value is null.
    """
    indexedCommit: GitObject
    """
    The Git ref (usually a branch) that is configured to be indexed for text search. To find the specific commit
    SHA that was indexed, use RepositoryTextSearchIndexedRef.indexedCommit; this field's ref target resolves to
    the current target, not the target at the time of indexing.
    """
    ref: GitRef!
}

"A saved search query, defined in settings."
type SavedSearch implements Node {
    "The description."
    description: String!
    "The unique ID of this saved query."
    id: ID!
    "The user or org that owns this saved search."
    namespace: Namespace!
    """
    Whether or not to notify the owner of the saved search via email. This owner is either
    a single user, or every member of an organization that owns the saved search.
    """
    notify: Boolean!
    "Whether or not to notify on Slack."
    notifySlack: Boolean!
    "The query."
    query: String!
    "The Slack webhook URL associated with this saved search, if any."
    slackWebhookURL: String
}

"A search."
type Search {
    "The results."
    results: SearchResults!
    """
    A subset of results (excluding actual search results) which are heavily
    cached and thus quicker to query. Useful for e.g. querying sparkline
    data.
    """
    stats: SearchResultsStats!
}

"A search-related alert message."
type SearchAlert {
    "The description."
    description: String
    "\"Did you mean: ____\" query proposals"
    proposedQueries: [SearchQueryDescription!]
    "The title."
    title: String!
}

"Details search-based code-intel support overview."
type SearchBasedCodeIntelSupport {
    """
    The infered language the underlying tool infered when building an index for
    search-based code-intel.
    """
    language: String!
    "Level of support."
    supportLevel: SearchBasedSupportLevel!
}

"A search context. Specifies a set of repositories to be searched."
type SearchContext implements Node {
    """
    Whether the search context is autodefined by Sourcegraph. Current examples include:
    global search context ("global"), default user search context ("@user"), and
    default organization search context ("@org").
    """
    autoDefined: Boolean!
    "The description of the search context."
    description: String!
    "The unique id of the search context."
    id: ID!
    "The name of the search context."
    name: String!
    "The owner (user or org) of the search context. If nil, search context is considered instance-level."
    namespace: Namespace
    """
    Public property controls the visibility of the search context. Public search context is available to
    any user on the instance. If a public search context contains private repositories, those are filtered out
    for unauthorized users. Private search contexts are only available to their owners. Private user search context
    is available only to the user, private org search context is available only to the members of the org, and private
    instance-level search contexts are available only to site-admins.
    """
    public: Boolean!
    """
    Sourcegraph search query that defines the search context.
    e.g. "r:^github\.com/org (rev:bar or rev:HEAD) file:^sub/dir"
    """
    query: String!
    "Repositories and their revisions that will be searched when querying."
    repositories: [SearchContextRepositoryRevisions!]!
    """
    Fully-qualified search context spec for use when querying.
    Examples: global, @username, @username/ctx, and @org/ctx.
    """
    spec: String!
    "Date and time the search context was last updated."
    updatedAt: DateTime!
    "If current viewer can manage (edit, delete) the search context."
    viewerCanManage: Boolean!
}

"A list of search contexts"
type SearchContextConnection {
    "A list of search contexts."
    nodes: [SearchContext!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of search contexts in the connection."
    totalCount: Int!
}

"Specifies a set of revisions to be searched within a repository."
type SearchContextRepositoryRevisions {
    "The repository to be searched."
    repository: Repository!
    "The set of revisions to be searched."
    revisions: [String!]!
}

"A search filter."
type SearchFilter {
    "Number of matches for a given filter."
    count: Int!
    "The kind of filter. Should be \"file\" or \"repo\"."
    kind: String!
    "The string to be displayed in the UI."
    label: String!
    "Whether the results returned are incomplete."
    limitHit: Boolean!
    "The value."
    value: String!
}

"Defines an insight data series that is constructed from a Sourcegraph search query."
type SearchInsightDataSeriesDefinition {
    "Whether or not the the time series are derived from the captured groups of the search results."
    generatedFromCaptureGroups: Boolean!
    """
    Whether or not the series has been pre-calculated, or still needs to be resolved. This field is largely only used
    for the code insights webapp, and should be considered unstable (planned to be deprecated in a future release).
    """
    isCalculated: Boolean!
    "The query string."
    query: String!
    "A scope of repositories defined for this insight."
    repositoryScope: InsightRepositoryScope!
    "Unique ID for the series."
    seriesId: String!
    "The scope of time for which the insight data is generated."
    timeScope: InsightTimeScope!
}

"Input object for a live preview search based code insight."
type SearchInsightLivePreviewSeries {
    "The label for the data series."
    label: String!
    "The data points for the time series."
    points: [InsightDataPoint!]!
}

"A search query description."
type SearchQueryDescription {
    "The description."
    description: String
    "The query."
    query: String!
}

"A match in a search result. Matches make up the body content of a search result."
type SearchResultMatch {
    "A markdown string containing the preview contents of the result match."
    body: Markdown!
    """
    A list of highlights that specify locations of matches of the query in the body. Each highlight is
    a line number, character offset, and length. Currently, highlights are only displayed on match bodies
    that are code blocks. If the result body is a code block, exclude the markdown code fence lines in
    the line and character count. Leave as an empty list if no highlights are available.
    """
    highlights: [Highlight!]!
    "URL for the individual result match."
    url: String!
}

"Search results."
type SearchResults {
    "An alert message that should be displayed before any results."
    alert: SearchAlert
    """
    The approximate number of results. This is like the length of the results
    array, except it can indicate the number of results regardless of whether
    or not the limit was hit. Currently, this is represented as e.g. "5+"
    results.
    This string is typically shown to users to indicate the true result count.
    """
    approximateResultCount: String!
    """
    Repositories that are busy cloning onto gitserver.
    In paginated search requests, some repositories may be cloning. These are reported here
    and you may choose to retry the paginated request with the same cursor after they have
    cloned OR you may simply continue making further paginated requests and choose to skip
    the cloning repositories.
    """
    cloning: [Repository!]!
    "Dynamic filters generated by the search results"
    dynamicFilters: [SearchFilter!]!
    "The time it took to generate these results."
    elapsedMilliseconds: Int!
    """
    DEPRECATED: This field is not used in known clients, and will always return `false`.
    True if indexed search is enabled but was not available during this search.
    """
    indexUnavailable: Boolean!
    """
    Whether or not the results limit was hit.
    In paginated requests, this field is always false. Use 'pageInfo.hasNextPage' instead.
    """
    limitHit: Boolean!
    """
    The total number of matches returned by this search. This is different
    than the length of the results array in that e.g. a single results array
    entry may contain multiple matches. For example, the results array may
    contain two file matches and this field would report 6 ("3 line matches
    per file") while the length of the results array would report 3
    ("3 FileMatch results").
    Typically, 'approximateResultCount', not this field, is shown to users.
    """
    matchCount: Int!
    """
    Repositories or commits that do not exist.
    In paginated search requests, some repositories may be missing (e.g. if Sourcegraph is
    aware of them but is temporarily unable to serve them). These are reported here and you
    may choose to retry the paginated request with the same cursor and they may no longer be
    missing OR you may simply continue making further paginated requests and choose to skip
    the missing repositories.
    """
    missing: [Repository!]!
    "Repositories from results."
    repositories: [Repository!]!
    """
    The number of repositories that had results (for clients
    that just wish to know how many without querying the, sometimes extremely
    large, list).
    """
    repositoriesCount: Int!
    "DEPRECATED: Renamed to 'matchCount' for less ambiguity."
    resultCount: Int! @deprecated(reason: "renamed to matchCount for less ambiguity")
    """
    The results. Inside each SearchResult there may be multiple matches, e.g.
    a FileMatch may contain multiple line matches.
    """
    results: [SearchResult!]!
    "Integers representing the sparkline for the search results."
    sparkline: [Int!]!
    """
    Repositories or commits which we did not manage to search in time. Trying
    again usually will work.
    In paginated search requests, this field is not relevant.
    """
    timedout: [Repository!]!
}

"Statistics about search results."
type SearchResultsStats {
    "The approximate number of results returned."
    approximateResultCount: String!
    """
    Statistics about the languages represented in the search results.
    Known issue: The LanguageStatistics.totalBytes field values are incorrect in the result.
    """
    languages: [LanguageStatistics!]!
    "The sparkline."
    sparkline: [Int!]!
}

"An active user session."
type Session {
    "Whether the user can sign out of this session on Sourcegraph."
    canSignOut: Boolean!
}

"Settings is a version of a configuration settings file."
type Settings {
    "The author, or null if there is no author or the authoring user was deleted."
    author: User
    """
    DEPRECATED: This field will be removed in a future release.
    The configuration.
    """
    configuration: Configuration! @deprecated(reason: "use the contents field instead")
    """
    The stringified JSON contents of the settings. The contents may include "//"-style comments and trailing
    commas in the JSON.
    """
    contents: JSONCString!
    "The time when this was created."
    createdAt: DateTime!
    "The ID."
    id: Int!
    "The subject that these settings are for."
    subject: SettingsSubject!
}

"The configurations for all of the relevant settings subjects, plus the merged settings."
type SettingsCascade {
    "The effective final merged settings as (stringified) JSON, merged from all of the subjects."
    final: String!
    """
    DEPRECATED: This field will be removed in a future release.
    The effective final merged settings, merged from all of the subjects.
    """
    merged: Configuration! @deprecated(reason: "use final instead")
    """
    The other settings subjects that are applied with lower precedence than this subject to
    form the final merged settings. For example, a user in 2 organizations would have the following
    settings subjects: site (global settings), org 1, org 2, and the user.
    """
    subjects: [SettingsSubject!]!
}

"""
Mutations that update settings (global, organization, or user settings). These mutations are grouped together
because they:
- are all versioned to avoid race conditions with concurrent editors
- all apply to a specific settings subject (i.e., a user, an organization, or the whole site)

Grouping them lets us extract those common parameters to the Mutation.settingsMutation field.
"""
type SettingsMutation {
    "DEPRECATED"
    editConfiguration(edit: ConfigurationEdit!): UpdateSettingsPayload
        @deprecated(
            reason: "Use editSettings instead. This field is a deprecated alias for it and will be removed in a future release."
        )
    "Edit a single property in the settings object."
    editSettings("The edit to apply to the settings." edit: SettingsEdit!): UpdateSettingsPayload
    "Overwrite the existing settings with the new settings."
    overwriteSettings(
        """
        A JSON object (stringified) of the settings. Trailing commas and "//"-style comments are supported. The
        entire previous settings value will be overwritten by this new value.
        """
        contents: String!
    ): UpdateSettingsPayload
}

"A signature."
type Signature {
    "The date."
    date: String!
    "The person."
    person: Person!
}

"""
A site is an installation of Sourcegraph that consists of one or more
servers that share the same configuration and database.
The site is a singleton; the API only ever returns the single global site.
"""
type Site implements SettingsSubject {
    "A list of all access tokens on this site."
    accessTokens("Returns the first n access tokens from the list." first: Int): AccessTokenConnection!
    "Alerts to display to the viewer."
    alerts: [Alert!]!
    """
    Whether changes can be made to site settings through the API. When global settings are configured through
    the GLOBAL_SETTINGS_FILE environment variable, site settings edits cannot be made through the API.
    """
    allowSiteSettingsEdits: Boolean!
    """
    A list of all authentication providers. This information is visible to all viewers and does not contain any
    secret information.
    """
    authProviders: AuthProviderConnection!
    """
    The build version of the Sourcegraph software that is running on this site (of the form
    NNNNN_YYYY-MM-DD_XXXXX, like 12345_2018-01-01_abcdef).
    """
    buildVersion: String!
    "Whether the viewer can reload the site (with the reloadSite mutation)."
    canReloadSite: Boolean!
    "The site's configuration. Only visible to site admins."
    configuration: SiteConfiguration!
    "DEPRECATED"
    configurationCascade: ConfigurationCascade!
        @deprecated(
            reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release."
        )
    "Whether we want to show built-in searches on the saved searches page"
    disableBuiltInSearches: Boolean!
    "A list of all user external accounts on this site."
    externalAccounts(
        "Include only external accounts with this client ID."
        clientID: String
        "Returns the first n external accounts from the list."
        first: Int
        "Include only external accounts with this service ID."
        serviceID: String
        "Include only external accounts with this service type."
        serviceType: String
        "Include only external accounts associated with this user."
        user: ID
    ): ExternalAccountConnection!
    """
    Whether the site is over the limit for free user accounts, and a warning needs to be shown to all users.
    Only applies if the site does not have a valid license.
    """
    freeUsersExceeded: Boolean!
    "BACKCOMPAT: Always returns true."
    hasCodeIntelligence: Boolean!
    """
    The site's opaque GraphQL ID. This is NOT the "site ID" as it is referred to elsewhere;
    use the siteID field for that. (GraphQL node types conventionally have an id field of type
    ID! that globally identifies the node.)
    """
    id: ID!
    """
    The site's latest site-wide settings (which are the second-lowest-precedence
    in the configuration cascade for a user).
    """
    latestSettings: Settings
    """
    Monitoring overview for this site.
    Note: This is primarily used for displaying recently-fired alerts in the web app. If your intent
    is to monitor Sourcegraph, it is better to configure alerting or query Prometheus directly in
    order to ensure that if the frontend goes down you still recieve alerts:
    Configure alerting: https://docs.sourcegraph.com/admin/observability/alerting
    Query Prometheus directly: https://docs.sourcegraph.com/admin/observability/alerting_custom_consumption
    """
    monitoringStatistics("Days of history (based on current UTC time)." days: Int): MonitoringStatistics!
    "Whether the site needs to be configured to add repositories."
    needsRepositoryConfiguration: Boolean!
    "Information about this site's product subscription status."
    productSubscription: ProductSubscriptionStatus!
    "The product version of the Sourcegraph software that is running on this site."
    productVersion: String!
    """
    Whether the server sends emails to users to verify email addresses. If false, then site admins must manually
    verify users' email addresses.
    """
    sendsEmailVerificationEmails: Boolean!
    """
    The global settings for this site, and the final merged settings.
    All viewers can access this field.
    """
    settingsCascade: SettingsCascade!
    "The URL to the site's settings."
    settingsURL: String
    "The site ID."
    siteID: String!
    "Information about software updates for the version of Sourcegraph that this site is running."
    updateCheck: UpdateCheck!
    "Usage statistics for this site."
    usageStatistics(
        "Days of history (based on current UTC time)."
        days: Int
        "Months of history (based on current UTC time)."
        months: Int
        "Weeks of history (based on current UTC time)."
        weeks: Int
    ): SiteUsageStatistics!
    "Whether the viewer can modify the subject's settings."
    viewerCanAdminister: Boolean!
}

"The configuration for a site."
type SiteConfiguration {
    "The effective configuration JSON."
    effectiveContents: JSONCString!
    "The unique identifier of this site configuration version."
    id: Int!
    """
    Messages describing validation problems or usage of deprecated configuration in the configuration JSON.
    This includes both JSON Schema validation problems and other messages that perform more advanced checks
    on the configuration (that can't be expressed in the JSON Schema).
    """
    validationMessages: [String!]!
}

"""
SiteUsagePeriod describes a site's usage statistics for a given timespan.
This information is visible to all viewers.
"""
type SiteUsagePeriod {
    "The anonymous user count."
    anonymousUserCount: Int!
    """
    The count of registered users that have been active on a code host integration.
    Excludes anonymous users.
    """
    integrationUserCount: Int!
    "The registered user count."
    registeredUserCount: Int!
    "The time when this started."
    startTime: String!
    "The user count."
    userCount: Int!
}

"""
SiteUsageStatistics describes a site's aggregate usage statistics.
This information is visible to all viewers.
"""
type SiteUsageStatistics {
    "Recent daily active users."
    daus: [SiteUsagePeriod!]!
    "Recent monthly active users."
    maus: [SiteUsagePeriod!]!
    "Recent weekly active users."
    waus: [SiteUsagePeriod!]!
}

"A Git submodule"
type Submodule {
    "The commit of the submodule."
    commit: String!
    "The path to which the submodule is checked out."
    path: String!
    "The remote repository URL of the submodule."
    url: String!
}

"An individual response to a user satisfaction (NPS) survey."
type SurveyResponse {
    "The answer to \"What can Sourcegraph do to provide a better product\""
    better: String
    "The time when this response was created."
    createdAt: DateTime!
    "The email that the user manually entered (if they were NOT authenticated at the time)."
    email: String
    "The unique ID of the survey response"
    id: ID!
    "The answer to \"What is the most important reason for the score you gave\"."
    reason: String
    "User's likelihood of recommending Sourcegraph to a friend, from 0-10."
    score: Int!
    "The user who submitted the survey (if they were authenticated at the time)."
    user: User
}

"A list of survey responses"
type SurveyResponseConnection {
    "The average score of survey responses in the connection submitted since 30 calendar days ago at 00:00 UTC."
    averageScore: Float!
    "The count of survey responses submitted since 30 calendar days ago at 00:00 UTC."
    last30DaysCount: Int!
    """
    The net promoter score (NPS) of survey responses in the connection submitted since 30 calendar days ago at 00:00 UTC.
    Return value is a signed integer, scaled from -100 (all detractors) to +100 (all promoters).
    See https://en.wikipedia.org/wiki/Net_Promoter for explanation.
    """
    netPromoterScore: Int!
    "A list of survey responses."
    nodes: [SurveyResponse!]!
    """
    The total count of survey responses in the connection. This total count may be larger
    than the number of nodes in this object when the result is paginated.
    """
    totalCount: Int!
}

"""
A code symbol (e.g., a function, variable, type, class, etc.).
It is derived from DocumentSymbol as defined in the Language Server Protocol (see https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_documentSymbol).
"""
type Symbol {
    "The canonical URL to this symbol (using an immutable revision specifier)."
    canonicalURL: String!
    """
    The name of the symbol that contains this symbol, if any. This field's value is not guaranteed to be
    structured in such a way that callers can infer a hierarchy of symbols.
    """
    containerName: String
    "Whether or not the symbol is local to the file it's defined in."
    fileLocal: Boolean!
    "The kind of the symbol."
    kind: SymbolKind!
    "The programming language of the symbol."
    language: String!
    "The location where this symbol is defined."
    location: Location!
    "The name of the symbol."
    name: String!
    "The URL to this symbol (using the input revision specifier, which may not be immutable)."
    url: String!
}

"FileBlock specifies a symbol to display within the block."
type SymbolBlock {
    "ID of the block."
    id: String!
    "Symbol block input."
    symbolInput: SymbolBlockInput!
}

"SymbolBlockInput contains the information necessary to find the symbol."
type SymbolBlockInput {
    "Path within the repository, e.g. \"client/web/file.tsx\"."
    filePath: String!
    "Number of lines to show before and after the matched symbol line."
    lineContext: Int!
    "Name of the repository, e.g. \"github.com/sourcegraph/sourcegraph\"."
    repositoryName: String!
    """
    An optional revision, e.g. "pr/feature-1", "a9505a2947d3df53558e8c88ff8bcef390fc4e3e".
    If omitted, we use the latest revision (HEAD).
    """
    revision: String
    "Name of the symbol container."
    symbolContainerName: String!
    "The symbol kind."
    symbolKind: SymbolKind!
    "The symbol name."
    symbolName: String!
}

"A list of symbols."
type SymbolConnection {
    "A list of symbols."
    nodes: [Symbol!]!
    "Pagination information."
    pageInfo: PageInfo!
}

"""
FOR INTERNAL USE ONLY: A status message produced when repositories could not
be synced
"""
type SyncError {
    "The message of this status message"
    message: String!
}

"Temporary settings for a user."
type TemporarySettings {
    "A JSON string representing the temporary settings."
    contents: String!
}

"Information about software updates for Sourcegraph."
type UpdateCheck {
    """
    When the last update check was completed, or null if no update check has
    been completed (or performed) yet.
    """
    checkedAt: DateTime
    """
    If an error occurred during the last update check, this message describes
    the error.
    """
    errorMessage: String
    "Whether an update check is currently in progress."
    pending: Boolean!
    "If an update is available, the version string of the updated version."
    updateVersionAvailable: String
}

"The state of a repository in the update queue."
type UpdateQueue {
    """
    The index of the repo in the update queue.
    Updating repos are placed at the end of the queue until they finish updating
    so don't display this if updating is true.
    """
    index: Int!
    "The total number of repos in the update queue (including updating repos)."
    total: Int!
    "True if the repo is currently updating."
    updating: Boolean!
}

"The state of a repository in the update schedule."
type UpdateSchedule {
    "The next time that the repo will be inserted into the update queue."
    due: DateTime!
    "The index of the repo in the schedule."
    index: Int!
    "The interval that was used when scheduling the current due time."
    intervalSeconds: Int!
    "The total number of repos in the schedule."
    total: Int!
}

"The payload for SettingsMutation.updateConfiguration."
type UpdateSettingsPayload {
    "An empty response."
    empty: EmptyResponse
}

"A user."
type User implements Namespace & Node & SettingsSubject {
    """
    The user's access tokens (which grant to the holder the privileges of the user). This consists
    of all access tokens whose subject is this user.
    Only the user and site admins can access this field.
    """
    accessTokens("Returns the first n access tokens from the list." first: Int): AccessTokenConnection!
    "The URL of the user's avatar image."
    avatarURL: String
    "A list of batch changes applied under this user's namespace."
    batchChanges(
        "Opaque pagination cursor."
        after: String
        "Returns the first n batch changes from the list."
        first: Int = 50
        "Only return batch changes in this state. If `states` is also specified, it will take precedence over `state`."
        state: BatchChangeState
        "Only return batch changes in any of these states. If `state` is also specified, `states` will take precedence over it."
        states: [BatchChangeState!]
        "Only include batch changes that the viewer can administer."
        viewerCanAdminister: Boolean
    ): BatchChangeConnection!
    """
    Returns a connection of configured external services accessible by this user, for usage with batch changes.
    These are all code hosts configured on the Sourcegraph instance that are supported by batch changes. They are
    connected to BatchChangesCredential resources, if one has been created for the code host connection before.
    """
    batchChangesCodeHosts(
        "Opaque pagination cursor."
        after: String
        "Returns the first n code hosts from the list."
        first: Int = 50
    ): BatchChangesCodeHostConnection!
    "Whether the user account uses built in auth."
    builtinAuth: Boolean!
    "DEPRECATED"
    configurationCascade: ConfigurationCascade!
        @deprecated(
            reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release."
        )
    "The date when the user account was created on Sourcegraph."
    createdAt: DateTime!
    """
    The unique numeric ID for the user.
    FOR INTERNAL USE ONLY.
    """
    databaseID: Int!
    "The display name chosen by the user."
    displayName: String
    """
    The user's primary email address.
    Only the user and site admins can access this field.
    """
    email: String! @deprecated(reason: "use emails instead")
    """
    The user's email addresses.
    Only the user and site admins can access this field.
    """
    emails: [UserEmail!]!
    "The user's events on Sourcegraph."
    eventLogs(
        "Only return events matching this event name"
        eventName: String
        "Returns the first n event logs from the list."
        first: Int
    ): EventLogsConnection!
    "A list of external accounts that are associated with the user."
    externalAccounts("Returns the first n external accounts from the list." first: Int): ExternalAccountConnection!
    "The unique ID for the user."
    id: ID!
    """
    EXPERIMENTAL: Collaborators who can be invited to Sourcegraph. This typically comes from a few
    repositories this user has access to, and is derived from recent commit history of those.
    """
    invitableCollaborators: [Person!]!
    """
    The latest settings for the user.
    Only the user and site admins can access this field.
    """
    latestSettings: Settings
    "A list of monitors owned by the user or her organization."
    monitors(
        "Opaque pagination cursor."
        after: String
        "Returns the first n monitors from the list."
        first: Int = 50
    ): MonitorConnection!
    "The name of this user namespace's component. For users, this is the username."
    namespaceName: String!
    "This user's organization memberships."
    organizationMemberships: OrganizationMembershipConnection!
    "The organizations that this user is a member of."
    organizations: OrgConnection!
    """
    The permissions information of the user over repositories.
    It is null when there is no permissions data stored for the user.
    """
    permissionsInfo: PermissionsInfo
    "publicRepositories returns the repos listed in user_public_repos for this user"
    publicRepositories: [Repository!]!
    "Repositories from external services owned by this user."
    repositories(
        "An opaque cursor that is used for pagination."
        after: String
        "Include cloned repositories."
        cloned: Boolean = true
        "Only include repositories from this external service."
        externalServiceID: ID
        "Returns the first n repositories from the list."
        first: Int
        "Include repositories that have a text search index."
        indexed: Boolean = true
        "Include repositories that are not yet cloned and for which cloning is not in progress."
        notCloned: Boolean = true
        "Include repositories that do not have a text search index."
        notIndexed: Boolean = true
        "Return repositories whose names match the query."
        query: String
    ): RepositoryConnection!
    "Whether the user accepted to be searched in the users picker or not."
    searchable: Boolean!
    """
    The user's currently active session.
    Only the currently authenticated user can access this field. Site admins are not able to access sessions for
    other users.
    """
    session: Session!
    """
    All settings for this user, and the individual levels in the settings cascade (global > organization > user)
    that were merged to produce the final merged settings.
    Only the user and site admins can access this field.
    """
    settingsCascade: SettingsCascade!
    "The URL to the user's settings."
    settingsURL: String
    """
    Whether the user is a site admin.
    Only the user and site admins can access this field.
    """
    siteAdmin: Boolean!
    """
    The user's survey responses.
    Only the user and site admins can access this field.
    """
    surveyResponses: [SurveyResponse!]!
    """
    Tags associated with the user. These are used for internal site management and feature selection.
    Only the user and site admins can access this field.
    """
    tags: [String!]!
    "Whether the user has already accepted the terms of service or not."
    tosAccepted: Boolean!
    "The date when the user account was last updated on Sourcegraph."
    updatedAt: DateTime
    "The URL to the user's profile on Sourcegraph."
    url: String!
    "The user's usage statistics on Sourcegraph."
    usageStatistics: UserUsageStatistics!
    "The user's username."
    username: String!
    """
    Whether the viewer has admin privileges on this user. The user has admin privileges on their own user, and
    site admins have admin privileges on all users.
    """
    viewerCanAdminister: Boolean!
    """
    Whether the viewer can change the username of this user.
    The user can change their username unless auth.disableUsernameChanges is set.
    Site admins can always change the username of any user.
    """
    viewerCanChangeUsername: Boolean!
}

"A list of users."
type UserConnection {
    "A list of users."
    nodes: [User!]!
    "Pagination information."
    pageInfo: PageInfo!
    """
    The total count of users in the connection. This total count may be larger
    than the number of nodes in this object when the result is paginated.
    """
    totalCount: Int!
}

"A user's email address."
type UserEmail {
    "The email address."
    email: String!
    """
    Whether the email address is the user's primary email address. Currently this is defined as the earliest
    email address associated with the user, preferring verified emails to unverified emails.
    """
    isPrimary: Boolean!
    "The user associated with this email address."
    user: User!
    "Whether the email address is pending verification."
    verificationPending: Boolean!
    "Whether the email address has been verified by the user."
    verified: Boolean!
    """
    Whether the viewer has privileges to manually mark this email address as verified (without the user going
    through the normal verification process). Only site admins have this privilege.
    """
    viewerCanManuallyVerify: Boolean!
}

"""
UserUsageStatistics describes a user's usage statistics.
This information is visible to all viewers.
"""
type UserUsageStatistics {
    "The number of code intelligence actions that the user has performed."
    codeIntelligenceActions: Int!
    "The number of find-refs actions that the user has performed."
    findReferencesActions: Int!
    "The last time the user was active on a code host integration."
    lastActiveCodeHostIntegrationTime: String
    "The last time the user was active (any action, any platform)."
    lastActiveTime: String
    "The number of page views that the user has performed."
    pageViews: Int!
    "The number of search queries that the user has performed."
    searchQueries: Int!
}

"A virtual file is an arbitrary file that is generated in memory."
type VirtualFile implements File2 {
    "Whether or not it is binary."
    binary: Boolean!
    "The file size in bytes."
    byteSize: Int!
    "Not implemented."
    canonicalURL: String!
    "The content of this file."
    content: String!
    "Not implemented."
    externalURLs: [ExternalLink!]!
    "Highlight the file."
    highlight(
        disableTimeout: Boolean!
        """
        If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.
        2000 bytes is enabled. This may produce a significant amount of HTML
        which some browsers (such as Chrome, but not Firefox) may have trouble
        rendering efficiently.
        """
        highlightLongLines: Boolean = false
        isLightTheme: Boolean
    ): HighlightedFile!
    "False because this is a file, not a directory."
    isDirectory: Boolean!
    "The base name (i.e., file name only) of this file."
    name: String!
    "The full path (relative to the root) of this file."
    path: String!
    """
    The file rendered as rich HTML, or an empty string if it is not a supported
    rich file type.
    This HTML string is already escaped and thus is always safe to render.
    """
    richHTML: String!
    "Not implemented."
    url: String!
}

"A preview entry where no changeset existed before matching the changeset spec."
type VisibleApplyPreviewTargetsAttach {
    "The changeset spec from this entry."
    changesetSpec: VisibleChangesetSpec!
}

"""
A preview entry where no changeset spec exists for the changeset currently in
the target batch change.
"""
type VisibleApplyPreviewTargetsDetach {
    "The changeset from this entry."
    changeset: ExternalChangeset!
}

"A preview entry where a changeset matches the changeset spec."
type VisibleApplyPreviewTargetsUpdate {
    "The changeset from this entry."
    changeset: ExternalChangeset!
    "The changeset spec from this entry."
    changesetSpec: VisibleChangesetSpec!
}

"""
One preview entry in the list of all previews against a batch spec. Each mapping
between changeset specs and current changesets yields one of these. It describes
which operations are taken against which changeset spec and changeset to ensure the
desired state is met.
"""
type VisibleChangesetApplyPreview {
    """
    The delta between the current changeset state and what the new changeset spec
    envisions the changeset to look like.
    """
    delta: ChangesetSpecDelta!
    "The operations to take to achieve the desired state."
    operations: [ChangesetSpecOperation!]!
    "The target entities in this preview entry."
    targets: VisibleApplyPreviewTargets!
}

"""
A changeset spec is an immutable description of the desired state of a changeset in a batch change. To
create a changeset spec, use the createChangesetSpec mutation.
"""
type VisibleChangesetSpec implements ChangesetSpec & Node {
    "The description of the changeset."
    description: ChangesetDescription!
    """
    The date, if any, when this changeset spec expires and is automatically purged. A changeset
    spec never expires (and this field is null) if its batch spec has been applied.
    """
    expiresAt: DateTime
    "The fork the changeset will be pushed to, if any."
    forkTarget: ForkTarget
    """
    The unique ID for a changeset spec.

    The ID is unguessable (i.e., long and randomly generated, not sequential). This is important
    even though repository permissions also apply to viewers of changeset specs, because being
    allowed to view a repository should not entitle a person to view all not-yet-published
    changesets for that repository. Consider a batch change to fix a security vulnerability: the
    batch change author may prefer to prepare all of the changesets in private so that the window
    between revealing the problem and merging the fixes is as short as possible.
    """
    id: ID!
    "The type of changeset spec."
    type: ChangesetSpecType!
    "The workspace this resulted from. Null, if not run server-side."
    workspace: BatchSpecWorkspace
}

"A single logged webhook delivery."
type WebhookLog implements Node {
    "The external service the webhook was matched to, if any."
    externalService: ExternalService
    "The webhook log ID."
    id: ID!
    "The time the webhook was received at."
    receivedAt: DateTime!
    "The received webhook request."
    request: WebhookLogRequest!
    "The response sent by the webhook handler."
    response: WebhookLogResponse!
    "The HTTP status code returned from the webhook handler."
    statusCode: Int!
}

"A list of logged webhook deliveries."
type WebhookLogConnection {
    "A list of webhook logs."
    nodes: [WebhookLog!]!
    "Pagination information."
    pageInfo: PageInfo!
    "The total number of webhook logs in the connection."
    totalCount: Int!
}

"A single HTTP header within a webhook log."
type WebhookLogHeader {
    "The header name."
    name: String!
    "The header values."
    values: [String!]!
}

"A HTTP request within a webhook log."
type WebhookLogRequest implements WebhookLogMessage {
    "The body content of the HTTP message."
    body: String!
    "The headers in the HTTP message."
    headers: [WebhookLogHeader!]!
    "The method used in the HTTP request."
    method: String!
    "The requested URL."
    url: String!
    "The HTTP version in use."
    version: String!
}

"A HTTP response within a webhook log."
type WebhookLogResponse implements WebhookLogMessage {
    "The body content of the HTTP message."
    body: String!
    "The headers in the HTTP message."
    headers: [WebhookLogHeader!]!
}

"The possible types of alerts (Alert.type values)."
enum AlertType {
    ERROR
    INFO
    WARNING
}

"The state of the batch change."
enum BatchChangeState {
    CLOSED
    DRAFT
    OPEN
}

"The possible states of a batch spec."
enum BatchSpecState {
    "The execution has been canceled."
    CANCELED
    "The execution is being canceled."
    CANCELING
    "This spec was processed successfully."
    COMPLETED
    "This spec failed to be processed."
    FAILED
    "The spec is not yet enqueued for processing."
    PENDING
    "This spec is being processed."
    PROCESSING
    "This spec is queued to be processed."
    QUEUED
}

"State of the workspace resolution."
enum BatchSpecWorkspaceResolutionState {
    "Resolving workspaces finished successfully."
    COMPLETED
    "An error occured while resolving workspaces. Will be retried eventually."
    ERRORED
    "A fatal error occured while resolving workspaces. No retries will be made."
    FAILED
    "Currently resolving workspaces."
    PROCESSING
    "Not yet started resolving. Will be picked up by a worker eventually."
    QUEUED
}

"The states a workspace can be in."
enum BatchSpecWorkspaceState {
    "Execution has been canceled."
    CANCELED
    "Execution is being canceled. This is an async process."
    CANCELING
    "Execution finished successfully."
    COMPLETED
    "A fatal error occured while executing. No retries will be made."
    FAILED
    "The workspace is not yet enqueued for execution."
    PENDING
    "Currently executing on the workspace."
    PROCESSING
    "Not yet started executing. Will be picked up by a worker eventually."
    QUEUED
    """
    The workspace will not be enqueued for execution, because either the
    workspace is unsupported/ignored or has 0 steps to execute.
    """
    SKIPPED
}

"All valid states a bulk operation can be in."
enum BulkOperationState {
    "No operations are still running and all of them finished without error."
    COMPLETED
    "No operations are still running and at least one of them finished with an error."
    FAILED
    "The bulk operation is still processing on some changesets."
    PROCESSING
}

"The available types of jobs that can be run over a batch change."
enum BulkOperationType {
    "Bulk close changesets."
    CLOSE
    "Bulk post comments over all involved changesets."
    COMMENT
    "Bulk detach changesets from a batch change."
    DETACH
    "Bulk merge changesets."
    MERGE
    "Bulk publish changesets."
    PUBLISH
    "Bulk reenqueue failed changesets."
    REENQUEUE
}

"The state of checks (e.g., for continuous integration) on a changeset."
enum ChangesetCheckState {
    FAILED
    PASSED
    PENDING
}

"The state of a changeset on the code host on which it's hosted."
enum ChangesetExternalState {
    CLOSED
    DELETED
    DRAFT
    MERGED
    OPEN
}

"The publication state of a changeset on Sourcegraph"
enum ChangesetPublicationState {
    "The changeset has been created on the code host."
    PUBLISHED
    "The changeset has not yet been created on the code host."
    UNPUBLISHED
}

"The reconciler state of a changeset on Sourcegraph"
enum ChangesetReconcilerState {
    "The changeset is not enqueued for processing."
    COMPLETED
    """
    The changeset reconciler ran into a problem while processing the
    changeset and will retry it for a number of retries.
    """
    ERRORED
    """
    The changeset reconciler ran into a problem while processing the
    changeset that can't be fixed by retrying.
    """
    FAILED
    """
    The changeset reconciler is currently computing the delta between the
    If a delta exists, the reconciler tries to update the state of the
    changeset on the code host and on Sourcegraph to the desired state.
    """
    PROCESSING
    "The changeset is enqueued for the reconciler to process it."
    QUEUED
    "The changeset is scheduled, and will be enqueued when its turn comes in Sourcegraph's rollout window."
    SCHEDULED
}

"The review state of a changeset."
enum ChangesetReviewState {
    APPROVED
    CHANGES_REQUESTED
    COMMENTED
    DISMISSED
    PENDING
}

"This enum declares all operations supported by the reconciler."
enum ChangesetSpecOperation {
    "The changeset is kept in the batch change, but it's marked as archived."
    ARCHIVE
    "Close the changeset on the codehost."
    CLOSE
    "The changeset is removed from some of the associated batch changes."
    DETACH
    "Import an existing changeset from the code host with the ExternalID from the spec."
    IMPORT
    "Publish a changeset to the codehost."
    PUBLISH
    "Publish a changeset to the codehost as a draft changeset. (Only on supported code hosts)."
    PUBLISH_DRAFT
    "Push a new commit to the code host."
    PUSH
    "Reopen the changeset on the codehost."
    REOPEN
    "Internal operation to get around slow code host updates."
    SLEEP
    "Sync the changeset with the current state on the codehost."
    SYNC
    "Move the existing changeset out of being a draft."
    UNDRAFT
    """
    Update the existing changeset on the codehost. This is purely the changeset resource on the code host,
    not the git commit. For updates to the commit, see 'PUSH'.
    """
    UPDATE
}

"The type of the changeset spec."
enum ChangesetSpecType {
    "References a branch and a patch to be applied to create the changeset from."
    BRANCH
    "References an existing changeset on a code host to be imported."
    EXISTING
}

"The visual state a changeset is currently in."
enum ChangesetState {
    "The changeset is published, not being reconciled and closed on the code host."
    CLOSED
    "The changeset is published, not being reconciled and has been deleted on the code host."
    DELETED
    "The changeset is published, not being reconciled and in draft state on the code host."
    DRAFT
    """
    The changeset reconciler ran into a problem while processing the
    changeset that can't be fixed by retrying.
    """
    FAILED
    "The changeset is published, not being reconciled and merged on the code host."
    MERGED
    "The changeset is published, not being reconciled and open on the code host."
    OPEN
    """
    The changeset reconciler is currently computing the delta between the
    If a delta exists, the reconciler tries to update the state of the
    changeset on the code host and on Sourcegraph to the desired state.
    """
    PROCESSING
    """
    The changeset reconciler ran into a problem while processing the
    changeset and will retry it for a number of retries.
    """
    RETRYING
    "The changeset is scheduled, and will be enqueued when its turn comes in Sourcegraph's rollout window."
    SCHEDULED
    "The changeset has not been marked as to be published."
    UNPUBLISHED
}

"Represents the severity level of a diagnostic."
enum DiagnosticSeverity {
    ERROR
    HINT
    INFORMATION
    WARNING
}

"The type of content in a hunk line."
enum DiffHunkLineType {
    "Added line."
    ADDED
    "Deleted line."
    DELETED
    "Unchanged line."
    UNCHANGED
}

"The product sources where events can come from."
enum EventSource {
    BACKEND
    CODEHOSTINTEGRATION
    IDEEXTENSION
    STATICWEB
    WEB
}

"Supported status of monitor events."
enum EventStatus {
    ERROR
    PENDING
    SUCCESS
}

"A specific kind of external service."
enum ExternalServiceKind {
    AWSCODECOMMIT
    BITBUCKETCLOUD
    BITBUCKETSERVER
    GITHUB
    GITLAB
    GITOLITE
    GOMODULES
    JVMPACKAGES
    NPMPACKAGES
    OTHER
    PAGURE
    PERFORCE
    PHABRICATOR
}

"All possible types of Git objects."
enum GitObjectType {
    "A Git blob object."
    GIT_BLOB
    "A Git commit object."
    GIT_COMMIT
    "A Git tag object."
    GIT_TAG
    "A Git tree object."
    GIT_TREE
    "A Git object of unknown type."
    GIT_UNKNOWN
}

"Ordering options for Git refs."
enum GitRefOrder {
    "By the authored or committed at date, whichever is more recent."
    AUTHORED_OR_COMMITTED_AT
}

"All possible types of Git refs."
enum GitRefType {
    "A Git branch (in refs/heads/)."
    GIT_BRANCH
    "A Git ref that is neither a branch nor tag."
    GIT_REF_OTHER
    "A Git tag (in refs/tags/)."
    GIT_TAG
}

"Denotes the confidence in the correctness of the proposed index target."
enum InferedPreciseSupportLevel {
    """
    An auto-indexing job configuration was able to be infered for this
    directory that has a high likelyhood of being complete enough to result
    in an LSIF index.
    """
    INDEX_JOB_INFERED
    """
    The language is known to have an LSIF indexer associated with it
    but this may not be the directory from which it should be invoked.
    Relevant build tool configuration may be available at a parent directory.
    """
    LANGUAGE_SUPPORTED
    """
    Relevant build tool configuration files were located that indicate
    a good possibility of this directory being where an LSIF indexer
    could be invoked, however we have or can not infer a potentially complete
    auto indexing job configuration.
    """
    PROJECT_STRUCTURE_SUPPORTED
}

"The state an LSIF index can be in."
enum LSIFIndexState {
    "This index was processed successfully."
    COMPLETED
    "This index failed to be processed."
    ERRORED
    "This index is being processed."
    PROCESSING
    "This index is queued to be processed later."
    QUEUED
}

"The state an LSIF upload can be in."
enum LSIFUploadState {
    "This upload was processed successfully."
    COMPLETED
    """
    This upload is queued for deletion. This upload was previously in the
    COMPLETED state and evicted, replaced by a newer upload, or deleted by
    a user. This upload is able to answer code intelligence queries until
    the commit graph of the upload's repository is next calculated, at which
    point the upload will become unreachable.
    """
    DELETING
    "This upload failed to be processed."
    ERRORED
    "This upload is being processed."
    PROCESSING
    "This upload is queued to be processed later."
    QUEUED
    "This upload is currently being transferred to Sourcegraph."
    UPLOADING
}

"The priority of an email action."
enum MonitorEmailPriority {
    CRITICAL
    NORMAL
}

"Enum of possible block types."
enum NotebookBlockType {
    COMPUTE
    FILE
    MARKDOWN
    QUERY
    SYMBOL
}

"NotebooksOrderBy enumerates the ways notebooks can be ordered."
enum NotebooksOrderBy {
    NOTEBOOK_CREATED_AT
    NOTEBOOK_STAR_COUNT
    NOTEBOOK_UPDATED_AT
}

"The recipient's possible responses to an invitation to join an organization as a member."
enum OrganizationInvitationResponseType {
    "The invitation was accepted by the recipient."
    ACCEPT
    "The invitation was rejected by the recipient."
    REJECT
}

"Ownership level of the recommended precise code-intel indexer."
enum PreciseSupportLevel {
    "When the recommended indexer is maintained by us."
    NATIVE
    """
    When the recommended indexer is maintained by a third-party
    but is recommended over a native indexer, where one exists.
    """
    THIRD_PARTY
    "When there is no known indexer."
    UNKNOWN
}

"RepositoryOrderBy enumerates the ways a repositories list can be ordered."
enum RepositoryOrderBy {
    "deprecated (use the equivalent REPOSITORY_CREATED_AT)"
    REPOSITORY_CREATED_AT
    REPOSITORY_NAME
    REPO_CREATED_AT
}

"Different repository permission levels."
enum RepositoryPermission {
    READ
}

"""
Tiered list of types of search-based support for a language. This may be expanded as different
indexing methods are introduced.
"""
enum SearchBasedSupportLevel {
    "Universal-ctags is used for indexing this language."
    BASIC
    "The language has no configured search-based code-intel support."
    UNSUPPORTED
}

"SearchContextsOrderBy enumerates the ways a search contexts list can be ordered."
enum SearchContextsOrderBy {
    SEARCH_CONTEXT_SPEC
    SEARCH_CONTEXT_UPDATED_AT
}

"The search pattern type."
enum SearchPatternType {
    literal
    regexp
    structural
}

"The version of the search syntax."
enum SearchVersion {
    "Search syntax that defaults to regexp search."
    V1
    "Search syntax that defaults to literal search."
    V2
}

"""
All possible kinds of symbols. This set matches that of the Language Server Protocol
(https://microsoft.github.io/language-server-protocol/specification#workspace_symbol).
"""
enum SymbolKind {
    ARRAY
    BOOLEAN
    CLASS
    CONSTANT
    CONSTRUCTOR
    ENUM
    ENUMMEMBER
    EVENT
    FIELD
    FILE
    FUNCTION
    INTERFACE
    KEY
    METHOD
    MODULE
    NAMESPACE
    NULL
    NUMBER
    OBJECT
    OPERATOR
    PACKAGE
    PROPERTY
    STRING
    STRUCT
    TYPEPARAMETER
    UNKNOWN
    VARIABLE
}

"Time interval units."
enum TimeIntervalStepUnit {
    DAY
    HOUR
    MONTH
    WEEK
    YEAR
}

"A period of time in which a set of users have been active."
enum UserActivePeriod {
    "All time."
    ALL_TIME
    "Since the first day of the current month at 00:00 UTC."
    THIS_MONTH
    "Since the latest Monday at 00:00 UTC."
    THIS_WEEK
    "Since today at 00:00 UTC."
    TODAY
}

"A user event."
enum UserEvent {
    CODEINTEL
    CODEINTELINTEGRATION
    CODEINTELINTEGRATIONREFS
    CODEINTELREFS
    PAGEVIEW
    SEARCHQUERY
    STAGEAUTOMATE
    STAGECODE
    STAGECONFIGURE
    STAGEDEPLOY
    "Product stages"
    STAGEMANAGE
    STAGEMONITOR
    STAGEPACKAGE
    STAGEPLAN
    STAGEREVIEW
    STAGESECURE
    STAGEVERIFY
}

"Possible sort orderings for a workspace connection."
enum WorkspacesSortOrder {
    "Sort by repository name in ascending order."
    REPO_NAME_ASC
    "Sort by repository name in descending order."
    REPO_NAME_DESC
}

"A new external service."
input AddExternalServiceInput {
    "The JSON configuration of the external service."
    config: String!
    "The display name of the external service."
    displayName: String!
    "The kind of the external service."
    kind: ExternalServiceKind!
    """
    The namespace this external service belongs to.
    This can be used both for a user and an organization.
    """
    namespace: ID
}

"Input object for adding insight view to dashboard."
input AddInsightViewToDashboardInput {
    "ID of the dashboard."
    dashboardId: ID!
    "ID of the insight view to attach to the dashboard"
    insightViewId: ID!
}

"""
A ChangesetSpecPublicationStateInput is a tuple containing a changeset spec ID
and its desired UI publication state.
"""
input ChangesetSpecPublicationStateInput {
    "The changeset spec ID."
    changesetSpec: ID!
    "The desired publication state."
    publicationState: PublishedValue!
}

"""
DEPRECATED: This type was renamed to SettingsEdit.
NOTE: GraphQL does not support @deprecated directives on INPUT_FIELD_DEFINITION (input fields).
"""
input ConfigurationEdit {
    "DEPRECATED"
    keyPath: [KeyPathSegment!]!
    "DEPRECATED"
    value: JSONValue
    "DEPRECATED"
    valueIsJSONCEncodedString: Boolean = false
}

"CreateFileBlockInput contains the information necessary to create a file block."
input CreateFileBlockInput {
    "Path within the repository, e.g. \"client/web/file.tsx\"."
    filePath: String!
    "An optional line range. If omitted, we display the entire file."
    lineRange: CreateFileBlockLineRangeInput
    "Name of the repository, e.g. \"github.com/sourcegraph/sourcegraph\"."
    repositoryName: String!
    """
    An optional revision, e.g. "pr/feature-1", "a9505a2947d3df53558e8c88ff8bcef390fc4e3e".
    If omitted, we use the latest revision (HEAD).
    """
    revision: String
}

"Input to create a line range for a file block."
input CreateFileBlockLineRangeInput {
    "The last line to fetch (0-indexed, exclusive)."
    endLine: Int!
    "The first line to fetch (0-indexed, inclusive)."
    startLine: Int!
}

"Input object for creating a new dashboard."
input CreateInsightsDashboardInput {
    "Permissions to grant to the dashboard."
    grants: InsightsPermissionGrantsInput!
    "Dashboard title."
    title: String!
}

"""
GraphQL does not accept union types as inputs, so we have to use
all possible optional inputs with an enum to select the actual block input we want to use.
"""
input CreateNotebookBlockInput {
    "Compute input."
    computeInput: String
    "File input."
    fileInput: CreateFileBlockInput
    "ID of the block."
    id: String!
    "Markdown input."
    markdownInput: String
    "Query input."
    queryInput: String
    "Symbol input."
    symbolInput: CreateSymbolBlockInput
    "Block type."
    type: NotebookBlockType!
}

"CreateSymbolBlockInput contains the information necessary to create a symbol block."
input CreateSymbolBlockInput {
    "Path within the repository, e.g. \"client/web/file.tsx\"."
    filePath: String!
    "Number of lines to show before and after the matched symbol line."
    lineContext: Int!
    "Name of the repository, e.g. \"github.com/sourcegraph/sourcegraph\"."
    repositoryName: String!
    """
    An optional revision, e.g. "pr/feature-1", "a9505a2947d3df53558e8c88ff8bcef390fc4e3e".
    If omitted, we use the latest revision (HEAD).
    """
    revision: String
    "Name of the symbol container."
    symbolContainerName: String!
    "The symbol kind."
    symbolKind: SymbolKind!
    "The symbol name."
    symbolName: String!
}

"A description of a user event."
input Event {
    "The additional argument information."
    argument: String
    """
    An optional cohort ID to identify the user as part of a specific A/B test.
    The cohort ID is expected to be a date in the form YYYY-MM-DD
    """
    cohortID: String
    "Device ID used for Amplitude analytics. Used on Sourcegraph Cloud only."
    deviceID: String
    "The name of the event."
    event: String!
    """
    Event ID used to deduplicate events that occur simultaneously in Amplitude analytics.
    See https://developers.amplitude.com/docs/http-api-v2#optional-keys. Used on Sourcegraph Cloud only.
    """
    eventID: Int
    "The first sourcegraph URL visited by the user, stored in a browser cookie."
    firstSourceURL: String
    """
    Insert ID used to deduplicate events that re-occur in the event of retries or
    backfills in Amplitude analytics. See https://developers.amplitude.com/docs/http-api-v2#optional-keys.
    Used on Sourcegraph Cloud only.
    """
    insertID: String
    "The last sourcegraph URL visited by the user, stored in a browser cookie."
    lastSourceURL: String
    """
    Public argument information. PRIVACY: Do NOT include any potentially private information in this field.
    These properties get sent to our analytics tools for Cloud, so must not include private information,
    such as search queries or repository names.
    """
    publicArgument: String
    """
    An optional referrer parameter for the user's current session.
    Only captured and stored on Sourcegraph Cloud.
    """
    referrer: String
    "The source of the event."
    source: EventSource!
    "The URL when the event was logged."
    url: String!
    "The randomly generated unique user ID stored in a browser cookie."
    userCookieID: String!
}

"Additional options when performing a permissions sync."
input FetchPermissionsOptions {
    """
    Indicate that any caches added for optimization encountered during this permissions
    sync should be invalidated.
    """
    invalidateCaches: Boolean
}

"Input for a happiness feedback submission."
input HappinessFeedbackSubmissionInput {
    "The path that the happiness feedback will be submitted from."
    currentPath: String
    "The answer to \"What's going well? What could be better?\"."
    feedback: String
    "User's happiness rating, from 1-4."
    score: Int!
}

"A specific highlighted line range to fetch."
input HighlightLineRange {
    """
    The last line to fetch (0-indexed, inclusive). Values outside the bounds of the file will
    automatically be clamped within the valid range.
    """
    endLine: Int!
    """
    The first line to fetch (0-indexed, inclusive). Values outside the bounds of the file will
    automatically be clamped within the valid range.
    """
    startLine: Int!
}

"Input for the default values for filters and aggregates for an insight."
input InsightViewControlsInput {
    "Input for the default filters for an insight."
    filters: InsightViewFiltersInput!
}

"Input for the default values by which the insight is filtered."
input InsightViewFiltersInput {
    "A regex string for which to exclude repositories in a filter."
    excludeRepoRegex: String
    "A regex string for which to include repositories in a filter."
    includeRepoRegex: String
    "A list of query based search contexts to include in the filters for the view."
    searchContexts: [String!]
}

"Input object for permissions to grant."
input InsightsPermissionGrantsInput {
    "Set global to true to grant global permission."
    global: Boolean
    "Organizations to grant permissions to."
    organizations: [ID!]
    "Specific users to grant permissions to."
    users: [ID!]
}

"""
A segment of a key path that locates a nested JSON value in a root JSON value. Exactly one field in each
KeyPathSegment must be non-null.
For example, in {"a": [0, {"b": 3}]}, the value 3 is located at the key path ["a", 1, "b"].
"""
input KeyPathSegment {
    "The index of the array at this location to descend into."
    index: Int
    "The name of the property in the object at this location to descend into."
    property: String
}

"Options for a line chart data series"
input LineChartDataSeriesOptionsInput {
    "The label for the data series."
    label: String
    "The line color for the data series."
    lineColor: String
}

"Options for a line chart"
input LineChartOptionsInput {
    "The chart title."
    title: String
}

"Input for a line chart search insight data series."
input LineChartSearchInsightDataSeriesInput {
    "Whether or not to generate the timeseries results from the query capture groups. Defaults to false if not provided."
    generatedFromCaptureGroups: Boolean
    "Options for this line chart data series."
    options: LineChartDataSeriesOptionsInput!
    "The query string."
    query: String!
    "The scope of repositories."
    repositoryScope: RepositoryScopeInput!
    "Unique ID for the series. Omit this field if it's a new series."
    seriesId: String
    "The scope of time."
    timeScope: TimeScopeInput!
}

"Input for a line chart search insight."
input LineChartSearchInsightInput {
    "The dashboard IDs to associate this insight with once created."
    dashboards: [ID!]
    "The list of data series to create (or add) to this insight."
    dataSeries: [LineChartSearchInsightDataSeriesInput!]!
    "The options for this line chart."
    options: LineChartOptionsInput!
    "The default values for filters and aggregates for this line chart."
    viewControls: InsightViewControlsInput
}

"Describes options for rendering Markdown."
input MarkdownOptions {
    "A dummy null value (empty input types are not allowed yet)."
    alwaysNil: String
}

"The input required to create an action."
input MonitorActionInput {
    "An email action."
    email: MonitorEmailInput
    "A Slack webhook action."
    slackWebhook: MonitorSlackWebhookInput
    "A webhook action."
    webhook: MonitorWebhookInput
}

"The input required to edit an action."
input MonitorEditActionInput {
    "An email action."
    email: MonitorEditEmailInput
    "A Slack webhook action."
    slackWebhook: MonitorEditSlackWebhookInput
    "A webhook action."
    webhook: MonitorEditWebhookInput
}

"The input required to edit an email action."
input MonitorEditEmailInput {
    """
    The id of an email action. If unset, this will
    be treated as a new email action and be created
    rather than updated.
    """
    id: ID
    "The desired state after the update."
    update: MonitorEmailInput!
}

"The input required to edit a code monitor."
input MonitorEditInput {
    "The id of the monitor."
    id: ID!
    "The desired state after the udpate."
    update: MonitorInput!
}

"The input required to edit a Slack webhook action."
input MonitorEditSlackWebhookInput {
    """
    The id of a Slack webhook action. If unset, this will
    be treated as a new Slack webhook action and be created
    rather than updated.
    """
    id: ID
    "The desired state after the update."
    update: MonitorSlackWebhookInput!
}

"The input required to edit a trigger."
input MonitorEditTriggerInput {
    "The id of the Trigger."
    id: ID!
    "The desired state after the udpate."
    update: MonitorTriggerInput!
}

"The input required to edit a webhook action."
input MonitorEditWebhookInput {
    """
    The id of a webhook action. If unset, this will
    be treated as a new webhook action and be created
    rather than updated.
    """
    id: ID
    "The desired state after the update."
    update: MonitorWebhookInput!
}

"The input required to create an email action."
input MonitorEmailInput {
    "Whether the email action is enabled or not."
    enabled: Boolean!
    "Use header to automatically approve the message in a read-only or moderated mailing list."
    header: String!
    "Whether to include the result contents in the email message"
    includeResults: Boolean!
    "The priority of the email."
    priority: MonitorEmailPriority!
    "A list of users or orgs which will receive the email."
    recipients: [ID!]!
}

"The input required to create a code monitor."
input MonitorInput {
    "A meaningful description of the code monitor."
    description: String!
    "Whether the code monitor is enabled or not."
    enabled: Boolean!
    """
    The namespace represents the owner of the code monitor.
    Owners can either be users or organizations.
    """
    namespace: ID!
}

"The input required to create a Slack webhook action."
input MonitorSlackWebhookInput {
    "Whether the Slack webhook action is enabled or not."
    enabled: Boolean!
    "Whether to include the result contents in Slack notification message."
    includeResults: Boolean!
    "The URL that will receive a payload when the action is triggered."
    url: String!
}

"The input required to create a trigger."
input MonitorTriggerInput {
    "The query string."
    query: String!
}

"The input required to create a webhook action."
input MonitorWebhookInput {
    "Whether the webhook action is enabled or not."
    enabled: Boolean!
    "Whether to include the result contents in webhook payload."
    includeResults: Boolean!
    "The URL that will receive a payload when the action is triggered."
    url: String!
}

"Input for a new notebook."
input NotebookInput {
    "Array of notebook blocks."
    blocks: [CreateNotebookBlockInput!]!
    """
    Notebook namespace (user or org). Controls the visibility of the notebook
    and who can edit the notebook. Only the notebook creator can update the namespace.
    """
    namespace: ID!
    """
    Public property controls the visibility of the notebook. A public notebook is available to
    any user on the instance. Private notebooks are only available to their creators.
    """
    public: Boolean!
    "The title of the notebook."
    title: String!
}

"Options for a pie chart"
input PieChartOptionsInput {
    """
    The threshold for which groups fall into the "other category". Only categories with a percentage greater than
    this value will be separately rendered.
    """
    otherThreshold: Float!
    "The title for the pie chart."
    title: String!
}

"Input for a pie chart search insight"
input PieChartSearchInsightInput {
    "The dashboard IDs to associate this insight with once created."
    dashboards: [ID!]
    "Options for this pie chart."
    presentationOptions: PieChartOptionsInput!
    "The query string."
    query: String!
    "The scope of repositories."
    repositoryScope: RepositoryScopeInput!
}

"Input object for adding insight view to dashboard."
input RemoveInsightViewFromDashboardInput {
    "ID of the dashboard."
    dashboardId: ID!
    "ID of the insight view to remove from the dashboard"
    insightViewId: ID!
}

"A custom repository scope for an insight data series."
input RepositoryScopeInput {
    "The list of repositories included in this scope."
    repositories: [String!]!
}

"Input for editing an existing search context."
input SearchContextEditInput {
    "Search context description."
    description: String!
    """
    Search context name. Not the same as the search context spec. Search context namespace and search context name
    are used to construct the fully-qualified search context spec.
    Example mappings from search context spec to search context name: global -> global, @user -> user, @org -> org,
    @user/ctx1 -> ctx1, @org/ctxs/ctx -> ctxs/ctx.
    """
    name: String!
    """
    Public property controls the visibility of the search context. Public search context is available to
    any user on the instance. If a public search context contains private repositories, those are filtered out
    for unauthorized users. Private search contexts are only available to their owners. Private user search context
    is available only to the user, private org search context is available only to the members of the org, and private
    instance-level search contexts are available only to site-admins.
    """
    public: Boolean!
    """
    Sourcegraph search query that defines the search context.
    e.g. "r:^github\.com/org (rev:bar or rev:HEAD) file:^sub/dir"
    """
    query: String!
}

"Input for a new search context."
input SearchContextInput {
    "Search context description."
    description: String!
    """
    Search context name. Not the same as the search context spec. Search context namespace and search context name
    are used to construct the fully-qualified search context spec.
    Example mappings from search context spec to search context name: global -> global, @user -> user, @org -> org,
    @user/ctx1 -> ctx1, @org/ctxs/ctx -> ctxs/ctx.
    """
    name: String!
    "Namespace of the search context (user or org). If not set, search context is considered instance-level."
    namespace: ID
    """
    Public property controls the visibility of the search context. Public search context is available to
    any user on the instance. If a public search context contains private repositories, those are filtered out
    for unauthorized users. Private search contexts are only available to their owners. Private user search context
    is available only to the user, private org search context is available only to the members of the org, and private
    instance-level search contexts are available only to site-admins.
    """
    public: Boolean!
    """
    Sourcegraph search query that defines the search context.
    e.g. "r:^github\.com/org (rev:bar or rev:HEAD) file:^sub/dir"
    """
    query: String!
}

"Input for a set of revisions to be searched within a repository."
input SearchContextRepositoryRevisionsInput {
    "ID of the repository to be searched."
    repositoryID: ID!
    "Revisions in the repository to be searched."
    revisions: [String!]!
}

"Required input to generate a time series for a search insight using live preview."
input SearchInsightLivePreviewInput {
    "Whether or not to generate the timeseries results from the query capture groups."
    generatedFromCaptureGroups: Boolean!
    "The desired label for the series. Will be overwritten when series are dynamically generated."
    label: String!
    "The query string."
    query: String!
    "The scope of repositories."
    repositoryScope: RepositoryScopeInput!
    "The scope of time."
    timeScope: TimeScopeInput!
}

"An edit to a JSON property in a settings JSON object. The JSON property to edit can be nested."
input SettingsEdit {
    """
    The key path of the property to update.

    Inserting into an existing array is not yet supported.
    """
    keyPath: [KeyPathSegment!]!
    """
    The new JSON-encoded value to insert. If the field's value is not set, the property is removed. (This is
    different from the field's value being the JSON null value.)

    When the value is a non-primitive type, it must be specified using a GraphQL variable, not an inline literal,
    or else the GraphQL parser will return an error.
    """
    value: JSONValue
    """
    Whether to treat the value as a JSONC-encoded string, which makes it possible to perform an edit that
    preserves (or adds/removes) comments.
    """
    valueIsJSONCEncodedString: Boolean = false
}

"""
Input for Mutation.settingsMutation, which contains fields that all settings (global, organization, and user
settings) mutations need.
"""
input SettingsMutationGroupInput {
    """
    The ID of the last-known settings known to the client, or null if there is none. This field is used to
    prevent race conditions when there are concurrent editors.
    """
    lastID: Int
    "The subject whose settings to mutate (organization, user, etc.)."
    subject: ID!
}

"Input for a user satisfaction (NPS) survey submission."
input SurveySubmissionInput {
    "The answer to \"What can Sourcegraph do to provide a better product\""
    better: String
    """
    User-provided email address, if there is no currently authenticated user. If there is, this value
    will not be used.
    """
    email: String
    "The answer to \"What is the most important reason for the score you gave\"."
    reason: String
    "User's likelihood of recommending Sourcegraph to a friend, from 0-10."
    score: Int!
}

"A time scope defined using a time interval (ex. 5 days)"
input TimeIntervalStepInput {
    "The time unit for the interval."
    unit: TimeIntervalStepUnit!
    "The value for the interval."
    value: Int!
}

"A custom time scope for an insight data series."
input TimeScopeInput {
    "Sets a time scope using a step interval (intervals of time)."
    stepInterval: TimeIntervalStepInput
}

"Fields to update for an existing external service."
input UpdateExternalServiceInput {
    "The updated config, if provided."
    config: String
    "The updated display name, if provided."
    displayName: String
    "The id of the external service to update."
    id: ID!
}

"Input object for update insight series mutation."
input UpdateInsightSeriesInput {
    "The desired activity state (enabled or disabled) for the series."
    enabled: Boolean
    "Unique ID for the series."
    seriesId: String!
}

"Input object for updating a dashboard."
input UpdateInsightsDashboardInput {
    "Permissions to grant to the dashboard."
    grants: InsightsPermissionGrantsInput
    "Dashboard title."
    title: String
}

"Input for updating a line chart search insight."
input UpdateLineChartSearchInsightInput {
    "The complete list of data series on this line chart. Note: excluding a data series will remove it."
    dataSeries: [LineChartSearchInsightDataSeriesInput!]!
    "The presentation options for this line chart."
    presentationOptions: LineChartOptionsInput!
    "The default values for filters and aggregates for this line chart."
    viewControls: InsightViewControlsInput!
}

"Input for updating a pie chart search insight"
input UpdatePieChartSearchInsightInput {
    "Options for this pie chart."
    presentationOptions: PieChartOptionsInput!
    "The query string."
    query: String!
    "The scope of repositories."
    repositoryScope: RepositoryScopeInput!
}

"A user (identified either by username or email address) with its repository permission."
input UserPermission {
    """
    Depending on the bindID option in the permissions.userMapping site configuration property,
    the elements of the list are either all usernames (bindID of "username") or all email
    addresses (bindID of "email").
    """
    bindID: String!
    "The highest level of repository permission."
    permission: RepositoryPermission = READ
}

"A user (identified either by username or email address) with its sub-repository permissions."
input UserSubRepoPermission {
    """
    Depending on the bindID option in the permissions.userMapping site configuration property,
    the elements of the list are either all usernames (bindID of "username") or all email
    addresses (bindID of "email").
    """
    bindID: String!
    "An array of paths that the user is not allowed to access, in glob format."
    pathExcludes: [String!]!
    "An array of paths that the user is allowed to access, in glob format."
    pathIncludes: [String!]!
}

"An arbitrarily large integer encoded as a decimal string."
scalar BigInt

"""
An RFC 3339-encoded UTC date string, such as 1973-11-29T21:33:09Z. This value can be parsed into a
JavaScript Date using Date.parse. To produce this value from a JavaScript Date instance, use
Date#toISOString.
"""
scalar DateTime

"A Git object ID (SHA-1 hash, 40 hexadecimal characters)."
scalar GitObjectID

"A string that contains valid JSON, with additional support for //-style comments and trailing commas."
scalar JSONCString

"A valid JSON value."
scalar JSONValue

"A quadruple that represents all possible states of the published value: true, false, 'draft', or null."
scalar PublishedValue
