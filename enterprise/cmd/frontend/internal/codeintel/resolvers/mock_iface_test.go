// Code generated by go-mockgen 1.2.0; DO NOT EDIT.

package resolvers

import (
	"context"
	"sync"
	"time"

	regexp "github.com/grafana/regexp"
	enqueuer "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/autoindex/enqueuer"
	api "github.com/sourcegraph/sourcegraph/internal/api"
	dbstore "github.com/sourcegraph/sourcegraph/internal/codeintel/stores/dbstore"
	gitserver1 "github.com/sourcegraph/sourcegraph/internal/codeintel/stores/gitserver"
	lsifstore "github.com/sourcegraph/sourcegraph/internal/codeintel/stores/lsifstore"
	basestore "github.com/sourcegraph/sourcegraph/internal/database/basestore"
	gitserver "github.com/sourcegraph/sourcegraph/internal/gitserver"
	gitdomain "github.com/sourcegraph/sourcegraph/internal/gitserver/gitdomain"
	protocol "github.com/sourcegraph/sourcegraph/internal/repoupdater/protocol"
	config "github.com/sourcegraph/sourcegraph/lib/codeintel/autoindex/config"
	precise "github.com/sourcegraph/sourcegraph/lib/codeintel/precise"
)

// MockDBStore is a mock implementation of the DBStore interface (from the
// package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/frontend/internal/codeintel/resolvers)
// used for unit testing.
type MockDBStore struct {
	// CommitGraphMetadataFunc is an instance of a mock function object
	// controlling the behavior of the method CommitGraphMetadata.
	CommitGraphMetadataFunc *DBStoreCommitGraphMetadataFunc
	// CommitsVisibleToUploadFunc is an instance of a mock function object
	// controlling the behavior of the method CommitsVisibleToUpload.
	CommitsVisibleToUploadFunc *DBStoreCommitsVisibleToUploadFunc
	// CreateConfigurationPolicyFunc is an instance of a mock function
	// object controlling the behavior of the method
	// CreateConfigurationPolicy.
	CreateConfigurationPolicyFunc *DBStoreCreateConfigurationPolicyFunc
	// DefinitionDumpsFunc is an instance of a mock function object
	// controlling the behavior of the method DefinitionDumps.
	DefinitionDumpsFunc *DBStoreDefinitionDumpsFunc
	// DeleteConfigurationPolicyByIDFunc is an instance of a mock function
	// object controlling the behavior of the method
	// DeleteConfigurationPolicyByID.
	DeleteConfigurationPolicyByIDFunc *DBStoreDeleteConfigurationPolicyByIDFunc
	// DeleteIndexByIDFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteIndexByID.
	DeleteIndexByIDFunc *DBStoreDeleteIndexByIDFunc
	// DeleteUploadByIDFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteUploadByID.
	DeleteUploadByIDFunc *DBStoreDeleteUploadByIDFunc
	// FindClosestDumpsFunc is an instance of a mock function object
	// controlling the behavior of the method FindClosestDumps.
	FindClosestDumpsFunc *DBStoreFindClosestDumpsFunc
	// FindClosestDumpsFromGraphFragmentFunc is an instance of a mock
	// function object controlling the behavior of the method
	// FindClosestDumpsFromGraphFragment.
	FindClosestDumpsFromGraphFragmentFunc *DBStoreFindClosestDumpsFromGraphFragmentFunc
	// GetConfigurationPoliciesFunc is an instance of a mock function object
	// controlling the behavior of the method GetConfigurationPolicies.
	GetConfigurationPoliciesFunc *DBStoreGetConfigurationPoliciesFunc
	// GetConfigurationPolicyByIDFunc is an instance of a mock function
	// object controlling the behavior of the method
	// GetConfigurationPolicyByID.
	GetConfigurationPolicyByIDFunc *DBStoreGetConfigurationPolicyByIDFunc
	// GetDumpsByIDsFunc is an instance of a mock function object
	// controlling the behavior of the method GetDumpsByIDs.
	GetDumpsByIDsFunc *DBStoreGetDumpsByIDsFunc
	// GetIndexByIDFunc is an instance of a mock function object controlling
	// the behavior of the method GetIndexByID.
	GetIndexByIDFunc *DBStoreGetIndexByIDFunc
	// GetIndexConfigurationByRepositoryIDFunc is an instance of a mock
	// function object controlling the behavior of the method
	// GetIndexConfigurationByRepositoryID.
	GetIndexConfigurationByRepositoryIDFunc *DBStoreGetIndexConfigurationByRepositoryIDFunc
	// GetIndexesFunc is an instance of a mock function object controlling
	// the behavior of the method GetIndexes.
	GetIndexesFunc *DBStoreGetIndexesFunc
	// GetIndexesByIDsFunc is an instance of a mock function object
	// controlling the behavior of the method GetIndexesByIDs.
	GetIndexesByIDsFunc *DBStoreGetIndexesByIDsFunc
	// GetUploadByIDFunc is an instance of a mock function object
	// controlling the behavior of the method GetUploadByID.
	GetUploadByIDFunc *DBStoreGetUploadByIDFunc
	// GetUploadsFunc is an instance of a mock function object controlling
	// the behavior of the method GetUploads.
	GetUploadsFunc *DBStoreGetUploadsFunc
	// GetUploadsByIDsFunc is an instance of a mock function object
	// controlling the behavior of the method GetUploadsByIDs.
	GetUploadsByIDsFunc *DBStoreGetUploadsByIDsFunc
	// HasCommitFunc is an instance of a mock function object controlling
	// the behavior of the method HasCommit.
	HasCommitFunc *DBStoreHasCommitFunc
	// HasRepositoryFunc is an instance of a mock function object
	// controlling the behavior of the method HasRepository.
	HasRepositoryFunc *DBStoreHasRepositoryFunc
	// LanguagesRequestedByFunc is an instance of a mock function object
	// controlling the behavior of the method LanguagesRequestedBy.
	LanguagesRequestedByFunc *DBStoreLanguagesRequestedByFunc
	// LastIndexScanForRepositoryFunc is an instance of a mock function
	// object controlling the behavior of the method
	// LastIndexScanForRepository.
	LastIndexScanForRepositoryFunc *DBStoreLastIndexScanForRepositoryFunc
	// LastUploadRetentionScanForRepositoryFunc is an instance of a mock
	// function object controlling the behavior of the method
	// LastUploadRetentionScanForRepository.
	LastUploadRetentionScanForRepositoryFunc *DBStoreLastUploadRetentionScanForRepositoryFunc
	// MarkRepositoryAsDirtyFunc is an instance of a mock function object
	// controlling the behavior of the method MarkRepositoryAsDirty.
	MarkRepositoryAsDirtyFunc *DBStoreMarkRepositoryAsDirtyFunc
	// RecentIndexesSummaryFunc is an instance of a mock function object
	// controlling the behavior of the method RecentIndexesSummary.
	RecentIndexesSummaryFunc *DBStoreRecentIndexesSummaryFunc
	// RecentUploadsSummaryFunc is an instance of a mock function object
	// controlling the behavior of the method RecentUploadsSummary.
	RecentUploadsSummaryFunc *DBStoreRecentUploadsSummaryFunc
	// ReferenceIDsFunc is an instance of a mock function object controlling
	// the behavior of the method ReferenceIDs.
	ReferenceIDsFunc *DBStoreReferenceIDsFunc
	// RepoIDsByGlobPatternsFunc is an instance of a mock function object
	// controlling the behavior of the method RepoIDsByGlobPatterns.
	RepoIDsByGlobPatternsFunc *DBStoreRepoIDsByGlobPatternsFunc
	// RepoNameFunc is an instance of a mock function object controlling the
	// behavior of the method RepoName.
	RepoNameFunc *DBStoreRepoNameFunc
	// RepoNamesFunc is an instance of a mock function object controlling
	// the behavior of the method RepoNames.
	RepoNamesFunc *DBStoreRepoNamesFunc
	// RequestLanguageSupportFunc is an instance of a mock function object
	// controlling the behavior of the method RequestLanguageSupport.
	RequestLanguageSupportFunc *DBStoreRequestLanguageSupportFunc
	// UpdateConfigurationPolicyFunc is an instance of a mock function
	// object controlling the behavior of the method
	// UpdateConfigurationPolicy.
	UpdateConfigurationPolicyFunc *DBStoreUpdateConfigurationPolicyFunc
	// UpdateIndexConfigurationByRepositoryIDFunc is an instance of a mock
	// function object controlling the behavior of the method
	// UpdateIndexConfigurationByRepositoryID.
	UpdateIndexConfigurationByRepositoryIDFunc *DBStoreUpdateIndexConfigurationByRepositoryIDFunc
}

// NewMockDBStore creates a new mock of the DBStore interface. All methods
// return zero values for all results, unless overwritten.
func NewMockDBStore() *MockDBStore {
	return &MockDBStore{
		CommitGraphMetadataFunc: &DBStoreCommitGraphMetadataFunc{
			defaultHook: func(context.Context, int) (r0 bool, r1 *time.Time, r2 error) {
				return
			},
		},
		CommitsVisibleToUploadFunc: &DBStoreCommitsVisibleToUploadFunc{
			defaultHook: func(context.Context, int, int, *string) (r0 []string, r1 *string, r2 error) {
				return
			},
		},
		CreateConfigurationPolicyFunc: &DBStoreCreateConfigurationPolicyFunc{
			defaultHook: func(context.Context, dbstore.ConfigurationPolicy) (r0 dbstore.ConfigurationPolicy, r1 error) {
				return
			},
		},
		DefinitionDumpsFunc: &DBStoreDefinitionDumpsFunc{
			defaultHook: func(context.Context, []precise.QualifiedMonikerData) (r0 []dbstore.Dump, r1 error) {
				return
			},
		},
		DeleteConfigurationPolicyByIDFunc: &DBStoreDeleteConfigurationPolicyByIDFunc{
			defaultHook: func(context.Context, int) (r0 error) {
				return
			},
		},
		DeleteIndexByIDFunc: &DBStoreDeleteIndexByIDFunc{
			defaultHook: func(context.Context, int) (r0 bool, r1 error) {
				return
			},
		},
		DeleteUploadByIDFunc: &DBStoreDeleteUploadByIDFunc{
			defaultHook: func(context.Context, int) (r0 bool, r1 error) {
				return
			},
		},
		FindClosestDumpsFunc: &DBStoreFindClosestDumpsFunc{
			defaultHook: func(context.Context, int, string, string, bool, string) (r0 []dbstore.Dump, r1 error) {
				return
			},
		},
		FindClosestDumpsFromGraphFragmentFunc: &DBStoreFindClosestDumpsFromGraphFragmentFunc{
			defaultHook: func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) (r0 []dbstore.Dump, r1 error) {
				return
			},
		},
		GetConfigurationPoliciesFunc: &DBStoreGetConfigurationPoliciesFunc{
			defaultHook: func(context.Context, dbstore.GetConfigurationPoliciesOptions) (r0 []dbstore.ConfigurationPolicy, r1 int, r2 error) {
				return
			},
		},
		GetConfigurationPolicyByIDFunc: &DBStoreGetConfigurationPolicyByIDFunc{
			defaultHook: func(context.Context, int) (r0 dbstore.ConfigurationPolicy, r1 bool, r2 error) {
				return
			},
		},
		GetDumpsByIDsFunc: &DBStoreGetDumpsByIDsFunc{
			defaultHook: func(context.Context, []int) (r0 []dbstore.Dump, r1 error) {
				return
			},
		},
		GetIndexByIDFunc: &DBStoreGetIndexByIDFunc{
			defaultHook: func(context.Context, int) (r0 dbstore.Index, r1 bool, r2 error) {
				return
			},
		},
		GetIndexConfigurationByRepositoryIDFunc: &DBStoreGetIndexConfigurationByRepositoryIDFunc{
			defaultHook: func(context.Context, int) (r0 dbstore.IndexConfiguration, r1 bool, r2 error) {
				return
			},
		},
		GetIndexesFunc: &DBStoreGetIndexesFunc{
			defaultHook: func(context.Context, dbstore.GetIndexesOptions) (r0 []dbstore.Index, r1 int, r2 error) {
				return
			},
		},
		GetIndexesByIDsFunc: &DBStoreGetIndexesByIDsFunc{
			defaultHook: func(context.Context, ...int) (r0 []dbstore.Index, r1 error) {
				return
			},
		},
		GetUploadByIDFunc: &DBStoreGetUploadByIDFunc{
			defaultHook: func(context.Context, int) (r0 dbstore.Upload, r1 bool, r2 error) {
				return
			},
		},
		GetUploadsFunc: &DBStoreGetUploadsFunc{
			defaultHook: func(context.Context, dbstore.GetUploadsOptions) (r0 []dbstore.Upload, r1 int, r2 error) {
				return
			},
		},
		GetUploadsByIDsFunc: &DBStoreGetUploadsByIDsFunc{
			defaultHook: func(context.Context, ...int) (r0 []dbstore.Upload, r1 error) {
				return
			},
		},
		HasCommitFunc: &DBStoreHasCommitFunc{
			defaultHook: func(context.Context, int, string) (r0 bool, r1 error) {
				return
			},
		},
		HasRepositoryFunc: &DBStoreHasRepositoryFunc{
			defaultHook: func(context.Context, int) (r0 bool, r1 error) {
				return
			},
		},
		LanguagesRequestedByFunc: &DBStoreLanguagesRequestedByFunc{
			defaultHook: func(context.Context, int) (r0 []string, r1 error) {
				return
			},
		},
		LastIndexScanForRepositoryFunc: &DBStoreLastIndexScanForRepositoryFunc{
			defaultHook: func(context.Context, int) (r0 *time.Time, r1 error) {
				return
			},
		},
		LastUploadRetentionScanForRepositoryFunc: &DBStoreLastUploadRetentionScanForRepositoryFunc{
			defaultHook: func(context.Context, int) (r0 *time.Time, r1 error) {
				return
			},
		},
		MarkRepositoryAsDirtyFunc: &DBStoreMarkRepositoryAsDirtyFunc{
			defaultHook: func(context.Context, int) (r0 error) {
				return
			},
		},
		RecentIndexesSummaryFunc: &DBStoreRecentIndexesSummaryFunc{
			defaultHook: func(context.Context, int) (r0 []dbstore.IndexesWithRepositoryNamespace, r1 error) {
				return
			},
		},
		RecentUploadsSummaryFunc: &DBStoreRecentUploadsSummaryFunc{
			defaultHook: func(context.Context, int) (r0 []dbstore.UploadsWithRepositoryNamespace, r1 error) {
				return
			},
		},
		ReferenceIDsFunc: &DBStoreReferenceIDsFunc{
			defaultHook: func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (r0 dbstore.PackageReferenceScanner, r1 int, r2 error) {
				return
			},
		},
		RepoIDsByGlobPatternsFunc: &DBStoreRepoIDsByGlobPatternsFunc{
			defaultHook: func(context.Context, []string, int, int) (r0 []int, r1 int, r2 error) {
				return
			},
		},
		RepoNameFunc: &DBStoreRepoNameFunc{
			defaultHook: func(context.Context, int) (r0 string, r1 error) {
				return
			},
		},
		RepoNamesFunc: &DBStoreRepoNamesFunc{
			defaultHook: func(context.Context, ...int) (r0 map[int]string, r1 error) {
				return
			},
		},
		RequestLanguageSupportFunc: &DBStoreRequestLanguageSupportFunc{
			defaultHook: func(context.Context, int, string) (r0 error) {
				return
			},
		},
		UpdateConfigurationPolicyFunc: &DBStoreUpdateConfigurationPolicyFunc{
			defaultHook: func(context.Context, dbstore.ConfigurationPolicy) (r0 error) {
				return
			},
		},
		UpdateIndexConfigurationByRepositoryIDFunc: &DBStoreUpdateIndexConfigurationByRepositoryIDFunc{
			defaultHook: func(context.Context, int, []byte) (r0 error) {
				return
			},
		},
	}
}

// NewStrictMockDBStore creates a new mock of the DBStore interface. All
// methods panic on invocation, unless overwritten.
func NewStrictMockDBStore() *MockDBStore {
	return &MockDBStore{
		CommitGraphMetadataFunc: &DBStoreCommitGraphMetadataFunc{
			defaultHook: func(context.Context, int) (bool, *time.Time, error) {
				panic("unexpected invocation of MockDBStore.CommitGraphMetadata")
			},
		},
		CommitsVisibleToUploadFunc: &DBStoreCommitsVisibleToUploadFunc{
			defaultHook: func(context.Context, int, int, *string) ([]string, *string, error) {
				panic("unexpected invocation of MockDBStore.CommitsVisibleToUpload")
			},
		},
		CreateConfigurationPolicyFunc: &DBStoreCreateConfigurationPolicyFunc{
			defaultHook: func(context.Context, dbstore.ConfigurationPolicy) (dbstore.ConfigurationPolicy, error) {
				panic("unexpected invocation of MockDBStore.CreateConfigurationPolicy")
			},
		},
		DefinitionDumpsFunc: &DBStoreDefinitionDumpsFunc{
			defaultHook: func(context.Context, []precise.QualifiedMonikerData) ([]dbstore.Dump, error) {
				panic("unexpected invocation of MockDBStore.DefinitionDumps")
			},
		},
		DeleteConfigurationPolicyByIDFunc: &DBStoreDeleteConfigurationPolicyByIDFunc{
			defaultHook: func(context.Context, int) error {
				panic("unexpected invocation of MockDBStore.DeleteConfigurationPolicyByID")
			},
		},
		DeleteIndexByIDFunc: &DBStoreDeleteIndexByIDFunc{
			defaultHook: func(context.Context, int) (bool, error) {
				panic("unexpected invocation of MockDBStore.DeleteIndexByID")
			},
		},
		DeleteUploadByIDFunc: &DBStoreDeleteUploadByIDFunc{
			defaultHook: func(context.Context, int) (bool, error) {
				panic("unexpected invocation of MockDBStore.DeleteUploadByID")
			},
		},
		FindClosestDumpsFunc: &DBStoreFindClosestDumpsFunc{
			defaultHook: func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error) {
				panic("unexpected invocation of MockDBStore.FindClosestDumps")
			},
		},
		FindClosestDumpsFromGraphFragmentFunc: &DBStoreFindClosestDumpsFromGraphFragmentFunc{
			defaultHook: func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) ([]dbstore.Dump, error) {
				panic("unexpected invocation of MockDBStore.FindClosestDumpsFromGraphFragment")
			},
		},
		GetConfigurationPoliciesFunc: &DBStoreGetConfigurationPoliciesFunc{
			defaultHook: func(context.Context, dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error) {
				panic("unexpected invocation of MockDBStore.GetConfigurationPolicies")
			},
		},
		GetConfigurationPolicyByIDFunc: &DBStoreGetConfigurationPolicyByIDFunc{
			defaultHook: func(context.Context, int) (dbstore.ConfigurationPolicy, bool, error) {
				panic("unexpected invocation of MockDBStore.GetConfigurationPolicyByID")
			},
		},
		GetDumpsByIDsFunc: &DBStoreGetDumpsByIDsFunc{
			defaultHook: func(context.Context, []int) ([]dbstore.Dump, error) {
				panic("unexpected invocation of MockDBStore.GetDumpsByIDs")
			},
		},
		GetIndexByIDFunc: &DBStoreGetIndexByIDFunc{
			defaultHook: func(context.Context, int) (dbstore.Index, bool, error) {
				panic("unexpected invocation of MockDBStore.GetIndexByID")
			},
		},
		GetIndexConfigurationByRepositoryIDFunc: &DBStoreGetIndexConfigurationByRepositoryIDFunc{
			defaultHook: func(context.Context, int) (dbstore.IndexConfiguration, bool, error) {
				panic("unexpected invocation of MockDBStore.GetIndexConfigurationByRepositoryID")
			},
		},
		GetIndexesFunc: &DBStoreGetIndexesFunc{
			defaultHook: func(context.Context, dbstore.GetIndexesOptions) ([]dbstore.Index, int, error) {
				panic("unexpected invocation of MockDBStore.GetIndexes")
			},
		},
		GetIndexesByIDsFunc: &DBStoreGetIndexesByIDsFunc{
			defaultHook: func(context.Context, ...int) ([]dbstore.Index, error) {
				panic("unexpected invocation of MockDBStore.GetIndexesByIDs")
			},
		},
		GetUploadByIDFunc: &DBStoreGetUploadByIDFunc{
			defaultHook: func(context.Context, int) (dbstore.Upload, bool, error) {
				panic("unexpected invocation of MockDBStore.GetUploadByID")
			},
		},
		GetUploadsFunc: &DBStoreGetUploadsFunc{
			defaultHook: func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error) {
				panic("unexpected invocation of MockDBStore.GetUploads")
			},
		},
		GetUploadsByIDsFunc: &DBStoreGetUploadsByIDsFunc{
			defaultHook: func(context.Context, ...int) ([]dbstore.Upload, error) {
				panic("unexpected invocation of MockDBStore.GetUploadsByIDs")
			},
		},
		HasCommitFunc: &DBStoreHasCommitFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				panic("unexpected invocation of MockDBStore.HasCommit")
			},
		},
		HasRepositoryFunc: &DBStoreHasRepositoryFunc{
			defaultHook: func(context.Context, int) (bool, error) {
				panic("unexpected invocation of MockDBStore.HasRepository")
			},
		},
		LanguagesRequestedByFunc: &DBStoreLanguagesRequestedByFunc{
			defaultHook: func(context.Context, int) ([]string, error) {
				panic("unexpected invocation of MockDBStore.LanguagesRequestedBy")
			},
		},
		LastIndexScanForRepositoryFunc: &DBStoreLastIndexScanForRepositoryFunc{
			defaultHook: func(context.Context, int) (*time.Time, error) {
				panic("unexpected invocation of MockDBStore.LastIndexScanForRepository")
			},
		},
		LastUploadRetentionScanForRepositoryFunc: &DBStoreLastUploadRetentionScanForRepositoryFunc{
			defaultHook: func(context.Context, int) (*time.Time, error) {
				panic("unexpected invocation of MockDBStore.LastUploadRetentionScanForRepository")
			},
		},
		MarkRepositoryAsDirtyFunc: &DBStoreMarkRepositoryAsDirtyFunc{
			defaultHook: func(context.Context, int) error {
				panic("unexpected invocation of MockDBStore.MarkRepositoryAsDirty")
			},
		},
		RecentIndexesSummaryFunc: &DBStoreRecentIndexesSummaryFunc{
			defaultHook: func(context.Context, int) ([]dbstore.IndexesWithRepositoryNamespace, error) {
				panic("unexpected invocation of MockDBStore.RecentIndexesSummary")
			},
		},
		RecentUploadsSummaryFunc: &DBStoreRecentUploadsSummaryFunc{
			defaultHook: func(context.Context, int) ([]dbstore.UploadsWithRepositoryNamespace, error) {
				panic("unexpected invocation of MockDBStore.RecentUploadsSummary")
			},
		},
		ReferenceIDsFunc: &DBStoreReferenceIDsFunc{
			defaultHook: func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (dbstore.PackageReferenceScanner, int, error) {
				panic("unexpected invocation of MockDBStore.ReferenceIDs")
			},
		},
		RepoIDsByGlobPatternsFunc: &DBStoreRepoIDsByGlobPatternsFunc{
			defaultHook: func(context.Context, []string, int, int) ([]int, int, error) {
				panic("unexpected invocation of MockDBStore.RepoIDsByGlobPatterns")
			},
		},
		RepoNameFunc: &DBStoreRepoNameFunc{
			defaultHook: func(context.Context, int) (string, error) {
				panic("unexpected invocation of MockDBStore.RepoName")
			},
		},
		RepoNamesFunc: &DBStoreRepoNamesFunc{
			defaultHook: func(context.Context, ...int) (map[int]string, error) {
				panic("unexpected invocation of MockDBStore.RepoNames")
			},
		},
		RequestLanguageSupportFunc: &DBStoreRequestLanguageSupportFunc{
			defaultHook: func(context.Context, int, string) error {
				panic("unexpected invocation of MockDBStore.RequestLanguageSupport")
			},
		},
		UpdateConfigurationPolicyFunc: &DBStoreUpdateConfigurationPolicyFunc{
			defaultHook: func(context.Context, dbstore.ConfigurationPolicy) error {
				panic("unexpected invocation of MockDBStore.UpdateConfigurationPolicy")
			},
		},
		UpdateIndexConfigurationByRepositoryIDFunc: &DBStoreUpdateIndexConfigurationByRepositoryIDFunc{
			defaultHook: func(context.Context, int, []byte) error {
				panic("unexpected invocation of MockDBStore.UpdateIndexConfigurationByRepositoryID")
			},
		},
	}
}

// NewMockDBStoreFrom creates a new mock of the MockDBStore interface. All
// methods delegate to the given implementation, unless overwritten.
func NewMockDBStoreFrom(i DBStore) *MockDBStore {
	return &MockDBStore{
		CommitGraphMetadataFunc: &DBStoreCommitGraphMetadataFunc{
			defaultHook: i.CommitGraphMetadata,
		},
		CommitsVisibleToUploadFunc: &DBStoreCommitsVisibleToUploadFunc{
			defaultHook: i.CommitsVisibleToUpload,
		},
		CreateConfigurationPolicyFunc: &DBStoreCreateConfigurationPolicyFunc{
			defaultHook: i.CreateConfigurationPolicy,
		},
		DefinitionDumpsFunc: &DBStoreDefinitionDumpsFunc{
			defaultHook: i.DefinitionDumps,
		},
		DeleteConfigurationPolicyByIDFunc: &DBStoreDeleteConfigurationPolicyByIDFunc{
			defaultHook: i.DeleteConfigurationPolicyByID,
		},
		DeleteIndexByIDFunc: &DBStoreDeleteIndexByIDFunc{
			defaultHook: i.DeleteIndexByID,
		},
		DeleteUploadByIDFunc: &DBStoreDeleteUploadByIDFunc{
			defaultHook: i.DeleteUploadByID,
		},
		FindClosestDumpsFunc: &DBStoreFindClosestDumpsFunc{
			defaultHook: i.FindClosestDumps,
		},
		FindClosestDumpsFromGraphFragmentFunc: &DBStoreFindClosestDumpsFromGraphFragmentFunc{
			defaultHook: i.FindClosestDumpsFromGraphFragment,
		},
		GetConfigurationPoliciesFunc: &DBStoreGetConfigurationPoliciesFunc{
			defaultHook: i.GetConfigurationPolicies,
		},
		GetConfigurationPolicyByIDFunc: &DBStoreGetConfigurationPolicyByIDFunc{
			defaultHook: i.GetConfigurationPolicyByID,
		},
		GetDumpsByIDsFunc: &DBStoreGetDumpsByIDsFunc{
			defaultHook: i.GetDumpsByIDs,
		},
		GetIndexByIDFunc: &DBStoreGetIndexByIDFunc{
			defaultHook: i.GetIndexByID,
		},
		GetIndexConfigurationByRepositoryIDFunc: &DBStoreGetIndexConfigurationByRepositoryIDFunc{
			defaultHook: i.GetIndexConfigurationByRepositoryID,
		},
		GetIndexesFunc: &DBStoreGetIndexesFunc{
			defaultHook: i.GetIndexes,
		},
		GetIndexesByIDsFunc: &DBStoreGetIndexesByIDsFunc{
			defaultHook: i.GetIndexesByIDs,
		},
		GetUploadByIDFunc: &DBStoreGetUploadByIDFunc{
			defaultHook: i.GetUploadByID,
		},
		GetUploadsFunc: &DBStoreGetUploadsFunc{
			defaultHook: i.GetUploads,
		},
		GetUploadsByIDsFunc: &DBStoreGetUploadsByIDsFunc{
			defaultHook: i.GetUploadsByIDs,
		},
		HasCommitFunc: &DBStoreHasCommitFunc{
			defaultHook: i.HasCommit,
		},
		HasRepositoryFunc: &DBStoreHasRepositoryFunc{
			defaultHook: i.HasRepository,
		},
		LanguagesRequestedByFunc: &DBStoreLanguagesRequestedByFunc{
			defaultHook: i.LanguagesRequestedBy,
		},
		LastIndexScanForRepositoryFunc: &DBStoreLastIndexScanForRepositoryFunc{
			defaultHook: i.LastIndexScanForRepository,
		},
		LastUploadRetentionScanForRepositoryFunc: &DBStoreLastUploadRetentionScanForRepositoryFunc{
			defaultHook: i.LastUploadRetentionScanForRepository,
		},
		MarkRepositoryAsDirtyFunc: &DBStoreMarkRepositoryAsDirtyFunc{
			defaultHook: i.MarkRepositoryAsDirty,
		},
		RecentIndexesSummaryFunc: &DBStoreRecentIndexesSummaryFunc{
			defaultHook: i.RecentIndexesSummary,
		},
		RecentUploadsSummaryFunc: &DBStoreRecentUploadsSummaryFunc{
			defaultHook: i.RecentUploadsSummary,
		},
		ReferenceIDsFunc: &DBStoreReferenceIDsFunc{
			defaultHook: i.ReferenceIDs,
		},
		RepoIDsByGlobPatternsFunc: &DBStoreRepoIDsByGlobPatternsFunc{
			defaultHook: i.RepoIDsByGlobPatterns,
		},
		RepoNameFunc: &DBStoreRepoNameFunc{
			defaultHook: i.RepoName,
		},
		RepoNamesFunc: &DBStoreRepoNamesFunc{
			defaultHook: i.RepoNames,
		},
		RequestLanguageSupportFunc: &DBStoreRequestLanguageSupportFunc{
			defaultHook: i.RequestLanguageSupport,
		},
		UpdateConfigurationPolicyFunc: &DBStoreUpdateConfigurationPolicyFunc{
			defaultHook: i.UpdateConfigurationPolicy,
		},
		UpdateIndexConfigurationByRepositoryIDFunc: &DBStoreUpdateIndexConfigurationByRepositoryIDFunc{
			defaultHook: i.UpdateIndexConfigurationByRepositoryID,
		},
	}
}

// DBStoreCommitGraphMetadataFunc describes the behavior when the
// CommitGraphMetadata method of the parent MockDBStore instance is invoked.
type DBStoreCommitGraphMetadataFunc struct {
	defaultHook func(context.Context, int) (bool, *time.Time, error)
	hooks       []func(context.Context, int) (bool, *time.Time, error)
	history     []DBStoreCommitGraphMetadataFuncCall
	mutex       sync.Mutex
}

// CommitGraphMetadata delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) CommitGraphMetadata(v0 context.Context, v1 int) (bool, *time.Time, error) {
	r0, r1, r2 := m.CommitGraphMetadataFunc.nextHook()(v0, v1)
	m.CommitGraphMetadataFunc.appendCall(DBStoreCommitGraphMetadataFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the CommitGraphMetadata
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreCommitGraphMetadataFunc) SetDefaultHook(hook func(context.Context, int) (bool, *time.Time, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitGraphMetadata method of the parent MockDBStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *DBStoreCommitGraphMetadataFunc) PushHook(hook func(context.Context, int) (bool, *time.Time, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreCommitGraphMetadataFunc) SetDefaultReturn(r0 bool, r1 *time.Time, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (bool, *time.Time, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreCommitGraphMetadataFunc) PushReturn(r0 bool, r1 *time.Time, r2 error) {
	f.PushHook(func(context.Context, int) (bool, *time.Time, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreCommitGraphMetadataFunc) nextHook() func(context.Context, int) (bool, *time.Time, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreCommitGraphMetadataFunc) appendCall(r0 DBStoreCommitGraphMetadataFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreCommitGraphMetadataFuncCall objects
// describing the invocations of this function.
func (f *DBStoreCommitGraphMetadataFunc) History() []DBStoreCommitGraphMetadataFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreCommitGraphMetadataFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreCommitGraphMetadataFuncCall is an object that describes an
// invocation of method CommitGraphMetadata on an instance of MockDBStore.
type DBStoreCommitGraphMetadataFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 *time.Time
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreCommitGraphMetadataFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreCommitGraphMetadataFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreCommitsVisibleToUploadFunc describes the behavior when the
// CommitsVisibleToUpload method of the parent MockDBStore instance is
// invoked.
type DBStoreCommitsVisibleToUploadFunc struct {
	defaultHook func(context.Context, int, int, *string) ([]string, *string, error)
	hooks       []func(context.Context, int, int, *string) ([]string, *string, error)
	history     []DBStoreCommitsVisibleToUploadFuncCall
	mutex       sync.Mutex
}

// CommitsVisibleToUpload delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) CommitsVisibleToUpload(v0 context.Context, v1 int, v2 int, v3 *string) ([]string, *string, error) {
	r0, r1, r2 := m.CommitsVisibleToUploadFunc.nextHook()(v0, v1, v2, v3)
	m.CommitsVisibleToUploadFunc.appendCall(DBStoreCommitsVisibleToUploadFuncCall{v0, v1, v2, v3, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// CommitsVisibleToUpload method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreCommitsVisibleToUploadFunc) SetDefaultHook(hook func(context.Context, int, int, *string) ([]string, *string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitsVisibleToUpload method of the parent MockDBStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreCommitsVisibleToUploadFunc) PushHook(hook func(context.Context, int, int, *string) ([]string, *string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreCommitsVisibleToUploadFunc) SetDefaultReturn(r0 []string, r1 *string, r2 error) {
	f.SetDefaultHook(func(context.Context, int, int, *string) ([]string, *string, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreCommitsVisibleToUploadFunc) PushReturn(r0 []string, r1 *string, r2 error) {
	f.PushHook(func(context.Context, int, int, *string) ([]string, *string, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreCommitsVisibleToUploadFunc) nextHook() func(context.Context, int, int, *string) ([]string, *string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreCommitsVisibleToUploadFunc) appendCall(r0 DBStoreCommitsVisibleToUploadFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreCommitsVisibleToUploadFuncCall
// objects describing the invocations of this function.
func (f *DBStoreCommitsVisibleToUploadFunc) History() []DBStoreCommitsVisibleToUploadFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreCommitsVisibleToUploadFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreCommitsVisibleToUploadFuncCall is an object that describes an
// invocation of method CommitsVisibleToUpload on an instance of
// MockDBStore.
type DBStoreCommitsVisibleToUploadFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 *string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 *string
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreCommitsVisibleToUploadFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreCommitsVisibleToUploadFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreCreateConfigurationPolicyFunc describes the behavior when the
// CreateConfigurationPolicy method of the parent MockDBStore instance is
// invoked.
type DBStoreCreateConfigurationPolicyFunc struct {
	defaultHook func(context.Context, dbstore.ConfigurationPolicy) (dbstore.ConfigurationPolicy, error)
	hooks       []func(context.Context, dbstore.ConfigurationPolicy) (dbstore.ConfigurationPolicy, error)
	history     []DBStoreCreateConfigurationPolicyFuncCall
	mutex       sync.Mutex
}

// CreateConfigurationPolicy delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockDBStore) CreateConfigurationPolicy(v0 context.Context, v1 dbstore.ConfigurationPolicy) (dbstore.ConfigurationPolicy, error) {
	r0, r1 := m.CreateConfigurationPolicyFunc.nextHook()(v0, v1)
	m.CreateConfigurationPolicyFunc.appendCall(DBStoreCreateConfigurationPolicyFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CreateConfigurationPolicy method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreCreateConfigurationPolicyFunc) SetDefaultHook(hook func(context.Context, dbstore.ConfigurationPolicy) (dbstore.ConfigurationPolicy, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CreateConfigurationPolicy method of the parent MockDBStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *DBStoreCreateConfigurationPolicyFunc) PushHook(hook func(context.Context, dbstore.ConfigurationPolicy) (dbstore.ConfigurationPolicy, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreCreateConfigurationPolicyFunc) SetDefaultReturn(r0 dbstore.ConfigurationPolicy, r1 error) {
	f.SetDefaultHook(func(context.Context, dbstore.ConfigurationPolicy) (dbstore.ConfigurationPolicy, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreCreateConfigurationPolicyFunc) PushReturn(r0 dbstore.ConfigurationPolicy, r1 error) {
	f.PushHook(func(context.Context, dbstore.ConfigurationPolicy) (dbstore.ConfigurationPolicy, error) {
		return r0, r1
	})
}

func (f *DBStoreCreateConfigurationPolicyFunc) nextHook() func(context.Context, dbstore.ConfigurationPolicy) (dbstore.ConfigurationPolicy, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreCreateConfigurationPolicyFunc) appendCall(r0 DBStoreCreateConfigurationPolicyFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreCreateConfigurationPolicyFuncCall
// objects describing the invocations of this function.
func (f *DBStoreCreateConfigurationPolicyFunc) History() []DBStoreCreateConfigurationPolicyFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreCreateConfigurationPolicyFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreCreateConfigurationPolicyFuncCall is an object that describes an
// invocation of method CreateConfigurationPolicy on an instance of
// MockDBStore.
type DBStoreCreateConfigurationPolicyFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 dbstore.ConfigurationPolicy
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 dbstore.ConfigurationPolicy
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreCreateConfigurationPolicyFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreCreateConfigurationPolicyFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreDefinitionDumpsFunc describes the behavior when the
// DefinitionDumps method of the parent MockDBStore instance is invoked.
type DBStoreDefinitionDumpsFunc struct {
	defaultHook func(context.Context, []precise.QualifiedMonikerData) ([]dbstore.Dump, error)
	hooks       []func(context.Context, []precise.QualifiedMonikerData) ([]dbstore.Dump, error)
	history     []DBStoreDefinitionDumpsFuncCall
	mutex       sync.Mutex
}

// DefinitionDumps delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) DefinitionDumps(v0 context.Context, v1 []precise.QualifiedMonikerData) ([]dbstore.Dump, error) {
	r0, r1 := m.DefinitionDumpsFunc.nextHook()(v0, v1)
	m.DefinitionDumpsFunc.appendCall(DBStoreDefinitionDumpsFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DefinitionDumps
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreDefinitionDumpsFunc) SetDefaultHook(hook func(context.Context, []precise.QualifiedMonikerData) ([]dbstore.Dump, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DefinitionDumps method of the parent MockDBStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *DBStoreDefinitionDumpsFunc) PushHook(hook func(context.Context, []precise.QualifiedMonikerData) ([]dbstore.Dump, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreDefinitionDumpsFunc) SetDefaultReturn(r0 []dbstore.Dump, r1 error) {
	f.SetDefaultHook(func(context.Context, []precise.QualifiedMonikerData) ([]dbstore.Dump, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreDefinitionDumpsFunc) PushReturn(r0 []dbstore.Dump, r1 error) {
	f.PushHook(func(context.Context, []precise.QualifiedMonikerData) ([]dbstore.Dump, error) {
		return r0, r1
	})
}

func (f *DBStoreDefinitionDumpsFunc) nextHook() func(context.Context, []precise.QualifiedMonikerData) ([]dbstore.Dump, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreDefinitionDumpsFunc) appendCall(r0 DBStoreDefinitionDumpsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreDefinitionDumpsFuncCall objects
// describing the invocations of this function.
func (f *DBStoreDefinitionDumpsFunc) History() []DBStoreDefinitionDumpsFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreDefinitionDumpsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreDefinitionDumpsFuncCall is an object that describes an invocation
// of method DefinitionDumps on an instance of MockDBStore.
type DBStoreDefinitionDumpsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []precise.QualifiedMonikerData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreDefinitionDumpsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreDefinitionDumpsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreDeleteConfigurationPolicyByIDFunc describes the behavior when the
// DeleteConfigurationPolicyByID method of the parent MockDBStore instance
// is invoked.
type DBStoreDeleteConfigurationPolicyByIDFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []DBStoreDeleteConfigurationPolicyByIDFuncCall
	mutex       sync.Mutex
}

// DeleteConfigurationPolicyByID delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockDBStore) DeleteConfigurationPolicyByID(v0 context.Context, v1 int) error {
	r0 := m.DeleteConfigurationPolicyByIDFunc.nextHook()(v0, v1)
	m.DeleteConfigurationPolicyByIDFunc.appendCall(DBStoreDeleteConfigurationPolicyByIDFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// DeleteConfigurationPolicyByID method of the parent MockDBStore instance
// is invoked and the hook queue is empty.
func (f *DBStoreDeleteConfigurationPolicyByIDFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteConfigurationPolicyByID method of the parent MockDBStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *DBStoreDeleteConfigurationPolicyByIDFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreDeleteConfigurationPolicyByIDFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreDeleteConfigurationPolicyByIDFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *DBStoreDeleteConfigurationPolicyByIDFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreDeleteConfigurationPolicyByIDFunc) appendCall(r0 DBStoreDeleteConfigurationPolicyByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// DBStoreDeleteConfigurationPolicyByIDFuncCall objects describing the
// invocations of this function.
func (f *DBStoreDeleteConfigurationPolicyByIDFunc) History() []DBStoreDeleteConfigurationPolicyByIDFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreDeleteConfigurationPolicyByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreDeleteConfigurationPolicyByIDFuncCall is an object that describes
// an invocation of method DeleteConfigurationPolicyByID on an instance of
// MockDBStore.
type DBStoreDeleteConfigurationPolicyByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreDeleteConfigurationPolicyByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreDeleteConfigurationPolicyByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreDeleteIndexByIDFunc describes the behavior when the
// DeleteIndexByID method of the parent MockDBStore instance is invoked.
type DBStoreDeleteIndexByIDFunc struct {
	defaultHook func(context.Context, int) (bool, error)
	hooks       []func(context.Context, int) (bool, error)
	history     []DBStoreDeleteIndexByIDFuncCall
	mutex       sync.Mutex
}

// DeleteIndexByID delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) DeleteIndexByID(v0 context.Context, v1 int) (bool, error) {
	r0, r1 := m.DeleteIndexByIDFunc.nextHook()(v0, v1)
	m.DeleteIndexByIDFunc.appendCall(DBStoreDeleteIndexByIDFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DeleteIndexByID
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreDeleteIndexByIDFunc) SetDefaultHook(hook func(context.Context, int) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteIndexByID method of the parent MockDBStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *DBStoreDeleteIndexByIDFunc) PushHook(hook func(context.Context, int) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreDeleteIndexByIDFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreDeleteIndexByIDFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

func (f *DBStoreDeleteIndexByIDFunc) nextHook() func(context.Context, int) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreDeleteIndexByIDFunc) appendCall(r0 DBStoreDeleteIndexByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreDeleteIndexByIDFuncCall objects
// describing the invocations of this function.
func (f *DBStoreDeleteIndexByIDFunc) History() []DBStoreDeleteIndexByIDFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreDeleteIndexByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreDeleteIndexByIDFuncCall is an object that describes an invocation
// of method DeleteIndexByID on an instance of MockDBStore.
type DBStoreDeleteIndexByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreDeleteIndexByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreDeleteIndexByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreDeleteUploadByIDFunc describes the behavior when the
// DeleteUploadByID method of the parent MockDBStore instance is invoked.
type DBStoreDeleteUploadByIDFunc struct {
	defaultHook func(context.Context, int) (bool, error)
	hooks       []func(context.Context, int) (bool, error)
	history     []DBStoreDeleteUploadByIDFuncCall
	mutex       sync.Mutex
}

// DeleteUploadByID delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) DeleteUploadByID(v0 context.Context, v1 int) (bool, error) {
	r0, r1 := m.DeleteUploadByIDFunc.nextHook()(v0, v1)
	m.DeleteUploadByIDFunc.appendCall(DBStoreDeleteUploadByIDFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DeleteUploadByID
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreDeleteUploadByIDFunc) SetDefaultHook(hook func(context.Context, int) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteUploadByID method of the parent MockDBStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *DBStoreDeleteUploadByIDFunc) PushHook(hook func(context.Context, int) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreDeleteUploadByIDFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreDeleteUploadByIDFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

func (f *DBStoreDeleteUploadByIDFunc) nextHook() func(context.Context, int) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreDeleteUploadByIDFunc) appendCall(r0 DBStoreDeleteUploadByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreDeleteUploadByIDFuncCall objects
// describing the invocations of this function.
func (f *DBStoreDeleteUploadByIDFunc) History() []DBStoreDeleteUploadByIDFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreDeleteUploadByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreDeleteUploadByIDFuncCall is an object that describes an invocation
// of method DeleteUploadByID on an instance of MockDBStore.
type DBStoreDeleteUploadByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreDeleteUploadByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreDeleteUploadByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreFindClosestDumpsFunc describes the behavior when the
// FindClosestDumps method of the parent MockDBStore instance is invoked.
type DBStoreFindClosestDumpsFunc struct {
	defaultHook func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error)
	hooks       []func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error)
	history     []DBStoreFindClosestDumpsFuncCall
	mutex       sync.Mutex
}

// FindClosestDumps delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) FindClosestDumps(v0 context.Context, v1 int, v2 string, v3 string, v4 bool, v5 string) ([]dbstore.Dump, error) {
	r0, r1 := m.FindClosestDumpsFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.FindClosestDumpsFunc.appendCall(DBStoreFindClosestDumpsFuncCall{v0, v1, v2, v3, v4, v5, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the FindClosestDumps
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreFindClosestDumpsFunc) SetDefaultHook(hook func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// FindClosestDumps method of the parent MockDBStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *DBStoreFindClosestDumpsFunc) PushHook(hook func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreFindClosestDumpsFunc) SetDefaultReturn(r0 []dbstore.Dump, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreFindClosestDumpsFunc) PushReturn(r0 []dbstore.Dump, r1 error) {
	f.PushHook(func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error) {
		return r0, r1
	})
}

func (f *DBStoreFindClosestDumpsFunc) nextHook() func(context.Context, int, string, string, bool, string) ([]dbstore.Dump, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreFindClosestDumpsFunc) appendCall(r0 DBStoreFindClosestDumpsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreFindClosestDumpsFuncCall objects
// describing the invocations of this function.
func (f *DBStoreFindClosestDumpsFunc) History() []DBStoreFindClosestDumpsFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreFindClosestDumpsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreFindClosestDumpsFuncCall is an object that describes an invocation
// of method FindClosestDumps on an instance of MockDBStore.
type DBStoreFindClosestDumpsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 bool
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreFindClosestDumpsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreFindClosestDumpsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreFindClosestDumpsFromGraphFragmentFunc describes the behavior when
// the FindClosestDumpsFromGraphFragment method of the parent MockDBStore
// instance is invoked.
type DBStoreFindClosestDumpsFromGraphFragmentFunc struct {
	defaultHook func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) ([]dbstore.Dump, error)
	hooks       []func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) ([]dbstore.Dump, error)
	history     []DBStoreFindClosestDumpsFromGraphFragmentFuncCall
	mutex       sync.Mutex
}

// FindClosestDumpsFromGraphFragment delegates to the next hook function in
// the queue and stores the parameter and result values of this invocation.
func (m *MockDBStore) FindClosestDumpsFromGraphFragment(v0 context.Context, v1 int, v2 string, v3 string, v4 bool, v5 string, v6 *gitdomain.CommitGraph) ([]dbstore.Dump, error) {
	r0, r1 := m.FindClosestDumpsFromGraphFragmentFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6)
	m.FindClosestDumpsFromGraphFragmentFunc.appendCall(DBStoreFindClosestDumpsFromGraphFragmentFuncCall{v0, v1, v2, v3, v4, v5, v6, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// FindClosestDumpsFromGraphFragment method of the parent MockDBStore
// instance is invoked and the hook queue is empty.
func (f *DBStoreFindClosestDumpsFromGraphFragmentFunc) SetDefaultHook(hook func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) ([]dbstore.Dump, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// FindClosestDumpsFromGraphFragment method of the parent MockDBStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *DBStoreFindClosestDumpsFromGraphFragmentFunc) PushHook(hook func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) ([]dbstore.Dump, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreFindClosestDumpsFromGraphFragmentFunc) SetDefaultReturn(r0 []dbstore.Dump, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) ([]dbstore.Dump, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreFindClosestDumpsFromGraphFragmentFunc) PushReturn(r0 []dbstore.Dump, r1 error) {
	f.PushHook(func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) ([]dbstore.Dump, error) {
		return r0, r1
	})
}

func (f *DBStoreFindClosestDumpsFromGraphFragmentFunc) nextHook() func(context.Context, int, string, string, bool, string, *gitdomain.CommitGraph) ([]dbstore.Dump, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreFindClosestDumpsFromGraphFragmentFunc) appendCall(r0 DBStoreFindClosestDumpsFromGraphFragmentFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// DBStoreFindClosestDumpsFromGraphFragmentFuncCall objects describing the
// invocations of this function.
func (f *DBStoreFindClosestDumpsFromGraphFragmentFunc) History() []DBStoreFindClosestDumpsFromGraphFragmentFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreFindClosestDumpsFromGraphFragmentFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreFindClosestDumpsFromGraphFragmentFuncCall is an object that
// describes an invocation of method FindClosestDumpsFromGraphFragment on an
// instance of MockDBStore.
type DBStoreFindClosestDumpsFromGraphFragmentFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 bool
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 string
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 *gitdomain.CommitGraph
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreFindClosestDumpsFromGraphFragmentFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreFindClosestDumpsFromGraphFragmentFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreGetConfigurationPoliciesFunc describes the behavior when the
// GetConfigurationPolicies method of the parent MockDBStore instance is
// invoked.
type DBStoreGetConfigurationPoliciesFunc struct {
	defaultHook func(context.Context, dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error)
	hooks       []func(context.Context, dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error)
	history     []DBStoreGetConfigurationPoliciesFuncCall
	mutex       sync.Mutex
}

// GetConfigurationPolicies delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) GetConfigurationPolicies(v0 context.Context, v1 dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error) {
	r0, r1, r2 := m.GetConfigurationPoliciesFunc.nextHook()(v0, v1)
	m.GetConfigurationPoliciesFunc.appendCall(DBStoreGetConfigurationPoliciesFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// GetConfigurationPolicies method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreGetConfigurationPoliciesFunc) SetDefaultHook(hook func(context.Context, dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetConfigurationPolicies method of the parent MockDBStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *DBStoreGetConfigurationPoliciesFunc) PushHook(hook func(context.Context, dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreGetConfigurationPoliciesFunc) SetDefaultReturn(r0 []dbstore.ConfigurationPolicy, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreGetConfigurationPoliciesFunc) PushReturn(r0 []dbstore.ConfigurationPolicy, r1 int, r2 error) {
	f.PushHook(func(context.Context, dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreGetConfigurationPoliciesFunc) nextHook() func(context.Context, dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetConfigurationPoliciesFunc) appendCall(r0 DBStoreGetConfigurationPoliciesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetConfigurationPoliciesFuncCall
// objects describing the invocations of this function.
func (f *DBStoreGetConfigurationPoliciesFunc) History() []DBStoreGetConfigurationPoliciesFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetConfigurationPoliciesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetConfigurationPoliciesFuncCall is an object that describes an
// invocation of method GetConfigurationPolicies on an instance of
// MockDBStore.
type DBStoreGetConfigurationPoliciesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 dbstore.GetConfigurationPoliciesOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.ConfigurationPolicy
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetConfigurationPoliciesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetConfigurationPoliciesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreGetConfigurationPolicyByIDFunc describes the behavior when the
// GetConfigurationPolicyByID method of the parent MockDBStore instance is
// invoked.
type DBStoreGetConfigurationPolicyByIDFunc struct {
	defaultHook func(context.Context, int) (dbstore.ConfigurationPolicy, bool, error)
	hooks       []func(context.Context, int) (dbstore.ConfigurationPolicy, bool, error)
	history     []DBStoreGetConfigurationPolicyByIDFuncCall
	mutex       sync.Mutex
}

// GetConfigurationPolicyByID delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockDBStore) GetConfigurationPolicyByID(v0 context.Context, v1 int) (dbstore.ConfigurationPolicy, bool, error) {
	r0, r1, r2 := m.GetConfigurationPolicyByIDFunc.nextHook()(v0, v1)
	m.GetConfigurationPolicyByIDFunc.appendCall(DBStoreGetConfigurationPolicyByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// GetConfigurationPolicyByID method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreGetConfigurationPolicyByIDFunc) SetDefaultHook(hook func(context.Context, int) (dbstore.ConfigurationPolicy, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetConfigurationPolicyByID method of the parent MockDBStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *DBStoreGetConfigurationPolicyByIDFunc) PushHook(hook func(context.Context, int) (dbstore.ConfigurationPolicy, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreGetConfigurationPolicyByIDFunc) SetDefaultReturn(r0 dbstore.ConfigurationPolicy, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (dbstore.ConfigurationPolicy, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreGetConfigurationPolicyByIDFunc) PushReturn(r0 dbstore.ConfigurationPolicy, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (dbstore.ConfigurationPolicy, bool, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreGetConfigurationPolicyByIDFunc) nextHook() func(context.Context, int) (dbstore.ConfigurationPolicy, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetConfigurationPolicyByIDFunc) appendCall(r0 DBStoreGetConfigurationPolicyByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetConfigurationPolicyByIDFuncCall
// objects describing the invocations of this function.
func (f *DBStoreGetConfigurationPolicyByIDFunc) History() []DBStoreGetConfigurationPolicyByIDFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetConfigurationPolicyByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetConfigurationPolicyByIDFuncCall is an object that describes an
// invocation of method GetConfigurationPolicyByID on an instance of
// MockDBStore.
type DBStoreGetConfigurationPolicyByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 dbstore.ConfigurationPolicy
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetConfigurationPolicyByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetConfigurationPolicyByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreGetDumpsByIDsFunc describes the behavior when the GetDumpsByIDs
// method of the parent MockDBStore instance is invoked.
type DBStoreGetDumpsByIDsFunc struct {
	defaultHook func(context.Context, []int) ([]dbstore.Dump, error)
	hooks       []func(context.Context, []int) ([]dbstore.Dump, error)
	history     []DBStoreGetDumpsByIDsFuncCall
	mutex       sync.Mutex
}

// GetDumpsByIDs delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) GetDumpsByIDs(v0 context.Context, v1 []int) ([]dbstore.Dump, error) {
	r0, r1 := m.GetDumpsByIDsFunc.nextHook()(v0, v1)
	m.GetDumpsByIDsFunc.appendCall(DBStoreGetDumpsByIDsFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetDumpsByIDs method
// of the parent MockDBStore instance is invoked and the hook queue is
// empty.
func (f *DBStoreGetDumpsByIDsFunc) SetDefaultHook(hook func(context.Context, []int) ([]dbstore.Dump, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetDumpsByIDs method of the parent MockDBStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreGetDumpsByIDsFunc) PushHook(hook func(context.Context, []int) ([]dbstore.Dump, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreGetDumpsByIDsFunc) SetDefaultReturn(r0 []dbstore.Dump, r1 error) {
	f.SetDefaultHook(func(context.Context, []int) ([]dbstore.Dump, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreGetDumpsByIDsFunc) PushReturn(r0 []dbstore.Dump, r1 error) {
	f.PushHook(func(context.Context, []int) ([]dbstore.Dump, error) {
		return r0, r1
	})
}

func (f *DBStoreGetDumpsByIDsFunc) nextHook() func(context.Context, []int) ([]dbstore.Dump, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetDumpsByIDsFunc) appendCall(r0 DBStoreGetDumpsByIDsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetDumpsByIDsFuncCall objects
// describing the invocations of this function.
func (f *DBStoreGetDumpsByIDsFunc) History() []DBStoreGetDumpsByIDsFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetDumpsByIDsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetDumpsByIDsFuncCall is an object that describes an invocation of
// method GetDumpsByIDs on an instance of MockDBStore.
type DBStoreGetDumpsByIDsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetDumpsByIDsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetDumpsByIDsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreGetIndexByIDFunc describes the behavior when the GetIndexByID
// method of the parent MockDBStore instance is invoked.
type DBStoreGetIndexByIDFunc struct {
	defaultHook func(context.Context, int) (dbstore.Index, bool, error)
	hooks       []func(context.Context, int) (dbstore.Index, bool, error)
	history     []DBStoreGetIndexByIDFuncCall
	mutex       sync.Mutex
}

// GetIndexByID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) GetIndexByID(v0 context.Context, v1 int) (dbstore.Index, bool, error) {
	r0, r1, r2 := m.GetIndexByIDFunc.nextHook()(v0, v1)
	m.GetIndexByIDFunc.appendCall(DBStoreGetIndexByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetIndexByID method
// of the parent MockDBStore instance is invoked and the hook queue is
// empty.
func (f *DBStoreGetIndexByIDFunc) SetDefaultHook(hook func(context.Context, int) (dbstore.Index, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexByID method of the parent MockDBStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreGetIndexByIDFunc) PushHook(hook func(context.Context, int) (dbstore.Index, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreGetIndexByIDFunc) SetDefaultReturn(r0 dbstore.Index, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (dbstore.Index, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreGetIndexByIDFunc) PushReturn(r0 dbstore.Index, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (dbstore.Index, bool, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreGetIndexByIDFunc) nextHook() func(context.Context, int) (dbstore.Index, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetIndexByIDFunc) appendCall(r0 DBStoreGetIndexByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetIndexByIDFuncCall objects
// describing the invocations of this function.
func (f *DBStoreGetIndexByIDFunc) History() []DBStoreGetIndexByIDFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetIndexByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetIndexByIDFuncCall is an object that describes an invocation of
// method GetIndexByID on an instance of MockDBStore.
type DBStoreGetIndexByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 dbstore.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetIndexByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetIndexByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreGetIndexConfigurationByRepositoryIDFunc describes the behavior
// when the GetIndexConfigurationByRepositoryID method of the parent
// MockDBStore instance is invoked.
type DBStoreGetIndexConfigurationByRepositoryIDFunc struct {
	defaultHook func(context.Context, int) (dbstore.IndexConfiguration, bool, error)
	hooks       []func(context.Context, int) (dbstore.IndexConfiguration, bool, error)
	history     []DBStoreGetIndexConfigurationByRepositoryIDFuncCall
	mutex       sync.Mutex
}

// GetIndexConfigurationByRepositoryID delegates to the next hook function
// in the queue and stores the parameter and result values of this
// invocation.
func (m *MockDBStore) GetIndexConfigurationByRepositoryID(v0 context.Context, v1 int) (dbstore.IndexConfiguration, bool, error) {
	r0, r1, r2 := m.GetIndexConfigurationByRepositoryIDFunc.nextHook()(v0, v1)
	m.GetIndexConfigurationByRepositoryIDFunc.appendCall(DBStoreGetIndexConfigurationByRepositoryIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// GetIndexConfigurationByRepositoryID method of the parent MockDBStore
// instance is invoked and the hook queue is empty.
func (f *DBStoreGetIndexConfigurationByRepositoryIDFunc) SetDefaultHook(hook func(context.Context, int) (dbstore.IndexConfiguration, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexConfigurationByRepositoryID method of the parent MockDBStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *DBStoreGetIndexConfigurationByRepositoryIDFunc) PushHook(hook func(context.Context, int) (dbstore.IndexConfiguration, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreGetIndexConfigurationByRepositoryIDFunc) SetDefaultReturn(r0 dbstore.IndexConfiguration, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (dbstore.IndexConfiguration, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreGetIndexConfigurationByRepositoryIDFunc) PushReturn(r0 dbstore.IndexConfiguration, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (dbstore.IndexConfiguration, bool, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreGetIndexConfigurationByRepositoryIDFunc) nextHook() func(context.Context, int) (dbstore.IndexConfiguration, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetIndexConfigurationByRepositoryIDFunc) appendCall(r0 DBStoreGetIndexConfigurationByRepositoryIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// DBStoreGetIndexConfigurationByRepositoryIDFuncCall objects describing the
// invocations of this function.
func (f *DBStoreGetIndexConfigurationByRepositoryIDFunc) History() []DBStoreGetIndexConfigurationByRepositoryIDFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetIndexConfigurationByRepositoryIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetIndexConfigurationByRepositoryIDFuncCall is an object that
// describes an invocation of method GetIndexConfigurationByRepositoryID on
// an instance of MockDBStore.
type DBStoreGetIndexConfigurationByRepositoryIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 dbstore.IndexConfiguration
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetIndexConfigurationByRepositoryIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetIndexConfigurationByRepositoryIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreGetIndexesFunc describes the behavior when the GetIndexes method
// of the parent MockDBStore instance is invoked.
type DBStoreGetIndexesFunc struct {
	defaultHook func(context.Context, dbstore.GetIndexesOptions) ([]dbstore.Index, int, error)
	hooks       []func(context.Context, dbstore.GetIndexesOptions) ([]dbstore.Index, int, error)
	history     []DBStoreGetIndexesFuncCall
	mutex       sync.Mutex
}

// GetIndexes delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) GetIndexes(v0 context.Context, v1 dbstore.GetIndexesOptions) ([]dbstore.Index, int, error) {
	r0, r1, r2 := m.GetIndexesFunc.nextHook()(v0, v1)
	m.GetIndexesFunc.appendCall(DBStoreGetIndexesFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetIndexes method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreGetIndexesFunc) SetDefaultHook(hook func(context.Context, dbstore.GetIndexesOptions) ([]dbstore.Index, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexes method of the parent MockDBStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreGetIndexesFunc) PushHook(hook func(context.Context, dbstore.GetIndexesOptions) ([]dbstore.Index, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreGetIndexesFunc) SetDefaultReturn(r0 []dbstore.Index, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, dbstore.GetIndexesOptions) ([]dbstore.Index, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreGetIndexesFunc) PushReturn(r0 []dbstore.Index, r1 int, r2 error) {
	f.PushHook(func(context.Context, dbstore.GetIndexesOptions) ([]dbstore.Index, int, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreGetIndexesFunc) nextHook() func(context.Context, dbstore.GetIndexesOptions) ([]dbstore.Index, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetIndexesFunc) appendCall(r0 DBStoreGetIndexesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetIndexesFuncCall objects
// describing the invocations of this function.
func (f *DBStoreGetIndexesFunc) History() []DBStoreGetIndexesFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetIndexesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetIndexesFuncCall is an object that describes an invocation of
// method GetIndexes on an instance of MockDBStore.
type DBStoreGetIndexesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 dbstore.GetIndexesOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetIndexesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetIndexesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreGetIndexesByIDsFunc describes the behavior when the
// GetIndexesByIDs method of the parent MockDBStore instance is invoked.
type DBStoreGetIndexesByIDsFunc struct {
	defaultHook func(context.Context, ...int) ([]dbstore.Index, error)
	hooks       []func(context.Context, ...int) ([]dbstore.Index, error)
	history     []DBStoreGetIndexesByIDsFuncCall
	mutex       sync.Mutex
}

// GetIndexesByIDs delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) GetIndexesByIDs(v0 context.Context, v1 ...int) ([]dbstore.Index, error) {
	r0, r1 := m.GetIndexesByIDsFunc.nextHook()(v0, v1...)
	m.GetIndexesByIDsFunc.appendCall(DBStoreGetIndexesByIDsFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetIndexesByIDs
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreGetIndexesByIDsFunc) SetDefaultHook(hook func(context.Context, ...int) ([]dbstore.Index, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexesByIDs method of the parent MockDBStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *DBStoreGetIndexesByIDsFunc) PushHook(hook func(context.Context, ...int) ([]dbstore.Index, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreGetIndexesByIDsFunc) SetDefaultReturn(r0 []dbstore.Index, r1 error) {
	f.SetDefaultHook(func(context.Context, ...int) ([]dbstore.Index, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreGetIndexesByIDsFunc) PushReturn(r0 []dbstore.Index, r1 error) {
	f.PushHook(func(context.Context, ...int) ([]dbstore.Index, error) {
		return r0, r1
	})
}

func (f *DBStoreGetIndexesByIDsFunc) nextHook() func(context.Context, ...int) ([]dbstore.Index, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetIndexesByIDsFunc) appendCall(r0 DBStoreGetIndexesByIDsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetIndexesByIDsFuncCall objects
// describing the invocations of this function.
func (f *DBStoreGetIndexesByIDsFunc) History() []DBStoreGetIndexesByIDsFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetIndexesByIDsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetIndexesByIDsFuncCall is an object that describes an invocation
// of method GetIndexesByIDs on an instance of MockDBStore.
type DBStoreGetIndexesByIDsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c DBStoreGetIndexesByIDsFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetIndexesByIDsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreGetUploadByIDFunc describes the behavior when the GetUploadByID
// method of the parent MockDBStore instance is invoked.
type DBStoreGetUploadByIDFunc struct {
	defaultHook func(context.Context, int) (dbstore.Upload, bool, error)
	hooks       []func(context.Context, int) (dbstore.Upload, bool, error)
	history     []DBStoreGetUploadByIDFuncCall
	mutex       sync.Mutex
}

// GetUploadByID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) GetUploadByID(v0 context.Context, v1 int) (dbstore.Upload, bool, error) {
	r0, r1, r2 := m.GetUploadByIDFunc.nextHook()(v0, v1)
	m.GetUploadByIDFunc.appendCall(DBStoreGetUploadByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetUploadByID method
// of the parent MockDBStore instance is invoked and the hook queue is
// empty.
func (f *DBStoreGetUploadByIDFunc) SetDefaultHook(hook func(context.Context, int) (dbstore.Upload, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadByID method of the parent MockDBStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreGetUploadByIDFunc) PushHook(hook func(context.Context, int) (dbstore.Upload, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreGetUploadByIDFunc) SetDefaultReturn(r0 dbstore.Upload, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (dbstore.Upload, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreGetUploadByIDFunc) PushReturn(r0 dbstore.Upload, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (dbstore.Upload, bool, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreGetUploadByIDFunc) nextHook() func(context.Context, int) (dbstore.Upload, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetUploadByIDFunc) appendCall(r0 DBStoreGetUploadByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetUploadByIDFuncCall objects
// describing the invocations of this function.
func (f *DBStoreGetUploadByIDFunc) History() []DBStoreGetUploadByIDFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetUploadByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetUploadByIDFuncCall is an object that describes an invocation of
// method GetUploadByID on an instance of MockDBStore.
type DBStoreGetUploadByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 dbstore.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetUploadByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetUploadByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreGetUploadsFunc describes the behavior when the GetUploads method
// of the parent MockDBStore instance is invoked.
type DBStoreGetUploadsFunc struct {
	defaultHook func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error)
	hooks       []func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error)
	history     []DBStoreGetUploadsFuncCall
	mutex       sync.Mutex
}

// GetUploads delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) GetUploads(v0 context.Context, v1 dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error) {
	r0, r1, r2 := m.GetUploadsFunc.nextHook()(v0, v1)
	m.GetUploadsFunc.appendCall(DBStoreGetUploadsFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetUploads method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreGetUploadsFunc) SetDefaultHook(hook func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploads method of the parent MockDBStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreGetUploadsFunc) PushHook(hook func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreGetUploadsFunc) SetDefaultReturn(r0 []dbstore.Upload, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreGetUploadsFunc) PushReturn(r0 []dbstore.Upload, r1 int, r2 error) {
	f.PushHook(func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreGetUploadsFunc) nextHook() func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetUploadsFunc) appendCall(r0 DBStoreGetUploadsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetUploadsFuncCall objects
// describing the invocations of this function.
func (f *DBStoreGetUploadsFunc) History() []DBStoreGetUploadsFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetUploadsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetUploadsFuncCall is an object that describes an invocation of
// method GetUploads on an instance of MockDBStore.
type DBStoreGetUploadsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 dbstore.GetUploadsOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetUploadsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetUploadsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreGetUploadsByIDsFunc describes the behavior when the
// GetUploadsByIDs method of the parent MockDBStore instance is invoked.
type DBStoreGetUploadsByIDsFunc struct {
	defaultHook func(context.Context, ...int) ([]dbstore.Upload, error)
	hooks       []func(context.Context, ...int) ([]dbstore.Upload, error)
	history     []DBStoreGetUploadsByIDsFuncCall
	mutex       sync.Mutex
}

// GetUploadsByIDs delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) GetUploadsByIDs(v0 context.Context, v1 ...int) ([]dbstore.Upload, error) {
	r0, r1 := m.GetUploadsByIDsFunc.nextHook()(v0, v1...)
	m.GetUploadsByIDsFunc.appendCall(DBStoreGetUploadsByIDsFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetUploadsByIDs
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreGetUploadsByIDsFunc) SetDefaultHook(hook func(context.Context, ...int) ([]dbstore.Upload, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadsByIDs method of the parent MockDBStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *DBStoreGetUploadsByIDsFunc) PushHook(hook func(context.Context, ...int) ([]dbstore.Upload, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreGetUploadsByIDsFunc) SetDefaultReturn(r0 []dbstore.Upload, r1 error) {
	f.SetDefaultHook(func(context.Context, ...int) ([]dbstore.Upload, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreGetUploadsByIDsFunc) PushReturn(r0 []dbstore.Upload, r1 error) {
	f.PushHook(func(context.Context, ...int) ([]dbstore.Upload, error) {
		return r0, r1
	})
}

func (f *DBStoreGetUploadsByIDsFunc) nextHook() func(context.Context, ...int) ([]dbstore.Upload, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetUploadsByIDsFunc) appendCall(r0 DBStoreGetUploadsByIDsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetUploadsByIDsFuncCall objects
// describing the invocations of this function.
func (f *DBStoreGetUploadsByIDsFunc) History() []DBStoreGetUploadsByIDsFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetUploadsByIDsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetUploadsByIDsFuncCall is an object that describes an invocation
// of method GetUploadsByIDs on an instance of MockDBStore.
type DBStoreGetUploadsByIDsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c DBStoreGetUploadsByIDsFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetUploadsByIDsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreHasCommitFunc describes the behavior when the HasCommit method of
// the parent MockDBStore instance is invoked.
type DBStoreHasCommitFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []DBStoreHasCommitFuncCall
	mutex       sync.Mutex
}

// HasCommit delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) HasCommit(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.HasCommitFunc.nextHook()(v0, v1, v2)
	m.HasCommitFunc.appendCall(DBStoreHasCommitFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the HasCommit method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreHasCommitFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// HasCommit method of the parent MockDBStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreHasCommitFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreHasCommitFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreHasCommitFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *DBStoreHasCommitFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreHasCommitFunc) appendCall(r0 DBStoreHasCommitFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreHasCommitFuncCall objects describing
// the invocations of this function.
func (f *DBStoreHasCommitFunc) History() []DBStoreHasCommitFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreHasCommitFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreHasCommitFuncCall is an object that describes an invocation of
// method HasCommit on an instance of MockDBStore.
type DBStoreHasCommitFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreHasCommitFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreHasCommitFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreHasRepositoryFunc describes the behavior when the HasRepository
// method of the parent MockDBStore instance is invoked.
type DBStoreHasRepositoryFunc struct {
	defaultHook func(context.Context, int) (bool, error)
	hooks       []func(context.Context, int) (bool, error)
	history     []DBStoreHasRepositoryFuncCall
	mutex       sync.Mutex
}

// HasRepository delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) HasRepository(v0 context.Context, v1 int) (bool, error) {
	r0, r1 := m.HasRepositoryFunc.nextHook()(v0, v1)
	m.HasRepositoryFunc.appendCall(DBStoreHasRepositoryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the HasRepository method
// of the parent MockDBStore instance is invoked and the hook queue is
// empty.
func (f *DBStoreHasRepositoryFunc) SetDefaultHook(hook func(context.Context, int) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// HasRepository method of the parent MockDBStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreHasRepositoryFunc) PushHook(hook func(context.Context, int) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreHasRepositoryFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreHasRepositoryFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

func (f *DBStoreHasRepositoryFunc) nextHook() func(context.Context, int) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreHasRepositoryFunc) appendCall(r0 DBStoreHasRepositoryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreHasRepositoryFuncCall objects
// describing the invocations of this function.
func (f *DBStoreHasRepositoryFunc) History() []DBStoreHasRepositoryFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreHasRepositoryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreHasRepositoryFuncCall is an object that describes an invocation of
// method HasRepository on an instance of MockDBStore.
type DBStoreHasRepositoryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreHasRepositoryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreHasRepositoryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreLanguagesRequestedByFunc describes the behavior when the
// LanguagesRequestedBy method of the parent MockDBStore instance is
// invoked.
type DBStoreLanguagesRequestedByFunc struct {
	defaultHook func(context.Context, int) ([]string, error)
	hooks       []func(context.Context, int) ([]string, error)
	history     []DBStoreLanguagesRequestedByFuncCall
	mutex       sync.Mutex
}

// LanguagesRequestedBy delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) LanguagesRequestedBy(v0 context.Context, v1 int) ([]string, error) {
	r0, r1 := m.LanguagesRequestedByFunc.nextHook()(v0, v1)
	m.LanguagesRequestedByFunc.appendCall(DBStoreLanguagesRequestedByFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the LanguagesRequestedBy
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreLanguagesRequestedByFunc) SetDefaultHook(hook func(context.Context, int) ([]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// LanguagesRequestedBy method of the parent MockDBStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreLanguagesRequestedByFunc) PushHook(hook func(context.Context, int) ([]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreLanguagesRequestedByFunc) SetDefaultReturn(r0 []string, r1 error) {
	f.SetDefaultHook(func(context.Context, int) ([]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreLanguagesRequestedByFunc) PushReturn(r0 []string, r1 error) {
	f.PushHook(func(context.Context, int) ([]string, error) {
		return r0, r1
	})
}

func (f *DBStoreLanguagesRequestedByFunc) nextHook() func(context.Context, int) ([]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreLanguagesRequestedByFunc) appendCall(r0 DBStoreLanguagesRequestedByFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreLanguagesRequestedByFuncCall objects
// describing the invocations of this function.
func (f *DBStoreLanguagesRequestedByFunc) History() []DBStoreLanguagesRequestedByFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreLanguagesRequestedByFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreLanguagesRequestedByFuncCall is an object that describes an
// invocation of method LanguagesRequestedBy on an instance of MockDBStore.
type DBStoreLanguagesRequestedByFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreLanguagesRequestedByFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreLanguagesRequestedByFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreLastIndexScanForRepositoryFunc describes the behavior when the
// LastIndexScanForRepository method of the parent MockDBStore instance is
// invoked.
type DBStoreLastIndexScanForRepositoryFunc struct {
	defaultHook func(context.Context, int) (*time.Time, error)
	hooks       []func(context.Context, int) (*time.Time, error)
	history     []DBStoreLastIndexScanForRepositoryFuncCall
	mutex       sync.Mutex
}

// LastIndexScanForRepository delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockDBStore) LastIndexScanForRepository(v0 context.Context, v1 int) (*time.Time, error) {
	r0, r1 := m.LastIndexScanForRepositoryFunc.nextHook()(v0, v1)
	m.LastIndexScanForRepositoryFunc.appendCall(DBStoreLastIndexScanForRepositoryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// LastIndexScanForRepository method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreLastIndexScanForRepositoryFunc) SetDefaultHook(hook func(context.Context, int) (*time.Time, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// LastIndexScanForRepository method of the parent MockDBStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *DBStoreLastIndexScanForRepositoryFunc) PushHook(hook func(context.Context, int) (*time.Time, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreLastIndexScanForRepositoryFunc) SetDefaultReturn(r0 *time.Time, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (*time.Time, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreLastIndexScanForRepositoryFunc) PushReturn(r0 *time.Time, r1 error) {
	f.PushHook(func(context.Context, int) (*time.Time, error) {
		return r0, r1
	})
}

func (f *DBStoreLastIndexScanForRepositoryFunc) nextHook() func(context.Context, int) (*time.Time, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreLastIndexScanForRepositoryFunc) appendCall(r0 DBStoreLastIndexScanForRepositoryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreLastIndexScanForRepositoryFuncCall
// objects describing the invocations of this function.
func (f *DBStoreLastIndexScanForRepositoryFunc) History() []DBStoreLastIndexScanForRepositoryFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreLastIndexScanForRepositoryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreLastIndexScanForRepositoryFuncCall is an object that describes an
// invocation of method LastIndexScanForRepository on an instance of
// MockDBStore.
type DBStoreLastIndexScanForRepositoryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *time.Time
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreLastIndexScanForRepositoryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreLastIndexScanForRepositoryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreLastUploadRetentionScanForRepositoryFunc describes the behavior
// when the LastUploadRetentionScanForRepository method of the parent
// MockDBStore instance is invoked.
type DBStoreLastUploadRetentionScanForRepositoryFunc struct {
	defaultHook func(context.Context, int) (*time.Time, error)
	hooks       []func(context.Context, int) (*time.Time, error)
	history     []DBStoreLastUploadRetentionScanForRepositoryFuncCall
	mutex       sync.Mutex
}

// LastUploadRetentionScanForRepository delegates to the next hook function
// in the queue and stores the parameter and result values of this
// invocation.
func (m *MockDBStore) LastUploadRetentionScanForRepository(v0 context.Context, v1 int) (*time.Time, error) {
	r0, r1 := m.LastUploadRetentionScanForRepositoryFunc.nextHook()(v0, v1)
	m.LastUploadRetentionScanForRepositoryFunc.appendCall(DBStoreLastUploadRetentionScanForRepositoryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// LastUploadRetentionScanForRepository method of the parent MockDBStore
// instance is invoked and the hook queue is empty.
func (f *DBStoreLastUploadRetentionScanForRepositoryFunc) SetDefaultHook(hook func(context.Context, int) (*time.Time, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// LastUploadRetentionScanForRepository method of the parent MockDBStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *DBStoreLastUploadRetentionScanForRepositoryFunc) PushHook(hook func(context.Context, int) (*time.Time, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreLastUploadRetentionScanForRepositoryFunc) SetDefaultReturn(r0 *time.Time, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (*time.Time, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreLastUploadRetentionScanForRepositoryFunc) PushReturn(r0 *time.Time, r1 error) {
	f.PushHook(func(context.Context, int) (*time.Time, error) {
		return r0, r1
	})
}

func (f *DBStoreLastUploadRetentionScanForRepositoryFunc) nextHook() func(context.Context, int) (*time.Time, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreLastUploadRetentionScanForRepositoryFunc) appendCall(r0 DBStoreLastUploadRetentionScanForRepositoryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// DBStoreLastUploadRetentionScanForRepositoryFuncCall objects describing
// the invocations of this function.
func (f *DBStoreLastUploadRetentionScanForRepositoryFunc) History() []DBStoreLastUploadRetentionScanForRepositoryFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreLastUploadRetentionScanForRepositoryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreLastUploadRetentionScanForRepositoryFuncCall is an object that
// describes an invocation of method LastUploadRetentionScanForRepository on
// an instance of MockDBStore.
type DBStoreLastUploadRetentionScanForRepositoryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *time.Time
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreLastUploadRetentionScanForRepositoryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreLastUploadRetentionScanForRepositoryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreMarkRepositoryAsDirtyFunc describes the behavior when the
// MarkRepositoryAsDirty method of the parent MockDBStore instance is
// invoked.
type DBStoreMarkRepositoryAsDirtyFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []DBStoreMarkRepositoryAsDirtyFuncCall
	mutex       sync.Mutex
}

// MarkRepositoryAsDirty delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) MarkRepositoryAsDirty(v0 context.Context, v1 int) error {
	r0 := m.MarkRepositoryAsDirtyFunc.nextHook()(v0, v1)
	m.MarkRepositoryAsDirtyFunc.appendCall(DBStoreMarkRepositoryAsDirtyFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// MarkRepositoryAsDirty method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreMarkRepositoryAsDirtyFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkRepositoryAsDirty method of the parent MockDBStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreMarkRepositoryAsDirtyFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreMarkRepositoryAsDirtyFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreMarkRepositoryAsDirtyFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *DBStoreMarkRepositoryAsDirtyFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreMarkRepositoryAsDirtyFunc) appendCall(r0 DBStoreMarkRepositoryAsDirtyFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreMarkRepositoryAsDirtyFuncCall
// objects describing the invocations of this function.
func (f *DBStoreMarkRepositoryAsDirtyFunc) History() []DBStoreMarkRepositoryAsDirtyFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreMarkRepositoryAsDirtyFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreMarkRepositoryAsDirtyFuncCall is an object that describes an
// invocation of method MarkRepositoryAsDirty on an instance of MockDBStore.
type DBStoreMarkRepositoryAsDirtyFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreMarkRepositoryAsDirtyFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreMarkRepositoryAsDirtyFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreRecentIndexesSummaryFunc describes the behavior when the
// RecentIndexesSummary method of the parent MockDBStore instance is
// invoked.
type DBStoreRecentIndexesSummaryFunc struct {
	defaultHook func(context.Context, int) ([]dbstore.IndexesWithRepositoryNamespace, error)
	hooks       []func(context.Context, int) ([]dbstore.IndexesWithRepositoryNamespace, error)
	history     []DBStoreRecentIndexesSummaryFuncCall
	mutex       sync.Mutex
}

// RecentIndexesSummary delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) RecentIndexesSummary(v0 context.Context, v1 int) ([]dbstore.IndexesWithRepositoryNamespace, error) {
	r0, r1 := m.RecentIndexesSummaryFunc.nextHook()(v0, v1)
	m.RecentIndexesSummaryFunc.appendCall(DBStoreRecentIndexesSummaryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RecentIndexesSummary
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreRecentIndexesSummaryFunc) SetDefaultHook(hook func(context.Context, int) ([]dbstore.IndexesWithRepositoryNamespace, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RecentIndexesSummary method of the parent MockDBStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreRecentIndexesSummaryFunc) PushHook(hook func(context.Context, int) ([]dbstore.IndexesWithRepositoryNamespace, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreRecentIndexesSummaryFunc) SetDefaultReturn(r0 []dbstore.IndexesWithRepositoryNamespace, r1 error) {
	f.SetDefaultHook(func(context.Context, int) ([]dbstore.IndexesWithRepositoryNamespace, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreRecentIndexesSummaryFunc) PushReturn(r0 []dbstore.IndexesWithRepositoryNamespace, r1 error) {
	f.PushHook(func(context.Context, int) ([]dbstore.IndexesWithRepositoryNamespace, error) {
		return r0, r1
	})
}

func (f *DBStoreRecentIndexesSummaryFunc) nextHook() func(context.Context, int) ([]dbstore.IndexesWithRepositoryNamespace, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreRecentIndexesSummaryFunc) appendCall(r0 DBStoreRecentIndexesSummaryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreRecentIndexesSummaryFuncCall objects
// describing the invocations of this function.
func (f *DBStoreRecentIndexesSummaryFunc) History() []DBStoreRecentIndexesSummaryFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreRecentIndexesSummaryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreRecentIndexesSummaryFuncCall is an object that describes an
// invocation of method RecentIndexesSummary on an instance of MockDBStore.
type DBStoreRecentIndexesSummaryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.IndexesWithRepositoryNamespace
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreRecentIndexesSummaryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreRecentIndexesSummaryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreRecentUploadsSummaryFunc describes the behavior when the
// RecentUploadsSummary method of the parent MockDBStore instance is
// invoked.
type DBStoreRecentUploadsSummaryFunc struct {
	defaultHook func(context.Context, int) ([]dbstore.UploadsWithRepositoryNamespace, error)
	hooks       []func(context.Context, int) ([]dbstore.UploadsWithRepositoryNamespace, error)
	history     []DBStoreRecentUploadsSummaryFuncCall
	mutex       sync.Mutex
}

// RecentUploadsSummary delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) RecentUploadsSummary(v0 context.Context, v1 int) ([]dbstore.UploadsWithRepositoryNamespace, error) {
	r0, r1 := m.RecentUploadsSummaryFunc.nextHook()(v0, v1)
	m.RecentUploadsSummaryFunc.appendCall(DBStoreRecentUploadsSummaryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RecentUploadsSummary
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreRecentUploadsSummaryFunc) SetDefaultHook(hook func(context.Context, int) ([]dbstore.UploadsWithRepositoryNamespace, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RecentUploadsSummary method of the parent MockDBStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreRecentUploadsSummaryFunc) PushHook(hook func(context.Context, int) ([]dbstore.UploadsWithRepositoryNamespace, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreRecentUploadsSummaryFunc) SetDefaultReturn(r0 []dbstore.UploadsWithRepositoryNamespace, r1 error) {
	f.SetDefaultHook(func(context.Context, int) ([]dbstore.UploadsWithRepositoryNamespace, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreRecentUploadsSummaryFunc) PushReturn(r0 []dbstore.UploadsWithRepositoryNamespace, r1 error) {
	f.PushHook(func(context.Context, int) ([]dbstore.UploadsWithRepositoryNamespace, error) {
		return r0, r1
	})
}

func (f *DBStoreRecentUploadsSummaryFunc) nextHook() func(context.Context, int) ([]dbstore.UploadsWithRepositoryNamespace, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreRecentUploadsSummaryFunc) appendCall(r0 DBStoreRecentUploadsSummaryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreRecentUploadsSummaryFuncCall objects
// describing the invocations of this function.
func (f *DBStoreRecentUploadsSummaryFunc) History() []DBStoreRecentUploadsSummaryFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreRecentUploadsSummaryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreRecentUploadsSummaryFuncCall is an object that describes an
// invocation of method RecentUploadsSummary on an instance of MockDBStore.
type DBStoreRecentUploadsSummaryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.UploadsWithRepositoryNamespace
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreRecentUploadsSummaryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreRecentUploadsSummaryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreReferenceIDsFunc describes the behavior when the ReferenceIDs
// method of the parent MockDBStore instance is invoked.
type DBStoreReferenceIDsFunc struct {
	defaultHook func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (dbstore.PackageReferenceScanner, int, error)
	hooks       []func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (dbstore.PackageReferenceScanner, int, error)
	history     []DBStoreReferenceIDsFuncCall
	mutex       sync.Mutex
}

// ReferenceIDs delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) ReferenceIDs(v0 context.Context, v1 int, v2 string, v3 []precise.QualifiedMonikerData, v4 int, v5 int) (dbstore.PackageReferenceScanner, int, error) {
	r0, r1, r2 := m.ReferenceIDsFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.ReferenceIDsFunc.appendCall(DBStoreReferenceIDsFuncCall{v0, v1, v2, v3, v4, v5, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the ReferenceIDs method
// of the parent MockDBStore instance is invoked and the hook queue is
// empty.
func (f *DBStoreReferenceIDsFunc) SetDefaultHook(hook func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (dbstore.PackageReferenceScanner, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReferenceIDs method of the parent MockDBStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreReferenceIDsFunc) PushHook(hook func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (dbstore.PackageReferenceScanner, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreReferenceIDsFunc) SetDefaultReturn(r0 dbstore.PackageReferenceScanner, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (dbstore.PackageReferenceScanner, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreReferenceIDsFunc) PushReturn(r0 dbstore.PackageReferenceScanner, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (dbstore.PackageReferenceScanner, int, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreReferenceIDsFunc) nextHook() func(context.Context, int, string, []precise.QualifiedMonikerData, int, int) (dbstore.PackageReferenceScanner, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreReferenceIDsFunc) appendCall(r0 DBStoreReferenceIDsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreReferenceIDsFuncCall objects
// describing the invocations of this function.
func (f *DBStoreReferenceIDsFunc) History() []DBStoreReferenceIDsFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreReferenceIDsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreReferenceIDsFuncCall is an object that describes an invocation of
// method ReferenceIDs on an instance of MockDBStore.
type DBStoreReferenceIDsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 []precise.QualifiedMonikerData
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 dbstore.PackageReferenceScanner
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreReferenceIDsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreReferenceIDsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreRepoIDsByGlobPatternsFunc describes the behavior when the
// RepoIDsByGlobPatterns method of the parent MockDBStore instance is
// invoked.
type DBStoreRepoIDsByGlobPatternsFunc struct {
	defaultHook func(context.Context, []string, int, int) ([]int, int, error)
	hooks       []func(context.Context, []string, int, int) ([]int, int, error)
	history     []DBStoreRepoIDsByGlobPatternsFuncCall
	mutex       sync.Mutex
}

// RepoIDsByGlobPatterns delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) RepoIDsByGlobPatterns(v0 context.Context, v1 []string, v2 int, v3 int) ([]int, int, error) {
	r0, r1, r2 := m.RepoIDsByGlobPatternsFunc.nextHook()(v0, v1, v2, v3)
	m.RepoIDsByGlobPatternsFunc.appendCall(DBStoreRepoIDsByGlobPatternsFuncCall{v0, v1, v2, v3, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// RepoIDsByGlobPatterns method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreRepoIDsByGlobPatternsFunc) SetDefaultHook(hook func(context.Context, []string, int, int) ([]int, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoIDsByGlobPatterns method of the parent MockDBStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreRepoIDsByGlobPatternsFunc) PushHook(hook func(context.Context, []string, int, int) ([]int, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreRepoIDsByGlobPatternsFunc) SetDefaultReturn(r0 []int, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, []string, int, int) ([]int, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreRepoIDsByGlobPatternsFunc) PushReturn(r0 []int, r1 int, r2 error) {
	f.PushHook(func(context.Context, []string, int, int) ([]int, int, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreRepoIDsByGlobPatternsFunc) nextHook() func(context.Context, []string, int, int) ([]int, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreRepoIDsByGlobPatternsFunc) appendCall(r0 DBStoreRepoIDsByGlobPatternsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreRepoIDsByGlobPatternsFuncCall
// objects describing the invocations of this function.
func (f *DBStoreRepoIDsByGlobPatternsFunc) History() []DBStoreRepoIDsByGlobPatternsFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreRepoIDsByGlobPatternsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreRepoIDsByGlobPatternsFuncCall is an object that describes an
// invocation of method RepoIDsByGlobPatterns on an instance of MockDBStore.
type DBStoreRepoIDsByGlobPatternsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreRepoIDsByGlobPatternsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreRepoIDsByGlobPatternsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreRepoNameFunc describes the behavior when the RepoName method of
// the parent MockDBStore instance is invoked.
type DBStoreRepoNameFunc struct {
	defaultHook func(context.Context, int) (string, error)
	hooks       []func(context.Context, int) (string, error)
	history     []DBStoreRepoNameFuncCall
	mutex       sync.Mutex
}

// RepoName delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) RepoName(v0 context.Context, v1 int) (string, error) {
	r0, r1 := m.RepoNameFunc.nextHook()(v0, v1)
	m.RepoNameFunc.appendCall(DBStoreRepoNameFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepoName method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreRepoNameFunc) SetDefaultHook(hook func(context.Context, int) (string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoName method of the parent MockDBStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreRepoNameFunc) PushHook(hook func(context.Context, int) (string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreRepoNameFunc) SetDefaultReturn(r0 string, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreRepoNameFunc) PushReturn(r0 string, r1 error) {
	f.PushHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

func (f *DBStoreRepoNameFunc) nextHook() func(context.Context, int) (string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreRepoNameFunc) appendCall(r0 DBStoreRepoNameFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreRepoNameFuncCall objects describing
// the invocations of this function.
func (f *DBStoreRepoNameFunc) History() []DBStoreRepoNameFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreRepoNameFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreRepoNameFuncCall is an object that describes an invocation of
// method RepoName on an instance of MockDBStore.
type DBStoreRepoNameFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreRepoNameFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreRepoNameFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreRepoNamesFunc describes the behavior when the RepoNames method of
// the parent MockDBStore instance is invoked.
type DBStoreRepoNamesFunc struct {
	defaultHook func(context.Context, ...int) (map[int]string, error)
	hooks       []func(context.Context, ...int) (map[int]string, error)
	history     []DBStoreRepoNamesFuncCall
	mutex       sync.Mutex
}

// RepoNames delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) RepoNames(v0 context.Context, v1 ...int) (map[int]string, error) {
	r0, r1 := m.RepoNamesFunc.nextHook()(v0, v1...)
	m.RepoNamesFunc.appendCall(DBStoreRepoNamesFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepoNames method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreRepoNamesFunc) SetDefaultHook(hook func(context.Context, ...int) (map[int]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoNames method of the parent MockDBStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreRepoNamesFunc) PushHook(hook func(context.Context, ...int) (map[int]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreRepoNamesFunc) SetDefaultReturn(r0 map[int]string, r1 error) {
	f.SetDefaultHook(func(context.Context, ...int) (map[int]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreRepoNamesFunc) PushReturn(r0 map[int]string, r1 error) {
	f.PushHook(func(context.Context, ...int) (map[int]string, error) {
		return r0, r1
	})
}

func (f *DBStoreRepoNamesFunc) nextHook() func(context.Context, ...int) (map[int]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreRepoNamesFunc) appendCall(r0 DBStoreRepoNamesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreRepoNamesFuncCall objects describing
// the invocations of this function.
func (f *DBStoreRepoNamesFunc) History() []DBStoreRepoNamesFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreRepoNamesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreRepoNamesFuncCall is an object that describes an invocation of
// method RepoNames on an instance of MockDBStore.
type DBStoreRepoNamesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[int]string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c DBStoreRepoNamesFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreRepoNamesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreRequestLanguageSupportFunc describes the behavior when the
// RequestLanguageSupport method of the parent MockDBStore instance is
// invoked.
type DBStoreRequestLanguageSupportFunc struct {
	defaultHook func(context.Context, int, string) error
	hooks       []func(context.Context, int, string) error
	history     []DBStoreRequestLanguageSupportFuncCall
	mutex       sync.Mutex
}

// RequestLanguageSupport delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) RequestLanguageSupport(v0 context.Context, v1 int, v2 string) error {
	r0 := m.RequestLanguageSupportFunc.nextHook()(v0, v1, v2)
	m.RequestLanguageSupportFunc.appendCall(DBStoreRequestLanguageSupportFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// RequestLanguageSupport method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreRequestLanguageSupportFunc) SetDefaultHook(hook func(context.Context, int, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RequestLanguageSupport method of the parent MockDBStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreRequestLanguageSupportFunc) PushHook(hook func(context.Context, int, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreRequestLanguageSupportFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreRequestLanguageSupportFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string) error {
		return r0
	})
}

func (f *DBStoreRequestLanguageSupportFunc) nextHook() func(context.Context, int, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreRequestLanguageSupportFunc) appendCall(r0 DBStoreRequestLanguageSupportFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreRequestLanguageSupportFuncCall
// objects describing the invocations of this function.
func (f *DBStoreRequestLanguageSupportFunc) History() []DBStoreRequestLanguageSupportFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreRequestLanguageSupportFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreRequestLanguageSupportFuncCall is an object that describes an
// invocation of method RequestLanguageSupport on an instance of
// MockDBStore.
type DBStoreRequestLanguageSupportFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreRequestLanguageSupportFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreRequestLanguageSupportFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreUpdateConfigurationPolicyFunc describes the behavior when the
// UpdateConfigurationPolicy method of the parent MockDBStore instance is
// invoked.
type DBStoreUpdateConfigurationPolicyFunc struct {
	defaultHook func(context.Context, dbstore.ConfigurationPolicy) error
	hooks       []func(context.Context, dbstore.ConfigurationPolicy) error
	history     []DBStoreUpdateConfigurationPolicyFuncCall
	mutex       sync.Mutex
}

// UpdateConfigurationPolicy delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockDBStore) UpdateConfigurationPolicy(v0 context.Context, v1 dbstore.ConfigurationPolicy) error {
	r0 := m.UpdateConfigurationPolicyFunc.nextHook()(v0, v1)
	m.UpdateConfigurationPolicyFunc.appendCall(DBStoreUpdateConfigurationPolicyFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdateConfigurationPolicy method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreUpdateConfigurationPolicyFunc) SetDefaultHook(hook func(context.Context, dbstore.ConfigurationPolicy) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateConfigurationPolicy method of the parent MockDBStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *DBStoreUpdateConfigurationPolicyFunc) PushHook(hook func(context.Context, dbstore.ConfigurationPolicy) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreUpdateConfigurationPolicyFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, dbstore.ConfigurationPolicy) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreUpdateConfigurationPolicyFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, dbstore.ConfigurationPolicy) error {
		return r0
	})
}

func (f *DBStoreUpdateConfigurationPolicyFunc) nextHook() func(context.Context, dbstore.ConfigurationPolicy) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreUpdateConfigurationPolicyFunc) appendCall(r0 DBStoreUpdateConfigurationPolicyFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreUpdateConfigurationPolicyFuncCall
// objects describing the invocations of this function.
func (f *DBStoreUpdateConfigurationPolicyFunc) History() []DBStoreUpdateConfigurationPolicyFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreUpdateConfigurationPolicyFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreUpdateConfigurationPolicyFuncCall is an object that describes an
// invocation of method UpdateConfigurationPolicy on an instance of
// MockDBStore.
type DBStoreUpdateConfigurationPolicyFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 dbstore.ConfigurationPolicy
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreUpdateConfigurationPolicyFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreUpdateConfigurationPolicyFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreUpdateIndexConfigurationByRepositoryIDFunc describes the behavior
// when the UpdateIndexConfigurationByRepositoryID method of the parent
// MockDBStore instance is invoked.
type DBStoreUpdateIndexConfigurationByRepositoryIDFunc struct {
	defaultHook func(context.Context, int, []byte) error
	hooks       []func(context.Context, int, []byte) error
	history     []DBStoreUpdateIndexConfigurationByRepositoryIDFuncCall
	mutex       sync.Mutex
}

// UpdateIndexConfigurationByRepositoryID delegates to the next hook
// function in the queue and stores the parameter and result values of this
// invocation.
func (m *MockDBStore) UpdateIndexConfigurationByRepositoryID(v0 context.Context, v1 int, v2 []byte) error {
	r0 := m.UpdateIndexConfigurationByRepositoryIDFunc.nextHook()(v0, v1, v2)
	m.UpdateIndexConfigurationByRepositoryIDFunc.appendCall(DBStoreUpdateIndexConfigurationByRepositoryIDFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdateIndexConfigurationByRepositoryID method of the parent MockDBStore
// instance is invoked and the hook queue is empty.
func (f *DBStoreUpdateIndexConfigurationByRepositoryIDFunc) SetDefaultHook(hook func(context.Context, int, []byte) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateIndexConfigurationByRepositoryID method of the parent MockDBStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *DBStoreUpdateIndexConfigurationByRepositoryIDFunc) PushHook(hook func(context.Context, int, []byte) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreUpdateIndexConfigurationByRepositoryIDFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, []byte) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreUpdateIndexConfigurationByRepositoryIDFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, []byte) error {
		return r0
	})
}

func (f *DBStoreUpdateIndexConfigurationByRepositoryIDFunc) nextHook() func(context.Context, int, []byte) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreUpdateIndexConfigurationByRepositoryIDFunc) appendCall(r0 DBStoreUpdateIndexConfigurationByRepositoryIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// DBStoreUpdateIndexConfigurationByRepositoryIDFuncCall objects describing
// the invocations of this function.
func (f *DBStoreUpdateIndexConfigurationByRepositoryIDFunc) History() []DBStoreUpdateIndexConfigurationByRepositoryIDFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreUpdateIndexConfigurationByRepositoryIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreUpdateIndexConfigurationByRepositoryIDFuncCall is an object that
// describes an invocation of method UpdateIndexConfigurationByRepositoryID
// on an instance of MockDBStore.
type DBStoreUpdateIndexConfigurationByRepositoryIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []byte
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreUpdateIndexConfigurationByRepositoryIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreUpdateIndexConfigurationByRepositoryIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// MockEnqueuerDBStore is a mock implementation of the EnqueuerDBStore
// interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/frontend/internal/codeintel/resolvers)
// used for unit testing.
type MockEnqueuerDBStore struct {
	// DirtyRepositoriesFunc is an instance of a mock function object
	// controlling the behavior of the method DirtyRepositories.
	DirtyRepositoriesFunc *EnqueuerDBStoreDirtyRepositoriesFunc
	// DoneFunc is an instance of a mock function object controlling the
	// behavior of the method Done.
	DoneFunc *EnqueuerDBStoreDoneFunc
	// GetIndexConfigurationByRepositoryIDFunc is an instance of a mock
	// function object controlling the behavior of the method
	// GetIndexConfigurationByRepositoryID.
	GetIndexConfigurationByRepositoryIDFunc *EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFunc
	// GetIndexesByIDsFunc is an instance of a mock function object
	// controlling the behavior of the method GetIndexesByIDs.
	GetIndexesByIDsFunc *EnqueuerDBStoreGetIndexesByIDsFunc
	// HandleFunc is an instance of a mock function object controlling the
	// behavior of the method Handle.
	HandleFunc *EnqueuerDBStoreHandleFunc
	// InsertIndexesFunc is an instance of a mock function object
	// controlling the behavior of the method InsertIndexes.
	InsertIndexesFunc *EnqueuerDBStoreInsertIndexesFunc
	// IsQueuedFunc is an instance of a mock function object controlling the
	// behavior of the method IsQueued.
	IsQueuedFunc *EnqueuerDBStoreIsQueuedFunc
	// RepoNameFunc is an instance of a mock function object controlling the
	// behavior of the method RepoName.
	RepoNameFunc *EnqueuerDBStoreRepoNameFunc
	// TransactFunc is an instance of a mock function object controlling the
	// behavior of the method Transact.
	TransactFunc *EnqueuerDBStoreTransactFunc
}

// NewMockEnqueuerDBStore creates a new mock of the EnqueuerDBStore
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockEnqueuerDBStore() *MockEnqueuerDBStore {
	return &MockEnqueuerDBStore{
		DirtyRepositoriesFunc: &EnqueuerDBStoreDirtyRepositoriesFunc{
			defaultHook: func(context.Context) (r0 map[int]int, r1 error) {
				return
			},
		},
		DoneFunc: &EnqueuerDBStoreDoneFunc{
			defaultHook: func(error) (r0 error) {
				return
			},
		},
		GetIndexConfigurationByRepositoryIDFunc: &EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFunc{
			defaultHook: func(context.Context, int) (r0 dbstore.IndexConfiguration, r1 bool, r2 error) {
				return
			},
		},
		GetIndexesByIDsFunc: &EnqueuerDBStoreGetIndexesByIDsFunc{
			defaultHook: func(context.Context, ...int) (r0 []dbstore.Index, r1 error) {
				return
			},
		},
		HandleFunc: &EnqueuerDBStoreHandleFunc{
			defaultHook: func() (r0 *basestore.TransactableHandle) {
				return
			},
		},
		InsertIndexesFunc: &EnqueuerDBStoreInsertIndexesFunc{
			defaultHook: func(context.Context, []dbstore.Index) (r0 []dbstore.Index, r1 error) {
				return
			},
		},
		IsQueuedFunc: &EnqueuerDBStoreIsQueuedFunc{
			defaultHook: func(context.Context, int, string) (r0 bool, r1 error) {
				return
			},
		},
		RepoNameFunc: &EnqueuerDBStoreRepoNameFunc{
			defaultHook: func(context.Context, int) (r0 string, r1 error) {
				return
			},
		},
		TransactFunc: &EnqueuerDBStoreTransactFunc{
			defaultHook: func(context.Context) (r0 enqueuer.DBStore, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockEnqueuerDBStore creates a new mock of the EnqueuerDBStore
// interface. All methods panic on invocation, unless overwritten.
func NewStrictMockEnqueuerDBStore() *MockEnqueuerDBStore {
	return &MockEnqueuerDBStore{
		DirtyRepositoriesFunc: &EnqueuerDBStoreDirtyRepositoriesFunc{
			defaultHook: func(context.Context) (map[int]int, error) {
				panic("unexpected invocation of MockEnqueuerDBStore.DirtyRepositories")
			},
		},
		DoneFunc: &EnqueuerDBStoreDoneFunc{
			defaultHook: func(error) error {
				panic("unexpected invocation of MockEnqueuerDBStore.Done")
			},
		},
		GetIndexConfigurationByRepositoryIDFunc: &EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFunc{
			defaultHook: func(context.Context, int) (dbstore.IndexConfiguration, bool, error) {
				panic("unexpected invocation of MockEnqueuerDBStore.GetIndexConfigurationByRepositoryID")
			},
		},
		GetIndexesByIDsFunc: &EnqueuerDBStoreGetIndexesByIDsFunc{
			defaultHook: func(context.Context, ...int) ([]dbstore.Index, error) {
				panic("unexpected invocation of MockEnqueuerDBStore.GetIndexesByIDs")
			},
		},
		HandleFunc: &EnqueuerDBStoreHandleFunc{
			defaultHook: func() *basestore.TransactableHandle {
				panic("unexpected invocation of MockEnqueuerDBStore.Handle")
			},
		},
		InsertIndexesFunc: &EnqueuerDBStoreInsertIndexesFunc{
			defaultHook: func(context.Context, []dbstore.Index) ([]dbstore.Index, error) {
				panic("unexpected invocation of MockEnqueuerDBStore.InsertIndexes")
			},
		},
		IsQueuedFunc: &EnqueuerDBStoreIsQueuedFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				panic("unexpected invocation of MockEnqueuerDBStore.IsQueued")
			},
		},
		RepoNameFunc: &EnqueuerDBStoreRepoNameFunc{
			defaultHook: func(context.Context, int) (string, error) {
				panic("unexpected invocation of MockEnqueuerDBStore.RepoName")
			},
		},
		TransactFunc: &EnqueuerDBStoreTransactFunc{
			defaultHook: func(context.Context) (enqueuer.DBStore, error) {
				panic("unexpected invocation of MockEnqueuerDBStore.Transact")
			},
		},
	}
}

// NewMockEnqueuerDBStoreFrom creates a new mock of the MockEnqueuerDBStore
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockEnqueuerDBStoreFrom(i EnqueuerDBStore) *MockEnqueuerDBStore {
	return &MockEnqueuerDBStore{
		DirtyRepositoriesFunc: &EnqueuerDBStoreDirtyRepositoriesFunc{
			defaultHook: i.DirtyRepositories,
		},
		DoneFunc: &EnqueuerDBStoreDoneFunc{
			defaultHook: i.Done,
		},
		GetIndexConfigurationByRepositoryIDFunc: &EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFunc{
			defaultHook: i.GetIndexConfigurationByRepositoryID,
		},
		GetIndexesByIDsFunc: &EnqueuerDBStoreGetIndexesByIDsFunc{
			defaultHook: i.GetIndexesByIDs,
		},
		HandleFunc: &EnqueuerDBStoreHandleFunc{
			defaultHook: i.Handle,
		},
		InsertIndexesFunc: &EnqueuerDBStoreInsertIndexesFunc{
			defaultHook: i.InsertIndexes,
		},
		IsQueuedFunc: &EnqueuerDBStoreIsQueuedFunc{
			defaultHook: i.IsQueued,
		},
		RepoNameFunc: &EnqueuerDBStoreRepoNameFunc{
			defaultHook: i.RepoName,
		},
		TransactFunc: &EnqueuerDBStoreTransactFunc{
			defaultHook: i.Transact,
		},
	}
}

// EnqueuerDBStoreDirtyRepositoriesFunc describes the behavior when the
// DirtyRepositories method of the parent MockEnqueuerDBStore instance is
// invoked.
type EnqueuerDBStoreDirtyRepositoriesFunc struct {
	defaultHook func(context.Context) (map[int]int, error)
	hooks       []func(context.Context) (map[int]int, error)
	history     []EnqueuerDBStoreDirtyRepositoriesFuncCall
	mutex       sync.Mutex
}

// DirtyRepositories delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockEnqueuerDBStore) DirtyRepositories(v0 context.Context) (map[int]int, error) {
	r0, r1 := m.DirtyRepositoriesFunc.nextHook()(v0)
	m.DirtyRepositoriesFunc.appendCall(EnqueuerDBStoreDirtyRepositoriesFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DirtyRepositories
// method of the parent MockEnqueuerDBStore instance is invoked and the hook
// queue is empty.
func (f *EnqueuerDBStoreDirtyRepositoriesFunc) SetDefaultHook(hook func(context.Context) (map[int]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DirtyRepositories method of the parent MockEnqueuerDBStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *EnqueuerDBStoreDirtyRepositoriesFunc) PushHook(hook func(context.Context) (map[int]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *EnqueuerDBStoreDirtyRepositoriesFunc) SetDefaultReturn(r0 map[int]int, r1 error) {
	f.SetDefaultHook(func(context.Context) (map[int]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *EnqueuerDBStoreDirtyRepositoriesFunc) PushReturn(r0 map[int]int, r1 error) {
	f.PushHook(func(context.Context) (map[int]int, error) {
		return r0, r1
	})
}

func (f *EnqueuerDBStoreDirtyRepositoriesFunc) nextHook() func(context.Context) (map[int]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EnqueuerDBStoreDirtyRepositoriesFunc) appendCall(r0 EnqueuerDBStoreDirtyRepositoriesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EnqueuerDBStoreDirtyRepositoriesFuncCall
// objects describing the invocations of this function.
func (f *EnqueuerDBStoreDirtyRepositoriesFunc) History() []EnqueuerDBStoreDirtyRepositoriesFuncCall {
	f.mutex.Lock()
	history := make([]EnqueuerDBStoreDirtyRepositoriesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EnqueuerDBStoreDirtyRepositoriesFuncCall is an object that describes an
// invocation of method DirtyRepositories on an instance of
// MockEnqueuerDBStore.
type EnqueuerDBStoreDirtyRepositoriesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[int]int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EnqueuerDBStoreDirtyRepositoriesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EnqueuerDBStoreDirtyRepositoriesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EnqueuerDBStoreDoneFunc describes the behavior when the Done method of
// the parent MockEnqueuerDBStore instance is invoked.
type EnqueuerDBStoreDoneFunc struct {
	defaultHook func(error) error
	hooks       []func(error) error
	history     []EnqueuerDBStoreDoneFuncCall
	mutex       sync.Mutex
}

// Done delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockEnqueuerDBStore) Done(v0 error) error {
	r0 := m.DoneFunc.nextHook()(v0)
	m.DoneFunc.appendCall(EnqueuerDBStoreDoneFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Done method of the
// parent MockEnqueuerDBStore instance is invoked and the hook queue is
// empty.
func (f *EnqueuerDBStoreDoneFunc) SetDefaultHook(hook func(error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Done method of the parent MockEnqueuerDBStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *EnqueuerDBStoreDoneFunc) PushHook(hook func(error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *EnqueuerDBStoreDoneFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(error) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *EnqueuerDBStoreDoneFunc) PushReturn(r0 error) {
	f.PushHook(func(error) error {
		return r0
	})
}

func (f *EnqueuerDBStoreDoneFunc) nextHook() func(error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EnqueuerDBStoreDoneFunc) appendCall(r0 EnqueuerDBStoreDoneFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EnqueuerDBStoreDoneFuncCall objects
// describing the invocations of this function.
func (f *EnqueuerDBStoreDoneFunc) History() []EnqueuerDBStoreDoneFuncCall {
	f.mutex.Lock()
	history := make([]EnqueuerDBStoreDoneFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EnqueuerDBStoreDoneFuncCall is an object that describes an invocation of
// method Done on an instance of MockEnqueuerDBStore.
type EnqueuerDBStoreDoneFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EnqueuerDBStoreDoneFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EnqueuerDBStoreDoneFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFunc describes the
// behavior when the GetIndexConfigurationByRepositoryID method of the
// parent MockEnqueuerDBStore instance is invoked.
type EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFunc struct {
	defaultHook func(context.Context, int) (dbstore.IndexConfiguration, bool, error)
	hooks       []func(context.Context, int) (dbstore.IndexConfiguration, bool, error)
	history     []EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFuncCall
	mutex       sync.Mutex
}

// GetIndexConfigurationByRepositoryID delegates to the next hook function
// in the queue and stores the parameter and result values of this
// invocation.
func (m *MockEnqueuerDBStore) GetIndexConfigurationByRepositoryID(v0 context.Context, v1 int) (dbstore.IndexConfiguration, bool, error) {
	r0, r1, r2 := m.GetIndexConfigurationByRepositoryIDFunc.nextHook()(v0, v1)
	m.GetIndexConfigurationByRepositoryIDFunc.appendCall(EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// GetIndexConfigurationByRepositoryID method of the parent
// MockEnqueuerDBStore instance is invoked and the hook queue is empty.
func (f *EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFunc) SetDefaultHook(hook func(context.Context, int) (dbstore.IndexConfiguration, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexConfigurationByRepositoryID method of the parent
// MockEnqueuerDBStore instance invokes the hook at the front of the queue
// and discards it. After the queue is empty, the default hook function is
// invoked for any future action.
func (f *EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFunc) PushHook(hook func(context.Context, int) (dbstore.IndexConfiguration, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFunc) SetDefaultReturn(r0 dbstore.IndexConfiguration, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (dbstore.IndexConfiguration, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFunc) PushReturn(r0 dbstore.IndexConfiguration, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (dbstore.IndexConfiguration, bool, error) {
		return r0, r1, r2
	})
}

func (f *EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFunc) nextHook() func(context.Context, int) (dbstore.IndexConfiguration, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFunc) appendCall(r0 EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFuncCall objects
// describing the invocations of this function.
func (f *EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFunc) History() []EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFuncCall {
	f.mutex.Lock()
	history := make([]EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFuncCall is an object
// that describes an invocation of method
// GetIndexConfigurationByRepositoryID on an instance of
// MockEnqueuerDBStore.
type EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 dbstore.IndexConfiguration
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EnqueuerDBStoreGetIndexConfigurationByRepositoryIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// EnqueuerDBStoreGetIndexesByIDsFunc describes the behavior when the
// GetIndexesByIDs method of the parent MockEnqueuerDBStore instance is
// invoked.
type EnqueuerDBStoreGetIndexesByIDsFunc struct {
	defaultHook func(context.Context, ...int) ([]dbstore.Index, error)
	hooks       []func(context.Context, ...int) ([]dbstore.Index, error)
	history     []EnqueuerDBStoreGetIndexesByIDsFuncCall
	mutex       sync.Mutex
}

// GetIndexesByIDs delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockEnqueuerDBStore) GetIndexesByIDs(v0 context.Context, v1 ...int) ([]dbstore.Index, error) {
	r0, r1 := m.GetIndexesByIDsFunc.nextHook()(v0, v1...)
	m.GetIndexesByIDsFunc.appendCall(EnqueuerDBStoreGetIndexesByIDsFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetIndexesByIDs
// method of the parent MockEnqueuerDBStore instance is invoked and the hook
// queue is empty.
func (f *EnqueuerDBStoreGetIndexesByIDsFunc) SetDefaultHook(hook func(context.Context, ...int) ([]dbstore.Index, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexesByIDs method of the parent MockEnqueuerDBStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *EnqueuerDBStoreGetIndexesByIDsFunc) PushHook(hook func(context.Context, ...int) ([]dbstore.Index, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *EnqueuerDBStoreGetIndexesByIDsFunc) SetDefaultReturn(r0 []dbstore.Index, r1 error) {
	f.SetDefaultHook(func(context.Context, ...int) ([]dbstore.Index, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *EnqueuerDBStoreGetIndexesByIDsFunc) PushReturn(r0 []dbstore.Index, r1 error) {
	f.PushHook(func(context.Context, ...int) ([]dbstore.Index, error) {
		return r0, r1
	})
}

func (f *EnqueuerDBStoreGetIndexesByIDsFunc) nextHook() func(context.Context, ...int) ([]dbstore.Index, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EnqueuerDBStoreGetIndexesByIDsFunc) appendCall(r0 EnqueuerDBStoreGetIndexesByIDsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EnqueuerDBStoreGetIndexesByIDsFuncCall
// objects describing the invocations of this function.
func (f *EnqueuerDBStoreGetIndexesByIDsFunc) History() []EnqueuerDBStoreGetIndexesByIDsFuncCall {
	f.mutex.Lock()
	history := make([]EnqueuerDBStoreGetIndexesByIDsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EnqueuerDBStoreGetIndexesByIDsFuncCall is an object that describes an
// invocation of method GetIndexesByIDs on an instance of
// MockEnqueuerDBStore.
type EnqueuerDBStoreGetIndexesByIDsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c EnqueuerDBStoreGetIndexesByIDsFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EnqueuerDBStoreGetIndexesByIDsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EnqueuerDBStoreHandleFunc describes the behavior when the Handle method
// of the parent MockEnqueuerDBStore instance is invoked.
type EnqueuerDBStoreHandleFunc struct {
	defaultHook func() *basestore.TransactableHandle
	hooks       []func() *basestore.TransactableHandle
	history     []EnqueuerDBStoreHandleFuncCall
	mutex       sync.Mutex
}

// Handle delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockEnqueuerDBStore) Handle() *basestore.TransactableHandle {
	r0 := m.HandleFunc.nextHook()()
	m.HandleFunc.appendCall(EnqueuerDBStoreHandleFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the Handle method of the
// parent MockEnqueuerDBStore instance is invoked and the hook queue is
// empty.
func (f *EnqueuerDBStoreHandleFunc) SetDefaultHook(hook func() *basestore.TransactableHandle) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Handle method of the parent MockEnqueuerDBStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *EnqueuerDBStoreHandleFunc) PushHook(hook func() *basestore.TransactableHandle) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *EnqueuerDBStoreHandleFunc) SetDefaultReturn(r0 *basestore.TransactableHandle) {
	f.SetDefaultHook(func() *basestore.TransactableHandle {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *EnqueuerDBStoreHandleFunc) PushReturn(r0 *basestore.TransactableHandle) {
	f.PushHook(func() *basestore.TransactableHandle {
		return r0
	})
}

func (f *EnqueuerDBStoreHandleFunc) nextHook() func() *basestore.TransactableHandle {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EnqueuerDBStoreHandleFunc) appendCall(r0 EnqueuerDBStoreHandleFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EnqueuerDBStoreHandleFuncCall objects
// describing the invocations of this function.
func (f *EnqueuerDBStoreHandleFunc) History() []EnqueuerDBStoreHandleFuncCall {
	f.mutex.Lock()
	history := make([]EnqueuerDBStoreHandleFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EnqueuerDBStoreHandleFuncCall is an object that describes an invocation
// of method Handle on an instance of MockEnqueuerDBStore.
type EnqueuerDBStoreHandleFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *basestore.TransactableHandle
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EnqueuerDBStoreHandleFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EnqueuerDBStoreHandleFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// EnqueuerDBStoreInsertIndexesFunc describes the behavior when the
// InsertIndexes method of the parent MockEnqueuerDBStore instance is
// invoked.
type EnqueuerDBStoreInsertIndexesFunc struct {
	defaultHook func(context.Context, []dbstore.Index) ([]dbstore.Index, error)
	hooks       []func(context.Context, []dbstore.Index) ([]dbstore.Index, error)
	history     []EnqueuerDBStoreInsertIndexesFuncCall
	mutex       sync.Mutex
}

// InsertIndexes delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockEnqueuerDBStore) InsertIndexes(v0 context.Context, v1 []dbstore.Index) ([]dbstore.Index, error) {
	r0, r1 := m.InsertIndexesFunc.nextHook()(v0, v1)
	m.InsertIndexesFunc.appendCall(EnqueuerDBStoreInsertIndexesFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the InsertIndexes method
// of the parent MockEnqueuerDBStore instance is invoked and the hook queue
// is empty.
func (f *EnqueuerDBStoreInsertIndexesFunc) SetDefaultHook(hook func(context.Context, []dbstore.Index) ([]dbstore.Index, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertIndexes method of the parent MockEnqueuerDBStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *EnqueuerDBStoreInsertIndexesFunc) PushHook(hook func(context.Context, []dbstore.Index) ([]dbstore.Index, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *EnqueuerDBStoreInsertIndexesFunc) SetDefaultReturn(r0 []dbstore.Index, r1 error) {
	f.SetDefaultHook(func(context.Context, []dbstore.Index) ([]dbstore.Index, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *EnqueuerDBStoreInsertIndexesFunc) PushReturn(r0 []dbstore.Index, r1 error) {
	f.PushHook(func(context.Context, []dbstore.Index) ([]dbstore.Index, error) {
		return r0, r1
	})
}

func (f *EnqueuerDBStoreInsertIndexesFunc) nextHook() func(context.Context, []dbstore.Index) ([]dbstore.Index, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EnqueuerDBStoreInsertIndexesFunc) appendCall(r0 EnqueuerDBStoreInsertIndexesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EnqueuerDBStoreInsertIndexesFuncCall
// objects describing the invocations of this function.
func (f *EnqueuerDBStoreInsertIndexesFunc) History() []EnqueuerDBStoreInsertIndexesFuncCall {
	f.mutex.Lock()
	history := make([]EnqueuerDBStoreInsertIndexesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EnqueuerDBStoreInsertIndexesFuncCall is an object that describes an
// invocation of method InsertIndexes on an instance of MockEnqueuerDBStore.
type EnqueuerDBStoreInsertIndexesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []dbstore.Index
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EnqueuerDBStoreInsertIndexesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EnqueuerDBStoreInsertIndexesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EnqueuerDBStoreIsQueuedFunc describes the behavior when the IsQueued
// method of the parent MockEnqueuerDBStore instance is invoked.
type EnqueuerDBStoreIsQueuedFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []EnqueuerDBStoreIsQueuedFuncCall
	mutex       sync.Mutex
}

// IsQueued delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockEnqueuerDBStore) IsQueued(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.IsQueuedFunc.nextHook()(v0, v1, v2)
	m.IsQueuedFunc.appendCall(EnqueuerDBStoreIsQueuedFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the IsQueued method of
// the parent MockEnqueuerDBStore instance is invoked and the hook queue is
// empty.
func (f *EnqueuerDBStoreIsQueuedFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// IsQueued method of the parent MockEnqueuerDBStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *EnqueuerDBStoreIsQueuedFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *EnqueuerDBStoreIsQueuedFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *EnqueuerDBStoreIsQueuedFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *EnqueuerDBStoreIsQueuedFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EnqueuerDBStoreIsQueuedFunc) appendCall(r0 EnqueuerDBStoreIsQueuedFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EnqueuerDBStoreIsQueuedFuncCall objects
// describing the invocations of this function.
func (f *EnqueuerDBStoreIsQueuedFunc) History() []EnqueuerDBStoreIsQueuedFuncCall {
	f.mutex.Lock()
	history := make([]EnqueuerDBStoreIsQueuedFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EnqueuerDBStoreIsQueuedFuncCall is an object that describes an invocation
// of method IsQueued on an instance of MockEnqueuerDBStore.
type EnqueuerDBStoreIsQueuedFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EnqueuerDBStoreIsQueuedFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EnqueuerDBStoreIsQueuedFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EnqueuerDBStoreRepoNameFunc describes the behavior when the RepoName
// method of the parent MockEnqueuerDBStore instance is invoked.
type EnqueuerDBStoreRepoNameFunc struct {
	defaultHook func(context.Context, int) (string, error)
	hooks       []func(context.Context, int) (string, error)
	history     []EnqueuerDBStoreRepoNameFuncCall
	mutex       sync.Mutex
}

// RepoName delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockEnqueuerDBStore) RepoName(v0 context.Context, v1 int) (string, error) {
	r0, r1 := m.RepoNameFunc.nextHook()(v0, v1)
	m.RepoNameFunc.appendCall(EnqueuerDBStoreRepoNameFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepoName method of
// the parent MockEnqueuerDBStore instance is invoked and the hook queue is
// empty.
func (f *EnqueuerDBStoreRepoNameFunc) SetDefaultHook(hook func(context.Context, int) (string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoName method of the parent MockEnqueuerDBStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *EnqueuerDBStoreRepoNameFunc) PushHook(hook func(context.Context, int) (string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *EnqueuerDBStoreRepoNameFunc) SetDefaultReturn(r0 string, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *EnqueuerDBStoreRepoNameFunc) PushReturn(r0 string, r1 error) {
	f.PushHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

func (f *EnqueuerDBStoreRepoNameFunc) nextHook() func(context.Context, int) (string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EnqueuerDBStoreRepoNameFunc) appendCall(r0 EnqueuerDBStoreRepoNameFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EnqueuerDBStoreRepoNameFuncCall objects
// describing the invocations of this function.
func (f *EnqueuerDBStoreRepoNameFunc) History() []EnqueuerDBStoreRepoNameFuncCall {
	f.mutex.Lock()
	history := make([]EnqueuerDBStoreRepoNameFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EnqueuerDBStoreRepoNameFuncCall is an object that describes an invocation
// of method RepoName on an instance of MockEnqueuerDBStore.
type EnqueuerDBStoreRepoNameFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EnqueuerDBStoreRepoNameFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EnqueuerDBStoreRepoNameFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EnqueuerDBStoreTransactFunc describes the behavior when the Transact
// method of the parent MockEnqueuerDBStore instance is invoked.
type EnqueuerDBStoreTransactFunc struct {
	defaultHook func(context.Context) (enqueuer.DBStore, error)
	hooks       []func(context.Context) (enqueuer.DBStore, error)
	history     []EnqueuerDBStoreTransactFuncCall
	mutex       sync.Mutex
}

// Transact delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockEnqueuerDBStore) Transact(v0 context.Context) (enqueuer.DBStore, error) {
	r0, r1 := m.TransactFunc.nextHook()(v0)
	m.TransactFunc.appendCall(EnqueuerDBStoreTransactFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Transact method of
// the parent MockEnqueuerDBStore instance is invoked and the hook queue is
// empty.
func (f *EnqueuerDBStoreTransactFunc) SetDefaultHook(hook func(context.Context) (enqueuer.DBStore, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Transact method of the parent MockEnqueuerDBStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *EnqueuerDBStoreTransactFunc) PushHook(hook func(context.Context) (enqueuer.DBStore, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *EnqueuerDBStoreTransactFunc) SetDefaultReturn(r0 enqueuer.DBStore, r1 error) {
	f.SetDefaultHook(func(context.Context) (enqueuer.DBStore, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *EnqueuerDBStoreTransactFunc) PushReturn(r0 enqueuer.DBStore, r1 error) {
	f.PushHook(func(context.Context) (enqueuer.DBStore, error) {
		return r0, r1
	})
}

func (f *EnqueuerDBStoreTransactFunc) nextHook() func(context.Context) (enqueuer.DBStore, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EnqueuerDBStoreTransactFunc) appendCall(r0 EnqueuerDBStoreTransactFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EnqueuerDBStoreTransactFuncCall objects
// describing the invocations of this function.
func (f *EnqueuerDBStoreTransactFunc) History() []EnqueuerDBStoreTransactFuncCall {
	f.mutex.Lock()
	history := make([]EnqueuerDBStoreTransactFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EnqueuerDBStoreTransactFuncCall is an object that describes an invocation
// of method Transact on an instance of MockEnqueuerDBStore.
type EnqueuerDBStoreTransactFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 enqueuer.DBStore
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EnqueuerDBStoreTransactFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EnqueuerDBStoreTransactFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockEnqueuerGitserverClient is a mock implementation of the
// EnqueuerGitserverClient interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/frontend/internal/codeintel/resolvers)
// used for unit testing.
type MockEnqueuerGitserverClient struct {
	// CommitExistsFunc is an instance of a mock function object controlling
	// the behavior of the method CommitExists.
	CommitExistsFunc *EnqueuerGitserverClientCommitExistsFunc
	// FileExistsFunc is an instance of a mock function object controlling
	// the behavior of the method FileExists.
	FileExistsFunc *EnqueuerGitserverClientFileExistsFunc
	// HeadFunc is an instance of a mock function object controlling the
	// behavior of the method Head.
	HeadFunc *EnqueuerGitserverClientHeadFunc
	// ListFilesFunc is an instance of a mock function object controlling
	// the behavior of the method ListFiles.
	ListFilesFunc *EnqueuerGitserverClientListFilesFunc
	// RawContentsFunc is an instance of a mock function object controlling
	// the behavior of the method RawContents.
	RawContentsFunc *EnqueuerGitserverClientRawContentsFunc
	// ResolveRevisionFunc is an instance of a mock function object
	// controlling the behavior of the method ResolveRevision.
	ResolveRevisionFunc *EnqueuerGitserverClientResolveRevisionFunc
}

// NewMockEnqueuerGitserverClient creates a new mock of the
// EnqueuerGitserverClient interface. All methods return zero values for all
// results, unless overwritten.
func NewMockEnqueuerGitserverClient() *MockEnqueuerGitserverClient {
	return &MockEnqueuerGitserverClient{
		CommitExistsFunc: &EnqueuerGitserverClientCommitExistsFunc{
			defaultHook: func(context.Context, int, string) (r0 bool, r1 error) {
				return
			},
		},
		FileExistsFunc: &EnqueuerGitserverClientFileExistsFunc{
			defaultHook: func(context.Context, int, string, string) (r0 bool, r1 error) {
				return
			},
		},
		HeadFunc: &EnqueuerGitserverClientHeadFunc{
			defaultHook: func(context.Context, int) (r0 string, r1 bool, r2 error) {
				return
			},
		},
		ListFilesFunc: &EnqueuerGitserverClientListFilesFunc{
			defaultHook: func(context.Context, int, string, *regexp.Regexp) (r0 []string, r1 error) {
				return
			},
		},
		RawContentsFunc: &EnqueuerGitserverClientRawContentsFunc{
			defaultHook: func(context.Context, int, string, string) (r0 []byte, r1 error) {
				return
			},
		},
		ResolveRevisionFunc: &EnqueuerGitserverClientResolveRevisionFunc{
			defaultHook: func(context.Context, int, string) (r0 api.CommitID, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockEnqueuerGitserverClient creates a new mock of the
// EnqueuerGitserverClient interface. All methods panic on invocation,
// unless overwritten.
func NewStrictMockEnqueuerGitserverClient() *MockEnqueuerGitserverClient {
	return &MockEnqueuerGitserverClient{
		CommitExistsFunc: &EnqueuerGitserverClientCommitExistsFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				panic("unexpected invocation of MockEnqueuerGitserverClient.CommitExists")
			},
		},
		FileExistsFunc: &EnqueuerGitserverClientFileExistsFunc{
			defaultHook: func(context.Context, int, string, string) (bool, error) {
				panic("unexpected invocation of MockEnqueuerGitserverClient.FileExists")
			},
		},
		HeadFunc: &EnqueuerGitserverClientHeadFunc{
			defaultHook: func(context.Context, int) (string, bool, error) {
				panic("unexpected invocation of MockEnqueuerGitserverClient.Head")
			},
		},
		ListFilesFunc: &EnqueuerGitserverClientListFilesFunc{
			defaultHook: func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
				panic("unexpected invocation of MockEnqueuerGitserverClient.ListFiles")
			},
		},
		RawContentsFunc: &EnqueuerGitserverClientRawContentsFunc{
			defaultHook: func(context.Context, int, string, string) ([]byte, error) {
				panic("unexpected invocation of MockEnqueuerGitserverClient.RawContents")
			},
		},
		ResolveRevisionFunc: &EnqueuerGitserverClientResolveRevisionFunc{
			defaultHook: func(context.Context, int, string) (api.CommitID, error) {
				panic("unexpected invocation of MockEnqueuerGitserverClient.ResolveRevision")
			},
		},
	}
}

// NewMockEnqueuerGitserverClientFrom creates a new mock of the
// MockEnqueuerGitserverClient interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockEnqueuerGitserverClientFrom(i EnqueuerGitserverClient) *MockEnqueuerGitserverClient {
	return &MockEnqueuerGitserverClient{
		CommitExistsFunc: &EnqueuerGitserverClientCommitExistsFunc{
			defaultHook: i.CommitExists,
		},
		FileExistsFunc: &EnqueuerGitserverClientFileExistsFunc{
			defaultHook: i.FileExists,
		},
		HeadFunc: &EnqueuerGitserverClientHeadFunc{
			defaultHook: i.Head,
		},
		ListFilesFunc: &EnqueuerGitserverClientListFilesFunc{
			defaultHook: i.ListFiles,
		},
		RawContentsFunc: &EnqueuerGitserverClientRawContentsFunc{
			defaultHook: i.RawContents,
		},
		ResolveRevisionFunc: &EnqueuerGitserverClientResolveRevisionFunc{
			defaultHook: i.ResolveRevision,
		},
	}
}

// EnqueuerGitserverClientCommitExistsFunc describes the behavior when the
// CommitExists method of the parent MockEnqueuerGitserverClient instance is
// invoked.
type EnqueuerGitserverClientCommitExistsFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []EnqueuerGitserverClientCommitExistsFuncCall
	mutex       sync.Mutex
}

// CommitExists delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockEnqueuerGitserverClient) CommitExists(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.CommitExistsFunc.nextHook()(v0, v1, v2)
	m.CommitExistsFunc.appendCall(EnqueuerGitserverClientCommitExistsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the CommitExists method
// of the parent MockEnqueuerGitserverClient instance is invoked and the
// hook queue is empty.
func (f *EnqueuerGitserverClientCommitExistsFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitExists method of the parent MockEnqueuerGitserverClient instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *EnqueuerGitserverClientCommitExistsFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *EnqueuerGitserverClientCommitExistsFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *EnqueuerGitserverClientCommitExistsFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *EnqueuerGitserverClientCommitExistsFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EnqueuerGitserverClientCommitExistsFunc) appendCall(r0 EnqueuerGitserverClientCommitExistsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EnqueuerGitserverClientCommitExistsFuncCall
// objects describing the invocations of this function.
func (f *EnqueuerGitserverClientCommitExistsFunc) History() []EnqueuerGitserverClientCommitExistsFuncCall {
	f.mutex.Lock()
	history := make([]EnqueuerGitserverClientCommitExistsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EnqueuerGitserverClientCommitExistsFuncCall is an object that describes
// an invocation of method CommitExists on an instance of
// MockEnqueuerGitserverClient.
type EnqueuerGitserverClientCommitExistsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EnqueuerGitserverClientCommitExistsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EnqueuerGitserverClientCommitExistsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EnqueuerGitserverClientFileExistsFunc describes the behavior when the
// FileExists method of the parent MockEnqueuerGitserverClient instance is
// invoked.
type EnqueuerGitserverClientFileExistsFunc struct {
	defaultHook func(context.Context, int, string, string) (bool, error)
	hooks       []func(context.Context, int, string, string) (bool, error)
	history     []EnqueuerGitserverClientFileExistsFuncCall
	mutex       sync.Mutex
}

// FileExists delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockEnqueuerGitserverClient) FileExists(v0 context.Context, v1 int, v2 string, v3 string) (bool, error) {
	r0, r1 := m.FileExistsFunc.nextHook()(v0, v1, v2, v3)
	m.FileExistsFunc.appendCall(EnqueuerGitserverClientFileExistsFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the FileExists method of
// the parent MockEnqueuerGitserverClient instance is invoked and the hook
// queue is empty.
func (f *EnqueuerGitserverClientFileExistsFunc) SetDefaultHook(hook func(context.Context, int, string, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// FileExists method of the parent MockEnqueuerGitserverClient instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *EnqueuerGitserverClientFileExistsFunc) PushHook(hook func(context.Context, int, string, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *EnqueuerGitserverClientFileExistsFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *EnqueuerGitserverClientFileExistsFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string, string) (bool, error) {
		return r0, r1
	})
}

func (f *EnqueuerGitserverClientFileExistsFunc) nextHook() func(context.Context, int, string, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EnqueuerGitserverClientFileExistsFunc) appendCall(r0 EnqueuerGitserverClientFileExistsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EnqueuerGitserverClientFileExistsFuncCall
// objects describing the invocations of this function.
func (f *EnqueuerGitserverClientFileExistsFunc) History() []EnqueuerGitserverClientFileExistsFuncCall {
	f.mutex.Lock()
	history := make([]EnqueuerGitserverClientFileExistsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EnqueuerGitserverClientFileExistsFuncCall is an object that describes an
// invocation of method FileExists on an instance of
// MockEnqueuerGitserverClient.
type EnqueuerGitserverClientFileExistsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EnqueuerGitserverClientFileExistsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EnqueuerGitserverClientFileExistsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EnqueuerGitserverClientHeadFunc describes the behavior when the Head
// method of the parent MockEnqueuerGitserverClient instance is invoked.
type EnqueuerGitserverClientHeadFunc struct {
	defaultHook func(context.Context, int) (string, bool, error)
	hooks       []func(context.Context, int) (string, bool, error)
	history     []EnqueuerGitserverClientHeadFuncCall
	mutex       sync.Mutex
}

// Head delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockEnqueuerGitserverClient) Head(v0 context.Context, v1 int) (string, bool, error) {
	r0, r1, r2 := m.HeadFunc.nextHook()(v0, v1)
	m.HeadFunc.appendCall(EnqueuerGitserverClientHeadFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Head method of the
// parent MockEnqueuerGitserverClient instance is invoked and the hook queue
// is empty.
func (f *EnqueuerGitserverClientHeadFunc) SetDefaultHook(hook func(context.Context, int) (string, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Head method of the parent MockEnqueuerGitserverClient instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *EnqueuerGitserverClientHeadFunc) PushHook(hook func(context.Context, int) (string, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *EnqueuerGitserverClientHeadFunc) SetDefaultReturn(r0 string, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (string, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *EnqueuerGitserverClientHeadFunc) PushReturn(r0 string, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (string, bool, error) {
		return r0, r1, r2
	})
}

func (f *EnqueuerGitserverClientHeadFunc) nextHook() func(context.Context, int) (string, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EnqueuerGitserverClientHeadFunc) appendCall(r0 EnqueuerGitserverClientHeadFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EnqueuerGitserverClientHeadFuncCall objects
// describing the invocations of this function.
func (f *EnqueuerGitserverClientHeadFunc) History() []EnqueuerGitserverClientHeadFuncCall {
	f.mutex.Lock()
	history := make([]EnqueuerGitserverClientHeadFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EnqueuerGitserverClientHeadFuncCall is an object that describes an
// invocation of method Head on an instance of MockEnqueuerGitserverClient.
type EnqueuerGitserverClientHeadFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EnqueuerGitserverClientHeadFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EnqueuerGitserverClientHeadFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// EnqueuerGitserverClientListFilesFunc describes the behavior when the
// ListFiles method of the parent MockEnqueuerGitserverClient instance is
// invoked.
type EnqueuerGitserverClientListFilesFunc struct {
	defaultHook func(context.Context, int, string, *regexp.Regexp) ([]string, error)
	hooks       []func(context.Context, int, string, *regexp.Regexp) ([]string, error)
	history     []EnqueuerGitserverClientListFilesFuncCall
	mutex       sync.Mutex
}

// ListFiles delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockEnqueuerGitserverClient) ListFiles(v0 context.Context, v1 int, v2 string, v3 *regexp.Regexp) ([]string, error) {
	r0, r1 := m.ListFilesFunc.nextHook()(v0, v1, v2, v3)
	m.ListFilesFunc.appendCall(EnqueuerGitserverClientListFilesFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ListFiles method of
// the parent MockEnqueuerGitserverClient instance is invoked and the hook
// queue is empty.
func (f *EnqueuerGitserverClientListFilesFunc) SetDefaultHook(hook func(context.Context, int, string, *regexp.Regexp) ([]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ListFiles method of the parent MockEnqueuerGitserverClient instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *EnqueuerGitserverClientListFilesFunc) PushHook(hook func(context.Context, int, string, *regexp.Regexp) ([]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *EnqueuerGitserverClientListFilesFunc) SetDefaultReturn(r0 []string, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *EnqueuerGitserverClientListFilesFunc) PushReturn(r0 []string, r1 error) {
	f.PushHook(func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
		return r0, r1
	})
}

func (f *EnqueuerGitserverClientListFilesFunc) nextHook() func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EnqueuerGitserverClientListFilesFunc) appendCall(r0 EnqueuerGitserverClientListFilesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EnqueuerGitserverClientListFilesFuncCall
// objects describing the invocations of this function.
func (f *EnqueuerGitserverClientListFilesFunc) History() []EnqueuerGitserverClientListFilesFuncCall {
	f.mutex.Lock()
	history := make([]EnqueuerGitserverClientListFilesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EnqueuerGitserverClientListFilesFuncCall is an object that describes an
// invocation of method ListFiles on an instance of
// MockEnqueuerGitserverClient.
type EnqueuerGitserverClientListFilesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 *regexp.Regexp
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EnqueuerGitserverClientListFilesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EnqueuerGitserverClientListFilesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EnqueuerGitserverClientRawContentsFunc describes the behavior when the
// RawContents method of the parent MockEnqueuerGitserverClient instance is
// invoked.
type EnqueuerGitserverClientRawContentsFunc struct {
	defaultHook func(context.Context, int, string, string) ([]byte, error)
	hooks       []func(context.Context, int, string, string) ([]byte, error)
	history     []EnqueuerGitserverClientRawContentsFuncCall
	mutex       sync.Mutex
}

// RawContents delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockEnqueuerGitserverClient) RawContents(v0 context.Context, v1 int, v2 string, v3 string) ([]byte, error) {
	r0, r1 := m.RawContentsFunc.nextHook()(v0, v1, v2, v3)
	m.RawContentsFunc.appendCall(EnqueuerGitserverClientRawContentsFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RawContents method
// of the parent MockEnqueuerGitserverClient instance is invoked and the
// hook queue is empty.
func (f *EnqueuerGitserverClientRawContentsFunc) SetDefaultHook(hook func(context.Context, int, string, string) ([]byte, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RawContents method of the parent MockEnqueuerGitserverClient instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *EnqueuerGitserverClientRawContentsFunc) PushHook(hook func(context.Context, int, string, string) ([]byte, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *EnqueuerGitserverClientRawContentsFunc) SetDefaultReturn(r0 []byte, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string) ([]byte, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *EnqueuerGitserverClientRawContentsFunc) PushReturn(r0 []byte, r1 error) {
	f.PushHook(func(context.Context, int, string, string) ([]byte, error) {
		return r0, r1
	})
}

func (f *EnqueuerGitserverClientRawContentsFunc) nextHook() func(context.Context, int, string, string) ([]byte, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EnqueuerGitserverClientRawContentsFunc) appendCall(r0 EnqueuerGitserverClientRawContentsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of EnqueuerGitserverClientRawContentsFuncCall
// objects describing the invocations of this function.
func (f *EnqueuerGitserverClientRawContentsFunc) History() []EnqueuerGitserverClientRawContentsFuncCall {
	f.mutex.Lock()
	history := make([]EnqueuerGitserverClientRawContentsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EnqueuerGitserverClientRawContentsFuncCall is an object that describes an
// invocation of method RawContents on an instance of
// MockEnqueuerGitserverClient.
type EnqueuerGitserverClientRawContentsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []byte
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EnqueuerGitserverClientRawContentsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EnqueuerGitserverClientRawContentsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// EnqueuerGitserverClientResolveRevisionFunc describes the behavior when
// the ResolveRevision method of the parent MockEnqueuerGitserverClient
// instance is invoked.
type EnqueuerGitserverClientResolveRevisionFunc struct {
	defaultHook func(context.Context, int, string) (api.CommitID, error)
	hooks       []func(context.Context, int, string) (api.CommitID, error)
	history     []EnqueuerGitserverClientResolveRevisionFuncCall
	mutex       sync.Mutex
}

// ResolveRevision delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockEnqueuerGitserverClient) ResolveRevision(v0 context.Context, v1 int, v2 string) (api.CommitID, error) {
	r0, r1 := m.ResolveRevisionFunc.nextHook()(v0, v1, v2)
	m.ResolveRevisionFunc.appendCall(EnqueuerGitserverClientResolveRevisionFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ResolveRevision
// method of the parent MockEnqueuerGitserverClient instance is invoked and
// the hook queue is empty.
func (f *EnqueuerGitserverClientResolveRevisionFunc) SetDefaultHook(hook func(context.Context, int, string) (api.CommitID, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ResolveRevision method of the parent MockEnqueuerGitserverClient instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *EnqueuerGitserverClientResolveRevisionFunc) PushHook(hook func(context.Context, int, string) (api.CommitID, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *EnqueuerGitserverClientResolveRevisionFunc) SetDefaultReturn(r0 api.CommitID, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (api.CommitID, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *EnqueuerGitserverClientResolveRevisionFunc) PushReturn(r0 api.CommitID, r1 error) {
	f.PushHook(func(context.Context, int, string) (api.CommitID, error) {
		return r0, r1
	})
}

func (f *EnqueuerGitserverClientResolveRevisionFunc) nextHook() func(context.Context, int, string) (api.CommitID, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *EnqueuerGitserverClientResolveRevisionFunc) appendCall(r0 EnqueuerGitserverClientResolveRevisionFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// EnqueuerGitserverClientResolveRevisionFuncCall objects describing the
// invocations of this function.
func (f *EnqueuerGitserverClientResolveRevisionFunc) History() []EnqueuerGitserverClientResolveRevisionFuncCall {
	f.mutex.Lock()
	history := make([]EnqueuerGitserverClientResolveRevisionFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// EnqueuerGitserverClientResolveRevisionFuncCall is an object that
// describes an invocation of method ResolveRevision on an instance of
// MockEnqueuerGitserverClient.
type EnqueuerGitserverClientResolveRevisionFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 api.CommitID
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c EnqueuerGitserverClientResolveRevisionFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c EnqueuerGitserverClientResolveRevisionFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockGitserverClient is a mock implementation of the GitserverClient
// interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/frontend/internal/codeintel/resolvers)
// used for unit testing.
type MockGitserverClient struct {
	// CommitDateFunc is an instance of a mock function object controlling
	// the behavior of the method CommitDate.
	CommitDateFunc *GitserverClientCommitDateFunc
	// CommitGraphFunc is an instance of a mock function object controlling
	// the behavior of the method CommitGraph.
	CommitGraphFunc *GitserverClientCommitGraphFunc
	// CommitsExistFunc is an instance of a mock function object controlling
	// the behavior of the method CommitsExist.
	CommitsExistFunc *GitserverClientCommitsExistFunc
	// CommitsUniqueToBranchFunc is an instance of a mock function object
	// controlling the behavior of the method CommitsUniqueToBranch.
	CommitsUniqueToBranchFunc *GitserverClientCommitsUniqueToBranchFunc
	// ListFilesFunc is an instance of a mock function object controlling
	// the behavior of the method ListFiles.
	ListFilesFunc *GitserverClientListFilesFunc
	// RefDescriptionsFunc is an instance of a mock function object
	// controlling the behavior of the method RefDescriptions.
	RefDescriptionsFunc *GitserverClientRefDescriptionsFunc
	// ResolveRevisionFunc is an instance of a mock function object
	// controlling the behavior of the method ResolveRevision.
	ResolveRevisionFunc *GitserverClientResolveRevisionFunc
}

// NewMockGitserverClient creates a new mock of the GitserverClient
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockGitserverClient() *MockGitserverClient {
	return &MockGitserverClient{
		CommitDateFunc: &GitserverClientCommitDateFunc{
			defaultHook: func(context.Context, int, string) (r0 string, r1 time.Time, r2 bool, r3 error) {
				return
			},
		},
		CommitGraphFunc: &GitserverClientCommitGraphFunc{
			defaultHook: func(context.Context, int, gitserver.CommitGraphOptions) (r0 *gitdomain.CommitGraph, r1 error) {
				return
			},
		},
		CommitsExistFunc: &GitserverClientCommitsExistFunc{
			defaultHook: func(context.Context, []gitserver1.RepositoryCommit) (r0 []bool, r1 error) {
				return
			},
		},
		CommitsUniqueToBranchFunc: &GitserverClientCommitsUniqueToBranchFunc{
			defaultHook: func(context.Context, int, string, bool, *time.Time) (r0 map[string]time.Time, r1 error) {
				return
			},
		},
		ListFilesFunc: &GitserverClientListFilesFunc{
			defaultHook: func(context.Context, int, string, *regexp.Regexp) (r0 []string, r1 error) {
				return
			},
		},
		RefDescriptionsFunc: &GitserverClientRefDescriptionsFunc{
			defaultHook: func(context.Context, int, ...string) (r0 map[string][]gitdomain.RefDescription, r1 error) {
				return
			},
		},
		ResolveRevisionFunc: &GitserverClientResolveRevisionFunc{
			defaultHook: func(context.Context, int, string) (r0 api.CommitID, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockGitserverClient creates a new mock of the GitserverClient
// interface. All methods panic on invocation, unless overwritten.
func NewStrictMockGitserverClient() *MockGitserverClient {
	return &MockGitserverClient{
		CommitDateFunc: &GitserverClientCommitDateFunc{
			defaultHook: func(context.Context, int, string) (string, time.Time, bool, error) {
				panic("unexpected invocation of MockGitserverClient.CommitDate")
			},
		},
		CommitGraphFunc: &GitserverClientCommitGraphFunc{
			defaultHook: func(context.Context, int, gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error) {
				panic("unexpected invocation of MockGitserverClient.CommitGraph")
			},
		},
		CommitsExistFunc: &GitserverClientCommitsExistFunc{
			defaultHook: func(context.Context, []gitserver1.RepositoryCommit) ([]bool, error) {
				panic("unexpected invocation of MockGitserverClient.CommitsExist")
			},
		},
		CommitsUniqueToBranchFunc: &GitserverClientCommitsUniqueToBranchFunc{
			defaultHook: func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error) {
				panic("unexpected invocation of MockGitserverClient.CommitsUniqueToBranch")
			},
		},
		ListFilesFunc: &GitserverClientListFilesFunc{
			defaultHook: func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
				panic("unexpected invocation of MockGitserverClient.ListFiles")
			},
		},
		RefDescriptionsFunc: &GitserverClientRefDescriptionsFunc{
			defaultHook: func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error) {
				panic("unexpected invocation of MockGitserverClient.RefDescriptions")
			},
		},
		ResolveRevisionFunc: &GitserverClientResolveRevisionFunc{
			defaultHook: func(context.Context, int, string) (api.CommitID, error) {
				panic("unexpected invocation of MockGitserverClient.ResolveRevision")
			},
		},
	}
}

// NewMockGitserverClientFrom creates a new mock of the MockGitserverClient
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockGitserverClientFrom(i GitserverClient) *MockGitserverClient {
	return &MockGitserverClient{
		CommitDateFunc: &GitserverClientCommitDateFunc{
			defaultHook: i.CommitDate,
		},
		CommitGraphFunc: &GitserverClientCommitGraphFunc{
			defaultHook: i.CommitGraph,
		},
		CommitsExistFunc: &GitserverClientCommitsExistFunc{
			defaultHook: i.CommitsExist,
		},
		CommitsUniqueToBranchFunc: &GitserverClientCommitsUniqueToBranchFunc{
			defaultHook: i.CommitsUniqueToBranch,
		},
		ListFilesFunc: &GitserverClientListFilesFunc{
			defaultHook: i.ListFiles,
		},
		RefDescriptionsFunc: &GitserverClientRefDescriptionsFunc{
			defaultHook: i.RefDescriptions,
		},
		ResolveRevisionFunc: &GitserverClientResolveRevisionFunc{
			defaultHook: i.ResolveRevision,
		},
	}
}

// GitserverClientCommitDateFunc describes the behavior when the CommitDate
// method of the parent MockGitserverClient instance is invoked.
type GitserverClientCommitDateFunc struct {
	defaultHook func(context.Context, int, string) (string, time.Time, bool, error)
	hooks       []func(context.Context, int, string) (string, time.Time, bool, error)
	history     []GitserverClientCommitDateFuncCall
	mutex       sync.Mutex
}

// CommitDate delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverClient) CommitDate(v0 context.Context, v1 int, v2 string) (string, time.Time, bool, error) {
	r0, r1, r2, r3 := m.CommitDateFunc.nextHook()(v0, v1, v2)
	m.CommitDateFunc.appendCall(GitserverClientCommitDateFuncCall{v0, v1, v2, r0, r1, r2, r3})
	return r0, r1, r2, r3
}

// SetDefaultHook sets function that is called when the CommitDate method of
// the parent MockGitserverClient instance is invoked and the hook queue is
// empty.
func (f *GitserverClientCommitDateFunc) SetDefaultHook(hook func(context.Context, int, string) (string, time.Time, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitDate method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientCommitDateFunc) PushHook(hook func(context.Context, int, string) (string, time.Time, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientCommitDateFunc) SetDefaultReturn(r0 string, r1 time.Time, r2 bool, r3 error) {
	f.SetDefaultHook(func(context.Context, int, string) (string, time.Time, bool, error) {
		return r0, r1, r2, r3
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientCommitDateFunc) PushReturn(r0 string, r1 time.Time, r2 bool, r3 error) {
	f.PushHook(func(context.Context, int, string) (string, time.Time, bool, error) {
		return r0, r1, r2, r3
	})
}

func (f *GitserverClientCommitDateFunc) nextHook() func(context.Context, int, string) (string, time.Time, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientCommitDateFunc) appendCall(r0 GitserverClientCommitDateFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientCommitDateFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientCommitDateFunc) History() []GitserverClientCommitDateFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientCommitDateFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientCommitDateFuncCall is an object that describes an
// invocation of method CommitDate on an instance of MockGitserverClient.
type GitserverClientCommitDateFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 time.Time
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 bool
	// Result3 is the value of the 4th result returned from this method
	// invocation.
	Result3 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientCommitDateFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientCommitDateFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2, c.Result3}
}

// GitserverClientCommitGraphFunc describes the behavior when the
// CommitGraph method of the parent MockGitserverClient instance is invoked.
type GitserverClientCommitGraphFunc struct {
	defaultHook func(context.Context, int, gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error)
	hooks       []func(context.Context, int, gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error)
	history     []GitserverClientCommitGraphFuncCall
	mutex       sync.Mutex
}

// CommitGraph delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverClient) CommitGraph(v0 context.Context, v1 int, v2 gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error) {
	r0, r1 := m.CommitGraphFunc.nextHook()(v0, v1, v2)
	m.CommitGraphFunc.appendCall(GitserverClientCommitGraphFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the CommitGraph method
// of the parent MockGitserverClient instance is invoked and the hook queue
// is empty.
func (f *GitserverClientCommitGraphFunc) SetDefaultHook(hook func(context.Context, int, gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitGraph method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientCommitGraphFunc) PushHook(hook func(context.Context, int, gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientCommitGraphFunc) SetDefaultReturn(r0 *gitdomain.CommitGraph, r1 error) {
	f.SetDefaultHook(func(context.Context, int, gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientCommitGraphFunc) PushReturn(r0 *gitdomain.CommitGraph, r1 error) {
	f.PushHook(func(context.Context, int, gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error) {
		return r0, r1
	})
}

func (f *GitserverClientCommitGraphFunc) nextHook() func(context.Context, int, gitserver.CommitGraphOptions) (*gitdomain.CommitGraph, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientCommitGraphFunc) appendCall(r0 GitserverClientCommitGraphFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientCommitGraphFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientCommitGraphFunc) History() []GitserverClientCommitGraphFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientCommitGraphFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientCommitGraphFuncCall is an object that describes an
// invocation of method CommitGraph on an instance of MockGitserverClient.
type GitserverClientCommitGraphFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 gitserver.CommitGraphOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *gitdomain.CommitGraph
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientCommitGraphFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientCommitGraphFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientCommitsExistFunc describes the behavior when the
// CommitsExist method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientCommitsExistFunc struct {
	defaultHook func(context.Context, []gitserver1.RepositoryCommit) ([]bool, error)
	hooks       []func(context.Context, []gitserver1.RepositoryCommit) ([]bool, error)
	history     []GitserverClientCommitsExistFuncCall
	mutex       sync.Mutex
}

// CommitsExist delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverClient) CommitsExist(v0 context.Context, v1 []gitserver1.RepositoryCommit) ([]bool, error) {
	r0, r1 := m.CommitsExistFunc.nextHook()(v0, v1)
	m.CommitsExistFunc.appendCall(GitserverClientCommitsExistFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the CommitsExist method
// of the parent MockGitserverClient instance is invoked and the hook queue
// is empty.
func (f *GitserverClientCommitsExistFunc) SetDefaultHook(hook func(context.Context, []gitserver1.RepositoryCommit) ([]bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitsExist method of the parent MockGitserverClient instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitserverClientCommitsExistFunc) PushHook(hook func(context.Context, []gitserver1.RepositoryCommit) ([]bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientCommitsExistFunc) SetDefaultReturn(r0 []bool, r1 error) {
	f.SetDefaultHook(func(context.Context, []gitserver1.RepositoryCommit) ([]bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientCommitsExistFunc) PushReturn(r0 []bool, r1 error) {
	f.PushHook(func(context.Context, []gitserver1.RepositoryCommit) ([]bool, error) {
		return r0, r1
	})
}

func (f *GitserverClientCommitsExistFunc) nextHook() func(context.Context, []gitserver1.RepositoryCommit) ([]bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientCommitsExistFunc) appendCall(r0 GitserverClientCommitsExistFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientCommitsExistFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientCommitsExistFunc) History() []GitserverClientCommitsExistFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientCommitsExistFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientCommitsExistFuncCall is an object that describes an
// invocation of method CommitsExist on an instance of MockGitserverClient.
type GitserverClientCommitsExistFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []gitserver1.RepositoryCommit
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientCommitsExistFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientCommitsExistFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientCommitsUniqueToBranchFunc describes the behavior when the
// CommitsUniqueToBranch method of the parent MockGitserverClient instance
// is invoked.
type GitserverClientCommitsUniqueToBranchFunc struct {
	defaultHook func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error)
	hooks       []func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error)
	history     []GitserverClientCommitsUniqueToBranchFuncCall
	mutex       sync.Mutex
}

// CommitsUniqueToBranch delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockGitserverClient) CommitsUniqueToBranch(v0 context.Context, v1 int, v2 string, v3 bool, v4 *time.Time) (map[string]time.Time, error) {
	r0, r1 := m.CommitsUniqueToBranchFunc.nextHook()(v0, v1, v2, v3, v4)
	m.CommitsUniqueToBranchFunc.appendCall(GitserverClientCommitsUniqueToBranchFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CommitsUniqueToBranch method of the parent MockGitserverClient instance
// is invoked and the hook queue is empty.
func (f *GitserverClientCommitsUniqueToBranchFunc) SetDefaultHook(hook func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitsUniqueToBranch method of the parent MockGitserverClient instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *GitserverClientCommitsUniqueToBranchFunc) PushHook(hook func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientCommitsUniqueToBranchFunc) SetDefaultReturn(r0 map[string]time.Time, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientCommitsUniqueToBranchFunc) PushReturn(r0 map[string]time.Time, r1 error) {
	f.PushHook(func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error) {
		return r0, r1
	})
}

func (f *GitserverClientCommitsUniqueToBranchFunc) nextHook() func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientCommitsUniqueToBranchFunc) appendCall(r0 GitserverClientCommitsUniqueToBranchFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// GitserverClientCommitsUniqueToBranchFuncCall objects describing the
// invocations of this function.
func (f *GitserverClientCommitsUniqueToBranchFunc) History() []GitserverClientCommitsUniqueToBranchFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientCommitsUniqueToBranchFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientCommitsUniqueToBranchFuncCall is an object that describes
// an invocation of method CommitsUniqueToBranch on an instance of
// MockGitserverClient.
type GitserverClientCommitsUniqueToBranchFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 bool
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 *time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[string]time.Time
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientCommitsUniqueToBranchFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientCommitsUniqueToBranchFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientListFilesFunc describes the behavior when the ListFiles
// method of the parent MockGitserverClient instance is invoked.
type GitserverClientListFilesFunc struct {
	defaultHook func(context.Context, int, string, *regexp.Regexp) ([]string, error)
	hooks       []func(context.Context, int, string, *regexp.Regexp) ([]string, error)
	history     []GitserverClientListFilesFuncCall
	mutex       sync.Mutex
}

// ListFiles delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockGitserverClient) ListFiles(v0 context.Context, v1 int, v2 string, v3 *regexp.Regexp) ([]string, error) {
	r0, r1 := m.ListFilesFunc.nextHook()(v0, v1, v2, v3)
	m.ListFilesFunc.appendCall(GitserverClientListFilesFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ListFiles method of
// the parent MockGitserverClient instance is invoked and the hook queue is
// empty.
func (f *GitserverClientListFilesFunc) SetDefaultHook(hook func(context.Context, int, string, *regexp.Regexp) ([]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ListFiles method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientListFilesFunc) PushHook(hook func(context.Context, int, string, *regexp.Regexp) ([]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientListFilesFunc) SetDefaultReturn(r0 []string, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientListFilesFunc) PushReturn(r0 []string, r1 error) {
	f.PushHook(func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
		return r0, r1
	})
}

func (f *GitserverClientListFilesFunc) nextHook() func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientListFilesFunc) appendCall(r0 GitserverClientListFilesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientListFilesFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientListFilesFunc) History() []GitserverClientListFilesFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientListFilesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientListFilesFuncCall is an object that describes an
// invocation of method ListFiles on an instance of MockGitserverClient.
type GitserverClientListFilesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 *regexp.Regexp
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientListFilesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientListFilesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientRefDescriptionsFunc describes the behavior when the
// RefDescriptions method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientRefDescriptionsFunc struct {
	defaultHook func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error)
	hooks       []func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error)
	history     []GitserverClientRefDescriptionsFuncCall
	mutex       sync.Mutex
}

// RefDescriptions delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockGitserverClient) RefDescriptions(v0 context.Context, v1 int, v2 ...string) (map[string][]gitdomain.RefDescription, error) {
	r0, r1 := m.RefDescriptionsFunc.nextHook()(v0, v1, v2...)
	m.RefDescriptionsFunc.appendCall(GitserverClientRefDescriptionsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RefDescriptions
// method of the parent MockGitserverClient instance is invoked and the hook
// queue is empty.
func (f *GitserverClientRefDescriptionsFunc) SetDefaultHook(hook func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RefDescriptions method of the parent MockGitserverClient instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitserverClientRefDescriptionsFunc) PushHook(hook func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientRefDescriptionsFunc) SetDefaultReturn(r0 map[string][]gitdomain.RefDescription, r1 error) {
	f.SetDefaultHook(func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientRefDescriptionsFunc) PushReturn(r0 map[string][]gitdomain.RefDescription, r1 error) {
	f.PushHook(func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error) {
		return r0, r1
	})
}

func (f *GitserverClientRefDescriptionsFunc) nextHook() func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientRefDescriptionsFunc) appendCall(r0 GitserverClientRefDescriptionsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientRefDescriptionsFuncCall
// objects describing the invocations of this function.
func (f *GitserverClientRefDescriptionsFunc) History() []GitserverClientRefDescriptionsFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientRefDescriptionsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientRefDescriptionsFuncCall is an object that describes an
// invocation of method RefDescriptions on an instance of
// MockGitserverClient.
type GitserverClientRefDescriptionsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg2 []string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[string][]gitdomain.RefDescription
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c GitserverClientRefDescriptionsFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg2 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0, c.Arg1}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientRefDescriptionsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientResolveRevisionFunc describes the behavior when the
// ResolveRevision method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientResolveRevisionFunc struct {
	defaultHook func(context.Context, int, string) (api.CommitID, error)
	hooks       []func(context.Context, int, string) (api.CommitID, error)
	history     []GitserverClientResolveRevisionFuncCall
	mutex       sync.Mutex
}

// ResolveRevision delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockGitserverClient) ResolveRevision(v0 context.Context, v1 int, v2 string) (api.CommitID, error) {
	r0, r1 := m.ResolveRevisionFunc.nextHook()(v0, v1, v2)
	m.ResolveRevisionFunc.appendCall(GitserverClientResolveRevisionFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ResolveRevision
// method of the parent MockGitserverClient instance is invoked and the hook
// queue is empty.
func (f *GitserverClientResolveRevisionFunc) SetDefaultHook(hook func(context.Context, int, string) (api.CommitID, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ResolveRevision method of the parent MockGitserverClient instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitserverClientResolveRevisionFunc) PushHook(hook func(context.Context, int, string) (api.CommitID, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientResolveRevisionFunc) SetDefaultReturn(r0 api.CommitID, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (api.CommitID, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientResolveRevisionFunc) PushReturn(r0 api.CommitID, r1 error) {
	f.PushHook(func(context.Context, int, string) (api.CommitID, error) {
		return r0, r1
	})
}

func (f *GitserverClientResolveRevisionFunc) nextHook() func(context.Context, int, string) (api.CommitID, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientResolveRevisionFunc) appendCall(r0 GitserverClientResolveRevisionFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientResolveRevisionFuncCall
// objects describing the invocations of this function.
func (f *GitserverClientResolveRevisionFunc) History() []GitserverClientResolveRevisionFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientResolveRevisionFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientResolveRevisionFuncCall is an object that describes an
// invocation of method ResolveRevision on an instance of
// MockGitserverClient.
type GitserverClientResolveRevisionFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 api.CommitID
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientResolveRevisionFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientResolveRevisionFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockIndexEnqueuer is a mock implementation of the IndexEnqueuer interface
// (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/frontend/internal/codeintel/resolvers)
// used for unit testing.
type MockIndexEnqueuer struct {
	// InferIndexConfigurationFunc is an instance of a mock function object
	// controlling the behavior of the method InferIndexConfiguration.
	InferIndexConfigurationFunc *IndexEnqueuerInferIndexConfigurationFunc
	// QueueIndexesFunc is an instance of a mock function object controlling
	// the behavior of the method QueueIndexes.
	QueueIndexesFunc *IndexEnqueuerQueueIndexesFunc
}

// NewMockIndexEnqueuer creates a new mock of the IndexEnqueuer interface.
// All methods return zero values for all results, unless overwritten.
func NewMockIndexEnqueuer() *MockIndexEnqueuer {
	return &MockIndexEnqueuer{
		InferIndexConfigurationFunc: &IndexEnqueuerInferIndexConfigurationFunc{
			defaultHook: func(context.Context, int, string) (r0 *config.IndexConfiguration, r1 []config.IndexJobHint, r2 error) {
				return
			},
		},
		QueueIndexesFunc: &IndexEnqueuerQueueIndexesFunc{
			defaultHook: func(context.Context, int, string, string, bool) (r0 []dbstore.Index, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockIndexEnqueuer creates a new mock of the IndexEnqueuer
// interface. All methods panic on invocation, unless overwritten.
func NewStrictMockIndexEnqueuer() *MockIndexEnqueuer {
	return &MockIndexEnqueuer{
		InferIndexConfigurationFunc: &IndexEnqueuerInferIndexConfigurationFunc{
			defaultHook: func(context.Context, int, string) (*config.IndexConfiguration, []config.IndexJobHint, error) {
				panic("unexpected invocation of MockIndexEnqueuer.InferIndexConfiguration")
			},
		},
		QueueIndexesFunc: &IndexEnqueuerQueueIndexesFunc{
			defaultHook: func(context.Context, int, string, string, bool) ([]dbstore.Index, error) {
				panic("unexpected invocation of MockIndexEnqueuer.QueueIndexes")
			},
		},
	}
}

// NewMockIndexEnqueuerFrom creates a new mock of the MockIndexEnqueuer
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockIndexEnqueuerFrom(i IndexEnqueuer) *MockIndexEnqueuer {
	return &MockIndexEnqueuer{
		InferIndexConfigurationFunc: &IndexEnqueuerInferIndexConfigurationFunc{
			defaultHook: i.InferIndexConfiguration,
		},
		QueueIndexesFunc: &IndexEnqueuerQueueIndexesFunc{
			defaultHook: i.QueueIndexes,
		},
	}
}

// IndexEnqueuerInferIndexConfigurationFunc describes the behavior when the
// InferIndexConfiguration method of the parent MockIndexEnqueuer instance
// is invoked.
type IndexEnqueuerInferIndexConfigurationFunc struct {
	defaultHook func(context.Context, int, string) (*config.IndexConfiguration, []config.IndexJobHint, error)
	hooks       []func(context.Context, int, string) (*config.IndexConfiguration, []config.IndexJobHint, error)
	history     []IndexEnqueuerInferIndexConfigurationFuncCall
	mutex       sync.Mutex
}

// InferIndexConfiguration delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockIndexEnqueuer) InferIndexConfiguration(v0 context.Context, v1 int, v2 string) (*config.IndexConfiguration, []config.IndexJobHint, error) {
	r0, r1, r2 := m.InferIndexConfigurationFunc.nextHook()(v0, v1, v2)
	m.InferIndexConfigurationFunc.appendCall(IndexEnqueuerInferIndexConfigurationFuncCall{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// InferIndexConfiguration method of the parent MockIndexEnqueuer instance
// is invoked and the hook queue is empty.
func (f *IndexEnqueuerInferIndexConfigurationFunc) SetDefaultHook(hook func(context.Context, int, string) (*config.IndexConfiguration, []config.IndexJobHint, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InferIndexConfiguration method of the parent MockIndexEnqueuer instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *IndexEnqueuerInferIndexConfigurationFunc) PushHook(hook func(context.Context, int, string) (*config.IndexConfiguration, []config.IndexJobHint, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *IndexEnqueuerInferIndexConfigurationFunc) SetDefaultReturn(r0 *config.IndexConfiguration, r1 []config.IndexJobHint, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string) (*config.IndexConfiguration, []config.IndexJobHint, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *IndexEnqueuerInferIndexConfigurationFunc) PushReturn(r0 *config.IndexConfiguration, r1 []config.IndexJobHint, r2 error) {
	f.PushHook(func(context.Context, int, string) (*config.IndexConfiguration, []config.IndexJobHint, error) {
		return r0, r1, r2
	})
}

func (f *IndexEnqueuerInferIndexConfigurationFunc) nextHook() func(context.Context, int, string) (*config.IndexConfiguration, []config.IndexJobHint, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *IndexEnqueuerInferIndexConfigurationFunc) appendCall(r0 IndexEnqueuerInferIndexConfigurationFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// IndexEnqueuerInferIndexConfigurationFuncCall objects describing the
// invocations of this function.
func (f *IndexEnqueuerInferIndexConfigurationFunc) History() []IndexEnqueuerInferIndexConfigurationFuncCall {
	f.mutex.Lock()
	history := make([]IndexEnqueuerInferIndexConfigurationFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// IndexEnqueuerInferIndexConfigurationFuncCall is an object that describes
// an invocation of method InferIndexConfiguration on an instance of
// MockIndexEnqueuer.
type IndexEnqueuerInferIndexConfigurationFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *config.IndexConfiguration
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 []config.IndexJobHint
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c IndexEnqueuerInferIndexConfigurationFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c IndexEnqueuerInferIndexConfigurationFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// IndexEnqueuerQueueIndexesFunc describes the behavior when the
// QueueIndexes method of the parent MockIndexEnqueuer instance is invoked.
type IndexEnqueuerQueueIndexesFunc struct {
	defaultHook func(context.Context, int, string, string, bool) ([]dbstore.Index, error)
	hooks       []func(context.Context, int, string, string, bool) ([]dbstore.Index, error)
	history     []IndexEnqueuerQueueIndexesFuncCall
	mutex       sync.Mutex
}

// QueueIndexes delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockIndexEnqueuer) QueueIndexes(v0 context.Context, v1 int, v2 string, v3 string, v4 bool) ([]dbstore.Index, error) {
	r0, r1 := m.QueueIndexesFunc.nextHook()(v0, v1, v2, v3, v4)
	m.QueueIndexesFunc.appendCall(IndexEnqueuerQueueIndexesFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the QueueIndexes method
// of the parent MockIndexEnqueuer instance is invoked and the hook queue is
// empty.
func (f *IndexEnqueuerQueueIndexesFunc) SetDefaultHook(hook func(context.Context, int, string, string, bool) ([]dbstore.Index, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// QueueIndexes method of the parent MockIndexEnqueuer instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *IndexEnqueuerQueueIndexesFunc) PushHook(hook func(context.Context, int, string, string, bool) ([]dbstore.Index, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *IndexEnqueuerQueueIndexesFunc) SetDefaultReturn(r0 []dbstore.Index, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, bool) ([]dbstore.Index, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *IndexEnqueuerQueueIndexesFunc) PushReturn(r0 []dbstore.Index, r1 error) {
	f.PushHook(func(context.Context, int, string, string, bool) ([]dbstore.Index, error) {
		return r0, r1
	})
}

func (f *IndexEnqueuerQueueIndexesFunc) nextHook() func(context.Context, int, string, string, bool) ([]dbstore.Index, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *IndexEnqueuerQueueIndexesFunc) appendCall(r0 IndexEnqueuerQueueIndexesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of IndexEnqueuerQueueIndexesFuncCall objects
// describing the invocations of this function.
func (f *IndexEnqueuerQueueIndexesFunc) History() []IndexEnqueuerQueueIndexesFuncCall {
	f.mutex.Lock()
	history := make([]IndexEnqueuerQueueIndexesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// IndexEnqueuerQueueIndexesFuncCall is an object that describes an
// invocation of method QueueIndexes on an instance of MockIndexEnqueuer.
type IndexEnqueuerQueueIndexesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 bool
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c IndexEnqueuerQueueIndexesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c IndexEnqueuerQueueIndexesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockLSIFStore is a mock implementation of the LSIFStore interface (from
// the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/frontend/internal/codeintel/resolvers)
// used for unit testing.
type MockLSIFStore struct {
	// BulkMonikerResultsFunc is an instance of a mock function object
	// controlling the behavior of the method BulkMonikerResults.
	BulkMonikerResultsFunc *LSIFStoreBulkMonikerResultsFunc
	// DefinitionsFunc is an instance of a mock function object controlling
	// the behavior of the method Definitions.
	DefinitionsFunc *LSIFStoreDefinitionsFunc
	// DiagnosticsFunc is an instance of a mock function object controlling
	// the behavior of the method Diagnostics.
	DiagnosticsFunc *LSIFStoreDiagnosticsFunc
	// DocumentPathsFunc is an instance of a mock function object
	// controlling the behavior of the method DocumentPaths.
	DocumentPathsFunc *LSIFStoreDocumentPathsFunc
	// ExistsFunc is an instance of a mock function object controlling the
	// behavior of the method Exists.
	ExistsFunc *LSIFStoreExistsFunc
	// HoverFunc is an instance of a mock function object controlling the
	// behavior of the method Hover.
	HoverFunc *LSIFStoreHoverFunc
	// ImplementationsFunc is an instance of a mock function object
	// controlling the behavior of the method Implementations.
	ImplementationsFunc *LSIFStoreImplementationsFunc
	// MonikersByPositionFunc is an instance of a mock function object
	// controlling the behavior of the method MonikersByPosition.
	MonikersByPositionFunc *LSIFStoreMonikersByPositionFunc
	// PackageInformationFunc is an instance of a mock function object
	// controlling the behavior of the method PackageInformation.
	PackageInformationFunc *LSIFStorePackageInformationFunc
	// RangesFunc is an instance of a mock function object controlling the
	// behavior of the method Ranges.
	RangesFunc *LSIFStoreRangesFunc
	// ReferencesFunc is an instance of a mock function object controlling
	// the behavior of the method References.
	ReferencesFunc *LSIFStoreReferencesFunc
	// StencilFunc is an instance of a mock function object controlling the
	// behavior of the method Stencil.
	StencilFunc *LSIFStoreStencilFunc
}

// NewMockLSIFStore creates a new mock of the LSIFStore interface. All
// methods return zero values for all results, unless overwritten.
func NewMockLSIFStore() *MockLSIFStore {
	return &MockLSIFStore{
		BulkMonikerResultsFunc: &LSIFStoreBulkMonikerResultsFunc{
			defaultHook: func(context.Context, string, []int, []precise.MonikerData, int, int) (r0 []lsifstore.Location, r1 int, r2 error) {
				return
			},
		},
		DefinitionsFunc: &LSIFStoreDefinitionsFunc{
			defaultHook: func(context.Context, int, string, int, int, int, int) (r0 []lsifstore.Location, r1 int, r2 error) {
				return
			},
		},
		DiagnosticsFunc: &LSIFStoreDiagnosticsFunc{
			defaultHook: func(context.Context, int, string, int, int) (r0 []lsifstore.Diagnostic, r1 int, r2 error) {
				return
			},
		},
		DocumentPathsFunc: &LSIFStoreDocumentPathsFunc{
			defaultHook: func(context.Context, int, string) (r0 []string, r1 int, r2 error) {
				return
			},
		},
		ExistsFunc: &LSIFStoreExistsFunc{
			defaultHook: func(context.Context, int, string) (r0 bool, r1 error) {
				return
			},
		},
		HoverFunc: &LSIFStoreHoverFunc{
			defaultHook: func(context.Context, int, string, int, int) (r0 string, r1 lsifstore.Range, r2 bool, r3 error) {
				return
			},
		},
		ImplementationsFunc: &LSIFStoreImplementationsFunc{
			defaultHook: func(context.Context, int, string, int, int, int, int) (r0 []lsifstore.Location, r1 int, r2 error) {
				return
			},
		},
		MonikersByPositionFunc: &LSIFStoreMonikersByPositionFunc{
			defaultHook: func(context.Context, int, string, int, int) (r0 [][]precise.MonikerData, r1 error) {
				return
			},
		},
		PackageInformationFunc: &LSIFStorePackageInformationFunc{
			defaultHook: func(context.Context, int, string, string) (r0 precise.PackageInformationData, r1 bool, r2 error) {
				return
			},
		},
		RangesFunc: &LSIFStoreRangesFunc{
			defaultHook: func(context.Context, int, string, int, int) (r0 []lsifstore.CodeIntelligenceRange, r1 error) {
				return
			},
		},
		ReferencesFunc: &LSIFStoreReferencesFunc{
			defaultHook: func(context.Context, int, string, int, int, int, int) (r0 []lsifstore.Location, r1 int, r2 error) {
				return
			},
		},
		StencilFunc: &LSIFStoreStencilFunc{
			defaultHook: func(context.Context, int, string) (r0 []lsifstore.Range, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockLSIFStore creates a new mock of the LSIFStore interface. All
// methods panic on invocation, unless overwritten.
func NewStrictMockLSIFStore() *MockLSIFStore {
	return &MockLSIFStore{
		BulkMonikerResultsFunc: &LSIFStoreBulkMonikerResultsFunc{
			defaultHook: func(context.Context, string, []int, []precise.MonikerData, int, int) ([]lsifstore.Location, int, error) {
				panic("unexpected invocation of MockLSIFStore.BulkMonikerResults")
			},
		},
		DefinitionsFunc: &LSIFStoreDefinitionsFunc{
			defaultHook: func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error) {
				panic("unexpected invocation of MockLSIFStore.Definitions")
			},
		},
		DiagnosticsFunc: &LSIFStoreDiagnosticsFunc{
			defaultHook: func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error) {
				panic("unexpected invocation of MockLSIFStore.Diagnostics")
			},
		},
		DocumentPathsFunc: &LSIFStoreDocumentPathsFunc{
			defaultHook: func(context.Context, int, string) ([]string, int, error) {
				panic("unexpected invocation of MockLSIFStore.DocumentPaths")
			},
		},
		ExistsFunc: &LSIFStoreExistsFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				panic("unexpected invocation of MockLSIFStore.Exists")
			},
		},
		HoverFunc: &LSIFStoreHoverFunc{
			defaultHook: func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error) {
				panic("unexpected invocation of MockLSIFStore.Hover")
			},
		},
		ImplementationsFunc: &LSIFStoreImplementationsFunc{
			defaultHook: func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error) {
				panic("unexpected invocation of MockLSIFStore.Implementations")
			},
		},
		MonikersByPositionFunc: &LSIFStoreMonikersByPositionFunc{
			defaultHook: func(context.Context, int, string, int, int) ([][]precise.MonikerData, error) {
				panic("unexpected invocation of MockLSIFStore.MonikersByPosition")
			},
		},
		PackageInformationFunc: &LSIFStorePackageInformationFunc{
			defaultHook: func(context.Context, int, string, string) (precise.PackageInformationData, bool, error) {
				panic("unexpected invocation of MockLSIFStore.PackageInformation")
			},
		},
		RangesFunc: &LSIFStoreRangesFunc{
			defaultHook: func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error) {
				panic("unexpected invocation of MockLSIFStore.Ranges")
			},
		},
		ReferencesFunc: &LSIFStoreReferencesFunc{
			defaultHook: func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error) {
				panic("unexpected invocation of MockLSIFStore.References")
			},
		},
		StencilFunc: &LSIFStoreStencilFunc{
			defaultHook: func(context.Context, int, string) ([]lsifstore.Range, error) {
				panic("unexpected invocation of MockLSIFStore.Stencil")
			},
		},
	}
}

// NewMockLSIFStoreFrom creates a new mock of the MockLSIFStore interface.
// All methods delegate to the given implementation, unless overwritten.
func NewMockLSIFStoreFrom(i LSIFStore) *MockLSIFStore {
	return &MockLSIFStore{
		BulkMonikerResultsFunc: &LSIFStoreBulkMonikerResultsFunc{
			defaultHook: i.BulkMonikerResults,
		},
		DefinitionsFunc: &LSIFStoreDefinitionsFunc{
			defaultHook: i.Definitions,
		},
		DiagnosticsFunc: &LSIFStoreDiagnosticsFunc{
			defaultHook: i.Diagnostics,
		},
		DocumentPathsFunc: &LSIFStoreDocumentPathsFunc{
			defaultHook: i.DocumentPaths,
		},
		ExistsFunc: &LSIFStoreExistsFunc{
			defaultHook: i.Exists,
		},
		HoverFunc: &LSIFStoreHoverFunc{
			defaultHook: i.Hover,
		},
		ImplementationsFunc: &LSIFStoreImplementationsFunc{
			defaultHook: i.Implementations,
		},
		MonikersByPositionFunc: &LSIFStoreMonikersByPositionFunc{
			defaultHook: i.MonikersByPosition,
		},
		PackageInformationFunc: &LSIFStorePackageInformationFunc{
			defaultHook: i.PackageInformation,
		},
		RangesFunc: &LSIFStoreRangesFunc{
			defaultHook: i.Ranges,
		},
		ReferencesFunc: &LSIFStoreReferencesFunc{
			defaultHook: i.References,
		},
		StencilFunc: &LSIFStoreStencilFunc{
			defaultHook: i.Stencil,
		},
	}
}

// LSIFStoreBulkMonikerResultsFunc describes the behavior when the
// BulkMonikerResults method of the parent MockLSIFStore instance is
// invoked.
type LSIFStoreBulkMonikerResultsFunc struct {
	defaultHook func(context.Context, string, []int, []precise.MonikerData, int, int) ([]lsifstore.Location, int, error)
	hooks       []func(context.Context, string, []int, []precise.MonikerData, int, int) ([]lsifstore.Location, int, error)
	history     []LSIFStoreBulkMonikerResultsFuncCall
	mutex       sync.Mutex
}

// BulkMonikerResults delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) BulkMonikerResults(v0 context.Context, v1 string, v2 []int, v3 []precise.MonikerData, v4 int, v5 int) ([]lsifstore.Location, int, error) {
	r0, r1, r2 := m.BulkMonikerResultsFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.BulkMonikerResultsFunc.appendCall(LSIFStoreBulkMonikerResultsFuncCall{v0, v1, v2, v3, v4, v5, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the BulkMonikerResults
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreBulkMonikerResultsFunc) SetDefaultHook(hook func(context.Context, string, []int, []precise.MonikerData, int, int) ([]lsifstore.Location, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// BulkMonikerResults method of the parent MockLSIFStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *LSIFStoreBulkMonikerResultsFunc) PushHook(hook func(context.Context, string, []int, []precise.MonikerData, int, int) ([]lsifstore.Location, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreBulkMonikerResultsFunc) SetDefaultReturn(r0 []lsifstore.Location, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, string, []int, []precise.MonikerData, int, int) ([]lsifstore.Location, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreBulkMonikerResultsFunc) PushReturn(r0 []lsifstore.Location, r1 int, r2 error) {
	f.PushHook(func(context.Context, string, []int, []precise.MonikerData, int, int) ([]lsifstore.Location, int, error) {
		return r0, r1, r2
	})
}

func (f *LSIFStoreBulkMonikerResultsFunc) nextHook() func(context.Context, string, []int, []precise.MonikerData, int, int) ([]lsifstore.Location, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreBulkMonikerResultsFunc) appendCall(r0 LSIFStoreBulkMonikerResultsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreBulkMonikerResultsFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreBulkMonikerResultsFunc) History() []LSIFStoreBulkMonikerResultsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreBulkMonikerResultsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreBulkMonikerResultsFuncCall is an object that describes an
// invocation of method BulkMonikerResults on an instance of MockLSIFStore.
type LSIFStoreBulkMonikerResultsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 []precise.MonikerData
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.Location
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreBulkMonikerResultsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreBulkMonikerResultsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// LSIFStoreDefinitionsFunc describes the behavior when the Definitions
// method of the parent MockLSIFStore instance is invoked.
type LSIFStoreDefinitionsFunc struct {
	defaultHook func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error)
	hooks       []func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error)
	history     []LSIFStoreDefinitionsFuncCall
	mutex       sync.Mutex
}

// Definitions delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockLSIFStore) Definitions(v0 context.Context, v1 int, v2 string, v3 int, v4 int, v5 int, v6 int) ([]lsifstore.Location, int, error) {
	r0, r1, r2 := m.DefinitionsFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6)
	m.DefinitionsFunc.appendCall(LSIFStoreDefinitionsFuncCall{v0, v1, v2, v3, v4, v5, v6, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Definitions method
// of the parent MockLSIFStore instance is invoked and the hook queue is
// empty.
func (f *LSIFStoreDefinitionsFunc) SetDefaultHook(hook func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Definitions method of the parent MockLSIFStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreDefinitionsFunc) PushHook(hook func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreDefinitionsFunc) SetDefaultReturn(r0 []lsifstore.Location, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreDefinitionsFunc) PushReturn(r0 []lsifstore.Location, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error) {
		return r0, r1, r2
	})
}

func (f *LSIFStoreDefinitionsFunc) nextHook() func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreDefinitionsFunc) appendCall(r0 LSIFStoreDefinitionsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreDefinitionsFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreDefinitionsFunc) History() []LSIFStoreDefinitionsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreDefinitionsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreDefinitionsFuncCall is an object that describes an invocation of
// method Definitions on an instance of MockLSIFStore.
type LSIFStoreDefinitionsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 int
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.Location
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreDefinitionsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreDefinitionsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// LSIFStoreDiagnosticsFunc describes the behavior when the Diagnostics
// method of the parent MockLSIFStore instance is invoked.
type LSIFStoreDiagnosticsFunc struct {
	defaultHook func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error)
	hooks       []func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error)
	history     []LSIFStoreDiagnosticsFuncCall
	mutex       sync.Mutex
}

// Diagnostics delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockLSIFStore) Diagnostics(v0 context.Context, v1 int, v2 string, v3 int, v4 int) ([]lsifstore.Diagnostic, int, error) {
	r0, r1, r2 := m.DiagnosticsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.DiagnosticsFunc.appendCall(LSIFStoreDiagnosticsFuncCall{v0, v1, v2, v3, v4, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Diagnostics method
// of the parent MockLSIFStore instance is invoked and the hook queue is
// empty.
func (f *LSIFStoreDiagnosticsFunc) SetDefaultHook(hook func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Diagnostics method of the parent MockLSIFStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreDiagnosticsFunc) PushHook(hook func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreDiagnosticsFunc) SetDefaultReturn(r0 []lsifstore.Diagnostic, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreDiagnosticsFunc) PushReturn(r0 []lsifstore.Diagnostic, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error) {
		return r0, r1, r2
	})
}

func (f *LSIFStoreDiagnosticsFunc) nextHook() func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreDiagnosticsFunc) appendCall(r0 LSIFStoreDiagnosticsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreDiagnosticsFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreDiagnosticsFunc) History() []LSIFStoreDiagnosticsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreDiagnosticsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreDiagnosticsFuncCall is an object that describes an invocation of
// method Diagnostics on an instance of MockLSIFStore.
type LSIFStoreDiagnosticsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.Diagnostic
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreDiagnosticsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreDiagnosticsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// LSIFStoreDocumentPathsFunc describes the behavior when the DocumentPaths
// method of the parent MockLSIFStore instance is invoked.
type LSIFStoreDocumentPathsFunc struct {
	defaultHook func(context.Context, int, string) ([]string, int, error)
	hooks       []func(context.Context, int, string) ([]string, int, error)
	history     []LSIFStoreDocumentPathsFuncCall
	mutex       sync.Mutex
}

// DocumentPaths delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockLSIFStore) DocumentPaths(v0 context.Context, v1 int, v2 string) ([]string, int, error) {
	r0, r1, r2 := m.DocumentPathsFunc.nextHook()(v0, v1, v2)
	m.DocumentPathsFunc.appendCall(LSIFStoreDocumentPathsFuncCall{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the DocumentPaths method
// of the parent MockLSIFStore instance is invoked and the hook queue is
// empty.
func (f *LSIFStoreDocumentPathsFunc) SetDefaultHook(hook func(context.Context, int, string) ([]string, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DocumentPaths method of the parent MockLSIFStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreDocumentPathsFunc) PushHook(hook func(context.Context, int, string) ([]string, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreDocumentPathsFunc) SetDefaultReturn(r0 []string, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string) ([]string, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreDocumentPathsFunc) PushReturn(r0 []string, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string) ([]string, int, error) {
		return r0, r1, r2
	})
}

func (f *LSIFStoreDocumentPathsFunc) nextHook() func(context.Context, int, string) ([]string, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreDocumentPathsFunc) appendCall(r0 LSIFStoreDocumentPathsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreDocumentPathsFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreDocumentPathsFunc) History() []LSIFStoreDocumentPathsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreDocumentPathsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreDocumentPathsFuncCall is an object that describes an invocation
// of method DocumentPaths on an instance of MockLSIFStore.
type LSIFStoreDocumentPathsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreDocumentPathsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreDocumentPathsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// LSIFStoreExistsFunc describes the behavior when the Exists method of the
// parent MockLSIFStore instance is invoked.
type LSIFStoreExistsFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []LSIFStoreExistsFuncCall
	mutex       sync.Mutex
}

// Exists delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) Exists(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.ExistsFunc.nextHook()(v0, v1, v2)
	m.ExistsFunc.appendCall(LSIFStoreExistsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Exists method of the
// parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreExistsFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Exists method of the parent MockLSIFStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreExistsFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreExistsFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreExistsFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *LSIFStoreExistsFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreExistsFunc) appendCall(r0 LSIFStoreExistsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreExistsFuncCall objects describing
// the invocations of this function.
func (f *LSIFStoreExistsFunc) History() []LSIFStoreExistsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreExistsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreExistsFuncCall is an object that describes an invocation of
// method Exists on an instance of MockLSIFStore.
type LSIFStoreExistsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreExistsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreExistsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStoreHoverFunc describes the behavior when the Hover method of the
// parent MockLSIFStore instance is invoked.
type LSIFStoreHoverFunc struct {
	defaultHook func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error)
	hooks       []func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error)
	history     []LSIFStoreHoverFuncCall
	mutex       sync.Mutex
}

// Hover delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) Hover(v0 context.Context, v1 int, v2 string, v3 int, v4 int) (string, lsifstore.Range, bool, error) {
	r0, r1, r2, r3 := m.HoverFunc.nextHook()(v0, v1, v2, v3, v4)
	m.HoverFunc.appendCall(LSIFStoreHoverFuncCall{v0, v1, v2, v3, v4, r0, r1, r2, r3})
	return r0, r1, r2, r3
}

// SetDefaultHook sets function that is called when the Hover method of the
// parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreHoverFunc) SetDefaultHook(hook func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Hover method of the parent MockLSIFStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *LSIFStoreHoverFunc) PushHook(hook func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreHoverFunc) SetDefaultReturn(r0 string, r1 lsifstore.Range, r2 bool, r3 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error) {
		return r0, r1, r2, r3
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreHoverFunc) PushReturn(r0 string, r1 lsifstore.Range, r2 bool, r3 error) {
	f.PushHook(func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error) {
		return r0, r1, r2, r3
	})
}

func (f *LSIFStoreHoverFunc) nextHook() func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreHoverFunc) appendCall(r0 LSIFStoreHoverFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreHoverFuncCall objects describing
// the invocations of this function.
func (f *LSIFStoreHoverFunc) History() []LSIFStoreHoverFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreHoverFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreHoverFuncCall is an object that describes an invocation of
// method Hover on an instance of MockLSIFStore.
type LSIFStoreHoverFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 lsifstore.Range
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 bool
	// Result3 is the value of the 4th result returned from this method
	// invocation.
	Result3 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreHoverFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreHoverFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2, c.Result3}
}

// LSIFStoreImplementationsFunc describes the behavior when the
// Implementations method of the parent MockLSIFStore instance is invoked.
type LSIFStoreImplementationsFunc struct {
	defaultHook func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error)
	hooks       []func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error)
	history     []LSIFStoreImplementationsFuncCall
	mutex       sync.Mutex
}

// Implementations delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) Implementations(v0 context.Context, v1 int, v2 string, v3 int, v4 int, v5 int, v6 int) ([]lsifstore.Location, int, error) {
	r0, r1, r2 := m.ImplementationsFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6)
	m.ImplementationsFunc.appendCall(LSIFStoreImplementationsFuncCall{v0, v1, v2, v3, v4, v5, v6, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Implementations
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreImplementationsFunc) SetDefaultHook(hook func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Implementations method of the parent MockLSIFStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreImplementationsFunc) PushHook(hook func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreImplementationsFunc) SetDefaultReturn(r0 []lsifstore.Location, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreImplementationsFunc) PushReturn(r0 []lsifstore.Location, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error) {
		return r0, r1, r2
	})
}

func (f *LSIFStoreImplementationsFunc) nextHook() func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreImplementationsFunc) appendCall(r0 LSIFStoreImplementationsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreImplementationsFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreImplementationsFunc) History() []LSIFStoreImplementationsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreImplementationsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreImplementationsFuncCall is an object that describes an
// invocation of method Implementations on an instance of MockLSIFStore.
type LSIFStoreImplementationsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 int
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.Location
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreImplementationsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreImplementationsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// LSIFStoreMonikersByPositionFunc describes the behavior when the
// MonikersByPosition method of the parent MockLSIFStore instance is
// invoked.
type LSIFStoreMonikersByPositionFunc struct {
	defaultHook func(context.Context, int, string, int, int) ([][]precise.MonikerData, error)
	hooks       []func(context.Context, int, string, int, int) ([][]precise.MonikerData, error)
	history     []LSIFStoreMonikersByPositionFuncCall
	mutex       sync.Mutex
}

// MonikersByPosition delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) MonikersByPosition(v0 context.Context, v1 int, v2 string, v3 int, v4 int) ([][]precise.MonikerData, error) {
	r0, r1 := m.MonikersByPositionFunc.nextHook()(v0, v1, v2, v3, v4)
	m.MonikersByPositionFunc.appendCall(LSIFStoreMonikersByPositionFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MonikersByPosition
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreMonikersByPositionFunc) SetDefaultHook(hook func(context.Context, int, string, int, int) ([][]precise.MonikerData, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MonikersByPosition method of the parent MockLSIFStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *LSIFStoreMonikersByPositionFunc) PushHook(hook func(context.Context, int, string, int, int) ([][]precise.MonikerData, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreMonikersByPositionFunc) SetDefaultReturn(r0 [][]precise.MonikerData, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int) ([][]precise.MonikerData, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreMonikersByPositionFunc) PushReturn(r0 [][]precise.MonikerData, r1 error) {
	f.PushHook(func(context.Context, int, string, int, int) ([][]precise.MonikerData, error) {
		return r0, r1
	})
}

func (f *LSIFStoreMonikersByPositionFunc) nextHook() func(context.Context, int, string, int, int) ([][]precise.MonikerData, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreMonikersByPositionFunc) appendCall(r0 LSIFStoreMonikersByPositionFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreMonikersByPositionFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreMonikersByPositionFunc) History() []LSIFStoreMonikersByPositionFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreMonikersByPositionFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreMonikersByPositionFuncCall is an object that describes an
// invocation of method MonikersByPosition on an instance of MockLSIFStore.
type LSIFStoreMonikersByPositionFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 [][]precise.MonikerData
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreMonikersByPositionFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreMonikersByPositionFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStorePackageInformationFunc describes the behavior when the
// PackageInformation method of the parent MockLSIFStore instance is
// invoked.
type LSIFStorePackageInformationFunc struct {
	defaultHook func(context.Context, int, string, string) (precise.PackageInformationData, bool, error)
	hooks       []func(context.Context, int, string, string) (precise.PackageInformationData, bool, error)
	history     []LSIFStorePackageInformationFuncCall
	mutex       sync.Mutex
}

// PackageInformation delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) PackageInformation(v0 context.Context, v1 int, v2 string, v3 string) (precise.PackageInformationData, bool, error) {
	r0, r1, r2 := m.PackageInformationFunc.nextHook()(v0, v1, v2, v3)
	m.PackageInformationFunc.appendCall(LSIFStorePackageInformationFuncCall{v0, v1, v2, v3, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the PackageInformation
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStorePackageInformationFunc) SetDefaultHook(hook func(context.Context, int, string, string) (precise.PackageInformationData, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// PackageInformation method of the parent MockLSIFStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *LSIFStorePackageInformationFunc) PushHook(hook func(context.Context, int, string, string) (precise.PackageInformationData, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStorePackageInformationFunc) SetDefaultReturn(r0 precise.PackageInformationData, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, string) (precise.PackageInformationData, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStorePackageInformationFunc) PushReturn(r0 precise.PackageInformationData, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int, string, string) (precise.PackageInformationData, bool, error) {
		return r0, r1, r2
	})
}

func (f *LSIFStorePackageInformationFunc) nextHook() func(context.Context, int, string, string) (precise.PackageInformationData, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStorePackageInformationFunc) appendCall(r0 LSIFStorePackageInformationFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStorePackageInformationFuncCall objects
// describing the invocations of this function.
func (f *LSIFStorePackageInformationFunc) History() []LSIFStorePackageInformationFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStorePackageInformationFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStorePackageInformationFuncCall is an object that describes an
// invocation of method PackageInformation on an instance of MockLSIFStore.
type LSIFStorePackageInformationFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 precise.PackageInformationData
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStorePackageInformationFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStorePackageInformationFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// LSIFStoreRangesFunc describes the behavior when the Ranges method of the
// parent MockLSIFStore instance is invoked.
type LSIFStoreRangesFunc struct {
	defaultHook func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error)
	hooks       []func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error)
	history     []LSIFStoreRangesFuncCall
	mutex       sync.Mutex
}

// Ranges delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) Ranges(v0 context.Context, v1 int, v2 string, v3 int, v4 int) ([]lsifstore.CodeIntelligenceRange, error) {
	r0, r1 := m.RangesFunc.nextHook()(v0, v1, v2, v3, v4)
	m.RangesFunc.appendCall(LSIFStoreRangesFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Ranges method of the
// parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreRangesFunc) SetDefaultHook(hook func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Ranges method of the parent MockLSIFStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreRangesFunc) PushHook(hook func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreRangesFunc) SetDefaultReturn(r0 []lsifstore.CodeIntelligenceRange, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreRangesFunc) PushReturn(r0 []lsifstore.CodeIntelligenceRange, r1 error) {
	f.PushHook(func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error) {
		return r0, r1
	})
}

func (f *LSIFStoreRangesFunc) nextHook() func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreRangesFunc) appendCall(r0 LSIFStoreRangesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreRangesFuncCall objects describing
// the invocations of this function.
func (f *LSIFStoreRangesFunc) History() []LSIFStoreRangesFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreRangesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreRangesFuncCall is an object that describes an invocation of
// method Ranges on an instance of MockLSIFStore.
type LSIFStoreRangesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.CodeIntelligenceRange
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreRangesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreRangesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStoreReferencesFunc describes the behavior when the References method
// of the parent MockLSIFStore instance is invoked.
type LSIFStoreReferencesFunc struct {
	defaultHook func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error)
	hooks       []func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error)
	history     []LSIFStoreReferencesFuncCall
	mutex       sync.Mutex
}

// References delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockLSIFStore) References(v0 context.Context, v1 int, v2 string, v3 int, v4 int, v5 int, v6 int) ([]lsifstore.Location, int, error) {
	r0, r1, r2 := m.ReferencesFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6)
	m.ReferencesFunc.appendCall(LSIFStoreReferencesFuncCall{v0, v1, v2, v3, v4, v5, v6, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the References method of
// the parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreReferencesFunc) SetDefaultHook(hook func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// References method of the parent MockLSIFStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreReferencesFunc) PushHook(hook func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreReferencesFunc) SetDefaultReturn(r0 []lsifstore.Location, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreReferencesFunc) PushReturn(r0 []lsifstore.Location, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error) {
		return r0, r1, r2
	})
}

func (f *LSIFStoreReferencesFunc) nextHook() func(context.Context, int, string, int, int, int, int) ([]lsifstore.Location, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreReferencesFunc) appendCall(r0 LSIFStoreReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreReferencesFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreReferencesFunc) History() []LSIFStoreReferencesFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreReferencesFuncCall is an object that describes an invocation of
// method References on an instance of MockLSIFStore.
type LSIFStoreReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 int
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.Location
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// LSIFStoreStencilFunc describes the behavior when the Stencil method of
// the parent MockLSIFStore instance is invoked.
type LSIFStoreStencilFunc struct {
	defaultHook func(context.Context, int, string) ([]lsifstore.Range, error)
	hooks       []func(context.Context, int, string) ([]lsifstore.Range, error)
	history     []LSIFStoreStencilFuncCall
	mutex       sync.Mutex
}

// Stencil delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) Stencil(v0 context.Context, v1 int, v2 string) ([]lsifstore.Range, error) {
	r0, r1 := m.StencilFunc.nextHook()(v0, v1, v2)
	m.StencilFunc.appendCall(LSIFStoreStencilFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Stencil method of
// the parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreStencilFunc) SetDefaultHook(hook func(context.Context, int, string) ([]lsifstore.Range, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Stencil method of the parent MockLSIFStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreStencilFunc) PushHook(hook func(context.Context, int, string) ([]lsifstore.Range, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *LSIFStoreStencilFunc) SetDefaultReturn(r0 []lsifstore.Range, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) ([]lsifstore.Range, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *LSIFStoreStencilFunc) PushReturn(r0 []lsifstore.Range, r1 error) {
	f.PushHook(func(context.Context, int, string) ([]lsifstore.Range, error) {
		return r0, r1
	})
}

func (f *LSIFStoreStencilFunc) nextHook() func(context.Context, int, string) ([]lsifstore.Range, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreStencilFunc) appendCall(r0 LSIFStoreStencilFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreStencilFuncCall objects describing
// the invocations of this function.
func (f *LSIFStoreStencilFunc) History() []LSIFStoreStencilFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreStencilFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreStencilFuncCall is an object that describes an invocation of
// method Stencil on an instance of MockLSIFStore.
type LSIFStoreStencilFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.Range
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreStencilFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreStencilFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockRepoUpdaterClient is a mock implementation of the RepoUpdaterClient
// interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/frontend/internal/codeintel/resolvers)
// used for unit testing.
type MockRepoUpdaterClient struct {
	// EnqueueRepoUpdateFunc is an instance of a mock function object
	// controlling the behavior of the method EnqueueRepoUpdate.
	EnqueueRepoUpdateFunc *RepoUpdaterClientEnqueueRepoUpdateFunc
}

// NewMockRepoUpdaterClient creates a new mock of the RepoUpdaterClient
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockRepoUpdaterClient() *MockRepoUpdaterClient {
	return &MockRepoUpdaterClient{
		EnqueueRepoUpdateFunc: &RepoUpdaterClientEnqueueRepoUpdateFunc{
			defaultHook: func(context.Context, api.RepoName) (r0 *protocol.RepoUpdateResponse, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockRepoUpdaterClient creates a new mock of the
// RepoUpdaterClient interface. All methods panic on invocation, unless
// overwritten.
func NewStrictMockRepoUpdaterClient() *MockRepoUpdaterClient {
	return &MockRepoUpdaterClient{
		EnqueueRepoUpdateFunc: &RepoUpdaterClientEnqueueRepoUpdateFunc{
			defaultHook: func(context.Context, api.RepoName) (*protocol.RepoUpdateResponse, error) {
				panic("unexpected invocation of MockRepoUpdaterClient.EnqueueRepoUpdate")
			},
		},
	}
}

// NewMockRepoUpdaterClientFrom creates a new mock of the
// MockRepoUpdaterClient interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockRepoUpdaterClientFrom(i RepoUpdaterClient) *MockRepoUpdaterClient {
	return &MockRepoUpdaterClient{
		EnqueueRepoUpdateFunc: &RepoUpdaterClientEnqueueRepoUpdateFunc{
			defaultHook: i.EnqueueRepoUpdate,
		},
	}
}

// RepoUpdaterClientEnqueueRepoUpdateFunc describes the behavior when the
// EnqueueRepoUpdate method of the parent MockRepoUpdaterClient instance is
// invoked.
type RepoUpdaterClientEnqueueRepoUpdateFunc struct {
	defaultHook func(context.Context, api.RepoName) (*protocol.RepoUpdateResponse, error)
	hooks       []func(context.Context, api.RepoName) (*protocol.RepoUpdateResponse, error)
	history     []RepoUpdaterClientEnqueueRepoUpdateFuncCall
	mutex       sync.Mutex
}

// EnqueueRepoUpdate delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockRepoUpdaterClient) EnqueueRepoUpdate(v0 context.Context, v1 api.RepoName) (*protocol.RepoUpdateResponse, error) {
	r0, r1 := m.EnqueueRepoUpdateFunc.nextHook()(v0, v1)
	m.EnqueueRepoUpdateFunc.appendCall(RepoUpdaterClientEnqueueRepoUpdateFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the EnqueueRepoUpdate
// method of the parent MockRepoUpdaterClient instance is invoked and the
// hook queue is empty.
func (f *RepoUpdaterClientEnqueueRepoUpdateFunc) SetDefaultHook(hook func(context.Context, api.RepoName) (*protocol.RepoUpdateResponse, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// EnqueueRepoUpdate method of the parent MockRepoUpdaterClient instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *RepoUpdaterClientEnqueueRepoUpdateFunc) PushHook(hook func(context.Context, api.RepoName) (*protocol.RepoUpdateResponse, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *RepoUpdaterClientEnqueueRepoUpdateFunc) SetDefaultReturn(r0 *protocol.RepoUpdateResponse, r1 error) {
	f.SetDefaultHook(func(context.Context, api.RepoName) (*protocol.RepoUpdateResponse, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *RepoUpdaterClientEnqueueRepoUpdateFunc) PushReturn(r0 *protocol.RepoUpdateResponse, r1 error) {
	f.PushHook(func(context.Context, api.RepoName) (*protocol.RepoUpdateResponse, error) {
		return r0, r1
	})
}

func (f *RepoUpdaterClientEnqueueRepoUpdateFunc) nextHook() func(context.Context, api.RepoName) (*protocol.RepoUpdateResponse, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *RepoUpdaterClientEnqueueRepoUpdateFunc) appendCall(r0 RepoUpdaterClientEnqueueRepoUpdateFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of RepoUpdaterClientEnqueueRepoUpdateFuncCall
// objects describing the invocations of this function.
func (f *RepoUpdaterClientEnqueueRepoUpdateFunc) History() []RepoUpdaterClientEnqueueRepoUpdateFuncCall {
	f.mutex.Lock()
	history := make([]RepoUpdaterClientEnqueueRepoUpdateFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// RepoUpdaterClientEnqueueRepoUpdateFuncCall is an object that describes an
// invocation of method EnqueueRepoUpdate on an instance of
// MockRepoUpdaterClient.
type RepoUpdaterClientEnqueueRepoUpdateFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 api.RepoName
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *protocol.RepoUpdateResponse
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c RepoUpdaterClientEnqueueRepoUpdateFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c RepoUpdaterClientEnqueueRepoUpdateFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}
