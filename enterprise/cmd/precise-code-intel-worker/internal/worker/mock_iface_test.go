// Code generated by go-mockgen 1.1.2; DO NOT EDIT.

package worker

import (
	"context"
	"sync"
	"time"

	dbstore "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/stores/dbstore"
	api "github.com/sourcegraph/sourcegraph/internal/api"
	basestore "github.com/sourcegraph/sourcegraph/internal/database/basestore"
	types "github.com/sourcegraph/sourcegraph/internal/types"
	precise "github.com/sourcegraph/sourcegraph/lib/codeintel/precise"
)

// MockDBStore is a mock implementation of the DBStore interface (from the
// package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/precise-code-intel-worker/internal/worker)
// used for unit testing.
type MockDBStore struct {
	// DeleteOverlappingDumpsFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteOverlappingDumps.
	DeleteOverlappingDumpsFunc *DBStoreDeleteOverlappingDumpsFunc
	// DoneFunc is an instance of a mock function object controlling the
	// behavior of the method Done.
	DoneFunc *DBStoreDoneFunc
	// HandleFunc is an instance of a mock function object controlling the
	// behavior of the method Handle.
	HandleFunc *DBStoreHandleFunc
	// InsertDependencySyncingJobFunc is an instance of a mock function
	// object controlling the behavior of the method
	// InsertDependencySyncingJob.
	InsertDependencySyncingJobFunc *DBStoreInsertDependencySyncingJobFunc
	// MarkRepositoryAsDirtyFunc is an instance of a mock function object
	// controlling the behavior of the method MarkRepositoryAsDirty.
	MarkRepositoryAsDirtyFunc *DBStoreMarkRepositoryAsDirtyFunc
	// RepoNameFunc is an instance of a mock function object controlling the
	// behavior of the method RepoName.
	RepoNameFunc *DBStoreRepoNameFunc
	// TransactFunc is an instance of a mock function object controlling the
	// behavior of the method Transact.
	TransactFunc *DBStoreTransactFunc
	// UpdateCommitedAtFunc is an instance of a mock function object
	// controlling the behavior of the method UpdateCommitedAt.
	UpdateCommitedAtFunc *DBStoreUpdateCommitedAtFunc
	// UpdateDependencyNumReferencesFunc is an instance of a mock function
	// object controlling the behavior of the method
	// UpdateDependencyNumReferences.
	UpdateDependencyNumReferencesFunc *DBStoreUpdateDependencyNumReferencesFunc
	// UpdateNumReferencesFunc is an instance of a mock function object
	// controlling the behavior of the method UpdateNumReferences.
	UpdateNumReferencesFunc *DBStoreUpdateNumReferencesFunc
	// UpdatePackageReferencesFunc is an instance of a mock function object
	// controlling the behavior of the method UpdatePackageReferences.
	UpdatePackageReferencesFunc *DBStoreUpdatePackageReferencesFunc
	// UpdatePackagesFunc is an instance of a mock function object
	// controlling the behavior of the method UpdatePackages.
	UpdatePackagesFunc *DBStoreUpdatePackagesFunc
	// WithFunc is an instance of a mock function object controlling the
	// behavior of the method With.
	WithFunc *DBStoreWithFunc
}

// NewMockDBStore creates a new mock of the DBStore interface. All methods
// return zero values for all results, unless overwritten.
func NewMockDBStore() *MockDBStore {
	return &MockDBStore{
		DeleteOverlappingDumpsFunc: &DBStoreDeleteOverlappingDumpsFunc{
			defaultHook: func(context.Context, int, string, string, string) error {
				return nil
			},
		},
		DoneFunc: &DBStoreDoneFunc{
			defaultHook: func(error) error {
				return nil
			},
		},
		HandleFunc: &DBStoreHandleFunc{
			defaultHook: func() *basestore.TransactableHandle {
				return nil
			},
		},
		InsertDependencySyncingJobFunc: &DBStoreInsertDependencySyncingJobFunc{
			defaultHook: func(context.Context, int) (int, error) {
				return 0, nil
			},
		},
		MarkRepositoryAsDirtyFunc: &DBStoreMarkRepositoryAsDirtyFunc{
			defaultHook: func(context.Context, int) error {
				return nil
			},
		},
		RepoNameFunc: &DBStoreRepoNameFunc{
			defaultHook: func(context.Context, int) (string, error) {
				return "", nil
			},
		},
		TransactFunc: &DBStoreTransactFunc{
			defaultHook: func(context.Context) (DBStore, error) {
				return nil, nil
			},
		},
		UpdateCommitedAtFunc: &DBStoreUpdateCommitedAtFunc{
			defaultHook: func(context.Context, int, time.Time) error {
				return nil
			},
		},
		UpdateDependencyNumReferencesFunc: &DBStoreUpdateDependencyNumReferencesFunc{
			defaultHook: func(context.Context, []int, bool) error {
				return nil
			},
		},
		UpdateNumReferencesFunc: &DBStoreUpdateNumReferencesFunc{
			defaultHook: func(context.Context, []int) error {
				return nil
			},
		},
		UpdatePackageReferencesFunc: &DBStoreUpdatePackageReferencesFunc{
			defaultHook: func(context.Context, int, []precise.PackageReference) error {
				return nil
			},
		},
		UpdatePackagesFunc: &DBStoreUpdatePackagesFunc{
			defaultHook: func(context.Context, int, []precise.Package) error {
				return nil
			},
		},
		WithFunc: &DBStoreWithFunc{
			defaultHook: func(basestore.ShareableStore) DBStore {
				return nil
			},
		},
	}
}

// NewMockDBStoreFrom creates a new mock of the MockDBStore interface. All
// methods delegate to the given implementation, unless overwritten.
func NewMockDBStoreFrom(i DBStore) *MockDBStore {
	return &MockDBStore{
		DeleteOverlappingDumpsFunc: &DBStoreDeleteOverlappingDumpsFunc{
			defaultHook: i.DeleteOverlappingDumps,
		},
		DoneFunc: &DBStoreDoneFunc{
			defaultHook: i.Done,
		},
		HandleFunc: &DBStoreHandleFunc{
			defaultHook: i.Handle,
		},
		InsertDependencySyncingJobFunc: &DBStoreInsertDependencySyncingJobFunc{
			defaultHook: i.InsertDependencySyncingJob,
		},
		MarkRepositoryAsDirtyFunc: &DBStoreMarkRepositoryAsDirtyFunc{
			defaultHook: i.MarkRepositoryAsDirty,
		},
		RepoNameFunc: &DBStoreRepoNameFunc{
			defaultHook: i.RepoName,
		},
		TransactFunc: &DBStoreTransactFunc{
			defaultHook: i.Transact,
		},
		UpdateCommitedAtFunc: &DBStoreUpdateCommitedAtFunc{
			defaultHook: i.UpdateCommitedAt,
		},
		UpdateDependencyNumReferencesFunc: &DBStoreUpdateDependencyNumReferencesFunc{
			defaultHook: i.UpdateDependencyNumReferences,
		},
		UpdateNumReferencesFunc: &DBStoreUpdateNumReferencesFunc{
			defaultHook: i.UpdateNumReferences,
		},
		UpdatePackageReferencesFunc: &DBStoreUpdatePackageReferencesFunc{
			defaultHook: i.UpdatePackageReferences,
		},
		UpdatePackagesFunc: &DBStoreUpdatePackagesFunc{
			defaultHook: i.UpdatePackages,
		},
		WithFunc: &DBStoreWithFunc{
			defaultHook: i.With,
		},
	}
}

// DBStoreDeleteOverlappingDumpsFunc describes the behavior when the
// DeleteOverlappingDumps method of the parent MockDBStore instance is
// invoked.
type DBStoreDeleteOverlappingDumpsFunc struct {
	defaultHook func(context.Context, int, string, string, string) error
	hooks       []func(context.Context, int, string, string, string) error
	history     []DBStoreDeleteOverlappingDumpsFuncCall
	mutex       sync.Mutex
}

// DeleteOverlappingDumps delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) DeleteOverlappingDumps(v0 context.Context, v1 int, v2 string, v3 string, v4 string) error {
	r0 := m.DeleteOverlappingDumpsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.DeleteOverlappingDumpsFunc.appendCall(DBStoreDeleteOverlappingDumpsFuncCall{v0, v1, v2, v3, v4, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// DeleteOverlappingDumps method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreDeleteOverlappingDumpsFunc) SetDefaultHook(hook func(context.Context, int, string, string, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteOverlappingDumps method of the parent MockDBStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreDeleteOverlappingDumpsFunc) PushHook(hook func(context.Context, int, string, string, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreDeleteOverlappingDumpsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, string) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreDeleteOverlappingDumpsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string, string, string) error {
		return r0
	})
}

func (f *DBStoreDeleteOverlappingDumpsFunc) nextHook() func(context.Context, int, string, string, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreDeleteOverlappingDumpsFunc) appendCall(r0 DBStoreDeleteOverlappingDumpsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreDeleteOverlappingDumpsFuncCall
// objects describing the invocations of this function.
func (f *DBStoreDeleteOverlappingDumpsFunc) History() []DBStoreDeleteOverlappingDumpsFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreDeleteOverlappingDumpsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreDeleteOverlappingDumpsFuncCall is an object that describes an
// invocation of method DeleteOverlappingDumps on an instance of
// MockDBStore.
type DBStoreDeleteOverlappingDumpsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreDeleteOverlappingDumpsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreDeleteOverlappingDumpsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreDoneFunc describes the behavior when the Done method of the parent
// MockDBStore instance is invoked.
type DBStoreDoneFunc struct {
	defaultHook func(error) error
	hooks       []func(error) error
	history     []DBStoreDoneFuncCall
	mutex       sync.Mutex
}

// Done delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) Done(v0 error) error {
	r0 := m.DoneFunc.nextHook()(v0)
	m.DoneFunc.appendCall(DBStoreDoneFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Done method of the
// parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreDoneFunc) SetDefaultHook(hook func(error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Done method of the parent MockDBStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *DBStoreDoneFunc) PushHook(hook func(error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreDoneFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(error) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreDoneFunc) PushReturn(r0 error) {
	f.PushHook(func(error) error {
		return r0
	})
}

func (f *DBStoreDoneFunc) nextHook() func(error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreDoneFunc) appendCall(r0 DBStoreDoneFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreDoneFuncCall objects describing the
// invocations of this function.
func (f *DBStoreDoneFunc) History() []DBStoreDoneFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreDoneFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreDoneFuncCall is an object that describes an invocation of method
// Done on an instance of MockDBStore.
type DBStoreDoneFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreDoneFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreDoneFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreHandleFunc describes the behavior when the Handle method of the
// parent MockDBStore instance is invoked.
type DBStoreHandleFunc struct {
	defaultHook func() *basestore.TransactableHandle
	hooks       []func() *basestore.TransactableHandle
	history     []DBStoreHandleFuncCall
	mutex       sync.Mutex
}

// Handle delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) Handle() *basestore.TransactableHandle {
	r0 := m.HandleFunc.nextHook()()
	m.HandleFunc.appendCall(DBStoreHandleFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the Handle method of the
// parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreHandleFunc) SetDefaultHook(hook func() *basestore.TransactableHandle) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Handle method of the parent MockDBStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *DBStoreHandleFunc) PushHook(hook func() *basestore.TransactableHandle) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreHandleFunc) SetDefaultReturn(r0 *basestore.TransactableHandle) {
	f.SetDefaultHook(func() *basestore.TransactableHandle {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreHandleFunc) PushReturn(r0 *basestore.TransactableHandle) {
	f.PushHook(func() *basestore.TransactableHandle {
		return r0
	})
}

func (f *DBStoreHandleFunc) nextHook() func() *basestore.TransactableHandle {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreHandleFunc) appendCall(r0 DBStoreHandleFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreHandleFuncCall objects describing
// the invocations of this function.
func (f *DBStoreHandleFunc) History() []DBStoreHandleFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreHandleFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreHandleFuncCall is an object that describes an invocation of method
// Handle on an instance of MockDBStore.
type DBStoreHandleFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *basestore.TransactableHandle
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreHandleFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreHandleFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreInsertDependencySyncingJobFunc describes the behavior when the
// InsertDependencySyncingJob method of the parent MockDBStore instance is
// invoked.
type DBStoreInsertDependencySyncingJobFunc struct {
	defaultHook func(context.Context, int) (int, error)
	hooks       []func(context.Context, int) (int, error)
	history     []DBStoreInsertDependencySyncingJobFuncCall
	mutex       sync.Mutex
}

// InsertDependencySyncingJob delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockDBStore) InsertDependencySyncingJob(v0 context.Context, v1 int) (int, error) {
	r0, r1 := m.InsertDependencySyncingJobFunc.nextHook()(v0, v1)
	m.InsertDependencySyncingJobFunc.appendCall(DBStoreInsertDependencySyncingJobFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// InsertDependencySyncingJob method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreInsertDependencySyncingJobFunc) SetDefaultHook(hook func(context.Context, int) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertDependencySyncingJob method of the parent MockDBStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *DBStoreInsertDependencySyncingJobFunc) PushHook(hook func(context.Context, int) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreInsertDependencySyncingJobFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreInsertDependencySyncingJobFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int) (int, error) {
		return r0, r1
	})
}

func (f *DBStoreInsertDependencySyncingJobFunc) nextHook() func(context.Context, int) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreInsertDependencySyncingJobFunc) appendCall(r0 DBStoreInsertDependencySyncingJobFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreInsertDependencySyncingJobFuncCall
// objects describing the invocations of this function.
func (f *DBStoreInsertDependencySyncingJobFunc) History() []DBStoreInsertDependencySyncingJobFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreInsertDependencySyncingJobFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreInsertDependencySyncingJobFuncCall is an object that describes an
// invocation of method InsertDependencySyncingJob on an instance of
// MockDBStore.
type DBStoreInsertDependencySyncingJobFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreInsertDependencySyncingJobFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreInsertDependencySyncingJobFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreMarkRepositoryAsDirtyFunc describes the behavior when the
// MarkRepositoryAsDirty method of the parent MockDBStore instance is
// invoked.
type DBStoreMarkRepositoryAsDirtyFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []DBStoreMarkRepositoryAsDirtyFuncCall
	mutex       sync.Mutex
}

// MarkRepositoryAsDirty delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) MarkRepositoryAsDirty(v0 context.Context, v1 int) error {
	r0 := m.MarkRepositoryAsDirtyFunc.nextHook()(v0, v1)
	m.MarkRepositoryAsDirtyFunc.appendCall(DBStoreMarkRepositoryAsDirtyFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// MarkRepositoryAsDirty method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreMarkRepositoryAsDirtyFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkRepositoryAsDirty method of the parent MockDBStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreMarkRepositoryAsDirtyFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreMarkRepositoryAsDirtyFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreMarkRepositoryAsDirtyFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *DBStoreMarkRepositoryAsDirtyFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreMarkRepositoryAsDirtyFunc) appendCall(r0 DBStoreMarkRepositoryAsDirtyFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreMarkRepositoryAsDirtyFuncCall
// objects describing the invocations of this function.
func (f *DBStoreMarkRepositoryAsDirtyFunc) History() []DBStoreMarkRepositoryAsDirtyFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreMarkRepositoryAsDirtyFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreMarkRepositoryAsDirtyFuncCall is an object that describes an
// invocation of method MarkRepositoryAsDirty on an instance of MockDBStore.
type DBStoreMarkRepositoryAsDirtyFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreMarkRepositoryAsDirtyFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreMarkRepositoryAsDirtyFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreRepoNameFunc describes the behavior when the RepoName method of
// the parent MockDBStore instance is invoked.
type DBStoreRepoNameFunc struct {
	defaultHook func(context.Context, int) (string, error)
	hooks       []func(context.Context, int) (string, error)
	history     []DBStoreRepoNameFuncCall
	mutex       sync.Mutex
}

// RepoName delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) RepoName(v0 context.Context, v1 int) (string, error) {
	r0, r1 := m.RepoNameFunc.nextHook()(v0, v1)
	m.RepoNameFunc.appendCall(DBStoreRepoNameFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepoName method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreRepoNameFunc) SetDefaultHook(hook func(context.Context, int) (string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoName method of the parent MockDBStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreRepoNameFunc) PushHook(hook func(context.Context, int) (string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreRepoNameFunc) SetDefaultReturn(r0 string, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreRepoNameFunc) PushReturn(r0 string, r1 error) {
	f.PushHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

func (f *DBStoreRepoNameFunc) nextHook() func(context.Context, int) (string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreRepoNameFunc) appendCall(r0 DBStoreRepoNameFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreRepoNameFuncCall objects describing
// the invocations of this function.
func (f *DBStoreRepoNameFunc) History() []DBStoreRepoNameFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreRepoNameFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreRepoNameFuncCall is an object that describes an invocation of
// method RepoName on an instance of MockDBStore.
type DBStoreRepoNameFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreRepoNameFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreRepoNameFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreTransactFunc describes the behavior when the Transact method of
// the parent MockDBStore instance is invoked.
type DBStoreTransactFunc struct {
	defaultHook func(context.Context) (DBStore, error)
	hooks       []func(context.Context) (DBStore, error)
	history     []DBStoreTransactFuncCall
	mutex       sync.Mutex
}

// Transact delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) Transact(v0 context.Context) (DBStore, error) {
	r0, r1 := m.TransactFunc.nextHook()(v0)
	m.TransactFunc.appendCall(DBStoreTransactFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Transact method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreTransactFunc) SetDefaultHook(hook func(context.Context) (DBStore, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Transact method of the parent MockDBStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreTransactFunc) PushHook(hook func(context.Context) (DBStore, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreTransactFunc) SetDefaultReturn(r0 DBStore, r1 error) {
	f.SetDefaultHook(func(context.Context) (DBStore, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreTransactFunc) PushReturn(r0 DBStore, r1 error) {
	f.PushHook(func(context.Context) (DBStore, error) {
		return r0, r1
	})
}

func (f *DBStoreTransactFunc) nextHook() func(context.Context) (DBStore, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreTransactFunc) appendCall(r0 DBStoreTransactFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreTransactFuncCall objects describing
// the invocations of this function.
func (f *DBStoreTransactFunc) History() []DBStoreTransactFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreTransactFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreTransactFuncCall is an object that describes an invocation of
// method Transact on an instance of MockDBStore.
type DBStoreTransactFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 DBStore
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreTransactFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreTransactFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreUpdateCommitedAtFunc describes the behavior when the
// UpdateCommitedAt method of the parent MockDBStore instance is invoked.
type DBStoreUpdateCommitedAtFunc struct {
	defaultHook func(context.Context, int, time.Time) error
	hooks       []func(context.Context, int, time.Time) error
	history     []DBStoreUpdateCommitedAtFuncCall
	mutex       sync.Mutex
}

// UpdateCommitedAt delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) UpdateCommitedAt(v0 context.Context, v1 int, v2 time.Time) error {
	r0 := m.UpdateCommitedAtFunc.nextHook()(v0, v1, v2)
	m.UpdateCommitedAtFunc.appendCall(DBStoreUpdateCommitedAtFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the UpdateCommitedAt
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreUpdateCommitedAtFunc) SetDefaultHook(hook func(context.Context, int, time.Time) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateCommitedAt method of the parent MockDBStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *DBStoreUpdateCommitedAtFunc) PushHook(hook func(context.Context, int, time.Time) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreUpdateCommitedAtFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreUpdateCommitedAtFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

func (f *DBStoreUpdateCommitedAtFunc) nextHook() func(context.Context, int, time.Time) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreUpdateCommitedAtFunc) appendCall(r0 DBStoreUpdateCommitedAtFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreUpdateCommitedAtFuncCall objects
// describing the invocations of this function.
func (f *DBStoreUpdateCommitedAtFunc) History() []DBStoreUpdateCommitedAtFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreUpdateCommitedAtFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreUpdateCommitedAtFuncCall is an object that describes an invocation
// of method UpdateCommitedAt on an instance of MockDBStore.
type DBStoreUpdateCommitedAtFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreUpdateCommitedAtFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreUpdateCommitedAtFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreUpdateDependencyNumReferencesFunc describes the behavior when the
// UpdateDependencyNumReferences method of the parent MockDBStore instance
// is invoked.
type DBStoreUpdateDependencyNumReferencesFunc struct {
	defaultHook func(context.Context, []int, bool) error
	hooks       []func(context.Context, []int, bool) error
	history     []DBStoreUpdateDependencyNumReferencesFuncCall
	mutex       sync.Mutex
}

// UpdateDependencyNumReferences delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockDBStore) UpdateDependencyNumReferences(v0 context.Context, v1 []int, v2 bool) error {
	r0 := m.UpdateDependencyNumReferencesFunc.nextHook()(v0, v1, v2)
	m.UpdateDependencyNumReferencesFunc.appendCall(DBStoreUpdateDependencyNumReferencesFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdateDependencyNumReferences method of the parent MockDBStore instance
// is invoked and the hook queue is empty.
func (f *DBStoreUpdateDependencyNumReferencesFunc) SetDefaultHook(hook func(context.Context, []int, bool) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateDependencyNumReferences method of the parent MockDBStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *DBStoreUpdateDependencyNumReferencesFunc) PushHook(hook func(context.Context, []int, bool) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreUpdateDependencyNumReferencesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, []int, bool) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreUpdateDependencyNumReferencesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, []int, bool) error {
		return r0
	})
}

func (f *DBStoreUpdateDependencyNumReferencesFunc) nextHook() func(context.Context, []int, bool) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreUpdateDependencyNumReferencesFunc) appendCall(r0 DBStoreUpdateDependencyNumReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// DBStoreUpdateDependencyNumReferencesFuncCall objects describing the
// invocations of this function.
func (f *DBStoreUpdateDependencyNumReferencesFunc) History() []DBStoreUpdateDependencyNumReferencesFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreUpdateDependencyNumReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreUpdateDependencyNumReferencesFuncCall is an object that describes
// an invocation of method UpdateDependencyNumReferences on an instance of
// MockDBStore.
type DBStoreUpdateDependencyNumReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 bool
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreUpdateDependencyNumReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreUpdateDependencyNumReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreUpdateNumReferencesFunc describes the behavior when the
// UpdateNumReferences method of the parent MockDBStore instance is invoked.
type DBStoreUpdateNumReferencesFunc struct {
	defaultHook func(context.Context, []int) error
	hooks       []func(context.Context, []int) error
	history     []DBStoreUpdateNumReferencesFuncCall
	mutex       sync.Mutex
}

// UpdateNumReferences delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) UpdateNumReferences(v0 context.Context, v1 []int) error {
	r0 := m.UpdateNumReferencesFunc.nextHook()(v0, v1)
	m.UpdateNumReferencesFunc.appendCall(DBStoreUpdateNumReferencesFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the UpdateNumReferences
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreUpdateNumReferencesFunc) SetDefaultHook(hook func(context.Context, []int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateNumReferences method of the parent MockDBStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *DBStoreUpdateNumReferencesFunc) PushHook(hook func(context.Context, []int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreUpdateNumReferencesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, []int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreUpdateNumReferencesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, []int) error {
		return r0
	})
}

func (f *DBStoreUpdateNumReferencesFunc) nextHook() func(context.Context, []int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreUpdateNumReferencesFunc) appendCall(r0 DBStoreUpdateNumReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreUpdateNumReferencesFuncCall objects
// describing the invocations of this function.
func (f *DBStoreUpdateNumReferencesFunc) History() []DBStoreUpdateNumReferencesFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreUpdateNumReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreUpdateNumReferencesFuncCall is an object that describes an
// invocation of method UpdateNumReferences on an instance of MockDBStore.
type DBStoreUpdateNumReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreUpdateNumReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreUpdateNumReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreUpdatePackageReferencesFunc describes the behavior when the
// UpdatePackageReferences method of the parent MockDBStore instance is
// invoked.
type DBStoreUpdatePackageReferencesFunc struct {
	defaultHook func(context.Context, int, []precise.PackageReference) error
	hooks       []func(context.Context, int, []precise.PackageReference) error
	history     []DBStoreUpdatePackageReferencesFuncCall
	mutex       sync.Mutex
}

// UpdatePackageReferences delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) UpdatePackageReferences(v0 context.Context, v1 int, v2 []precise.PackageReference) error {
	r0 := m.UpdatePackageReferencesFunc.nextHook()(v0, v1, v2)
	m.UpdatePackageReferencesFunc.appendCall(DBStoreUpdatePackageReferencesFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdatePackageReferences method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreUpdatePackageReferencesFunc) SetDefaultHook(hook func(context.Context, int, []precise.PackageReference) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdatePackageReferences method of the parent MockDBStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *DBStoreUpdatePackageReferencesFunc) PushHook(hook func(context.Context, int, []precise.PackageReference) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreUpdatePackageReferencesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, []precise.PackageReference) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreUpdatePackageReferencesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, []precise.PackageReference) error {
		return r0
	})
}

func (f *DBStoreUpdatePackageReferencesFunc) nextHook() func(context.Context, int, []precise.PackageReference) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreUpdatePackageReferencesFunc) appendCall(r0 DBStoreUpdatePackageReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreUpdatePackageReferencesFuncCall
// objects describing the invocations of this function.
func (f *DBStoreUpdatePackageReferencesFunc) History() []DBStoreUpdatePackageReferencesFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreUpdatePackageReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreUpdatePackageReferencesFuncCall is an object that describes an
// invocation of method UpdatePackageReferences on an instance of
// MockDBStore.
type DBStoreUpdatePackageReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []precise.PackageReference
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreUpdatePackageReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreUpdatePackageReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreUpdatePackagesFunc describes the behavior when the UpdatePackages
// method of the parent MockDBStore instance is invoked.
type DBStoreUpdatePackagesFunc struct {
	defaultHook func(context.Context, int, []precise.Package) error
	hooks       []func(context.Context, int, []precise.Package) error
	history     []DBStoreUpdatePackagesFuncCall
	mutex       sync.Mutex
}

// UpdatePackages delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) UpdatePackages(v0 context.Context, v1 int, v2 []precise.Package) error {
	r0 := m.UpdatePackagesFunc.nextHook()(v0, v1, v2)
	m.UpdatePackagesFunc.appendCall(DBStoreUpdatePackagesFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the UpdatePackages
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreUpdatePackagesFunc) SetDefaultHook(hook func(context.Context, int, []precise.Package) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdatePackages method of the parent MockDBStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreUpdatePackagesFunc) PushHook(hook func(context.Context, int, []precise.Package) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreUpdatePackagesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, []precise.Package) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreUpdatePackagesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, []precise.Package) error {
		return r0
	})
}

func (f *DBStoreUpdatePackagesFunc) nextHook() func(context.Context, int, []precise.Package) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreUpdatePackagesFunc) appendCall(r0 DBStoreUpdatePackagesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreUpdatePackagesFuncCall objects
// describing the invocations of this function.
func (f *DBStoreUpdatePackagesFunc) History() []DBStoreUpdatePackagesFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreUpdatePackagesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreUpdatePackagesFuncCall is an object that describes an invocation
// of method UpdatePackages on an instance of MockDBStore.
type DBStoreUpdatePackagesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []precise.Package
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreUpdatePackagesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreUpdatePackagesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// DBStoreWithFunc describes the behavior when the With method of the parent
// MockDBStore instance is invoked.
type DBStoreWithFunc struct {
	defaultHook func(basestore.ShareableStore) DBStore
	hooks       []func(basestore.ShareableStore) DBStore
	history     []DBStoreWithFuncCall
	mutex       sync.Mutex
}

// With delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) With(v0 basestore.ShareableStore) DBStore {
	r0 := m.WithFunc.nextHook()(v0)
	m.WithFunc.appendCall(DBStoreWithFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the With method of the
// parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreWithFunc) SetDefaultHook(hook func(basestore.ShareableStore) DBStore) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// With method of the parent MockDBStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *DBStoreWithFunc) PushHook(hook func(basestore.ShareableStore) DBStore) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *DBStoreWithFunc) SetDefaultReturn(r0 DBStore) {
	f.SetDefaultHook(func(basestore.ShareableStore) DBStore {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *DBStoreWithFunc) PushReturn(r0 DBStore) {
	f.PushHook(func(basestore.ShareableStore) DBStore {
		return r0
	})
}

func (f *DBStoreWithFunc) nextHook() func(basestore.ShareableStore) DBStore {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreWithFunc) appendCall(r0 DBStoreWithFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreWithFuncCall objects describing the
// invocations of this function.
func (f *DBStoreWithFunc) History() []DBStoreWithFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreWithFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreWithFuncCall is an object that describes an invocation of method
// With on an instance of MockDBStore.
type DBStoreWithFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 basestore.ShareableStore
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 DBStore
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreWithFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreWithFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// MockGitserverClient is a mock implementation of the GitserverClient
// interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/precise-code-intel-worker/internal/worker)
// used for unit testing.
type MockGitserverClient struct {
	// CommitDateFunc is an instance of a mock function object controlling
	// the behavior of the method CommitDate.
	CommitDateFunc *GitserverClientCommitDateFunc
	// DefaultBranchContainsFunc is an instance of a mock function object
	// controlling the behavior of the method DefaultBranchContains.
	DefaultBranchContainsFunc *GitserverClientDefaultBranchContainsFunc
	// DirectoryChildrenFunc is an instance of a mock function object
	// controlling the behavior of the method DirectoryChildren.
	DirectoryChildrenFunc *GitserverClientDirectoryChildrenFunc
	// ResolveRevisionFunc is an instance of a mock function object
	// controlling the behavior of the method ResolveRevision.
	ResolveRevisionFunc *GitserverClientResolveRevisionFunc
}

// NewMockGitserverClient creates a new mock of the GitserverClient
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockGitserverClient() *MockGitserverClient {
	return &MockGitserverClient{
		CommitDateFunc: &GitserverClientCommitDateFunc{
			defaultHook: func(context.Context, int, string) (string, time.Time, bool, error) {
				return "", time.Time{}, false, nil
			},
		},
		DefaultBranchContainsFunc: &GitserverClientDefaultBranchContainsFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				return false, nil
			},
		},
		DirectoryChildrenFunc: &GitserverClientDirectoryChildrenFunc{
			defaultHook: func(context.Context, int, string, []string) (map[string][]string, error) {
				return nil, nil
			},
		},
		ResolveRevisionFunc: &GitserverClientResolveRevisionFunc{
			defaultHook: func(context.Context, int, string) (api.CommitID, error) {
				return "", nil
			},
		},
	}
}

// NewMockGitserverClientFrom creates a new mock of the MockGitserverClient
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockGitserverClientFrom(i GitserverClient) *MockGitserverClient {
	return &MockGitserverClient{
		CommitDateFunc: &GitserverClientCommitDateFunc{
			defaultHook: i.CommitDate,
		},
		DefaultBranchContainsFunc: &GitserverClientDefaultBranchContainsFunc{
			defaultHook: i.DefaultBranchContains,
		},
		DirectoryChildrenFunc: &GitserverClientDirectoryChildrenFunc{
			defaultHook: i.DirectoryChildren,
		},
		ResolveRevisionFunc: &GitserverClientResolveRevisionFunc{
			defaultHook: i.ResolveRevision,
		},
	}
}

// GitserverClientCommitDateFunc describes the behavior when the CommitDate
// method of the parent MockGitserverClient instance is invoked.
type GitserverClientCommitDateFunc struct {
	defaultHook func(context.Context, int, string) (string, time.Time, bool, error)
	hooks       []func(context.Context, int, string) (string, time.Time, bool, error)
	history     []GitserverClientCommitDateFuncCall
	mutex       sync.Mutex
}

// CommitDate delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverClient) CommitDate(v0 context.Context, v1 int, v2 string) (string, time.Time, bool, error) {
	r0, r1, r2, r3 := m.CommitDateFunc.nextHook()(v0, v1, v2)
	m.CommitDateFunc.appendCall(GitserverClientCommitDateFuncCall{v0, v1, v2, r0, r1, r2, r3})
	return r0, r1, r2, r3
}

// SetDefaultHook sets function that is called when the CommitDate method of
// the parent MockGitserverClient instance is invoked and the hook queue is
// empty.
func (f *GitserverClientCommitDateFunc) SetDefaultHook(hook func(context.Context, int, string) (string, time.Time, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitDate method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientCommitDateFunc) PushHook(hook func(context.Context, int, string) (string, time.Time, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *GitserverClientCommitDateFunc) SetDefaultReturn(r0 string, r1 time.Time, r2 bool, r3 error) {
	f.SetDefaultHook(func(context.Context, int, string) (string, time.Time, bool, error) {
		return r0, r1, r2, r3
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *GitserverClientCommitDateFunc) PushReturn(r0 string, r1 time.Time, r2 bool, r3 error) {
	f.PushHook(func(context.Context, int, string) (string, time.Time, bool, error) {
		return r0, r1, r2, r3
	})
}

func (f *GitserverClientCommitDateFunc) nextHook() func(context.Context, int, string) (string, time.Time, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientCommitDateFunc) appendCall(r0 GitserverClientCommitDateFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientCommitDateFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientCommitDateFunc) History() []GitserverClientCommitDateFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientCommitDateFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientCommitDateFuncCall is an object that describes an
// invocation of method CommitDate on an instance of MockGitserverClient.
type GitserverClientCommitDateFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 time.Time
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 bool
	// Result3 is the value of the 4th result returned from this method
	// invocation.
	Result3 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientCommitDateFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientCommitDateFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2, c.Result3}
}

// GitserverClientDefaultBranchContainsFunc describes the behavior when the
// DefaultBranchContains method of the parent MockGitserverClient instance
// is invoked.
type GitserverClientDefaultBranchContainsFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []GitserverClientDefaultBranchContainsFuncCall
	mutex       sync.Mutex
}

// DefaultBranchContains delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockGitserverClient) DefaultBranchContains(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.DefaultBranchContainsFunc.nextHook()(v0, v1, v2)
	m.DefaultBranchContainsFunc.appendCall(GitserverClientDefaultBranchContainsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// DefaultBranchContains method of the parent MockGitserverClient instance
// is invoked and the hook queue is empty.
func (f *GitserverClientDefaultBranchContainsFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DefaultBranchContains method of the parent MockGitserverClient instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *GitserverClientDefaultBranchContainsFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *GitserverClientDefaultBranchContainsFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *GitserverClientDefaultBranchContainsFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *GitserverClientDefaultBranchContainsFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientDefaultBranchContainsFunc) appendCall(r0 GitserverClientDefaultBranchContainsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// GitserverClientDefaultBranchContainsFuncCall objects describing the
// invocations of this function.
func (f *GitserverClientDefaultBranchContainsFunc) History() []GitserverClientDefaultBranchContainsFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientDefaultBranchContainsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientDefaultBranchContainsFuncCall is an object that describes
// an invocation of method DefaultBranchContains on an instance of
// MockGitserverClient.
type GitserverClientDefaultBranchContainsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientDefaultBranchContainsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientDefaultBranchContainsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientDirectoryChildrenFunc describes the behavior when the
// DirectoryChildren method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientDirectoryChildrenFunc struct {
	defaultHook func(context.Context, int, string, []string) (map[string][]string, error)
	hooks       []func(context.Context, int, string, []string) (map[string][]string, error)
	history     []GitserverClientDirectoryChildrenFuncCall
	mutex       sync.Mutex
}

// DirectoryChildren delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockGitserverClient) DirectoryChildren(v0 context.Context, v1 int, v2 string, v3 []string) (map[string][]string, error) {
	r0, r1 := m.DirectoryChildrenFunc.nextHook()(v0, v1, v2, v3)
	m.DirectoryChildrenFunc.appendCall(GitserverClientDirectoryChildrenFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DirectoryChildren
// method of the parent MockGitserverClient instance is invoked and the hook
// queue is empty.
func (f *GitserverClientDirectoryChildrenFunc) SetDefaultHook(hook func(context.Context, int, string, []string) (map[string][]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DirectoryChildren method of the parent MockGitserverClient instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *GitserverClientDirectoryChildrenFunc) PushHook(hook func(context.Context, int, string, []string) (map[string][]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *GitserverClientDirectoryChildrenFunc) SetDefaultReturn(r0 map[string][]string, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, []string) (map[string][]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *GitserverClientDirectoryChildrenFunc) PushReturn(r0 map[string][]string, r1 error) {
	f.PushHook(func(context.Context, int, string, []string) (map[string][]string, error) {
		return r0, r1
	})
}

func (f *GitserverClientDirectoryChildrenFunc) nextHook() func(context.Context, int, string, []string) (map[string][]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientDirectoryChildrenFunc) appendCall(r0 GitserverClientDirectoryChildrenFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientDirectoryChildrenFuncCall
// objects describing the invocations of this function.
func (f *GitserverClientDirectoryChildrenFunc) History() []GitserverClientDirectoryChildrenFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientDirectoryChildrenFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientDirectoryChildrenFuncCall is an object that describes an
// invocation of method DirectoryChildren on an instance of
// MockGitserverClient.
type GitserverClientDirectoryChildrenFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 []string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[string][]string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientDirectoryChildrenFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientDirectoryChildrenFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientResolveRevisionFunc describes the behavior when the
// ResolveRevision method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientResolveRevisionFunc struct {
	defaultHook func(context.Context, int, string) (api.CommitID, error)
	hooks       []func(context.Context, int, string) (api.CommitID, error)
	history     []GitserverClientResolveRevisionFuncCall
	mutex       sync.Mutex
}

// ResolveRevision delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockGitserverClient) ResolveRevision(v0 context.Context, v1 int, v2 string) (api.CommitID, error) {
	r0, r1 := m.ResolveRevisionFunc.nextHook()(v0, v1, v2)
	m.ResolveRevisionFunc.appendCall(GitserverClientResolveRevisionFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ResolveRevision
// method of the parent MockGitserverClient instance is invoked and the hook
// queue is empty.
func (f *GitserverClientResolveRevisionFunc) SetDefaultHook(hook func(context.Context, int, string) (api.CommitID, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ResolveRevision method of the parent MockGitserverClient instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitserverClientResolveRevisionFunc) PushHook(hook func(context.Context, int, string) (api.CommitID, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *GitserverClientResolveRevisionFunc) SetDefaultReturn(r0 api.CommitID, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (api.CommitID, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *GitserverClientResolveRevisionFunc) PushReturn(r0 api.CommitID, r1 error) {
	f.PushHook(func(context.Context, int, string) (api.CommitID, error) {
		return r0, r1
	})
}

func (f *GitserverClientResolveRevisionFunc) nextHook() func(context.Context, int, string) (api.CommitID, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientResolveRevisionFunc) appendCall(r0 GitserverClientResolveRevisionFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientResolveRevisionFuncCall
// objects describing the invocations of this function.
func (f *GitserverClientResolveRevisionFunc) History() []GitserverClientResolveRevisionFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientResolveRevisionFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientResolveRevisionFuncCall is an object that describes an
// invocation of method ResolveRevision on an instance of
// MockGitserverClient.
type GitserverClientResolveRevisionFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 api.CommitID
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientResolveRevisionFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientResolveRevisionFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockLSIFStore is a mock implementation of the LSIFStore interface (from
// the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/precise-code-intel-worker/internal/worker)
// used for unit testing.
type MockLSIFStore struct {
	// DoneFunc is an instance of a mock function object controlling the
	// behavior of the method Done.
	DoneFunc *LSIFStoreDoneFunc
	// TransactFunc is an instance of a mock function object controlling the
	// behavior of the method Transact.
	TransactFunc *LSIFStoreTransactFunc
	// WriteDefinitionsFunc is an instance of a mock function object
	// controlling the behavior of the method WriteDefinitions.
	WriteDefinitionsFunc *LSIFStoreWriteDefinitionsFunc
	// WriteDocumentationMappingsFunc is an instance of a mock function
	// object controlling the behavior of the method
	// WriteDocumentationMappings.
	WriteDocumentationMappingsFunc *LSIFStoreWriteDocumentationMappingsFunc
	// WriteDocumentationPagesFunc is an instance of a mock function object
	// controlling the behavior of the method WriteDocumentationPages.
	WriteDocumentationPagesFunc *LSIFStoreWriteDocumentationPagesFunc
	// WriteDocumentationPathInfoFunc is an instance of a mock function
	// object controlling the behavior of the method
	// WriteDocumentationPathInfo.
	WriteDocumentationPathInfoFunc *LSIFStoreWriteDocumentationPathInfoFunc
	// WriteDocumentationSearchPreworkFunc is an instance of a mock function
	// object controlling the behavior of the method
	// WriteDocumentationSearchPrework.
	WriteDocumentationSearchPreworkFunc *LSIFStoreWriteDocumentationSearchPreworkFunc
	// WriteDocumentsFunc is an instance of a mock function object
	// controlling the behavior of the method WriteDocuments.
	WriteDocumentsFunc *LSIFStoreWriteDocumentsFunc
	// WriteMetaFunc is an instance of a mock function object controlling
	// the behavior of the method WriteMeta.
	WriteMetaFunc *LSIFStoreWriteMetaFunc
	// WriteReferencesFunc is an instance of a mock function object
	// controlling the behavior of the method WriteReferences.
	WriteReferencesFunc *LSIFStoreWriteReferencesFunc
	// WriteResultChunksFunc is an instance of a mock function object
	// controlling the behavior of the method WriteResultChunks.
	WriteResultChunksFunc *LSIFStoreWriteResultChunksFunc
}

// NewMockLSIFStore creates a new mock of the LSIFStore interface. All
// methods return zero values for all results, unless overwritten.
func NewMockLSIFStore() *MockLSIFStore {
	return &MockLSIFStore{
		DoneFunc: &LSIFStoreDoneFunc{
			defaultHook: func(error) error {
				return nil
			},
		},
		TransactFunc: &LSIFStoreTransactFunc{
			defaultHook: func(context.Context) (LSIFStore, error) {
				return nil, nil
			},
		},
		WriteDefinitionsFunc: &LSIFStoreWriteDefinitionsFunc{
			defaultHook: func(context.Context, int, chan precise.MonikerLocations) error {
				return nil
			},
		},
		WriteDocumentationMappingsFunc: &LSIFStoreWriteDocumentationMappingsFunc{
			defaultHook: func(context.Context, int, chan precise.DocumentationMapping) error {
				return nil
			},
		},
		WriteDocumentationPagesFunc: &LSIFStoreWriteDocumentationPagesFunc{
			defaultHook: func(context.Context, dbstore.Upload, *types.Repo, bool, chan *precise.DocumentationPageData, int, int) error {
				return nil
			},
		},
		WriteDocumentationPathInfoFunc: &LSIFStoreWriteDocumentationPathInfoFunc{
			defaultHook: func(context.Context, int, chan *precise.DocumentationPathInfoData) error {
				return nil
			},
		},
		WriteDocumentationSearchPreworkFunc: &LSIFStoreWriteDocumentationSearchPreworkFunc{
			defaultHook: func(context.Context, dbstore.Upload, *types.Repo, bool) (int, int, error) {
				return 0, 0, nil
			},
		},
		WriteDocumentsFunc: &LSIFStoreWriteDocumentsFunc{
			defaultHook: func(context.Context, int, chan precise.KeyedDocumentData) error {
				return nil
			},
		},
		WriteMetaFunc: &LSIFStoreWriteMetaFunc{
			defaultHook: func(context.Context, int, precise.MetaData) error {
				return nil
			},
		},
		WriteReferencesFunc: &LSIFStoreWriteReferencesFunc{
			defaultHook: func(context.Context, int, chan precise.MonikerLocations) error {
				return nil
			},
		},
		WriteResultChunksFunc: &LSIFStoreWriteResultChunksFunc{
			defaultHook: func(context.Context, int, chan precise.IndexedResultChunkData) error {
				return nil
			},
		},
	}
}

// NewMockLSIFStoreFrom creates a new mock of the MockLSIFStore interface.
// All methods delegate to the given implementation, unless overwritten.
func NewMockLSIFStoreFrom(i LSIFStore) *MockLSIFStore {
	return &MockLSIFStore{
		DoneFunc: &LSIFStoreDoneFunc{
			defaultHook: i.Done,
		},
		TransactFunc: &LSIFStoreTransactFunc{
			defaultHook: i.Transact,
		},
		WriteDefinitionsFunc: &LSIFStoreWriteDefinitionsFunc{
			defaultHook: i.WriteDefinitions,
		},
		WriteDocumentationMappingsFunc: &LSIFStoreWriteDocumentationMappingsFunc{
			defaultHook: i.WriteDocumentationMappings,
		},
		WriteDocumentationPagesFunc: &LSIFStoreWriteDocumentationPagesFunc{
			defaultHook: i.WriteDocumentationPages,
		},
		WriteDocumentationPathInfoFunc: &LSIFStoreWriteDocumentationPathInfoFunc{
			defaultHook: i.WriteDocumentationPathInfo,
		},
		WriteDocumentationSearchPreworkFunc: &LSIFStoreWriteDocumentationSearchPreworkFunc{
			defaultHook: i.WriteDocumentationSearchPrework,
		},
		WriteDocumentsFunc: &LSIFStoreWriteDocumentsFunc{
			defaultHook: i.WriteDocuments,
		},
		WriteMetaFunc: &LSIFStoreWriteMetaFunc{
			defaultHook: i.WriteMeta,
		},
		WriteReferencesFunc: &LSIFStoreWriteReferencesFunc{
			defaultHook: i.WriteReferences,
		},
		WriteResultChunksFunc: &LSIFStoreWriteResultChunksFunc{
			defaultHook: i.WriteResultChunks,
		},
	}
}

// LSIFStoreDoneFunc describes the behavior when the Done method of the
// parent MockLSIFStore instance is invoked.
type LSIFStoreDoneFunc struct {
	defaultHook func(error) error
	hooks       []func(error) error
	history     []LSIFStoreDoneFuncCall
	mutex       sync.Mutex
}

// Done delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) Done(v0 error) error {
	r0 := m.DoneFunc.nextHook()(v0)
	m.DoneFunc.appendCall(LSIFStoreDoneFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Done method of the
// parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreDoneFunc) SetDefaultHook(hook func(error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Done method of the parent MockLSIFStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *LSIFStoreDoneFunc) PushHook(hook func(error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreDoneFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(error) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreDoneFunc) PushReturn(r0 error) {
	f.PushHook(func(error) error {
		return r0
	})
}

func (f *LSIFStoreDoneFunc) nextHook() func(error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreDoneFunc) appendCall(r0 LSIFStoreDoneFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreDoneFuncCall objects describing
// the invocations of this function.
func (f *LSIFStoreDoneFunc) History() []LSIFStoreDoneFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreDoneFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreDoneFuncCall is an object that describes an invocation of method
// Done on an instance of MockLSIFStore.
type LSIFStoreDoneFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreDoneFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreDoneFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreTransactFunc describes the behavior when the Transact method of
// the parent MockLSIFStore instance is invoked.
type LSIFStoreTransactFunc struct {
	defaultHook func(context.Context) (LSIFStore, error)
	hooks       []func(context.Context) (LSIFStore, error)
	history     []LSIFStoreTransactFuncCall
	mutex       sync.Mutex
}

// Transact delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) Transact(v0 context.Context) (LSIFStore, error) {
	r0, r1 := m.TransactFunc.nextHook()(v0)
	m.TransactFunc.appendCall(LSIFStoreTransactFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Transact method of
// the parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreTransactFunc) SetDefaultHook(hook func(context.Context) (LSIFStore, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Transact method of the parent MockLSIFStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreTransactFunc) PushHook(hook func(context.Context) (LSIFStore, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreTransactFunc) SetDefaultReturn(r0 LSIFStore, r1 error) {
	f.SetDefaultHook(func(context.Context) (LSIFStore, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreTransactFunc) PushReturn(r0 LSIFStore, r1 error) {
	f.PushHook(func(context.Context) (LSIFStore, error) {
		return r0, r1
	})
}

func (f *LSIFStoreTransactFunc) nextHook() func(context.Context) (LSIFStore, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreTransactFunc) appendCall(r0 LSIFStoreTransactFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreTransactFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreTransactFunc) History() []LSIFStoreTransactFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreTransactFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreTransactFuncCall is an object that describes an invocation of
// method Transact on an instance of MockLSIFStore.
type LSIFStoreTransactFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 LSIFStore
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreTransactFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreTransactFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// LSIFStoreWriteDefinitionsFunc describes the behavior when the
// WriteDefinitions method of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteDefinitionsFunc struct {
	defaultHook func(context.Context, int, chan precise.MonikerLocations) error
	hooks       []func(context.Context, int, chan precise.MonikerLocations) error
	history     []LSIFStoreWriteDefinitionsFuncCall
	mutex       sync.Mutex
}

// WriteDefinitions delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteDefinitions(v0 context.Context, v1 int, v2 chan precise.MonikerLocations) error {
	r0 := m.WriteDefinitionsFunc.nextHook()(v0, v1, v2)
	m.WriteDefinitionsFunc.appendCall(LSIFStoreWriteDefinitionsFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteDefinitions
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreWriteDefinitionsFunc) SetDefaultHook(hook func(context.Context, int, chan precise.MonikerLocations) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteDefinitions method of the parent MockLSIFStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreWriteDefinitionsFunc) PushHook(hook func(context.Context, int, chan precise.MonikerLocations) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteDefinitionsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan precise.MonikerLocations) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteDefinitionsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan precise.MonikerLocations) error {
		return r0
	})
}

func (f *LSIFStoreWriteDefinitionsFunc) nextHook() func(context.Context, int, chan precise.MonikerLocations) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteDefinitionsFunc) appendCall(r0 LSIFStoreWriteDefinitionsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteDefinitionsFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteDefinitionsFunc) History() []LSIFStoreWriteDefinitionsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteDefinitionsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteDefinitionsFuncCall is an object that describes an
// invocation of method WriteDefinitions on an instance of MockLSIFStore.
type LSIFStoreWriteDefinitionsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan precise.MonikerLocations
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteDefinitionsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteDefinitionsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreWriteDocumentationMappingsFunc describes the behavior when the
// WriteDocumentationMappings method of the parent MockLSIFStore instance is
// invoked.
type LSIFStoreWriteDocumentationMappingsFunc struct {
	defaultHook func(context.Context, int, chan precise.DocumentationMapping) error
	hooks       []func(context.Context, int, chan precise.DocumentationMapping) error
	history     []LSIFStoreWriteDocumentationMappingsFuncCall
	mutex       sync.Mutex
}

// WriteDocumentationMappings delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteDocumentationMappings(v0 context.Context, v1 int, v2 chan precise.DocumentationMapping) error {
	r0 := m.WriteDocumentationMappingsFunc.nextHook()(v0, v1, v2)
	m.WriteDocumentationMappingsFunc.appendCall(LSIFStoreWriteDocumentationMappingsFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// WriteDocumentationMappings method of the parent MockLSIFStore instance is
// invoked and the hook queue is empty.
func (f *LSIFStoreWriteDocumentationMappingsFunc) SetDefaultHook(hook func(context.Context, int, chan precise.DocumentationMapping) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteDocumentationMappings method of the parent MockLSIFStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *LSIFStoreWriteDocumentationMappingsFunc) PushHook(hook func(context.Context, int, chan precise.DocumentationMapping) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteDocumentationMappingsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan precise.DocumentationMapping) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteDocumentationMappingsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan precise.DocumentationMapping) error {
		return r0
	})
}

func (f *LSIFStoreWriteDocumentationMappingsFunc) nextHook() func(context.Context, int, chan precise.DocumentationMapping) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteDocumentationMappingsFunc) appendCall(r0 LSIFStoreWriteDocumentationMappingsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteDocumentationMappingsFuncCall
// objects describing the invocations of this function.
func (f *LSIFStoreWriteDocumentationMappingsFunc) History() []LSIFStoreWriteDocumentationMappingsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteDocumentationMappingsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteDocumentationMappingsFuncCall is an object that describes
// an invocation of method WriteDocumentationMappings on an instance of
// MockLSIFStore.
type LSIFStoreWriteDocumentationMappingsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan precise.DocumentationMapping
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteDocumentationMappingsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteDocumentationMappingsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreWriteDocumentationPagesFunc describes the behavior when the
// WriteDocumentationPages method of the parent MockLSIFStore instance is
// invoked.
type LSIFStoreWriteDocumentationPagesFunc struct {
	defaultHook func(context.Context, dbstore.Upload, *types.Repo, bool, chan *precise.DocumentationPageData, int, int) error
	hooks       []func(context.Context, dbstore.Upload, *types.Repo, bool, chan *precise.DocumentationPageData, int, int) error
	history     []LSIFStoreWriteDocumentationPagesFuncCall
	mutex       sync.Mutex
}

// WriteDocumentationPages delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteDocumentationPages(v0 context.Context, v1 dbstore.Upload, v2 *types.Repo, v3 bool, v4 chan *precise.DocumentationPageData, v5 int, v6 int) error {
	r0 := m.WriteDocumentationPagesFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6)
	m.WriteDocumentationPagesFunc.appendCall(LSIFStoreWriteDocumentationPagesFuncCall{v0, v1, v2, v3, v4, v5, v6, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// WriteDocumentationPages method of the parent MockLSIFStore instance is
// invoked and the hook queue is empty.
func (f *LSIFStoreWriteDocumentationPagesFunc) SetDefaultHook(hook func(context.Context, dbstore.Upload, *types.Repo, bool, chan *precise.DocumentationPageData, int, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteDocumentationPages method of the parent MockLSIFStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *LSIFStoreWriteDocumentationPagesFunc) PushHook(hook func(context.Context, dbstore.Upload, *types.Repo, bool, chan *precise.DocumentationPageData, int, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteDocumentationPagesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, dbstore.Upload, *types.Repo, bool, chan *precise.DocumentationPageData, int, int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteDocumentationPagesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, dbstore.Upload, *types.Repo, bool, chan *precise.DocumentationPageData, int, int) error {
		return r0
	})
}

func (f *LSIFStoreWriteDocumentationPagesFunc) nextHook() func(context.Context, dbstore.Upload, *types.Repo, bool, chan *precise.DocumentationPageData, int, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteDocumentationPagesFunc) appendCall(r0 LSIFStoreWriteDocumentationPagesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteDocumentationPagesFuncCall
// objects describing the invocations of this function.
func (f *LSIFStoreWriteDocumentationPagesFunc) History() []LSIFStoreWriteDocumentationPagesFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteDocumentationPagesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteDocumentationPagesFuncCall is an object that describes an
// invocation of method WriteDocumentationPages on an instance of
// MockLSIFStore.
type LSIFStoreWriteDocumentationPagesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 dbstore.Upload
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 *types.Repo
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 bool
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 chan *precise.DocumentationPageData
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 int
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteDocumentationPagesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteDocumentationPagesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreWriteDocumentationPathInfoFunc describes the behavior when the
// WriteDocumentationPathInfo method of the parent MockLSIFStore instance is
// invoked.
type LSIFStoreWriteDocumentationPathInfoFunc struct {
	defaultHook func(context.Context, int, chan *precise.DocumentationPathInfoData) error
	hooks       []func(context.Context, int, chan *precise.DocumentationPathInfoData) error
	history     []LSIFStoreWriteDocumentationPathInfoFuncCall
	mutex       sync.Mutex
}

// WriteDocumentationPathInfo delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteDocumentationPathInfo(v0 context.Context, v1 int, v2 chan *precise.DocumentationPathInfoData) error {
	r0 := m.WriteDocumentationPathInfoFunc.nextHook()(v0, v1, v2)
	m.WriteDocumentationPathInfoFunc.appendCall(LSIFStoreWriteDocumentationPathInfoFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// WriteDocumentationPathInfo method of the parent MockLSIFStore instance is
// invoked and the hook queue is empty.
func (f *LSIFStoreWriteDocumentationPathInfoFunc) SetDefaultHook(hook func(context.Context, int, chan *precise.DocumentationPathInfoData) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteDocumentationPathInfo method of the parent MockLSIFStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *LSIFStoreWriteDocumentationPathInfoFunc) PushHook(hook func(context.Context, int, chan *precise.DocumentationPathInfoData) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteDocumentationPathInfoFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan *precise.DocumentationPathInfoData) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteDocumentationPathInfoFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan *precise.DocumentationPathInfoData) error {
		return r0
	})
}

func (f *LSIFStoreWriteDocumentationPathInfoFunc) nextHook() func(context.Context, int, chan *precise.DocumentationPathInfoData) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteDocumentationPathInfoFunc) appendCall(r0 LSIFStoreWriteDocumentationPathInfoFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteDocumentationPathInfoFuncCall
// objects describing the invocations of this function.
func (f *LSIFStoreWriteDocumentationPathInfoFunc) History() []LSIFStoreWriteDocumentationPathInfoFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteDocumentationPathInfoFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteDocumentationPathInfoFuncCall is an object that describes
// an invocation of method WriteDocumentationPathInfo on an instance of
// MockLSIFStore.
type LSIFStoreWriteDocumentationPathInfoFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan *precise.DocumentationPathInfoData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteDocumentationPathInfoFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteDocumentationPathInfoFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreWriteDocumentationSearchPreworkFunc describes the behavior when
// the WriteDocumentationSearchPrework method of the parent MockLSIFStore
// instance is invoked.
type LSIFStoreWriteDocumentationSearchPreworkFunc struct {
	defaultHook func(context.Context, dbstore.Upload, *types.Repo, bool) (int, int, error)
	hooks       []func(context.Context, dbstore.Upload, *types.Repo, bool) (int, int, error)
	history     []LSIFStoreWriteDocumentationSearchPreworkFuncCall
	mutex       sync.Mutex
}

// WriteDocumentationSearchPrework delegates to the next hook function in
// the queue and stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteDocumentationSearchPrework(v0 context.Context, v1 dbstore.Upload, v2 *types.Repo, v3 bool) (int, int, error) {
	r0, r1, r2 := m.WriteDocumentationSearchPreworkFunc.nextHook()(v0, v1, v2, v3)
	m.WriteDocumentationSearchPreworkFunc.appendCall(LSIFStoreWriteDocumentationSearchPreworkFuncCall{v0, v1, v2, v3, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// WriteDocumentationSearchPrework method of the parent MockLSIFStore
// instance is invoked and the hook queue is empty.
func (f *LSIFStoreWriteDocumentationSearchPreworkFunc) SetDefaultHook(hook func(context.Context, dbstore.Upload, *types.Repo, bool) (int, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteDocumentationSearchPrework method of the parent MockLSIFStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *LSIFStoreWriteDocumentationSearchPreworkFunc) PushHook(hook func(context.Context, dbstore.Upload, *types.Repo, bool) (int, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteDocumentationSearchPreworkFunc) SetDefaultReturn(r0 int, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, dbstore.Upload, *types.Repo, bool) (int, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteDocumentationSearchPreworkFunc) PushReturn(r0 int, r1 int, r2 error) {
	f.PushHook(func(context.Context, dbstore.Upload, *types.Repo, bool) (int, int, error) {
		return r0, r1, r2
	})
}

func (f *LSIFStoreWriteDocumentationSearchPreworkFunc) nextHook() func(context.Context, dbstore.Upload, *types.Repo, bool) (int, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteDocumentationSearchPreworkFunc) appendCall(r0 LSIFStoreWriteDocumentationSearchPreworkFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// LSIFStoreWriteDocumentationSearchPreworkFuncCall objects describing the
// invocations of this function.
func (f *LSIFStoreWriteDocumentationSearchPreworkFunc) History() []LSIFStoreWriteDocumentationSearchPreworkFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteDocumentationSearchPreworkFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteDocumentationSearchPreworkFuncCall is an object that
// describes an invocation of method WriteDocumentationSearchPrework on an
// instance of MockLSIFStore.
type LSIFStoreWriteDocumentationSearchPreworkFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 dbstore.Upload
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 *types.Repo
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 bool
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteDocumentationSearchPreworkFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteDocumentationSearchPreworkFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// LSIFStoreWriteDocumentsFunc describes the behavior when the
// WriteDocuments method of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteDocumentsFunc struct {
	defaultHook func(context.Context, int, chan precise.KeyedDocumentData) error
	hooks       []func(context.Context, int, chan precise.KeyedDocumentData) error
	history     []LSIFStoreWriteDocumentsFuncCall
	mutex       sync.Mutex
}

// WriteDocuments delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteDocuments(v0 context.Context, v1 int, v2 chan precise.KeyedDocumentData) error {
	r0 := m.WriteDocumentsFunc.nextHook()(v0, v1, v2)
	m.WriteDocumentsFunc.appendCall(LSIFStoreWriteDocumentsFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteDocuments
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreWriteDocumentsFunc) SetDefaultHook(hook func(context.Context, int, chan precise.KeyedDocumentData) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteDocuments method of the parent MockLSIFStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreWriteDocumentsFunc) PushHook(hook func(context.Context, int, chan precise.KeyedDocumentData) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteDocumentsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan precise.KeyedDocumentData) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteDocumentsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan precise.KeyedDocumentData) error {
		return r0
	})
}

func (f *LSIFStoreWriteDocumentsFunc) nextHook() func(context.Context, int, chan precise.KeyedDocumentData) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteDocumentsFunc) appendCall(r0 LSIFStoreWriteDocumentsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteDocumentsFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteDocumentsFunc) History() []LSIFStoreWriteDocumentsFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteDocumentsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteDocumentsFuncCall is an object that describes an invocation
// of method WriteDocuments on an instance of MockLSIFStore.
type LSIFStoreWriteDocumentsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan precise.KeyedDocumentData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteDocumentsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteDocumentsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreWriteMetaFunc describes the behavior when the WriteMeta method
// of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteMetaFunc struct {
	defaultHook func(context.Context, int, precise.MetaData) error
	hooks       []func(context.Context, int, precise.MetaData) error
	history     []LSIFStoreWriteMetaFuncCall
	mutex       sync.Mutex
}

// WriteMeta delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockLSIFStore) WriteMeta(v0 context.Context, v1 int, v2 precise.MetaData) error {
	r0 := m.WriteMetaFunc.nextHook()(v0, v1, v2)
	m.WriteMetaFunc.appendCall(LSIFStoreWriteMetaFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteMeta method of
// the parent MockLSIFStore instance is invoked and the hook queue is empty.
func (f *LSIFStoreWriteMetaFunc) SetDefaultHook(hook func(context.Context, int, precise.MetaData) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteMeta method of the parent MockLSIFStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *LSIFStoreWriteMetaFunc) PushHook(hook func(context.Context, int, precise.MetaData) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteMetaFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, precise.MetaData) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteMetaFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, precise.MetaData) error {
		return r0
	})
}

func (f *LSIFStoreWriteMetaFunc) nextHook() func(context.Context, int, precise.MetaData) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteMetaFunc) appendCall(r0 LSIFStoreWriteMetaFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteMetaFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteMetaFunc) History() []LSIFStoreWriteMetaFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteMetaFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteMetaFuncCall is an object that describes an invocation of
// method WriteMeta on an instance of MockLSIFStore.
type LSIFStoreWriteMetaFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 precise.MetaData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteMetaFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteMetaFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreWriteReferencesFunc describes the behavior when the
// WriteReferences method of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteReferencesFunc struct {
	defaultHook func(context.Context, int, chan precise.MonikerLocations) error
	hooks       []func(context.Context, int, chan precise.MonikerLocations) error
	history     []LSIFStoreWriteReferencesFuncCall
	mutex       sync.Mutex
}

// WriteReferences delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteReferences(v0 context.Context, v1 int, v2 chan precise.MonikerLocations) error {
	r0 := m.WriteReferencesFunc.nextHook()(v0, v1, v2)
	m.WriteReferencesFunc.appendCall(LSIFStoreWriteReferencesFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteReferences
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreWriteReferencesFunc) SetDefaultHook(hook func(context.Context, int, chan precise.MonikerLocations) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteReferences method of the parent MockLSIFStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreWriteReferencesFunc) PushHook(hook func(context.Context, int, chan precise.MonikerLocations) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteReferencesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan precise.MonikerLocations) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteReferencesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan precise.MonikerLocations) error {
		return r0
	})
}

func (f *LSIFStoreWriteReferencesFunc) nextHook() func(context.Context, int, chan precise.MonikerLocations) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteReferencesFunc) appendCall(r0 LSIFStoreWriteReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteReferencesFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteReferencesFunc) History() []LSIFStoreWriteReferencesFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteReferencesFuncCall is an object that describes an
// invocation of method WriteReferences on an instance of MockLSIFStore.
type LSIFStoreWriteReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan precise.MonikerLocations
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// LSIFStoreWriteResultChunksFunc describes the behavior when the
// WriteResultChunks method of the parent MockLSIFStore instance is invoked.
type LSIFStoreWriteResultChunksFunc struct {
	defaultHook func(context.Context, int, chan precise.IndexedResultChunkData) error
	hooks       []func(context.Context, int, chan precise.IndexedResultChunkData) error
	history     []LSIFStoreWriteResultChunksFuncCall
	mutex       sync.Mutex
}

// WriteResultChunks delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockLSIFStore) WriteResultChunks(v0 context.Context, v1 int, v2 chan precise.IndexedResultChunkData) error {
	r0 := m.WriteResultChunksFunc.nextHook()(v0, v1, v2)
	m.WriteResultChunksFunc.appendCall(LSIFStoreWriteResultChunksFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteResultChunks
// method of the parent MockLSIFStore instance is invoked and the hook queue
// is empty.
func (f *LSIFStoreWriteResultChunksFunc) SetDefaultHook(hook func(context.Context, int, chan precise.IndexedResultChunkData) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteResultChunks method of the parent MockLSIFStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *LSIFStoreWriteResultChunksFunc) PushHook(hook func(context.Context, int, chan precise.IndexedResultChunkData) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *LSIFStoreWriteResultChunksFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan precise.IndexedResultChunkData) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *LSIFStoreWriteResultChunksFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan precise.IndexedResultChunkData) error {
		return r0
	})
}

func (f *LSIFStoreWriteResultChunksFunc) nextHook() func(context.Context, int, chan precise.IndexedResultChunkData) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *LSIFStoreWriteResultChunksFunc) appendCall(r0 LSIFStoreWriteResultChunksFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of LSIFStoreWriteResultChunksFuncCall objects
// describing the invocations of this function.
func (f *LSIFStoreWriteResultChunksFunc) History() []LSIFStoreWriteResultChunksFuncCall {
	f.mutex.Lock()
	history := make([]LSIFStoreWriteResultChunksFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// LSIFStoreWriteResultChunksFuncCall is an object that describes an
// invocation of method WriteResultChunks on an instance of MockLSIFStore.
type LSIFStoreWriteResultChunksFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan precise.IndexedResultChunkData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c LSIFStoreWriteResultChunksFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c LSIFStoreWriteResultChunksFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}
