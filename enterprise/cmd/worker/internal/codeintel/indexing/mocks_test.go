// Code generated by go-mockgen 1.3.4; DO NOT EDIT.
//
// This file was generated by running `sg generate` (or `go-mockgen`) at the root of
// this repository. To add additional mocks to this or another package, add a new entry
// to the mockgen.yaml file in the root of this repository.

package indexing

import (
	"context"
	"sync"
	"time"

	regexp "github.com/grafana/regexp"
	sqlf "github.com/keegancsmith/sqlf"
	api "github.com/sourcegraph/sourcegraph/internal/api"
	shared "github.com/sourcegraph/sourcegraph/internal/codeintel/autoindexing/shared"
	enterprise "github.com/sourcegraph/sourcegraph/internal/codeintel/policies/enterprise"
	dbstore "github.com/sourcegraph/sourcegraph/internal/codeintel/stores/dbstore"
	shared1 "github.com/sourcegraph/sourcegraph/internal/codeintel/stores/shared"
	database "github.com/sourcegraph/sourcegraph/internal/database"
	basestore "github.com/sourcegraph/sourcegraph/internal/database/basestore"
	protocol "github.com/sourcegraph/sourcegraph/internal/repoupdater/protocol"
	types "github.com/sourcegraph/sourcegraph/internal/types"
	workerutil "github.com/sourcegraph/sourcegraph/internal/workerutil"
	store "github.com/sourcegraph/sourcegraph/internal/workerutil/dbworker/store"
	precise "github.com/sourcegraph/sourcegraph/lib/codeintel/precise"
	schema "github.com/sourcegraph/sourcegraph/schema"
)

// MockDBStore is a mock implementation of the DBStore interface (from the
// package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/worker/internal/codeintel/indexing)
// used for unit testing.
type MockDBStore struct {
	// GetConfigurationPoliciesFunc is an instance of a mock function object
	// controlling the behavior of the method GetConfigurationPolicies.
	GetConfigurationPoliciesFunc *DBStoreGetConfigurationPoliciesFunc
	// GetUploadByIDFunc is an instance of a mock function object
	// controlling the behavior of the method GetUploadByID.
	GetUploadByIDFunc *DBStoreGetUploadByIDFunc
	// GetUploadsFunc is an instance of a mock function object controlling
	// the behavior of the method GetUploads.
	GetUploadsFunc *DBStoreGetUploadsFunc
	// InsertCloneableDependencyRepoFunc is an instance of a mock function
	// object controlling the behavior of the method
	// InsertCloneableDependencyRepo.
	InsertCloneableDependencyRepoFunc *DBStoreInsertCloneableDependencyRepoFunc
	// InsertDependencyIndexingJobFunc is an instance of a mock function
	// object controlling the behavior of the method
	// InsertDependencyIndexingJob.
	InsertDependencyIndexingJobFunc *DBStoreInsertDependencyIndexingJobFunc
	// ReferencesForUploadFunc is an instance of a mock function object
	// controlling the behavior of the method ReferencesForUpload.
	ReferencesForUploadFunc *DBStoreReferencesForUploadFunc
	// SelectRepositoriesForIndexScanFunc is an instance of a mock function
	// object controlling the behavior of the method
	// SelectRepositoriesForIndexScan.
	SelectRepositoriesForIndexScanFunc *DBStoreSelectRepositoriesForIndexScanFunc
	// WithFunc is an instance of a mock function object controlling the
	// behavior of the method With.
	WithFunc *DBStoreWithFunc
}

// NewMockDBStore creates a new mock of the DBStore interface. All methods
// return zero values for all results, unless overwritten.
func NewMockDBStore() *MockDBStore {
	return &MockDBStore{
		GetConfigurationPoliciesFunc: &DBStoreGetConfigurationPoliciesFunc{
			defaultHook: func(context.Context, dbstore.GetConfigurationPoliciesOptions) (r0 []dbstore.ConfigurationPolicy, r1 int, r2 error) {
				return
			},
		},
		GetUploadByIDFunc: &DBStoreGetUploadByIDFunc{
			defaultHook: func(context.Context, int) (r0 dbstore.Upload, r1 bool, r2 error) {
				return
			},
		},
		GetUploadsFunc: &DBStoreGetUploadsFunc{
			defaultHook: func(context.Context, dbstore.GetUploadsOptions) (r0 []dbstore.Upload, r1 int, r2 error) {
				return
			},
		},
		InsertCloneableDependencyRepoFunc: &DBStoreInsertCloneableDependencyRepoFunc{
			defaultHook: func(context.Context, precise.Package) (r0 bool, r1 error) {
				return
			},
		},
		InsertDependencyIndexingJobFunc: &DBStoreInsertDependencyIndexingJobFunc{
			defaultHook: func(context.Context, int, string, time.Time) (r0 int, r1 error) {
				return
			},
		},
		ReferencesForUploadFunc: &DBStoreReferencesForUploadFunc{
			defaultHook: func(context.Context, int) (r0 dbstore.PackageReferenceScanner, r1 error) {
				return
			},
		},
		SelectRepositoriesForIndexScanFunc: &DBStoreSelectRepositoriesForIndexScanFunc{
			defaultHook: func(context.Context, string, string, time.Duration, bool, *int, int) (r0 []int, r1 error) {
				return
			},
		},
		WithFunc: &DBStoreWithFunc{
			defaultHook: func(basestore.ShareableStore) (r0 DBStore) {
				return
			},
		},
	}
}

// NewStrictMockDBStore creates a new mock of the DBStore interface. All
// methods panic on invocation, unless overwritten.
func NewStrictMockDBStore() *MockDBStore {
	return &MockDBStore{
		GetConfigurationPoliciesFunc: &DBStoreGetConfigurationPoliciesFunc{
			defaultHook: func(context.Context, dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error) {
				panic("unexpected invocation of MockDBStore.GetConfigurationPolicies")
			},
		},
		GetUploadByIDFunc: &DBStoreGetUploadByIDFunc{
			defaultHook: func(context.Context, int) (dbstore.Upload, bool, error) {
				panic("unexpected invocation of MockDBStore.GetUploadByID")
			},
		},
		GetUploadsFunc: &DBStoreGetUploadsFunc{
			defaultHook: func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error) {
				panic("unexpected invocation of MockDBStore.GetUploads")
			},
		},
		InsertCloneableDependencyRepoFunc: &DBStoreInsertCloneableDependencyRepoFunc{
			defaultHook: func(context.Context, precise.Package) (bool, error) {
				panic("unexpected invocation of MockDBStore.InsertCloneableDependencyRepo")
			},
		},
		InsertDependencyIndexingJobFunc: &DBStoreInsertDependencyIndexingJobFunc{
			defaultHook: func(context.Context, int, string, time.Time) (int, error) {
				panic("unexpected invocation of MockDBStore.InsertDependencyIndexingJob")
			},
		},
		ReferencesForUploadFunc: &DBStoreReferencesForUploadFunc{
			defaultHook: func(context.Context, int) (dbstore.PackageReferenceScanner, error) {
				panic("unexpected invocation of MockDBStore.ReferencesForUpload")
			},
		},
		SelectRepositoriesForIndexScanFunc: &DBStoreSelectRepositoriesForIndexScanFunc{
			defaultHook: func(context.Context, string, string, time.Duration, bool, *int, int) ([]int, error) {
				panic("unexpected invocation of MockDBStore.SelectRepositoriesForIndexScan")
			},
		},
		WithFunc: &DBStoreWithFunc{
			defaultHook: func(basestore.ShareableStore) DBStore {
				panic("unexpected invocation of MockDBStore.With")
			},
		},
	}
}

// NewMockDBStoreFrom creates a new mock of the MockDBStore interface. All
// methods delegate to the given implementation, unless overwritten.
func NewMockDBStoreFrom(i DBStore) *MockDBStore {
	return &MockDBStore{
		GetConfigurationPoliciesFunc: &DBStoreGetConfigurationPoliciesFunc{
			defaultHook: i.GetConfigurationPolicies,
		},
		GetUploadByIDFunc: &DBStoreGetUploadByIDFunc{
			defaultHook: i.GetUploadByID,
		},
		GetUploadsFunc: &DBStoreGetUploadsFunc{
			defaultHook: i.GetUploads,
		},
		InsertCloneableDependencyRepoFunc: &DBStoreInsertCloneableDependencyRepoFunc{
			defaultHook: i.InsertCloneableDependencyRepo,
		},
		InsertDependencyIndexingJobFunc: &DBStoreInsertDependencyIndexingJobFunc{
			defaultHook: i.InsertDependencyIndexingJob,
		},
		ReferencesForUploadFunc: &DBStoreReferencesForUploadFunc{
			defaultHook: i.ReferencesForUpload,
		},
		SelectRepositoriesForIndexScanFunc: &DBStoreSelectRepositoriesForIndexScanFunc{
			defaultHook: i.SelectRepositoriesForIndexScan,
		},
		WithFunc: &DBStoreWithFunc{
			defaultHook: i.With,
		},
	}
}

// DBStoreGetConfigurationPoliciesFunc describes the behavior when the
// GetConfigurationPolicies method of the parent MockDBStore instance is
// invoked.
type DBStoreGetConfigurationPoliciesFunc struct {
	defaultHook func(context.Context, dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error)
	hooks       []func(context.Context, dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error)
	history     []DBStoreGetConfigurationPoliciesFuncCall
	mutex       sync.Mutex
}

// GetConfigurationPolicies delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDBStore) GetConfigurationPolicies(v0 context.Context, v1 dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error) {
	r0, r1, r2 := m.GetConfigurationPoliciesFunc.nextHook()(v0, v1)
	m.GetConfigurationPoliciesFunc.appendCall(DBStoreGetConfigurationPoliciesFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// GetConfigurationPolicies method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreGetConfigurationPoliciesFunc) SetDefaultHook(hook func(context.Context, dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetConfigurationPolicies method of the parent MockDBStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *DBStoreGetConfigurationPoliciesFunc) PushHook(hook func(context.Context, dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreGetConfigurationPoliciesFunc) SetDefaultReturn(r0 []dbstore.ConfigurationPolicy, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreGetConfigurationPoliciesFunc) PushReturn(r0 []dbstore.ConfigurationPolicy, r1 int, r2 error) {
	f.PushHook(func(context.Context, dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreGetConfigurationPoliciesFunc) nextHook() func(context.Context, dbstore.GetConfigurationPoliciesOptions) ([]dbstore.ConfigurationPolicy, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetConfigurationPoliciesFunc) appendCall(r0 DBStoreGetConfigurationPoliciesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetConfigurationPoliciesFuncCall
// objects describing the invocations of this function.
func (f *DBStoreGetConfigurationPoliciesFunc) History() []DBStoreGetConfigurationPoliciesFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetConfigurationPoliciesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetConfigurationPoliciesFuncCall is an object that describes an
// invocation of method GetConfigurationPolicies on an instance of
// MockDBStore.
type DBStoreGetConfigurationPoliciesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 dbstore.GetConfigurationPoliciesOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.ConfigurationPolicy
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetConfigurationPoliciesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetConfigurationPoliciesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreGetUploadByIDFunc describes the behavior when the GetUploadByID
// method of the parent MockDBStore instance is invoked.
type DBStoreGetUploadByIDFunc struct {
	defaultHook func(context.Context, int) (dbstore.Upload, bool, error)
	hooks       []func(context.Context, int) (dbstore.Upload, bool, error)
	history     []DBStoreGetUploadByIDFuncCall
	mutex       sync.Mutex
}

// GetUploadByID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) GetUploadByID(v0 context.Context, v1 int) (dbstore.Upload, bool, error) {
	r0, r1, r2 := m.GetUploadByIDFunc.nextHook()(v0, v1)
	m.GetUploadByIDFunc.appendCall(DBStoreGetUploadByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetUploadByID method
// of the parent MockDBStore instance is invoked and the hook queue is
// empty.
func (f *DBStoreGetUploadByIDFunc) SetDefaultHook(hook func(context.Context, int) (dbstore.Upload, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadByID method of the parent MockDBStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreGetUploadByIDFunc) PushHook(hook func(context.Context, int) (dbstore.Upload, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreGetUploadByIDFunc) SetDefaultReturn(r0 dbstore.Upload, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (dbstore.Upload, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreGetUploadByIDFunc) PushReturn(r0 dbstore.Upload, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (dbstore.Upload, bool, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreGetUploadByIDFunc) nextHook() func(context.Context, int) (dbstore.Upload, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetUploadByIDFunc) appendCall(r0 DBStoreGetUploadByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetUploadByIDFuncCall objects
// describing the invocations of this function.
func (f *DBStoreGetUploadByIDFunc) History() []DBStoreGetUploadByIDFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetUploadByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetUploadByIDFuncCall is an object that describes an invocation of
// method GetUploadByID on an instance of MockDBStore.
type DBStoreGetUploadByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 dbstore.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetUploadByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetUploadByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreGetUploadsFunc describes the behavior when the GetUploads method
// of the parent MockDBStore instance is invoked.
type DBStoreGetUploadsFunc struct {
	defaultHook func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error)
	hooks       []func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error)
	history     []DBStoreGetUploadsFuncCall
	mutex       sync.Mutex
}

// GetUploads delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockDBStore) GetUploads(v0 context.Context, v1 dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error) {
	r0, r1, r2 := m.GetUploadsFunc.nextHook()(v0, v1)
	m.GetUploadsFunc.appendCall(DBStoreGetUploadsFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetUploads method of
// the parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreGetUploadsFunc) SetDefaultHook(hook func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploads method of the parent MockDBStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *DBStoreGetUploadsFunc) PushHook(hook func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreGetUploadsFunc) SetDefaultReturn(r0 []dbstore.Upload, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreGetUploadsFunc) PushReturn(r0 []dbstore.Upload, r1 int, r2 error) {
	f.PushHook(func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error) {
		return r0, r1, r2
	})
}

func (f *DBStoreGetUploadsFunc) nextHook() func(context.Context, dbstore.GetUploadsOptions) ([]dbstore.Upload, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreGetUploadsFunc) appendCall(r0 DBStoreGetUploadsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreGetUploadsFuncCall objects
// describing the invocations of this function.
func (f *DBStoreGetUploadsFunc) History() []DBStoreGetUploadsFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreGetUploadsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreGetUploadsFuncCall is an object that describes an invocation of
// method GetUploads on an instance of MockDBStore.
type DBStoreGetUploadsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 dbstore.GetUploadsOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []dbstore.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreGetUploadsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreGetUploadsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DBStoreInsertCloneableDependencyRepoFunc describes the behavior when the
// InsertCloneableDependencyRepo method of the parent MockDBStore instance
// is invoked.
type DBStoreInsertCloneableDependencyRepoFunc struct {
	defaultHook func(context.Context, precise.Package) (bool, error)
	hooks       []func(context.Context, precise.Package) (bool, error)
	history     []DBStoreInsertCloneableDependencyRepoFuncCall
	mutex       sync.Mutex
}

// InsertCloneableDependencyRepo delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockDBStore) InsertCloneableDependencyRepo(v0 context.Context, v1 precise.Package) (bool, error) {
	r0, r1 := m.InsertCloneableDependencyRepoFunc.nextHook()(v0, v1)
	m.InsertCloneableDependencyRepoFunc.appendCall(DBStoreInsertCloneableDependencyRepoFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// InsertCloneableDependencyRepo method of the parent MockDBStore instance
// is invoked and the hook queue is empty.
func (f *DBStoreInsertCloneableDependencyRepoFunc) SetDefaultHook(hook func(context.Context, precise.Package) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertCloneableDependencyRepo method of the parent MockDBStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *DBStoreInsertCloneableDependencyRepoFunc) PushHook(hook func(context.Context, precise.Package) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreInsertCloneableDependencyRepoFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, precise.Package) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreInsertCloneableDependencyRepoFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, precise.Package) (bool, error) {
		return r0, r1
	})
}

func (f *DBStoreInsertCloneableDependencyRepoFunc) nextHook() func(context.Context, precise.Package) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreInsertCloneableDependencyRepoFunc) appendCall(r0 DBStoreInsertCloneableDependencyRepoFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// DBStoreInsertCloneableDependencyRepoFuncCall objects describing the
// invocations of this function.
func (f *DBStoreInsertCloneableDependencyRepoFunc) History() []DBStoreInsertCloneableDependencyRepoFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreInsertCloneableDependencyRepoFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreInsertCloneableDependencyRepoFuncCall is an object that describes
// an invocation of method InsertCloneableDependencyRepo on an instance of
// MockDBStore.
type DBStoreInsertCloneableDependencyRepoFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 precise.Package
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreInsertCloneableDependencyRepoFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreInsertCloneableDependencyRepoFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreInsertDependencyIndexingJobFunc describes the behavior when the
// InsertDependencyIndexingJob method of the parent MockDBStore instance is
// invoked.
type DBStoreInsertDependencyIndexingJobFunc struct {
	defaultHook func(context.Context, int, string, time.Time) (int, error)
	hooks       []func(context.Context, int, string, time.Time) (int, error)
	history     []DBStoreInsertDependencyIndexingJobFuncCall
	mutex       sync.Mutex
}

// InsertDependencyIndexingJob delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockDBStore) InsertDependencyIndexingJob(v0 context.Context, v1 int, v2 string, v3 time.Time) (int, error) {
	r0, r1 := m.InsertDependencyIndexingJobFunc.nextHook()(v0, v1, v2, v3)
	m.InsertDependencyIndexingJobFunc.appendCall(DBStoreInsertDependencyIndexingJobFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// InsertDependencyIndexingJob method of the parent MockDBStore instance is
// invoked and the hook queue is empty.
func (f *DBStoreInsertDependencyIndexingJobFunc) SetDefaultHook(hook func(context.Context, int, string, time.Time) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertDependencyIndexingJob method of the parent MockDBStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *DBStoreInsertDependencyIndexingJobFunc) PushHook(hook func(context.Context, int, string, time.Time) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreInsertDependencyIndexingJobFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, time.Time) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreInsertDependencyIndexingJobFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int, string, time.Time) (int, error) {
		return r0, r1
	})
}

func (f *DBStoreInsertDependencyIndexingJobFunc) nextHook() func(context.Context, int, string, time.Time) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreInsertDependencyIndexingJobFunc) appendCall(r0 DBStoreInsertDependencyIndexingJobFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreInsertDependencyIndexingJobFuncCall
// objects describing the invocations of this function.
func (f *DBStoreInsertDependencyIndexingJobFunc) History() []DBStoreInsertDependencyIndexingJobFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreInsertDependencyIndexingJobFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreInsertDependencyIndexingJobFuncCall is an object that describes an
// invocation of method InsertDependencyIndexingJob on an instance of
// MockDBStore.
type DBStoreInsertDependencyIndexingJobFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreInsertDependencyIndexingJobFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreInsertDependencyIndexingJobFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreReferencesForUploadFunc describes the behavior when the
// ReferencesForUpload method of the parent MockDBStore instance is invoked.
type DBStoreReferencesForUploadFunc struct {
	defaultHook func(context.Context, int) (dbstore.PackageReferenceScanner, error)
	hooks       []func(context.Context, int) (dbstore.PackageReferenceScanner, error)
	history     []DBStoreReferencesForUploadFuncCall
	mutex       sync.Mutex
}

// ReferencesForUpload delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockDBStore) ReferencesForUpload(v0 context.Context, v1 int) (dbstore.PackageReferenceScanner, error) {
	r0, r1 := m.ReferencesForUploadFunc.nextHook()(v0, v1)
	m.ReferencesForUploadFunc.appendCall(DBStoreReferencesForUploadFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ReferencesForUpload
// method of the parent MockDBStore instance is invoked and the hook queue
// is empty.
func (f *DBStoreReferencesForUploadFunc) SetDefaultHook(hook func(context.Context, int) (dbstore.PackageReferenceScanner, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReferencesForUpload method of the parent MockDBStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *DBStoreReferencesForUploadFunc) PushHook(hook func(context.Context, int) (dbstore.PackageReferenceScanner, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreReferencesForUploadFunc) SetDefaultReturn(r0 dbstore.PackageReferenceScanner, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (dbstore.PackageReferenceScanner, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreReferencesForUploadFunc) PushReturn(r0 dbstore.PackageReferenceScanner, r1 error) {
	f.PushHook(func(context.Context, int) (dbstore.PackageReferenceScanner, error) {
		return r0, r1
	})
}

func (f *DBStoreReferencesForUploadFunc) nextHook() func(context.Context, int) (dbstore.PackageReferenceScanner, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreReferencesForUploadFunc) appendCall(r0 DBStoreReferencesForUploadFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreReferencesForUploadFuncCall objects
// describing the invocations of this function.
func (f *DBStoreReferencesForUploadFunc) History() []DBStoreReferencesForUploadFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreReferencesForUploadFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreReferencesForUploadFuncCall is an object that describes an
// invocation of method ReferencesForUpload on an instance of MockDBStore.
type DBStoreReferencesForUploadFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 dbstore.PackageReferenceScanner
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreReferencesForUploadFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreReferencesForUploadFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreSelectRepositoriesForIndexScanFunc describes the behavior when the
// SelectRepositoriesForIndexScan method of the parent MockDBStore instance
// is invoked.
type DBStoreSelectRepositoriesForIndexScanFunc struct {
	defaultHook func(context.Context, string, string, time.Duration, bool, *int, int) ([]int, error)
	hooks       []func(context.Context, string, string, time.Duration, bool, *int, int) ([]int, error)
	history     []DBStoreSelectRepositoriesForIndexScanFuncCall
	mutex       sync.Mutex
}

// SelectRepositoriesForIndexScan delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockDBStore) SelectRepositoriesForIndexScan(v0 context.Context, v1 string, v2 string, v3 time.Duration, v4 bool, v5 *int, v6 int) ([]int, error) {
	r0, r1 := m.SelectRepositoriesForIndexScanFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6)
	m.SelectRepositoriesForIndexScanFunc.appendCall(DBStoreSelectRepositoriesForIndexScanFuncCall{v0, v1, v2, v3, v4, v5, v6, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// SelectRepositoriesForIndexScan method of the parent MockDBStore instance
// is invoked and the hook queue is empty.
func (f *DBStoreSelectRepositoriesForIndexScanFunc) SetDefaultHook(hook func(context.Context, string, string, time.Duration, bool, *int, int) ([]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SelectRepositoriesForIndexScan method of the parent MockDBStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *DBStoreSelectRepositoriesForIndexScanFunc) PushHook(hook func(context.Context, string, string, time.Duration, bool, *int, int) ([]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreSelectRepositoriesForIndexScanFunc) SetDefaultReturn(r0 []int, r1 error) {
	f.SetDefaultHook(func(context.Context, string, string, time.Duration, bool, *int, int) ([]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreSelectRepositoriesForIndexScanFunc) PushReturn(r0 []int, r1 error) {
	f.PushHook(func(context.Context, string, string, time.Duration, bool, *int, int) ([]int, error) {
		return r0, r1
	})
}

func (f *DBStoreSelectRepositoriesForIndexScanFunc) nextHook() func(context.Context, string, string, time.Duration, bool, *int, int) ([]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreSelectRepositoriesForIndexScanFunc) appendCall(r0 DBStoreSelectRepositoriesForIndexScanFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// DBStoreSelectRepositoriesForIndexScanFuncCall objects describing the
// invocations of this function.
func (f *DBStoreSelectRepositoriesForIndexScanFunc) History() []DBStoreSelectRepositoriesForIndexScanFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreSelectRepositoriesForIndexScanFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreSelectRepositoriesForIndexScanFuncCall is an object that describes
// an invocation of method SelectRepositoriesForIndexScan on an instance of
// MockDBStore.
type DBStoreSelectRepositoriesForIndexScanFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 time.Duration
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 bool
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 *int
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreSelectRepositoriesForIndexScanFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreSelectRepositoriesForIndexScanFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// DBStoreWithFunc describes the behavior when the With method of the parent
// MockDBStore instance is invoked.
type DBStoreWithFunc struct {
	defaultHook func(basestore.ShareableStore) DBStore
	hooks       []func(basestore.ShareableStore) DBStore
	history     []DBStoreWithFuncCall
	mutex       sync.Mutex
}

// With delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockDBStore) With(v0 basestore.ShareableStore) DBStore {
	r0 := m.WithFunc.nextHook()(v0)
	m.WithFunc.appendCall(DBStoreWithFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the With method of the
// parent MockDBStore instance is invoked and the hook queue is empty.
func (f *DBStoreWithFunc) SetDefaultHook(hook func(basestore.ShareableStore) DBStore) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// With method of the parent MockDBStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *DBStoreWithFunc) PushHook(hook func(basestore.ShareableStore) DBStore) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DBStoreWithFunc) SetDefaultReturn(r0 DBStore) {
	f.SetDefaultHook(func(basestore.ShareableStore) DBStore {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DBStoreWithFunc) PushReturn(r0 DBStore) {
	f.PushHook(func(basestore.ShareableStore) DBStore {
		return r0
	})
}

func (f *DBStoreWithFunc) nextHook() func(basestore.ShareableStore) DBStore {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DBStoreWithFunc) appendCall(r0 DBStoreWithFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of DBStoreWithFuncCall objects describing the
// invocations of this function.
func (f *DBStoreWithFunc) History() []DBStoreWithFuncCall {
	f.mutex.Lock()
	history := make([]DBStoreWithFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DBStoreWithFuncCall is an object that describes an invocation of method
// With on an instance of MockDBStore.
type DBStoreWithFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 basestore.ShareableStore
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 DBStore
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DBStoreWithFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DBStoreWithFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// MockExternalServiceStore is a mock implementation of the
// ExternalServiceStore interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/worker/internal/codeintel/indexing)
// used for unit testing.
type MockExternalServiceStore struct {
	// ListFunc is an instance of a mock function object controlling the
	// behavior of the method List.
	ListFunc *ExternalServiceStoreListFunc
	// UpsertFunc is an instance of a mock function object controlling the
	// behavior of the method Upsert.
	UpsertFunc *ExternalServiceStoreUpsertFunc
}

// NewMockExternalServiceStore creates a new mock of the
// ExternalServiceStore interface. All methods return zero values for all
// results, unless overwritten.
func NewMockExternalServiceStore() *MockExternalServiceStore {
	return &MockExternalServiceStore{
		ListFunc: &ExternalServiceStoreListFunc{
			defaultHook: func(context.Context, database.ExternalServicesListOptions) (r0 []*types.ExternalService, r1 error) {
				return
			},
		},
		UpsertFunc: &ExternalServiceStoreUpsertFunc{
			defaultHook: func(context.Context, ...*types.ExternalService) (r0 error) {
				return
			},
		},
	}
}

// NewStrictMockExternalServiceStore creates a new mock of the
// ExternalServiceStore interface. All methods panic on invocation, unless
// overwritten.
func NewStrictMockExternalServiceStore() *MockExternalServiceStore {
	return &MockExternalServiceStore{
		ListFunc: &ExternalServiceStoreListFunc{
			defaultHook: func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error) {
				panic("unexpected invocation of MockExternalServiceStore.List")
			},
		},
		UpsertFunc: &ExternalServiceStoreUpsertFunc{
			defaultHook: func(context.Context, ...*types.ExternalService) error {
				panic("unexpected invocation of MockExternalServiceStore.Upsert")
			},
		},
	}
}

// NewMockExternalServiceStoreFrom creates a new mock of the
// MockExternalServiceStore interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockExternalServiceStoreFrom(i ExternalServiceStore) *MockExternalServiceStore {
	return &MockExternalServiceStore{
		ListFunc: &ExternalServiceStoreListFunc{
			defaultHook: i.List,
		},
		UpsertFunc: &ExternalServiceStoreUpsertFunc{
			defaultHook: i.Upsert,
		},
	}
}

// ExternalServiceStoreListFunc describes the behavior when the List method
// of the parent MockExternalServiceStore instance is invoked.
type ExternalServiceStoreListFunc struct {
	defaultHook func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error)
	hooks       []func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error)
	history     []ExternalServiceStoreListFuncCall
	mutex       sync.Mutex
}

// List delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockExternalServiceStore) List(v0 context.Context, v1 database.ExternalServicesListOptions) ([]*types.ExternalService, error) {
	r0, r1 := m.ListFunc.nextHook()(v0, v1)
	m.ListFunc.appendCall(ExternalServiceStoreListFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the List method of the
// parent MockExternalServiceStore instance is invoked and the hook queue is
// empty.
func (f *ExternalServiceStoreListFunc) SetDefaultHook(hook func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// List method of the parent MockExternalServiceStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ExternalServiceStoreListFunc) PushHook(hook func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ExternalServiceStoreListFunc) SetDefaultReturn(r0 []*types.ExternalService, r1 error) {
	f.SetDefaultHook(func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ExternalServiceStoreListFunc) PushReturn(r0 []*types.ExternalService, r1 error) {
	f.PushHook(func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error) {
		return r0, r1
	})
}

func (f *ExternalServiceStoreListFunc) nextHook() func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ExternalServiceStoreListFunc) appendCall(r0 ExternalServiceStoreListFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ExternalServiceStoreListFuncCall objects
// describing the invocations of this function.
func (f *ExternalServiceStoreListFunc) History() []ExternalServiceStoreListFuncCall {
	f.mutex.Lock()
	history := make([]ExternalServiceStoreListFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ExternalServiceStoreListFuncCall is an object that describes an
// invocation of method List on an instance of MockExternalServiceStore.
type ExternalServiceStoreListFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 database.ExternalServicesListOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []*types.ExternalService
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ExternalServiceStoreListFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ExternalServiceStoreListFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// ExternalServiceStoreUpsertFunc describes the behavior when the Upsert
// method of the parent MockExternalServiceStore instance is invoked.
type ExternalServiceStoreUpsertFunc struct {
	defaultHook func(context.Context, ...*types.ExternalService) error
	hooks       []func(context.Context, ...*types.ExternalService) error
	history     []ExternalServiceStoreUpsertFuncCall
	mutex       sync.Mutex
}

// Upsert delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockExternalServiceStore) Upsert(v0 context.Context, v1 ...*types.ExternalService) error {
	r0 := m.UpsertFunc.nextHook()(v0, v1...)
	m.UpsertFunc.appendCall(ExternalServiceStoreUpsertFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Upsert method of the
// parent MockExternalServiceStore instance is invoked and the hook queue is
// empty.
func (f *ExternalServiceStoreUpsertFunc) SetDefaultHook(hook func(context.Context, ...*types.ExternalService) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Upsert method of the parent MockExternalServiceStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ExternalServiceStoreUpsertFunc) PushHook(hook func(context.Context, ...*types.ExternalService) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ExternalServiceStoreUpsertFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, ...*types.ExternalService) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ExternalServiceStoreUpsertFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, ...*types.ExternalService) error {
		return r0
	})
}

func (f *ExternalServiceStoreUpsertFunc) nextHook() func(context.Context, ...*types.ExternalService) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ExternalServiceStoreUpsertFunc) appendCall(r0 ExternalServiceStoreUpsertFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ExternalServiceStoreUpsertFuncCall objects
// describing the invocations of this function.
func (f *ExternalServiceStoreUpsertFunc) History() []ExternalServiceStoreUpsertFuncCall {
	f.mutex.Lock()
	history := make([]ExternalServiceStoreUpsertFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ExternalServiceStoreUpsertFuncCall is an object that describes an
// invocation of method Upsert on an instance of MockExternalServiceStore.
type ExternalServiceStoreUpsertFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []*types.ExternalService
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c ExternalServiceStoreUpsertFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ExternalServiceStoreUpsertFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// MockGitserverClient is a mock implementation of the GitserverClient
// interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/worker/internal/codeintel/indexing)
// used for unit testing.
type MockGitserverClient struct {
	// FileExistsFunc is an instance of a mock function object controlling
	// the behavior of the method FileExists.
	FileExistsFunc *GitserverClientFileExistsFunc
	// HeadFunc is an instance of a mock function object controlling the
	// behavior of the method Head.
	HeadFunc *GitserverClientHeadFunc
	// ListFilesFunc is an instance of a mock function object controlling
	// the behavior of the method ListFiles.
	ListFilesFunc *GitserverClientListFilesFunc
	// RawContentsFunc is an instance of a mock function object controlling
	// the behavior of the method RawContents.
	RawContentsFunc *GitserverClientRawContentsFunc
	// ResolveRevisionFunc is an instance of a mock function object
	// controlling the behavior of the method ResolveRevision.
	ResolveRevisionFunc *GitserverClientResolveRevisionFunc
}

// NewMockGitserverClient creates a new mock of the GitserverClient
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockGitserverClient() *MockGitserverClient {
	return &MockGitserverClient{
		FileExistsFunc: &GitserverClientFileExistsFunc{
			defaultHook: func(context.Context, int, string, string) (r0 bool, r1 error) {
				return
			},
		},
		HeadFunc: &GitserverClientHeadFunc{
			defaultHook: func(context.Context, int) (r0 string, r1 bool, r2 error) {
				return
			},
		},
		ListFilesFunc: &GitserverClientListFilesFunc{
			defaultHook: func(context.Context, int, string, *regexp.Regexp) (r0 []string, r1 error) {
				return
			},
		},
		RawContentsFunc: &GitserverClientRawContentsFunc{
			defaultHook: func(context.Context, int, string, string) (r0 []byte, r1 error) {
				return
			},
		},
		ResolveRevisionFunc: &GitserverClientResolveRevisionFunc{
			defaultHook: func(context.Context, int, string) (r0 api.CommitID, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockGitserverClient creates a new mock of the GitserverClient
// interface. All methods panic on invocation, unless overwritten.
func NewStrictMockGitserverClient() *MockGitserverClient {
	return &MockGitserverClient{
		FileExistsFunc: &GitserverClientFileExistsFunc{
			defaultHook: func(context.Context, int, string, string) (bool, error) {
				panic("unexpected invocation of MockGitserverClient.FileExists")
			},
		},
		HeadFunc: &GitserverClientHeadFunc{
			defaultHook: func(context.Context, int) (string, bool, error) {
				panic("unexpected invocation of MockGitserverClient.Head")
			},
		},
		ListFilesFunc: &GitserverClientListFilesFunc{
			defaultHook: func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
				panic("unexpected invocation of MockGitserverClient.ListFiles")
			},
		},
		RawContentsFunc: &GitserverClientRawContentsFunc{
			defaultHook: func(context.Context, int, string, string) ([]byte, error) {
				panic("unexpected invocation of MockGitserverClient.RawContents")
			},
		},
		ResolveRevisionFunc: &GitserverClientResolveRevisionFunc{
			defaultHook: func(context.Context, int, string) (api.CommitID, error) {
				panic("unexpected invocation of MockGitserverClient.ResolveRevision")
			},
		},
	}
}

// NewMockGitserverClientFrom creates a new mock of the MockGitserverClient
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockGitserverClientFrom(i GitserverClient) *MockGitserverClient {
	return &MockGitserverClient{
		FileExistsFunc: &GitserverClientFileExistsFunc{
			defaultHook: i.FileExists,
		},
		HeadFunc: &GitserverClientHeadFunc{
			defaultHook: i.Head,
		},
		ListFilesFunc: &GitserverClientListFilesFunc{
			defaultHook: i.ListFiles,
		},
		RawContentsFunc: &GitserverClientRawContentsFunc{
			defaultHook: i.RawContents,
		},
		ResolveRevisionFunc: &GitserverClientResolveRevisionFunc{
			defaultHook: i.ResolveRevision,
		},
	}
}

// GitserverClientFileExistsFunc describes the behavior when the FileExists
// method of the parent MockGitserverClient instance is invoked.
type GitserverClientFileExistsFunc struct {
	defaultHook func(context.Context, int, string, string) (bool, error)
	hooks       []func(context.Context, int, string, string) (bool, error)
	history     []GitserverClientFileExistsFuncCall
	mutex       sync.Mutex
}

// FileExists delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverClient) FileExists(v0 context.Context, v1 int, v2 string, v3 string) (bool, error) {
	r0, r1 := m.FileExistsFunc.nextHook()(v0, v1, v2, v3)
	m.FileExistsFunc.appendCall(GitserverClientFileExistsFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the FileExists method of
// the parent MockGitserverClient instance is invoked and the hook queue is
// empty.
func (f *GitserverClientFileExistsFunc) SetDefaultHook(hook func(context.Context, int, string, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// FileExists method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientFileExistsFunc) PushHook(hook func(context.Context, int, string, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientFileExistsFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientFileExistsFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string, string) (bool, error) {
		return r0, r1
	})
}

func (f *GitserverClientFileExistsFunc) nextHook() func(context.Context, int, string, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientFileExistsFunc) appendCall(r0 GitserverClientFileExistsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientFileExistsFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientFileExistsFunc) History() []GitserverClientFileExistsFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientFileExistsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientFileExistsFuncCall is an object that describes an
// invocation of method FileExists on an instance of MockGitserverClient.
type GitserverClientFileExistsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientFileExistsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientFileExistsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientHeadFunc describes the behavior when the Head method of
// the parent MockGitserverClient instance is invoked.
type GitserverClientHeadFunc struct {
	defaultHook func(context.Context, int) (string, bool, error)
	hooks       []func(context.Context, int) (string, bool, error)
	history     []GitserverClientHeadFuncCall
	mutex       sync.Mutex
}

// Head delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockGitserverClient) Head(v0 context.Context, v1 int) (string, bool, error) {
	r0, r1, r2 := m.HeadFunc.nextHook()(v0, v1)
	m.HeadFunc.appendCall(GitserverClientHeadFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Head method of the
// parent MockGitserverClient instance is invoked and the hook queue is
// empty.
func (f *GitserverClientHeadFunc) SetDefaultHook(hook func(context.Context, int) (string, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Head method of the parent MockGitserverClient instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *GitserverClientHeadFunc) PushHook(hook func(context.Context, int) (string, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientHeadFunc) SetDefaultReturn(r0 string, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (string, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientHeadFunc) PushReturn(r0 string, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (string, bool, error) {
		return r0, r1, r2
	})
}

func (f *GitserverClientHeadFunc) nextHook() func(context.Context, int) (string, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientHeadFunc) appendCall(r0 GitserverClientHeadFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientHeadFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientHeadFunc) History() []GitserverClientHeadFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientHeadFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientHeadFuncCall is an object that describes an invocation of
// method Head on an instance of MockGitserverClient.
type GitserverClientHeadFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientHeadFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientHeadFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// GitserverClientListFilesFunc describes the behavior when the ListFiles
// method of the parent MockGitserverClient instance is invoked.
type GitserverClientListFilesFunc struct {
	defaultHook func(context.Context, int, string, *regexp.Regexp) ([]string, error)
	hooks       []func(context.Context, int, string, *regexp.Regexp) ([]string, error)
	history     []GitserverClientListFilesFuncCall
	mutex       sync.Mutex
}

// ListFiles delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockGitserverClient) ListFiles(v0 context.Context, v1 int, v2 string, v3 *regexp.Regexp) ([]string, error) {
	r0, r1 := m.ListFilesFunc.nextHook()(v0, v1, v2, v3)
	m.ListFilesFunc.appendCall(GitserverClientListFilesFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ListFiles method of
// the parent MockGitserverClient instance is invoked and the hook queue is
// empty.
func (f *GitserverClientListFilesFunc) SetDefaultHook(hook func(context.Context, int, string, *regexp.Regexp) ([]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ListFiles method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientListFilesFunc) PushHook(hook func(context.Context, int, string, *regexp.Regexp) ([]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientListFilesFunc) SetDefaultReturn(r0 []string, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientListFilesFunc) PushReturn(r0 []string, r1 error) {
	f.PushHook(func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
		return r0, r1
	})
}

func (f *GitserverClientListFilesFunc) nextHook() func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientListFilesFunc) appendCall(r0 GitserverClientListFilesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientListFilesFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientListFilesFunc) History() []GitserverClientListFilesFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientListFilesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientListFilesFuncCall is an object that describes an
// invocation of method ListFiles on an instance of MockGitserverClient.
type GitserverClientListFilesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 *regexp.Regexp
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientListFilesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientListFilesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientRawContentsFunc describes the behavior when the
// RawContents method of the parent MockGitserverClient instance is invoked.
type GitserverClientRawContentsFunc struct {
	defaultHook func(context.Context, int, string, string) ([]byte, error)
	hooks       []func(context.Context, int, string, string) ([]byte, error)
	history     []GitserverClientRawContentsFuncCall
	mutex       sync.Mutex
}

// RawContents delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverClient) RawContents(v0 context.Context, v1 int, v2 string, v3 string) ([]byte, error) {
	r0, r1 := m.RawContentsFunc.nextHook()(v0, v1, v2, v3)
	m.RawContentsFunc.appendCall(GitserverClientRawContentsFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RawContents method
// of the parent MockGitserverClient instance is invoked and the hook queue
// is empty.
func (f *GitserverClientRawContentsFunc) SetDefaultHook(hook func(context.Context, int, string, string) ([]byte, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RawContents method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientRawContentsFunc) PushHook(hook func(context.Context, int, string, string) ([]byte, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientRawContentsFunc) SetDefaultReturn(r0 []byte, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string) ([]byte, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientRawContentsFunc) PushReturn(r0 []byte, r1 error) {
	f.PushHook(func(context.Context, int, string, string) ([]byte, error) {
		return r0, r1
	})
}

func (f *GitserverClientRawContentsFunc) nextHook() func(context.Context, int, string, string) ([]byte, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientRawContentsFunc) appendCall(r0 GitserverClientRawContentsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientRawContentsFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientRawContentsFunc) History() []GitserverClientRawContentsFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientRawContentsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientRawContentsFuncCall is an object that describes an
// invocation of method RawContents on an instance of MockGitserverClient.
type GitserverClientRawContentsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []byte
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientRawContentsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientRawContentsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientResolveRevisionFunc describes the behavior when the
// ResolveRevision method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientResolveRevisionFunc struct {
	defaultHook func(context.Context, int, string) (api.CommitID, error)
	hooks       []func(context.Context, int, string) (api.CommitID, error)
	history     []GitserverClientResolveRevisionFuncCall
	mutex       sync.Mutex
}

// ResolveRevision delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockGitserverClient) ResolveRevision(v0 context.Context, v1 int, v2 string) (api.CommitID, error) {
	r0, r1 := m.ResolveRevisionFunc.nextHook()(v0, v1, v2)
	m.ResolveRevisionFunc.appendCall(GitserverClientResolveRevisionFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ResolveRevision
// method of the parent MockGitserverClient instance is invoked and the hook
// queue is empty.
func (f *GitserverClientResolveRevisionFunc) SetDefaultHook(hook func(context.Context, int, string) (api.CommitID, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ResolveRevision method of the parent MockGitserverClient instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitserverClientResolveRevisionFunc) PushHook(hook func(context.Context, int, string) (api.CommitID, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientResolveRevisionFunc) SetDefaultReturn(r0 api.CommitID, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (api.CommitID, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientResolveRevisionFunc) PushReturn(r0 api.CommitID, r1 error) {
	f.PushHook(func(context.Context, int, string) (api.CommitID, error) {
		return r0, r1
	})
}

func (f *GitserverClientResolveRevisionFunc) nextHook() func(context.Context, int, string) (api.CommitID, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientResolveRevisionFunc) appendCall(r0 GitserverClientResolveRevisionFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientResolveRevisionFuncCall
// objects describing the invocations of this function.
func (f *GitserverClientResolveRevisionFunc) History() []GitserverClientResolveRevisionFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientResolveRevisionFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientResolveRevisionFuncCall is an object that describes an
// invocation of method ResolveRevision on an instance of
// MockGitserverClient.
type GitserverClientResolveRevisionFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 api.CommitID
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientResolveRevisionFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientResolveRevisionFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockGitserverRepoStore is a mock implementation of the GitserverRepoStore
// interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/worker/internal/codeintel/indexing)
// used for unit testing.
type MockGitserverRepoStore struct {
	// GetByNamesFunc is an instance of a mock function object controlling
	// the behavior of the method GetByNames.
	GetByNamesFunc *GitserverRepoStoreGetByNamesFunc
}

// NewMockGitserverRepoStore creates a new mock of the GitserverRepoStore
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockGitserverRepoStore() *MockGitserverRepoStore {
	return &MockGitserverRepoStore{
		GetByNamesFunc: &GitserverRepoStoreGetByNamesFunc{
			defaultHook: func(context.Context, ...api.RepoName) (r0 map[api.RepoName]*types.GitserverRepo, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockGitserverRepoStore creates a new mock of the
// GitserverRepoStore interface. All methods panic on invocation, unless
// overwritten.
func NewStrictMockGitserverRepoStore() *MockGitserverRepoStore {
	return &MockGitserverRepoStore{
		GetByNamesFunc: &GitserverRepoStoreGetByNamesFunc{
			defaultHook: func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error) {
				panic("unexpected invocation of MockGitserverRepoStore.GetByNames")
			},
		},
	}
}

// NewMockGitserverRepoStoreFrom creates a new mock of the
// MockGitserverRepoStore interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockGitserverRepoStoreFrom(i GitserverRepoStore) *MockGitserverRepoStore {
	return &MockGitserverRepoStore{
		GetByNamesFunc: &GitserverRepoStoreGetByNamesFunc{
			defaultHook: i.GetByNames,
		},
	}
}

// GitserverRepoStoreGetByNamesFunc describes the behavior when the
// GetByNames method of the parent MockGitserverRepoStore instance is
// invoked.
type GitserverRepoStoreGetByNamesFunc struct {
	defaultHook func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error)
	hooks       []func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error)
	history     []GitserverRepoStoreGetByNamesFuncCall
	mutex       sync.Mutex
}

// GetByNames delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverRepoStore) GetByNames(v0 context.Context, v1 ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error) {
	r0, r1 := m.GetByNamesFunc.nextHook()(v0, v1...)
	m.GetByNamesFunc.appendCall(GitserverRepoStoreGetByNamesFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetByNames method of
// the parent MockGitserverRepoStore instance is invoked and the hook queue
// is empty.
func (f *GitserverRepoStoreGetByNamesFunc) SetDefaultHook(hook func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetByNames method of the parent MockGitserverRepoStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitserverRepoStoreGetByNamesFunc) PushHook(hook func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverRepoStoreGetByNamesFunc) SetDefaultReturn(r0 map[api.RepoName]*types.GitserverRepo, r1 error) {
	f.SetDefaultHook(func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverRepoStoreGetByNamesFunc) PushReturn(r0 map[api.RepoName]*types.GitserverRepo, r1 error) {
	f.PushHook(func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error) {
		return r0, r1
	})
}

func (f *GitserverRepoStoreGetByNamesFunc) nextHook() func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverRepoStoreGetByNamesFunc) appendCall(r0 GitserverRepoStoreGetByNamesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverRepoStoreGetByNamesFuncCall
// objects describing the invocations of this function.
func (f *GitserverRepoStoreGetByNamesFunc) History() []GitserverRepoStoreGetByNamesFuncCall {
	f.mutex.Lock()
	history := make([]GitserverRepoStoreGetByNamesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverRepoStoreGetByNamesFuncCall is an object that describes an
// invocation of method GetByNames on an instance of MockGitserverRepoStore.
type GitserverRepoStoreGetByNamesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []api.RepoName
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[api.RepoName]*types.GitserverRepo
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c GitserverRepoStoreGetByNamesFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverRepoStoreGetByNamesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockIndexEnqueuer is a mock implementation of the IndexEnqueuer interface
// (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/worker/internal/codeintel/indexing)
// used for unit testing.
type MockIndexEnqueuer struct {
	// QueueIndexesFunc is an instance of a mock function object controlling
	// the behavior of the method QueueIndexes.
	QueueIndexesFunc *IndexEnqueuerQueueIndexesFunc
	// QueueIndexesForPackageFunc is an instance of a mock function object
	// controlling the behavior of the method QueueIndexesForPackage.
	QueueIndexesForPackageFunc *IndexEnqueuerQueueIndexesForPackageFunc
}

// NewMockIndexEnqueuer creates a new mock of the IndexEnqueuer interface.
// All methods return zero values for all results, unless overwritten.
func NewMockIndexEnqueuer() *MockIndexEnqueuer {
	return &MockIndexEnqueuer{
		QueueIndexesFunc: &IndexEnqueuerQueueIndexesFunc{
			defaultHook: func(context.Context, int, string, string, bool, bool) (r0 []shared.Index, r1 error) {
				return
			},
		},
		QueueIndexesForPackageFunc: &IndexEnqueuerQueueIndexesForPackageFunc{
			defaultHook: func(context.Context, precise.Package) (r0 error) {
				return
			},
		},
	}
}

// NewStrictMockIndexEnqueuer creates a new mock of the IndexEnqueuer
// interface. All methods panic on invocation, unless overwritten.
func NewStrictMockIndexEnqueuer() *MockIndexEnqueuer {
	return &MockIndexEnqueuer{
		QueueIndexesFunc: &IndexEnqueuerQueueIndexesFunc{
			defaultHook: func(context.Context, int, string, string, bool, bool) ([]shared.Index, error) {
				panic("unexpected invocation of MockIndexEnqueuer.QueueIndexes")
			},
		},
		QueueIndexesForPackageFunc: &IndexEnqueuerQueueIndexesForPackageFunc{
			defaultHook: func(context.Context, precise.Package) error {
				panic("unexpected invocation of MockIndexEnqueuer.QueueIndexesForPackage")
			},
		},
	}
}

// NewMockIndexEnqueuerFrom creates a new mock of the MockIndexEnqueuer
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockIndexEnqueuerFrom(i IndexEnqueuer) *MockIndexEnqueuer {
	return &MockIndexEnqueuer{
		QueueIndexesFunc: &IndexEnqueuerQueueIndexesFunc{
			defaultHook: i.QueueIndexes,
		},
		QueueIndexesForPackageFunc: &IndexEnqueuerQueueIndexesForPackageFunc{
			defaultHook: i.QueueIndexesForPackage,
		},
	}
}

// IndexEnqueuerQueueIndexesFunc describes the behavior when the
// QueueIndexes method of the parent MockIndexEnqueuer instance is invoked.
type IndexEnqueuerQueueIndexesFunc struct {
	defaultHook func(context.Context, int, string, string, bool, bool) ([]shared.Index, error)
	hooks       []func(context.Context, int, string, string, bool, bool) ([]shared.Index, error)
	history     []IndexEnqueuerQueueIndexesFuncCall
	mutex       sync.Mutex
}

// QueueIndexes delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockIndexEnqueuer) QueueIndexes(v0 context.Context, v1 int, v2 string, v3 string, v4 bool, v5 bool) ([]shared.Index, error) {
	r0, r1 := m.QueueIndexesFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.QueueIndexesFunc.appendCall(IndexEnqueuerQueueIndexesFuncCall{v0, v1, v2, v3, v4, v5, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the QueueIndexes method
// of the parent MockIndexEnqueuer instance is invoked and the hook queue is
// empty.
func (f *IndexEnqueuerQueueIndexesFunc) SetDefaultHook(hook func(context.Context, int, string, string, bool, bool) ([]shared.Index, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// QueueIndexes method of the parent MockIndexEnqueuer instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *IndexEnqueuerQueueIndexesFunc) PushHook(hook func(context.Context, int, string, string, bool, bool) ([]shared.Index, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *IndexEnqueuerQueueIndexesFunc) SetDefaultReturn(r0 []shared.Index, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, bool, bool) ([]shared.Index, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *IndexEnqueuerQueueIndexesFunc) PushReturn(r0 []shared.Index, r1 error) {
	f.PushHook(func(context.Context, int, string, string, bool, bool) ([]shared.Index, error) {
		return r0, r1
	})
}

func (f *IndexEnqueuerQueueIndexesFunc) nextHook() func(context.Context, int, string, string, bool, bool) ([]shared.Index, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *IndexEnqueuerQueueIndexesFunc) appendCall(r0 IndexEnqueuerQueueIndexesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of IndexEnqueuerQueueIndexesFuncCall objects
// describing the invocations of this function.
func (f *IndexEnqueuerQueueIndexesFunc) History() []IndexEnqueuerQueueIndexesFuncCall {
	f.mutex.Lock()
	history := make([]IndexEnqueuerQueueIndexesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// IndexEnqueuerQueueIndexesFuncCall is an object that describes an
// invocation of method QueueIndexes on an instance of MockIndexEnqueuer.
type IndexEnqueuerQueueIndexesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 bool
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 bool
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c IndexEnqueuerQueueIndexesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c IndexEnqueuerQueueIndexesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// IndexEnqueuerQueueIndexesForPackageFunc describes the behavior when the
// QueueIndexesForPackage method of the parent MockIndexEnqueuer instance is
// invoked.
type IndexEnqueuerQueueIndexesForPackageFunc struct {
	defaultHook func(context.Context, precise.Package) error
	hooks       []func(context.Context, precise.Package) error
	history     []IndexEnqueuerQueueIndexesForPackageFuncCall
	mutex       sync.Mutex
}

// QueueIndexesForPackage delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockIndexEnqueuer) QueueIndexesForPackage(v0 context.Context, v1 precise.Package) error {
	r0 := m.QueueIndexesForPackageFunc.nextHook()(v0, v1)
	m.QueueIndexesForPackageFunc.appendCall(IndexEnqueuerQueueIndexesForPackageFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// QueueIndexesForPackage method of the parent MockIndexEnqueuer instance is
// invoked and the hook queue is empty.
func (f *IndexEnqueuerQueueIndexesForPackageFunc) SetDefaultHook(hook func(context.Context, precise.Package) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// QueueIndexesForPackage method of the parent MockIndexEnqueuer instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *IndexEnqueuerQueueIndexesForPackageFunc) PushHook(hook func(context.Context, precise.Package) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *IndexEnqueuerQueueIndexesForPackageFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, precise.Package) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *IndexEnqueuerQueueIndexesForPackageFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, precise.Package) error {
		return r0
	})
}

func (f *IndexEnqueuerQueueIndexesForPackageFunc) nextHook() func(context.Context, precise.Package) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *IndexEnqueuerQueueIndexesForPackageFunc) appendCall(r0 IndexEnqueuerQueueIndexesForPackageFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of IndexEnqueuerQueueIndexesForPackageFuncCall
// objects describing the invocations of this function.
func (f *IndexEnqueuerQueueIndexesForPackageFunc) History() []IndexEnqueuerQueueIndexesForPackageFuncCall {
	f.mutex.Lock()
	history := make([]IndexEnqueuerQueueIndexesForPackageFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// IndexEnqueuerQueueIndexesForPackageFuncCall is an object that describes
// an invocation of method QueueIndexesForPackage on an instance of
// MockIndexEnqueuer.
type IndexEnqueuerQueueIndexesForPackageFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 precise.Package
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c IndexEnqueuerQueueIndexesForPackageFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c IndexEnqueuerQueueIndexesForPackageFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// MockIndexingRepoStore is a mock implementation of the IndexingRepoStore
// interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/worker/internal/codeintel/indexing)
// used for unit testing.
type MockIndexingRepoStore struct {
	// ListIndexableReposFunc is an instance of a mock function object
	// controlling the behavior of the method ListIndexableRepos.
	ListIndexableReposFunc *IndexingRepoStoreListIndexableReposFunc
	// ListMinimalReposFunc is an instance of a mock function object
	// controlling the behavior of the method ListMinimalRepos.
	ListMinimalReposFunc *IndexingRepoStoreListMinimalReposFunc
}

// NewMockIndexingRepoStore creates a new mock of the IndexingRepoStore
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockIndexingRepoStore() *MockIndexingRepoStore {
	return &MockIndexingRepoStore{
		ListIndexableReposFunc: &IndexingRepoStoreListIndexableReposFunc{
			defaultHook: func(context.Context, database.ListIndexableReposOptions) (r0 []types.MinimalRepo, r1 error) {
				return
			},
		},
		ListMinimalReposFunc: &IndexingRepoStoreListMinimalReposFunc{
			defaultHook: func(context.Context, database.ReposListOptions) (r0 []types.MinimalRepo, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockIndexingRepoStore creates a new mock of the
// IndexingRepoStore interface. All methods panic on invocation, unless
// overwritten.
func NewStrictMockIndexingRepoStore() *MockIndexingRepoStore {
	return &MockIndexingRepoStore{
		ListIndexableReposFunc: &IndexingRepoStoreListIndexableReposFunc{
			defaultHook: func(context.Context, database.ListIndexableReposOptions) ([]types.MinimalRepo, error) {
				panic("unexpected invocation of MockIndexingRepoStore.ListIndexableRepos")
			},
		},
		ListMinimalReposFunc: &IndexingRepoStoreListMinimalReposFunc{
			defaultHook: func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error) {
				panic("unexpected invocation of MockIndexingRepoStore.ListMinimalRepos")
			},
		},
	}
}

// NewMockIndexingRepoStoreFrom creates a new mock of the
// MockIndexingRepoStore interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockIndexingRepoStoreFrom(i IndexingRepoStore) *MockIndexingRepoStore {
	return &MockIndexingRepoStore{
		ListIndexableReposFunc: &IndexingRepoStoreListIndexableReposFunc{
			defaultHook: i.ListIndexableRepos,
		},
		ListMinimalReposFunc: &IndexingRepoStoreListMinimalReposFunc{
			defaultHook: i.ListMinimalRepos,
		},
	}
}

// IndexingRepoStoreListIndexableReposFunc describes the behavior when the
// ListIndexableRepos method of the parent MockIndexingRepoStore instance is
// invoked.
type IndexingRepoStoreListIndexableReposFunc struct {
	defaultHook func(context.Context, database.ListIndexableReposOptions) ([]types.MinimalRepo, error)
	hooks       []func(context.Context, database.ListIndexableReposOptions) ([]types.MinimalRepo, error)
	history     []IndexingRepoStoreListIndexableReposFuncCall
	mutex       sync.Mutex
}

// ListIndexableRepos delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockIndexingRepoStore) ListIndexableRepos(v0 context.Context, v1 database.ListIndexableReposOptions) ([]types.MinimalRepo, error) {
	r0, r1 := m.ListIndexableReposFunc.nextHook()(v0, v1)
	m.ListIndexableReposFunc.appendCall(IndexingRepoStoreListIndexableReposFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ListIndexableRepos
// method of the parent MockIndexingRepoStore instance is invoked and the
// hook queue is empty.
func (f *IndexingRepoStoreListIndexableReposFunc) SetDefaultHook(hook func(context.Context, database.ListIndexableReposOptions) ([]types.MinimalRepo, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ListIndexableRepos method of the parent MockIndexingRepoStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *IndexingRepoStoreListIndexableReposFunc) PushHook(hook func(context.Context, database.ListIndexableReposOptions) ([]types.MinimalRepo, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *IndexingRepoStoreListIndexableReposFunc) SetDefaultReturn(r0 []types.MinimalRepo, r1 error) {
	f.SetDefaultHook(func(context.Context, database.ListIndexableReposOptions) ([]types.MinimalRepo, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *IndexingRepoStoreListIndexableReposFunc) PushReturn(r0 []types.MinimalRepo, r1 error) {
	f.PushHook(func(context.Context, database.ListIndexableReposOptions) ([]types.MinimalRepo, error) {
		return r0, r1
	})
}

func (f *IndexingRepoStoreListIndexableReposFunc) nextHook() func(context.Context, database.ListIndexableReposOptions) ([]types.MinimalRepo, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *IndexingRepoStoreListIndexableReposFunc) appendCall(r0 IndexingRepoStoreListIndexableReposFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of IndexingRepoStoreListIndexableReposFuncCall
// objects describing the invocations of this function.
func (f *IndexingRepoStoreListIndexableReposFunc) History() []IndexingRepoStoreListIndexableReposFuncCall {
	f.mutex.Lock()
	history := make([]IndexingRepoStoreListIndexableReposFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// IndexingRepoStoreListIndexableReposFuncCall is an object that describes
// an invocation of method ListIndexableRepos on an instance of
// MockIndexingRepoStore.
type IndexingRepoStoreListIndexableReposFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 database.ListIndexableReposOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types.MinimalRepo
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c IndexingRepoStoreListIndexableReposFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c IndexingRepoStoreListIndexableReposFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// IndexingRepoStoreListMinimalReposFunc describes the behavior when the
// ListMinimalRepos method of the parent MockIndexingRepoStore instance is
// invoked.
type IndexingRepoStoreListMinimalReposFunc struct {
	defaultHook func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error)
	hooks       []func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error)
	history     []IndexingRepoStoreListMinimalReposFuncCall
	mutex       sync.Mutex
}

// ListMinimalRepos delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockIndexingRepoStore) ListMinimalRepos(v0 context.Context, v1 database.ReposListOptions) ([]types.MinimalRepo, error) {
	r0, r1 := m.ListMinimalReposFunc.nextHook()(v0, v1)
	m.ListMinimalReposFunc.appendCall(IndexingRepoStoreListMinimalReposFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ListMinimalRepos
// method of the parent MockIndexingRepoStore instance is invoked and the
// hook queue is empty.
func (f *IndexingRepoStoreListMinimalReposFunc) SetDefaultHook(hook func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ListMinimalRepos method of the parent MockIndexingRepoStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *IndexingRepoStoreListMinimalReposFunc) PushHook(hook func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *IndexingRepoStoreListMinimalReposFunc) SetDefaultReturn(r0 []types.MinimalRepo, r1 error) {
	f.SetDefaultHook(func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *IndexingRepoStoreListMinimalReposFunc) PushReturn(r0 []types.MinimalRepo, r1 error) {
	f.PushHook(func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error) {
		return r0, r1
	})
}

func (f *IndexingRepoStoreListMinimalReposFunc) nextHook() func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *IndexingRepoStoreListMinimalReposFunc) appendCall(r0 IndexingRepoStoreListMinimalReposFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of IndexingRepoStoreListMinimalReposFuncCall
// objects describing the invocations of this function.
func (f *IndexingRepoStoreListMinimalReposFunc) History() []IndexingRepoStoreListMinimalReposFuncCall {
	f.mutex.Lock()
	history := make([]IndexingRepoStoreListMinimalReposFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// IndexingRepoStoreListMinimalReposFuncCall is an object that describes an
// invocation of method ListMinimalRepos on an instance of
// MockIndexingRepoStore.
type IndexingRepoStoreListMinimalReposFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 database.ReposListOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types.MinimalRepo
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c IndexingRepoStoreListMinimalReposFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c IndexingRepoStoreListMinimalReposFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockIndexingSettingStore is a mock implementation of the
// IndexingSettingStore interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/worker/internal/codeintel/indexing)
// used for unit testing.
type MockIndexingSettingStore struct {
	// GetLastestSchemaSettingsFunc is an instance of a mock function object
	// controlling the behavior of the method GetLastestSchemaSettings.
	GetLastestSchemaSettingsFunc *IndexingSettingStoreGetLastestSchemaSettingsFunc
}

// NewMockIndexingSettingStore creates a new mock of the
// IndexingSettingStore interface. All methods return zero values for all
// results, unless overwritten.
func NewMockIndexingSettingStore() *MockIndexingSettingStore {
	return &MockIndexingSettingStore{
		GetLastestSchemaSettingsFunc: &IndexingSettingStoreGetLastestSchemaSettingsFunc{
			defaultHook: func(context.Context, api.SettingsSubject) (r0 *schema.Settings, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockIndexingSettingStore creates a new mock of the
// IndexingSettingStore interface. All methods panic on invocation, unless
// overwritten.
func NewStrictMockIndexingSettingStore() *MockIndexingSettingStore {
	return &MockIndexingSettingStore{
		GetLastestSchemaSettingsFunc: &IndexingSettingStoreGetLastestSchemaSettingsFunc{
			defaultHook: func(context.Context, api.SettingsSubject) (*schema.Settings, error) {
				panic("unexpected invocation of MockIndexingSettingStore.GetLastestSchemaSettings")
			},
		},
	}
}

// NewMockIndexingSettingStoreFrom creates a new mock of the
// MockIndexingSettingStore interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockIndexingSettingStoreFrom(i IndexingSettingStore) *MockIndexingSettingStore {
	return &MockIndexingSettingStore{
		GetLastestSchemaSettingsFunc: &IndexingSettingStoreGetLastestSchemaSettingsFunc{
			defaultHook: i.GetLastestSchemaSettings,
		},
	}
}

// IndexingSettingStoreGetLastestSchemaSettingsFunc describes the behavior
// when the GetLastestSchemaSettings method of the parent
// MockIndexingSettingStore instance is invoked.
type IndexingSettingStoreGetLastestSchemaSettingsFunc struct {
	defaultHook func(context.Context, api.SettingsSubject) (*schema.Settings, error)
	hooks       []func(context.Context, api.SettingsSubject) (*schema.Settings, error)
	history     []IndexingSettingStoreGetLastestSchemaSettingsFuncCall
	mutex       sync.Mutex
}

// GetLastestSchemaSettings delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockIndexingSettingStore) GetLastestSchemaSettings(v0 context.Context, v1 api.SettingsSubject) (*schema.Settings, error) {
	r0, r1 := m.GetLastestSchemaSettingsFunc.nextHook()(v0, v1)
	m.GetLastestSchemaSettingsFunc.appendCall(IndexingSettingStoreGetLastestSchemaSettingsFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// GetLastestSchemaSettings method of the parent MockIndexingSettingStore
// instance is invoked and the hook queue is empty.
func (f *IndexingSettingStoreGetLastestSchemaSettingsFunc) SetDefaultHook(hook func(context.Context, api.SettingsSubject) (*schema.Settings, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetLastestSchemaSettings method of the parent MockIndexingSettingStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *IndexingSettingStoreGetLastestSchemaSettingsFunc) PushHook(hook func(context.Context, api.SettingsSubject) (*schema.Settings, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *IndexingSettingStoreGetLastestSchemaSettingsFunc) SetDefaultReturn(r0 *schema.Settings, r1 error) {
	f.SetDefaultHook(func(context.Context, api.SettingsSubject) (*schema.Settings, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *IndexingSettingStoreGetLastestSchemaSettingsFunc) PushReturn(r0 *schema.Settings, r1 error) {
	f.PushHook(func(context.Context, api.SettingsSubject) (*schema.Settings, error) {
		return r0, r1
	})
}

func (f *IndexingSettingStoreGetLastestSchemaSettingsFunc) nextHook() func(context.Context, api.SettingsSubject) (*schema.Settings, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *IndexingSettingStoreGetLastestSchemaSettingsFunc) appendCall(r0 IndexingSettingStoreGetLastestSchemaSettingsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// IndexingSettingStoreGetLastestSchemaSettingsFuncCall objects describing
// the invocations of this function.
func (f *IndexingSettingStoreGetLastestSchemaSettingsFunc) History() []IndexingSettingStoreGetLastestSchemaSettingsFuncCall {
	f.mutex.Lock()
	history := make([]IndexingSettingStoreGetLastestSchemaSettingsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// IndexingSettingStoreGetLastestSchemaSettingsFuncCall is an object that
// describes an invocation of method GetLastestSchemaSettings on an instance
// of MockIndexingSettingStore.
type IndexingSettingStoreGetLastestSchemaSettingsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 api.SettingsSubject
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *schema.Settings
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c IndexingSettingStoreGetLastestSchemaSettingsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c IndexingSettingStoreGetLastestSchemaSettingsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockPolicyMatcher is a mock implementation of the PolicyMatcher interface
// (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/worker/internal/codeintel/indexing)
// used for unit testing.
type MockPolicyMatcher struct {
	// CommitsDescribedByPolicyFunc is an instance of a mock function object
	// controlling the behavior of the method CommitsDescribedByPolicy.
	CommitsDescribedByPolicyFunc *PolicyMatcherCommitsDescribedByPolicyFunc
}

// NewMockPolicyMatcher creates a new mock of the PolicyMatcher interface.
// All methods return zero values for all results, unless overwritten.
func NewMockPolicyMatcher() *MockPolicyMatcher {
	return &MockPolicyMatcher{
		CommitsDescribedByPolicyFunc: &PolicyMatcherCommitsDescribedByPolicyFunc{
			defaultHook: func(context.Context, int, []dbstore.ConfigurationPolicy, time.Time, ...string) (r0 map[string][]enterprise.PolicyMatch, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockPolicyMatcher creates a new mock of the PolicyMatcher
// interface. All methods panic on invocation, unless overwritten.
func NewStrictMockPolicyMatcher() *MockPolicyMatcher {
	return &MockPolicyMatcher{
		CommitsDescribedByPolicyFunc: &PolicyMatcherCommitsDescribedByPolicyFunc{
			defaultHook: func(context.Context, int, []dbstore.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error) {
				panic("unexpected invocation of MockPolicyMatcher.CommitsDescribedByPolicy")
			},
		},
	}
}

// NewMockPolicyMatcherFrom creates a new mock of the MockPolicyMatcher
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockPolicyMatcherFrom(i PolicyMatcher) *MockPolicyMatcher {
	return &MockPolicyMatcher{
		CommitsDescribedByPolicyFunc: &PolicyMatcherCommitsDescribedByPolicyFunc{
			defaultHook: i.CommitsDescribedByPolicy,
		},
	}
}

// PolicyMatcherCommitsDescribedByPolicyFunc describes the behavior when the
// CommitsDescribedByPolicy method of the parent MockPolicyMatcher instance
// is invoked.
type PolicyMatcherCommitsDescribedByPolicyFunc struct {
	defaultHook func(context.Context, int, []dbstore.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error)
	hooks       []func(context.Context, int, []dbstore.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error)
	history     []PolicyMatcherCommitsDescribedByPolicyFuncCall
	mutex       sync.Mutex
}

// CommitsDescribedByPolicy delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockPolicyMatcher) CommitsDescribedByPolicy(v0 context.Context, v1 int, v2 []dbstore.ConfigurationPolicy, v3 time.Time, v4 ...string) (map[string][]enterprise.PolicyMatch, error) {
	r0, r1 := m.CommitsDescribedByPolicyFunc.nextHook()(v0, v1, v2, v3, v4...)
	m.CommitsDescribedByPolicyFunc.appendCall(PolicyMatcherCommitsDescribedByPolicyFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CommitsDescribedByPolicy method of the parent MockPolicyMatcher instance
// is invoked and the hook queue is empty.
func (f *PolicyMatcherCommitsDescribedByPolicyFunc) SetDefaultHook(hook func(context.Context, int, []dbstore.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitsDescribedByPolicy method of the parent MockPolicyMatcher instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *PolicyMatcherCommitsDescribedByPolicyFunc) PushHook(hook func(context.Context, int, []dbstore.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *PolicyMatcherCommitsDescribedByPolicyFunc) SetDefaultReturn(r0 map[string][]enterprise.PolicyMatch, r1 error) {
	f.SetDefaultHook(func(context.Context, int, []dbstore.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *PolicyMatcherCommitsDescribedByPolicyFunc) PushReturn(r0 map[string][]enterprise.PolicyMatch, r1 error) {
	f.PushHook(func(context.Context, int, []dbstore.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error) {
		return r0, r1
	})
}

func (f *PolicyMatcherCommitsDescribedByPolicyFunc) nextHook() func(context.Context, int, []dbstore.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *PolicyMatcherCommitsDescribedByPolicyFunc) appendCall(r0 PolicyMatcherCommitsDescribedByPolicyFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// PolicyMatcherCommitsDescribedByPolicyFuncCall objects describing the
// invocations of this function.
func (f *PolicyMatcherCommitsDescribedByPolicyFunc) History() []PolicyMatcherCommitsDescribedByPolicyFuncCall {
	f.mutex.Lock()
	history := make([]PolicyMatcherCommitsDescribedByPolicyFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// PolicyMatcherCommitsDescribedByPolicyFuncCall is an object that describes
// an invocation of method CommitsDescribedByPolicy on an instance of
// MockPolicyMatcher.
type PolicyMatcherCommitsDescribedByPolicyFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []dbstore.ConfigurationPolicy
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 time.Time
	// Arg4 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg4 []string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[string][]enterprise.PolicyMatch
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c PolicyMatcherCommitsDescribedByPolicyFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg4 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c PolicyMatcherCommitsDescribedByPolicyFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockRepoUpdaterClient is a mock implementation of the RepoUpdaterClient
// interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/worker/internal/codeintel/indexing)
// used for unit testing.
type MockRepoUpdaterClient struct {
	// RepoLookupFunc is an instance of a mock function object controlling
	// the behavior of the method RepoLookup.
	RepoLookupFunc *RepoUpdaterClientRepoLookupFunc
}

// NewMockRepoUpdaterClient creates a new mock of the RepoUpdaterClient
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockRepoUpdaterClient() *MockRepoUpdaterClient {
	return &MockRepoUpdaterClient{
		RepoLookupFunc: &RepoUpdaterClientRepoLookupFunc{
			defaultHook: func(context.Context, api.RepoName) (r0 *protocol.RepoInfo, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockRepoUpdaterClient creates a new mock of the
// RepoUpdaterClient interface. All methods panic on invocation, unless
// overwritten.
func NewStrictMockRepoUpdaterClient() *MockRepoUpdaterClient {
	return &MockRepoUpdaterClient{
		RepoLookupFunc: &RepoUpdaterClientRepoLookupFunc{
			defaultHook: func(context.Context, api.RepoName) (*protocol.RepoInfo, error) {
				panic("unexpected invocation of MockRepoUpdaterClient.RepoLookup")
			},
		},
	}
}

// NewMockRepoUpdaterClientFrom creates a new mock of the
// MockRepoUpdaterClient interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockRepoUpdaterClientFrom(i RepoUpdaterClient) *MockRepoUpdaterClient {
	return &MockRepoUpdaterClient{
		RepoLookupFunc: &RepoUpdaterClientRepoLookupFunc{
			defaultHook: i.RepoLookup,
		},
	}
}

// RepoUpdaterClientRepoLookupFunc describes the behavior when the
// RepoLookup method of the parent MockRepoUpdaterClient instance is
// invoked.
type RepoUpdaterClientRepoLookupFunc struct {
	defaultHook func(context.Context, api.RepoName) (*protocol.RepoInfo, error)
	hooks       []func(context.Context, api.RepoName) (*protocol.RepoInfo, error)
	history     []RepoUpdaterClientRepoLookupFuncCall
	mutex       sync.Mutex
}

// RepoLookup delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockRepoUpdaterClient) RepoLookup(v0 context.Context, v1 api.RepoName) (*protocol.RepoInfo, error) {
	r0, r1 := m.RepoLookupFunc.nextHook()(v0, v1)
	m.RepoLookupFunc.appendCall(RepoUpdaterClientRepoLookupFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepoLookup method of
// the parent MockRepoUpdaterClient instance is invoked and the hook queue
// is empty.
func (f *RepoUpdaterClientRepoLookupFunc) SetDefaultHook(hook func(context.Context, api.RepoName) (*protocol.RepoInfo, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoLookup method of the parent MockRepoUpdaterClient instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *RepoUpdaterClientRepoLookupFunc) PushHook(hook func(context.Context, api.RepoName) (*protocol.RepoInfo, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *RepoUpdaterClientRepoLookupFunc) SetDefaultReturn(r0 *protocol.RepoInfo, r1 error) {
	f.SetDefaultHook(func(context.Context, api.RepoName) (*protocol.RepoInfo, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *RepoUpdaterClientRepoLookupFunc) PushReturn(r0 *protocol.RepoInfo, r1 error) {
	f.PushHook(func(context.Context, api.RepoName) (*protocol.RepoInfo, error) {
		return r0, r1
	})
}

func (f *RepoUpdaterClientRepoLookupFunc) nextHook() func(context.Context, api.RepoName) (*protocol.RepoInfo, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *RepoUpdaterClientRepoLookupFunc) appendCall(r0 RepoUpdaterClientRepoLookupFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of RepoUpdaterClientRepoLookupFuncCall objects
// describing the invocations of this function.
func (f *RepoUpdaterClientRepoLookupFunc) History() []RepoUpdaterClientRepoLookupFuncCall {
	f.mutex.Lock()
	history := make([]RepoUpdaterClientRepoLookupFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// RepoUpdaterClientRepoLookupFuncCall is an object that describes an
// invocation of method RepoLookup on an instance of MockRepoUpdaterClient.
type RepoUpdaterClientRepoLookupFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 api.RepoName
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *protocol.RepoInfo
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c RepoUpdaterClientRepoLookupFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c RepoUpdaterClientRepoLookupFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockReposStore is a mock implementation of the ReposStore interface (from
// the package
// github.com/sourcegraph/sourcegraph/enterprise/cmd/worker/internal/codeintel/indexing)
// used for unit testing.
type MockReposStore struct {
	// ListMinimalReposFunc is an instance of a mock function object
	// controlling the behavior of the method ListMinimalRepos.
	ListMinimalReposFunc *ReposStoreListMinimalReposFunc
}

// NewMockReposStore creates a new mock of the ReposStore interface. All
// methods return zero values for all results, unless overwritten.
func NewMockReposStore() *MockReposStore {
	return &MockReposStore{
		ListMinimalReposFunc: &ReposStoreListMinimalReposFunc{
			defaultHook: func(context.Context, database.ReposListOptions) (r0 []types.MinimalRepo, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockReposStore creates a new mock of the ReposStore interface.
// All methods panic on invocation, unless overwritten.
func NewStrictMockReposStore() *MockReposStore {
	return &MockReposStore{
		ListMinimalReposFunc: &ReposStoreListMinimalReposFunc{
			defaultHook: func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error) {
				panic("unexpected invocation of MockReposStore.ListMinimalRepos")
			},
		},
	}
}

// NewMockReposStoreFrom creates a new mock of the MockReposStore interface.
// All methods delegate to the given implementation, unless overwritten.
func NewMockReposStoreFrom(i ReposStore) *MockReposStore {
	return &MockReposStore{
		ListMinimalReposFunc: &ReposStoreListMinimalReposFunc{
			defaultHook: i.ListMinimalRepos,
		},
	}
}

// ReposStoreListMinimalReposFunc describes the behavior when the
// ListMinimalRepos method of the parent MockReposStore instance is invoked.
type ReposStoreListMinimalReposFunc struct {
	defaultHook func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error)
	hooks       []func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error)
	history     []ReposStoreListMinimalReposFuncCall
	mutex       sync.Mutex
}

// ListMinimalRepos delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockReposStore) ListMinimalRepos(v0 context.Context, v1 database.ReposListOptions) ([]types.MinimalRepo, error) {
	r0, r1 := m.ListMinimalReposFunc.nextHook()(v0, v1)
	m.ListMinimalReposFunc.appendCall(ReposStoreListMinimalReposFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ListMinimalRepos
// method of the parent MockReposStore instance is invoked and the hook
// queue is empty.
func (f *ReposStoreListMinimalReposFunc) SetDefaultHook(hook func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ListMinimalRepos method of the parent MockReposStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ReposStoreListMinimalReposFunc) PushHook(hook func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ReposStoreListMinimalReposFunc) SetDefaultReturn(r0 []types.MinimalRepo, r1 error) {
	f.SetDefaultHook(func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ReposStoreListMinimalReposFunc) PushReturn(r0 []types.MinimalRepo, r1 error) {
	f.PushHook(func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error) {
		return r0, r1
	})
}

func (f *ReposStoreListMinimalReposFunc) nextHook() func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ReposStoreListMinimalReposFunc) appendCall(r0 ReposStoreListMinimalReposFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ReposStoreListMinimalReposFuncCall objects
// describing the invocations of this function.
func (f *ReposStoreListMinimalReposFunc) History() []ReposStoreListMinimalReposFuncCall {
	f.mutex.Lock()
	history := make([]ReposStoreListMinimalReposFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ReposStoreListMinimalReposFuncCall is an object that describes an
// invocation of method ListMinimalRepos on an instance of MockReposStore.
type ReposStoreListMinimalReposFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 database.ReposListOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types.MinimalRepo
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ReposStoreListMinimalReposFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ReposStoreListMinimalReposFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockPackageReferenceScanner is a mock implementation of the
// PackageReferenceScanner interface (from the package
// github.com/sourcegraph/sourcegraph/internal/codeintel/stores/dbstore)
// used for unit testing.
type MockPackageReferenceScanner struct {
	// CloseFunc is an instance of a mock function object controlling the
	// behavior of the method Close.
	CloseFunc *PackageReferenceScannerCloseFunc
	// NextFunc is an instance of a mock function object controlling the
	// behavior of the method Next.
	NextFunc *PackageReferenceScannerNextFunc
}

// NewMockPackageReferenceScanner creates a new mock of the
// PackageReferenceScanner interface. All methods return zero values for all
// results, unless overwritten.
func NewMockPackageReferenceScanner() *MockPackageReferenceScanner {
	return &MockPackageReferenceScanner{
		CloseFunc: &PackageReferenceScannerCloseFunc{
			defaultHook: func() (r0 error) {
				return
			},
		},
		NextFunc: &PackageReferenceScannerNextFunc{
			defaultHook: func() (r0 shared1.PackageReference, r1 bool, r2 error) {
				return
			},
		},
	}
}

// NewStrictMockPackageReferenceScanner creates a new mock of the
// PackageReferenceScanner interface. All methods panic on invocation,
// unless overwritten.
func NewStrictMockPackageReferenceScanner() *MockPackageReferenceScanner {
	return &MockPackageReferenceScanner{
		CloseFunc: &PackageReferenceScannerCloseFunc{
			defaultHook: func() error {
				panic("unexpected invocation of MockPackageReferenceScanner.Close")
			},
		},
		NextFunc: &PackageReferenceScannerNextFunc{
			defaultHook: func() (shared1.PackageReference, bool, error) {
				panic("unexpected invocation of MockPackageReferenceScanner.Next")
			},
		},
	}
}

// NewMockPackageReferenceScannerFrom creates a new mock of the
// MockPackageReferenceScanner interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockPackageReferenceScannerFrom(i dbstore.PackageReferenceScanner) *MockPackageReferenceScanner {
	return &MockPackageReferenceScanner{
		CloseFunc: &PackageReferenceScannerCloseFunc{
			defaultHook: i.Close,
		},
		NextFunc: &PackageReferenceScannerNextFunc{
			defaultHook: i.Next,
		},
	}
}

// PackageReferenceScannerCloseFunc describes the behavior when the Close
// method of the parent MockPackageReferenceScanner instance is invoked.
type PackageReferenceScannerCloseFunc struct {
	defaultHook func() error
	hooks       []func() error
	history     []PackageReferenceScannerCloseFuncCall
	mutex       sync.Mutex
}

// Close delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockPackageReferenceScanner) Close() error {
	r0 := m.CloseFunc.nextHook()()
	m.CloseFunc.appendCall(PackageReferenceScannerCloseFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the Close method of the
// parent MockPackageReferenceScanner instance is invoked and the hook queue
// is empty.
func (f *PackageReferenceScannerCloseFunc) SetDefaultHook(hook func() error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Close method of the parent MockPackageReferenceScanner instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *PackageReferenceScannerCloseFunc) PushHook(hook func() error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *PackageReferenceScannerCloseFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func() error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *PackageReferenceScannerCloseFunc) PushReturn(r0 error) {
	f.PushHook(func() error {
		return r0
	})
}

func (f *PackageReferenceScannerCloseFunc) nextHook() func() error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *PackageReferenceScannerCloseFunc) appendCall(r0 PackageReferenceScannerCloseFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of PackageReferenceScannerCloseFuncCall
// objects describing the invocations of this function.
func (f *PackageReferenceScannerCloseFunc) History() []PackageReferenceScannerCloseFuncCall {
	f.mutex.Lock()
	history := make([]PackageReferenceScannerCloseFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// PackageReferenceScannerCloseFuncCall is an object that describes an
// invocation of method Close on an instance of MockPackageReferenceScanner.
type PackageReferenceScannerCloseFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c PackageReferenceScannerCloseFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c PackageReferenceScannerCloseFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// PackageReferenceScannerNextFunc describes the behavior when the Next
// method of the parent MockPackageReferenceScanner instance is invoked.
type PackageReferenceScannerNextFunc struct {
	defaultHook func() (shared1.PackageReference, bool, error)
	hooks       []func() (shared1.PackageReference, bool, error)
	history     []PackageReferenceScannerNextFuncCall
	mutex       sync.Mutex
}

// Next delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockPackageReferenceScanner) Next() (shared1.PackageReference, bool, error) {
	r0, r1, r2 := m.NextFunc.nextHook()()
	m.NextFunc.appendCall(PackageReferenceScannerNextFuncCall{r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Next method of the
// parent MockPackageReferenceScanner instance is invoked and the hook queue
// is empty.
func (f *PackageReferenceScannerNextFunc) SetDefaultHook(hook func() (shared1.PackageReference, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Next method of the parent MockPackageReferenceScanner instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *PackageReferenceScannerNextFunc) PushHook(hook func() (shared1.PackageReference, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *PackageReferenceScannerNextFunc) SetDefaultReturn(r0 shared1.PackageReference, r1 bool, r2 error) {
	f.SetDefaultHook(func() (shared1.PackageReference, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *PackageReferenceScannerNextFunc) PushReturn(r0 shared1.PackageReference, r1 bool, r2 error) {
	f.PushHook(func() (shared1.PackageReference, bool, error) {
		return r0, r1, r2
	})
}

func (f *PackageReferenceScannerNextFunc) nextHook() func() (shared1.PackageReference, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *PackageReferenceScannerNextFunc) appendCall(r0 PackageReferenceScannerNextFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of PackageReferenceScannerNextFuncCall objects
// describing the invocations of this function.
func (f *PackageReferenceScannerNextFunc) History() []PackageReferenceScannerNextFuncCall {
	f.mutex.Lock()
	history := make([]PackageReferenceScannerNextFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// PackageReferenceScannerNextFuncCall is an object that describes an
// invocation of method Next on an instance of MockPackageReferenceScanner.
type PackageReferenceScannerNextFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 shared1.PackageReference
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c PackageReferenceScannerNextFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c PackageReferenceScannerNextFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// MockWorkerStore is a mock implementation of the Store interface (from the
// package
// github.com/sourcegraph/sourcegraph/internal/workerutil/dbworker/store)
// used for unit testing.
type MockWorkerStore struct {
	// AddExecutionLogEntryFunc is an instance of a mock function object
	// controlling the behavior of the method AddExecutionLogEntry.
	AddExecutionLogEntryFunc *WorkerStoreAddExecutionLogEntryFunc
	// CanceledJobsFunc is an instance of a mock function object controlling
	// the behavior of the method CanceledJobs.
	CanceledJobsFunc *WorkerStoreCanceledJobsFunc
	// DequeueFunc is an instance of a mock function object controlling the
	// behavior of the method Dequeue.
	DequeueFunc *WorkerStoreDequeueFunc
	// HandleFunc is an instance of a mock function object controlling the
	// behavior of the method Handle.
	HandleFunc *WorkerStoreHandleFunc
	// HeartbeatFunc is an instance of a mock function object controlling
	// the behavior of the method Heartbeat.
	HeartbeatFunc *WorkerStoreHeartbeatFunc
	// MarkCompleteFunc is an instance of a mock function object controlling
	// the behavior of the method MarkComplete.
	MarkCompleteFunc *WorkerStoreMarkCompleteFunc
	// MarkErroredFunc is an instance of a mock function object controlling
	// the behavior of the method MarkErrored.
	MarkErroredFunc *WorkerStoreMarkErroredFunc
	// MarkFailedFunc is an instance of a mock function object controlling
	// the behavior of the method MarkFailed.
	MarkFailedFunc *WorkerStoreMarkFailedFunc
	// MaxDurationInQueueFunc is an instance of a mock function object
	// controlling the behavior of the method MaxDurationInQueue.
	MaxDurationInQueueFunc *WorkerStoreMaxDurationInQueueFunc
	// QueuedCountFunc is an instance of a mock function object controlling
	// the behavior of the method QueuedCount.
	QueuedCountFunc *WorkerStoreQueuedCountFunc
	// RequeueFunc is an instance of a mock function object controlling the
	// behavior of the method Requeue.
	RequeueFunc *WorkerStoreRequeueFunc
	// ResetStalledFunc is an instance of a mock function object controlling
	// the behavior of the method ResetStalled.
	ResetStalledFunc *WorkerStoreResetStalledFunc
	// UpdateExecutionLogEntryFunc is an instance of a mock function object
	// controlling the behavior of the method UpdateExecutionLogEntry.
	UpdateExecutionLogEntryFunc *WorkerStoreUpdateExecutionLogEntryFunc
	// WithFunc is an instance of a mock function object controlling the
	// behavior of the method With.
	WithFunc *WorkerStoreWithFunc
}

// NewMockWorkerStore creates a new mock of the Store interface. All methods
// return zero values for all results, unless overwritten.
func NewMockWorkerStore() *MockWorkerStore {
	return &MockWorkerStore{
		AddExecutionLogEntryFunc: &WorkerStoreAddExecutionLogEntryFunc{
			defaultHook: func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (r0 int, r1 error) {
				return
			},
		},
		CanceledJobsFunc: &WorkerStoreCanceledJobsFunc{
			defaultHook: func(context.Context, []int, store.CanceledJobsOptions) (r0 []int, r1 error) {
				return
			},
		},
		DequeueFunc: &WorkerStoreDequeueFunc{
			defaultHook: func(context.Context, string, []*sqlf.Query) (r0 workerutil.Record, r1 bool, r2 error) {
				return
			},
		},
		HandleFunc: &WorkerStoreHandleFunc{
			defaultHook: func() (r0 basestore.TransactableHandle) {
				return
			},
		},
		HeartbeatFunc: &WorkerStoreHeartbeatFunc{
			defaultHook: func(context.Context, []int, store.HeartbeatOptions) (r0 []int, r1 error) {
				return
			},
		},
		MarkCompleteFunc: &WorkerStoreMarkCompleteFunc{
			defaultHook: func(context.Context, int, store.MarkFinalOptions) (r0 bool, r1 error) {
				return
			},
		},
		MarkErroredFunc: &WorkerStoreMarkErroredFunc{
			defaultHook: func(context.Context, int, string, store.MarkFinalOptions) (r0 bool, r1 error) {
				return
			},
		},
		MarkFailedFunc: &WorkerStoreMarkFailedFunc{
			defaultHook: func(context.Context, int, string, store.MarkFinalOptions) (r0 bool, r1 error) {
				return
			},
		},
		MaxDurationInQueueFunc: &WorkerStoreMaxDurationInQueueFunc{
			defaultHook: func(context.Context) (r0 time.Duration, r1 error) {
				return
			},
		},
		QueuedCountFunc: &WorkerStoreQueuedCountFunc{
			defaultHook: func(context.Context, bool) (r0 int, r1 error) {
				return
			},
		},
		RequeueFunc: &WorkerStoreRequeueFunc{
			defaultHook: func(context.Context, int, time.Time) (r0 error) {
				return
			},
		},
		ResetStalledFunc: &WorkerStoreResetStalledFunc{
			defaultHook: func(context.Context) (r0 map[int]time.Duration, r1 map[int]time.Duration, r2 error) {
				return
			},
		},
		UpdateExecutionLogEntryFunc: &WorkerStoreUpdateExecutionLogEntryFunc{
			defaultHook: func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (r0 error) {
				return
			},
		},
		WithFunc: &WorkerStoreWithFunc{
			defaultHook: func(basestore.ShareableStore) (r0 store.Store) {
				return
			},
		},
	}
}

// NewStrictMockWorkerStore creates a new mock of the Store interface. All
// methods panic on invocation, unless overwritten.
func NewStrictMockWorkerStore() *MockWorkerStore {
	return &MockWorkerStore{
		AddExecutionLogEntryFunc: &WorkerStoreAddExecutionLogEntryFunc{
			defaultHook: func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (int, error) {
				panic("unexpected invocation of MockWorkerStore.AddExecutionLogEntry")
			},
		},
		CanceledJobsFunc: &WorkerStoreCanceledJobsFunc{
			defaultHook: func(context.Context, []int, store.CanceledJobsOptions) ([]int, error) {
				panic("unexpected invocation of MockWorkerStore.CanceledJobs")
			},
		},
		DequeueFunc: &WorkerStoreDequeueFunc{
			defaultHook: func(context.Context, string, []*sqlf.Query) (workerutil.Record, bool, error) {
				panic("unexpected invocation of MockWorkerStore.Dequeue")
			},
		},
		HandleFunc: &WorkerStoreHandleFunc{
			defaultHook: func() basestore.TransactableHandle {
				panic("unexpected invocation of MockWorkerStore.Handle")
			},
		},
		HeartbeatFunc: &WorkerStoreHeartbeatFunc{
			defaultHook: func(context.Context, []int, store.HeartbeatOptions) ([]int, error) {
				panic("unexpected invocation of MockWorkerStore.Heartbeat")
			},
		},
		MarkCompleteFunc: &WorkerStoreMarkCompleteFunc{
			defaultHook: func(context.Context, int, store.MarkFinalOptions) (bool, error) {
				panic("unexpected invocation of MockWorkerStore.MarkComplete")
			},
		},
		MarkErroredFunc: &WorkerStoreMarkErroredFunc{
			defaultHook: func(context.Context, int, string, store.MarkFinalOptions) (bool, error) {
				panic("unexpected invocation of MockWorkerStore.MarkErrored")
			},
		},
		MarkFailedFunc: &WorkerStoreMarkFailedFunc{
			defaultHook: func(context.Context, int, string, store.MarkFinalOptions) (bool, error) {
				panic("unexpected invocation of MockWorkerStore.MarkFailed")
			},
		},
		MaxDurationInQueueFunc: &WorkerStoreMaxDurationInQueueFunc{
			defaultHook: func(context.Context) (time.Duration, error) {
				panic("unexpected invocation of MockWorkerStore.MaxDurationInQueue")
			},
		},
		QueuedCountFunc: &WorkerStoreQueuedCountFunc{
			defaultHook: func(context.Context, bool) (int, error) {
				panic("unexpected invocation of MockWorkerStore.QueuedCount")
			},
		},
		RequeueFunc: &WorkerStoreRequeueFunc{
			defaultHook: func(context.Context, int, time.Time) error {
				panic("unexpected invocation of MockWorkerStore.Requeue")
			},
		},
		ResetStalledFunc: &WorkerStoreResetStalledFunc{
			defaultHook: func(context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
				panic("unexpected invocation of MockWorkerStore.ResetStalled")
			},
		},
		UpdateExecutionLogEntryFunc: &WorkerStoreUpdateExecutionLogEntryFunc{
			defaultHook: func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) error {
				panic("unexpected invocation of MockWorkerStore.UpdateExecutionLogEntry")
			},
		},
		WithFunc: &WorkerStoreWithFunc{
			defaultHook: func(basestore.ShareableStore) store.Store {
				panic("unexpected invocation of MockWorkerStore.With")
			},
		},
	}
}

// NewMockWorkerStoreFrom creates a new mock of the MockWorkerStore
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockWorkerStoreFrom(i store.Store) *MockWorkerStore {
	return &MockWorkerStore{
		AddExecutionLogEntryFunc: &WorkerStoreAddExecutionLogEntryFunc{
			defaultHook: i.AddExecutionLogEntry,
		},
		CanceledJobsFunc: &WorkerStoreCanceledJobsFunc{
			defaultHook: i.CanceledJobs,
		},
		DequeueFunc: &WorkerStoreDequeueFunc{
			defaultHook: i.Dequeue,
		},
		HandleFunc: &WorkerStoreHandleFunc{
			defaultHook: i.Handle,
		},
		HeartbeatFunc: &WorkerStoreHeartbeatFunc{
			defaultHook: i.Heartbeat,
		},
		MarkCompleteFunc: &WorkerStoreMarkCompleteFunc{
			defaultHook: i.MarkComplete,
		},
		MarkErroredFunc: &WorkerStoreMarkErroredFunc{
			defaultHook: i.MarkErrored,
		},
		MarkFailedFunc: &WorkerStoreMarkFailedFunc{
			defaultHook: i.MarkFailed,
		},
		MaxDurationInQueueFunc: &WorkerStoreMaxDurationInQueueFunc{
			defaultHook: i.MaxDurationInQueue,
		},
		QueuedCountFunc: &WorkerStoreQueuedCountFunc{
			defaultHook: i.QueuedCount,
		},
		RequeueFunc: &WorkerStoreRequeueFunc{
			defaultHook: i.Requeue,
		},
		ResetStalledFunc: &WorkerStoreResetStalledFunc{
			defaultHook: i.ResetStalled,
		},
		UpdateExecutionLogEntryFunc: &WorkerStoreUpdateExecutionLogEntryFunc{
			defaultHook: i.UpdateExecutionLogEntry,
		},
		WithFunc: &WorkerStoreWithFunc{
			defaultHook: i.With,
		},
	}
}

// WorkerStoreAddExecutionLogEntryFunc describes the behavior when the
// AddExecutionLogEntry method of the parent MockWorkerStore instance is
// invoked.
type WorkerStoreAddExecutionLogEntryFunc struct {
	defaultHook func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (int, error)
	hooks       []func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (int, error)
	history     []WorkerStoreAddExecutionLogEntryFuncCall
	mutex       sync.Mutex
}

// AddExecutionLogEntry delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockWorkerStore) AddExecutionLogEntry(v0 context.Context, v1 int, v2 workerutil.ExecutionLogEntry, v3 store.ExecutionLogEntryOptions) (int, error) {
	r0, r1 := m.AddExecutionLogEntryFunc.nextHook()(v0, v1, v2, v3)
	m.AddExecutionLogEntryFunc.appendCall(WorkerStoreAddExecutionLogEntryFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the AddExecutionLogEntry
// method of the parent MockWorkerStore instance is invoked and the hook
// queue is empty.
func (f *WorkerStoreAddExecutionLogEntryFunc) SetDefaultHook(hook func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// AddExecutionLogEntry method of the parent MockWorkerStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *WorkerStoreAddExecutionLogEntryFunc) PushHook(hook func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreAddExecutionLogEntryFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreAddExecutionLogEntryFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (int, error) {
		return r0, r1
	})
}

func (f *WorkerStoreAddExecutionLogEntryFunc) nextHook() func(context.Context, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreAddExecutionLogEntryFunc) appendCall(r0 WorkerStoreAddExecutionLogEntryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreAddExecutionLogEntryFuncCall
// objects describing the invocations of this function.
func (f *WorkerStoreAddExecutionLogEntryFunc) History() []WorkerStoreAddExecutionLogEntryFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreAddExecutionLogEntryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreAddExecutionLogEntryFuncCall is an object that describes an
// invocation of method AddExecutionLogEntry on an instance of
// MockWorkerStore.
type WorkerStoreAddExecutionLogEntryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 workerutil.ExecutionLogEntry
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 store.ExecutionLogEntryOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreAddExecutionLogEntryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreAddExecutionLogEntryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreCanceledJobsFunc describes the behavior when the CanceledJobs
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreCanceledJobsFunc struct {
	defaultHook func(context.Context, []int, store.CanceledJobsOptions) ([]int, error)
	hooks       []func(context.Context, []int, store.CanceledJobsOptions) ([]int, error)
	history     []WorkerStoreCanceledJobsFuncCall
	mutex       sync.Mutex
}

// CanceledJobs delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore) CanceledJobs(v0 context.Context, v1 []int, v2 store.CanceledJobsOptions) ([]int, error) {
	r0, r1 := m.CanceledJobsFunc.nextHook()(v0, v1, v2)
	m.CanceledJobsFunc.appendCall(WorkerStoreCanceledJobsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the CanceledJobs method
// of the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreCanceledJobsFunc) SetDefaultHook(hook func(context.Context, []int, store.CanceledJobsOptions) ([]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CanceledJobs method of the parent MockWorkerStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *WorkerStoreCanceledJobsFunc) PushHook(hook func(context.Context, []int, store.CanceledJobsOptions) ([]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreCanceledJobsFunc) SetDefaultReturn(r0 []int, r1 error) {
	f.SetDefaultHook(func(context.Context, []int, store.CanceledJobsOptions) ([]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreCanceledJobsFunc) PushReturn(r0 []int, r1 error) {
	f.PushHook(func(context.Context, []int, store.CanceledJobsOptions) ([]int, error) {
		return r0, r1
	})
}

func (f *WorkerStoreCanceledJobsFunc) nextHook() func(context.Context, []int, store.CanceledJobsOptions) ([]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreCanceledJobsFunc) appendCall(r0 WorkerStoreCanceledJobsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreCanceledJobsFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreCanceledJobsFunc) History() []WorkerStoreCanceledJobsFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreCanceledJobsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreCanceledJobsFuncCall is an object that describes an invocation
// of method CanceledJobs on an instance of MockWorkerStore.
type WorkerStoreCanceledJobsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 store.CanceledJobsOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreCanceledJobsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreCanceledJobsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreDequeueFunc describes the behavior when the Dequeue method of
// the parent MockWorkerStore instance is invoked.
type WorkerStoreDequeueFunc struct {
	defaultHook func(context.Context, string, []*sqlf.Query) (workerutil.Record, bool, error)
	hooks       []func(context.Context, string, []*sqlf.Query) (workerutil.Record, bool, error)
	history     []WorkerStoreDequeueFuncCall
	mutex       sync.Mutex
}

// Dequeue delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore) Dequeue(v0 context.Context, v1 string, v2 []*sqlf.Query) (workerutil.Record, bool, error) {
	r0, r1, r2 := m.DequeueFunc.nextHook()(v0, v1, v2)
	m.DequeueFunc.appendCall(WorkerStoreDequeueFuncCall{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Dequeue method of
// the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreDequeueFunc) SetDefaultHook(hook func(context.Context, string, []*sqlf.Query) (workerutil.Record, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Dequeue method of the parent MockWorkerStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreDequeueFunc) PushHook(hook func(context.Context, string, []*sqlf.Query) (workerutil.Record, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreDequeueFunc) SetDefaultReturn(r0 workerutil.Record, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, string, []*sqlf.Query) (workerutil.Record, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreDequeueFunc) PushReturn(r0 workerutil.Record, r1 bool, r2 error) {
	f.PushHook(func(context.Context, string, []*sqlf.Query) (workerutil.Record, bool, error) {
		return r0, r1, r2
	})
}

func (f *WorkerStoreDequeueFunc) nextHook() func(context.Context, string, []*sqlf.Query) (workerutil.Record, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreDequeueFunc) appendCall(r0 WorkerStoreDequeueFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreDequeueFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreDequeueFunc) History() []WorkerStoreDequeueFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreDequeueFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreDequeueFuncCall is an object that describes an invocation of
// method Dequeue on an instance of MockWorkerStore.
type WorkerStoreDequeueFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []*sqlf.Query
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 workerutil.Record
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreDequeueFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreDequeueFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// WorkerStoreHandleFunc describes the behavior when the Handle method of
// the parent MockWorkerStore instance is invoked.
type WorkerStoreHandleFunc struct {
	defaultHook func() basestore.TransactableHandle
	hooks       []func() basestore.TransactableHandle
	history     []WorkerStoreHandleFuncCall
	mutex       sync.Mutex
}

// Handle delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore) Handle() basestore.TransactableHandle {
	r0 := m.HandleFunc.nextHook()()
	m.HandleFunc.appendCall(WorkerStoreHandleFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the Handle method of the
// parent MockWorkerStore instance is invoked and the hook queue is empty.
func (f *WorkerStoreHandleFunc) SetDefaultHook(hook func() basestore.TransactableHandle) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Handle method of the parent MockWorkerStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreHandleFunc) PushHook(hook func() basestore.TransactableHandle) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreHandleFunc) SetDefaultReturn(r0 basestore.TransactableHandle) {
	f.SetDefaultHook(func() basestore.TransactableHandle {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreHandleFunc) PushReturn(r0 basestore.TransactableHandle) {
	f.PushHook(func() basestore.TransactableHandle {
		return r0
	})
}

func (f *WorkerStoreHandleFunc) nextHook() func() basestore.TransactableHandle {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreHandleFunc) appendCall(r0 WorkerStoreHandleFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreHandleFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreHandleFunc) History() []WorkerStoreHandleFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreHandleFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreHandleFuncCall is an object that describes an invocation of
// method Handle on an instance of MockWorkerStore.
type WorkerStoreHandleFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 basestore.TransactableHandle
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreHandleFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreHandleFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// WorkerStoreHeartbeatFunc describes the behavior when the Heartbeat method
// of the parent MockWorkerStore instance is invoked.
type WorkerStoreHeartbeatFunc struct {
	defaultHook func(context.Context, []int, store.HeartbeatOptions) ([]int, error)
	hooks       []func(context.Context, []int, store.HeartbeatOptions) ([]int, error)
	history     []WorkerStoreHeartbeatFuncCall
	mutex       sync.Mutex
}

// Heartbeat delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore) Heartbeat(v0 context.Context, v1 []int, v2 store.HeartbeatOptions) ([]int, error) {
	r0, r1 := m.HeartbeatFunc.nextHook()(v0, v1, v2)
	m.HeartbeatFunc.appendCall(WorkerStoreHeartbeatFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Heartbeat method of
// the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreHeartbeatFunc) SetDefaultHook(hook func(context.Context, []int, store.HeartbeatOptions) ([]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Heartbeat method of the parent MockWorkerStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreHeartbeatFunc) PushHook(hook func(context.Context, []int, store.HeartbeatOptions) ([]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreHeartbeatFunc) SetDefaultReturn(r0 []int, r1 error) {
	f.SetDefaultHook(func(context.Context, []int, store.HeartbeatOptions) ([]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreHeartbeatFunc) PushReturn(r0 []int, r1 error) {
	f.PushHook(func(context.Context, []int, store.HeartbeatOptions) ([]int, error) {
		return r0, r1
	})
}

func (f *WorkerStoreHeartbeatFunc) nextHook() func(context.Context, []int, store.HeartbeatOptions) ([]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreHeartbeatFunc) appendCall(r0 WorkerStoreHeartbeatFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreHeartbeatFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreHeartbeatFunc) History() []WorkerStoreHeartbeatFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreHeartbeatFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreHeartbeatFuncCall is an object that describes an invocation of
// method Heartbeat on an instance of MockWorkerStore.
type WorkerStoreHeartbeatFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 store.HeartbeatOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreHeartbeatFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreHeartbeatFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreMarkCompleteFunc describes the behavior when the MarkComplete
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreMarkCompleteFunc struct {
	defaultHook func(context.Context, int, store.MarkFinalOptions) (bool, error)
	hooks       []func(context.Context, int, store.MarkFinalOptions) (bool, error)
	history     []WorkerStoreMarkCompleteFuncCall
	mutex       sync.Mutex
}

// MarkComplete delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore) MarkComplete(v0 context.Context, v1 int, v2 store.MarkFinalOptions) (bool, error) {
	r0, r1 := m.MarkCompleteFunc.nextHook()(v0, v1, v2)
	m.MarkCompleteFunc.appendCall(WorkerStoreMarkCompleteFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MarkComplete method
// of the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreMarkCompleteFunc) SetDefaultHook(hook func(context.Context, int, store.MarkFinalOptions) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkComplete method of the parent MockWorkerStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *WorkerStoreMarkCompleteFunc) PushHook(hook func(context.Context, int, store.MarkFinalOptions) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreMarkCompleteFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, store.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreMarkCompleteFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, store.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

func (f *WorkerStoreMarkCompleteFunc) nextHook() func(context.Context, int, store.MarkFinalOptions) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreMarkCompleteFunc) appendCall(r0 WorkerStoreMarkCompleteFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreMarkCompleteFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreMarkCompleteFunc) History() []WorkerStoreMarkCompleteFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreMarkCompleteFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreMarkCompleteFuncCall is an object that describes an invocation
// of method MarkComplete on an instance of MockWorkerStore.
type WorkerStoreMarkCompleteFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 store.MarkFinalOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreMarkCompleteFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreMarkCompleteFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreMarkErroredFunc describes the behavior when the MarkErrored
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreMarkErroredFunc struct {
	defaultHook func(context.Context, int, string, store.MarkFinalOptions) (bool, error)
	hooks       []func(context.Context, int, string, store.MarkFinalOptions) (bool, error)
	history     []WorkerStoreMarkErroredFuncCall
	mutex       sync.Mutex
}

// MarkErrored delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore) MarkErrored(v0 context.Context, v1 int, v2 string, v3 store.MarkFinalOptions) (bool, error) {
	r0, r1 := m.MarkErroredFunc.nextHook()(v0, v1, v2, v3)
	m.MarkErroredFunc.appendCall(WorkerStoreMarkErroredFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MarkErrored method
// of the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreMarkErroredFunc) SetDefaultHook(hook func(context.Context, int, string, store.MarkFinalOptions) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkErrored method of the parent MockWorkerStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *WorkerStoreMarkErroredFunc) PushHook(hook func(context.Context, int, string, store.MarkFinalOptions) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreMarkErroredFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, store.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreMarkErroredFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string, store.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

func (f *WorkerStoreMarkErroredFunc) nextHook() func(context.Context, int, string, store.MarkFinalOptions) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreMarkErroredFunc) appendCall(r0 WorkerStoreMarkErroredFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreMarkErroredFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreMarkErroredFunc) History() []WorkerStoreMarkErroredFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreMarkErroredFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreMarkErroredFuncCall is an object that describes an invocation
// of method MarkErrored on an instance of MockWorkerStore.
type WorkerStoreMarkErroredFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 store.MarkFinalOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreMarkErroredFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreMarkErroredFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreMarkFailedFunc describes the behavior when the MarkFailed
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreMarkFailedFunc struct {
	defaultHook func(context.Context, int, string, store.MarkFinalOptions) (bool, error)
	hooks       []func(context.Context, int, string, store.MarkFinalOptions) (bool, error)
	history     []WorkerStoreMarkFailedFuncCall
	mutex       sync.Mutex
}

// MarkFailed delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore) MarkFailed(v0 context.Context, v1 int, v2 string, v3 store.MarkFinalOptions) (bool, error) {
	r0, r1 := m.MarkFailedFunc.nextHook()(v0, v1, v2, v3)
	m.MarkFailedFunc.appendCall(WorkerStoreMarkFailedFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MarkFailed method of
// the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreMarkFailedFunc) SetDefaultHook(hook func(context.Context, int, string, store.MarkFinalOptions) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkFailed method of the parent MockWorkerStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreMarkFailedFunc) PushHook(hook func(context.Context, int, string, store.MarkFinalOptions) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreMarkFailedFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, store.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreMarkFailedFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string, store.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

func (f *WorkerStoreMarkFailedFunc) nextHook() func(context.Context, int, string, store.MarkFinalOptions) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreMarkFailedFunc) appendCall(r0 WorkerStoreMarkFailedFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreMarkFailedFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreMarkFailedFunc) History() []WorkerStoreMarkFailedFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreMarkFailedFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreMarkFailedFuncCall is an object that describes an invocation
// of method MarkFailed on an instance of MockWorkerStore.
type WorkerStoreMarkFailedFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 store.MarkFinalOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreMarkFailedFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreMarkFailedFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreMaxDurationInQueueFunc describes the behavior when the
// MaxDurationInQueue method of the parent MockWorkerStore instance is
// invoked.
type WorkerStoreMaxDurationInQueueFunc struct {
	defaultHook func(context.Context) (time.Duration, error)
	hooks       []func(context.Context) (time.Duration, error)
	history     []WorkerStoreMaxDurationInQueueFuncCall
	mutex       sync.Mutex
}

// MaxDurationInQueue delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockWorkerStore) MaxDurationInQueue(v0 context.Context) (time.Duration, error) {
	r0, r1 := m.MaxDurationInQueueFunc.nextHook()(v0)
	m.MaxDurationInQueueFunc.appendCall(WorkerStoreMaxDurationInQueueFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MaxDurationInQueue
// method of the parent MockWorkerStore instance is invoked and the hook
// queue is empty.
func (f *WorkerStoreMaxDurationInQueueFunc) SetDefaultHook(hook func(context.Context) (time.Duration, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MaxDurationInQueue method of the parent MockWorkerStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *WorkerStoreMaxDurationInQueueFunc) PushHook(hook func(context.Context) (time.Duration, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreMaxDurationInQueueFunc) SetDefaultReturn(r0 time.Duration, r1 error) {
	f.SetDefaultHook(func(context.Context) (time.Duration, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreMaxDurationInQueueFunc) PushReturn(r0 time.Duration, r1 error) {
	f.PushHook(func(context.Context) (time.Duration, error) {
		return r0, r1
	})
}

func (f *WorkerStoreMaxDurationInQueueFunc) nextHook() func(context.Context) (time.Duration, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreMaxDurationInQueueFunc) appendCall(r0 WorkerStoreMaxDurationInQueueFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreMaxDurationInQueueFuncCall
// objects describing the invocations of this function.
func (f *WorkerStoreMaxDurationInQueueFunc) History() []WorkerStoreMaxDurationInQueueFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreMaxDurationInQueueFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreMaxDurationInQueueFuncCall is an object that describes an
// invocation of method MaxDurationInQueue on an instance of
// MockWorkerStore.
type WorkerStoreMaxDurationInQueueFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 time.Duration
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreMaxDurationInQueueFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreMaxDurationInQueueFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreQueuedCountFunc describes the behavior when the QueuedCount
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreQueuedCountFunc struct {
	defaultHook func(context.Context, bool) (int, error)
	hooks       []func(context.Context, bool) (int, error)
	history     []WorkerStoreQueuedCountFuncCall
	mutex       sync.Mutex
}

// QueuedCount delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore) QueuedCount(v0 context.Context, v1 bool) (int, error) {
	r0, r1 := m.QueuedCountFunc.nextHook()(v0, v1)
	m.QueuedCountFunc.appendCall(WorkerStoreQueuedCountFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the QueuedCount method
// of the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreQueuedCountFunc) SetDefaultHook(hook func(context.Context, bool) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// QueuedCount method of the parent MockWorkerStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *WorkerStoreQueuedCountFunc) PushHook(hook func(context.Context, bool) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreQueuedCountFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, bool) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreQueuedCountFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, bool) (int, error) {
		return r0, r1
	})
}

func (f *WorkerStoreQueuedCountFunc) nextHook() func(context.Context, bool) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreQueuedCountFunc) appendCall(r0 WorkerStoreQueuedCountFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreQueuedCountFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreQueuedCountFunc) History() []WorkerStoreQueuedCountFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreQueuedCountFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreQueuedCountFuncCall is an object that describes an invocation
// of method QueuedCount on an instance of MockWorkerStore.
type WorkerStoreQueuedCountFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 bool
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreQueuedCountFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreQueuedCountFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreRequeueFunc describes the behavior when the Requeue method of
// the parent MockWorkerStore instance is invoked.
type WorkerStoreRequeueFunc struct {
	defaultHook func(context.Context, int, time.Time) error
	hooks       []func(context.Context, int, time.Time) error
	history     []WorkerStoreRequeueFuncCall
	mutex       sync.Mutex
}

// Requeue delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore) Requeue(v0 context.Context, v1 int, v2 time.Time) error {
	r0 := m.RequeueFunc.nextHook()(v0, v1, v2)
	m.RequeueFunc.appendCall(WorkerStoreRequeueFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Requeue method of
// the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreRequeueFunc) SetDefaultHook(hook func(context.Context, int, time.Time) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Requeue method of the parent MockWorkerStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreRequeueFunc) PushHook(hook func(context.Context, int, time.Time) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreRequeueFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreRequeueFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

func (f *WorkerStoreRequeueFunc) nextHook() func(context.Context, int, time.Time) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreRequeueFunc) appendCall(r0 WorkerStoreRequeueFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreRequeueFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreRequeueFunc) History() []WorkerStoreRequeueFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreRequeueFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreRequeueFuncCall is an object that describes an invocation of
// method Requeue on an instance of MockWorkerStore.
type WorkerStoreRequeueFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreRequeueFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreRequeueFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// WorkerStoreResetStalledFunc describes the behavior when the ResetStalled
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreResetStalledFunc struct {
	defaultHook func(context.Context) (map[int]time.Duration, map[int]time.Duration, error)
	hooks       []func(context.Context) (map[int]time.Duration, map[int]time.Duration, error)
	history     []WorkerStoreResetStalledFuncCall
	mutex       sync.Mutex
}

// ResetStalled delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore) ResetStalled(v0 context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
	r0, r1, r2 := m.ResetStalledFunc.nextHook()(v0)
	m.ResetStalledFunc.appendCall(WorkerStoreResetStalledFuncCall{v0, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the ResetStalled method
// of the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreResetStalledFunc) SetDefaultHook(hook func(context.Context) (map[int]time.Duration, map[int]time.Duration, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ResetStalled method of the parent MockWorkerStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *WorkerStoreResetStalledFunc) PushHook(hook func(context.Context) (map[int]time.Duration, map[int]time.Duration, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreResetStalledFunc) SetDefaultReturn(r0 map[int]time.Duration, r1 map[int]time.Duration, r2 error) {
	f.SetDefaultHook(func(context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreResetStalledFunc) PushReturn(r0 map[int]time.Duration, r1 map[int]time.Duration, r2 error) {
	f.PushHook(func(context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
		return r0, r1, r2
	})
}

func (f *WorkerStoreResetStalledFunc) nextHook() func(context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreResetStalledFunc) appendCall(r0 WorkerStoreResetStalledFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreResetStalledFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreResetStalledFunc) History() []WorkerStoreResetStalledFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreResetStalledFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreResetStalledFuncCall is an object that describes an invocation
// of method ResetStalled on an instance of MockWorkerStore.
type WorkerStoreResetStalledFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[int]time.Duration
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 map[int]time.Duration
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreResetStalledFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreResetStalledFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// WorkerStoreUpdateExecutionLogEntryFunc describes the behavior when the
// UpdateExecutionLogEntry method of the parent MockWorkerStore instance is
// invoked.
type WorkerStoreUpdateExecutionLogEntryFunc struct {
	defaultHook func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) error
	hooks       []func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) error
	history     []WorkerStoreUpdateExecutionLogEntryFuncCall
	mutex       sync.Mutex
}

// UpdateExecutionLogEntry delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockWorkerStore) UpdateExecutionLogEntry(v0 context.Context, v1 int, v2 int, v3 workerutil.ExecutionLogEntry, v4 store.ExecutionLogEntryOptions) error {
	r0 := m.UpdateExecutionLogEntryFunc.nextHook()(v0, v1, v2, v3, v4)
	m.UpdateExecutionLogEntryFunc.appendCall(WorkerStoreUpdateExecutionLogEntryFuncCall{v0, v1, v2, v3, v4, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdateExecutionLogEntry method of the parent MockWorkerStore instance is
// invoked and the hook queue is empty.
func (f *WorkerStoreUpdateExecutionLogEntryFunc) SetDefaultHook(hook func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateExecutionLogEntry method of the parent MockWorkerStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *WorkerStoreUpdateExecutionLogEntryFunc) PushHook(hook func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreUpdateExecutionLogEntryFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreUpdateExecutionLogEntryFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) error {
		return r0
	})
}

func (f *WorkerStoreUpdateExecutionLogEntryFunc) nextHook() func(context.Context, int, int, workerutil.ExecutionLogEntry, store.ExecutionLogEntryOptions) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreUpdateExecutionLogEntryFunc) appendCall(r0 WorkerStoreUpdateExecutionLogEntryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreUpdateExecutionLogEntryFuncCall
// objects describing the invocations of this function.
func (f *WorkerStoreUpdateExecutionLogEntryFunc) History() []WorkerStoreUpdateExecutionLogEntryFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreUpdateExecutionLogEntryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreUpdateExecutionLogEntryFuncCall is an object that describes an
// invocation of method UpdateExecutionLogEntry on an instance of
// MockWorkerStore.
type WorkerStoreUpdateExecutionLogEntryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 workerutil.ExecutionLogEntry
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 store.ExecutionLogEntryOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreUpdateExecutionLogEntryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreUpdateExecutionLogEntryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// WorkerStoreWithFunc describes the behavior when the With method of the
// parent MockWorkerStore instance is invoked.
type WorkerStoreWithFunc struct {
	defaultHook func(basestore.ShareableStore) store.Store
	hooks       []func(basestore.ShareableStore) store.Store
	history     []WorkerStoreWithFuncCall
	mutex       sync.Mutex
}

// With delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore) With(v0 basestore.ShareableStore) store.Store {
	r0 := m.WithFunc.nextHook()(v0)
	m.WithFunc.appendCall(WorkerStoreWithFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the With method of the
// parent MockWorkerStore instance is invoked and the hook queue is empty.
func (f *WorkerStoreWithFunc) SetDefaultHook(hook func(basestore.ShareableStore) store.Store) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// With method of the parent MockWorkerStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreWithFunc) PushHook(hook func(basestore.ShareableStore) store.Store) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreWithFunc) SetDefaultReturn(r0 store.Store) {
	f.SetDefaultHook(func(basestore.ShareableStore) store.Store {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreWithFunc) PushReturn(r0 store.Store) {
	f.PushHook(func(basestore.ShareableStore) store.Store {
		return r0
	})
}

func (f *WorkerStoreWithFunc) nextHook() func(basestore.ShareableStore) store.Store {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreWithFunc) appendCall(r0 WorkerStoreWithFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreWithFuncCall objects describing
// the invocations of this function.
func (f *WorkerStoreWithFunc) History() []WorkerStoreWithFuncCall {
	f.mutex.Lock()
	history := make([]WorkerStoreWithFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreWithFuncCall is an object that describes an invocation of
// method With on an instance of MockWorkerStore.
type WorkerStoreWithFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 basestore.ShareableStore
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Store
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreWithFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreWithFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}
