// Code generated by go-mockgen 1.3.7; DO NOT EDIT.
//
// This file was generated by running `sg generate` (or `go-mockgen`) at the root of
// this repository. To add additional mocks to this or another package, add a new entry
// to the mockgen.yaml file in the root of this repository.

package background

import (
	"context"
	"sync"
	"time"

	regexp "github.com/grafana/regexp"
	sqlf "github.com/keegancsmith/sqlf"
	store "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/autoindexing/internal/store"
	shared2 "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/autoindexing/shared"
	enterprise "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/policies/enterprise"
	types1 "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/shared/types"
	shared1 "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/uploads/shared"
	api "github.com/sourcegraph/sourcegraph/internal/api"
	shared "github.com/sourcegraph/sourcegraph/internal/codeintel/dependencies/shared"
	database "github.com/sourcegraph/sourcegraph/internal/database"
	basestore "github.com/sourcegraph/sourcegraph/internal/database/basestore"
	executor "github.com/sourcegraph/sourcegraph/internal/executor"
	gitdomain "github.com/sourcegraph/sourcegraph/internal/gitserver/gitdomain"
	protocol "github.com/sourcegraph/sourcegraph/internal/repoupdater/protocol"
	types "github.com/sourcegraph/sourcegraph/internal/types"
	workerutil "github.com/sourcegraph/sourcegraph/internal/workerutil"
	store1 "github.com/sourcegraph/sourcegraph/internal/workerutil/dbworker/store"
	precise "github.com/sourcegraph/sourcegraph/lib/codeintel/precise"
)

// MockDependenciesService is a mock implementation of the
// DependenciesService interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/autoindexing/internal/background)
// used for unit testing.
type MockDependenciesService struct {
	// InsertPackageRepoRefsFunc is an instance of a mock function object
	// controlling the behavior of the method InsertPackageRepoRefs.
	InsertPackageRepoRefsFunc *DependenciesServiceInsertPackageRepoRefsFunc
}

// NewMockDependenciesService creates a new mock of the DependenciesService
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockDependenciesService() *MockDependenciesService {
	return &MockDependenciesService{
		InsertPackageRepoRefsFunc: &DependenciesServiceInsertPackageRepoRefsFunc{
			defaultHook: func(context.Context, []shared.MinimalPackageRepoRef) (r0 []shared.PackageRepoReference, r1 []shared.PackageRepoRefVersion, r2 error) {
				return
			},
		},
	}
}

// NewStrictMockDependenciesService creates a new mock of the
// DependenciesService interface. All methods panic on invocation, unless
// overwritten.
func NewStrictMockDependenciesService() *MockDependenciesService {
	return &MockDependenciesService{
		InsertPackageRepoRefsFunc: &DependenciesServiceInsertPackageRepoRefsFunc{
			defaultHook: func(context.Context, []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error) {
				panic("unexpected invocation of MockDependenciesService.InsertPackageRepoRefs")
			},
		},
	}
}

// NewMockDependenciesServiceFrom creates a new mock of the
// MockDependenciesService interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockDependenciesServiceFrom(i DependenciesService) *MockDependenciesService {
	return &MockDependenciesService{
		InsertPackageRepoRefsFunc: &DependenciesServiceInsertPackageRepoRefsFunc{
			defaultHook: i.InsertPackageRepoRefs,
		},
	}
}

// DependenciesServiceInsertPackageRepoRefsFunc describes the behavior when
// the InsertPackageRepoRefs method of the parent MockDependenciesService
// instance is invoked.
type DependenciesServiceInsertPackageRepoRefsFunc struct {
	defaultHook func(context.Context, []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error)
	hooks       []func(context.Context, []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error)
	history     []DependenciesServiceInsertPackageRepoRefsFuncCall
	mutex       sync.Mutex
}

// InsertPackageRepoRefs delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDependenciesService) InsertPackageRepoRefs(v0 context.Context, v1 []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error) {
	r0, r1, r2 := m.InsertPackageRepoRefsFunc.nextHook()(v0, v1)
	m.InsertPackageRepoRefsFunc.appendCall(DependenciesServiceInsertPackageRepoRefsFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// InsertPackageRepoRefs method of the parent MockDependenciesService
// instance is invoked and the hook queue is empty.
func (f *DependenciesServiceInsertPackageRepoRefsFunc) SetDefaultHook(hook func(context.Context, []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertPackageRepoRefs method of the parent MockDependenciesService
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *DependenciesServiceInsertPackageRepoRefsFunc) PushHook(hook func(context.Context, []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DependenciesServiceInsertPackageRepoRefsFunc) SetDefaultReturn(r0 []shared.PackageRepoReference, r1 []shared.PackageRepoRefVersion, r2 error) {
	f.SetDefaultHook(func(context.Context, []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DependenciesServiceInsertPackageRepoRefsFunc) PushReturn(r0 []shared.PackageRepoReference, r1 []shared.PackageRepoRefVersion, r2 error) {
	f.PushHook(func(context.Context, []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error) {
		return r0, r1, r2
	})
}

func (f *DependenciesServiceInsertPackageRepoRefsFunc) nextHook() func(context.Context, []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DependenciesServiceInsertPackageRepoRefsFunc) appendCall(r0 DependenciesServiceInsertPackageRepoRefsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// DependenciesServiceInsertPackageRepoRefsFuncCall objects describing the
// invocations of this function.
func (f *DependenciesServiceInsertPackageRepoRefsFunc) History() []DependenciesServiceInsertPackageRepoRefsFuncCall {
	f.mutex.Lock()
	history := make([]DependenciesServiceInsertPackageRepoRefsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DependenciesServiceInsertPackageRepoRefsFuncCall is an object that
// describes an invocation of method InsertPackageRepoRefs on an instance of
// MockDependenciesService.
type DependenciesServiceInsertPackageRepoRefsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []shared.MinimalPackageRepoRef
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared.PackageRepoReference
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 []shared.PackageRepoRefVersion
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DependenciesServiceInsertPackageRepoRefsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DependenciesServiceInsertPackageRepoRefsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// MockExternalServiceStore is a mock implementation of the
// ExternalServiceStore interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/autoindexing/internal/background)
// used for unit testing.
type MockExternalServiceStore struct {
	// ListFunc is an instance of a mock function object controlling the
	// behavior of the method List.
	ListFunc *ExternalServiceStoreListFunc
	// UpsertFunc is an instance of a mock function object controlling the
	// behavior of the method Upsert.
	UpsertFunc *ExternalServiceStoreUpsertFunc
}

// NewMockExternalServiceStore creates a new mock of the
// ExternalServiceStore interface. All methods return zero values for all
// results, unless overwritten.
func NewMockExternalServiceStore() *MockExternalServiceStore {
	return &MockExternalServiceStore{
		ListFunc: &ExternalServiceStoreListFunc{
			defaultHook: func(context.Context, database.ExternalServicesListOptions) (r0 []*types.ExternalService, r1 error) {
				return
			},
		},
		UpsertFunc: &ExternalServiceStoreUpsertFunc{
			defaultHook: func(context.Context, ...*types.ExternalService) (r0 error) {
				return
			},
		},
	}
}

// NewStrictMockExternalServiceStore creates a new mock of the
// ExternalServiceStore interface. All methods panic on invocation, unless
// overwritten.
func NewStrictMockExternalServiceStore() *MockExternalServiceStore {
	return &MockExternalServiceStore{
		ListFunc: &ExternalServiceStoreListFunc{
			defaultHook: func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error) {
				panic("unexpected invocation of MockExternalServiceStore.List")
			},
		},
		UpsertFunc: &ExternalServiceStoreUpsertFunc{
			defaultHook: func(context.Context, ...*types.ExternalService) error {
				panic("unexpected invocation of MockExternalServiceStore.Upsert")
			},
		},
	}
}

// NewMockExternalServiceStoreFrom creates a new mock of the
// MockExternalServiceStore interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockExternalServiceStoreFrom(i ExternalServiceStore) *MockExternalServiceStore {
	return &MockExternalServiceStore{
		ListFunc: &ExternalServiceStoreListFunc{
			defaultHook: i.List,
		},
		UpsertFunc: &ExternalServiceStoreUpsertFunc{
			defaultHook: i.Upsert,
		},
	}
}

// ExternalServiceStoreListFunc describes the behavior when the List method
// of the parent MockExternalServiceStore instance is invoked.
type ExternalServiceStoreListFunc struct {
	defaultHook func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error)
	hooks       []func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error)
	history     []ExternalServiceStoreListFuncCall
	mutex       sync.Mutex
}

// List delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockExternalServiceStore) List(v0 context.Context, v1 database.ExternalServicesListOptions) ([]*types.ExternalService, error) {
	r0, r1 := m.ListFunc.nextHook()(v0, v1)
	m.ListFunc.appendCall(ExternalServiceStoreListFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the List method of the
// parent MockExternalServiceStore instance is invoked and the hook queue is
// empty.
func (f *ExternalServiceStoreListFunc) SetDefaultHook(hook func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// List method of the parent MockExternalServiceStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ExternalServiceStoreListFunc) PushHook(hook func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ExternalServiceStoreListFunc) SetDefaultReturn(r0 []*types.ExternalService, r1 error) {
	f.SetDefaultHook(func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ExternalServiceStoreListFunc) PushReturn(r0 []*types.ExternalService, r1 error) {
	f.PushHook(func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error) {
		return r0, r1
	})
}

func (f *ExternalServiceStoreListFunc) nextHook() func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ExternalServiceStoreListFunc) appendCall(r0 ExternalServiceStoreListFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ExternalServiceStoreListFuncCall objects
// describing the invocations of this function.
func (f *ExternalServiceStoreListFunc) History() []ExternalServiceStoreListFuncCall {
	f.mutex.Lock()
	history := make([]ExternalServiceStoreListFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ExternalServiceStoreListFuncCall is an object that describes an
// invocation of method List on an instance of MockExternalServiceStore.
type ExternalServiceStoreListFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 database.ExternalServicesListOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []*types.ExternalService
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ExternalServiceStoreListFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ExternalServiceStoreListFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// ExternalServiceStoreUpsertFunc describes the behavior when the Upsert
// method of the parent MockExternalServiceStore instance is invoked.
type ExternalServiceStoreUpsertFunc struct {
	defaultHook func(context.Context, ...*types.ExternalService) error
	hooks       []func(context.Context, ...*types.ExternalService) error
	history     []ExternalServiceStoreUpsertFuncCall
	mutex       sync.Mutex
}

// Upsert delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockExternalServiceStore) Upsert(v0 context.Context, v1 ...*types.ExternalService) error {
	r0 := m.UpsertFunc.nextHook()(v0, v1...)
	m.UpsertFunc.appendCall(ExternalServiceStoreUpsertFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Upsert method of the
// parent MockExternalServiceStore instance is invoked and the hook queue is
// empty.
func (f *ExternalServiceStoreUpsertFunc) SetDefaultHook(hook func(context.Context, ...*types.ExternalService) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Upsert method of the parent MockExternalServiceStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ExternalServiceStoreUpsertFunc) PushHook(hook func(context.Context, ...*types.ExternalService) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ExternalServiceStoreUpsertFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, ...*types.ExternalService) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ExternalServiceStoreUpsertFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, ...*types.ExternalService) error {
		return r0
	})
}

func (f *ExternalServiceStoreUpsertFunc) nextHook() func(context.Context, ...*types.ExternalService) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ExternalServiceStoreUpsertFunc) appendCall(r0 ExternalServiceStoreUpsertFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ExternalServiceStoreUpsertFuncCall objects
// describing the invocations of this function.
func (f *ExternalServiceStoreUpsertFunc) History() []ExternalServiceStoreUpsertFuncCall {
	f.mutex.Lock()
	history := make([]ExternalServiceStoreUpsertFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ExternalServiceStoreUpsertFuncCall is an object that describes an
// invocation of method Upsert on an instance of MockExternalServiceStore.
type ExternalServiceStoreUpsertFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []*types.ExternalService
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c ExternalServiceStoreUpsertFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ExternalServiceStoreUpsertFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// MockGitserverClient is a mock implementation of the GitserverClient
// interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/autoindexing/internal/background)
// used for unit testing.
type MockGitserverClient struct {
	// CommitDateFunc is an instance of a mock function object controlling
	// the behavior of the method CommitDate.
	CommitDateFunc *GitserverClientCommitDateFunc
	// CommitExistsFunc is an instance of a mock function object controlling
	// the behavior of the method CommitExists.
	CommitExistsFunc *GitserverClientCommitExistsFunc
	// CommitsUniqueToBranchFunc is an instance of a mock function object
	// controlling the behavior of the method CommitsUniqueToBranch.
	CommitsUniqueToBranchFunc *GitserverClientCommitsUniqueToBranchFunc
	// FileExistsFunc is an instance of a mock function object controlling
	// the behavior of the method FileExists.
	FileExistsFunc *GitserverClientFileExistsFunc
	// HeadFunc is an instance of a mock function object controlling the
	// behavior of the method Head.
	HeadFunc *GitserverClientHeadFunc
	// ListFilesFunc is an instance of a mock function object controlling
	// the behavior of the method ListFiles.
	ListFilesFunc *GitserverClientListFilesFunc
	// ListTagsFunc is an instance of a mock function object controlling the
	// behavior of the method ListTags.
	ListTagsFunc *GitserverClientListTagsFunc
	// RawContentsFunc is an instance of a mock function object controlling
	// the behavior of the method RawContents.
	RawContentsFunc *GitserverClientRawContentsFunc
	// RefDescriptionsFunc is an instance of a mock function object
	// controlling the behavior of the method RefDescriptions.
	RefDescriptionsFunc *GitserverClientRefDescriptionsFunc
	// ResolveRevisionFunc is an instance of a mock function object
	// controlling the behavior of the method ResolveRevision.
	ResolveRevisionFunc *GitserverClientResolveRevisionFunc
}

// NewMockGitserverClient creates a new mock of the GitserverClient
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockGitserverClient() *MockGitserverClient {
	return &MockGitserverClient{
		CommitDateFunc: &GitserverClientCommitDateFunc{
			defaultHook: func(context.Context, int, string) (r0 string, r1 time.Time, r2 bool, r3 error) {
				return
			},
		},
		CommitExistsFunc: &GitserverClientCommitExistsFunc{
			defaultHook: func(context.Context, int, string) (r0 bool, r1 error) {
				return
			},
		},
		CommitsUniqueToBranchFunc: &GitserverClientCommitsUniqueToBranchFunc{
			defaultHook: func(context.Context, int, string, bool, *time.Time) (r0 map[string]time.Time, r1 error) {
				return
			},
		},
		FileExistsFunc: &GitserverClientFileExistsFunc{
			defaultHook: func(context.Context, int, string, string) (r0 bool, r1 error) {
				return
			},
		},
		HeadFunc: &GitserverClientHeadFunc{
			defaultHook: func(context.Context, int) (r0 string, r1 bool, r2 error) {
				return
			},
		},
		ListFilesFunc: &GitserverClientListFilesFunc{
			defaultHook: func(context.Context, int, string, *regexp.Regexp) (r0 []string, r1 error) {
				return
			},
		},
		ListTagsFunc: &GitserverClientListTagsFunc{
			defaultHook: func(context.Context, api.RepoName, ...string) (r0 []*gitdomain.Tag, r1 error) {
				return
			},
		},
		RawContentsFunc: &GitserverClientRawContentsFunc{
			defaultHook: func(context.Context, int, string, string) (r0 []byte, r1 error) {
				return
			},
		},
		RefDescriptionsFunc: &GitserverClientRefDescriptionsFunc{
			defaultHook: func(context.Context, int, ...string) (r0 map[string][]gitdomain.RefDescription, r1 error) {
				return
			},
		},
		ResolveRevisionFunc: &GitserverClientResolveRevisionFunc{
			defaultHook: func(context.Context, int, string) (r0 api.CommitID, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockGitserverClient creates a new mock of the GitserverClient
// interface. All methods panic on invocation, unless overwritten.
func NewStrictMockGitserverClient() *MockGitserverClient {
	return &MockGitserverClient{
		CommitDateFunc: &GitserverClientCommitDateFunc{
			defaultHook: func(context.Context, int, string) (string, time.Time, bool, error) {
				panic("unexpected invocation of MockGitserverClient.CommitDate")
			},
		},
		CommitExistsFunc: &GitserverClientCommitExistsFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				panic("unexpected invocation of MockGitserverClient.CommitExists")
			},
		},
		CommitsUniqueToBranchFunc: &GitserverClientCommitsUniqueToBranchFunc{
			defaultHook: func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error) {
				panic("unexpected invocation of MockGitserverClient.CommitsUniqueToBranch")
			},
		},
		FileExistsFunc: &GitserverClientFileExistsFunc{
			defaultHook: func(context.Context, int, string, string) (bool, error) {
				panic("unexpected invocation of MockGitserverClient.FileExists")
			},
		},
		HeadFunc: &GitserverClientHeadFunc{
			defaultHook: func(context.Context, int) (string, bool, error) {
				panic("unexpected invocation of MockGitserverClient.Head")
			},
		},
		ListFilesFunc: &GitserverClientListFilesFunc{
			defaultHook: func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
				panic("unexpected invocation of MockGitserverClient.ListFiles")
			},
		},
		ListTagsFunc: &GitserverClientListTagsFunc{
			defaultHook: func(context.Context, api.RepoName, ...string) ([]*gitdomain.Tag, error) {
				panic("unexpected invocation of MockGitserverClient.ListTags")
			},
		},
		RawContentsFunc: &GitserverClientRawContentsFunc{
			defaultHook: func(context.Context, int, string, string) ([]byte, error) {
				panic("unexpected invocation of MockGitserverClient.RawContents")
			},
		},
		RefDescriptionsFunc: &GitserverClientRefDescriptionsFunc{
			defaultHook: func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error) {
				panic("unexpected invocation of MockGitserverClient.RefDescriptions")
			},
		},
		ResolveRevisionFunc: &GitserverClientResolveRevisionFunc{
			defaultHook: func(context.Context, int, string) (api.CommitID, error) {
				panic("unexpected invocation of MockGitserverClient.ResolveRevision")
			},
		},
	}
}

// NewMockGitserverClientFrom creates a new mock of the MockGitserverClient
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockGitserverClientFrom(i GitserverClient) *MockGitserverClient {
	return &MockGitserverClient{
		CommitDateFunc: &GitserverClientCommitDateFunc{
			defaultHook: i.CommitDate,
		},
		CommitExistsFunc: &GitserverClientCommitExistsFunc{
			defaultHook: i.CommitExists,
		},
		CommitsUniqueToBranchFunc: &GitserverClientCommitsUniqueToBranchFunc{
			defaultHook: i.CommitsUniqueToBranch,
		},
		FileExistsFunc: &GitserverClientFileExistsFunc{
			defaultHook: i.FileExists,
		},
		HeadFunc: &GitserverClientHeadFunc{
			defaultHook: i.Head,
		},
		ListFilesFunc: &GitserverClientListFilesFunc{
			defaultHook: i.ListFiles,
		},
		ListTagsFunc: &GitserverClientListTagsFunc{
			defaultHook: i.ListTags,
		},
		RawContentsFunc: &GitserverClientRawContentsFunc{
			defaultHook: i.RawContents,
		},
		RefDescriptionsFunc: &GitserverClientRefDescriptionsFunc{
			defaultHook: i.RefDescriptions,
		},
		ResolveRevisionFunc: &GitserverClientResolveRevisionFunc{
			defaultHook: i.ResolveRevision,
		},
	}
}

// GitserverClientCommitDateFunc describes the behavior when the CommitDate
// method of the parent MockGitserverClient instance is invoked.
type GitserverClientCommitDateFunc struct {
	defaultHook func(context.Context, int, string) (string, time.Time, bool, error)
	hooks       []func(context.Context, int, string) (string, time.Time, bool, error)
	history     []GitserverClientCommitDateFuncCall
	mutex       sync.Mutex
}

// CommitDate delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverClient) CommitDate(v0 context.Context, v1 int, v2 string) (string, time.Time, bool, error) {
	r0, r1, r2, r3 := m.CommitDateFunc.nextHook()(v0, v1, v2)
	m.CommitDateFunc.appendCall(GitserverClientCommitDateFuncCall{v0, v1, v2, r0, r1, r2, r3})
	return r0, r1, r2, r3
}

// SetDefaultHook sets function that is called when the CommitDate method of
// the parent MockGitserverClient instance is invoked and the hook queue is
// empty.
func (f *GitserverClientCommitDateFunc) SetDefaultHook(hook func(context.Context, int, string) (string, time.Time, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitDate method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientCommitDateFunc) PushHook(hook func(context.Context, int, string) (string, time.Time, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientCommitDateFunc) SetDefaultReturn(r0 string, r1 time.Time, r2 bool, r3 error) {
	f.SetDefaultHook(func(context.Context, int, string) (string, time.Time, bool, error) {
		return r0, r1, r2, r3
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientCommitDateFunc) PushReturn(r0 string, r1 time.Time, r2 bool, r3 error) {
	f.PushHook(func(context.Context, int, string) (string, time.Time, bool, error) {
		return r0, r1, r2, r3
	})
}

func (f *GitserverClientCommitDateFunc) nextHook() func(context.Context, int, string) (string, time.Time, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientCommitDateFunc) appendCall(r0 GitserverClientCommitDateFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientCommitDateFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientCommitDateFunc) History() []GitserverClientCommitDateFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientCommitDateFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientCommitDateFuncCall is an object that describes an
// invocation of method CommitDate on an instance of MockGitserverClient.
type GitserverClientCommitDateFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 time.Time
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 bool
	// Result3 is the value of the 4th result returned from this method
	// invocation.
	Result3 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientCommitDateFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientCommitDateFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2, c.Result3}
}

// GitserverClientCommitExistsFunc describes the behavior when the
// CommitExists method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientCommitExistsFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []GitserverClientCommitExistsFuncCall
	mutex       sync.Mutex
}

// CommitExists delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverClient) CommitExists(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.CommitExistsFunc.nextHook()(v0, v1, v2)
	m.CommitExistsFunc.appendCall(GitserverClientCommitExistsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the CommitExists method
// of the parent MockGitserverClient instance is invoked and the hook queue
// is empty.
func (f *GitserverClientCommitExistsFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitExists method of the parent MockGitserverClient instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitserverClientCommitExistsFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientCommitExistsFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientCommitExistsFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *GitserverClientCommitExistsFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientCommitExistsFunc) appendCall(r0 GitserverClientCommitExistsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientCommitExistsFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientCommitExistsFunc) History() []GitserverClientCommitExistsFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientCommitExistsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientCommitExistsFuncCall is an object that describes an
// invocation of method CommitExists on an instance of MockGitserverClient.
type GitserverClientCommitExistsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientCommitExistsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientCommitExistsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientCommitsUniqueToBranchFunc describes the behavior when the
// CommitsUniqueToBranch method of the parent MockGitserverClient instance
// is invoked.
type GitserverClientCommitsUniqueToBranchFunc struct {
	defaultHook func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error)
	hooks       []func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error)
	history     []GitserverClientCommitsUniqueToBranchFuncCall
	mutex       sync.Mutex
}

// CommitsUniqueToBranch delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockGitserverClient) CommitsUniqueToBranch(v0 context.Context, v1 int, v2 string, v3 bool, v4 *time.Time) (map[string]time.Time, error) {
	r0, r1 := m.CommitsUniqueToBranchFunc.nextHook()(v0, v1, v2, v3, v4)
	m.CommitsUniqueToBranchFunc.appendCall(GitserverClientCommitsUniqueToBranchFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CommitsUniqueToBranch method of the parent MockGitserverClient instance
// is invoked and the hook queue is empty.
func (f *GitserverClientCommitsUniqueToBranchFunc) SetDefaultHook(hook func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitsUniqueToBranch method of the parent MockGitserverClient instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *GitserverClientCommitsUniqueToBranchFunc) PushHook(hook func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientCommitsUniqueToBranchFunc) SetDefaultReturn(r0 map[string]time.Time, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientCommitsUniqueToBranchFunc) PushReturn(r0 map[string]time.Time, r1 error) {
	f.PushHook(func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error) {
		return r0, r1
	})
}

func (f *GitserverClientCommitsUniqueToBranchFunc) nextHook() func(context.Context, int, string, bool, *time.Time) (map[string]time.Time, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientCommitsUniqueToBranchFunc) appendCall(r0 GitserverClientCommitsUniqueToBranchFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// GitserverClientCommitsUniqueToBranchFuncCall objects describing the
// invocations of this function.
func (f *GitserverClientCommitsUniqueToBranchFunc) History() []GitserverClientCommitsUniqueToBranchFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientCommitsUniqueToBranchFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientCommitsUniqueToBranchFuncCall is an object that describes
// an invocation of method CommitsUniqueToBranch on an instance of
// MockGitserverClient.
type GitserverClientCommitsUniqueToBranchFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 bool
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 *time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[string]time.Time
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientCommitsUniqueToBranchFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientCommitsUniqueToBranchFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientFileExistsFunc describes the behavior when the FileExists
// method of the parent MockGitserverClient instance is invoked.
type GitserverClientFileExistsFunc struct {
	defaultHook func(context.Context, int, string, string) (bool, error)
	hooks       []func(context.Context, int, string, string) (bool, error)
	history     []GitserverClientFileExistsFuncCall
	mutex       sync.Mutex
}

// FileExists delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverClient) FileExists(v0 context.Context, v1 int, v2 string, v3 string) (bool, error) {
	r0, r1 := m.FileExistsFunc.nextHook()(v0, v1, v2, v3)
	m.FileExistsFunc.appendCall(GitserverClientFileExistsFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the FileExists method of
// the parent MockGitserverClient instance is invoked and the hook queue is
// empty.
func (f *GitserverClientFileExistsFunc) SetDefaultHook(hook func(context.Context, int, string, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// FileExists method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientFileExistsFunc) PushHook(hook func(context.Context, int, string, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientFileExistsFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientFileExistsFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string, string) (bool, error) {
		return r0, r1
	})
}

func (f *GitserverClientFileExistsFunc) nextHook() func(context.Context, int, string, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientFileExistsFunc) appendCall(r0 GitserverClientFileExistsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientFileExistsFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientFileExistsFunc) History() []GitserverClientFileExistsFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientFileExistsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientFileExistsFuncCall is an object that describes an
// invocation of method FileExists on an instance of MockGitserverClient.
type GitserverClientFileExistsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientFileExistsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientFileExistsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientHeadFunc describes the behavior when the Head method of
// the parent MockGitserverClient instance is invoked.
type GitserverClientHeadFunc struct {
	defaultHook func(context.Context, int) (string, bool, error)
	hooks       []func(context.Context, int) (string, bool, error)
	history     []GitserverClientHeadFuncCall
	mutex       sync.Mutex
}

// Head delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockGitserverClient) Head(v0 context.Context, v1 int) (string, bool, error) {
	r0, r1, r2 := m.HeadFunc.nextHook()(v0, v1)
	m.HeadFunc.appendCall(GitserverClientHeadFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Head method of the
// parent MockGitserverClient instance is invoked and the hook queue is
// empty.
func (f *GitserverClientHeadFunc) SetDefaultHook(hook func(context.Context, int) (string, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Head method of the parent MockGitserverClient instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *GitserverClientHeadFunc) PushHook(hook func(context.Context, int) (string, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientHeadFunc) SetDefaultReturn(r0 string, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (string, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientHeadFunc) PushReturn(r0 string, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (string, bool, error) {
		return r0, r1, r2
	})
}

func (f *GitserverClientHeadFunc) nextHook() func(context.Context, int) (string, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientHeadFunc) appendCall(r0 GitserverClientHeadFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientHeadFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientHeadFunc) History() []GitserverClientHeadFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientHeadFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientHeadFuncCall is an object that describes an invocation of
// method Head on an instance of MockGitserverClient.
type GitserverClientHeadFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientHeadFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientHeadFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// GitserverClientListFilesFunc describes the behavior when the ListFiles
// method of the parent MockGitserverClient instance is invoked.
type GitserverClientListFilesFunc struct {
	defaultHook func(context.Context, int, string, *regexp.Regexp) ([]string, error)
	hooks       []func(context.Context, int, string, *regexp.Regexp) ([]string, error)
	history     []GitserverClientListFilesFuncCall
	mutex       sync.Mutex
}

// ListFiles delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockGitserverClient) ListFiles(v0 context.Context, v1 int, v2 string, v3 *regexp.Regexp) ([]string, error) {
	r0, r1 := m.ListFilesFunc.nextHook()(v0, v1, v2, v3)
	m.ListFilesFunc.appendCall(GitserverClientListFilesFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ListFiles method of
// the parent MockGitserverClient instance is invoked and the hook queue is
// empty.
func (f *GitserverClientListFilesFunc) SetDefaultHook(hook func(context.Context, int, string, *regexp.Regexp) ([]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ListFiles method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientListFilesFunc) PushHook(hook func(context.Context, int, string, *regexp.Regexp) ([]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientListFilesFunc) SetDefaultReturn(r0 []string, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientListFilesFunc) PushReturn(r0 []string, r1 error) {
	f.PushHook(func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
		return r0, r1
	})
}

func (f *GitserverClientListFilesFunc) nextHook() func(context.Context, int, string, *regexp.Regexp) ([]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientListFilesFunc) appendCall(r0 GitserverClientListFilesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientListFilesFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientListFilesFunc) History() []GitserverClientListFilesFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientListFilesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientListFilesFuncCall is an object that describes an
// invocation of method ListFiles on an instance of MockGitserverClient.
type GitserverClientListFilesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 *regexp.Regexp
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientListFilesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientListFilesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientListTagsFunc describes the behavior when the ListTags
// method of the parent MockGitserverClient instance is invoked.
type GitserverClientListTagsFunc struct {
	defaultHook func(context.Context, api.RepoName, ...string) ([]*gitdomain.Tag, error)
	hooks       []func(context.Context, api.RepoName, ...string) ([]*gitdomain.Tag, error)
	history     []GitserverClientListTagsFuncCall
	mutex       sync.Mutex
}

// ListTags delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockGitserverClient) ListTags(v0 context.Context, v1 api.RepoName, v2 ...string) ([]*gitdomain.Tag, error) {
	r0, r1 := m.ListTagsFunc.nextHook()(v0, v1, v2...)
	m.ListTagsFunc.appendCall(GitserverClientListTagsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ListTags method of
// the parent MockGitserverClient instance is invoked and the hook queue is
// empty.
func (f *GitserverClientListTagsFunc) SetDefaultHook(hook func(context.Context, api.RepoName, ...string) ([]*gitdomain.Tag, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ListTags method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientListTagsFunc) PushHook(hook func(context.Context, api.RepoName, ...string) ([]*gitdomain.Tag, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientListTagsFunc) SetDefaultReturn(r0 []*gitdomain.Tag, r1 error) {
	f.SetDefaultHook(func(context.Context, api.RepoName, ...string) ([]*gitdomain.Tag, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientListTagsFunc) PushReturn(r0 []*gitdomain.Tag, r1 error) {
	f.PushHook(func(context.Context, api.RepoName, ...string) ([]*gitdomain.Tag, error) {
		return r0, r1
	})
}

func (f *GitserverClientListTagsFunc) nextHook() func(context.Context, api.RepoName, ...string) ([]*gitdomain.Tag, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientListTagsFunc) appendCall(r0 GitserverClientListTagsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientListTagsFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientListTagsFunc) History() []GitserverClientListTagsFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientListTagsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientListTagsFuncCall is an object that describes an invocation
// of method ListTags on an instance of MockGitserverClient.
type GitserverClientListTagsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 api.RepoName
	// Arg2 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg2 []string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []*gitdomain.Tag
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c GitserverClientListTagsFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg2 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0, c.Arg1}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientListTagsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientRawContentsFunc describes the behavior when the
// RawContents method of the parent MockGitserverClient instance is invoked.
type GitserverClientRawContentsFunc struct {
	defaultHook func(context.Context, int, string, string) ([]byte, error)
	hooks       []func(context.Context, int, string, string) ([]byte, error)
	history     []GitserverClientRawContentsFuncCall
	mutex       sync.Mutex
}

// RawContents delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverClient) RawContents(v0 context.Context, v1 int, v2 string, v3 string) ([]byte, error) {
	r0, r1 := m.RawContentsFunc.nextHook()(v0, v1, v2, v3)
	m.RawContentsFunc.appendCall(GitserverClientRawContentsFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RawContents method
// of the parent MockGitserverClient instance is invoked and the hook queue
// is empty.
func (f *GitserverClientRawContentsFunc) SetDefaultHook(hook func(context.Context, int, string, string) ([]byte, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RawContents method of the parent MockGitserverClient instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *GitserverClientRawContentsFunc) PushHook(hook func(context.Context, int, string, string) ([]byte, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientRawContentsFunc) SetDefaultReturn(r0 []byte, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string) ([]byte, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientRawContentsFunc) PushReturn(r0 []byte, r1 error) {
	f.PushHook(func(context.Context, int, string, string) ([]byte, error) {
		return r0, r1
	})
}

func (f *GitserverClientRawContentsFunc) nextHook() func(context.Context, int, string, string) ([]byte, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientRawContentsFunc) appendCall(r0 GitserverClientRawContentsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientRawContentsFuncCall objects
// describing the invocations of this function.
func (f *GitserverClientRawContentsFunc) History() []GitserverClientRawContentsFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientRawContentsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientRawContentsFuncCall is an object that describes an
// invocation of method RawContents on an instance of MockGitserverClient.
type GitserverClientRawContentsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []byte
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientRawContentsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientRawContentsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientRefDescriptionsFunc describes the behavior when the
// RefDescriptions method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientRefDescriptionsFunc struct {
	defaultHook func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error)
	hooks       []func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error)
	history     []GitserverClientRefDescriptionsFuncCall
	mutex       sync.Mutex
}

// RefDescriptions delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockGitserverClient) RefDescriptions(v0 context.Context, v1 int, v2 ...string) (map[string][]gitdomain.RefDescription, error) {
	r0, r1 := m.RefDescriptionsFunc.nextHook()(v0, v1, v2...)
	m.RefDescriptionsFunc.appendCall(GitserverClientRefDescriptionsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RefDescriptions
// method of the parent MockGitserverClient instance is invoked and the hook
// queue is empty.
func (f *GitserverClientRefDescriptionsFunc) SetDefaultHook(hook func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RefDescriptions method of the parent MockGitserverClient instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitserverClientRefDescriptionsFunc) PushHook(hook func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientRefDescriptionsFunc) SetDefaultReturn(r0 map[string][]gitdomain.RefDescription, r1 error) {
	f.SetDefaultHook(func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientRefDescriptionsFunc) PushReturn(r0 map[string][]gitdomain.RefDescription, r1 error) {
	f.PushHook(func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error) {
		return r0, r1
	})
}

func (f *GitserverClientRefDescriptionsFunc) nextHook() func(context.Context, int, ...string) (map[string][]gitdomain.RefDescription, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientRefDescriptionsFunc) appendCall(r0 GitserverClientRefDescriptionsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientRefDescriptionsFuncCall
// objects describing the invocations of this function.
func (f *GitserverClientRefDescriptionsFunc) History() []GitserverClientRefDescriptionsFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientRefDescriptionsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientRefDescriptionsFuncCall is an object that describes an
// invocation of method RefDescriptions on an instance of
// MockGitserverClient.
type GitserverClientRefDescriptionsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg2 []string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[string][]gitdomain.RefDescription
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c GitserverClientRefDescriptionsFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg2 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0, c.Arg1}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientRefDescriptionsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// GitserverClientResolveRevisionFunc describes the behavior when the
// ResolveRevision method of the parent MockGitserverClient instance is
// invoked.
type GitserverClientResolveRevisionFunc struct {
	defaultHook func(context.Context, int, string) (api.CommitID, error)
	hooks       []func(context.Context, int, string) (api.CommitID, error)
	history     []GitserverClientResolveRevisionFuncCall
	mutex       sync.Mutex
}

// ResolveRevision delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockGitserverClient) ResolveRevision(v0 context.Context, v1 int, v2 string) (api.CommitID, error) {
	r0, r1 := m.ResolveRevisionFunc.nextHook()(v0, v1, v2)
	m.ResolveRevisionFunc.appendCall(GitserverClientResolveRevisionFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ResolveRevision
// method of the parent MockGitserverClient instance is invoked and the hook
// queue is empty.
func (f *GitserverClientResolveRevisionFunc) SetDefaultHook(hook func(context.Context, int, string) (api.CommitID, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ResolveRevision method of the parent MockGitserverClient instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitserverClientResolveRevisionFunc) PushHook(hook func(context.Context, int, string) (api.CommitID, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverClientResolveRevisionFunc) SetDefaultReturn(r0 api.CommitID, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (api.CommitID, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverClientResolveRevisionFunc) PushReturn(r0 api.CommitID, r1 error) {
	f.PushHook(func(context.Context, int, string) (api.CommitID, error) {
		return r0, r1
	})
}

func (f *GitserverClientResolveRevisionFunc) nextHook() func(context.Context, int, string) (api.CommitID, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverClientResolveRevisionFunc) appendCall(r0 GitserverClientResolveRevisionFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverClientResolveRevisionFuncCall
// objects describing the invocations of this function.
func (f *GitserverClientResolveRevisionFunc) History() []GitserverClientResolveRevisionFuncCall {
	f.mutex.Lock()
	history := make([]GitserverClientResolveRevisionFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverClientResolveRevisionFuncCall is an object that describes an
// invocation of method ResolveRevision on an instance of
// MockGitserverClient.
type GitserverClientResolveRevisionFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 api.CommitID
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c GitserverClientResolveRevisionFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverClientResolveRevisionFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockGitserverRepoStore is a mock implementation of the GitserverRepoStore
// interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/autoindexing/internal/background)
// used for unit testing.
type MockGitserverRepoStore struct {
	// GetByNamesFunc is an instance of a mock function object controlling
	// the behavior of the method GetByNames.
	GetByNamesFunc *GitserverRepoStoreGetByNamesFunc
}

// NewMockGitserverRepoStore creates a new mock of the GitserverRepoStore
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockGitserverRepoStore() *MockGitserverRepoStore {
	return &MockGitserverRepoStore{
		GetByNamesFunc: &GitserverRepoStoreGetByNamesFunc{
			defaultHook: func(context.Context, ...api.RepoName) (r0 map[api.RepoName]*types.GitserverRepo, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockGitserverRepoStore creates a new mock of the
// GitserverRepoStore interface. All methods panic on invocation, unless
// overwritten.
func NewStrictMockGitserverRepoStore() *MockGitserverRepoStore {
	return &MockGitserverRepoStore{
		GetByNamesFunc: &GitserverRepoStoreGetByNamesFunc{
			defaultHook: func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error) {
				panic("unexpected invocation of MockGitserverRepoStore.GetByNames")
			},
		},
	}
}

// NewMockGitserverRepoStoreFrom creates a new mock of the
// MockGitserverRepoStore interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockGitserverRepoStoreFrom(i GitserverRepoStore) *MockGitserverRepoStore {
	return &MockGitserverRepoStore{
		GetByNamesFunc: &GitserverRepoStoreGetByNamesFunc{
			defaultHook: i.GetByNames,
		},
	}
}

// GitserverRepoStoreGetByNamesFunc describes the behavior when the
// GetByNames method of the parent MockGitserverRepoStore instance is
// invoked.
type GitserverRepoStoreGetByNamesFunc struct {
	defaultHook func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error)
	hooks       []func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error)
	history     []GitserverRepoStoreGetByNamesFuncCall
	mutex       sync.Mutex
}

// GetByNames delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverRepoStore) GetByNames(v0 context.Context, v1 ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error) {
	r0, r1 := m.GetByNamesFunc.nextHook()(v0, v1...)
	m.GetByNamesFunc.appendCall(GitserverRepoStoreGetByNamesFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetByNames method of
// the parent MockGitserverRepoStore instance is invoked and the hook queue
// is empty.
func (f *GitserverRepoStoreGetByNamesFunc) SetDefaultHook(hook func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetByNames method of the parent MockGitserverRepoStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitserverRepoStoreGetByNamesFunc) PushHook(hook func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverRepoStoreGetByNamesFunc) SetDefaultReturn(r0 map[api.RepoName]*types.GitserverRepo, r1 error) {
	f.SetDefaultHook(func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverRepoStoreGetByNamesFunc) PushReturn(r0 map[api.RepoName]*types.GitserverRepo, r1 error) {
	f.PushHook(func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error) {
		return r0, r1
	})
}

func (f *GitserverRepoStoreGetByNamesFunc) nextHook() func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverRepoStoreGetByNamesFunc) appendCall(r0 GitserverRepoStoreGetByNamesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverRepoStoreGetByNamesFuncCall
// objects describing the invocations of this function.
func (f *GitserverRepoStoreGetByNamesFunc) History() []GitserverRepoStoreGetByNamesFuncCall {
	f.mutex.Lock()
	history := make([]GitserverRepoStoreGetByNamesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverRepoStoreGetByNamesFuncCall is an object that describes an
// invocation of method GetByNames on an instance of MockGitserverRepoStore.
type GitserverRepoStoreGetByNamesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []api.RepoName
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[api.RepoName]*types.GitserverRepo
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c GitserverRepoStoreGetByNamesFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverRepoStoreGetByNamesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockIndexEnqueuer is a mock implementation of the IndexEnqueuer interface
// (from the package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/autoindexing/internal/background)
// used for unit testing.
type MockIndexEnqueuer struct {
	// QueueIndexesFunc is an instance of a mock function object controlling
	// the behavior of the method QueueIndexes.
	QueueIndexesFunc *IndexEnqueuerQueueIndexesFunc
	// QueueIndexesForPackageFunc is an instance of a mock function object
	// controlling the behavior of the method QueueIndexesForPackage.
	QueueIndexesForPackageFunc *IndexEnqueuerQueueIndexesForPackageFunc
}

// NewMockIndexEnqueuer creates a new mock of the IndexEnqueuer interface.
// All methods return zero values for all results, unless overwritten.
func NewMockIndexEnqueuer() *MockIndexEnqueuer {
	return &MockIndexEnqueuer{
		QueueIndexesFunc: &IndexEnqueuerQueueIndexesFunc{
			defaultHook: func(context.Context, int, string, string, bool, bool) (r0 []types1.Index, r1 error) {
				return
			},
		},
		QueueIndexesForPackageFunc: &IndexEnqueuerQueueIndexesForPackageFunc{
			defaultHook: func(context.Context, precise.Package) (r0 error) {
				return
			},
		},
	}
}

// NewStrictMockIndexEnqueuer creates a new mock of the IndexEnqueuer
// interface. All methods panic on invocation, unless overwritten.
func NewStrictMockIndexEnqueuer() *MockIndexEnqueuer {
	return &MockIndexEnqueuer{
		QueueIndexesFunc: &IndexEnqueuerQueueIndexesFunc{
			defaultHook: func(context.Context, int, string, string, bool, bool) ([]types1.Index, error) {
				panic("unexpected invocation of MockIndexEnqueuer.QueueIndexes")
			},
		},
		QueueIndexesForPackageFunc: &IndexEnqueuerQueueIndexesForPackageFunc{
			defaultHook: func(context.Context, precise.Package) error {
				panic("unexpected invocation of MockIndexEnqueuer.QueueIndexesForPackage")
			},
		},
	}
}

// NewMockIndexEnqueuerFrom creates a new mock of the MockIndexEnqueuer
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockIndexEnqueuerFrom(i IndexEnqueuer) *MockIndexEnqueuer {
	return &MockIndexEnqueuer{
		QueueIndexesFunc: &IndexEnqueuerQueueIndexesFunc{
			defaultHook: i.QueueIndexes,
		},
		QueueIndexesForPackageFunc: &IndexEnqueuerQueueIndexesForPackageFunc{
			defaultHook: i.QueueIndexesForPackage,
		},
	}
}

// IndexEnqueuerQueueIndexesFunc describes the behavior when the
// QueueIndexes method of the parent MockIndexEnqueuer instance is invoked.
type IndexEnqueuerQueueIndexesFunc struct {
	defaultHook func(context.Context, int, string, string, bool, bool) ([]types1.Index, error)
	hooks       []func(context.Context, int, string, string, bool, bool) ([]types1.Index, error)
	history     []IndexEnqueuerQueueIndexesFuncCall
	mutex       sync.Mutex
}

// QueueIndexes delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockIndexEnqueuer) QueueIndexes(v0 context.Context, v1 int, v2 string, v3 string, v4 bool, v5 bool) ([]types1.Index, error) {
	r0, r1 := m.QueueIndexesFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.QueueIndexesFunc.appendCall(IndexEnqueuerQueueIndexesFuncCall{v0, v1, v2, v3, v4, v5, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the QueueIndexes method
// of the parent MockIndexEnqueuer instance is invoked and the hook queue is
// empty.
func (f *IndexEnqueuerQueueIndexesFunc) SetDefaultHook(hook func(context.Context, int, string, string, bool, bool) ([]types1.Index, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// QueueIndexes method of the parent MockIndexEnqueuer instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *IndexEnqueuerQueueIndexesFunc) PushHook(hook func(context.Context, int, string, string, bool, bool) ([]types1.Index, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *IndexEnqueuerQueueIndexesFunc) SetDefaultReturn(r0 []types1.Index, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, bool, bool) ([]types1.Index, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *IndexEnqueuerQueueIndexesFunc) PushReturn(r0 []types1.Index, r1 error) {
	f.PushHook(func(context.Context, int, string, string, bool, bool) ([]types1.Index, error) {
		return r0, r1
	})
}

func (f *IndexEnqueuerQueueIndexesFunc) nextHook() func(context.Context, int, string, string, bool, bool) ([]types1.Index, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *IndexEnqueuerQueueIndexesFunc) appendCall(r0 IndexEnqueuerQueueIndexesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of IndexEnqueuerQueueIndexesFuncCall objects
// describing the invocations of this function.
func (f *IndexEnqueuerQueueIndexesFunc) History() []IndexEnqueuerQueueIndexesFuncCall {
	f.mutex.Lock()
	history := make([]IndexEnqueuerQueueIndexesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// IndexEnqueuerQueueIndexesFuncCall is an object that describes an
// invocation of method QueueIndexes on an instance of MockIndexEnqueuer.
type IndexEnqueuerQueueIndexesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 bool
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 bool
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types1.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c IndexEnqueuerQueueIndexesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c IndexEnqueuerQueueIndexesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// IndexEnqueuerQueueIndexesForPackageFunc describes the behavior when the
// QueueIndexesForPackage method of the parent MockIndexEnqueuer instance is
// invoked.
type IndexEnqueuerQueueIndexesForPackageFunc struct {
	defaultHook func(context.Context, precise.Package) error
	hooks       []func(context.Context, precise.Package) error
	history     []IndexEnqueuerQueueIndexesForPackageFuncCall
	mutex       sync.Mutex
}

// QueueIndexesForPackage delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockIndexEnqueuer) QueueIndexesForPackage(v0 context.Context, v1 precise.Package) error {
	r0 := m.QueueIndexesForPackageFunc.nextHook()(v0, v1)
	m.QueueIndexesForPackageFunc.appendCall(IndexEnqueuerQueueIndexesForPackageFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// QueueIndexesForPackage method of the parent MockIndexEnqueuer instance is
// invoked and the hook queue is empty.
func (f *IndexEnqueuerQueueIndexesForPackageFunc) SetDefaultHook(hook func(context.Context, precise.Package) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// QueueIndexesForPackage method of the parent MockIndexEnqueuer instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *IndexEnqueuerQueueIndexesForPackageFunc) PushHook(hook func(context.Context, precise.Package) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *IndexEnqueuerQueueIndexesForPackageFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, precise.Package) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *IndexEnqueuerQueueIndexesForPackageFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, precise.Package) error {
		return r0
	})
}

func (f *IndexEnqueuerQueueIndexesForPackageFunc) nextHook() func(context.Context, precise.Package) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *IndexEnqueuerQueueIndexesForPackageFunc) appendCall(r0 IndexEnqueuerQueueIndexesForPackageFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of IndexEnqueuerQueueIndexesForPackageFuncCall
// objects describing the invocations of this function.
func (f *IndexEnqueuerQueueIndexesForPackageFunc) History() []IndexEnqueuerQueueIndexesForPackageFuncCall {
	f.mutex.Lock()
	history := make([]IndexEnqueuerQueueIndexesForPackageFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// IndexEnqueuerQueueIndexesForPackageFuncCall is an object that describes
// an invocation of method QueueIndexesForPackage on an instance of
// MockIndexEnqueuer.
type IndexEnqueuerQueueIndexesForPackageFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 precise.Package
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c IndexEnqueuerQueueIndexesForPackageFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c IndexEnqueuerQueueIndexesForPackageFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// MockPolicyMatcher is a mock implementation of the PolicyMatcher interface
// (from the package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/autoindexing/internal/background)
// used for unit testing.
type MockPolicyMatcher struct {
	// CommitsDescribedByPolicyFunc is an instance of a mock function object
	// controlling the behavior of the method CommitsDescribedByPolicy.
	CommitsDescribedByPolicyFunc *PolicyMatcherCommitsDescribedByPolicyFunc
}

// NewMockPolicyMatcher creates a new mock of the PolicyMatcher interface.
// All methods return zero values for all results, unless overwritten.
func NewMockPolicyMatcher() *MockPolicyMatcher {
	return &MockPolicyMatcher{
		CommitsDescribedByPolicyFunc: &PolicyMatcherCommitsDescribedByPolicyFunc{
			defaultHook: func(context.Context, int, []types1.ConfigurationPolicy, time.Time, ...string) (r0 map[string][]enterprise.PolicyMatch, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockPolicyMatcher creates a new mock of the PolicyMatcher
// interface. All methods panic on invocation, unless overwritten.
func NewStrictMockPolicyMatcher() *MockPolicyMatcher {
	return &MockPolicyMatcher{
		CommitsDescribedByPolicyFunc: &PolicyMatcherCommitsDescribedByPolicyFunc{
			defaultHook: func(context.Context, int, []types1.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error) {
				panic("unexpected invocation of MockPolicyMatcher.CommitsDescribedByPolicy")
			},
		},
	}
}

// NewMockPolicyMatcherFrom creates a new mock of the MockPolicyMatcher
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockPolicyMatcherFrom(i PolicyMatcher) *MockPolicyMatcher {
	return &MockPolicyMatcher{
		CommitsDescribedByPolicyFunc: &PolicyMatcherCommitsDescribedByPolicyFunc{
			defaultHook: i.CommitsDescribedByPolicy,
		},
	}
}

// PolicyMatcherCommitsDescribedByPolicyFunc describes the behavior when the
// CommitsDescribedByPolicy method of the parent MockPolicyMatcher instance
// is invoked.
type PolicyMatcherCommitsDescribedByPolicyFunc struct {
	defaultHook func(context.Context, int, []types1.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error)
	hooks       []func(context.Context, int, []types1.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error)
	history     []PolicyMatcherCommitsDescribedByPolicyFuncCall
	mutex       sync.Mutex
}

// CommitsDescribedByPolicy delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockPolicyMatcher) CommitsDescribedByPolicy(v0 context.Context, v1 int, v2 []types1.ConfigurationPolicy, v3 time.Time, v4 ...string) (map[string][]enterprise.PolicyMatch, error) {
	r0, r1 := m.CommitsDescribedByPolicyFunc.nextHook()(v0, v1, v2, v3, v4...)
	m.CommitsDescribedByPolicyFunc.appendCall(PolicyMatcherCommitsDescribedByPolicyFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// CommitsDescribedByPolicy method of the parent MockPolicyMatcher instance
// is invoked and the hook queue is empty.
func (f *PolicyMatcherCommitsDescribedByPolicyFunc) SetDefaultHook(hook func(context.Context, int, []types1.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CommitsDescribedByPolicy method of the parent MockPolicyMatcher instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *PolicyMatcherCommitsDescribedByPolicyFunc) PushHook(hook func(context.Context, int, []types1.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *PolicyMatcherCommitsDescribedByPolicyFunc) SetDefaultReturn(r0 map[string][]enterprise.PolicyMatch, r1 error) {
	f.SetDefaultHook(func(context.Context, int, []types1.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *PolicyMatcherCommitsDescribedByPolicyFunc) PushReturn(r0 map[string][]enterprise.PolicyMatch, r1 error) {
	f.PushHook(func(context.Context, int, []types1.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error) {
		return r0, r1
	})
}

func (f *PolicyMatcherCommitsDescribedByPolicyFunc) nextHook() func(context.Context, int, []types1.ConfigurationPolicy, time.Time, ...string) (map[string][]enterprise.PolicyMatch, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *PolicyMatcherCommitsDescribedByPolicyFunc) appendCall(r0 PolicyMatcherCommitsDescribedByPolicyFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// PolicyMatcherCommitsDescribedByPolicyFuncCall objects describing the
// invocations of this function.
func (f *PolicyMatcherCommitsDescribedByPolicyFunc) History() []PolicyMatcherCommitsDescribedByPolicyFuncCall {
	f.mutex.Lock()
	history := make([]PolicyMatcherCommitsDescribedByPolicyFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// PolicyMatcherCommitsDescribedByPolicyFuncCall is an object that describes
// an invocation of method CommitsDescribedByPolicy on an instance of
// MockPolicyMatcher.
type PolicyMatcherCommitsDescribedByPolicyFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []types1.ConfigurationPolicy
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 time.Time
	// Arg4 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg4 []string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[string][]enterprise.PolicyMatch
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c PolicyMatcherCommitsDescribedByPolicyFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg4 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c PolicyMatcherCommitsDescribedByPolicyFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockRepoUpdaterClient is a mock implementation of the RepoUpdaterClient
// interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/autoindexing/internal/background)
// used for unit testing.
type MockRepoUpdaterClient struct {
	// EnqueueRepoUpdateFunc is an instance of a mock function object
	// controlling the behavior of the method EnqueueRepoUpdate.
	EnqueueRepoUpdateFunc *RepoUpdaterClientEnqueueRepoUpdateFunc
	// RepoLookupFunc is an instance of a mock function object controlling
	// the behavior of the method RepoLookup.
	RepoLookupFunc *RepoUpdaterClientRepoLookupFunc
}

// NewMockRepoUpdaterClient creates a new mock of the RepoUpdaterClient
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockRepoUpdaterClient() *MockRepoUpdaterClient {
	return &MockRepoUpdaterClient{
		EnqueueRepoUpdateFunc: &RepoUpdaterClientEnqueueRepoUpdateFunc{
			defaultHook: func(context.Context, api.RepoName) (r0 *protocol.RepoUpdateResponse, r1 error) {
				return
			},
		},
		RepoLookupFunc: &RepoUpdaterClientRepoLookupFunc{
			defaultHook: func(context.Context, protocol.RepoLookupArgs) (r0 *protocol.RepoLookupResult, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockRepoUpdaterClient creates a new mock of the
// RepoUpdaterClient interface. All methods panic on invocation, unless
// overwritten.
func NewStrictMockRepoUpdaterClient() *MockRepoUpdaterClient {
	return &MockRepoUpdaterClient{
		EnqueueRepoUpdateFunc: &RepoUpdaterClientEnqueueRepoUpdateFunc{
			defaultHook: func(context.Context, api.RepoName) (*protocol.RepoUpdateResponse, error) {
				panic("unexpected invocation of MockRepoUpdaterClient.EnqueueRepoUpdate")
			},
		},
		RepoLookupFunc: &RepoUpdaterClientRepoLookupFunc{
			defaultHook: func(context.Context, protocol.RepoLookupArgs) (*protocol.RepoLookupResult, error) {
				panic("unexpected invocation of MockRepoUpdaterClient.RepoLookup")
			},
		},
	}
}

// NewMockRepoUpdaterClientFrom creates a new mock of the
// MockRepoUpdaterClient interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockRepoUpdaterClientFrom(i RepoUpdaterClient) *MockRepoUpdaterClient {
	return &MockRepoUpdaterClient{
		EnqueueRepoUpdateFunc: &RepoUpdaterClientEnqueueRepoUpdateFunc{
			defaultHook: i.EnqueueRepoUpdate,
		},
		RepoLookupFunc: &RepoUpdaterClientRepoLookupFunc{
			defaultHook: i.RepoLookup,
		},
	}
}

// RepoUpdaterClientEnqueueRepoUpdateFunc describes the behavior when the
// EnqueueRepoUpdate method of the parent MockRepoUpdaterClient instance is
// invoked.
type RepoUpdaterClientEnqueueRepoUpdateFunc struct {
	defaultHook func(context.Context, api.RepoName) (*protocol.RepoUpdateResponse, error)
	hooks       []func(context.Context, api.RepoName) (*protocol.RepoUpdateResponse, error)
	history     []RepoUpdaterClientEnqueueRepoUpdateFuncCall
	mutex       sync.Mutex
}

// EnqueueRepoUpdate delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockRepoUpdaterClient) EnqueueRepoUpdate(v0 context.Context, v1 api.RepoName) (*protocol.RepoUpdateResponse, error) {
	r0, r1 := m.EnqueueRepoUpdateFunc.nextHook()(v0, v1)
	m.EnqueueRepoUpdateFunc.appendCall(RepoUpdaterClientEnqueueRepoUpdateFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the EnqueueRepoUpdate
// method of the parent MockRepoUpdaterClient instance is invoked and the
// hook queue is empty.
func (f *RepoUpdaterClientEnqueueRepoUpdateFunc) SetDefaultHook(hook func(context.Context, api.RepoName) (*protocol.RepoUpdateResponse, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// EnqueueRepoUpdate method of the parent MockRepoUpdaterClient instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *RepoUpdaterClientEnqueueRepoUpdateFunc) PushHook(hook func(context.Context, api.RepoName) (*protocol.RepoUpdateResponse, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *RepoUpdaterClientEnqueueRepoUpdateFunc) SetDefaultReturn(r0 *protocol.RepoUpdateResponse, r1 error) {
	f.SetDefaultHook(func(context.Context, api.RepoName) (*protocol.RepoUpdateResponse, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *RepoUpdaterClientEnqueueRepoUpdateFunc) PushReturn(r0 *protocol.RepoUpdateResponse, r1 error) {
	f.PushHook(func(context.Context, api.RepoName) (*protocol.RepoUpdateResponse, error) {
		return r0, r1
	})
}

func (f *RepoUpdaterClientEnqueueRepoUpdateFunc) nextHook() func(context.Context, api.RepoName) (*protocol.RepoUpdateResponse, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *RepoUpdaterClientEnqueueRepoUpdateFunc) appendCall(r0 RepoUpdaterClientEnqueueRepoUpdateFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of RepoUpdaterClientEnqueueRepoUpdateFuncCall
// objects describing the invocations of this function.
func (f *RepoUpdaterClientEnqueueRepoUpdateFunc) History() []RepoUpdaterClientEnqueueRepoUpdateFuncCall {
	f.mutex.Lock()
	history := make([]RepoUpdaterClientEnqueueRepoUpdateFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// RepoUpdaterClientEnqueueRepoUpdateFuncCall is an object that describes an
// invocation of method EnqueueRepoUpdate on an instance of
// MockRepoUpdaterClient.
type RepoUpdaterClientEnqueueRepoUpdateFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 api.RepoName
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *protocol.RepoUpdateResponse
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c RepoUpdaterClientEnqueueRepoUpdateFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c RepoUpdaterClientEnqueueRepoUpdateFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// RepoUpdaterClientRepoLookupFunc describes the behavior when the
// RepoLookup method of the parent MockRepoUpdaterClient instance is
// invoked.
type RepoUpdaterClientRepoLookupFunc struct {
	defaultHook func(context.Context, protocol.RepoLookupArgs) (*protocol.RepoLookupResult, error)
	hooks       []func(context.Context, protocol.RepoLookupArgs) (*protocol.RepoLookupResult, error)
	history     []RepoUpdaterClientRepoLookupFuncCall
	mutex       sync.Mutex
}

// RepoLookup delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockRepoUpdaterClient) RepoLookup(v0 context.Context, v1 protocol.RepoLookupArgs) (*protocol.RepoLookupResult, error) {
	r0, r1 := m.RepoLookupFunc.nextHook()(v0, v1)
	m.RepoLookupFunc.appendCall(RepoUpdaterClientRepoLookupFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepoLookup method of
// the parent MockRepoUpdaterClient instance is invoked and the hook queue
// is empty.
func (f *RepoUpdaterClientRepoLookupFunc) SetDefaultHook(hook func(context.Context, protocol.RepoLookupArgs) (*protocol.RepoLookupResult, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoLookup method of the parent MockRepoUpdaterClient instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *RepoUpdaterClientRepoLookupFunc) PushHook(hook func(context.Context, protocol.RepoLookupArgs) (*protocol.RepoLookupResult, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *RepoUpdaterClientRepoLookupFunc) SetDefaultReturn(r0 *protocol.RepoLookupResult, r1 error) {
	f.SetDefaultHook(func(context.Context, protocol.RepoLookupArgs) (*protocol.RepoLookupResult, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *RepoUpdaterClientRepoLookupFunc) PushReturn(r0 *protocol.RepoLookupResult, r1 error) {
	f.PushHook(func(context.Context, protocol.RepoLookupArgs) (*protocol.RepoLookupResult, error) {
		return r0, r1
	})
}

func (f *RepoUpdaterClientRepoLookupFunc) nextHook() func(context.Context, protocol.RepoLookupArgs) (*protocol.RepoLookupResult, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *RepoUpdaterClientRepoLookupFunc) appendCall(r0 RepoUpdaterClientRepoLookupFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of RepoUpdaterClientRepoLookupFuncCall objects
// describing the invocations of this function.
func (f *RepoUpdaterClientRepoLookupFunc) History() []RepoUpdaterClientRepoLookupFuncCall {
	f.mutex.Lock()
	history := make([]RepoUpdaterClientRepoLookupFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// RepoUpdaterClientRepoLookupFuncCall is an object that describes an
// invocation of method RepoLookup on an instance of MockRepoUpdaterClient.
type RepoUpdaterClientRepoLookupFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 protocol.RepoLookupArgs
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *protocol.RepoLookupResult
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c RepoUpdaterClientRepoLookupFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c RepoUpdaterClientRepoLookupFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockReposStore is a mock implementation of the ReposStore interface (from
// the package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/autoindexing/internal/background)
// used for unit testing.
type MockReposStore struct {
	// ListMinimalReposFunc is an instance of a mock function object
	// controlling the behavior of the method ListMinimalRepos.
	ListMinimalReposFunc *ReposStoreListMinimalReposFunc
}

// NewMockReposStore creates a new mock of the ReposStore interface. All
// methods return zero values for all results, unless overwritten.
func NewMockReposStore() *MockReposStore {
	return &MockReposStore{
		ListMinimalReposFunc: &ReposStoreListMinimalReposFunc{
			defaultHook: func(context.Context, database.ReposListOptions) (r0 []types.MinimalRepo, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockReposStore creates a new mock of the ReposStore interface.
// All methods panic on invocation, unless overwritten.
func NewStrictMockReposStore() *MockReposStore {
	return &MockReposStore{
		ListMinimalReposFunc: &ReposStoreListMinimalReposFunc{
			defaultHook: func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error) {
				panic("unexpected invocation of MockReposStore.ListMinimalRepos")
			},
		},
	}
}

// NewMockReposStoreFrom creates a new mock of the MockReposStore interface.
// All methods delegate to the given implementation, unless overwritten.
func NewMockReposStoreFrom(i ReposStore) *MockReposStore {
	return &MockReposStore{
		ListMinimalReposFunc: &ReposStoreListMinimalReposFunc{
			defaultHook: i.ListMinimalRepos,
		},
	}
}

// ReposStoreListMinimalReposFunc describes the behavior when the
// ListMinimalRepos method of the parent MockReposStore instance is invoked.
type ReposStoreListMinimalReposFunc struct {
	defaultHook func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error)
	hooks       []func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error)
	history     []ReposStoreListMinimalReposFuncCall
	mutex       sync.Mutex
}

// ListMinimalRepos delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockReposStore) ListMinimalRepos(v0 context.Context, v1 database.ReposListOptions) ([]types.MinimalRepo, error) {
	r0, r1 := m.ListMinimalReposFunc.nextHook()(v0, v1)
	m.ListMinimalReposFunc.appendCall(ReposStoreListMinimalReposFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ListMinimalRepos
// method of the parent MockReposStore instance is invoked and the hook
// queue is empty.
func (f *ReposStoreListMinimalReposFunc) SetDefaultHook(hook func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ListMinimalRepos method of the parent MockReposStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ReposStoreListMinimalReposFunc) PushHook(hook func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ReposStoreListMinimalReposFunc) SetDefaultReturn(r0 []types.MinimalRepo, r1 error) {
	f.SetDefaultHook(func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ReposStoreListMinimalReposFunc) PushReturn(r0 []types.MinimalRepo, r1 error) {
	f.PushHook(func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error) {
		return r0, r1
	})
}

func (f *ReposStoreListMinimalReposFunc) nextHook() func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ReposStoreListMinimalReposFunc) appendCall(r0 ReposStoreListMinimalReposFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ReposStoreListMinimalReposFuncCall objects
// describing the invocations of this function.
func (f *ReposStoreListMinimalReposFunc) History() []ReposStoreListMinimalReposFuncCall {
	f.mutex.Lock()
	history := make([]ReposStoreListMinimalReposFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ReposStoreListMinimalReposFuncCall is an object that describes an
// invocation of method ListMinimalRepos on an instance of MockReposStore.
type ReposStoreListMinimalReposFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 database.ReposListOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types.MinimalRepo
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ReposStoreListMinimalReposFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ReposStoreListMinimalReposFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockUploadService is a mock implementation of the UploadService interface
// (from the package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/autoindexing/internal/background)
// used for unit testing.
type MockUploadService struct {
	// GetDirtyRepositoriesFunc is an instance of a mock function object
	// controlling the behavior of the method GetDirtyRepositories.
	GetDirtyRepositoriesFunc *UploadServiceGetDirtyRepositoriesFunc
	// GetRepoNameFunc is an instance of a mock function object controlling
	// the behavior of the method GetRepoName.
	GetRepoNameFunc *UploadServiceGetRepoNameFunc
	// GetRepositoriesForIndexScanFunc is an instance of a mock function
	// object controlling the behavior of the method
	// GetRepositoriesForIndexScan.
	GetRepositoriesForIndexScanFunc *UploadServiceGetRepositoriesForIndexScanFunc
	// GetUploadByIDFunc is an instance of a mock function object
	// controlling the behavior of the method GetUploadByID.
	GetUploadByIDFunc *UploadServiceGetUploadByIDFunc
	// GetUploadsByIDsFunc is an instance of a mock function object
	// controlling the behavior of the method GetUploadsByIDs.
	GetUploadsByIDsFunc *UploadServiceGetUploadsByIDsFunc
	// ReferencesForUploadFunc is an instance of a mock function object
	// controlling the behavior of the method ReferencesForUpload.
	ReferencesForUploadFunc *UploadServiceReferencesForUploadFunc
}

// NewMockUploadService creates a new mock of the UploadService interface.
// All methods return zero values for all results, unless overwritten.
func NewMockUploadService() *MockUploadService {
	return &MockUploadService{
		GetDirtyRepositoriesFunc: &UploadServiceGetDirtyRepositoriesFunc{
			defaultHook: func(context.Context) (r0 map[int]int, r1 error) {
				return
			},
		},
		GetRepoNameFunc: &UploadServiceGetRepoNameFunc{
			defaultHook: func(context.Context, int) (r0 string, r1 error) {
				return
			},
		},
		GetRepositoriesForIndexScanFunc: &UploadServiceGetRepositoriesForIndexScanFunc{
			defaultHook: func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) (r0 []int, r1 error) {
				return
			},
		},
		GetUploadByIDFunc: &UploadServiceGetUploadByIDFunc{
			defaultHook: func(context.Context, int) (r0 types1.Upload, r1 bool, r2 error) {
				return
			},
		},
		GetUploadsByIDsFunc: &UploadServiceGetUploadsByIDsFunc{
			defaultHook: func(context.Context, ...int) (r0 []types1.Upload, r1 error) {
				return
			},
		},
		ReferencesForUploadFunc: &UploadServiceReferencesForUploadFunc{
			defaultHook: func(context.Context, int) (r0 shared1.PackageReferenceScanner, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockUploadService creates a new mock of the UploadService
// interface. All methods panic on invocation, unless overwritten.
func NewStrictMockUploadService() *MockUploadService {
	return &MockUploadService{
		GetDirtyRepositoriesFunc: &UploadServiceGetDirtyRepositoriesFunc{
			defaultHook: func(context.Context) (map[int]int, error) {
				panic("unexpected invocation of MockUploadService.GetDirtyRepositories")
			},
		},
		GetRepoNameFunc: &UploadServiceGetRepoNameFunc{
			defaultHook: func(context.Context, int) (string, error) {
				panic("unexpected invocation of MockUploadService.GetRepoName")
			},
		},
		GetRepositoriesForIndexScanFunc: &UploadServiceGetRepositoriesForIndexScanFunc{
			defaultHook: func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) ([]int, error) {
				panic("unexpected invocation of MockUploadService.GetRepositoriesForIndexScan")
			},
		},
		GetUploadByIDFunc: &UploadServiceGetUploadByIDFunc{
			defaultHook: func(context.Context, int) (types1.Upload, bool, error) {
				panic("unexpected invocation of MockUploadService.GetUploadByID")
			},
		},
		GetUploadsByIDsFunc: &UploadServiceGetUploadsByIDsFunc{
			defaultHook: func(context.Context, ...int) ([]types1.Upload, error) {
				panic("unexpected invocation of MockUploadService.GetUploadsByIDs")
			},
		},
		ReferencesForUploadFunc: &UploadServiceReferencesForUploadFunc{
			defaultHook: func(context.Context, int) (shared1.PackageReferenceScanner, error) {
				panic("unexpected invocation of MockUploadService.ReferencesForUpload")
			},
		},
	}
}

// NewMockUploadServiceFrom creates a new mock of the MockUploadService
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockUploadServiceFrom(i UploadService) *MockUploadService {
	return &MockUploadService{
		GetDirtyRepositoriesFunc: &UploadServiceGetDirtyRepositoriesFunc{
			defaultHook: i.GetDirtyRepositories,
		},
		GetRepoNameFunc: &UploadServiceGetRepoNameFunc{
			defaultHook: i.GetRepoName,
		},
		GetRepositoriesForIndexScanFunc: &UploadServiceGetRepositoriesForIndexScanFunc{
			defaultHook: i.GetRepositoriesForIndexScan,
		},
		GetUploadByIDFunc: &UploadServiceGetUploadByIDFunc{
			defaultHook: i.GetUploadByID,
		},
		GetUploadsByIDsFunc: &UploadServiceGetUploadsByIDsFunc{
			defaultHook: i.GetUploadsByIDs,
		},
		ReferencesForUploadFunc: &UploadServiceReferencesForUploadFunc{
			defaultHook: i.ReferencesForUpload,
		},
	}
}

// UploadServiceGetDirtyRepositoriesFunc describes the behavior when the
// GetDirtyRepositories method of the parent MockUploadService instance is
// invoked.
type UploadServiceGetDirtyRepositoriesFunc struct {
	defaultHook func(context.Context) (map[int]int, error)
	hooks       []func(context.Context) (map[int]int, error)
	history     []UploadServiceGetDirtyRepositoriesFuncCall
	mutex       sync.Mutex
}

// GetDirtyRepositories delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockUploadService) GetDirtyRepositories(v0 context.Context) (map[int]int, error) {
	r0, r1 := m.GetDirtyRepositoriesFunc.nextHook()(v0)
	m.GetDirtyRepositoriesFunc.appendCall(UploadServiceGetDirtyRepositoriesFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetDirtyRepositories
// method of the parent MockUploadService instance is invoked and the hook
// queue is empty.
func (f *UploadServiceGetDirtyRepositoriesFunc) SetDefaultHook(hook func(context.Context) (map[int]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetDirtyRepositories method of the parent MockUploadService instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *UploadServiceGetDirtyRepositoriesFunc) PushHook(hook func(context.Context) (map[int]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *UploadServiceGetDirtyRepositoriesFunc) SetDefaultReturn(r0 map[int]int, r1 error) {
	f.SetDefaultHook(func(context.Context) (map[int]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *UploadServiceGetDirtyRepositoriesFunc) PushReturn(r0 map[int]int, r1 error) {
	f.PushHook(func(context.Context) (map[int]int, error) {
		return r0, r1
	})
}

func (f *UploadServiceGetDirtyRepositoriesFunc) nextHook() func(context.Context) (map[int]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *UploadServiceGetDirtyRepositoriesFunc) appendCall(r0 UploadServiceGetDirtyRepositoriesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of UploadServiceGetDirtyRepositoriesFuncCall
// objects describing the invocations of this function.
func (f *UploadServiceGetDirtyRepositoriesFunc) History() []UploadServiceGetDirtyRepositoriesFuncCall {
	f.mutex.Lock()
	history := make([]UploadServiceGetDirtyRepositoriesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// UploadServiceGetDirtyRepositoriesFuncCall is an object that describes an
// invocation of method GetDirtyRepositories on an instance of
// MockUploadService.
type UploadServiceGetDirtyRepositoriesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[int]int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c UploadServiceGetDirtyRepositoriesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c UploadServiceGetDirtyRepositoriesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// UploadServiceGetRepoNameFunc describes the behavior when the GetRepoName
// method of the parent MockUploadService instance is invoked.
type UploadServiceGetRepoNameFunc struct {
	defaultHook func(context.Context, int) (string, error)
	hooks       []func(context.Context, int) (string, error)
	history     []UploadServiceGetRepoNameFuncCall
	mutex       sync.Mutex
}

// GetRepoName delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockUploadService) GetRepoName(v0 context.Context, v1 int) (string, error) {
	r0, r1 := m.GetRepoNameFunc.nextHook()(v0, v1)
	m.GetRepoNameFunc.appendCall(UploadServiceGetRepoNameFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetRepoName method
// of the parent MockUploadService instance is invoked and the hook queue is
// empty.
func (f *UploadServiceGetRepoNameFunc) SetDefaultHook(hook func(context.Context, int) (string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetRepoName method of the parent MockUploadService instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *UploadServiceGetRepoNameFunc) PushHook(hook func(context.Context, int) (string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *UploadServiceGetRepoNameFunc) SetDefaultReturn(r0 string, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *UploadServiceGetRepoNameFunc) PushReturn(r0 string, r1 error) {
	f.PushHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

func (f *UploadServiceGetRepoNameFunc) nextHook() func(context.Context, int) (string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *UploadServiceGetRepoNameFunc) appendCall(r0 UploadServiceGetRepoNameFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of UploadServiceGetRepoNameFuncCall objects
// describing the invocations of this function.
func (f *UploadServiceGetRepoNameFunc) History() []UploadServiceGetRepoNameFuncCall {
	f.mutex.Lock()
	history := make([]UploadServiceGetRepoNameFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// UploadServiceGetRepoNameFuncCall is an object that describes an
// invocation of method GetRepoName on an instance of MockUploadService.
type UploadServiceGetRepoNameFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c UploadServiceGetRepoNameFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c UploadServiceGetRepoNameFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// UploadServiceGetRepositoriesForIndexScanFunc describes the behavior when
// the GetRepositoriesForIndexScan method of the parent MockUploadService
// instance is invoked.
type UploadServiceGetRepositoriesForIndexScanFunc struct {
	defaultHook func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) ([]int, error)
	hooks       []func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) ([]int, error)
	history     []UploadServiceGetRepositoriesForIndexScanFuncCall
	mutex       sync.Mutex
}

// GetRepositoriesForIndexScan delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockUploadService) GetRepositoriesForIndexScan(v0 context.Context, v1 string, v2 string, v3 time.Duration, v4 bool, v5 *int, v6 int, v7 time.Time) ([]int, error) {
	r0, r1 := m.GetRepositoriesForIndexScanFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6, v7)
	m.GetRepositoriesForIndexScanFunc.appendCall(UploadServiceGetRepositoriesForIndexScanFuncCall{v0, v1, v2, v3, v4, v5, v6, v7, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// GetRepositoriesForIndexScan method of the parent MockUploadService
// instance is invoked and the hook queue is empty.
func (f *UploadServiceGetRepositoriesForIndexScanFunc) SetDefaultHook(hook func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) ([]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetRepositoriesForIndexScan method of the parent MockUploadService
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *UploadServiceGetRepositoriesForIndexScanFunc) PushHook(hook func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) ([]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *UploadServiceGetRepositoriesForIndexScanFunc) SetDefaultReturn(r0 []int, r1 error) {
	f.SetDefaultHook(func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) ([]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *UploadServiceGetRepositoriesForIndexScanFunc) PushReturn(r0 []int, r1 error) {
	f.PushHook(func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) ([]int, error) {
		return r0, r1
	})
}

func (f *UploadServiceGetRepositoriesForIndexScanFunc) nextHook() func(context.Context, string, string, time.Duration, bool, *int, int, time.Time) ([]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *UploadServiceGetRepositoriesForIndexScanFunc) appendCall(r0 UploadServiceGetRepositoriesForIndexScanFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// UploadServiceGetRepositoriesForIndexScanFuncCall objects describing the
// invocations of this function.
func (f *UploadServiceGetRepositoriesForIndexScanFunc) History() []UploadServiceGetRepositoriesForIndexScanFuncCall {
	f.mutex.Lock()
	history := make([]UploadServiceGetRepositoriesForIndexScanFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// UploadServiceGetRepositoriesForIndexScanFuncCall is an object that
// describes an invocation of method GetRepositoriesForIndexScan on an
// instance of MockUploadService.
type UploadServiceGetRepositoriesForIndexScanFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 time.Duration
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 bool
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 *int
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 int
	// Arg7 is the value of the 8th argument passed to this method
	// invocation.
	Arg7 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c UploadServiceGetRepositoriesForIndexScanFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6, c.Arg7}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c UploadServiceGetRepositoriesForIndexScanFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// UploadServiceGetUploadByIDFunc describes the behavior when the
// GetUploadByID method of the parent MockUploadService instance is invoked.
type UploadServiceGetUploadByIDFunc struct {
	defaultHook func(context.Context, int) (types1.Upload, bool, error)
	hooks       []func(context.Context, int) (types1.Upload, bool, error)
	history     []UploadServiceGetUploadByIDFuncCall
	mutex       sync.Mutex
}

// GetUploadByID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockUploadService) GetUploadByID(v0 context.Context, v1 int) (types1.Upload, bool, error) {
	r0, r1, r2 := m.GetUploadByIDFunc.nextHook()(v0, v1)
	m.GetUploadByIDFunc.appendCall(UploadServiceGetUploadByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetUploadByID method
// of the parent MockUploadService instance is invoked and the hook queue is
// empty.
func (f *UploadServiceGetUploadByIDFunc) SetDefaultHook(hook func(context.Context, int) (types1.Upload, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadByID method of the parent MockUploadService instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *UploadServiceGetUploadByIDFunc) PushHook(hook func(context.Context, int) (types1.Upload, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *UploadServiceGetUploadByIDFunc) SetDefaultReturn(r0 types1.Upload, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (types1.Upload, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *UploadServiceGetUploadByIDFunc) PushReturn(r0 types1.Upload, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (types1.Upload, bool, error) {
		return r0, r1, r2
	})
}

func (f *UploadServiceGetUploadByIDFunc) nextHook() func(context.Context, int) (types1.Upload, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *UploadServiceGetUploadByIDFunc) appendCall(r0 UploadServiceGetUploadByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of UploadServiceGetUploadByIDFuncCall objects
// describing the invocations of this function.
func (f *UploadServiceGetUploadByIDFunc) History() []UploadServiceGetUploadByIDFuncCall {
	f.mutex.Lock()
	history := make([]UploadServiceGetUploadByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// UploadServiceGetUploadByIDFuncCall is an object that describes an
// invocation of method GetUploadByID on an instance of MockUploadService.
type UploadServiceGetUploadByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 types1.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c UploadServiceGetUploadByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c UploadServiceGetUploadByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// UploadServiceGetUploadsByIDsFunc describes the behavior when the
// GetUploadsByIDs method of the parent MockUploadService instance is
// invoked.
type UploadServiceGetUploadsByIDsFunc struct {
	defaultHook func(context.Context, ...int) ([]types1.Upload, error)
	hooks       []func(context.Context, ...int) ([]types1.Upload, error)
	history     []UploadServiceGetUploadsByIDsFuncCall
	mutex       sync.Mutex
}

// GetUploadsByIDs delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockUploadService) GetUploadsByIDs(v0 context.Context, v1 ...int) ([]types1.Upload, error) {
	r0, r1 := m.GetUploadsByIDsFunc.nextHook()(v0, v1...)
	m.GetUploadsByIDsFunc.appendCall(UploadServiceGetUploadsByIDsFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetUploadsByIDs
// method of the parent MockUploadService instance is invoked and the hook
// queue is empty.
func (f *UploadServiceGetUploadsByIDsFunc) SetDefaultHook(hook func(context.Context, ...int) ([]types1.Upload, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadsByIDs method of the parent MockUploadService instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *UploadServiceGetUploadsByIDsFunc) PushHook(hook func(context.Context, ...int) ([]types1.Upload, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *UploadServiceGetUploadsByIDsFunc) SetDefaultReturn(r0 []types1.Upload, r1 error) {
	f.SetDefaultHook(func(context.Context, ...int) ([]types1.Upload, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *UploadServiceGetUploadsByIDsFunc) PushReturn(r0 []types1.Upload, r1 error) {
	f.PushHook(func(context.Context, ...int) ([]types1.Upload, error) {
		return r0, r1
	})
}

func (f *UploadServiceGetUploadsByIDsFunc) nextHook() func(context.Context, ...int) ([]types1.Upload, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *UploadServiceGetUploadsByIDsFunc) appendCall(r0 UploadServiceGetUploadsByIDsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of UploadServiceGetUploadsByIDsFuncCall
// objects describing the invocations of this function.
func (f *UploadServiceGetUploadsByIDsFunc) History() []UploadServiceGetUploadsByIDsFuncCall {
	f.mutex.Lock()
	history := make([]UploadServiceGetUploadsByIDsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// UploadServiceGetUploadsByIDsFuncCall is an object that describes an
// invocation of method GetUploadsByIDs on an instance of MockUploadService.
type UploadServiceGetUploadsByIDsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types1.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c UploadServiceGetUploadsByIDsFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c UploadServiceGetUploadsByIDsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// UploadServiceReferencesForUploadFunc describes the behavior when the
// ReferencesForUpload method of the parent MockUploadService instance is
// invoked.
type UploadServiceReferencesForUploadFunc struct {
	defaultHook func(context.Context, int) (shared1.PackageReferenceScanner, error)
	hooks       []func(context.Context, int) (shared1.PackageReferenceScanner, error)
	history     []UploadServiceReferencesForUploadFuncCall
	mutex       sync.Mutex
}

// ReferencesForUpload delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockUploadService) ReferencesForUpload(v0 context.Context, v1 int) (shared1.PackageReferenceScanner, error) {
	r0, r1 := m.ReferencesForUploadFunc.nextHook()(v0, v1)
	m.ReferencesForUploadFunc.appendCall(UploadServiceReferencesForUploadFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ReferencesForUpload
// method of the parent MockUploadService instance is invoked and the hook
// queue is empty.
func (f *UploadServiceReferencesForUploadFunc) SetDefaultHook(hook func(context.Context, int) (shared1.PackageReferenceScanner, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReferencesForUpload method of the parent MockUploadService instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *UploadServiceReferencesForUploadFunc) PushHook(hook func(context.Context, int) (shared1.PackageReferenceScanner, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *UploadServiceReferencesForUploadFunc) SetDefaultReturn(r0 shared1.PackageReferenceScanner, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (shared1.PackageReferenceScanner, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *UploadServiceReferencesForUploadFunc) PushReturn(r0 shared1.PackageReferenceScanner, r1 error) {
	f.PushHook(func(context.Context, int) (shared1.PackageReferenceScanner, error) {
		return r0, r1
	})
}

func (f *UploadServiceReferencesForUploadFunc) nextHook() func(context.Context, int) (shared1.PackageReferenceScanner, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *UploadServiceReferencesForUploadFunc) appendCall(r0 UploadServiceReferencesForUploadFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of UploadServiceReferencesForUploadFuncCall
// objects describing the invocations of this function.
func (f *UploadServiceReferencesForUploadFunc) History() []UploadServiceReferencesForUploadFuncCall {
	f.mutex.Lock()
	history := make([]UploadServiceReferencesForUploadFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// UploadServiceReferencesForUploadFuncCall is an object that describes an
// invocation of method ReferencesForUpload on an instance of
// MockUploadService.
type UploadServiceReferencesForUploadFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 shared1.PackageReferenceScanner
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c UploadServiceReferencesForUploadFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c UploadServiceReferencesForUploadFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockPackageReferenceScanner is a mock implementation of the
// PackageReferenceScanner interface (from the package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/uploads/shared)
// used for unit testing.
type MockPackageReferenceScanner struct {
	// CloseFunc is an instance of a mock function object controlling the
	// behavior of the method Close.
	CloseFunc *PackageReferenceScannerCloseFunc
	// NextFunc is an instance of a mock function object controlling the
	// behavior of the method Next.
	NextFunc *PackageReferenceScannerNextFunc
}

// NewMockPackageReferenceScanner creates a new mock of the
// PackageReferenceScanner interface. All methods return zero values for all
// results, unless overwritten.
func NewMockPackageReferenceScanner() *MockPackageReferenceScanner {
	return &MockPackageReferenceScanner{
		CloseFunc: &PackageReferenceScannerCloseFunc{
			defaultHook: func() (r0 error) {
				return
			},
		},
		NextFunc: &PackageReferenceScannerNextFunc{
			defaultHook: func() (r0 shared1.PackageReference, r1 bool, r2 error) {
				return
			},
		},
	}
}

// NewStrictMockPackageReferenceScanner creates a new mock of the
// PackageReferenceScanner interface. All methods panic on invocation,
// unless overwritten.
func NewStrictMockPackageReferenceScanner() *MockPackageReferenceScanner {
	return &MockPackageReferenceScanner{
		CloseFunc: &PackageReferenceScannerCloseFunc{
			defaultHook: func() error {
				panic("unexpected invocation of MockPackageReferenceScanner.Close")
			},
		},
		NextFunc: &PackageReferenceScannerNextFunc{
			defaultHook: func() (shared1.PackageReference, bool, error) {
				panic("unexpected invocation of MockPackageReferenceScanner.Next")
			},
		},
	}
}

// NewMockPackageReferenceScannerFrom creates a new mock of the
// MockPackageReferenceScanner interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockPackageReferenceScannerFrom(i shared1.PackageReferenceScanner) *MockPackageReferenceScanner {
	return &MockPackageReferenceScanner{
		CloseFunc: &PackageReferenceScannerCloseFunc{
			defaultHook: i.Close,
		},
		NextFunc: &PackageReferenceScannerNextFunc{
			defaultHook: i.Next,
		},
	}
}

// PackageReferenceScannerCloseFunc describes the behavior when the Close
// method of the parent MockPackageReferenceScanner instance is invoked.
type PackageReferenceScannerCloseFunc struct {
	defaultHook func() error
	hooks       []func() error
	history     []PackageReferenceScannerCloseFuncCall
	mutex       sync.Mutex
}

// Close delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockPackageReferenceScanner) Close() error {
	r0 := m.CloseFunc.nextHook()()
	m.CloseFunc.appendCall(PackageReferenceScannerCloseFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the Close method of the
// parent MockPackageReferenceScanner instance is invoked and the hook queue
// is empty.
func (f *PackageReferenceScannerCloseFunc) SetDefaultHook(hook func() error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Close method of the parent MockPackageReferenceScanner instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *PackageReferenceScannerCloseFunc) PushHook(hook func() error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *PackageReferenceScannerCloseFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func() error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *PackageReferenceScannerCloseFunc) PushReturn(r0 error) {
	f.PushHook(func() error {
		return r0
	})
}

func (f *PackageReferenceScannerCloseFunc) nextHook() func() error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *PackageReferenceScannerCloseFunc) appendCall(r0 PackageReferenceScannerCloseFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of PackageReferenceScannerCloseFuncCall
// objects describing the invocations of this function.
func (f *PackageReferenceScannerCloseFunc) History() []PackageReferenceScannerCloseFuncCall {
	f.mutex.Lock()
	history := make([]PackageReferenceScannerCloseFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// PackageReferenceScannerCloseFuncCall is an object that describes an
// invocation of method Close on an instance of MockPackageReferenceScanner.
type PackageReferenceScannerCloseFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c PackageReferenceScannerCloseFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c PackageReferenceScannerCloseFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// PackageReferenceScannerNextFunc describes the behavior when the Next
// method of the parent MockPackageReferenceScanner instance is invoked.
type PackageReferenceScannerNextFunc struct {
	defaultHook func() (shared1.PackageReference, bool, error)
	hooks       []func() (shared1.PackageReference, bool, error)
	history     []PackageReferenceScannerNextFuncCall
	mutex       sync.Mutex
}

// Next delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockPackageReferenceScanner) Next() (shared1.PackageReference, bool, error) {
	r0, r1, r2 := m.NextFunc.nextHook()()
	m.NextFunc.appendCall(PackageReferenceScannerNextFuncCall{r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Next method of the
// parent MockPackageReferenceScanner instance is invoked and the hook queue
// is empty.
func (f *PackageReferenceScannerNextFunc) SetDefaultHook(hook func() (shared1.PackageReference, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Next method of the parent MockPackageReferenceScanner instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *PackageReferenceScannerNextFunc) PushHook(hook func() (shared1.PackageReference, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *PackageReferenceScannerNextFunc) SetDefaultReturn(r0 shared1.PackageReference, r1 bool, r2 error) {
	f.SetDefaultHook(func() (shared1.PackageReference, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *PackageReferenceScannerNextFunc) PushReturn(r0 shared1.PackageReference, r1 bool, r2 error) {
	f.PushHook(func() (shared1.PackageReference, bool, error) {
		return r0, r1, r2
	})
}

func (f *PackageReferenceScannerNextFunc) nextHook() func() (shared1.PackageReference, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *PackageReferenceScannerNextFunc) appendCall(r0 PackageReferenceScannerNextFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of PackageReferenceScannerNextFuncCall objects
// describing the invocations of this function.
func (f *PackageReferenceScannerNextFunc) History() []PackageReferenceScannerNextFuncCall {
	f.mutex.Lock()
	history := make([]PackageReferenceScannerNextFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// PackageReferenceScannerNextFuncCall is an object that describes an
// invocation of method Next on an instance of MockPackageReferenceScanner.
type PackageReferenceScannerNextFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 shared1.PackageReference
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c PackageReferenceScannerNextFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c PackageReferenceScannerNextFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// MockStore is a mock implementation of the Store interface (from the
// package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/autoindexing/internal/store)
// used for unit testing.
type MockStore struct {
	// DeleteIndexByIDFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteIndexByID.
	DeleteIndexByIDFunc *StoreDeleteIndexByIDFunc
	// DeleteIndexesFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteIndexes.
	DeleteIndexesFunc *StoreDeleteIndexesFunc
	// DeleteIndexesWithoutRepositoryFunc is an instance of a mock function
	// object controlling the behavior of the method
	// DeleteIndexesWithoutRepository.
	DeleteIndexesWithoutRepositoryFunc *StoreDeleteIndexesWithoutRepositoryFunc
	// DoneFunc is an instance of a mock function object controlling the
	// behavior of the method Done.
	DoneFunc *StoreDoneFunc
	// ExpireFailedRecordsFunc is an instance of a mock function object
	// controlling the behavior of the method ExpireFailedRecords.
	ExpireFailedRecordsFunc *StoreExpireFailedRecordsFunc
	// GetIndexByIDFunc is an instance of a mock function object controlling
	// the behavior of the method GetIndexByID.
	GetIndexByIDFunc *StoreGetIndexByIDFunc
	// GetIndexConfigurationByRepositoryIDFunc is an instance of a mock
	// function object controlling the behavior of the method
	// GetIndexConfigurationByRepositoryID.
	GetIndexConfigurationByRepositoryIDFunc *StoreGetIndexConfigurationByRepositoryIDFunc
	// GetIndexesFunc is an instance of a mock function object controlling
	// the behavior of the method GetIndexes.
	GetIndexesFunc *StoreGetIndexesFunc
	// GetIndexesByIDsFunc is an instance of a mock function object
	// controlling the behavior of the method GetIndexesByIDs.
	GetIndexesByIDsFunc *StoreGetIndexesByIDsFunc
	// GetInferenceScriptFunc is an instance of a mock function object
	// controlling the behavior of the method GetInferenceScript.
	GetInferenceScriptFunc *StoreGetInferenceScriptFunc
	// GetLanguagesRequestedByFunc is an instance of a mock function object
	// controlling the behavior of the method GetLanguagesRequestedBy.
	GetLanguagesRequestedByFunc *StoreGetLanguagesRequestedByFunc
	// GetLastIndexScanForRepositoryFunc is an instance of a mock function
	// object controlling the behavior of the method
	// GetLastIndexScanForRepository.
	GetLastIndexScanForRepositoryFunc *StoreGetLastIndexScanForRepositoryFunc
	// GetQueuedRepoRevFunc is an instance of a mock function object
	// controlling the behavior of the method GetQueuedRepoRev.
	GetQueuedRepoRevFunc *StoreGetQueuedRepoRevFunc
	// GetRecentIndexesSummaryFunc is an instance of a mock function object
	// controlling the behavior of the method GetRecentIndexesSummary.
	GetRecentIndexesSummaryFunc *StoreGetRecentIndexesSummaryFunc
	// GetUnsafeDBFunc is an instance of a mock function object controlling
	// the behavior of the method GetUnsafeDB.
	GetUnsafeDBFunc *StoreGetUnsafeDBFunc
	// InsertDependencyIndexingJobFunc is an instance of a mock function
	// object controlling the behavior of the method
	// InsertDependencyIndexingJob.
	InsertDependencyIndexingJobFunc *StoreInsertDependencyIndexingJobFunc
	// InsertIndexesFunc is an instance of a mock function object
	// controlling the behavior of the method InsertIndexes.
	InsertIndexesFunc *StoreInsertIndexesFunc
	// IsQueuedFunc is an instance of a mock function object controlling the
	// behavior of the method IsQueued.
	IsQueuedFunc *StoreIsQueuedFunc
	// IsQueuedRootIndexerFunc is an instance of a mock function object
	// controlling the behavior of the method IsQueuedRootIndexer.
	IsQueuedRootIndexerFunc *StoreIsQueuedRootIndexerFunc
	// MarkRepoRevsAsProcessedFunc is an instance of a mock function object
	// controlling the behavior of the method MarkRepoRevsAsProcessed.
	MarkRepoRevsAsProcessedFunc *StoreMarkRepoRevsAsProcessedFunc
	// ProcessStaleSourcedCommitsFunc is an instance of a mock function
	// object controlling the behavior of the method
	// ProcessStaleSourcedCommits.
	ProcessStaleSourcedCommitsFunc *StoreProcessStaleSourcedCommitsFunc
	// QueueRepoRevFunc is an instance of a mock function object controlling
	// the behavior of the method QueueRepoRev.
	QueueRepoRevFunc *StoreQueueRepoRevFunc
	// ReindexIndexByIDFunc is an instance of a mock function object
	// controlling the behavior of the method ReindexIndexByID.
	ReindexIndexByIDFunc *StoreReindexIndexByIDFunc
	// ReindexIndexesFunc is an instance of a mock function object
	// controlling the behavior of the method ReindexIndexes.
	ReindexIndexesFunc *StoreReindexIndexesFunc
	// SetInferenceScriptFunc is an instance of a mock function object
	// controlling the behavior of the method SetInferenceScript.
	SetInferenceScriptFunc *StoreSetInferenceScriptFunc
	// SetRequestLanguageSupportFunc is an instance of a mock function
	// object controlling the behavior of the method
	// SetRequestLanguageSupport.
	SetRequestLanguageSupportFunc *StoreSetRequestLanguageSupportFunc
	// TransactFunc is an instance of a mock function object controlling the
	// behavior of the method Transact.
	TransactFunc *StoreTransactFunc
	// UpdateIndexConfigurationByRepositoryIDFunc is an instance of a mock
	// function object controlling the behavior of the method
	// UpdateIndexConfigurationByRepositoryID.
	UpdateIndexConfigurationByRepositoryIDFunc *StoreUpdateIndexConfigurationByRepositoryIDFunc
}

// NewMockStore creates a new mock of the Store interface. All methods
// return zero values for all results, unless overwritten.
func NewMockStore() *MockStore {
	return &MockStore{
		DeleteIndexByIDFunc: &StoreDeleteIndexByIDFunc{
			defaultHook: func(context.Context, int) (r0 bool, r1 error) {
				return
			},
		},
		DeleteIndexesFunc: &StoreDeleteIndexesFunc{
			defaultHook: func(context.Context, shared2.DeleteIndexesOptions) (r0 error) {
				return
			},
		},
		DeleteIndexesWithoutRepositoryFunc: &StoreDeleteIndexesWithoutRepositoryFunc{
			defaultHook: func(context.Context, time.Time) (r0 map[int]int, r1 error) {
				return
			},
		},
		DoneFunc: &StoreDoneFunc{
			defaultHook: func(error) (r0 error) {
				return
			},
		},
		ExpireFailedRecordsFunc: &StoreExpireFailedRecordsFunc{
			defaultHook: func(context.Context, int, time.Duration, time.Time) (r0 error) {
				return
			},
		},
		GetIndexByIDFunc: &StoreGetIndexByIDFunc{
			defaultHook: func(context.Context, int) (r0 types1.Index, r1 bool, r2 error) {
				return
			},
		},
		GetIndexConfigurationByRepositoryIDFunc: &StoreGetIndexConfigurationByRepositoryIDFunc{
			defaultHook: func(context.Context, int) (r0 shared2.IndexConfiguration, r1 bool, r2 error) {
				return
			},
		},
		GetIndexesFunc: &StoreGetIndexesFunc{
			defaultHook: func(context.Context, shared2.GetIndexesOptions) (r0 []types1.Index, r1 int, r2 error) {
				return
			},
		},
		GetIndexesByIDsFunc: &StoreGetIndexesByIDsFunc{
			defaultHook: func(context.Context, ...int) (r0 []types1.Index, r1 error) {
				return
			},
		},
		GetInferenceScriptFunc: &StoreGetInferenceScriptFunc{
			defaultHook: func(context.Context) (r0 string, r1 error) {
				return
			},
		},
		GetLanguagesRequestedByFunc: &StoreGetLanguagesRequestedByFunc{
			defaultHook: func(context.Context, int) (r0 []string, r1 error) {
				return
			},
		},
		GetLastIndexScanForRepositoryFunc: &StoreGetLastIndexScanForRepositoryFunc{
			defaultHook: func(context.Context, int) (r0 *time.Time, r1 error) {
				return
			},
		},
		GetQueuedRepoRevFunc: &StoreGetQueuedRepoRevFunc{
			defaultHook: func(context.Context, int) (r0 []store.RepoRev, r1 error) {
				return
			},
		},
		GetRecentIndexesSummaryFunc: &StoreGetRecentIndexesSummaryFunc{
			defaultHook: func(context.Context, int) (r0 []shared2.IndexesWithRepositoryNamespace, r1 error) {
				return
			},
		},
		GetUnsafeDBFunc: &StoreGetUnsafeDBFunc{
			defaultHook: func() (r0 database.DB) {
				return
			},
		},
		InsertDependencyIndexingJobFunc: &StoreInsertDependencyIndexingJobFunc{
			defaultHook: func(context.Context, int, string, time.Time) (r0 int, r1 error) {
				return
			},
		},
		InsertIndexesFunc: &StoreInsertIndexesFunc{
			defaultHook: func(context.Context, []types1.Index) (r0 []types1.Index, r1 error) {
				return
			},
		},
		IsQueuedFunc: &StoreIsQueuedFunc{
			defaultHook: func(context.Context, int, string) (r0 bool, r1 error) {
				return
			},
		},
		IsQueuedRootIndexerFunc: &StoreIsQueuedRootIndexerFunc{
			defaultHook: func(context.Context, int, string, string, string) (r0 bool, r1 error) {
				return
			},
		},
		MarkRepoRevsAsProcessedFunc: &StoreMarkRepoRevsAsProcessedFunc{
			defaultHook: func(context.Context, []int) (r0 error) {
				return
			},
		},
		ProcessStaleSourcedCommitsFunc: &StoreProcessStaleSourcedCommitsFunc{
			defaultHook: func(context.Context, time.Duration, int, time.Duration, func(ctx context.Context, repositoryID int, commit string) (bool, error)) (r0 int, r1 error) {
				return
			},
		},
		QueueRepoRevFunc: &StoreQueueRepoRevFunc{
			defaultHook: func(context.Context, int, string) (r0 error) {
				return
			},
		},
		ReindexIndexByIDFunc: &StoreReindexIndexByIDFunc{
			defaultHook: func(context.Context, int) (r0 error) {
				return
			},
		},
		ReindexIndexesFunc: &StoreReindexIndexesFunc{
			defaultHook: func(context.Context, shared2.ReindexIndexesOptions) (r0 error) {
				return
			},
		},
		SetInferenceScriptFunc: &StoreSetInferenceScriptFunc{
			defaultHook: func(context.Context, string) (r0 error) {
				return
			},
		},
		SetRequestLanguageSupportFunc: &StoreSetRequestLanguageSupportFunc{
			defaultHook: func(context.Context, int, string) (r0 error) {
				return
			},
		},
		TransactFunc: &StoreTransactFunc{
			defaultHook: func(context.Context) (r0 store.Store, r1 error) {
				return
			},
		},
		UpdateIndexConfigurationByRepositoryIDFunc: &StoreUpdateIndexConfigurationByRepositoryIDFunc{
			defaultHook: func(context.Context, int, []byte) (r0 error) {
				return
			},
		},
	}
}

// NewStrictMockStore creates a new mock of the Store interface. All methods
// panic on invocation, unless overwritten.
func NewStrictMockStore() *MockStore {
	return &MockStore{
		DeleteIndexByIDFunc: &StoreDeleteIndexByIDFunc{
			defaultHook: func(context.Context, int) (bool, error) {
				panic("unexpected invocation of MockStore.DeleteIndexByID")
			},
		},
		DeleteIndexesFunc: &StoreDeleteIndexesFunc{
			defaultHook: func(context.Context, shared2.DeleteIndexesOptions) error {
				panic("unexpected invocation of MockStore.DeleteIndexes")
			},
		},
		DeleteIndexesWithoutRepositoryFunc: &StoreDeleteIndexesWithoutRepositoryFunc{
			defaultHook: func(context.Context, time.Time) (map[int]int, error) {
				panic("unexpected invocation of MockStore.DeleteIndexesWithoutRepository")
			},
		},
		DoneFunc: &StoreDoneFunc{
			defaultHook: func(error) error {
				panic("unexpected invocation of MockStore.Done")
			},
		},
		ExpireFailedRecordsFunc: &StoreExpireFailedRecordsFunc{
			defaultHook: func(context.Context, int, time.Duration, time.Time) error {
				panic("unexpected invocation of MockStore.ExpireFailedRecords")
			},
		},
		GetIndexByIDFunc: &StoreGetIndexByIDFunc{
			defaultHook: func(context.Context, int) (types1.Index, bool, error) {
				panic("unexpected invocation of MockStore.GetIndexByID")
			},
		},
		GetIndexConfigurationByRepositoryIDFunc: &StoreGetIndexConfigurationByRepositoryIDFunc{
			defaultHook: func(context.Context, int) (shared2.IndexConfiguration, bool, error) {
				panic("unexpected invocation of MockStore.GetIndexConfigurationByRepositoryID")
			},
		},
		GetIndexesFunc: &StoreGetIndexesFunc{
			defaultHook: func(context.Context, shared2.GetIndexesOptions) ([]types1.Index, int, error) {
				panic("unexpected invocation of MockStore.GetIndexes")
			},
		},
		GetIndexesByIDsFunc: &StoreGetIndexesByIDsFunc{
			defaultHook: func(context.Context, ...int) ([]types1.Index, error) {
				panic("unexpected invocation of MockStore.GetIndexesByIDs")
			},
		},
		GetInferenceScriptFunc: &StoreGetInferenceScriptFunc{
			defaultHook: func(context.Context) (string, error) {
				panic("unexpected invocation of MockStore.GetInferenceScript")
			},
		},
		GetLanguagesRequestedByFunc: &StoreGetLanguagesRequestedByFunc{
			defaultHook: func(context.Context, int) ([]string, error) {
				panic("unexpected invocation of MockStore.GetLanguagesRequestedBy")
			},
		},
		GetLastIndexScanForRepositoryFunc: &StoreGetLastIndexScanForRepositoryFunc{
			defaultHook: func(context.Context, int) (*time.Time, error) {
				panic("unexpected invocation of MockStore.GetLastIndexScanForRepository")
			},
		},
		GetQueuedRepoRevFunc: &StoreGetQueuedRepoRevFunc{
			defaultHook: func(context.Context, int) ([]store.RepoRev, error) {
				panic("unexpected invocation of MockStore.GetQueuedRepoRev")
			},
		},
		GetRecentIndexesSummaryFunc: &StoreGetRecentIndexesSummaryFunc{
			defaultHook: func(context.Context, int) ([]shared2.IndexesWithRepositoryNamespace, error) {
				panic("unexpected invocation of MockStore.GetRecentIndexesSummary")
			},
		},
		GetUnsafeDBFunc: &StoreGetUnsafeDBFunc{
			defaultHook: func() database.DB {
				panic("unexpected invocation of MockStore.GetUnsafeDB")
			},
		},
		InsertDependencyIndexingJobFunc: &StoreInsertDependencyIndexingJobFunc{
			defaultHook: func(context.Context, int, string, time.Time) (int, error) {
				panic("unexpected invocation of MockStore.InsertDependencyIndexingJob")
			},
		},
		InsertIndexesFunc: &StoreInsertIndexesFunc{
			defaultHook: func(context.Context, []types1.Index) ([]types1.Index, error) {
				panic("unexpected invocation of MockStore.InsertIndexes")
			},
		},
		IsQueuedFunc: &StoreIsQueuedFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				panic("unexpected invocation of MockStore.IsQueued")
			},
		},
		IsQueuedRootIndexerFunc: &StoreIsQueuedRootIndexerFunc{
			defaultHook: func(context.Context, int, string, string, string) (bool, error) {
				panic("unexpected invocation of MockStore.IsQueuedRootIndexer")
			},
		},
		MarkRepoRevsAsProcessedFunc: &StoreMarkRepoRevsAsProcessedFunc{
			defaultHook: func(context.Context, []int) error {
				panic("unexpected invocation of MockStore.MarkRepoRevsAsProcessed")
			},
		},
		ProcessStaleSourcedCommitsFunc: &StoreProcessStaleSourcedCommitsFunc{
			defaultHook: func(context.Context, time.Duration, int, time.Duration, func(ctx context.Context, repositoryID int, commit string) (bool, error)) (int, error) {
				panic("unexpected invocation of MockStore.ProcessStaleSourcedCommits")
			},
		},
		QueueRepoRevFunc: &StoreQueueRepoRevFunc{
			defaultHook: func(context.Context, int, string) error {
				panic("unexpected invocation of MockStore.QueueRepoRev")
			},
		},
		ReindexIndexByIDFunc: &StoreReindexIndexByIDFunc{
			defaultHook: func(context.Context, int) error {
				panic("unexpected invocation of MockStore.ReindexIndexByID")
			},
		},
		ReindexIndexesFunc: &StoreReindexIndexesFunc{
			defaultHook: func(context.Context, shared2.ReindexIndexesOptions) error {
				panic("unexpected invocation of MockStore.ReindexIndexes")
			},
		},
		SetInferenceScriptFunc: &StoreSetInferenceScriptFunc{
			defaultHook: func(context.Context, string) error {
				panic("unexpected invocation of MockStore.SetInferenceScript")
			},
		},
		SetRequestLanguageSupportFunc: &StoreSetRequestLanguageSupportFunc{
			defaultHook: func(context.Context, int, string) error {
				panic("unexpected invocation of MockStore.SetRequestLanguageSupport")
			},
		},
		TransactFunc: &StoreTransactFunc{
			defaultHook: func(context.Context) (store.Store, error) {
				panic("unexpected invocation of MockStore.Transact")
			},
		},
		UpdateIndexConfigurationByRepositoryIDFunc: &StoreUpdateIndexConfigurationByRepositoryIDFunc{
			defaultHook: func(context.Context, int, []byte) error {
				panic("unexpected invocation of MockStore.UpdateIndexConfigurationByRepositoryID")
			},
		},
	}
}

// NewMockStoreFrom creates a new mock of the MockStore interface. All
// methods delegate to the given implementation, unless overwritten.
func NewMockStoreFrom(i store.Store) *MockStore {
	return &MockStore{
		DeleteIndexByIDFunc: &StoreDeleteIndexByIDFunc{
			defaultHook: i.DeleteIndexByID,
		},
		DeleteIndexesFunc: &StoreDeleteIndexesFunc{
			defaultHook: i.DeleteIndexes,
		},
		DeleteIndexesWithoutRepositoryFunc: &StoreDeleteIndexesWithoutRepositoryFunc{
			defaultHook: i.DeleteIndexesWithoutRepository,
		},
		DoneFunc: &StoreDoneFunc{
			defaultHook: i.Done,
		},
		ExpireFailedRecordsFunc: &StoreExpireFailedRecordsFunc{
			defaultHook: i.ExpireFailedRecords,
		},
		GetIndexByIDFunc: &StoreGetIndexByIDFunc{
			defaultHook: i.GetIndexByID,
		},
		GetIndexConfigurationByRepositoryIDFunc: &StoreGetIndexConfigurationByRepositoryIDFunc{
			defaultHook: i.GetIndexConfigurationByRepositoryID,
		},
		GetIndexesFunc: &StoreGetIndexesFunc{
			defaultHook: i.GetIndexes,
		},
		GetIndexesByIDsFunc: &StoreGetIndexesByIDsFunc{
			defaultHook: i.GetIndexesByIDs,
		},
		GetInferenceScriptFunc: &StoreGetInferenceScriptFunc{
			defaultHook: i.GetInferenceScript,
		},
		GetLanguagesRequestedByFunc: &StoreGetLanguagesRequestedByFunc{
			defaultHook: i.GetLanguagesRequestedBy,
		},
		GetLastIndexScanForRepositoryFunc: &StoreGetLastIndexScanForRepositoryFunc{
			defaultHook: i.GetLastIndexScanForRepository,
		},
		GetQueuedRepoRevFunc: &StoreGetQueuedRepoRevFunc{
			defaultHook: i.GetQueuedRepoRev,
		},
		GetRecentIndexesSummaryFunc: &StoreGetRecentIndexesSummaryFunc{
			defaultHook: i.GetRecentIndexesSummary,
		},
		GetUnsafeDBFunc: &StoreGetUnsafeDBFunc{
			defaultHook: i.GetUnsafeDB,
		},
		InsertDependencyIndexingJobFunc: &StoreInsertDependencyIndexingJobFunc{
			defaultHook: i.InsertDependencyIndexingJob,
		},
		InsertIndexesFunc: &StoreInsertIndexesFunc{
			defaultHook: i.InsertIndexes,
		},
		IsQueuedFunc: &StoreIsQueuedFunc{
			defaultHook: i.IsQueued,
		},
		IsQueuedRootIndexerFunc: &StoreIsQueuedRootIndexerFunc{
			defaultHook: i.IsQueuedRootIndexer,
		},
		MarkRepoRevsAsProcessedFunc: &StoreMarkRepoRevsAsProcessedFunc{
			defaultHook: i.MarkRepoRevsAsProcessed,
		},
		ProcessStaleSourcedCommitsFunc: &StoreProcessStaleSourcedCommitsFunc{
			defaultHook: i.ProcessStaleSourcedCommits,
		},
		QueueRepoRevFunc: &StoreQueueRepoRevFunc{
			defaultHook: i.QueueRepoRev,
		},
		ReindexIndexByIDFunc: &StoreReindexIndexByIDFunc{
			defaultHook: i.ReindexIndexByID,
		},
		ReindexIndexesFunc: &StoreReindexIndexesFunc{
			defaultHook: i.ReindexIndexes,
		},
		SetInferenceScriptFunc: &StoreSetInferenceScriptFunc{
			defaultHook: i.SetInferenceScript,
		},
		SetRequestLanguageSupportFunc: &StoreSetRequestLanguageSupportFunc{
			defaultHook: i.SetRequestLanguageSupport,
		},
		TransactFunc: &StoreTransactFunc{
			defaultHook: i.Transact,
		},
		UpdateIndexConfigurationByRepositoryIDFunc: &StoreUpdateIndexConfigurationByRepositoryIDFunc{
			defaultHook: i.UpdateIndexConfigurationByRepositoryID,
		},
	}
}

// StoreDeleteIndexByIDFunc describes the behavior when the DeleteIndexByID
// method of the parent MockStore instance is invoked.
type StoreDeleteIndexByIDFunc struct {
	defaultHook func(context.Context, int) (bool, error)
	hooks       []func(context.Context, int) (bool, error)
	history     []StoreDeleteIndexByIDFuncCall
	mutex       sync.Mutex
}

// DeleteIndexByID delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) DeleteIndexByID(v0 context.Context, v1 int) (bool, error) {
	r0, r1 := m.DeleteIndexByIDFunc.nextHook()(v0, v1)
	m.DeleteIndexByIDFunc.appendCall(StoreDeleteIndexByIDFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DeleteIndexByID
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreDeleteIndexByIDFunc) SetDefaultHook(hook func(context.Context, int) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteIndexByID method of the parent MockStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreDeleteIndexByIDFunc) PushHook(hook func(context.Context, int) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreDeleteIndexByIDFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreDeleteIndexByIDFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

func (f *StoreDeleteIndexByIDFunc) nextHook() func(context.Context, int) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteIndexByIDFunc) appendCall(r0 StoreDeleteIndexByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteIndexByIDFuncCall objects
// describing the invocations of this function.
func (f *StoreDeleteIndexByIDFunc) History() []StoreDeleteIndexByIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteIndexByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteIndexByIDFuncCall is an object that describes an invocation of
// method DeleteIndexByID on an instance of MockStore.
type StoreDeleteIndexByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteIndexByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteIndexByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreDeleteIndexesFunc describes the behavior when the DeleteIndexes
// method of the parent MockStore instance is invoked.
type StoreDeleteIndexesFunc struct {
	defaultHook func(context.Context, shared2.DeleteIndexesOptions) error
	hooks       []func(context.Context, shared2.DeleteIndexesOptions) error
	history     []StoreDeleteIndexesFuncCall
	mutex       sync.Mutex
}

// DeleteIndexes delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) DeleteIndexes(v0 context.Context, v1 shared2.DeleteIndexesOptions) error {
	r0 := m.DeleteIndexesFunc.nextHook()(v0, v1)
	m.DeleteIndexesFunc.appendCall(StoreDeleteIndexesFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the DeleteIndexes method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreDeleteIndexesFunc) SetDefaultHook(hook func(context.Context, shared2.DeleteIndexesOptions) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteIndexes method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreDeleteIndexesFunc) PushHook(hook func(context.Context, shared2.DeleteIndexesOptions) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreDeleteIndexesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, shared2.DeleteIndexesOptions) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreDeleteIndexesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, shared2.DeleteIndexesOptions) error {
		return r0
	})
}

func (f *StoreDeleteIndexesFunc) nextHook() func(context.Context, shared2.DeleteIndexesOptions) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteIndexesFunc) appendCall(r0 StoreDeleteIndexesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteIndexesFuncCall objects
// describing the invocations of this function.
func (f *StoreDeleteIndexesFunc) History() []StoreDeleteIndexesFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteIndexesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteIndexesFuncCall is an object that describes an invocation of
// method DeleteIndexes on an instance of MockStore.
type StoreDeleteIndexesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 shared2.DeleteIndexesOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteIndexesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteIndexesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreDeleteIndexesWithoutRepositoryFunc describes the behavior when the
// DeleteIndexesWithoutRepository method of the parent MockStore instance is
// invoked.
type StoreDeleteIndexesWithoutRepositoryFunc struct {
	defaultHook func(context.Context, time.Time) (map[int]int, error)
	hooks       []func(context.Context, time.Time) (map[int]int, error)
	history     []StoreDeleteIndexesWithoutRepositoryFuncCall
	mutex       sync.Mutex
}

// DeleteIndexesWithoutRepository delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) DeleteIndexesWithoutRepository(v0 context.Context, v1 time.Time) (map[int]int, error) {
	r0, r1 := m.DeleteIndexesWithoutRepositoryFunc.nextHook()(v0, v1)
	m.DeleteIndexesWithoutRepositoryFunc.appendCall(StoreDeleteIndexesWithoutRepositoryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// DeleteIndexesWithoutRepository method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreDeleteIndexesWithoutRepositoryFunc) SetDefaultHook(hook func(context.Context, time.Time) (map[int]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteIndexesWithoutRepository method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreDeleteIndexesWithoutRepositoryFunc) PushHook(hook func(context.Context, time.Time) (map[int]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreDeleteIndexesWithoutRepositoryFunc) SetDefaultReturn(r0 map[int]int, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Time) (map[int]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreDeleteIndexesWithoutRepositoryFunc) PushReturn(r0 map[int]int, r1 error) {
	f.PushHook(func(context.Context, time.Time) (map[int]int, error) {
		return r0, r1
	})
}

func (f *StoreDeleteIndexesWithoutRepositoryFunc) nextHook() func(context.Context, time.Time) (map[int]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteIndexesWithoutRepositoryFunc) appendCall(r0 StoreDeleteIndexesWithoutRepositoryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteIndexesWithoutRepositoryFuncCall
// objects describing the invocations of this function.
func (f *StoreDeleteIndexesWithoutRepositoryFunc) History() []StoreDeleteIndexesWithoutRepositoryFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteIndexesWithoutRepositoryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteIndexesWithoutRepositoryFuncCall is an object that describes
// an invocation of method DeleteIndexesWithoutRepository on an instance of
// MockStore.
type StoreDeleteIndexesWithoutRepositoryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[int]int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteIndexesWithoutRepositoryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteIndexesWithoutRepositoryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreDoneFunc describes the behavior when the Done method of the parent
// MockStore instance is invoked.
type StoreDoneFunc struct {
	defaultHook func(error) error
	hooks       []func(error) error
	history     []StoreDoneFuncCall
	mutex       sync.Mutex
}

// Done delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Done(v0 error) error {
	r0 := m.DoneFunc.nextHook()(v0)
	m.DoneFunc.appendCall(StoreDoneFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Done method of the
// parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreDoneFunc) SetDefaultHook(hook func(error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Done method of the parent MockStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreDoneFunc) PushHook(hook func(error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreDoneFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(error) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreDoneFunc) PushReturn(r0 error) {
	f.PushHook(func(error) error {
		return r0
	})
}

func (f *StoreDoneFunc) nextHook() func(error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDoneFunc) appendCall(r0 StoreDoneFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDoneFuncCall objects describing the
// invocations of this function.
func (f *StoreDoneFunc) History() []StoreDoneFuncCall {
	f.mutex.Lock()
	history := make([]StoreDoneFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDoneFuncCall is an object that describes an invocation of method
// Done on an instance of MockStore.
type StoreDoneFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDoneFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDoneFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreExpireFailedRecordsFunc describes the behavior when the
// ExpireFailedRecords method of the parent MockStore instance is invoked.
type StoreExpireFailedRecordsFunc struct {
	defaultHook func(context.Context, int, time.Duration, time.Time) error
	hooks       []func(context.Context, int, time.Duration, time.Time) error
	history     []StoreExpireFailedRecordsFuncCall
	mutex       sync.Mutex
}

// ExpireFailedRecords delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) ExpireFailedRecords(v0 context.Context, v1 int, v2 time.Duration, v3 time.Time) error {
	r0 := m.ExpireFailedRecordsFunc.nextHook()(v0, v1, v2, v3)
	m.ExpireFailedRecordsFunc.appendCall(StoreExpireFailedRecordsFuncCall{v0, v1, v2, v3, r0})
	return r0
}

// SetDefaultHook sets function that is called when the ExpireFailedRecords
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreExpireFailedRecordsFunc) SetDefaultHook(hook func(context.Context, int, time.Duration, time.Time) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ExpireFailedRecords method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreExpireFailedRecordsFunc) PushHook(hook func(context.Context, int, time.Duration, time.Time) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreExpireFailedRecordsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, time.Duration, time.Time) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreExpireFailedRecordsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, time.Duration, time.Time) error {
		return r0
	})
}

func (f *StoreExpireFailedRecordsFunc) nextHook() func(context.Context, int, time.Duration, time.Time) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreExpireFailedRecordsFunc) appendCall(r0 StoreExpireFailedRecordsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreExpireFailedRecordsFuncCall objects
// describing the invocations of this function.
func (f *StoreExpireFailedRecordsFunc) History() []StoreExpireFailedRecordsFuncCall {
	f.mutex.Lock()
	history := make([]StoreExpireFailedRecordsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreExpireFailedRecordsFuncCall is an object that describes an
// invocation of method ExpireFailedRecords on an instance of MockStore.
type StoreExpireFailedRecordsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Duration
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreExpireFailedRecordsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreExpireFailedRecordsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreGetIndexByIDFunc describes the behavior when the GetIndexByID method
// of the parent MockStore instance is invoked.
type StoreGetIndexByIDFunc struct {
	defaultHook func(context.Context, int) (types1.Index, bool, error)
	hooks       []func(context.Context, int) (types1.Index, bool, error)
	history     []StoreGetIndexByIDFuncCall
	mutex       sync.Mutex
}

// GetIndexByID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetIndexByID(v0 context.Context, v1 int) (types1.Index, bool, error) {
	r0, r1, r2 := m.GetIndexByIDFunc.nextHook()(v0, v1)
	m.GetIndexByIDFunc.appendCall(StoreGetIndexByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetIndexByID method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetIndexByIDFunc) SetDefaultHook(hook func(context.Context, int) (types1.Index, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexByID method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetIndexByIDFunc) PushHook(hook func(context.Context, int) (types1.Index, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetIndexByIDFunc) SetDefaultReturn(r0 types1.Index, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (types1.Index, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetIndexByIDFunc) PushReturn(r0 types1.Index, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (types1.Index, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetIndexByIDFunc) nextHook() func(context.Context, int) (types1.Index, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetIndexByIDFunc) appendCall(r0 StoreGetIndexByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetIndexByIDFuncCall objects
// describing the invocations of this function.
func (f *StoreGetIndexByIDFunc) History() []StoreGetIndexByIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetIndexByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetIndexByIDFuncCall is an object that describes an invocation of
// method GetIndexByID on an instance of MockStore.
type StoreGetIndexByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 types1.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetIndexByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetIndexByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetIndexConfigurationByRepositoryIDFunc describes the behavior when
// the GetIndexConfigurationByRepositoryID method of the parent MockStore
// instance is invoked.
type StoreGetIndexConfigurationByRepositoryIDFunc struct {
	defaultHook func(context.Context, int) (shared2.IndexConfiguration, bool, error)
	hooks       []func(context.Context, int) (shared2.IndexConfiguration, bool, error)
	history     []StoreGetIndexConfigurationByRepositoryIDFuncCall
	mutex       sync.Mutex
}

// GetIndexConfigurationByRepositoryID delegates to the next hook function
// in the queue and stores the parameter and result values of this
// invocation.
func (m *MockStore) GetIndexConfigurationByRepositoryID(v0 context.Context, v1 int) (shared2.IndexConfiguration, bool, error) {
	r0, r1, r2 := m.GetIndexConfigurationByRepositoryIDFunc.nextHook()(v0, v1)
	m.GetIndexConfigurationByRepositoryIDFunc.appendCall(StoreGetIndexConfigurationByRepositoryIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// GetIndexConfigurationByRepositoryID method of the parent MockStore
// instance is invoked and the hook queue is empty.
func (f *StoreGetIndexConfigurationByRepositoryIDFunc) SetDefaultHook(hook func(context.Context, int) (shared2.IndexConfiguration, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexConfigurationByRepositoryID method of the parent MockStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *StoreGetIndexConfigurationByRepositoryIDFunc) PushHook(hook func(context.Context, int) (shared2.IndexConfiguration, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetIndexConfigurationByRepositoryIDFunc) SetDefaultReturn(r0 shared2.IndexConfiguration, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (shared2.IndexConfiguration, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetIndexConfigurationByRepositoryIDFunc) PushReturn(r0 shared2.IndexConfiguration, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (shared2.IndexConfiguration, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetIndexConfigurationByRepositoryIDFunc) nextHook() func(context.Context, int) (shared2.IndexConfiguration, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetIndexConfigurationByRepositoryIDFunc) appendCall(r0 StoreGetIndexConfigurationByRepositoryIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// StoreGetIndexConfigurationByRepositoryIDFuncCall objects describing the
// invocations of this function.
func (f *StoreGetIndexConfigurationByRepositoryIDFunc) History() []StoreGetIndexConfigurationByRepositoryIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetIndexConfigurationByRepositoryIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetIndexConfigurationByRepositoryIDFuncCall is an object that
// describes an invocation of method GetIndexConfigurationByRepositoryID on
// an instance of MockStore.
type StoreGetIndexConfigurationByRepositoryIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 shared2.IndexConfiguration
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetIndexConfigurationByRepositoryIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetIndexConfigurationByRepositoryIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetIndexesFunc describes the behavior when the GetIndexes method of
// the parent MockStore instance is invoked.
type StoreGetIndexesFunc struct {
	defaultHook func(context.Context, shared2.GetIndexesOptions) ([]types1.Index, int, error)
	hooks       []func(context.Context, shared2.GetIndexesOptions) ([]types1.Index, int, error)
	history     []StoreGetIndexesFuncCall
	mutex       sync.Mutex
}

// GetIndexes delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetIndexes(v0 context.Context, v1 shared2.GetIndexesOptions) ([]types1.Index, int, error) {
	r0, r1, r2 := m.GetIndexesFunc.nextHook()(v0, v1)
	m.GetIndexesFunc.appendCall(StoreGetIndexesFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetIndexes method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetIndexesFunc) SetDefaultHook(hook func(context.Context, shared2.GetIndexesOptions) ([]types1.Index, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexes method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetIndexesFunc) PushHook(hook func(context.Context, shared2.GetIndexesOptions) ([]types1.Index, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetIndexesFunc) SetDefaultReturn(r0 []types1.Index, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, shared2.GetIndexesOptions) ([]types1.Index, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetIndexesFunc) PushReturn(r0 []types1.Index, r1 int, r2 error) {
	f.PushHook(func(context.Context, shared2.GetIndexesOptions) ([]types1.Index, int, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetIndexesFunc) nextHook() func(context.Context, shared2.GetIndexesOptions) ([]types1.Index, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetIndexesFunc) appendCall(r0 StoreGetIndexesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetIndexesFuncCall objects describing
// the invocations of this function.
func (f *StoreGetIndexesFunc) History() []StoreGetIndexesFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetIndexesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetIndexesFuncCall is an object that describes an invocation of
// method GetIndexes on an instance of MockStore.
type StoreGetIndexesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 shared2.GetIndexesOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types1.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetIndexesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetIndexesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetIndexesByIDsFunc describes the behavior when the GetIndexesByIDs
// method of the parent MockStore instance is invoked.
type StoreGetIndexesByIDsFunc struct {
	defaultHook func(context.Context, ...int) ([]types1.Index, error)
	hooks       []func(context.Context, ...int) ([]types1.Index, error)
	history     []StoreGetIndexesByIDsFuncCall
	mutex       sync.Mutex
}

// GetIndexesByIDs delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) GetIndexesByIDs(v0 context.Context, v1 ...int) ([]types1.Index, error) {
	r0, r1 := m.GetIndexesByIDsFunc.nextHook()(v0, v1...)
	m.GetIndexesByIDsFunc.appendCall(StoreGetIndexesByIDsFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetIndexesByIDs
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreGetIndexesByIDsFunc) SetDefaultHook(hook func(context.Context, ...int) ([]types1.Index, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexesByIDs method of the parent MockStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetIndexesByIDsFunc) PushHook(hook func(context.Context, ...int) ([]types1.Index, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetIndexesByIDsFunc) SetDefaultReturn(r0 []types1.Index, r1 error) {
	f.SetDefaultHook(func(context.Context, ...int) ([]types1.Index, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetIndexesByIDsFunc) PushReturn(r0 []types1.Index, r1 error) {
	f.PushHook(func(context.Context, ...int) ([]types1.Index, error) {
		return r0, r1
	})
}

func (f *StoreGetIndexesByIDsFunc) nextHook() func(context.Context, ...int) ([]types1.Index, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetIndexesByIDsFunc) appendCall(r0 StoreGetIndexesByIDsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetIndexesByIDsFuncCall objects
// describing the invocations of this function.
func (f *StoreGetIndexesByIDsFunc) History() []StoreGetIndexesByIDsFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetIndexesByIDsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetIndexesByIDsFuncCall is an object that describes an invocation of
// method GetIndexesByIDs on an instance of MockStore.
type StoreGetIndexesByIDsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types1.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c StoreGetIndexesByIDsFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetIndexesByIDsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetInferenceScriptFunc describes the behavior when the
// GetInferenceScript method of the parent MockStore instance is invoked.
type StoreGetInferenceScriptFunc struct {
	defaultHook func(context.Context) (string, error)
	hooks       []func(context.Context) (string, error)
	history     []StoreGetInferenceScriptFuncCall
	mutex       sync.Mutex
}

// GetInferenceScript delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) GetInferenceScript(v0 context.Context) (string, error) {
	r0, r1 := m.GetInferenceScriptFunc.nextHook()(v0)
	m.GetInferenceScriptFunc.appendCall(StoreGetInferenceScriptFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetInferenceScript
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreGetInferenceScriptFunc) SetDefaultHook(hook func(context.Context) (string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetInferenceScript method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreGetInferenceScriptFunc) PushHook(hook func(context.Context) (string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetInferenceScriptFunc) SetDefaultReturn(r0 string, r1 error) {
	f.SetDefaultHook(func(context.Context) (string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetInferenceScriptFunc) PushReturn(r0 string, r1 error) {
	f.PushHook(func(context.Context) (string, error) {
		return r0, r1
	})
}

func (f *StoreGetInferenceScriptFunc) nextHook() func(context.Context) (string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetInferenceScriptFunc) appendCall(r0 StoreGetInferenceScriptFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetInferenceScriptFuncCall objects
// describing the invocations of this function.
func (f *StoreGetInferenceScriptFunc) History() []StoreGetInferenceScriptFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetInferenceScriptFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetInferenceScriptFuncCall is an object that describes an invocation
// of method GetInferenceScript on an instance of MockStore.
type StoreGetInferenceScriptFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetInferenceScriptFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetInferenceScriptFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetLanguagesRequestedByFunc describes the behavior when the
// GetLanguagesRequestedBy method of the parent MockStore instance is
// invoked.
type StoreGetLanguagesRequestedByFunc struct {
	defaultHook func(context.Context, int) ([]string, error)
	hooks       []func(context.Context, int) ([]string, error)
	history     []StoreGetLanguagesRequestedByFuncCall
	mutex       sync.Mutex
}

// GetLanguagesRequestedBy delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) GetLanguagesRequestedBy(v0 context.Context, v1 int) ([]string, error) {
	r0, r1 := m.GetLanguagesRequestedByFunc.nextHook()(v0, v1)
	m.GetLanguagesRequestedByFunc.appendCall(StoreGetLanguagesRequestedByFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// GetLanguagesRequestedBy method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreGetLanguagesRequestedByFunc) SetDefaultHook(hook func(context.Context, int) ([]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetLanguagesRequestedBy method of the parent MockStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreGetLanguagesRequestedByFunc) PushHook(hook func(context.Context, int) ([]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetLanguagesRequestedByFunc) SetDefaultReturn(r0 []string, r1 error) {
	f.SetDefaultHook(func(context.Context, int) ([]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetLanguagesRequestedByFunc) PushReturn(r0 []string, r1 error) {
	f.PushHook(func(context.Context, int) ([]string, error) {
		return r0, r1
	})
}

func (f *StoreGetLanguagesRequestedByFunc) nextHook() func(context.Context, int) ([]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetLanguagesRequestedByFunc) appendCall(r0 StoreGetLanguagesRequestedByFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetLanguagesRequestedByFuncCall
// objects describing the invocations of this function.
func (f *StoreGetLanguagesRequestedByFunc) History() []StoreGetLanguagesRequestedByFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetLanguagesRequestedByFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetLanguagesRequestedByFuncCall is an object that describes an
// invocation of method GetLanguagesRequestedBy on an instance of MockStore.
type StoreGetLanguagesRequestedByFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetLanguagesRequestedByFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetLanguagesRequestedByFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetLastIndexScanForRepositoryFunc describes the behavior when the
// GetLastIndexScanForRepository method of the parent MockStore instance is
// invoked.
type StoreGetLastIndexScanForRepositoryFunc struct {
	defaultHook func(context.Context, int) (*time.Time, error)
	hooks       []func(context.Context, int) (*time.Time, error)
	history     []StoreGetLastIndexScanForRepositoryFuncCall
	mutex       sync.Mutex
}

// GetLastIndexScanForRepository delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) GetLastIndexScanForRepository(v0 context.Context, v1 int) (*time.Time, error) {
	r0, r1 := m.GetLastIndexScanForRepositoryFunc.nextHook()(v0, v1)
	m.GetLastIndexScanForRepositoryFunc.appendCall(StoreGetLastIndexScanForRepositoryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// GetLastIndexScanForRepository method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreGetLastIndexScanForRepositoryFunc) SetDefaultHook(hook func(context.Context, int) (*time.Time, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetLastIndexScanForRepository method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreGetLastIndexScanForRepositoryFunc) PushHook(hook func(context.Context, int) (*time.Time, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetLastIndexScanForRepositoryFunc) SetDefaultReturn(r0 *time.Time, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (*time.Time, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetLastIndexScanForRepositoryFunc) PushReturn(r0 *time.Time, r1 error) {
	f.PushHook(func(context.Context, int) (*time.Time, error) {
		return r0, r1
	})
}

func (f *StoreGetLastIndexScanForRepositoryFunc) nextHook() func(context.Context, int) (*time.Time, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetLastIndexScanForRepositoryFunc) appendCall(r0 StoreGetLastIndexScanForRepositoryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetLastIndexScanForRepositoryFuncCall
// objects describing the invocations of this function.
func (f *StoreGetLastIndexScanForRepositoryFunc) History() []StoreGetLastIndexScanForRepositoryFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetLastIndexScanForRepositoryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetLastIndexScanForRepositoryFuncCall is an object that describes an
// invocation of method GetLastIndexScanForRepository on an instance of
// MockStore.
type StoreGetLastIndexScanForRepositoryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *time.Time
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetLastIndexScanForRepositoryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetLastIndexScanForRepositoryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetQueuedRepoRevFunc describes the behavior when the
// GetQueuedRepoRev method of the parent MockStore instance is invoked.
type StoreGetQueuedRepoRevFunc struct {
	defaultHook func(context.Context, int) ([]store.RepoRev, error)
	hooks       []func(context.Context, int) ([]store.RepoRev, error)
	history     []StoreGetQueuedRepoRevFuncCall
	mutex       sync.Mutex
}

// GetQueuedRepoRev delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) GetQueuedRepoRev(v0 context.Context, v1 int) ([]store.RepoRev, error) {
	r0, r1 := m.GetQueuedRepoRevFunc.nextHook()(v0, v1)
	m.GetQueuedRepoRevFunc.appendCall(StoreGetQueuedRepoRevFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetQueuedRepoRev
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreGetQueuedRepoRevFunc) SetDefaultHook(hook func(context.Context, int) ([]store.RepoRev, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetQueuedRepoRev method of the parent MockStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetQueuedRepoRevFunc) PushHook(hook func(context.Context, int) ([]store.RepoRev, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetQueuedRepoRevFunc) SetDefaultReturn(r0 []store.RepoRev, r1 error) {
	f.SetDefaultHook(func(context.Context, int) ([]store.RepoRev, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetQueuedRepoRevFunc) PushReturn(r0 []store.RepoRev, r1 error) {
	f.PushHook(func(context.Context, int) ([]store.RepoRev, error) {
		return r0, r1
	})
}

func (f *StoreGetQueuedRepoRevFunc) nextHook() func(context.Context, int) ([]store.RepoRev, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetQueuedRepoRevFunc) appendCall(r0 StoreGetQueuedRepoRevFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetQueuedRepoRevFuncCall objects
// describing the invocations of this function.
func (f *StoreGetQueuedRepoRevFunc) History() []StoreGetQueuedRepoRevFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetQueuedRepoRevFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetQueuedRepoRevFuncCall is an object that describes an invocation
// of method GetQueuedRepoRev on an instance of MockStore.
type StoreGetQueuedRepoRevFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []store.RepoRev
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetQueuedRepoRevFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetQueuedRepoRevFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetRecentIndexesSummaryFunc describes the behavior when the
// GetRecentIndexesSummary method of the parent MockStore instance is
// invoked.
type StoreGetRecentIndexesSummaryFunc struct {
	defaultHook func(context.Context, int) ([]shared2.IndexesWithRepositoryNamespace, error)
	hooks       []func(context.Context, int) ([]shared2.IndexesWithRepositoryNamespace, error)
	history     []StoreGetRecentIndexesSummaryFuncCall
	mutex       sync.Mutex
}

// GetRecentIndexesSummary delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) GetRecentIndexesSummary(v0 context.Context, v1 int) ([]shared2.IndexesWithRepositoryNamespace, error) {
	r0, r1 := m.GetRecentIndexesSummaryFunc.nextHook()(v0, v1)
	m.GetRecentIndexesSummaryFunc.appendCall(StoreGetRecentIndexesSummaryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// GetRecentIndexesSummary method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreGetRecentIndexesSummaryFunc) SetDefaultHook(hook func(context.Context, int) ([]shared2.IndexesWithRepositoryNamespace, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetRecentIndexesSummary method of the parent MockStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreGetRecentIndexesSummaryFunc) PushHook(hook func(context.Context, int) ([]shared2.IndexesWithRepositoryNamespace, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetRecentIndexesSummaryFunc) SetDefaultReturn(r0 []shared2.IndexesWithRepositoryNamespace, r1 error) {
	f.SetDefaultHook(func(context.Context, int) ([]shared2.IndexesWithRepositoryNamespace, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetRecentIndexesSummaryFunc) PushReturn(r0 []shared2.IndexesWithRepositoryNamespace, r1 error) {
	f.PushHook(func(context.Context, int) ([]shared2.IndexesWithRepositoryNamespace, error) {
		return r0, r1
	})
}

func (f *StoreGetRecentIndexesSummaryFunc) nextHook() func(context.Context, int) ([]shared2.IndexesWithRepositoryNamespace, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetRecentIndexesSummaryFunc) appendCall(r0 StoreGetRecentIndexesSummaryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetRecentIndexesSummaryFuncCall
// objects describing the invocations of this function.
func (f *StoreGetRecentIndexesSummaryFunc) History() []StoreGetRecentIndexesSummaryFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetRecentIndexesSummaryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetRecentIndexesSummaryFuncCall is an object that describes an
// invocation of method GetRecentIndexesSummary on an instance of MockStore.
type StoreGetRecentIndexesSummaryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared2.IndexesWithRepositoryNamespace
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetRecentIndexesSummaryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetRecentIndexesSummaryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetUnsafeDBFunc describes the behavior when the GetUnsafeDB method
// of the parent MockStore instance is invoked.
type StoreGetUnsafeDBFunc struct {
	defaultHook func() database.DB
	hooks       []func() database.DB
	history     []StoreGetUnsafeDBFuncCall
	mutex       sync.Mutex
}

// GetUnsafeDB delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetUnsafeDB() database.DB {
	r0 := m.GetUnsafeDBFunc.nextHook()()
	m.GetUnsafeDBFunc.appendCall(StoreGetUnsafeDBFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the GetUnsafeDB method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetUnsafeDBFunc) SetDefaultHook(hook func() database.DB) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUnsafeDB method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetUnsafeDBFunc) PushHook(hook func() database.DB) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetUnsafeDBFunc) SetDefaultReturn(r0 database.DB) {
	f.SetDefaultHook(func() database.DB {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetUnsafeDBFunc) PushReturn(r0 database.DB) {
	f.PushHook(func() database.DB {
		return r0
	})
}

func (f *StoreGetUnsafeDBFunc) nextHook() func() database.DB {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetUnsafeDBFunc) appendCall(r0 StoreGetUnsafeDBFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetUnsafeDBFuncCall objects describing
// the invocations of this function.
func (f *StoreGetUnsafeDBFunc) History() []StoreGetUnsafeDBFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetUnsafeDBFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetUnsafeDBFuncCall is an object that describes an invocation of
// method GetUnsafeDB on an instance of MockStore.
type StoreGetUnsafeDBFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 database.DB
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetUnsafeDBFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetUnsafeDBFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreInsertDependencyIndexingJobFunc describes the behavior when the
// InsertDependencyIndexingJob method of the parent MockStore instance is
// invoked.
type StoreInsertDependencyIndexingJobFunc struct {
	defaultHook func(context.Context, int, string, time.Time) (int, error)
	hooks       []func(context.Context, int, string, time.Time) (int, error)
	history     []StoreInsertDependencyIndexingJobFuncCall
	mutex       sync.Mutex
}

// InsertDependencyIndexingJob delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) InsertDependencyIndexingJob(v0 context.Context, v1 int, v2 string, v3 time.Time) (int, error) {
	r0, r1 := m.InsertDependencyIndexingJobFunc.nextHook()(v0, v1, v2, v3)
	m.InsertDependencyIndexingJobFunc.appendCall(StoreInsertDependencyIndexingJobFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// InsertDependencyIndexingJob method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreInsertDependencyIndexingJobFunc) SetDefaultHook(hook func(context.Context, int, string, time.Time) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertDependencyIndexingJob method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreInsertDependencyIndexingJobFunc) PushHook(hook func(context.Context, int, string, time.Time) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreInsertDependencyIndexingJobFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, time.Time) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreInsertDependencyIndexingJobFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int, string, time.Time) (int, error) {
		return r0, r1
	})
}

func (f *StoreInsertDependencyIndexingJobFunc) nextHook() func(context.Context, int, string, time.Time) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreInsertDependencyIndexingJobFunc) appendCall(r0 StoreInsertDependencyIndexingJobFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreInsertDependencyIndexingJobFuncCall
// objects describing the invocations of this function.
func (f *StoreInsertDependencyIndexingJobFunc) History() []StoreInsertDependencyIndexingJobFuncCall {
	f.mutex.Lock()
	history := make([]StoreInsertDependencyIndexingJobFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreInsertDependencyIndexingJobFuncCall is an object that describes an
// invocation of method InsertDependencyIndexingJob on an instance of
// MockStore.
type StoreInsertDependencyIndexingJobFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreInsertDependencyIndexingJobFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreInsertDependencyIndexingJobFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreInsertIndexesFunc describes the behavior when the InsertIndexes
// method of the parent MockStore instance is invoked.
type StoreInsertIndexesFunc struct {
	defaultHook func(context.Context, []types1.Index) ([]types1.Index, error)
	hooks       []func(context.Context, []types1.Index) ([]types1.Index, error)
	history     []StoreInsertIndexesFuncCall
	mutex       sync.Mutex
}

// InsertIndexes delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) InsertIndexes(v0 context.Context, v1 []types1.Index) ([]types1.Index, error) {
	r0, r1 := m.InsertIndexesFunc.nextHook()(v0, v1)
	m.InsertIndexesFunc.appendCall(StoreInsertIndexesFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the InsertIndexes method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreInsertIndexesFunc) SetDefaultHook(hook func(context.Context, []types1.Index) ([]types1.Index, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertIndexes method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreInsertIndexesFunc) PushHook(hook func(context.Context, []types1.Index) ([]types1.Index, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreInsertIndexesFunc) SetDefaultReturn(r0 []types1.Index, r1 error) {
	f.SetDefaultHook(func(context.Context, []types1.Index) ([]types1.Index, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreInsertIndexesFunc) PushReturn(r0 []types1.Index, r1 error) {
	f.PushHook(func(context.Context, []types1.Index) ([]types1.Index, error) {
		return r0, r1
	})
}

func (f *StoreInsertIndexesFunc) nextHook() func(context.Context, []types1.Index) ([]types1.Index, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreInsertIndexesFunc) appendCall(r0 StoreInsertIndexesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreInsertIndexesFuncCall objects
// describing the invocations of this function.
func (f *StoreInsertIndexesFunc) History() []StoreInsertIndexesFuncCall {
	f.mutex.Lock()
	history := make([]StoreInsertIndexesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreInsertIndexesFuncCall is an object that describes an invocation of
// method InsertIndexes on an instance of MockStore.
type StoreInsertIndexesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []types1.Index
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types1.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreInsertIndexesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreInsertIndexesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreIsQueuedFunc describes the behavior when the IsQueued method of the
// parent MockStore instance is invoked.
type StoreIsQueuedFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []StoreIsQueuedFuncCall
	mutex       sync.Mutex
}

// IsQueued delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) IsQueued(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.IsQueuedFunc.nextHook()(v0, v1, v2)
	m.IsQueuedFunc.appendCall(StoreIsQueuedFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the IsQueued method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreIsQueuedFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// IsQueued method of the parent MockStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreIsQueuedFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreIsQueuedFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreIsQueuedFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *StoreIsQueuedFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreIsQueuedFunc) appendCall(r0 StoreIsQueuedFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreIsQueuedFuncCall objects describing
// the invocations of this function.
func (f *StoreIsQueuedFunc) History() []StoreIsQueuedFuncCall {
	f.mutex.Lock()
	history := make([]StoreIsQueuedFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreIsQueuedFuncCall is an object that describes an invocation of method
// IsQueued on an instance of MockStore.
type StoreIsQueuedFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreIsQueuedFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreIsQueuedFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreIsQueuedRootIndexerFunc describes the behavior when the
// IsQueuedRootIndexer method of the parent MockStore instance is invoked.
type StoreIsQueuedRootIndexerFunc struct {
	defaultHook func(context.Context, int, string, string, string) (bool, error)
	hooks       []func(context.Context, int, string, string, string) (bool, error)
	history     []StoreIsQueuedRootIndexerFuncCall
	mutex       sync.Mutex
}

// IsQueuedRootIndexer delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) IsQueuedRootIndexer(v0 context.Context, v1 int, v2 string, v3 string, v4 string) (bool, error) {
	r0, r1 := m.IsQueuedRootIndexerFunc.nextHook()(v0, v1, v2, v3, v4)
	m.IsQueuedRootIndexerFunc.appendCall(StoreIsQueuedRootIndexerFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the IsQueuedRootIndexer
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreIsQueuedRootIndexerFunc) SetDefaultHook(hook func(context.Context, int, string, string, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// IsQueuedRootIndexer method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreIsQueuedRootIndexerFunc) PushHook(hook func(context.Context, int, string, string, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreIsQueuedRootIndexerFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreIsQueuedRootIndexerFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string, string, string) (bool, error) {
		return r0, r1
	})
}

func (f *StoreIsQueuedRootIndexerFunc) nextHook() func(context.Context, int, string, string, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreIsQueuedRootIndexerFunc) appendCall(r0 StoreIsQueuedRootIndexerFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreIsQueuedRootIndexerFuncCall objects
// describing the invocations of this function.
func (f *StoreIsQueuedRootIndexerFunc) History() []StoreIsQueuedRootIndexerFuncCall {
	f.mutex.Lock()
	history := make([]StoreIsQueuedRootIndexerFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreIsQueuedRootIndexerFuncCall is an object that describes an
// invocation of method IsQueuedRootIndexer on an instance of MockStore.
type StoreIsQueuedRootIndexerFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreIsQueuedRootIndexerFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreIsQueuedRootIndexerFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreMarkRepoRevsAsProcessedFunc describes the behavior when the
// MarkRepoRevsAsProcessed method of the parent MockStore instance is
// invoked.
type StoreMarkRepoRevsAsProcessedFunc struct {
	defaultHook func(context.Context, []int) error
	hooks       []func(context.Context, []int) error
	history     []StoreMarkRepoRevsAsProcessedFuncCall
	mutex       sync.Mutex
}

// MarkRepoRevsAsProcessed delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) MarkRepoRevsAsProcessed(v0 context.Context, v1 []int) error {
	r0 := m.MarkRepoRevsAsProcessedFunc.nextHook()(v0, v1)
	m.MarkRepoRevsAsProcessedFunc.appendCall(StoreMarkRepoRevsAsProcessedFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// MarkRepoRevsAsProcessed method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreMarkRepoRevsAsProcessedFunc) SetDefaultHook(hook func(context.Context, []int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkRepoRevsAsProcessed method of the parent MockStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreMarkRepoRevsAsProcessedFunc) PushHook(hook func(context.Context, []int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreMarkRepoRevsAsProcessedFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, []int) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreMarkRepoRevsAsProcessedFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, []int) error {
		return r0
	})
}

func (f *StoreMarkRepoRevsAsProcessedFunc) nextHook() func(context.Context, []int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreMarkRepoRevsAsProcessedFunc) appendCall(r0 StoreMarkRepoRevsAsProcessedFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreMarkRepoRevsAsProcessedFuncCall
// objects describing the invocations of this function.
func (f *StoreMarkRepoRevsAsProcessedFunc) History() []StoreMarkRepoRevsAsProcessedFuncCall {
	f.mutex.Lock()
	history := make([]StoreMarkRepoRevsAsProcessedFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreMarkRepoRevsAsProcessedFuncCall is an object that describes an
// invocation of method MarkRepoRevsAsProcessed on an instance of MockStore.
type StoreMarkRepoRevsAsProcessedFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreMarkRepoRevsAsProcessedFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreMarkRepoRevsAsProcessedFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreProcessStaleSourcedCommitsFunc describes the behavior when the
// ProcessStaleSourcedCommits method of the parent MockStore instance is
// invoked.
type StoreProcessStaleSourcedCommitsFunc struct {
	defaultHook func(context.Context, time.Duration, int, time.Duration, func(ctx context.Context, repositoryID int, commit string) (bool, error)) (int, error)
	hooks       []func(context.Context, time.Duration, int, time.Duration, func(ctx context.Context, repositoryID int, commit string) (bool, error)) (int, error)
	history     []StoreProcessStaleSourcedCommitsFuncCall
	mutex       sync.Mutex
}

// ProcessStaleSourcedCommits delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) ProcessStaleSourcedCommits(v0 context.Context, v1 time.Duration, v2 int, v3 time.Duration, v4 func(ctx context.Context, repositoryID int, commit string) (bool, error)) (int, error) {
	r0, r1 := m.ProcessStaleSourcedCommitsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.ProcessStaleSourcedCommitsFunc.appendCall(StoreProcessStaleSourcedCommitsFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// ProcessStaleSourcedCommits method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreProcessStaleSourcedCommitsFunc) SetDefaultHook(hook func(context.Context, time.Duration, int, time.Duration, func(ctx context.Context, repositoryID int, commit string) (bool, error)) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ProcessStaleSourcedCommits method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreProcessStaleSourcedCommitsFunc) PushHook(hook func(context.Context, time.Duration, int, time.Duration, func(ctx context.Context, repositoryID int, commit string) (bool, error)) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreProcessStaleSourcedCommitsFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Duration, int, time.Duration, func(ctx context.Context, repositoryID int, commit string) (bool, error)) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreProcessStaleSourcedCommitsFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, time.Duration, int, time.Duration, func(ctx context.Context, repositoryID int, commit string) (bool, error)) (int, error) {
		return r0, r1
	})
}

func (f *StoreProcessStaleSourcedCommitsFunc) nextHook() func(context.Context, time.Duration, int, time.Duration, func(ctx context.Context, repositoryID int, commit string) (bool, error)) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreProcessStaleSourcedCommitsFunc) appendCall(r0 StoreProcessStaleSourcedCommitsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreProcessStaleSourcedCommitsFuncCall
// objects describing the invocations of this function.
func (f *StoreProcessStaleSourcedCommitsFunc) History() []StoreProcessStaleSourcedCommitsFuncCall {
	f.mutex.Lock()
	history := make([]StoreProcessStaleSourcedCommitsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreProcessStaleSourcedCommitsFuncCall is an object that describes an
// invocation of method ProcessStaleSourcedCommits on an instance of
// MockStore.
type StoreProcessStaleSourcedCommitsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Duration
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 time.Duration
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 func(ctx context.Context, repositoryID int, commit string) (bool, error)
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreProcessStaleSourcedCommitsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreProcessStaleSourcedCommitsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreQueueRepoRevFunc describes the behavior when the QueueRepoRev method
// of the parent MockStore instance is invoked.
type StoreQueueRepoRevFunc struct {
	defaultHook func(context.Context, int, string) error
	hooks       []func(context.Context, int, string) error
	history     []StoreQueueRepoRevFuncCall
	mutex       sync.Mutex
}

// QueueRepoRev delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) QueueRepoRev(v0 context.Context, v1 int, v2 string) error {
	r0 := m.QueueRepoRevFunc.nextHook()(v0, v1, v2)
	m.QueueRepoRevFunc.appendCall(StoreQueueRepoRevFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the QueueRepoRev method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreQueueRepoRevFunc) SetDefaultHook(hook func(context.Context, int, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// QueueRepoRev method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreQueueRepoRevFunc) PushHook(hook func(context.Context, int, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreQueueRepoRevFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreQueueRepoRevFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string) error {
		return r0
	})
}

func (f *StoreQueueRepoRevFunc) nextHook() func(context.Context, int, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreQueueRepoRevFunc) appendCall(r0 StoreQueueRepoRevFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreQueueRepoRevFuncCall objects
// describing the invocations of this function.
func (f *StoreQueueRepoRevFunc) History() []StoreQueueRepoRevFuncCall {
	f.mutex.Lock()
	history := make([]StoreQueueRepoRevFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreQueueRepoRevFuncCall is an object that describes an invocation of
// method QueueRepoRev on an instance of MockStore.
type StoreQueueRepoRevFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreQueueRepoRevFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreQueueRepoRevFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreReindexIndexByIDFunc describes the behavior when the
// ReindexIndexByID method of the parent MockStore instance is invoked.
type StoreReindexIndexByIDFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []StoreReindexIndexByIDFuncCall
	mutex       sync.Mutex
}

// ReindexIndexByID delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) ReindexIndexByID(v0 context.Context, v1 int) error {
	r0 := m.ReindexIndexByIDFunc.nextHook()(v0, v1)
	m.ReindexIndexByIDFunc.appendCall(StoreReindexIndexByIDFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the ReindexIndexByID
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreReindexIndexByIDFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReindexIndexByID method of the parent MockStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreReindexIndexByIDFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreReindexIndexByIDFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreReindexIndexByIDFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *StoreReindexIndexByIDFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreReindexIndexByIDFunc) appendCall(r0 StoreReindexIndexByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreReindexIndexByIDFuncCall objects
// describing the invocations of this function.
func (f *StoreReindexIndexByIDFunc) History() []StoreReindexIndexByIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreReindexIndexByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreReindexIndexByIDFuncCall is an object that describes an invocation
// of method ReindexIndexByID on an instance of MockStore.
type StoreReindexIndexByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreReindexIndexByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreReindexIndexByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreReindexIndexesFunc describes the behavior when the ReindexIndexes
// method of the parent MockStore instance is invoked.
type StoreReindexIndexesFunc struct {
	defaultHook func(context.Context, shared2.ReindexIndexesOptions) error
	hooks       []func(context.Context, shared2.ReindexIndexesOptions) error
	history     []StoreReindexIndexesFuncCall
	mutex       sync.Mutex
}

// ReindexIndexes delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) ReindexIndexes(v0 context.Context, v1 shared2.ReindexIndexesOptions) error {
	r0 := m.ReindexIndexesFunc.nextHook()(v0, v1)
	m.ReindexIndexesFunc.appendCall(StoreReindexIndexesFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the ReindexIndexes
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreReindexIndexesFunc) SetDefaultHook(hook func(context.Context, shared2.ReindexIndexesOptions) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReindexIndexes method of the parent MockStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreReindexIndexesFunc) PushHook(hook func(context.Context, shared2.ReindexIndexesOptions) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreReindexIndexesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, shared2.ReindexIndexesOptions) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreReindexIndexesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, shared2.ReindexIndexesOptions) error {
		return r0
	})
}

func (f *StoreReindexIndexesFunc) nextHook() func(context.Context, shared2.ReindexIndexesOptions) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreReindexIndexesFunc) appendCall(r0 StoreReindexIndexesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreReindexIndexesFuncCall objects
// describing the invocations of this function.
func (f *StoreReindexIndexesFunc) History() []StoreReindexIndexesFuncCall {
	f.mutex.Lock()
	history := make([]StoreReindexIndexesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreReindexIndexesFuncCall is an object that describes an invocation of
// method ReindexIndexes on an instance of MockStore.
type StoreReindexIndexesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 shared2.ReindexIndexesOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreReindexIndexesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreReindexIndexesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreSetInferenceScriptFunc describes the behavior when the
// SetInferenceScript method of the parent MockStore instance is invoked.
type StoreSetInferenceScriptFunc struct {
	defaultHook func(context.Context, string) error
	hooks       []func(context.Context, string) error
	history     []StoreSetInferenceScriptFuncCall
	mutex       sync.Mutex
}

// SetInferenceScript delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) SetInferenceScript(v0 context.Context, v1 string) error {
	r0 := m.SetInferenceScriptFunc.nextHook()(v0, v1)
	m.SetInferenceScriptFunc.appendCall(StoreSetInferenceScriptFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the SetInferenceScript
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreSetInferenceScriptFunc) SetDefaultHook(hook func(context.Context, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SetInferenceScript method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreSetInferenceScriptFunc) PushHook(hook func(context.Context, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreSetInferenceScriptFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, string) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreSetInferenceScriptFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, string) error {
		return r0
	})
}

func (f *StoreSetInferenceScriptFunc) nextHook() func(context.Context, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreSetInferenceScriptFunc) appendCall(r0 StoreSetInferenceScriptFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreSetInferenceScriptFuncCall objects
// describing the invocations of this function.
func (f *StoreSetInferenceScriptFunc) History() []StoreSetInferenceScriptFuncCall {
	f.mutex.Lock()
	history := make([]StoreSetInferenceScriptFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreSetInferenceScriptFuncCall is an object that describes an invocation
// of method SetInferenceScript on an instance of MockStore.
type StoreSetInferenceScriptFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreSetInferenceScriptFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreSetInferenceScriptFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreSetRequestLanguageSupportFunc describes the behavior when the
// SetRequestLanguageSupport method of the parent MockStore instance is
// invoked.
type StoreSetRequestLanguageSupportFunc struct {
	defaultHook func(context.Context, int, string) error
	hooks       []func(context.Context, int, string) error
	history     []StoreSetRequestLanguageSupportFuncCall
	mutex       sync.Mutex
}

// SetRequestLanguageSupport delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) SetRequestLanguageSupport(v0 context.Context, v1 int, v2 string) error {
	r0 := m.SetRequestLanguageSupportFunc.nextHook()(v0, v1, v2)
	m.SetRequestLanguageSupportFunc.appendCall(StoreSetRequestLanguageSupportFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// SetRequestLanguageSupport method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreSetRequestLanguageSupportFunc) SetDefaultHook(hook func(context.Context, int, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SetRequestLanguageSupport method of the parent MockStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreSetRequestLanguageSupportFunc) PushHook(hook func(context.Context, int, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreSetRequestLanguageSupportFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreSetRequestLanguageSupportFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string) error {
		return r0
	})
}

func (f *StoreSetRequestLanguageSupportFunc) nextHook() func(context.Context, int, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreSetRequestLanguageSupportFunc) appendCall(r0 StoreSetRequestLanguageSupportFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreSetRequestLanguageSupportFuncCall
// objects describing the invocations of this function.
func (f *StoreSetRequestLanguageSupportFunc) History() []StoreSetRequestLanguageSupportFuncCall {
	f.mutex.Lock()
	history := make([]StoreSetRequestLanguageSupportFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreSetRequestLanguageSupportFuncCall is an object that describes an
// invocation of method SetRequestLanguageSupport on an instance of
// MockStore.
type StoreSetRequestLanguageSupportFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreSetRequestLanguageSupportFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreSetRequestLanguageSupportFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreTransactFunc describes the behavior when the Transact method of the
// parent MockStore instance is invoked.
type StoreTransactFunc struct {
	defaultHook func(context.Context) (store.Store, error)
	hooks       []func(context.Context) (store.Store, error)
	history     []StoreTransactFuncCall
	mutex       sync.Mutex
}

// Transact delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Transact(v0 context.Context) (store.Store, error) {
	r0, r1 := m.TransactFunc.nextHook()(v0)
	m.TransactFunc.appendCall(StoreTransactFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Transact method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreTransactFunc) SetDefaultHook(hook func(context.Context) (store.Store, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Transact method of the parent MockStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreTransactFunc) PushHook(hook func(context.Context) (store.Store, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreTransactFunc) SetDefaultReturn(r0 store.Store, r1 error) {
	f.SetDefaultHook(func(context.Context) (store.Store, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreTransactFunc) PushReturn(r0 store.Store, r1 error) {
	f.PushHook(func(context.Context) (store.Store, error) {
		return r0, r1
	})
}

func (f *StoreTransactFunc) nextHook() func(context.Context) (store.Store, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreTransactFunc) appendCall(r0 StoreTransactFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreTransactFuncCall objects describing
// the invocations of this function.
func (f *StoreTransactFunc) History() []StoreTransactFuncCall {
	f.mutex.Lock()
	history := make([]StoreTransactFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreTransactFuncCall is an object that describes an invocation of method
// Transact on an instance of MockStore.
type StoreTransactFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Store
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreTransactFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreTransactFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreUpdateIndexConfigurationByRepositoryIDFunc describes the behavior
// when the UpdateIndexConfigurationByRepositoryID method of the parent
// MockStore instance is invoked.
type StoreUpdateIndexConfigurationByRepositoryIDFunc struct {
	defaultHook func(context.Context, int, []byte) error
	hooks       []func(context.Context, int, []byte) error
	history     []StoreUpdateIndexConfigurationByRepositoryIDFuncCall
	mutex       sync.Mutex
}

// UpdateIndexConfigurationByRepositoryID delegates to the next hook
// function in the queue and stores the parameter and result values of this
// invocation.
func (m *MockStore) UpdateIndexConfigurationByRepositoryID(v0 context.Context, v1 int, v2 []byte) error {
	r0 := m.UpdateIndexConfigurationByRepositoryIDFunc.nextHook()(v0, v1, v2)
	m.UpdateIndexConfigurationByRepositoryIDFunc.appendCall(StoreUpdateIndexConfigurationByRepositoryIDFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdateIndexConfigurationByRepositoryID method of the parent MockStore
// instance is invoked and the hook queue is empty.
func (f *StoreUpdateIndexConfigurationByRepositoryIDFunc) SetDefaultHook(hook func(context.Context, int, []byte) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateIndexConfigurationByRepositoryID method of the parent MockStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *StoreUpdateIndexConfigurationByRepositoryIDFunc) PushHook(hook func(context.Context, int, []byte) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreUpdateIndexConfigurationByRepositoryIDFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, []byte) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreUpdateIndexConfigurationByRepositoryIDFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, []byte) error {
		return r0
	})
}

func (f *StoreUpdateIndexConfigurationByRepositoryIDFunc) nextHook() func(context.Context, int, []byte) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreUpdateIndexConfigurationByRepositoryIDFunc) appendCall(r0 StoreUpdateIndexConfigurationByRepositoryIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// StoreUpdateIndexConfigurationByRepositoryIDFuncCall objects describing
// the invocations of this function.
func (f *StoreUpdateIndexConfigurationByRepositoryIDFunc) History() []StoreUpdateIndexConfigurationByRepositoryIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreUpdateIndexConfigurationByRepositoryIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreUpdateIndexConfigurationByRepositoryIDFuncCall is an object that
// describes an invocation of method UpdateIndexConfigurationByRepositoryID
// on an instance of MockStore.
type StoreUpdateIndexConfigurationByRepositoryIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []byte
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreUpdateIndexConfigurationByRepositoryIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreUpdateIndexConfigurationByRepositoryIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// MockWorkerStore is a mock implementation of the Store interface (from the
// package
// github.com/sourcegraph/sourcegraph/internal/workerutil/dbworker/store)
// used for unit testing.
type MockWorkerStore[T workerutil.Record] struct {
	// AddExecutionLogEntryFunc is an instance of a mock function object
	// controlling the behavior of the method AddExecutionLogEntry.
	AddExecutionLogEntryFunc *WorkerStoreAddExecutionLogEntryFunc[T]
	// DequeueFunc is an instance of a mock function object controlling the
	// behavior of the method Dequeue.
	DequeueFunc *WorkerStoreDequeueFunc[T]
	// HandleFunc is an instance of a mock function object controlling the
	// behavior of the method Handle.
	HandleFunc *WorkerStoreHandleFunc[T]
	// HeartbeatFunc is an instance of a mock function object controlling
	// the behavior of the method Heartbeat.
	HeartbeatFunc *WorkerStoreHeartbeatFunc[T]
	// MarkCompleteFunc is an instance of a mock function object controlling
	// the behavior of the method MarkComplete.
	MarkCompleteFunc *WorkerStoreMarkCompleteFunc[T]
	// MarkErroredFunc is an instance of a mock function object controlling
	// the behavior of the method MarkErrored.
	MarkErroredFunc *WorkerStoreMarkErroredFunc[T]
	// MarkFailedFunc is an instance of a mock function object controlling
	// the behavior of the method MarkFailed.
	MarkFailedFunc *WorkerStoreMarkFailedFunc[T]
	// MaxDurationInQueueFunc is an instance of a mock function object
	// controlling the behavior of the method MaxDurationInQueue.
	MaxDurationInQueueFunc *WorkerStoreMaxDurationInQueueFunc[T]
	// QueuedCountFunc is an instance of a mock function object controlling
	// the behavior of the method QueuedCount.
	QueuedCountFunc *WorkerStoreQueuedCountFunc[T]
	// RequeueFunc is an instance of a mock function object controlling the
	// behavior of the method Requeue.
	RequeueFunc *WorkerStoreRequeueFunc[T]
	// ResetStalledFunc is an instance of a mock function object controlling
	// the behavior of the method ResetStalled.
	ResetStalledFunc *WorkerStoreResetStalledFunc[T]
	// UpdateExecutionLogEntryFunc is an instance of a mock function object
	// controlling the behavior of the method UpdateExecutionLogEntry.
	UpdateExecutionLogEntryFunc *WorkerStoreUpdateExecutionLogEntryFunc[T]
	// WithFunc is an instance of a mock function object controlling the
	// behavior of the method With.
	WithFunc *WorkerStoreWithFunc[T]
}

// NewMockWorkerStore creates a new mock of the Store interface. All methods
// return zero values for all results, unless overwritten.
func NewMockWorkerStore[T workerutil.Record]() *MockWorkerStore[T] {
	return &MockWorkerStore[T]{
		AddExecutionLogEntryFunc: &WorkerStoreAddExecutionLogEntryFunc[T]{
			defaultHook: func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (r0 int, r1 error) {
				return
			},
		},
		DequeueFunc: &WorkerStoreDequeueFunc[T]{
			defaultHook: func(context.Context, string, []*sqlf.Query) (r0 T, r1 bool, r2 error) {
				return
			},
		},
		HandleFunc: &WorkerStoreHandleFunc[T]{
			defaultHook: func() (r0 basestore.TransactableHandle) {
				return
			},
		},
		HeartbeatFunc: &WorkerStoreHeartbeatFunc[T]{
			defaultHook: func(context.Context, []int, store1.HeartbeatOptions) (r0 []int, r1 []int, r2 error) {
				return
			},
		},
		MarkCompleteFunc: &WorkerStoreMarkCompleteFunc[T]{
			defaultHook: func(context.Context, int, store1.MarkFinalOptions) (r0 bool, r1 error) {
				return
			},
		},
		MarkErroredFunc: &WorkerStoreMarkErroredFunc[T]{
			defaultHook: func(context.Context, int, string, store1.MarkFinalOptions) (r0 bool, r1 error) {
				return
			},
		},
		MarkFailedFunc: &WorkerStoreMarkFailedFunc[T]{
			defaultHook: func(context.Context, int, string, store1.MarkFinalOptions) (r0 bool, r1 error) {
				return
			},
		},
		MaxDurationInQueueFunc: &WorkerStoreMaxDurationInQueueFunc[T]{
			defaultHook: func(context.Context) (r0 time.Duration, r1 error) {
				return
			},
		},
		QueuedCountFunc: &WorkerStoreQueuedCountFunc[T]{
			defaultHook: func(context.Context, bool) (r0 int, r1 error) {
				return
			},
		},
		RequeueFunc: &WorkerStoreRequeueFunc[T]{
			defaultHook: func(context.Context, int, time.Time) (r0 error) {
				return
			},
		},
		ResetStalledFunc: &WorkerStoreResetStalledFunc[T]{
			defaultHook: func(context.Context) (r0 map[int]time.Duration, r1 map[int]time.Duration, r2 error) {
				return
			},
		},
		UpdateExecutionLogEntryFunc: &WorkerStoreUpdateExecutionLogEntryFunc[T]{
			defaultHook: func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (r0 error) {
				return
			},
		},
		WithFunc: &WorkerStoreWithFunc[T]{
			defaultHook: func(basestore.ShareableStore) (r0 store1.Store[T]) {
				return
			},
		},
	}
}

// NewStrictMockWorkerStore creates a new mock of the Store interface. All
// methods panic on invocation, unless overwritten.
func NewStrictMockWorkerStore[T workerutil.Record]() *MockWorkerStore[T] {
	return &MockWorkerStore[T]{
		AddExecutionLogEntryFunc: &WorkerStoreAddExecutionLogEntryFunc[T]{
			defaultHook: func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (int, error) {
				panic("unexpected invocation of MockWorkerStore.AddExecutionLogEntry")
			},
		},
		DequeueFunc: &WorkerStoreDequeueFunc[T]{
			defaultHook: func(context.Context, string, []*sqlf.Query) (T, bool, error) {
				panic("unexpected invocation of MockWorkerStore.Dequeue")
			},
		},
		HandleFunc: &WorkerStoreHandleFunc[T]{
			defaultHook: func() basestore.TransactableHandle {
				panic("unexpected invocation of MockWorkerStore.Handle")
			},
		},
		HeartbeatFunc: &WorkerStoreHeartbeatFunc[T]{
			defaultHook: func(context.Context, []int, store1.HeartbeatOptions) ([]int, []int, error) {
				panic("unexpected invocation of MockWorkerStore.Heartbeat")
			},
		},
		MarkCompleteFunc: &WorkerStoreMarkCompleteFunc[T]{
			defaultHook: func(context.Context, int, store1.MarkFinalOptions) (bool, error) {
				panic("unexpected invocation of MockWorkerStore.MarkComplete")
			},
		},
		MarkErroredFunc: &WorkerStoreMarkErroredFunc[T]{
			defaultHook: func(context.Context, int, string, store1.MarkFinalOptions) (bool, error) {
				panic("unexpected invocation of MockWorkerStore.MarkErrored")
			},
		},
		MarkFailedFunc: &WorkerStoreMarkFailedFunc[T]{
			defaultHook: func(context.Context, int, string, store1.MarkFinalOptions) (bool, error) {
				panic("unexpected invocation of MockWorkerStore.MarkFailed")
			},
		},
		MaxDurationInQueueFunc: &WorkerStoreMaxDurationInQueueFunc[T]{
			defaultHook: func(context.Context) (time.Duration, error) {
				panic("unexpected invocation of MockWorkerStore.MaxDurationInQueue")
			},
		},
		QueuedCountFunc: &WorkerStoreQueuedCountFunc[T]{
			defaultHook: func(context.Context, bool) (int, error) {
				panic("unexpected invocation of MockWorkerStore.QueuedCount")
			},
		},
		RequeueFunc: &WorkerStoreRequeueFunc[T]{
			defaultHook: func(context.Context, int, time.Time) error {
				panic("unexpected invocation of MockWorkerStore.Requeue")
			},
		},
		ResetStalledFunc: &WorkerStoreResetStalledFunc[T]{
			defaultHook: func(context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
				panic("unexpected invocation of MockWorkerStore.ResetStalled")
			},
		},
		UpdateExecutionLogEntryFunc: &WorkerStoreUpdateExecutionLogEntryFunc[T]{
			defaultHook: func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) error {
				panic("unexpected invocation of MockWorkerStore.UpdateExecutionLogEntry")
			},
		},
		WithFunc: &WorkerStoreWithFunc[T]{
			defaultHook: func(basestore.ShareableStore) store1.Store[T] {
				panic("unexpected invocation of MockWorkerStore.With")
			},
		},
	}
}

// NewMockWorkerStoreFrom creates a new mock of the MockWorkerStore
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockWorkerStoreFrom[T workerutil.Record](i store1.Store[T]) *MockWorkerStore[T] {
	return &MockWorkerStore[T]{
		AddExecutionLogEntryFunc: &WorkerStoreAddExecutionLogEntryFunc[T]{
			defaultHook: i.AddExecutionLogEntry,
		},
		DequeueFunc: &WorkerStoreDequeueFunc[T]{
			defaultHook: i.Dequeue,
		},
		HandleFunc: &WorkerStoreHandleFunc[T]{
			defaultHook: i.Handle,
		},
		HeartbeatFunc: &WorkerStoreHeartbeatFunc[T]{
			defaultHook: i.Heartbeat,
		},
		MarkCompleteFunc: &WorkerStoreMarkCompleteFunc[T]{
			defaultHook: i.MarkComplete,
		},
		MarkErroredFunc: &WorkerStoreMarkErroredFunc[T]{
			defaultHook: i.MarkErrored,
		},
		MarkFailedFunc: &WorkerStoreMarkFailedFunc[T]{
			defaultHook: i.MarkFailed,
		},
		MaxDurationInQueueFunc: &WorkerStoreMaxDurationInQueueFunc[T]{
			defaultHook: i.MaxDurationInQueue,
		},
		QueuedCountFunc: &WorkerStoreQueuedCountFunc[T]{
			defaultHook: i.QueuedCount,
		},
		RequeueFunc: &WorkerStoreRequeueFunc[T]{
			defaultHook: i.Requeue,
		},
		ResetStalledFunc: &WorkerStoreResetStalledFunc[T]{
			defaultHook: i.ResetStalled,
		},
		UpdateExecutionLogEntryFunc: &WorkerStoreUpdateExecutionLogEntryFunc[T]{
			defaultHook: i.UpdateExecutionLogEntry,
		},
		WithFunc: &WorkerStoreWithFunc[T]{
			defaultHook: i.With,
		},
	}
}

// WorkerStoreAddExecutionLogEntryFunc describes the behavior when the
// AddExecutionLogEntry method of the parent MockWorkerStore instance is
// invoked.
type WorkerStoreAddExecutionLogEntryFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (int, error)
	hooks       []func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (int, error)
	history     []WorkerStoreAddExecutionLogEntryFuncCall[T]
	mutex       sync.Mutex
}

// AddExecutionLogEntry delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockWorkerStore[T]) AddExecutionLogEntry(v0 context.Context, v1 int, v2 executor.ExecutionLogEntry, v3 store1.ExecutionLogEntryOptions) (int, error) {
	r0, r1 := m.AddExecutionLogEntryFunc.nextHook()(v0, v1, v2, v3)
	m.AddExecutionLogEntryFunc.appendCall(WorkerStoreAddExecutionLogEntryFuncCall[T]{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the AddExecutionLogEntry
// method of the parent MockWorkerStore instance is invoked and the hook
// queue is empty.
func (f *WorkerStoreAddExecutionLogEntryFunc[T]) SetDefaultHook(hook func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// AddExecutionLogEntry method of the parent MockWorkerStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *WorkerStoreAddExecutionLogEntryFunc[T]) PushHook(hook func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreAddExecutionLogEntryFunc[T]) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreAddExecutionLogEntryFunc[T]) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (int, error) {
		return r0, r1
	})
}

func (f *WorkerStoreAddExecutionLogEntryFunc[T]) nextHook() func(context.Context, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreAddExecutionLogEntryFunc[T]) appendCall(r0 WorkerStoreAddExecutionLogEntryFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreAddExecutionLogEntryFuncCall
// objects describing the invocations of this function.
func (f *WorkerStoreAddExecutionLogEntryFunc[T]) History() []WorkerStoreAddExecutionLogEntryFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreAddExecutionLogEntryFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreAddExecutionLogEntryFuncCall is an object that describes an
// invocation of method AddExecutionLogEntry on an instance of
// MockWorkerStore.
type WorkerStoreAddExecutionLogEntryFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 executor.ExecutionLogEntry
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 store1.ExecutionLogEntryOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreAddExecutionLogEntryFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreAddExecutionLogEntryFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreDequeueFunc describes the behavior when the Dequeue method of
// the parent MockWorkerStore instance is invoked.
type WorkerStoreDequeueFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, string, []*sqlf.Query) (T, bool, error)
	hooks       []func(context.Context, string, []*sqlf.Query) (T, bool, error)
	history     []WorkerStoreDequeueFuncCall[T]
	mutex       sync.Mutex
}

// Dequeue delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore[T]) Dequeue(v0 context.Context, v1 string, v2 []*sqlf.Query) (T, bool, error) {
	r0, r1, r2 := m.DequeueFunc.nextHook()(v0, v1, v2)
	m.DequeueFunc.appendCall(WorkerStoreDequeueFuncCall[T]{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Dequeue method of
// the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreDequeueFunc[T]) SetDefaultHook(hook func(context.Context, string, []*sqlf.Query) (T, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Dequeue method of the parent MockWorkerStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreDequeueFunc[T]) PushHook(hook func(context.Context, string, []*sqlf.Query) (T, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreDequeueFunc[T]) SetDefaultReturn(r0 T, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, string, []*sqlf.Query) (T, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreDequeueFunc[T]) PushReturn(r0 T, r1 bool, r2 error) {
	f.PushHook(func(context.Context, string, []*sqlf.Query) (T, bool, error) {
		return r0, r1, r2
	})
}

func (f *WorkerStoreDequeueFunc[T]) nextHook() func(context.Context, string, []*sqlf.Query) (T, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreDequeueFunc[T]) appendCall(r0 WorkerStoreDequeueFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreDequeueFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreDequeueFunc[T]) History() []WorkerStoreDequeueFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreDequeueFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreDequeueFuncCall is an object that describes an invocation of
// method Dequeue on an instance of MockWorkerStore.
type WorkerStoreDequeueFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []*sqlf.Query
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 T
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreDequeueFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreDequeueFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// WorkerStoreHandleFunc describes the behavior when the Handle method of
// the parent MockWorkerStore instance is invoked.
type WorkerStoreHandleFunc[T workerutil.Record] struct {
	defaultHook func() basestore.TransactableHandle
	hooks       []func() basestore.TransactableHandle
	history     []WorkerStoreHandleFuncCall[T]
	mutex       sync.Mutex
}

// Handle delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore[T]) Handle() basestore.TransactableHandle {
	r0 := m.HandleFunc.nextHook()()
	m.HandleFunc.appendCall(WorkerStoreHandleFuncCall[T]{r0})
	return r0
}

// SetDefaultHook sets function that is called when the Handle method of the
// parent MockWorkerStore instance is invoked and the hook queue is empty.
func (f *WorkerStoreHandleFunc[T]) SetDefaultHook(hook func() basestore.TransactableHandle) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Handle method of the parent MockWorkerStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreHandleFunc[T]) PushHook(hook func() basestore.TransactableHandle) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreHandleFunc[T]) SetDefaultReturn(r0 basestore.TransactableHandle) {
	f.SetDefaultHook(func() basestore.TransactableHandle {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreHandleFunc[T]) PushReturn(r0 basestore.TransactableHandle) {
	f.PushHook(func() basestore.TransactableHandle {
		return r0
	})
}

func (f *WorkerStoreHandleFunc[T]) nextHook() func() basestore.TransactableHandle {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreHandleFunc[T]) appendCall(r0 WorkerStoreHandleFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreHandleFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreHandleFunc[T]) History() []WorkerStoreHandleFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreHandleFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreHandleFuncCall is an object that describes an invocation of
// method Handle on an instance of MockWorkerStore.
type WorkerStoreHandleFuncCall[T workerutil.Record] struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 basestore.TransactableHandle
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreHandleFuncCall[T]) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreHandleFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0}
}

// WorkerStoreHeartbeatFunc describes the behavior when the Heartbeat method
// of the parent MockWorkerStore instance is invoked.
type WorkerStoreHeartbeatFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, []int, store1.HeartbeatOptions) ([]int, []int, error)
	hooks       []func(context.Context, []int, store1.HeartbeatOptions) ([]int, []int, error)
	history     []WorkerStoreHeartbeatFuncCall[T]
	mutex       sync.Mutex
}

// Heartbeat delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore[T]) Heartbeat(v0 context.Context, v1 []int, v2 store1.HeartbeatOptions) ([]int, []int, error) {
	r0, r1, r2 := m.HeartbeatFunc.nextHook()(v0, v1, v2)
	m.HeartbeatFunc.appendCall(WorkerStoreHeartbeatFuncCall[T]{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Heartbeat method of
// the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreHeartbeatFunc[T]) SetDefaultHook(hook func(context.Context, []int, store1.HeartbeatOptions) ([]int, []int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Heartbeat method of the parent MockWorkerStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreHeartbeatFunc[T]) PushHook(hook func(context.Context, []int, store1.HeartbeatOptions) ([]int, []int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreHeartbeatFunc[T]) SetDefaultReturn(r0 []int, r1 []int, r2 error) {
	f.SetDefaultHook(func(context.Context, []int, store1.HeartbeatOptions) ([]int, []int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreHeartbeatFunc[T]) PushReturn(r0 []int, r1 []int, r2 error) {
	f.PushHook(func(context.Context, []int, store1.HeartbeatOptions) ([]int, []int, error) {
		return r0, r1, r2
	})
}

func (f *WorkerStoreHeartbeatFunc[T]) nextHook() func(context.Context, []int, store1.HeartbeatOptions) ([]int, []int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreHeartbeatFunc[T]) appendCall(r0 WorkerStoreHeartbeatFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreHeartbeatFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreHeartbeatFunc[T]) History() []WorkerStoreHeartbeatFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreHeartbeatFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreHeartbeatFuncCall is an object that describes an invocation of
// method Heartbeat on an instance of MockWorkerStore.
type WorkerStoreHeartbeatFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 store1.HeartbeatOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 []int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreHeartbeatFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreHeartbeatFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// WorkerStoreMarkCompleteFunc describes the behavior when the MarkComplete
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreMarkCompleteFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, int, store1.MarkFinalOptions) (bool, error)
	hooks       []func(context.Context, int, store1.MarkFinalOptions) (bool, error)
	history     []WorkerStoreMarkCompleteFuncCall[T]
	mutex       sync.Mutex
}

// MarkComplete delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore[T]) MarkComplete(v0 context.Context, v1 int, v2 store1.MarkFinalOptions) (bool, error) {
	r0, r1 := m.MarkCompleteFunc.nextHook()(v0, v1, v2)
	m.MarkCompleteFunc.appendCall(WorkerStoreMarkCompleteFuncCall[T]{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MarkComplete method
// of the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreMarkCompleteFunc[T]) SetDefaultHook(hook func(context.Context, int, store1.MarkFinalOptions) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkComplete method of the parent MockWorkerStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *WorkerStoreMarkCompleteFunc[T]) PushHook(hook func(context.Context, int, store1.MarkFinalOptions) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreMarkCompleteFunc[T]) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, store1.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreMarkCompleteFunc[T]) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, store1.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

func (f *WorkerStoreMarkCompleteFunc[T]) nextHook() func(context.Context, int, store1.MarkFinalOptions) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreMarkCompleteFunc[T]) appendCall(r0 WorkerStoreMarkCompleteFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreMarkCompleteFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreMarkCompleteFunc[T]) History() []WorkerStoreMarkCompleteFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreMarkCompleteFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreMarkCompleteFuncCall is an object that describes an invocation
// of method MarkComplete on an instance of MockWorkerStore.
type WorkerStoreMarkCompleteFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 store1.MarkFinalOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreMarkCompleteFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreMarkCompleteFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreMarkErroredFunc describes the behavior when the MarkErrored
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreMarkErroredFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, int, string, store1.MarkFinalOptions) (bool, error)
	hooks       []func(context.Context, int, string, store1.MarkFinalOptions) (bool, error)
	history     []WorkerStoreMarkErroredFuncCall[T]
	mutex       sync.Mutex
}

// MarkErrored delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore[T]) MarkErrored(v0 context.Context, v1 int, v2 string, v3 store1.MarkFinalOptions) (bool, error) {
	r0, r1 := m.MarkErroredFunc.nextHook()(v0, v1, v2, v3)
	m.MarkErroredFunc.appendCall(WorkerStoreMarkErroredFuncCall[T]{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MarkErrored method
// of the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreMarkErroredFunc[T]) SetDefaultHook(hook func(context.Context, int, string, store1.MarkFinalOptions) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkErrored method of the parent MockWorkerStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *WorkerStoreMarkErroredFunc[T]) PushHook(hook func(context.Context, int, string, store1.MarkFinalOptions) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreMarkErroredFunc[T]) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, store1.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreMarkErroredFunc[T]) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string, store1.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

func (f *WorkerStoreMarkErroredFunc[T]) nextHook() func(context.Context, int, string, store1.MarkFinalOptions) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreMarkErroredFunc[T]) appendCall(r0 WorkerStoreMarkErroredFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreMarkErroredFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreMarkErroredFunc[T]) History() []WorkerStoreMarkErroredFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreMarkErroredFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreMarkErroredFuncCall is an object that describes an invocation
// of method MarkErrored on an instance of MockWorkerStore.
type WorkerStoreMarkErroredFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 store1.MarkFinalOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreMarkErroredFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreMarkErroredFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreMarkFailedFunc describes the behavior when the MarkFailed
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreMarkFailedFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, int, string, store1.MarkFinalOptions) (bool, error)
	hooks       []func(context.Context, int, string, store1.MarkFinalOptions) (bool, error)
	history     []WorkerStoreMarkFailedFuncCall[T]
	mutex       sync.Mutex
}

// MarkFailed delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore[T]) MarkFailed(v0 context.Context, v1 int, v2 string, v3 store1.MarkFinalOptions) (bool, error) {
	r0, r1 := m.MarkFailedFunc.nextHook()(v0, v1, v2, v3)
	m.MarkFailedFunc.appendCall(WorkerStoreMarkFailedFuncCall[T]{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MarkFailed method of
// the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreMarkFailedFunc[T]) SetDefaultHook(hook func(context.Context, int, string, store1.MarkFinalOptions) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkFailed method of the parent MockWorkerStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreMarkFailedFunc[T]) PushHook(hook func(context.Context, int, string, store1.MarkFinalOptions) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreMarkFailedFunc[T]) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, store1.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreMarkFailedFunc[T]) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string, store1.MarkFinalOptions) (bool, error) {
		return r0, r1
	})
}

func (f *WorkerStoreMarkFailedFunc[T]) nextHook() func(context.Context, int, string, store1.MarkFinalOptions) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreMarkFailedFunc[T]) appendCall(r0 WorkerStoreMarkFailedFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreMarkFailedFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreMarkFailedFunc[T]) History() []WorkerStoreMarkFailedFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreMarkFailedFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreMarkFailedFuncCall is an object that describes an invocation
// of method MarkFailed on an instance of MockWorkerStore.
type WorkerStoreMarkFailedFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 store1.MarkFinalOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreMarkFailedFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreMarkFailedFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreMaxDurationInQueueFunc describes the behavior when the
// MaxDurationInQueue method of the parent MockWorkerStore instance is
// invoked.
type WorkerStoreMaxDurationInQueueFunc[T workerutil.Record] struct {
	defaultHook func(context.Context) (time.Duration, error)
	hooks       []func(context.Context) (time.Duration, error)
	history     []WorkerStoreMaxDurationInQueueFuncCall[T]
	mutex       sync.Mutex
}

// MaxDurationInQueue delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockWorkerStore[T]) MaxDurationInQueue(v0 context.Context) (time.Duration, error) {
	r0, r1 := m.MaxDurationInQueueFunc.nextHook()(v0)
	m.MaxDurationInQueueFunc.appendCall(WorkerStoreMaxDurationInQueueFuncCall[T]{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MaxDurationInQueue
// method of the parent MockWorkerStore instance is invoked and the hook
// queue is empty.
func (f *WorkerStoreMaxDurationInQueueFunc[T]) SetDefaultHook(hook func(context.Context) (time.Duration, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MaxDurationInQueue method of the parent MockWorkerStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *WorkerStoreMaxDurationInQueueFunc[T]) PushHook(hook func(context.Context) (time.Duration, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreMaxDurationInQueueFunc[T]) SetDefaultReturn(r0 time.Duration, r1 error) {
	f.SetDefaultHook(func(context.Context) (time.Duration, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreMaxDurationInQueueFunc[T]) PushReturn(r0 time.Duration, r1 error) {
	f.PushHook(func(context.Context) (time.Duration, error) {
		return r0, r1
	})
}

func (f *WorkerStoreMaxDurationInQueueFunc[T]) nextHook() func(context.Context) (time.Duration, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreMaxDurationInQueueFunc[T]) appendCall(r0 WorkerStoreMaxDurationInQueueFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreMaxDurationInQueueFuncCall
// objects describing the invocations of this function.
func (f *WorkerStoreMaxDurationInQueueFunc[T]) History() []WorkerStoreMaxDurationInQueueFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreMaxDurationInQueueFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreMaxDurationInQueueFuncCall is an object that describes an
// invocation of method MaxDurationInQueue on an instance of
// MockWorkerStore.
type WorkerStoreMaxDurationInQueueFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 time.Duration
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreMaxDurationInQueueFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreMaxDurationInQueueFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreQueuedCountFunc describes the behavior when the QueuedCount
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreQueuedCountFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, bool) (int, error)
	hooks       []func(context.Context, bool) (int, error)
	history     []WorkerStoreQueuedCountFuncCall[T]
	mutex       sync.Mutex
}

// QueuedCount delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore[T]) QueuedCount(v0 context.Context, v1 bool) (int, error) {
	r0, r1 := m.QueuedCountFunc.nextHook()(v0, v1)
	m.QueuedCountFunc.appendCall(WorkerStoreQueuedCountFuncCall[T]{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the QueuedCount method
// of the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreQueuedCountFunc[T]) SetDefaultHook(hook func(context.Context, bool) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// QueuedCount method of the parent MockWorkerStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *WorkerStoreQueuedCountFunc[T]) PushHook(hook func(context.Context, bool) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreQueuedCountFunc[T]) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, bool) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreQueuedCountFunc[T]) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, bool) (int, error) {
		return r0, r1
	})
}

func (f *WorkerStoreQueuedCountFunc[T]) nextHook() func(context.Context, bool) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreQueuedCountFunc[T]) appendCall(r0 WorkerStoreQueuedCountFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreQueuedCountFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreQueuedCountFunc[T]) History() []WorkerStoreQueuedCountFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreQueuedCountFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreQueuedCountFuncCall is an object that describes an invocation
// of method QueuedCount on an instance of MockWorkerStore.
type WorkerStoreQueuedCountFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 bool
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreQueuedCountFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreQueuedCountFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// WorkerStoreRequeueFunc describes the behavior when the Requeue method of
// the parent MockWorkerStore instance is invoked.
type WorkerStoreRequeueFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, int, time.Time) error
	hooks       []func(context.Context, int, time.Time) error
	history     []WorkerStoreRequeueFuncCall[T]
	mutex       sync.Mutex
}

// Requeue delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore[T]) Requeue(v0 context.Context, v1 int, v2 time.Time) error {
	r0 := m.RequeueFunc.nextHook()(v0, v1, v2)
	m.RequeueFunc.appendCall(WorkerStoreRequeueFuncCall[T]{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Requeue method of
// the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreRequeueFunc[T]) SetDefaultHook(hook func(context.Context, int, time.Time) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Requeue method of the parent MockWorkerStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreRequeueFunc[T]) PushHook(hook func(context.Context, int, time.Time) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreRequeueFunc[T]) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreRequeueFunc[T]) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

func (f *WorkerStoreRequeueFunc[T]) nextHook() func(context.Context, int, time.Time) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreRequeueFunc[T]) appendCall(r0 WorkerStoreRequeueFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreRequeueFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreRequeueFunc[T]) History() []WorkerStoreRequeueFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreRequeueFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreRequeueFuncCall is an object that describes an invocation of
// method Requeue on an instance of MockWorkerStore.
type WorkerStoreRequeueFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreRequeueFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreRequeueFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0}
}

// WorkerStoreResetStalledFunc describes the behavior when the ResetStalled
// method of the parent MockWorkerStore instance is invoked.
type WorkerStoreResetStalledFunc[T workerutil.Record] struct {
	defaultHook func(context.Context) (map[int]time.Duration, map[int]time.Duration, error)
	hooks       []func(context.Context) (map[int]time.Duration, map[int]time.Duration, error)
	history     []WorkerStoreResetStalledFuncCall[T]
	mutex       sync.Mutex
}

// ResetStalled delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockWorkerStore[T]) ResetStalled(v0 context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
	r0, r1, r2 := m.ResetStalledFunc.nextHook()(v0)
	m.ResetStalledFunc.appendCall(WorkerStoreResetStalledFuncCall[T]{v0, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the ResetStalled method
// of the parent MockWorkerStore instance is invoked and the hook queue is
// empty.
func (f *WorkerStoreResetStalledFunc[T]) SetDefaultHook(hook func(context.Context) (map[int]time.Duration, map[int]time.Duration, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ResetStalled method of the parent MockWorkerStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *WorkerStoreResetStalledFunc[T]) PushHook(hook func(context.Context) (map[int]time.Duration, map[int]time.Duration, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreResetStalledFunc[T]) SetDefaultReturn(r0 map[int]time.Duration, r1 map[int]time.Duration, r2 error) {
	f.SetDefaultHook(func(context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreResetStalledFunc[T]) PushReturn(r0 map[int]time.Duration, r1 map[int]time.Duration, r2 error) {
	f.PushHook(func(context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
		return r0, r1, r2
	})
}

func (f *WorkerStoreResetStalledFunc[T]) nextHook() func(context.Context) (map[int]time.Duration, map[int]time.Duration, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreResetStalledFunc[T]) appendCall(r0 WorkerStoreResetStalledFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreResetStalledFuncCall objects
// describing the invocations of this function.
func (f *WorkerStoreResetStalledFunc[T]) History() []WorkerStoreResetStalledFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreResetStalledFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreResetStalledFuncCall is an object that describes an invocation
// of method ResetStalled on an instance of MockWorkerStore.
type WorkerStoreResetStalledFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[int]time.Duration
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 map[int]time.Duration
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreResetStalledFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreResetStalledFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// WorkerStoreUpdateExecutionLogEntryFunc describes the behavior when the
// UpdateExecutionLogEntry method of the parent MockWorkerStore instance is
// invoked.
type WorkerStoreUpdateExecutionLogEntryFunc[T workerutil.Record] struct {
	defaultHook func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) error
	hooks       []func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) error
	history     []WorkerStoreUpdateExecutionLogEntryFuncCall[T]
	mutex       sync.Mutex
}

// UpdateExecutionLogEntry delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockWorkerStore[T]) UpdateExecutionLogEntry(v0 context.Context, v1 int, v2 int, v3 executor.ExecutionLogEntry, v4 store1.ExecutionLogEntryOptions) error {
	r0 := m.UpdateExecutionLogEntryFunc.nextHook()(v0, v1, v2, v3, v4)
	m.UpdateExecutionLogEntryFunc.appendCall(WorkerStoreUpdateExecutionLogEntryFuncCall[T]{v0, v1, v2, v3, v4, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdateExecutionLogEntry method of the parent MockWorkerStore instance is
// invoked and the hook queue is empty.
func (f *WorkerStoreUpdateExecutionLogEntryFunc[T]) SetDefaultHook(hook func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateExecutionLogEntry method of the parent MockWorkerStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *WorkerStoreUpdateExecutionLogEntryFunc[T]) PushHook(hook func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreUpdateExecutionLogEntryFunc[T]) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreUpdateExecutionLogEntryFunc[T]) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) error {
		return r0
	})
}

func (f *WorkerStoreUpdateExecutionLogEntryFunc[T]) nextHook() func(context.Context, int, int, executor.ExecutionLogEntry, store1.ExecutionLogEntryOptions) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreUpdateExecutionLogEntryFunc[T]) appendCall(r0 WorkerStoreUpdateExecutionLogEntryFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreUpdateExecutionLogEntryFuncCall
// objects describing the invocations of this function.
func (f *WorkerStoreUpdateExecutionLogEntryFunc[T]) History() []WorkerStoreUpdateExecutionLogEntryFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreUpdateExecutionLogEntryFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreUpdateExecutionLogEntryFuncCall is an object that describes an
// invocation of method UpdateExecutionLogEntry on an instance of
// MockWorkerStore.
type WorkerStoreUpdateExecutionLogEntryFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 executor.ExecutionLogEntry
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 store1.ExecutionLogEntryOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreUpdateExecutionLogEntryFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreUpdateExecutionLogEntryFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0}
}

// WorkerStoreWithFunc describes the behavior when the With method of the
// parent MockWorkerStore instance is invoked.
type WorkerStoreWithFunc[T workerutil.Record] struct {
	defaultHook func(basestore.ShareableStore) store1.Store[T]
	hooks       []func(basestore.ShareableStore) store1.Store[T]
	history     []WorkerStoreWithFuncCall[T]
	mutex       sync.Mutex
}

// With delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockWorkerStore[T]) With(v0 basestore.ShareableStore) store1.Store[T] {
	r0 := m.WithFunc.nextHook()(v0)
	m.WithFunc.appendCall(WorkerStoreWithFuncCall[T]{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the With method of the
// parent MockWorkerStore instance is invoked and the hook queue is empty.
func (f *WorkerStoreWithFunc[T]) SetDefaultHook(hook func(basestore.ShareableStore) store1.Store[T]) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// With method of the parent MockWorkerStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *WorkerStoreWithFunc[T]) PushHook(hook func(basestore.ShareableStore) store1.Store[T]) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *WorkerStoreWithFunc[T]) SetDefaultReturn(r0 store1.Store[T]) {
	f.SetDefaultHook(func(basestore.ShareableStore) store1.Store[T] {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *WorkerStoreWithFunc[T]) PushReturn(r0 store1.Store[T]) {
	f.PushHook(func(basestore.ShareableStore) store1.Store[T] {
		return r0
	})
}

func (f *WorkerStoreWithFunc[T]) nextHook() func(basestore.ShareableStore) store1.Store[T] {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *WorkerStoreWithFunc[T]) appendCall(r0 WorkerStoreWithFuncCall[T]) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of WorkerStoreWithFuncCall objects describing
// the invocations of this function.
func (f *WorkerStoreWithFunc[T]) History() []WorkerStoreWithFuncCall[T] {
	f.mutex.Lock()
	history := make([]WorkerStoreWithFuncCall[T], len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// WorkerStoreWithFuncCall is an object that describes an invocation of
// method With on an instance of MockWorkerStore.
type WorkerStoreWithFuncCall[T workerutil.Record] struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 basestore.ShareableStore
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store1.Store[T]
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c WorkerStoreWithFuncCall[T]) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c WorkerStoreWithFuncCall[T]) Results() []interface{} {
	return []interface{}{c.Result0}
}
