// Code generated by github.com/efritz/go-mockgen 0.1.0; DO NOT EDIT.

package mocks

import (
	"context"
	lsifstore "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/lsifstore"
	"sync"
)

// MockStore is a mock implementation of the Store interface (from the
// package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/lsifstore)
// used for unit testing.
type MockStore struct {
	// ClearFunc is an instance of a mock function object controlling the
	// behavior of the method Clear.
	ClearFunc *StoreClearFunc
	// DefinitionsFunc is an instance of a mock function object controlling
	// the behavior of the method Definitions.
	DefinitionsFunc *StoreDefinitionsFunc
	// DiagnosticsFunc is an instance of a mock function object controlling
	// the behavior of the method Diagnostics.
	DiagnosticsFunc *StoreDiagnosticsFunc
	// DoneFunc is an instance of a mock function object controlling the
	// behavior of the method Done.
	DoneFunc *StoreDoneFunc
	// ExistsFunc is an instance of a mock function object controlling the
	// behavior of the method Exists.
	ExistsFunc *StoreExistsFunc
	// HoverFunc is an instance of a mock function object controlling the
	// behavior of the method Hover.
	HoverFunc *StoreHoverFunc
	// MonikerResultsFunc is an instance of a mock function object
	// controlling the behavior of the method MonikerResults.
	MonikerResultsFunc *StoreMonikerResultsFunc
	// MonikersByPositionFunc is an instance of a mock function object
	// controlling the behavior of the method MonikersByPosition.
	MonikersByPositionFunc *StoreMonikersByPositionFunc
	// PackageInformationFunc is an instance of a mock function object
	// controlling the behavior of the method PackageInformation.
	PackageInformationFunc *StorePackageInformationFunc
	// PathsWithPrefixFunc is an instance of a mock function object
	// controlling the behavior of the method PathsWithPrefix.
	PathsWithPrefixFunc *StorePathsWithPrefixFunc
	// RangesFunc is an instance of a mock function object controlling the
	// behavior of the method Ranges.
	RangesFunc *StoreRangesFunc
	// ReadDefinitionsFunc is an instance of a mock function object
	// controlling the behavior of the method ReadDefinitions.
	ReadDefinitionsFunc *StoreReadDefinitionsFunc
	// ReadDocumentFunc is an instance of a mock function object controlling
	// the behavior of the method ReadDocument.
	ReadDocumentFunc *StoreReadDocumentFunc
	// ReadMetaFunc is an instance of a mock function object controlling the
	// behavior of the method ReadMeta.
	ReadMetaFunc *StoreReadMetaFunc
	// ReadReferencesFunc is an instance of a mock function object
	// controlling the behavior of the method ReadReferences.
	ReadReferencesFunc *StoreReadReferencesFunc
	// ReadResultChunkFunc is an instance of a mock function object
	// controlling the behavior of the method ReadResultChunk.
	ReadResultChunkFunc *StoreReadResultChunkFunc
	// ReferencesFunc is an instance of a mock function object controlling
	// the behavior of the method References.
	ReferencesFunc *StoreReferencesFunc
	// TransactFunc is an instance of a mock function object controlling the
	// behavior of the method Transact.
	TransactFunc *StoreTransactFunc
	// WriteDefinitionsFunc is an instance of a mock function object
	// controlling the behavior of the method WriteDefinitions.
	WriteDefinitionsFunc *StoreWriteDefinitionsFunc
	// WriteDocumentsFunc is an instance of a mock function object
	// controlling the behavior of the method WriteDocuments.
	WriteDocumentsFunc *StoreWriteDocumentsFunc
	// WriteMetaFunc is an instance of a mock function object controlling
	// the behavior of the method WriteMeta.
	WriteMetaFunc *StoreWriteMetaFunc
	// WriteReferencesFunc is an instance of a mock function object
	// controlling the behavior of the method WriteReferences.
	WriteReferencesFunc *StoreWriteReferencesFunc
	// WriteResultChunksFunc is an instance of a mock function object
	// controlling the behavior of the method WriteResultChunks.
	WriteResultChunksFunc *StoreWriteResultChunksFunc
}

// NewMockStore creates a new mock of the Store interface. All methods
// return zero values for all results, unless overwritten.
func NewMockStore() *MockStore {
	return &MockStore{
		ClearFunc: &StoreClearFunc{
			defaultHook: func(context.Context, ...int) error {
				return nil
			},
		},
		DefinitionsFunc: &StoreDefinitionsFunc{
			defaultHook: func(context.Context, int, string, int, int) ([]lsifstore.Location, error) {
				return nil, nil
			},
		},
		DiagnosticsFunc: &StoreDiagnosticsFunc{
			defaultHook: func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error) {
				return nil, 0, nil
			},
		},
		DoneFunc: &StoreDoneFunc{
			defaultHook: func(error) error {
				return nil
			},
		},
		ExistsFunc: &StoreExistsFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				return false, nil
			},
		},
		HoverFunc: &StoreHoverFunc{
			defaultHook: func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error) {
				return "", lsifstore.Range{}, false, nil
			},
		},
		MonikerResultsFunc: &StoreMonikerResultsFunc{
			defaultHook: func(context.Context, int, string, string, string, int, int) ([]lsifstore.Location, int, error) {
				return nil, 0, nil
			},
		},
		MonikersByPositionFunc: &StoreMonikersByPositionFunc{
			defaultHook: func(context.Context, int, string, int, int) ([][]lsifstore.MonikerData, error) {
				return nil, nil
			},
		},
		PackageInformationFunc: &StorePackageInformationFunc{
			defaultHook: func(context.Context, int, string, string) (lsifstore.PackageInformationData, bool, error) {
				return lsifstore.PackageInformationData{}, false, nil
			},
		},
		PathsWithPrefixFunc: &StorePathsWithPrefixFunc{
			defaultHook: func(context.Context, int, string) ([]string, error) {
				return nil, nil
			},
		},
		RangesFunc: &StoreRangesFunc{
			defaultHook: func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error) {
				return nil, nil
			},
		},
		ReadDefinitionsFunc: &StoreReadDefinitionsFunc{
			defaultHook: func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error) {
				return nil, 0, nil
			},
		},
		ReadDocumentFunc: &StoreReadDocumentFunc{
			defaultHook: func(context.Context, int, string) (lsifstore.DocumentData, bool, error) {
				return lsifstore.DocumentData{}, false, nil
			},
		},
		ReadMetaFunc: &StoreReadMetaFunc{
			defaultHook: func(context.Context, int) (lsifstore.MetaData, error) {
				return lsifstore.MetaData{}, nil
			},
		},
		ReadReferencesFunc: &StoreReadReferencesFunc{
			defaultHook: func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error) {
				return nil, 0, nil
			},
		},
		ReadResultChunkFunc: &StoreReadResultChunkFunc{
			defaultHook: func(context.Context, int, int) (lsifstore.ResultChunkData, bool, error) {
				return lsifstore.ResultChunkData{}, false, nil
			},
		},
		ReferencesFunc: &StoreReferencesFunc{
			defaultHook: func(context.Context, int, string, int, int) ([]lsifstore.Location, error) {
				return nil, nil
			},
		},
		TransactFunc: &StoreTransactFunc{
			defaultHook: func(context.Context) (lsifstore.Store, error) {
				return nil, nil
			},
		},
		WriteDefinitionsFunc: &StoreWriteDefinitionsFunc{
			defaultHook: func(context.Context, int, chan lsifstore.MonikerLocations) error {
				return nil
			},
		},
		WriteDocumentsFunc: &StoreWriteDocumentsFunc{
			defaultHook: func(context.Context, int, chan lsifstore.KeyedDocumentData) error {
				return nil
			},
		},
		WriteMetaFunc: &StoreWriteMetaFunc{
			defaultHook: func(context.Context, int, lsifstore.MetaData) error {
				return nil
			},
		},
		WriteReferencesFunc: &StoreWriteReferencesFunc{
			defaultHook: func(context.Context, int, chan lsifstore.MonikerLocations) error {
				return nil
			},
		},
		WriteResultChunksFunc: &StoreWriteResultChunksFunc{
			defaultHook: func(context.Context, int, chan lsifstore.IndexedResultChunkData) error {
				return nil
			},
		},
	}
}

// NewMockStoreFrom creates a new mock of the MockStore interface. All
// methods delegate to the given implementation, unless overwritten.
func NewMockStoreFrom(i lsifstore.Store) *MockStore {
	return &MockStore{
		ClearFunc: &StoreClearFunc{
			defaultHook: i.Clear,
		},
		DefinitionsFunc: &StoreDefinitionsFunc{
			defaultHook: i.Definitions,
		},
		DiagnosticsFunc: &StoreDiagnosticsFunc{
			defaultHook: i.Diagnostics,
		},
		DoneFunc: &StoreDoneFunc{
			defaultHook: i.Done,
		},
		ExistsFunc: &StoreExistsFunc{
			defaultHook: i.Exists,
		},
		HoverFunc: &StoreHoverFunc{
			defaultHook: i.Hover,
		},
		MonikerResultsFunc: &StoreMonikerResultsFunc{
			defaultHook: i.MonikerResults,
		},
		MonikersByPositionFunc: &StoreMonikersByPositionFunc{
			defaultHook: i.MonikersByPosition,
		},
		PackageInformationFunc: &StorePackageInformationFunc{
			defaultHook: i.PackageInformation,
		},
		PathsWithPrefixFunc: &StorePathsWithPrefixFunc{
			defaultHook: i.PathsWithPrefix,
		},
		RangesFunc: &StoreRangesFunc{
			defaultHook: i.Ranges,
		},
		ReadDefinitionsFunc: &StoreReadDefinitionsFunc{
			defaultHook: i.ReadDefinitions,
		},
		ReadDocumentFunc: &StoreReadDocumentFunc{
			defaultHook: i.ReadDocument,
		},
		ReadMetaFunc: &StoreReadMetaFunc{
			defaultHook: i.ReadMeta,
		},
		ReadReferencesFunc: &StoreReadReferencesFunc{
			defaultHook: i.ReadReferences,
		},
		ReadResultChunkFunc: &StoreReadResultChunkFunc{
			defaultHook: i.ReadResultChunk,
		},
		ReferencesFunc: &StoreReferencesFunc{
			defaultHook: i.References,
		},
		TransactFunc: &StoreTransactFunc{
			defaultHook: i.Transact,
		},
		WriteDefinitionsFunc: &StoreWriteDefinitionsFunc{
			defaultHook: i.WriteDefinitions,
		},
		WriteDocumentsFunc: &StoreWriteDocumentsFunc{
			defaultHook: i.WriteDocuments,
		},
		WriteMetaFunc: &StoreWriteMetaFunc{
			defaultHook: i.WriteMeta,
		},
		WriteReferencesFunc: &StoreWriteReferencesFunc{
			defaultHook: i.WriteReferences,
		},
		WriteResultChunksFunc: &StoreWriteResultChunksFunc{
			defaultHook: i.WriteResultChunks,
		},
	}
}

// StoreClearFunc describes the behavior when the Clear method of the parent
// MockStore instance is invoked.
type StoreClearFunc struct {
	defaultHook func(context.Context, ...int) error
	hooks       []func(context.Context, ...int) error
	history     []StoreClearFuncCall
	mutex       sync.Mutex
}

// Clear delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Clear(v0 context.Context, v1 ...int) error {
	r0 := m.ClearFunc.nextHook()(v0, v1...)
	m.ClearFunc.appendCall(StoreClearFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Clear method of the
// parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreClearFunc) SetDefaultHook(hook func(context.Context, ...int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Clear method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreClearFunc) PushHook(hook func(context.Context, ...int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreClearFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, ...int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreClearFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, ...int) error {
		return r0
	})
}

func (f *StoreClearFunc) nextHook() func(context.Context, ...int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreClearFunc) appendCall(r0 StoreClearFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreClearFuncCall objects describing the
// invocations of this function.
func (f *StoreClearFunc) History() []StoreClearFuncCall {
	f.mutex.Lock()
	history := make([]StoreClearFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreClearFuncCall is an object that describes an invocation of method
// Clear on an instance of MockStore.
type StoreClearFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c StoreClearFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreClearFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreDefinitionsFunc describes the behavior when the Definitions method
// of the parent MockStore instance is invoked.
type StoreDefinitionsFunc struct {
	defaultHook func(context.Context, int, string, int, int) ([]lsifstore.Location, error)
	hooks       []func(context.Context, int, string, int, int) ([]lsifstore.Location, error)
	history     []StoreDefinitionsFuncCall
	mutex       sync.Mutex
}

// Definitions delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) Definitions(v0 context.Context, v1 int, v2 string, v3 int, v4 int) ([]lsifstore.Location, error) {
	r0, r1 := m.DefinitionsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.DefinitionsFunc.appendCall(StoreDefinitionsFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Definitions method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreDefinitionsFunc) SetDefaultHook(hook func(context.Context, int, string, int, int) ([]lsifstore.Location, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Definitions method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreDefinitionsFunc) PushHook(hook func(context.Context, int, string, int, int) ([]lsifstore.Location, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDefinitionsFunc) SetDefaultReturn(r0 []lsifstore.Location, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int) ([]lsifstore.Location, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDefinitionsFunc) PushReturn(r0 []lsifstore.Location, r1 error) {
	f.PushHook(func(context.Context, int, string, int, int) ([]lsifstore.Location, error) {
		return r0, r1
	})
}

func (f *StoreDefinitionsFunc) nextHook() func(context.Context, int, string, int, int) ([]lsifstore.Location, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDefinitionsFunc) appendCall(r0 StoreDefinitionsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDefinitionsFuncCall objects describing
// the invocations of this function.
func (f *StoreDefinitionsFunc) History() []StoreDefinitionsFuncCall {
	f.mutex.Lock()
	history := make([]StoreDefinitionsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDefinitionsFuncCall is an object that describes an invocation of
// method Definitions on an instance of MockStore.
type StoreDefinitionsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.Location
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDefinitionsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDefinitionsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreDiagnosticsFunc describes the behavior when the Diagnostics method
// of the parent MockStore instance is invoked.
type StoreDiagnosticsFunc struct {
	defaultHook func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error)
	hooks       []func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error)
	history     []StoreDiagnosticsFuncCall
	mutex       sync.Mutex
}

// Diagnostics delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) Diagnostics(v0 context.Context, v1 int, v2 string, v3 int, v4 int) ([]lsifstore.Diagnostic, int, error) {
	r0, r1, r2 := m.DiagnosticsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.DiagnosticsFunc.appendCall(StoreDiagnosticsFuncCall{v0, v1, v2, v3, v4, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Diagnostics method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreDiagnosticsFunc) SetDefaultHook(hook func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Diagnostics method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreDiagnosticsFunc) PushHook(hook func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDiagnosticsFunc) SetDefaultReturn(r0 []lsifstore.Diagnostic, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDiagnosticsFunc) PushReturn(r0 []lsifstore.Diagnostic, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error) {
		return r0, r1, r2
	})
}

func (f *StoreDiagnosticsFunc) nextHook() func(context.Context, int, string, int, int) ([]lsifstore.Diagnostic, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDiagnosticsFunc) appendCall(r0 StoreDiagnosticsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDiagnosticsFuncCall objects describing
// the invocations of this function.
func (f *StoreDiagnosticsFunc) History() []StoreDiagnosticsFuncCall {
	f.mutex.Lock()
	history := make([]StoreDiagnosticsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDiagnosticsFuncCall is an object that describes an invocation of
// method Diagnostics on an instance of MockStore.
type StoreDiagnosticsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.Diagnostic
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDiagnosticsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDiagnosticsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreDoneFunc describes the behavior when the Done method of the parent
// MockStore instance is invoked.
type StoreDoneFunc struct {
	defaultHook func(error) error
	hooks       []func(error) error
	history     []StoreDoneFuncCall
	mutex       sync.Mutex
}

// Done delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Done(v0 error) error {
	r0 := m.DoneFunc.nextHook()(v0)
	m.DoneFunc.appendCall(StoreDoneFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Done method of the
// parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreDoneFunc) SetDefaultHook(hook func(error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Done method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreDoneFunc) PushHook(hook func(error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDoneFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(error) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDoneFunc) PushReturn(r0 error) {
	f.PushHook(func(error) error {
		return r0
	})
}

func (f *StoreDoneFunc) nextHook() func(error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDoneFunc) appendCall(r0 StoreDoneFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDoneFuncCall objects describing the
// invocations of this function.
func (f *StoreDoneFunc) History() []StoreDoneFuncCall {
	f.mutex.Lock()
	history := make([]StoreDoneFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDoneFuncCall is an object that describes an invocation of method
// Done on an instance of MockStore.
type StoreDoneFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDoneFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDoneFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreExistsFunc describes the behavior when the Exists method of the
// parent MockStore instance is invoked.
type StoreExistsFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []StoreExistsFuncCall
	mutex       sync.Mutex
}

// Exists delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Exists(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.ExistsFunc.nextHook()(v0, v1, v2)
	m.ExistsFunc.appendCall(StoreExistsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Exists method of the
// parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreExistsFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Exists method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreExistsFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreExistsFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreExistsFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *StoreExistsFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreExistsFunc) appendCall(r0 StoreExistsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreExistsFuncCall objects describing the
// invocations of this function.
func (f *StoreExistsFunc) History() []StoreExistsFuncCall {
	f.mutex.Lock()
	history := make([]StoreExistsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreExistsFuncCall is an object that describes an invocation of method
// Exists on an instance of MockStore.
type StoreExistsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreExistsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreExistsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreHoverFunc describes the behavior when the Hover method of the parent
// MockStore instance is invoked.
type StoreHoverFunc struct {
	defaultHook func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error)
	hooks       []func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error)
	history     []StoreHoverFuncCall
	mutex       sync.Mutex
}

// Hover delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Hover(v0 context.Context, v1 int, v2 string, v3 int, v4 int) (string, lsifstore.Range, bool, error) {
	r0, r1, r2, r3 := m.HoverFunc.nextHook()(v0, v1, v2, v3, v4)
	m.HoverFunc.appendCall(StoreHoverFuncCall{v0, v1, v2, v3, v4, r0, r1, r2, r3})
	return r0, r1, r2, r3
}

// SetDefaultHook sets function that is called when the Hover method of the
// parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreHoverFunc) SetDefaultHook(hook func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Hover method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreHoverFunc) PushHook(hook func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreHoverFunc) SetDefaultReturn(r0 string, r1 lsifstore.Range, r2 bool, r3 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error) {
		return r0, r1, r2, r3
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreHoverFunc) PushReturn(r0 string, r1 lsifstore.Range, r2 bool, r3 error) {
	f.PushHook(func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error) {
		return r0, r1, r2, r3
	})
}

func (f *StoreHoverFunc) nextHook() func(context.Context, int, string, int, int) (string, lsifstore.Range, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreHoverFunc) appendCall(r0 StoreHoverFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreHoverFuncCall objects describing the
// invocations of this function.
func (f *StoreHoverFunc) History() []StoreHoverFuncCall {
	f.mutex.Lock()
	history := make([]StoreHoverFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreHoverFuncCall is an object that describes an invocation of method
// Hover on an instance of MockStore.
type StoreHoverFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 lsifstore.Range
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 bool
	// Result3 is the value of the 4th result returned from this method
	// invocation.
	Result3 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreHoverFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreHoverFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2, c.Result3}
}

// StoreMonikerResultsFunc describes the behavior when the MonikerResults
// method of the parent MockStore instance is invoked.
type StoreMonikerResultsFunc struct {
	defaultHook func(context.Context, int, string, string, string, int, int) ([]lsifstore.Location, int, error)
	hooks       []func(context.Context, int, string, string, string, int, int) ([]lsifstore.Location, int, error)
	history     []StoreMonikerResultsFuncCall
	mutex       sync.Mutex
}

// MonikerResults delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) MonikerResults(v0 context.Context, v1 int, v2 string, v3 string, v4 string, v5 int, v6 int) ([]lsifstore.Location, int, error) {
	r0, r1, r2 := m.MonikerResultsFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6)
	m.MonikerResultsFunc.appendCall(StoreMonikerResultsFuncCall{v0, v1, v2, v3, v4, v5, v6, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the MonikerResults
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreMonikerResultsFunc) SetDefaultHook(hook func(context.Context, int, string, string, string, int, int) ([]lsifstore.Location, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MonikerResults method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreMonikerResultsFunc) PushHook(hook func(context.Context, int, string, string, string, int, int) ([]lsifstore.Location, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreMonikerResultsFunc) SetDefaultReturn(r0 []lsifstore.Location, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, string, int, int) ([]lsifstore.Location, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreMonikerResultsFunc) PushReturn(r0 []lsifstore.Location, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string, string, string, int, int) ([]lsifstore.Location, int, error) {
		return r0, r1, r2
	})
}

func (f *StoreMonikerResultsFunc) nextHook() func(context.Context, int, string, string, string, int, int) ([]lsifstore.Location, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreMonikerResultsFunc) appendCall(r0 StoreMonikerResultsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreMonikerResultsFuncCall objects
// describing the invocations of this function.
func (f *StoreMonikerResultsFunc) History() []StoreMonikerResultsFuncCall {
	f.mutex.Lock()
	history := make([]StoreMonikerResultsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreMonikerResultsFuncCall is an object that describes an invocation of
// method MonikerResults on an instance of MockStore.
type StoreMonikerResultsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 int
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.Location
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreMonikerResultsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreMonikerResultsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreMonikersByPositionFunc describes the behavior when the
// MonikersByPosition method of the parent MockStore instance is invoked.
type StoreMonikersByPositionFunc struct {
	defaultHook func(context.Context, int, string, int, int) ([][]lsifstore.MonikerData, error)
	hooks       []func(context.Context, int, string, int, int) ([][]lsifstore.MonikerData, error)
	history     []StoreMonikersByPositionFuncCall
	mutex       sync.Mutex
}

// MonikersByPosition delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) MonikersByPosition(v0 context.Context, v1 int, v2 string, v3 int, v4 int) ([][]lsifstore.MonikerData, error) {
	r0, r1 := m.MonikersByPositionFunc.nextHook()(v0, v1, v2, v3, v4)
	m.MonikersByPositionFunc.appendCall(StoreMonikersByPositionFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the MonikersByPosition
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreMonikersByPositionFunc) SetDefaultHook(hook func(context.Context, int, string, int, int) ([][]lsifstore.MonikerData, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MonikersByPosition method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreMonikersByPositionFunc) PushHook(hook func(context.Context, int, string, int, int) ([][]lsifstore.MonikerData, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreMonikersByPositionFunc) SetDefaultReturn(r0 [][]lsifstore.MonikerData, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int) ([][]lsifstore.MonikerData, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreMonikersByPositionFunc) PushReturn(r0 [][]lsifstore.MonikerData, r1 error) {
	f.PushHook(func(context.Context, int, string, int, int) ([][]lsifstore.MonikerData, error) {
		return r0, r1
	})
}

func (f *StoreMonikersByPositionFunc) nextHook() func(context.Context, int, string, int, int) ([][]lsifstore.MonikerData, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreMonikersByPositionFunc) appendCall(r0 StoreMonikersByPositionFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreMonikersByPositionFuncCall objects
// describing the invocations of this function.
func (f *StoreMonikersByPositionFunc) History() []StoreMonikersByPositionFuncCall {
	f.mutex.Lock()
	history := make([]StoreMonikersByPositionFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreMonikersByPositionFuncCall is an object that describes an invocation
// of method MonikersByPosition on an instance of MockStore.
type StoreMonikersByPositionFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 [][]lsifstore.MonikerData
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreMonikersByPositionFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreMonikersByPositionFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StorePackageInformationFunc describes the behavior when the
// PackageInformation method of the parent MockStore instance is invoked.
type StorePackageInformationFunc struct {
	defaultHook func(context.Context, int, string, string) (lsifstore.PackageInformationData, bool, error)
	hooks       []func(context.Context, int, string, string) (lsifstore.PackageInformationData, bool, error)
	history     []StorePackageInformationFuncCall
	mutex       sync.Mutex
}

// PackageInformation delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) PackageInformation(v0 context.Context, v1 int, v2 string, v3 string) (lsifstore.PackageInformationData, bool, error) {
	r0, r1, r2 := m.PackageInformationFunc.nextHook()(v0, v1, v2, v3)
	m.PackageInformationFunc.appendCall(StorePackageInformationFuncCall{v0, v1, v2, v3, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the PackageInformation
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StorePackageInformationFunc) SetDefaultHook(hook func(context.Context, int, string, string) (lsifstore.PackageInformationData, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// PackageInformation method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StorePackageInformationFunc) PushHook(hook func(context.Context, int, string, string) (lsifstore.PackageInformationData, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StorePackageInformationFunc) SetDefaultReturn(r0 lsifstore.PackageInformationData, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, string) (lsifstore.PackageInformationData, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StorePackageInformationFunc) PushReturn(r0 lsifstore.PackageInformationData, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int, string, string) (lsifstore.PackageInformationData, bool, error) {
		return r0, r1, r2
	})
}

func (f *StorePackageInformationFunc) nextHook() func(context.Context, int, string, string) (lsifstore.PackageInformationData, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StorePackageInformationFunc) appendCall(r0 StorePackageInformationFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StorePackageInformationFuncCall objects
// describing the invocations of this function.
func (f *StorePackageInformationFunc) History() []StorePackageInformationFuncCall {
	f.mutex.Lock()
	history := make([]StorePackageInformationFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StorePackageInformationFuncCall is an object that describes an invocation
// of method PackageInformation on an instance of MockStore.
type StorePackageInformationFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 lsifstore.PackageInformationData
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StorePackageInformationFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StorePackageInformationFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StorePathsWithPrefixFunc describes the behavior when the PathsWithPrefix
// method of the parent MockStore instance is invoked.
type StorePathsWithPrefixFunc struct {
	defaultHook func(context.Context, int, string) ([]string, error)
	hooks       []func(context.Context, int, string) ([]string, error)
	history     []StorePathsWithPrefixFuncCall
	mutex       sync.Mutex
}

// PathsWithPrefix delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) PathsWithPrefix(v0 context.Context, v1 int, v2 string) ([]string, error) {
	r0, r1 := m.PathsWithPrefixFunc.nextHook()(v0, v1, v2)
	m.PathsWithPrefixFunc.appendCall(StorePathsWithPrefixFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the PathsWithPrefix
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StorePathsWithPrefixFunc) SetDefaultHook(hook func(context.Context, int, string) ([]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// PathsWithPrefix method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StorePathsWithPrefixFunc) PushHook(hook func(context.Context, int, string) ([]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StorePathsWithPrefixFunc) SetDefaultReturn(r0 []string, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) ([]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StorePathsWithPrefixFunc) PushReturn(r0 []string, r1 error) {
	f.PushHook(func(context.Context, int, string) ([]string, error) {
		return r0, r1
	})
}

func (f *StorePathsWithPrefixFunc) nextHook() func(context.Context, int, string) ([]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StorePathsWithPrefixFunc) appendCall(r0 StorePathsWithPrefixFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StorePathsWithPrefixFuncCall objects
// describing the invocations of this function.
func (f *StorePathsWithPrefixFunc) History() []StorePathsWithPrefixFuncCall {
	f.mutex.Lock()
	history := make([]StorePathsWithPrefixFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StorePathsWithPrefixFuncCall is an object that describes an invocation of
// method PathsWithPrefix on an instance of MockStore.
type StorePathsWithPrefixFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StorePathsWithPrefixFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StorePathsWithPrefixFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreRangesFunc describes the behavior when the Ranges method of the
// parent MockStore instance is invoked.
type StoreRangesFunc struct {
	defaultHook func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error)
	hooks       []func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error)
	history     []StoreRangesFuncCall
	mutex       sync.Mutex
}

// Ranges delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Ranges(v0 context.Context, v1 int, v2 string, v3 int, v4 int) ([]lsifstore.CodeIntelligenceRange, error) {
	r0, r1 := m.RangesFunc.nextHook()(v0, v1, v2, v3, v4)
	m.RangesFunc.appendCall(StoreRangesFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Ranges method of the
// parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreRangesFunc) SetDefaultHook(hook func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Ranges method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreRangesFunc) PushHook(hook func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreRangesFunc) SetDefaultReturn(r0 []lsifstore.CodeIntelligenceRange, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreRangesFunc) PushReturn(r0 []lsifstore.CodeIntelligenceRange, r1 error) {
	f.PushHook(func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error) {
		return r0, r1
	})
}

func (f *StoreRangesFunc) nextHook() func(context.Context, int, string, int, int) ([]lsifstore.CodeIntelligenceRange, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreRangesFunc) appendCall(r0 StoreRangesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreRangesFuncCall objects describing the
// invocations of this function.
func (f *StoreRangesFunc) History() []StoreRangesFuncCall {
	f.mutex.Lock()
	history := make([]StoreRangesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreRangesFuncCall is an object that describes an invocation of method
// Ranges on an instance of MockStore.
type StoreRangesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.CodeIntelligenceRange
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreRangesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreRangesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreReadDefinitionsFunc describes the behavior when the ReadDefinitions
// method of the parent MockStore instance is invoked.
type StoreReadDefinitionsFunc struct {
	defaultHook func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error)
	hooks       []func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error)
	history     []StoreReadDefinitionsFuncCall
	mutex       sync.Mutex
}

// ReadDefinitions delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) ReadDefinitions(v0 context.Context, v1 int, v2 string, v3 string, v4 int, v5 int) ([]lsifstore.LocationData, int, error) {
	r0, r1, r2 := m.ReadDefinitionsFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.ReadDefinitionsFunc.appendCall(StoreReadDefinitionsFuncCall{v0, v1, v2, v3, v4, v5, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the ReadDefinitions
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreReadDefinitionsFunc) SetDefaultHook(hook func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReadDefinitions method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreReadDefinitionsFunc) PushHook(hook func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreReadDefinitionsFunc) SetDefaultReturn(r0 []lsifstore.LocationData, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreReadDefinitionsFunc) PushReturn(r0 []lsifstore.LocationData, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error) {
		return r0, r1, r2
	})
}

func (f *StoreReadDefinitionsFunc) nextHook() func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreReadDefinitionsFunc) appendCall(r0 StoreReadDefinitionsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreReadDefinitionsFuncCall objects
// describing the invocations of this function.
func (f *StoreReadDefinitionsFunc) History() []StoreReadDefinitionsFuncCall {
	f.mutex.Lock()
	history := make([]StoreReadDefinitionsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreReadDefinitionsFuncCall is an object that describes an invocation of
// method ReadDefinitions on an instance of MockStore.
type StoreReadDefinitionsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.LocationData
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreReadDefinitionsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreReadDefinitionsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreReadDocumentFunc describes the behavior when the ReadDocument method
// of the parent MockStore instance is invoked.
type StoreReadDocumentFunc struct {
	defaultHook func(context.Context, int, string) (lsifstore.DocumentData, bool, error)
	hooks       []func(context.Context, int, string) (lsifstore.DocumentData, bool, error)
	history     []StoreReadDocumentFuncCall
	mutex       sync.Mutex
}

// ReadDocument delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) ReadDocument(v0 context.Context, v1 int, v2 string) (lsifstore.DocumentData, bool, error) {
	r0, r1, r2 := m.ReadDocumentFunc.nextHook()(v0, v1, v2)
	m.ReadDocumentFunc.appendCall(StoreReadDocumentFuncCall{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the ReadDocument method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreReadDocumentFunc) SetDefaultHook(hook func(context.Context, int, string) (lsifstore.DocumentData, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReadDocument method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreReadDocumentFunc) PushHook(hook func(context.Context, int, string) (lsifstore.DocumentData, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreReadDocumentFunc) SetDefaultReturn(r0 lsifstore.DocumentData, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string) (lsifstore.DocumentData, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreReadDocumentFunc) PushReturn(r0 lsifstore.DocumentData, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int, string) (lsifstore.DocumentData, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreReadDocumentFunc) nextHook() func(context.Context, int, string) (lsifstore.DocumentData, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreReadDocumentFunc) appendCall(r0 StoreReadDocumentFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreReadDocumentFuncCall objects
// describing the invocations of this function.
func (f *StoreReadDocumentFunc) History() []StoreReadDocumentFuncCall {
	f.mutex.Lock()
	history := make([]StoreReadDocumentFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreReadDocumentFuncCall is an object that describes an invocation of
// method ReadDocument on an instance of MockStore.
type StoreReadDocumentFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 lsifstore.DocumentData
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreReadDocumentFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreReadDocumentFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreReadMetaFunc describes the behavior when the ReadMeta method of the
// parent MockStore instance is invoked.
type StoreReadMetaFunc struct {
	defaultHook func(context.Context, int) (lsifstore.MetaData, error)
	hooks       []func(context.Context, int) (lsifstore.MetaData, error)
	history     []StoreReadMetaFuncCall
	mutex       sync.Mutex
}

// ReadMeta delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) ReadMeta(v0 context.Context, v1 int) (lsifstore.MetaData, error) {
	r0, r1 := m.ReadMetaFunc.nextHook()(v0, v1)
	m.ReadMetaFunc.appendCall(StoreReadMetaFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ReadMeta method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreReadMetaFunc) SetDefaultHook(hook func(context.Context, int) (lsifstore.MetaData, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReadMeta method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreReadMetaFunc) PushHook(hook func(context.Context, int) (lsifstore.MetaData, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreReadMetaFunc) SetDefaultReturn(r0 lsifstore.MetaData, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (lsifstore.MetaData, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreReadMetaFunc) PushReturn(r0 lsifstore.MetaData, r1 error) {
	f.PushHook(func(context.Context, int) (lsifstore.MetaData, error) {
		return r0, r1
	})
}

func (f *StoreReadMetaFunc) nextHook() func(context.Context, int) (lsifstore.MetaData, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreReadMetaFunc) appendCall(r0 StoreReadMetaFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreReadMetaFuncCall objects describing
// the invocations of this function.
func (f *StoreReadMetaFunc) History() []StoreReadMetaFuncCall {
	f.mutex.Lock()
	history := make([]StoreReadMetaFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreReadMetaFuncCall is an object that describes an invocation of method
// ReadMeta on an instance of MockStore.
type StoreReadMetaFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 lsifstore.MetaData
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreReadMetaFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreReadMetaFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreReadReferencesFunc describes the behavior when the ReadReferences
// method of the parent MockStore instance is invoked.
type StoreReadReferencesFunc struct {
	defaultHook func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error)
	hooks       []func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error)
	history     []StoreReadReferencesFuncCall
	mutex       sync.Mutex
}

// ReadReferences delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) ReadReferences(v0 context.Context, v1 int, v2 string, v3 string, v4 int, v5 int) ([]lsifstore.LocationData, int, error) {
	r0, r1, r2 := m.ReadReferencesFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.ReadReferencesFunc.appendCall(StoreReadReferencesFuncCall{v0, v1, v2, v3, v4, v5, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the ReadReferences
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreReadReferencesFunc) SetDefaultHook(hook func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReadReferences method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreReadReferencesFunc) PushHook(hook func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreReadReferencesFunc) SetDefaultReturn(r0 []lsifstore.LocationData, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreReadReferencesFunc) PushReturn(r0 []lsifstore.LocationData, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error) {
		return r0, r1, r2
	})
}

func (f *StoreReadReferencesFunc) nextHook() func(context.Context, int, string, string, int, int) ([]lsifstore.LocationData, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreReadReferencesFunc) appendCall(r0 StoreReadReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreReadReferencesFuncCall objects
// describing the invocations of this function.
func (f *StoreReadReferencesFunc) History() []StoreReadReferencesFuncCall {
	f.mutex.Lock()
	history := make([]StoreReadReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreReadReferencesFuncCall is an object that describes an invocation of
// method ReadReferences on an instance of MockStore.
type StoreReadReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.LocationData
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreReadReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreReadReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreReadResultChunkFunc describes the behavior when the ReadResultChunk
// method of the parent MockStore instance is invoked.
type StoreReadResultChunkFunc struct {
	defaultHook func(context.Context, int, int) (lsifstore.ResultChunkData, bool, error)
	hooks       []func(context.Context, int, int) (lsifstore.ResultChunkData, bool, error)
	history     []StoreReadResultChunkFuncCall
	mutex       sync.Mutex
}

// ReadResultChunk delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) ReadResultChunk(v0 context.Context, v1 int, v2 int) (lsifstore.ResultChunkData, bool, error) {
	r0, r1, r2 := m.ReadResultChunkFunc.nextHook()(v0, v1, v2)
	m.ReadResultChunkFunc.appendCall(StoreReadResultChunkFuncCall{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the ReadResultChunk
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreReadResultChunkFunc) SetDefaultHook(hook func(context.Context, int, int) (lsifstore.ResultChunkData, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReadResultChunk method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreReadResultChunkFunc) PushHook(hook func(context.Context, int, int) (lsifstore.ResultChunkData, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreReadResultChunkFunc) SetDefaultReturn(r0 lsifstore.ResultChunkData, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int, int) (lsifstore.ResultChunkData, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreReadResultChunkFunc) PushReturn(r0 lsifstore.ResultChunkData, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int, int) (lsifstore.ResultChunkData, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreReadResultChunkFunc) nextHook() func(context.Context, int, int) (lsifstore.ResultChunkData, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreReadResultChunkFunc) appendCall(r0 StoreReadResultChunkFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreReadResultChunkFuncCall objects
// describing the invocations of this function.
func (f *StoreReadResultChunkFunc) History() []StoreReadResultChunkFuncCall {
	f.mutex.Lock()
	history := make([]StoreReadResultChunkFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreReadResultChunkFuncCall is an object that describes an invocation of
// method ReadResultChunk on an instance of MockStore.
type StoreReadResultChunkFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 lsifstore.ResultChunkData
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreReadResultChunkFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreReadResultChunkFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreReferencesFunc describes the behavior when the References method of
// the parent MockStore instance is invoked.
type StoreReferencesFunc struct {
	defaultHook func(context.Context, int, string, int, int) ([]lsifstore.Location, error)
	hooks       []func(context.Context, int, string, int, int) ([]lsifstore.Location, error)
	history     []StoreReferencesFuncCall
	mutex       sync.Mutex
}

// References delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) References(v0 context.Context, v1 int, v2 string, v3 int, v4 int) ([]lsifstore.Location, error) {
	r0, r1 := m.ReferencesFunc.nextHook()(v0, v1, v2, v3, v4)
	m.ReferencesFunc.appendCall(StoreReferencesFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the References method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreReferencesFunc) SetDefaultHook(hook func(context.Context, int, string, int, int) ([]lsifstore.Location, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// References method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreReferencesFunc) PushHook(hook func(context.Context, int, string, int, int) ([]lsifstore.Location, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreReferencesFunc) SetDefaultReturn(r0 []lsifstore.Location, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, int, int) ([]lsifstore.Location, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreReferencesFunc) PushReturn(r0 []lsifstore.Location, r1 error) {
	f.PushHook(func(context.Context, int, string, int, int) ([]lsifstore.Location, error) {
		return r0, r1
	})
}

func (f *StoreReferencesFunc) nextHook() func(context.Context, int, string, int, int) ([]lsifstore.Location, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreReferencesFunc) appendCall(r0 StoreReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreReferencesFuncCall objects describing
// the invocations of this function.
func (f *StoreReferencesFunc) History() []StoreReferencesFuncCall {
	f.mutex.Lock()
	history := make([]StoreReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreReferencesFuncCall is an object that describes an invocation of
// method References on an instance of MockStore.
type StoreReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 int
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []lsifstore.Location
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreTransactFunc describes the behavior when the Transact method of the
// parent MockStore instance is invoked.
type StoreTransactFunc struct {
	defaultHook func(context.Context) (lsifstore.Store, error)
	hooks       []func(context.Context) (lsifstore.Store, error)
	history     []StoreTransactFuncCall
	mutex       sync.Mutex
}

// Transact delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Transact(v0 context.Context) (lsifstore.Store, error) {
	r0, r1 := m.TransactFunc.nextHook()(v0)
	m.TransactFunc.appendCall(StoreTransactFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Transact method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreTransactFunc) SetDefaultHook(hook func(context.Context) (lsifstore.Store, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Transact method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreTransactFunc) PushHook(hook func(context.Context) (lsifstore.Store, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreTransactFunc) SetDefaultReturn(r0 lsifstore.Store, r1 error) {
	f.SetDefaultHook(func(context.Context) (lsifstore.Store, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreTransactFunc) PushReturn(r0 lsifstore.Store, r1 error) {
	f.PushHook(func(context.Context) (lsifstore.Store, error) {
		return r0, r1
	})
}

func (f *StoreTransactFunc) nextHook() func(context.Context) (lsifstore.Store, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreTransactFunc) appendCall(r0 StoreTransactFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreTransactFuncCall objects describing
// the invocations of this function.
func (f *StoreTransactFunc) History() []StoreTransactFuncCall {
	f.mutex.Lock()
	history := make([]StoreTransactFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreTransactFuncCall is an object that describes an invocation of method
// Transact on an instance of MockStore.
type StoreTransactFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 lsifstore.Store
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreTransactFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreTransactFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreWriteDefinitionsFunc describes the behavior when the
// WriteDefinitions method of the parent MockStore instance is invoked.
type StoreWriteDefinitionsFunc struct {
	defaultHook func(context.Context, int, chan lsifstore.MonikerLocations) error
	hooks       []func(context.Context, int, chan lsifstore.MonikerLocations) error
	history     []StoreWriteDefinitionsFuncCall
	mutex       sync.Mutex
}

// WriteDefinitions delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) WriteDefinitions(v0 context.Context, v1 int, v2 chan lsifstore.MonikerLocations) error {
	r0 := m.WriteDefinitionsFunc.nextHook()(v0, v1, v2)
	m.WriteDefinitionsFunc.appendCall(StoreWriteDefinitionsFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteDefinitions
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreWriteDefinitionsFunc) SetDefaultHook(hook func(context.Context, int, chan lsifstore.MonikerLocations) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteDefinitions method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreWriteDefinitionsFunc) PushHook(hook func(context.Context, int, chan lsifstore.MonikerLocations) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreWriteDefinitionsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan lsifstore.MonikerLocations) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreWriteDefinitionsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan lsifstore.MonikerLocations) error {
		return r0
	})
}

func (f *StoreWriteDefinitionsFunc) nextHook() func(context.Context, int, chan lsifstore.MonikerLocations) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreWriteDefinitionsFunc) appendCall(r0 StoreWriteDefinitionsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreWriteDefinitionsFuncCall objects
// describing the invocations of this function.
func (f *StoreWriteDefinitionsFunc) History() []StoreWriteDefinitionsFuncCall {
	f.mutex.Lock()
	history := make([]StoreWriteDefinitionsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreWriteDefinitionsFuncCall is an object that describes an invocation
// of method WriteDefinitions on an instance of MockStore.
type StoreWriteDefinitionsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan lsifstore.MonikerLocations
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreWriteDefinitionsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreWriteDefinitionsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreWriteDocumentsFunc describes the behavior when the WriteDocuments
// method of the parent MockStore instance is invoked.
type StoreWriteDocumentsFunc struct {
	defaultHook func(context.Context, int, chan lsifstore.KeyedDocumentData) error
	hooks       []func(context.Context, int, chan lsifstore.KeyedDocumentData) error
	history     []StoreWriteDocumentsFuncCall
	mutex       sync.Mutex
}

// WriteDocuments delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) WriteDocuments(v0 context.Context, v1 int, v2 chan lsifstore.KeyedDocumentData) error {
	r0 := m.WriteDocumentsFunc.nextHook()(v0, v1, v2)
	m.WriteDocumentsFunc.appendCall(StoreWriteDocumentsFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteDocuments
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreWriteDocumentsFunc) SetDefaultHook(hook func(context.Context, int, chan lsifstore.KeyedDocumentData) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteDocuments method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreWriteDocumentsFunc) PushHook(hook func(context.Context, int, chan lsifstore.KeyedDocumentData) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreWriteDocumentsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan lsifstore.KeyedDocumentData) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreWriteDocumentsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan lsifstore.KeyedDocumentData) error {
		return r0
	})
}

func (f *StoreWriteDocumentsFunc) nextHook() func(context.Context, int, chan lsifstore.KeyedDocumentData) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreWriteDocumentsFunc) appendCall(r0 StoreWriteDocumentsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreWriteDocumentsFuncCall objects
// describing the invocations of this function.
func (f *StoreWriteDocumentsFunc) History() []StoreWriteDocumentsFuncCall {
	f.mutex.Lock()
	history := make([]StoreWriteDocumentsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreWriteDocumentsFuncCall is an object that describes an invocation of
// method WriteDocuments on an instance of MockStore.
type StoreWriteDocumentsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan lsifstore.KeyedDocumentData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreWriteDocumentsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreWriteDocumentsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreWriteMetaFunc describes the behavior when the WriteMeta method of
// the parent MockStore instance is invoked.
type StoreWriteMetaFunc struct {
	defaultHook func(context.Context, int, lsifstore.MetaData) error
	hooks       []func(context.Context, int, lsifstore.MetaData) error
	history     []StoreWriteMetaFuncCall
	mutex       sync.Mutex
}

// WriteMeta delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) WriteMeta(v0 context.Context, v1 int, v2 lsifstore.MetaData) error {
	r0 := m.WriteMetaFunc.nextHook()(v0, v1, v2)
	m.WriteMetaFunc.appendCall(StoreWriteMetaFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteMeta method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreWriteMetaFunc) SetDefaultHook(hook func(context.Context, int, lsifstore.MetaData) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteMeta method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreWriteMetaFunc) PushHook(hook func(context.Context, int, lsifstore.MetaData) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreWriteMetaFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, lsifstore.MetaData) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreWriteMetaFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, lsifstore.MetaData) error {
		return r0
	})
}

func (f *StoreWriteMetaFunc) nextHook() func(context.Context, int, lsifstore.MetaData) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreWriteMetaFunc) appendCall(r0 StoreWriteMetaFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreWriteMetaFuncCall objects describing
// the invocations of this function.
func (f *StoreWriteMetaFunc) History() []StoreWriteMetaFuncCall {
	f.mutex.Lock()
	history := make([]StoreWriteMetaFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreWriteMetaFuncCall is an object that describes an invocation of
// method WriteMeta on an instance of MockStore.
type StoreWriteMetaFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 lsifstore.MetaData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreWriteMetaFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreWriteMetaFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreWriteReferencesFunc describes the behavior when the WriteReferences
// method of the parent MockStore instance is invoked.
type StoreWriteReferencesFunc struct {
	defaultHook func(context.Context, int, chan lsifstore.MonikerLocations) error
	hooks       []func(context.Context, int, chan lsifstore.MonikerLocations) error
	history     []StoreWriteReferencesFuncCall
	mutex       sync.Mutex
}

// WriteReferences delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) WriteReferences(v0 context.Context, v1 int, v2 chan lsifstore.MonikerLocations) error {
	r0 := m.WriteReferencesFunc.nextHook()(v0, v1, v2)
	m.WriteReferencesFunc.appendCall(StoreWriteReferencesFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteReferences
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreWriteReferencesFunc) SetDefaultHook(hook func(context.Context, int, chan lsifstore.MonikerLocations) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteReferences method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreWriteReferencesFunc) PushHook(hook func(context.Context, int, chan lsifstore.MonikerLocations) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreWriteReferencesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan lsifstore.MonikerLocations) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreWriteReferencesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan lsifstore.MonikerLocations) error {
		return r0
	})
}

func (f *StoreWriteReferencesFunc) nextHook() func(context.Context, int, chan lsifstore.MonikerLocations) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreWriteReferencesFunc) appendCall(r0 StoreWriteReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreWriteReferencesFuncCall objects
// describing the invocations of this function.
func (f *StoreWriteReferencesFunc) History() []StoreWriteReferencesFuncCall {
	f.mutex.Lock()
	history := make([]StoreWriteReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreWriteReferencesFuncCall is an object that describes an invocation of
// method WriteReferences on an instance of MockStore.
type StoreWriteReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan lsifstore.MonikerLocations
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreWriteReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreWriteReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreWriteResultChunksFunc describes the behavior when the
// WriteResultChunks method of the parent MockStore instance is invoked.
type StoreWriteResultChunksFunc struct {
	defaultHook func(context.Context, int, chan lsifstore.IndexedResultChunkData) error
	hooks       []func(context.Context, int, chan lsifstore.IndexedResultChunkData) error
	history     []StoreWriteResultChunksFuncCall
	mutex       sync.Mutex
}

// WriteResultChunks delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) WriteResultChunks(v0 context.Context, v1 int, v2 chan lsifstore.IndexedResultChunkData) error {
	r0 := m.WriteResultChunksFunc.nextHook()(v0, v1, v2)
	m.WriteResultChunksFunc.appendCall(StoreWriteResultChunksFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WriteResultChunks
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreWriteResultChunksFunc) SetDefaultHook(hook func(context.Context, int, chan lsifstore.IndexedResultChunkData) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WriteResultChunks method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreWriteResultChunksFunc) PushHook(hook func(context.Context, int, chan lsifstore.IndexedResultChunkData) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreWriteResultChunksFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, chan lsifstore.IndexedResultChunkData) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreWriteResultChunksFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, chan lsifstore.IndexedResultChunkData) error {
		return r0
	})
}

func (f *StoreWriteResultChunksFunc) nextHook() func(context.Context, int, chan lsifstore.IndexedResultChunkData) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreWriteResultChunksFunc) appendCall(r0 StoreWriteResultChunksFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreWriteResultChunksFuncCall objects
// describing the invocations of this function.
func (f *StoreWriteResultChunksFunc) History() []StoreWriteResultChunksFuncCall {
	f.mutex.Lock()
	history := make([]StoreWriteResultChunksFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreWriteResultChunksFuncCall is an object that describes an invocation
// of method WriteResultChunks on an instance of MockStore.
type StoreWriteResultChunksFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 chan lsifstore.IndexedResultChunkData
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreWriteResultChunksFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreWriteResultChunksFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}
