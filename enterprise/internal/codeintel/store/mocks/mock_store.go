// Code generated by github.com/efritz/go-mockgen 0.1.0; DO NOT EDIT.

package mocks

import (
	"context"
	types "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/bundles/types"
	store "github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/store"
	basestore "github.com/sourcegraph/sourcegraph/internal/db/basestore"
	"sync"
	"time"
)

// MockStore is a mock implementation of the Store interface (from the
// package
// github.com/sourcegraph/sourcegraph/enterprise/internal/codeintel/store)
// used for unit testing.
type MockStore struct {
	// AddUploadPartFunc is an instance of a mock function object
	// controlling the behavior of the method AddUploadPart.
	AddUploadPartFunc *StoreAddUploadPartFunc
	// CalculateVisibleUploadsFunc is an instance of a mock function object
	// controlling the behavior of the method CalculateVisibleUploads.
	CalculateVisibleUploadsFunc *StoreCalculateVisibleUploadsFunc
	// DeleteIndexByIDFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteIndexByID.
	DeleteIndexByIDFunc *StoreDeleteIndexByIDFunc
	// DeleteIndexesWithoutRepositoryFunc is an instance of a mock function
	// object controlling the behavior of the method
	// DeleteIndexesWithoutRepository.
	DeleteIndexesWithoutRepositoryFunc *StoreDeleteIndexesWithoutRepositoryFunc
	// DeleteOldestDumpFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteOldestDump.
	DeleteOldestDumpFunc *StoreDeleteOldestDumpFunc
	// DeleteOverlappingDumpsFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteOverlappingDumps.
	DeleteOverlappingDumpsFunc *StoreDeleteOverlappingDumpsFunc
	// DeleteUploadByIDFunc is an instance of a mock function object
	// controlling the behavior of the method DeleteUploadByID.
	DeleteUploadByIDFunc *StoreDeleteUploadByIDFunc
	// DeleteUploadsStuckUploadingFunc is an instance of a mock function
	// object controlling the behavior of the method
	// DeleteUploadsStuckUploading.
	DeleteUploadsStuckUploadingFunc *StoreDeleteUploadsStuckUploadingFunc
	// DeleteUploadsWithoutRepositoryFunc is an instance of a mock function
	// object controlling the behavior of the method
	// DeleteUploadsWithoutRepository.
	DeleteUploadsWithoutRepositoryFunc *StoreDeleteUploadsWithoutRepositoryFunc
	// DequeueFunc is an instance of a mock function object controlling the
	// behavior of the method Dequeue.
	DequeueFunc *StoreDequeueFunc
	// DequeueIndexFunc is an instance of a mock function object controlling
	// the behavior of the method DequeueIndex.
	DequeueIndexFunc *StoreDequeueIndexFunc
	// DirtyRepositoriesFunc is an instance of a mock function object
	// controlling the behavior of the method DirtyRepositories.
	DirtyRepositoriesFunc *StoreDirtyRepositoriesFunc
	// DoneFunc is an instance of a mock function object controlling the
	// behavior of the method Done.
	DoneFunc *StoreDoneFunc
	// FindClosestDumpsFunc is an instance of a mock function object
	// controlling the behavior of the method FindClosestDumps.
	FindClosestDumpsFunc *StoreFindClosestDumpsFunc
	// FindClosestDumpsFromGraphFragmentFunc is an instance of a mock
	// function object controlling the behavior of the method
	// FindClosestDumpsFromGraphFragment.
	FindClosestDumpsFromGraphFragmentFunc *StoreFindClosestDumpsFromGraphFragmentFunc
	// GetDumpByIDFunc is an instance of a mock function object controlling
	// the behavior of the method GetDumpByID.
	GetDumpByIDFunc *StoreGetDumpByIDFunc
	// GetIndexByIDFunc is an instance of a mock function object controlling
	// the behavior of the method GetIndexByID.
	GetIndexByIDFunc *StoreGetIndexByIDFunc
	// GetIndexConfigurationByRepositoryIDFunc is an instance of a mock
	// function object controlling the behavior of the method
	// GetIndexConfigurationByRepositoryID.
	GetIndexConfigurationByRepositoryIDFunc *StoreGetIndexConfigurationByRepositoryIDFunc
	// GetIndexesFunc is an instance of a mock function object controlling
	// the behavior of the method GetIndexes.
	GetIndexesFunc *StoreGetIndexesFunc
	// GetPackageFunc is an instance of a mock function object controlling
	// the behavior of the method GetPackage.
	GetPackageFunc *StoreGetPackageFunc
	// GetRepositoriesWithIndexConfigurationFunc is an instance of a mock
	// function object controlling the behavior of the method
	// GetRepositoriesWithIndexConfiguration.
	GetRepositoriesWithIndexConfigurationFunc *StoreGetRepositoriesWithIndexConfigurationFunc
	// GetStatesFunc is an instance of a mock function object controlling
	// the behavior of the method GetStates.
	GetStatesFunc *StoreGetStatesFunc
	// GetUploadByIDFunc is an instance of a mock function object
	// controlling the behavior of the method GetUploadByID.
	GetUploadByIDFunc *StoreGetUploadByIDFunc
	// GetUploadsFunc is an instance of a mock function object controlling
	// the behavior of the method GetUploads.
	GetUploadsFunc *StoreGetUploadsFunc
	// HandleFunc is an instance of a mock function object controlling the
	// behavior of the method Handle.
	HandleFunc *StoreHandleFunc
	// HardDeleteUploadByIDFunc is an instance of a mock function object
	// controlling the behavior of the method HardDeleteUploadByID.
	HardDeleteUploadByIDFunc *StoreHardDeleteUploadByIDFunc
	// HasCommitFunc is an instance of a mock function object controlling
	// the behavior of the method HasCommit.
	HasCommitFunc *StoreHasCommitFunc
	// HasRepositoryFunc is an instance of a mock function object
	// controlling the behavior of the method HasRepository.
	HasRepositoryFunc *StoreHasRepositoryFunc
	// IndexQueueSizeFunc is an instance of a mock function object
	// controlling the behavior of the method IndexQueueSize.
	IndexQueueSizeFunc *StoreIndexQueueSizeFunc
	// IndexableRepositoriesFunc is an instance of a mock function object
	// controlling the behavior of the method IndexableRepositories.
	IndexableRepositoriesFunc *StoreIndexableRepositoriesFunc
	// InsertIndexFunc is an instance of a mock function object controlling
	// the behavior of the method InsertIndex.
	InsertIndexFunc *StoreInsertIndexFunc
	// InsertUploadFunc is an instance of a mock function object controlling
	// the behavior of the method InsertUpload.
	InsertUploadFunc *StoreInsertUploadFunc
	// IsQueuedFunc is an instance of a mock function object controlling the
	// behavior of the method IsQueued.
	IsQueuedFunc *StoreIsQueuedFunc
	// LockFunc is an instance of a mock function object controlling the
	// behavior of the method Lock.
	LockFunc *StoreLockFunc
	// MarkCompleteFunc is an instance of a mock function object controlling
	// the behavior of the method MarkComplete.
	MarkCompleteFunc *StoreMarkCompleteFunc
	// MarkErroredFunc is an instance of a mock function object controlling
	// the behavior of the method MarkErrored.
	MarkErroredFunc *StoreMarkErroredFunc
	// MarkIndexCompleteFunc is an instance of a mock function object
	// controlling the behavior of the method MarkIndexComplete.
	MarkIndexCompleteFunc *StoreMarkIndexCompleteFunc
	// MarkIndexErroredFunc is an instance of a mock function object
	// controlling the behavior of the method MarkIndexErrored.
	MarkIndexErroredFunc *StoreMarkIndexErroredFunc
	// MarkQueuedFunc is an instance of a mock function object controlling
	// the behavior of the method MarkQueued.
	MarkQueuedFunc *StoreMarkQueuedFunc
	// MarkRepositoryAsDirtyFunc is an instance of a mock function object
	// controlling the behavior of the method MarkRepositoryAsDirty.
	MarkRepositoryAsDirtyFunc *StoreMarkRepositoryAsDirtyFunc
	// PackageReferencePagerFunc is an instance of a mock function object
	// controlling the behavior of the method PackageReferencePager.
	PackageReferencePagerFunc *StorePackageReferencePagerFunc
	// QueueSizeFunc is an instance of a mock function object controlling
	// the behavior of the method QueueSize.
	QueueSizeFunc *StoreQueueSizeFunc
	// RepoNameFunc is an instance of a mock function object controlling the
	// behavior of the method RepoName.
	RepoNameFunc *StoreRepoNameFunc
	// RepoUsageStatisticsFunc is an instance of a mock function object
	// controlling the behavior of the method RepoUsageStatistics.
	RepoUsageStatisticsFunc *StoreRepoUsageStatisticsFunc
	// RequeueFunc is an instance of a mock function object controlling the
	// behavior of the method Requeue.
	RequeueFunc *StoreRequeueFunc
	// RequeueIndexFunc is an instance of a mock function object controlling
	// the behavior of the method RequeueIndex.
	RequeueIndexFunc *StoreRequeueIndexFunc
	// ResetIndexableRepositoriesFunc is an instance of a mock function
	// object controlling the behavior of the method
	// ResetIndexableRepositories.
	ResetIndexableRepositoriesFunc *StoreResetIndexableRepositoriesFunc
	// ResetStalledFunc is an instance of a mock function object controlling
	// the behavior of the method ResetStalled.
	ResetStalledFunc *StoreResetStalledFunc
	// ResetStalledIndexesFunc is an instance of a mock function object
	// controlling the behavior of the method ResetStalledIndexes.
	ResetStalledIndexesFunc *StoreResetStalledIndexesFunc
	// SameRepoPagerFunc is an instance of a mock function object
	// controlling the behavior of the method SameRepoPager.
	SameRepoPagerFunc *StoreSameRepoPagerFunc
	// SetIndexLogContentsFunc is an instance of a mock function object
	// controlling the behavior of the method SetIndexLogContents.
	SetIndexLogContentsFunc *StoreSetIndexLogContentsFunc
	// SoftDeleteOldDumpsFunc is an instance of a mock function object
	// controlling the behavior of the method SoftDeleteOldDumps.
	SoftDeleteOldDumpsFunc *StoreSoftDeleteOldDumpsFunc
	// TransactFunc is an instance of a mock function object controlling the
	// behavior of the method Transact.
	TransactFunc *StoreTransactFunc
	// UpdateIndexableRepositoryFunc is an instance of a mock function
	// object controlling the behavior of the method
	// UpdateIndexableRepository.
	UpdateIndexableRepositoryFunc *StoreUpdateIndexableRepositoryFunc
	// UpdatePackageReferencesFunc is an instance of a mock function object
	// controlling the behavior of the method UpdatePackageReferences.
	UpdatePackageReferencesFunc *StoreUpdatePackageReferencesFunc
	// UpdatePackagesFunc is an instance of a mock function object
	// controlling the behavior of the method UpdatePackages.
	UpdatePackagesFunc *StoreUpdatePackagesFunc
	// WithFunc is an instance of a mock function object controlling the
	// behavior of the method With.
	WithFunc *StoreWithFunc
}

// NewMockStore creates a new mock of the Store interface. All methods
// return zero values for all results, unless overwritten.
func NewMockStore() *MockStore {
	return &MockStore{
		AddUploadPartFunc: &StoreAddUploadPartFunc{
			defaultHook: func(context.Context, int, int) error {
				return nil
			},
		},
		CalculateVisibleUploadsFunc: &StoreCalculateVisibleUploadsFunc{
			defaultHook: func(context.Context, int, map[string][]string, string, int) error {
				return nil
			},
		},
		DeleteIndexByIDFunc: &StoreDeleteIndexByIDFunc{
			defaultHook: func(context.Context, int) (bool, error) {
				return false, nil
			},
		},
		DeleteIndexesWithoutRepositoryFunc: &StoreDeleteIndexesWithoutRepositoryFunc{
			defaultHook: func(context.Context, time.Time) (map[int]int, error) {
				return nil, nil
			},
		},
		DeleteOldestDumpFunc: &StoreDeleteOldestDumpFunc{
			defaultHook: func(context.Context) (int, bool, error) {
				return 0, false, nil
			},
		},
		DeleteOverlappingDumpsFunc: &StoreDeleteOverlappingDumpsFunc{
			defaultHook: func(context.Context, int, string, string, string) error {
				return nil
			},
		},
		DeleteUploadByIDFunc: &StoreDeleteUploadByIDFunc{
			defaultHook: func(context.Context, int) (bool, error) {
				return false, nil
			},
		},
		DeleteUploadsStuckUploadingFunc: &StoreDeleteUploadsStuckUploadingFunc{
			defaultHook: func(context.Context, time.Time) (int, error) {
				return 0, nil
			},
		},
		DeleteUploadsWithoutRepositoryFunc: &StoreDeleteUploadsWithoutRepositoryFunc{
			defaultHook: func(context.Context, time.Time) (map[int]int, error) {
				return nil, nil
			},
		},
		DequeueFunc: &StoreDequeueFunc{
			defaultHook: func(context.Context, int64) (store.Upload, store.Store, bool, error) {
				return store.Upload{}, nil, false, nil
			},
		},
		DequeueIndexFunc: &StoreDequeueIndexFunc{
			defaultHook: func(context.Context) (store.Index, store.Store, bool, error) {
				return store.Index{}, nil, false, nil
			},
		},
		DirtyRepositoriesFunc: &StoreDirtyRepositoriesFunc{
			defaultHook: func(context.Context) (map[int]int, error) {
				return nil, nil
			},
		},
		DoneFunc: &StoreDoneFunc{
			defaultHook: func(error) error {
				return nil
			},
		},
		FindClosestDumpsFunc: &StoreFindClosestDumpsFunc{
			defaultHook: func(context.Context, int, string, string, bool, string) ([]store.Dump, error) {
				return nil, nil
			},
		},
		FindClosestDumpsFromGraphFragmentFunc: &StoreFindClosestDumpsFromGraphFragmentFunc{
			defaultHook: func(context.Context, int, string, string, bool, string, map[string][]string) ([]store.Dump, error) {
				return nil, nil
			},
		},
		GetDumpByIDFunc: &StoreGetDumpByIDFunc{
			defaultHook: func(context.Context, int) (store.Dump, bool, error) {
				return store.Dump{}, false, nil
			},
		},
		GetIndexByIDFunc: &StoreGetIndexByIDFunc{
			defaultHook: func(context.Context, int) (store.Index, bool, error) {
				return store.Index{}, false, nil
			},
		},
		GetIndexConfigurationByRepositoryIDFunc: &StoreGetIndexConfigurationByRepositoryIDFunc{
			defaultHook: func(context.Context, int) (store.IndexConfiguration, bool, error) {
				return store.IndexConfiguration{}, false, nil
			},
		},
		GetIndexesFunc: &StoreGetIndexesFunc{
			defaultHook: func(context.Context, store.GetIndexesOptions) ([]store.Index, int, error) {
				return nil, 0, nil
			},
		},
		GetPackageFunc: &StoreGetPackageFunc{
			defaultHook: func(context.Context, string, string, string) (store.Dump, bool, error) {
				return store.Dump{}, false, nil
			},
		},
		GetRepositoriesWithIndexConfigurationFunc: &StoreGetRepositoriesWithIndexConfigurationFunc{
			defaultHook: func(context.Context) ([]int, error) {
				return nil, nil
			},
		},
		GetStatesFunc: &StoreGetStatesFunc{
			defaultHook: func(context.Context, []int) (map[int]string, error) {
				return nil, nil
			},
		},
		GetUploadByIDFunc: &StoreGetUploadByIDFunc{
			defaultHook: func(context.Context, int) (store.Upload, bool, error) {
				return store.Upload{}, false, nil
			},
		},
		GetUploadsFunc: &StoreGetUploadsFunc{
			defaultHook: func(context.Context, store.GetUploadsOptions) ([]store.Upload, int, error) {
				return nil, 0, nil
			},
		},
		HandleFunc: &StoreHandleFunc{
			defaultHook: func() *basestore.TransactableHandle {
				return nil
			},
		},
		HardDeleteUploadByIDFunc: &StoreHardDeleteUploadByIDFunc{
			defaultHook: func(context.Context, ...int) error {
				return nil
			},
		},
		HasCommitFunc: &StoreHasCommitFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				return false, nil
			},
		},
		HasRepositoryFunc: &StoreHasRepositoryFunc{
			defaultHook: func(context.Context, int) (bool, error) {
				return false, nil
			},
		},
		IndexQueueSizeFunc: &StoreIndexQueueSizeFunc{
			defaultHook: func(context.Context) (int, error) {
				return 0, nil
			},
		},
		IndexableRepositoriesFunc: &StoreIndexableRepositoriesFunc{
			defaultHook: func(context.Context, store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error) {
				return nil, nil
			},
		},
		InsertIndexFunc: &StoreInsertIndexFunc{
			defaultHook: func(context.Context, store.Index) (int, error) {
				return 0, nil
			},
		},
		InsertUploadFunc: &StoreInsertUploadFunc{
			defaultHook: func(context.Context, store.Upload) (int, error) {
				return 0, nil
			},
		},
		IsQueuedFunc: &StoreIsQueuedFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				return false, nil
			},
		},
		LockFunc: &StoreLockFunc{
			defaultHook: func(context.Context, int, bool) (bool, store.UnlockFunc, error) {
				return false, nil, nil
			},
		},
		MarkCompleteFunc: &StoreMarkCompleteFunc{
			defaultHook: func(context.Context, int) error {
				return nil
			},
		},
		MarkErroredFunc: &StoreMarkErroredFunc{
			defaultHook: func(context.Context, int, string) error {
				return nil
			},
		},
		MarkIndexCompleteFunc: &StoreMarkIndexCompleteFunc{
			defaultHook: func(context.Context, int) error {
				return nil
			},
		},
		MarkIndexErroredFunc: &StoreMarkIndexErroredFunc{
			defaultHook: func(context.Context, int, string) error {
				return nil
			},
		},
		MarkQueuedFunc: &StoreMarkQueuedFunc{
			defaultHook: func(context.Context, int, *int) error {
				return nil
			},
		},
		MarkRepositoryAsDirtyFunc: &StoreMarkRepositoryAsDirtyFunc{
			defaultHook: func(context.Context, int) error {
				return nil
			},
		},
		PackageReferencePagerFunc: &StorePackageReferencePagerFunc{
			defaultHook: func(context.Context, string, string, string, int, int) (int, store.ReferencePager, error) {
				return 0, nil, nil
			},
		},
		QueueSizeFunc: &StoreQueueSizeFunc{
			defaultHook: func(context.Context) (int, error) {
				return 0, nil
			},
		},
		RepoNameFunc: &StoreRepoNameFunc{
			defaultHook: func(context.Context, int) (string, error) {
				return "", nil
			},
		},
		RepoUsageStatisticsFunc: &StoreRepoUsageStatisticsFunc{
			defaultHook: func(context.Context) ([]store.RepoUsageStatistics, error) {
				return nil, nil
			},
		},
		RequeueFunc: &StoreRequeueFunc{
			defaultHook: func(context.Context, int, time.Time) error {
				return nil
			},
		},
		RequeueIndexFunc: &StoreRequeueIndexFunc{
			defaultHook: func(context.Context, int, time.Time) error {
				return nil
			},
		},
		ResetIndexableRepositoriesFunc: &StoreResetIndexableRepositoriesFunc{
			defaultHook: func(context.Context, time.Time) error {
				return nil
			},
		},
		ResetStalledFunc: &StoreResetStalledFunc{
			defaultHook: func(context.Context, time.Time) ([]int, []int, error) {
				return nil, nil, nil
			},
		},
		ResetStalledIndexesFunc: &StoreResetStalledIndexesFunc{
			defaultHook: func(context.Context, time.Time) ([]int, []int, error) {
				return nil, nil, nil
			},
		},
		SameRepoPagerFunc: &StoreSameRepoPagerFunc{
			defaultHook: func(context.Context, int, string, string, string, string, int) (int, store.ReferencePager, error) {
				return 0, nil, nil
			},
		},
		SetIndexLogContentsFunc: &StoreSetIndexLogContentsFunc{
			defaultHook: func(context.Context, int, string) error {
				return nil
			},
		},
		SoftDeleteOldDumpsFunc: &StoreSoftDeleteOldDumpsFunc{
			defaultHook: func(context.Context, time.Duration, time.Time) (int, error) {
				return 0, nil
			},
		},
		TransactFunc: &StoreTransactFunc{
			defaultHook: func(context.Context) (store.Store, error) {
				return nil, nil
			},
		},
		UpdateIndexableRepositoryFunc: &StoreUpdateIndexableRepositoryFunc{
			defaultHook: func(context.Context, store.UpdateableIndexableRepository, time.Time) error {
				return nil
			},
		},
		UpdatePackageReferencesFunc: &StoreUpdatePackageReferencesFunc{
			defaultHook: func(context.Context, []types.PackageReference) error {
				return nil
			},
		},
		UpdatePackagesFunc: &StoreUpdatePackagesFunc{
			defaultHook: func(context.Context, []types.Package) error {
				return nil
			},
		},
		WithFunc: &StoreWithFunc{
			defaultHook: func(basestore.ShareableStore) store.Store {
				return nil
			},
		},
	}
}

// NewMockStoreFrom creates a new mock of the MockStore interface. All
// methods delegate to the given implementation, unless overwritten.
func NewMockStoreFrom(i store.Store) *MockStore {
	return &MockStore{
		AddUploadPartFunc: &StoreAddUploadPartFunc{
			defaultHook: i.AddUploadPart,
		},
		CalculateVisibleUploadsFunc: &StoreCalculateVisibleUploadsFunc{
			defaultHook: i.CalculateVisibleUploads,
		},
		DeleteIndexByIDFunc: &StoreDeleteIndexByIDFunc{
			defaultHook: i.DeleteIndexByID,
		},
		DeleteIndexesWithoutRepositoryFunc: &StoreDeleteIndexesWithoutRepositoryFunc{
			defaultHook: i.DeleteIndexesWithoutRepository,
		},
		DeleteOldestDumpFunc: &StoreDeleteOldestDumpFunc{
			defaultHook: i.DeleteOldestDump,
		},
		DeleteOverlappingDumpsFunc: &StoreDeleteOverlappingDumpsFunc{
			defaultHook: i.DeleteOverlappingDumps,
		},
		DeleteUploadByIDFunc: &StoreDeleteUploadByIDFunc{
			defaultHook: i.DeleteUploadByID,
		},
		DeleteUploadsStuckUploadingFunc: &StoreDeleteUploadsStuckUploadingFunc{
			defaultHook: i.DeleteUploadsStuckUploading,
		},
		DeleteUploadsWithoutRepositoryFunc: &StoreDeleteUploadsWithoutRepositoryFunc{
			defaultHook: i.DeleteUploadsWithoutRepository,
		},
		DequeueFunc: &StoreDequeueFunc{
			defaultHook: i.Dequeue,
		},
		DequeueIndexFunc: &StoreDequeueIndexFunc{
			defaultHook: i.DequeueIndex,
		},
		DirtyRepositoriesFunc: &StoreDirtyRepositoriesFunc{
			defaultHook: i.DirtyRepositories,
		},
		DoneFunc: &StoreDoneFunc{
			defaultHook: i.Done,
		},
		FindClosestDumpsFunc: &StoreFindClosestDumpsFunc{
			defaultHook: i.FindClosestDumps,
		},
		FindClosestDumpsFromGraphFragmentFunc: &StoreFindClosestDumpsFromGraphFragmentFunc{
			defaultHook: i.FindClosestDumpsFromGraphFragment,
		},
		GetDumpByIDFunc: &StoreGetDumpByIDFunc{
			defaultHook: i.GetDumpByID,
		},
		GetIndexByIDFunc: &StoreGetIndexByIDFunc{
			defaultHook: i.GetIndexByID,
		},
		GetIndexConfigurationByRepositoryIDFunc: &StoreGetIndexConfigurationByRepositoryIDFunc{
			defaultHook: i.GetIndexConfigurationByRepositoryID,
		},
		GetIndexesFunc: &StoreGetIndexesFunc{
			defaultHook: i.GetIndexes,
		},
		GetPackageFunc: &StoreGetPackageFunc{
			defaultHook: i.GetPackage,
		},
		GetRepositoriesWithIndexConfigurationFunc: &StoreGetRepositoriesWithIndexConfigurationFunc{
			defaultHook: i.GetRepositoriesWithIndexConfiguration,
		},
		GetStatesFunc: &StoreGetStatesFunc{
			defaultHook: i.GetStates,
		},
		GetUploadByIDFunc: &StoreGetUploadByIDFunc{
			defaultHook: i.GetUploadByID,
		},
		GetUploadsFunc: &StoreGetUploadsFunc{
			defaultHook: i.GetUploads,
		},
		HandleFunc: &StoreHandleFunc{
			defaultHook: i.Handle,
		},
		HardDeleteUploadByIDFunc: &StoreHardDeleteUploadByIDFunc{
			defaultHook: i.HardDeleteUploadByID,
		},
		HasCommitFunc: &StoreHasCommitFunc{
			defaultHook: i.HasCommit,
		},
		HasRepositoryFunc: &StoreHasRepositoryFunc{
			defaultHook: i.HasRepository,
		},
		IndexQueueSizeFunc: &StoreIndexQueueSizeFunc{
			defaultHook: i.IndexQueueSize,
		},
		IndexableRepositoriesFunc: &StoreIndexableRepositoriesFunc{
			defaultHook: i.IndexableRepositories,
		},
		InsertIndexFunc: &StoreInsertIndexFunc{
			defaultHook: i.InsertIndex,
		},
		InsertUploadFunc: &StoreInsertUploadFunc{
			defaultHook: i.InsertUpload,
		},
		IsQueuedFunc: &StoreIsQueuedFunc{
			defaultHook: i.IsQueued,
		},
		LockFunc: &StoreLockFunc{
			defaultHook: i.Lock,
		},
		MarkCompleteFunc: &StoreMarkCompleteFunc{
			defaultHook: i.MarkComplete,
		},
		MarkErroredFunc: &StoreMarkErroredFunc{
			defaultHook: i.MarkErrored,
		},
		MarkIndexCompleteFunc: &StoreMarkIndexCompleteFunc{
			defaultHook: i.MarkIndexComplete,
		},
		MarkIndexErroredFunc: &StoreMarkIndexErroredFunc{
			defaultHook: i.MarkIndexErrored,
		},
		MarkQueuedFunc: &StoreMarkQueuedFunc{
			defaultHook: i.MarkQueued,
		},
		MarkRepositoryAsDirtyFunc: &StoreMarkRepositoryAsDirtyFunc{
			defaultHook: i.MarkRepositoryAsDirty,
		},
		PackageReferencePagerFunc: &StorePackageReferencePagerFunc{
			defaultHook: i.PackageReferencePager,
		},
		QueueSizeFunc: &StoreQueueSizeFunc{
			defaultHook: i.QueueSize,
		},
		RepoNameFunc: &StoreRepoNameFunc{
			defaultHook: i.RepoName,
		},
		RepoUsageStatisticsFunc: &StoreRepoUsageStatisticsFunc{
			defaultHook: i.RepoUsageStatistics,
		},
		RequeueFunc: &StoreRequeueFunc{
			defaultHook: i.Requeue,
		},
		RequeueIndexFunc: &StoreRequeueIndexFunc{
			defaultHook: i.RequeueIndex,
		},
		ResetIndexableRepositoriesFunc: &StoreResetIndexableRepositoriesFunc{
			defaultHook: i.ResetIndexableRepositories,
		},
		ResetStalledFunc: &StoreResetStalledFunc{
			defaultHook: i.ResetStalled,
		},
		ResetStalledIndexesFunc: &StoreResetStalledIndexesFunc{
			defaultHook: i.ResetStalledIndexes,
		},
		SameRepoPagerFunc: &StoreSameRepoPagerFunc{
			defaultHook: i.SameRepoPager,
		},
		SetIndexLogContentsFunc: &StoreSetIndexLogContentsFunc{
			defaultHook: i.SetIndexLogContents,
		},
		SoftDeleteOldDumpsFunc: &StoreSoftDeleteOldDumpsFunc{
			defaultHook: i.SoftDeleteOldDumps,
		},
		TransactFunc: &StoreTransactFunc{
			defaultHook: i.Transact,
		},
		UpdateIndexableRepositoryFunc: &StoreUpdateIndexableRepositoryFunc{
			defaultHook: i.UpdateIndexableRepository,
		},
		UpdatePackageReferencesFunc: &StoreUpdatePackageReferencesFunc{
			defaultHook: i.UpdatePackageReferences,
		},
		UpdatePackagesFunc: &StoreUpdatePackagesFunc{
			defaultHook: i.UpdatePackages,
		},
		WithFunc: &StoreWithFunc{
			defaultHook: i.With,
		},
	}
}

// StoreAddUploadPartFunc describes the behavior when the AddUploadPart
// method of the parent MockStore instance is invoked.
type StoreAddUploadPartFunc struct {
	defaultHook func(context.Context, int, int) error
	hooks       []func(context.Context, int, int) error
	history     []StoreAddUploadPartFuncCall
	mutex       sync.Mutex
}

// AddUploadPart delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) AddUploadPart(v0 context.Context, v1 int, v2 int) error {
	r0 := m.AddUploadPartFunc.nextHook()(v0, v1, v2)
	m.AddUploadPartFunc.appendCall(StoreAddUploadPartFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the AddUploadPart method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreAddUploadPartFunc) SetDefaultHook(hook func(context.Context, int, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// AddUploadPart method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreAddUploadPartFunc) PushHook(hook func(context.Context, int, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreAddUploadPartFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreAddUploadPartFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, int) error {
		return r0
	})
}

func (f *StoreAddUploadPartFunc) nextHook() func(context.Context, int, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreAddUploadPartFunc) appendCall(r0 StoreAddUploadPartFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreAddUploadPartFuncCall objects
// describing the invocations of this function.
func (f *StoreAddUploadPartFunc) History() []StoreAddUploadPartFuncCall {
	f.mutex.Lock()
	history := make([]StoreAddUploadPartFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreAddUploadPartFuncCall is an object that describes an invocation of
// method AddUploadPart on an instance of MockStore.
type StoreAddUploadPartFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreAddUploadPartFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreAddUploadPartFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreCalculateVisibleUploadsFunc describes the behavior when the
// CalculateVisibleUploads method of the parent MockStore instance is
// invoked.
type StoreCalculateVisibleUploadsFunc struct {
	defaultHook func(context.Context, int, map[string][]string, string, int) error
	hooks       []func(context.Context, int, map[string][]string, string, int) error
	history     []StoreCalculateVisibleUploadsFuncCall
	mutex       sync.Mutex
}

// CalculateVisibleUploads delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) CalculateVisibleUploads(v0 context.Context, v1 int, v2 map[string][]string, v3 string, v4 int) error {
	r0 := m.CalculateVisibleUploadsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.CalculateVisibleUploadsFunc.appendCall(StoreCalculateVisibleUploadsFuncCall{v0, v1, v2, v3, v4, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// CalculateVisibleUploads method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreCalculateVisibleUploadsFunc) SetDefaultHook(hook func(context.Context, int, map[string][]string, string, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// CalculateVisibleUploads method of the parent MockStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreCalculateVisibleUploadsFunc) PushHook(hook func(context.Context, int, map[string][]string, string, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreCalculateVisibleUploadsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, map[string][]string, string, int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreCalculateVisibleUploadsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, map[string][]string, string, int) error {
		return r0
	})
}

func (f *StoreCalculateVisibleUploadsFunc) nextHook() func(context.Context, int, map[string][]string, string, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreCalculateVisibleUploadsFunc) appendCall(r0 StoreCalculateVisibleUploadsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreCalculateVisibleUploadsFuncCall
// objects describing the invocations of this function.
func (f *StoreCalculateVisibleUploadsFunc) History() []StoreCalculateVisibleUploadsFuncCall {
	f.mutex.Lock()
	history := make([]StoreCalculateVisibleUploadsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreCalculateVisibleUploadsFuncCall is an object that describes an
// invocation of method CalculateVisibleUploads on an instance of MockStore.
type StoreCalculateVisibleUploadsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 map[string][]string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreCalculateVisibleUploadsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreCalculateVisibleUploadsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreDeleteIndexByIDFunc describes the behavior when the DeleteIndexByID
// method of the parent MockStore instance is invoked.
type StoreDeleteIndexByIDFunc struct {
	defaultHook func(context.Context, int) (bool, error)
	hooks       []func(context.Context, int) (bool, error)
	history     []StoreDeleteIndexByIDFuncCall
	mutex       sync.Mutex
}

// DeleteIndexByID delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) DeleteIndexByID(v0 context.Context, v1 int) (bool, error) {
	r0, r1 := m.DeleteIndexByIDFunc.nextHook()(v0, v1)
	m.DeleteIndexByIDFunc.appendCall(StoreDeleteIndexByIDFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DeleteIndexByID
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreDeleteIndexByIDFunc) SetDefaultHook(hook func(context.Context, int) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteIndexByID method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreDeleteIndexByIDFunc) PushHook(hook func(context.Context, int) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDeleteIndexByIDFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDeleteIndexByIDFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

func (f *StoreDeleteIndexByIDFunc) nextHook() func(context.Context, int) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteIndexByIDFunc) appendCall(r0 StoreDeleteIndexByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteIndexByIDFuncCall objects
// describing the invocations of this function.
func (f *StoreDeleteIndexByIDFunc) History() []StoreDeleteIndexByIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteIndexByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteIndexByIDFuncCall is an object that describes an invocation of
// method DeleteIndexByID on an instance of MockStore.
type StoreDeleteIndexByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteIndexByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteIndexByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreDeleteIndexesWithoutRepositoryFunc describes the behavior when the
// DeleteIndexesWithoutRepository method of the parent MockStore instance is
// invoked.
type StoreDeleteIndexesWithoutRepositoryFunc struct {
	defaultHook func(context.Context, time.Time) (map[int]int, error)
	hooks       []func(context.Context, time.Time) (map[int]int, error)
	history     []StoreDeleteIndexesWithoutRepositoryFuncCall
	mutex       sync.Mutex
}

// DeleteIndexesWithoutRepository delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) DeleteIndexesWithoutRepository(v0 context.Context, v1 time.Time) (map[int]int, error) {
	r0, r1 := m.DeleteIndexesWithoutRepositoryFunc.nextHook()(v0, v1)
	m.DeleteIndexesWithoutRepositoryFunc.appendCall(StoreDeleteIndexesWithoutRepositoryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// DeleteIndexesWithoutRepository method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreDeleteIndexesWithoutRepositoryFunc) SetDefaultHook(hook func(context.Context, time.Time) (map[int]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteIndexesWithoutRepository method of the parent MockStore instance
// inovkes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreDeleteIndexesWithoutRepositoryFunc) PushHook(hook func(context.Context, time.Time) (map[int]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDeleteIndexesWithoutRepositoryFunc) SetDefaultReturn(r0 map[int]int, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Time) (map[int]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDeleteIndexesWithoutRepositoryFunc) PushReturn(r0 map[int]int, r1 error) {
	f.PushHook(func(context.Context, time.Time) (map[int]int, error) {
		return r0, r1
	})
}

func (f *StoreDeleteIndexesWithoutRepositoryFunc) nextHook() func(context.Context, time.Time) (map[int]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteIndexesWithoutRepositoryFunc) appendCall(r0 StoreDeleteIndexesWithoutRepositoryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteIndexesWithoutRepositoryFuncCall
// objects describing the invocations of this function.
func (f *StoreDeleteIndexesWithoutRepositoryFunc) History() []StoreDeleteIndexesWithoutRepositoryFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteIndexesWithoutRepositoryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteIndexesWithoutRepositoryFuncCall is an object that describes
// an invocation of method DeleteIndexesWithoutRepository on an instance of
// MockStore.
type StoreDeleteIndexesWithoutRepositoryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[int]int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteIndexesWithoutRepositoryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteIndexesWithoutRepositoryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreDeleteOldestDumpFunc describes the behavior when the
// DeleteOldestDump method of the parent MockStore instance is invoked.
type StoreDeleteOldestDumpFunc struct {
	defaultHook func(context.Context) (int, bool, error)
	hooks       []func(context.Context) (int, bool, error)
	history     []StoreDeleteOldestDumpFuncCall
	mutex       sync.Mutex
}

// DeleteOldestDump delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) DeleteOldestDump(v0 context.Context) (int, bool, error) {
	r0, r1, r2 := m.DeleteOldestDumpFunc.nextHook()(v0)
	m.DeleteOldestDumpFunc.appendCall(StoreDeleteOldestDumpFuncCall{v0, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the DeleteOldestDump
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreDeleteOldestDumpFunc) SetDefaultHook(hook func(context.Context) (int, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteOldestDump method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreDeleteOldestDumpFunc) PushHook(hook func(context.Context) (int, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDeleteOldestDumpFunc) SetDefaultReturn(r0 int, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context) (int, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDeleteOldestDumpFunc) PushReturn(r0 int, r1 bool, r2 error) {
	f.PushHook(func(context.Context) (int, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreDeleteOldestDumpFunc) nextHook() func(context.Context) (int, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteOldestDumpFunc) appendCall(r0 StoreDeleteOldestDumpFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteOldestDumpFuncCall objects
// describing the invocations of this function.
func (f *StoreDeleteOldestDumpFunc) History() []StoreDeleteOldestDumpFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteOldestDumpFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteOldestDumpFuncCall is an object that describes an invocation
// of method DeleteOldestDump on an instance of MockStore.
type StoreDeleteOldestDumpFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteOldestDumpFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteOldestDumpFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreDeleteOverlappingDumpsFunc describes the behavior when the
// DeleteOverlappingDumps method of the parent MockStore instance is
// invoked.
type StoreDeleteOverlappingDumpsFunc struct {
	defaultHook func(context.Context, int, string, string, string) error
	hooks       []func(context.Context, int, string, string, string) error
	history     []StoreDeleteOverlappingDumpsFuncCall
	mutex       sync.Mutex
}

// DeleteOverlappingDumps delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) DeleteOverlappingDumps(v0 context.Context, v1 int, v2 string, v3 string, v4 string) error {
	r0 := m.DeleteOverlappingDumpsFunc.nextHook()(v0, v1, v2, v3, v4)
	m.DeleteOverlappingDumpsFunc.appendCall(StoreDeleteOverlappingDumpsFuncCall{v0, v1, v2, v3, v4, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// DeleteOverlappingDumps method of the parent MockStore instance is invoked
// and the hook queue is empty.
func (f *StoreDeleteOverlappingDumpsFunc) SetDefaultHook(hook func(context.Context, int, string, string, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteOverlappingDumps method of the parent MockStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreDeleteOverlappingDumpsFunc) PushHook(hook func(context.Context, int, string, string, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDeleteOverlappingDumpsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, string) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDeleteOverlappingDumpsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string, string, string) error {
		return r0
	})
}

func (f *StoreDeleteOverlappingDumpsFunc) nextHook() func(context.Context, int, string, string, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteOverlappingDumpsFunc) appendCall(r0 StoreDeleteOverlappingDumpsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteOverlappingDumpsFuncCall objects
// describing the invocations of this function.
func (f *StoreDeleteOverlappingDumpsFunc) History() []StoreDeleteOverlappingDumpsFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteOverlappingDumpsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteOverlappingDumpsFuncCall is an object that describes an
// invocation of method DeleteOverlappingDumps on an instance of MockStore.
type StoreDeleteOverlappingDumpsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteOverlappingDumpsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteOverlappingDumpsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreDeleteUploadByIDFunc describes the behavior when the
// DeleteUploadByID method of the parent MockStore instance is invoked.
type StoreDeleteUploadByIDFunc struct {
	defaultHook func(context.Context, int) (bool, error)
	hooks       []func(context.Context, int) (bool, error)
	history     []StoreDeleteUploadByIDFuncCall
	mutex       sync.Mutex
}

// DeleteUploadByID delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) DeleteUploadByID(v0 context.Context, v1 int) (bool, error) {
	r0, r1 := m.DeleteUploadByIDFunc.nextHook()(v0, v1)
	m.DeleteUploadByIDFunc.appendCall(StoreDeleteUploadByIDFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DeleteUploadByID
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreDeleteUploadByIDFunc) SetDefaultHook(hook func(context.Context, int) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteUploadByID method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreDeleteUploadByIDFunc) PushHook(hook func(context.Context, int) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDeleteUploadByIDFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDeleteUploadByIDFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

func (f *StoreDeleteUploadByIDFunc) nextHook() func(context.Context, int) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteUploadByIDFunc) appendCall(r0 StoreDeleteUploadByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteUploadByIDFuncCall objects
// describing the invocations of this function.
func (f *StoreDeleteUploadByIDFunc) History() []StoreDeleteUploadByIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteUploadByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteUploadByIDFuncCall is an object that describes an invocation
// of method DeleteUploadByID on an instance of MockStore.
type StoreDeleteUploadByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteUploadByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteUploadByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreDeleteUploadsStuckUploadingFunc describes the behavior when the
// DeleteUploadsStuckUploading method of the parent MockStore instance is
// invoked.
type StoreDeleteUploadsStuckUploadingFunc struct {
	defaultHook func(context.Context, time.Time) (int, error)
	hooks       []func(context.Context, time.Time) (int, error)
	history     []StoreDeleteUploadsStuckUploadingFuncCall
	mutex       sync.Mutex
}

// DeleteUploadsStuckUploading delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) DeleteUploadsStuckUploading(v0 context.Context, v1 time.Time) (int, error) {
	r0, r1 := m.DeleteUploadsStuckUploadingFunc.nextHook()(v0, v1)
	m.DeleteUploadsStuckUploadingFunc.appendCall(StoreDeleteUploadsStuckUploadingFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// DeleteUploadsStuckUploading method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreDeleteUploadsStuckUploadingFunc) SetDefaultHook(hook func(context.Context, time.Time) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteUploadsStuckUploading method of the parent MockStore instance
// inovkes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreDeleteUploadsStuckUploadingFunc) PushHook(hook func(context.Context, time.Time) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDeleteUploadsStuckUploadingFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Time) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDeleteUploadsStuckUploadingFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, time.Time) (int, error) {
		return r0, r1
	})
}

func (f *StoreDeleteUploadsStuckUploadingFunc) nextHook() func(context.Context, time.Time) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteUploadsStuckUploadingFunc) appendCall(r0 StoreDeleteUploadsStuckUploadingFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteUploadsStuckUploadingFuncCall
// objects describing the invocations of this function.
func (f *StoreDeleteUploadsStuckUploadingFunc) History() []StoreDeleteUploadsStuckUploadingFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteUploadsStuckUploadingFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteUploadsStuckUploadingFuncCall is an object that describes an
// invocation of method DeleteUploadsStuckUploading on an instance of
// MockStore.
type StoreDeleteUploadsStuckUploadingFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteUploadsStuckUploadingFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteUploadsStuckUploadingFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreDeleteUploadsWithoutRepositoryFunc describes the behavior when the
// DeleteUploadsWithoutRepository method of the parent MockStore instance is
// invoked.
type StoreDeleteUploadsWithoutRepositoryFunc struct {
	defaultHook func(context.Context, time.Time) (map[int]int, error)
	hooks       []func(context.Context, time.Time) (map[int]int, error)
	history     []StoreDeleteUploadsWithoutRepositoryFuncCall
	mutex       sync.Mutex
}

// DeleteUploadsWithoutRepository delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) DeleteUploadsWithoutRepository(v0 context.Context, v1 time.Time) (map[int]int, error) {
	r0, r1 := m.DeleteUploadsWithoutRepositoryFunc.nextHook()(v0, v1)
	m.DeleteUploadsWithoutRepositoryFunc.appendCall(StoreDeleteUploadsWithoutRepositoryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// DeleteUploadsWithoutRepository method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreDeleteUploadsWithoutRepositoryFunc) SetDefaultHook(hook func(context.Context, time.Time) (map[int]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DeleteUploadsWithoutRepository method of the parent MockStore instance
// inovkes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreDeleteUploadsWithoutRepositoryFunc) PushHook(hook func(context.Context, time.Time) (map[int]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDeleteUploadsWithoutRepositoryFunc) SetDefaultReturn(r0 map[int]int, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Time) (map[int]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDeleteUploadsWithoutRepositoryFunc) PushReturn(r0 map[int]int, r1 error) {
	f.PushHook(func(context.Context, time.Time) (map[int]int, error) {
		return r0, r1
	})
}

func (f *StoreDeleteUploadsWithoutRepositoryFunc) nextHook() func(context.Context, time.Time) (map[int]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDeleteUploadsWithoutRepositoryFunc) appendCall(r0 StoreDeleteUploadsWithoutRepositoryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDeleteUploadsWithoutRepositoryFuncCall
// objects describing the invocations of this function.
func (f *StoreDeleteUploadsWithoutRepositoryFunc) History() []StoreDeleteUploadsWithoutRepositoryFuncCall {
	f.mutex.Lock()
	history := make([]StoreDeleteUploadsWithoutRepositoryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDeleteUploadsWithoutRepositoryFuncCall is an object that describes
// an invocation of method DeleteUploadsWithoutRepository on an instance of
// MockStore.
type StoreDeleteUploadsWithoutRepositoryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[int]int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDeleteUploadsWithoutRepositoryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDeleteUploadsWithoutRepositoryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreDequeueFunc describes the behavior when the Dequeue method of the
// parent MockStore instance is invoked.
type StoreDequeueFunc struct {
	defaultHook func(context.Context, int64) (store.Upload, store.Store, bool, error)
	hooks       []func(context.Context, int64) (store.Upload, store.Store, bool, error)
	history     []StoreDequeueFuncCall
	mutex       sync.Mutex
}

// Dequeue delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Dequeue(v0 context.Context, v1 int64) (store.Upload, store.Store, bool, error) {
	r0, r1, r2, r3 := m.DequeueFunc.nextHook()(v0, v1)
	m.DequeueFunc.appendCall(StoreDequeueFuncCall{v0, v1, r0, r1, r2, r3})
	return r0, r1, r2, r3
}

// SetDefaultHook sets function that is called when the Dequeue method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreDequeueFunc) SetDefaultHook(hook func(context.Context, int64) (store.Upload, store.Store, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Dequeue method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreDequeueFunc) PushHook(hook func(context.Context, int64) (store.Upload, store.Store, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDequeueFunc) SetDefaultReturn(r0 store.Upload, r1 store.Store, r2 bool, r3 error) {
	f.SetDefaultHook(func(context.Context, int64) (store.Upload, store.Store, bool, error) {
		return r0, r1, r2, r3
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDequeueFunc) PushReturn(r0 store.Upload, r1 store.Store, r2 bool, r3 error) {
	f.PushHook(func(context.Context, int64) (store.Upload, store.Store, bool, error) {
		return r0, r1, r2, r3
	})
}

func (f *StoreDequeueFunc) nextHook() func(context.Context, int64) (store.Upload, store.Store, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDequeueFunc) appendCall(r0 StoreDequeueFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDequeueFuncCall objects describing the
// invocations of this function.
func (f *StoreDequeueFunc) History() []StoreDequeueFuncCall {
	f.mutex.Lock()
	history := make([]StoreDequeueFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDequeueFuncCall is an object that describes an invocation of method
// Dequeue on an instance of MockStore.
type StoreDequeueFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int64
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 store.Store
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 bool
	// Result3 is the value of the 4th result returned from this method
	// invocation.
	Result3 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDequeueFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDequeueFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2, c.Result3}
}

// StoreDequeueIndexFunc describes the behavior when the DequeueIndex method
// of the parent MockStore instance is invoked.
type StoreDequeueIndexFunc struct {
	defaultHook func(context.Context) (store.Index, store.Store, bool, error)
	hooks       []func(context.Context) (store.Index, store.Store, bool, error)
	history     []StoreDequeueIndexFuncCall
	mutex       sync.Mutex
}

// DequeueIndex delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) DequeueIndex(v0 context.Context) (store.Index, store.Store, bool, error) {
	r0, r1, r2, r3 := m.DequeueIndexFunc.nextHook()(v0)
	m.DequeueIndexFunc.appendCall(StoreDequeueIndexFuncCall{v0, r0, r1, r2, r3})
	return r0, r1, r2, r3
}

// SetDefaultHook sets function that is called when the DequeueIndex method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreDequeueIndexFunc) SetDefaultHook(hook func(context.Context) (store.Index, store.Store, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DequeueIndex method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreDequeueIndexFunc) PushHook(hook func(context.Context) (store.Index, store.Store, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDequeueIndexFunc) SetDefaultReturn(r0 store.Index, r1 store.Store, r2 bool, r3 error) {
	f.SetDefaultHook(func(context.Context) (store.Index, store.Store, bool, error) {
		return r0, r1, r2, r3
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDequeueIndexFunc) PushReturn(r0 store.Index, r1 store.Store, r2 bool, r3 error) {
	f.PushHook(func(context.Context) (store.Index, store.Store, bool, error) {
		return r0, r1, r2, r3
	})
}

func (f *StoreDequeueIndexFunc) nextHook() func(context.Context) (store.Index, store.Store, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDequeueIndexFunc) appendCall(r0 StoreDequeueIndexFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDequeueIndexFuncCall objects
// describing the invocations of this function.
func (f *StoreDequeueIndexFunc) History() []StoreDequeueIndexFuncCall {
	f.mutex.Lock()
	history := make([]StoreDequeueIndexFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDequeueIndexFuncCall is an object that describes an invocation of
// method DequeueIndex on an instance of MockStore.
type StoreDequeueIndexFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 store.Store
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 bool
	// Result3 is the value of the 4th result returned from this method
	// invocation.
	Result3 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDequeueIndexFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDequeueIndexFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2, c.Result3}
}

// StoreDirtyRepositoriesFunc describes the behavior when the
// DirtyRepositories method of the parent MockStore instance is invoked.
type StoreDirtyRepositoriesFunc struct {
	defaultHook func(context.Context) (map[int]int, error)
	hooks       []func(context.Context) (map[int]int, error)
	history     []StoreDirtyRepositoriesFuncCall
	mutex       sync.Mutex
}

// DirtyRepositories delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) DirtyRepositories(v0 context.Context) (map[int]int, error) {
	r0, r1 := m.DirtyRepositoriesFunc.nextHook()(v0)
	m.DirtyRepositoriesFunc.appendCall(StoreDirtyRepositoriesFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the DirtyRepositories
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreDirtyRepositoriesFunc) SetDefaultHook(hook func(context.Context) (map[int]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// DirtyRepositories method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreDirtyRepositoriesFunc) PushHook(hook func(context.Context) (map[int]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDirtyRepositoriesFunc) SetDefaultReturn(r0 map[int]int, r1 error) {
	f.SetDefaultHook(func(context.Context) (map[int]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDirtyRepositoriesFunc) PushReturn(r0 map[int]int, r1 error) {
	f.PushHook(func(context.Context) (map[int]int, error) {
		return r0, r1
	})
}

func (f *StoreDirtyRepositoriesFunc) nextHook() func(context.Context) (map[int]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDirtyRepositoriesFunc) appendCall(r0 StoreDirtyRepositoriesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDirtyRepositoriesFuncCall objects
// describing the invocations of this function.
func (f *StoreDirtyRepositoriesFunc) History() []StoreDirtyRepositoriesFuncCall {
	f.mutex.Lock()
	history := make([]StoreDirtyRepositoriesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDirtyRepositoriesFuncCall is an object that describes an invocation
// of method DirtyRepositories on an instance of MockStore.
type StoreDirtyRepositoriesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[int]int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDirtyRepositoriesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDirtyRepositoriesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreDoneFunc describes the behavior when the Done method of the parent
// MockStore instance is invoked.
type StoreDoneFunc struct {
	defaultHook func(error) error
	hooks       []func(error) error
	history     []StoreDoneFuncCall
	mutex       sync.Mutex
}

// Done delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Done(v0 error) error {
	r0 := m.DoneFunc.nextHook()(v0)
	m.DoneFunc.appendCall(StoreDoneFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Done method of the
// parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreDoneFunc) SetDefaultHook(hook func(error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Done method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreDoneFunc) PushHook(hook func(error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreDoneFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(error) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreDoneFunc) PushReturn(r0 error) {
	f.PushHook(func(error) error {
		return r0
	})
}

func (f *StoreDoneFunc) nextHook() func(error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreDoneFunc) appendCall(r0 StoreDoneFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreDoneFuncCall objects describing the
// invocations of this function.
func (f *StoreDoneFunc) History() []StoreDoneFuncCall {
	f.mutex.Lock()
	history := make([]StoreDoneFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreDoneFuncCall is an object that describes an invocation of method
// Done on an instance of MockStore.
type StoreDoneFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreDoneFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreDoneFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreFindClosestDumpsFunc describes the behavior when the
// FindClosestDumps method of the parent MockStore instance is invoked.
type StoreFindClosestDumpsFunc struct {
	defaultHook func(context.Context, int, string, string, bool, string) ([]store.Dump, error)
	hooks       []func(context.Context, int, string, string, bool, string) ([]store.Dump, error)
	history     []StoreFindClosestDumpsFuncCall
	mutex       sync.Mutex
}

// FindClosestDumps delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) FindClosestDumps(v0 context.Context, v1 int, v2 string, v3 string, v4 bool, v5 string) ([]store.Dump, error) {
	r0, r1 := m.FindClosestDumpsFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.FindClosestDumpsFunc.appendCall(StoreFindClosestDumpsFuncCall{v0, v1, v2, v3, v4, v5, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the FindClosestDumps
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreFindClosestDumpsFunc) SetDefaultHook(hook func(context.Context, int, string, string, bool, string) ([]store.Dump, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// FindClosestDumps method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreFindClosestDumpsFunc) PushHook(hook func(context.Context, int, string, string, bool, string) ([]store.Dump, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreFindClosestDumpsFunc) SetDefaultReturn(r0 []store.Dump, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, bool, string) ([]store.Dump, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreFindClosestDumpsFunc) PushReturn(r0 []store.Dump, r1 error) {
	f.PushHook(func(context.Context, int, string, string, bool, string) ([]store.Dump, error) {
		return r0, r1
	})
}

func (f *StoreFindClosestDumpsFunc) nextHook() func(context.Context, int, string, string, bool, string) ([]store.Dump, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreFindClosestDumpsFunc) appendCall(r0 StoreFindClosestDumpsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreFindClosestDumpsFuncCall objects
// describing the invocations of this function.
func (f *StoreFindClosestDumpsFunc) History() []StoreFindClosestDumpsFuncCall {
	f.mutex.Lock()
	history := make([]StoreFindClosestDumpsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreFindClosestDumpsFuncCall is an object that describes an invocation
// of method FindClosestDumps on an instance of MockStore.
type StoreFindClosestDumpsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 bool
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []store.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreFindClosestDumpsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreFindClosestDumpsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreFindClosestDumpsFromGraphFragmentFunc describes the behavior when
// the FindClosestDumpsFromGraphFragment method of the parent MockStore
// instance is invoked.
type StoreFindClosestDumpsFromGraphFragmentFunc struct {
	defaultHook func(context.Context, int, string, string, bool, string, map[string][]string) ([]store.Dump, error)
	hooks       []func(context.Context, int, string, string, bool, string, map[string][]string) ([]store.Dump, error)
	history     []StoreFindClosestDumpsFromGraphFragmentFuncCall
	mutex       sync.Mutex
}

// FindClosestDumpsFromGraphFragment delegates to the next hook function in
// the queue and stores the parameter and result values of this invocation.
func (m *MockStore) FindClosestDumpsFromGraphFragment(v0 context.Context, v1 int, v2 string, v3 string, v4 bool, v5 string, v6 map[string][]string) ([]store.Dump, error) {
	r0, r1 := m.FindClosestDumpsFromGraphFragmentFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6)
	m.FindClosestDumpsFromGraphFragmentFunc.appendCall(StoreFindClosestDumpsFromGraphFragmentFuncCall{v0, v1, v2, v3, v4, v5, v6, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// FindClosestDumpsFromGraphFragment method of the parent MockStore instance
// is invoked and the hook queue is empty.
func (f *StoreFindClosestDumpsFromGraphFragmentFunc) SetDefaultHook(hook func(context.Context, int, string, string, bool, string, map[string][]string) ([]store.Dump, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// FindClosestDumpsFromGraphFragment method of the parent MockStore instance
// inovkes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreFindClosestDumpsFromGraphFragmentFunc) PushHook(hook func(context.Context, int, string, string, bool, string, map[string][]string) ([]store.Dump, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreFindClosestDumpsFromGraphFragmentFunc) SetDefaultReturn(r0 []store.Dump, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, bool, string, map[string][]string) ([]store.Dump, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreFindClosestDumpsFromGraphFragmentFunc) PushReturn(r0 []store.Dump, r1 error) {
	f.PushHook(func(context.Context, int, string, string, bool, string, map[string][]string) ([]store.Dump, error) {
		return r0, r1
	})
}

func (f *StoreFindClosestDumpsFromGraphFragmentFunc) nextHook() func(context.Context, int, string, string, bool, string, map[string][]string) ([]store.Dump, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreFindClosestDumpsFromGraphFragmentFunc) appendCall(r0 StoreFindClosestDumpsFromGraphFragmentFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// StoreFindClosestDumpsFromGraphFragmentFuncCall objects describing the
// invocations of this function.
func (f *StoreFindClosestDumpsFromGraphFragmentFunc) History() []StoreFindClosestDumpsFromGraphFragmentFuncCall {
	f.mutex.Lock()
	history := make([]StoreFindClosestDumpsFromGraphFragmentFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreFindClosestDumpsFromGraphFragmentFuncCall is an object that
// describes an invocation of method FindClosestDumpsFromGraphFragment on an
// instance of MockStore.
type StoreFindClosestDumpsFromGraphFragmentFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 bool
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 string
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 map[string][]string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []store.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreFindClosestDumpsFromGraphFragmentFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreFindClosestDumpsFromGraphFragmentFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetDumpByIDFunc describes the behavior when the GetDumpByID method
// of the parent MockStore instance is invoked.
type StoreGetDumpByIDFunc struct {
	defaultHook func(context.Context, int) (store.Dump, bool, error)
	hooks       []func(context.Context, int) (store.Dump, bool, error)
	history     []StoreGetDumpByIDFuncCall
	mutex       sync.Mutex
}

// GetDumpByID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetDumpByID(v0 context.Context, v1 int) (store.Dump, bool, error) {
	r0, r1, r2 := m.GetDumpByIDFunc.nextHook()(v0, v1)
	m.GetDumpByIDFunc.appendCall(StoreGetDumpByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetDumpByID method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetDumpByIDFunc) SetDefaultHook(hook func(context.Context, int) (store.Dump, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetDumpByID method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetDumpByIDFunc) PushHook(hook func(context.Context, int) (store.Dump, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreGetDumpByIDFunc) SetDefaultReturn(r0 store.Dump, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (store.Dump, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreGetDumpByIDFunc) PushReturn(r0 store.Dump, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (store.Dump, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetDumpByIDFunc) nextHook() func(context.Context, int) (store.Dump, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetDumpByIDFunc) appendCall(r0 StoreGetDumpByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetDumpByIDFuncCall objects describing
// the invocations of this function.
func (f *StoreGetDumpByIDFunc) History() []StoreGetDumpByIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetDumpByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetDumpByIDFuncCall is an object that describes an invocation of
// method GetDumpByID on an instance of MockStore.
type StoreGetDumpByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetDumpByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetDumpByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetIndexByIDFunc describes the behavior when the GetIndexByID method
// of the parent MockStore instance is invoked.
type StoreGetIndexByIDFunc struct {
	defaultHook func(context.Context, int) (store.Index, bool, error)
	hooks       []func(context.Context, int) (store.Index, bool, error)
	history     []StoreGetIndexByIDFuncCall
	mutex       sync.Mutex
}

// GetIndexByID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetIndexByID(v0 context.Context, v1 int) (store.Index, bool, error) {
	r0, r1, r2 := m.GetIndexByIDFunc.nextHook()(v0, v1)
	m.GetIndexByIDFunc.appendCall(StoreGetIndexByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetIndexByID method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetIndexByIDFunc) SetDefaultHook(hook func(context.Context, int) (store.Index, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexByID method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetIndexByIDFunc) PushHook(hook func(context.Context, int) (store.Index, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreGetIndexByIDFunc) SetDefaultReturn(r0 store.Index, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (store.Index, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreGetIndexByIDFunc) PushReturn(r0 store.Index, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (store.Index, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetIndexByIDFunc) nextHook() func(context.Context, int) (store.Index, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetIndexByIDFunc) appendCall(r0 StoreGetIndexByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetIndexByIDFuncCall objects
// describing the invocations of this function.
func (f *StoreGetIndexByIDFunc) History() []StoreGetIndexByIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetIndexByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetIndexByIDFuncCall is an object that describes an invocation of
// method GetIndexByID on an instance of MockStore.
type StoreGetIndexByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetIndexByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetIndexByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetIndexConfigurationByRepositoryIDFunc describes the behavior when
// the GetIndexConfigurationByRepositoryID method of the parent MockStore
// instance is invoked.
type StoreGetIndexConfigurationByRepositoryIDFunc struct {
	defaultHook func(context.Context, int) (store.IndexConfiguration, bool, error)
	hooks       []func(context.Context, int) (store.IndexConfiguration, bool, error)
	history     []StoreGetIndexConfigurationByRepositoryIDFuncCall
	mutex       sync.Mutex
}

// GetIndexConfigurationByRepositoryID delegates to the next hook function
// in the queue and stores the parameter and result values of this
// invocation.
func (m *MockStore) GetIndexConfigurationByRepositoryID(v0 context.Context, v1 int) (store.IndexConfiguration, bool, error) {
	r0, r1, r2 := m.GetIndexConfigurationByRepositoryIDFunc.nextHook()(v0, v1)
	m.GetIndexConfigurationByRepositoryIDFunc.appendCall(StoreGetIndexConfigurationByRepositoryIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// GetIndexConfigurationByRepositoryID method of the parent MockStore
// instance is invoked and the hook queue is empty.
func (f *StoreGetIndexConfigurationByRepositoryIDFunc) SetDefaultHook(hook func(context.Context, int) (store.IndexConfiguration, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexConfigurationByRepositoryID method of the parent MockStore
// instance inovkes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *StoreGetIndexConfigurationByRepositoryIDFunc) PushHook(hook func(context.Context, int) (store.IndexConfiguration, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreGetIndexConfigurationByRepositoryIDFunc) SetDefaultReturn(r0 store.IndexConfiguration, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (store.IndexConfiguration, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreGetIndexConfigurationByRepositoryIDFunc) PushReturn(r0 store.IndexConfiguration, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (store.IndexConfiguration, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetIndexConfigurationByRepositoryIDFunc) nextHook() func(context.Context, int) (store.IndexConfiguration, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetIndexConfigurationByRepositoryIDFunc) appendCall(r0 StoreGetIndexConfigurationByRepositoryIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// StoreGetIndexConfigurationByRepositoryIDFuncCall objects describing the
// invocations of this function.
func (f *StoreGetIndexConfigurationByRepositoryIDFunc) History() []StoreGetIndexConfigurationByRepositoryIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetIndexConfigurationByRepositoryIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetIndexConfigurationByRepositoryIDFuncCall is an object that
// describes an invocation of method GetIndexConfigurationByRepositoryID on
// an instance of MockStore.
type StoreGetIndexConfigurationByRepositoryIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.IndexConfiguration
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetIndexConfigurationByRepositoryIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetIndexConfigurationByRepositoryIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetIndexesFunc describes the behavior when the GetIndexes method of
// the parent MockStore instance is invoked.
type StoreGetIndexesFunc struct {
	defaultHook func(context.Context, store.GetIndexesOptions) ([]store.Index, int, error)
	hooks       []func(context.Context, store.GetIndexesOptions) ([]store.Index, int, error)
	history     []StoreGetIndexesFuncCall
	mutex       sync.Mutex
}

// GetIndexes delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetIndexes(v0 context.Context, v1 store.GetIndexesOptions) ([]store.Index, int, error) {
	r0, r1, r2 := m.GetIndexesFunc.nextHook()(v0, v1)
	m.GetIndexesFunc.appendCall(StoreGetIndexesFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetIndexes method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetIndexesFunc) SetDefaultHook(hook func(context.Context, store.GetIndexesOptions) ([]store.Index, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexes method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetIndexesFunc) PushHook(hook func(context.Context, store.GetIndexesOptions) ([]store.Index, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreGetIndexesFunc) SetDefaultReturn(r0 []store.Index, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, store.GetIndexesOptions) ([]store.Index, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreGetIndexesFunc) PushReturn(r0 []store.Index, r1 int, r2 error) {
	f.PushHook(func(context.Context, store.GetIndexesOptions) ([]store.Index, int, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetIndexesFunc) nextHook() func(context.Context, store.GetIndexesOptions) ([]store.Index, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetIndexesFunc) appendCall(r0 StoreGetIndexesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetIndexesFuncCall objects describing
// the invocations of this function.
func (f *StoreGetIndexesFunc) History() []StoreGetIndexesFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetIndexesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetIndexesFuncCall is an object that describes an invocation of
// method GetIndexes on an instance of MockStore.
type StoreGetIndexesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 store.GetIndexesOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []store.Index
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetIndexesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetIndexesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetPackageFunc describes the behavior when the GetPackage method of
// the parent MockStore instance is invoked.
type StoreGetPackageFunc struct {
	defaultHook func(context.Context, string, string, string) (store.Dump, bool, error)
	hooks       []func(context.Context, string, string, string) (store.Dump, bool, error)
	history     []StoreGetPackageFuncCall
	mutex       sync.Mutex
}

// GetPackage delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetPackage(v0 context.Context, v1 string, v2 string, v3 string) (store.Dump, bool, error) {
	r0, r1, r2 := m.GetPackageFunc.nextHook()(v0, v1, v2, v3)
	m.GetPackageFunc.appendCall(StoreGetPackageFuncCall{v0, v1, v2, v3, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetPackage method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetPackageFunc) SetDefaultHook(hook func(context.Context, string, string, string) (store.Dump, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetPackage method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetPackageFunc) PushHook(hook func(context.Context, string, string, string) (store.Dump, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreGetPackageFunc) SetDefaultReturn(r0 store.Dump, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, string, string, string) (store.Dump, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreGetPackageFunc) PushReturn(r0 store.Dump, r1 bool, r2 error) {
	f.PushHook(func(context.Context, string, string, string) (store.Dump, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetPackageFunc) nextHook() func(context.Context, string, string, string) (store.Dump, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetPackageFunc) appendCall(r0 StoreGetPackageFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetPackageFuncCall objects describing
// the invocations of this function.
func (f *StoreGetPackageFunc) History() []StoreGetPackageFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetPackageFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetPackageFuncCall is an object that describes an invocation of
// method GetPackage on an instance of MockStore.
type StoreGetPackageFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Dump
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetPackageFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetPackageFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetRepositoriesWithIndexConfigurationFunc describes the behavior
// when the GetRepositoriesWithIndexConfiguration method of the parent
// MockStore instance is invoked.
type StoreGetRepositoriesWithIndexConfigurationFunc struct {
	defaultHook func(context.Context) ([]int, error)
	hooks       []func(context.Context) ([]int, error)
	history     []StoreGetRepositoriesWithIndexConfigurationFuncCall
	mutex       sync.Mutex
}

// GetRepositoriesWithIndexConfiguration delegates to the next hook function
// in the queue and stores the parameter and result values of this
// invocation.
func (m *MockStore) GetRepositoriesWithIndexConfiguration(v0 context.Context) ([]int, error) {
	r0, r1 := m.GetRepositoriesWithIndexConfigurationFunc.nextHook()(v0)
	m.GetRepositoriesWithIndexConfigurationFunc.appendCall(StoreGetRepositoriesWithIndexConfigurationFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// GetRepositoriesWithIndexConfiguration method of the parent MockStore
// instance is invoked and the hook queue is empty.
func (f *StoreGetRepositoriesWithIndexConfigurationFunc) SetDefaultHook(hook func(context.Context) ([]int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetRepositoriesWithIndexConfiguration method of the parent MockStore
// instance inovkes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *StoreGetRepositoriesWithIndexConfigurationFunc) PushHook(hook func(context.Context) ([]int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreGetRepositoriesWithIndexConfigurationFunc) SetDefaultReturn(r0 []int, r1 error) {
	f.SetDefaultHook(func(context.Context) ([]int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreGetRepositoriesWithIndexConfigurationFunc) PushReturn(r0 []int, r1 error) {
	f.PushHook(func(context.Context) ([]int, error) {
		return r0, r1
	})
}

func (f *StoreGetRepositoriesWithIndexConfigurationFunc) nextHook() func(context.Context) ([]int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetRepositoriesWithIndexConfigurationFunc) appendCall(r0 StoreGetRepositoriesWithIndexConfigurationFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// StoreGetRepositoriesWithIndexConfigurationFuncCall objects describing the
// invocations of this function.
func (f *StoreGetRepositoriesWithIndexConfigurationFunc) History() []StoreGetRepositoriesWithIndexConfigurationFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetRepositoriesWithIndexConfigurationFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetRepositoriesWithIndexConfigurationFuncCall is an object that
// describes an invocation of method GetRepositoriesWithIndexConfiguration
// on an instance of MockStore.
type StoreGetRepositoriesWithIndexConfigurationFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetRepositoriesWithIndexConfigurationFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetRepositoriesWithIndexConfigurationFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetStatesFunc describes the behavior when the GetStates method of
// the parent MockStore instance is invoked.
type StoreGetStatesFunc struct {
	defaultHook func(context.Context, []int) (map[int]string, error)
	hooks       []func(context.Context, []int) (map[int]string, error)
	history     []StoreGetStatesFuncCall
	mutex       sync.Mutex
}

// GetStates delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) GetStates(v0 context.Context, v1 []int) (map[int]string, error) {
	r0, r1 := m.GetStatesFunc.nextHook()(v0, v1)
	m.GetStatesFunc.appendCall(StoreGetStatesFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetStates method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetStatesFunc) SetDefaultHook(hook func(context.Context, []int) (map[int]string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetStates method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreGetStatesFunc) PushHook(hook func(context.Context, []int) (map[int]string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreGetStatesFunc) SetDefaultReturn(r0 map[int]string, r1 error) {
	f.SetDefaultHook(func(context.Context, []int) (map[int]string, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreGetStatesFunc) PushReturn(r0 map[int]string, r1 error) {
	f.PushHook(func(context.Context, []int) (map[int]string, error) {
		return r0, r1
	})
}

func (f *StoreGetStatesFunc) nextHook() func(context.Context, []int) (map[int]string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetStatesFunc) appendCall(r0 StoreGetStatesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetStatesFuncCall objects describing
// the invocations of this function.
func (f *StoreGetStatesFunc) History() []StoreGetStatesFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetStatesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetStatesFuncCall is an object that describes an invocation of
// method GetStates on an instance of MockStore.
type StoreGetStatesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[int]string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetStatesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetStatesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetUploadByIDFunc describes the behavior when the GetUploadByID
// method of the parent MockStore instance is invoked.
type StoreGetUploadByIDFunc struct {
	defaultHook func(context.Context, int) (store.Upload, bool, error)
	hooks       []func(context.Context, int) (store.Upload, bool, error)
	history     []StoreGetUploadByIDFuncCall
	mutex       sync.Mutex
}

// GetUploadByID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetUploadByID(v0 context.Context, v1 int) (store.Upload, bool, error) {
	r0, r1, r2 := m.GetUploadByIDFunc.nextHook()(v0, v1)
	m.GetUploadByIDFunc.appendCall(StoreGetUploadByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetUploadByID method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetUploadByIDFunc) SetDefaultHook(hook func(context.Context, int) (store.Upload, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadByID method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetUploadByIDFunc) PushHook(hook func(context.Context, int) (store.Upload, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreGetUploadByIDFunc) SetDefaultReturn(r0 store.Upload, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (store.Upload, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreGetUploadByIDFunc) PushReturn(r0 store.Upload, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (store.Upload, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetUploadByIDFunc) nextHook() func(context.Context, int) (store.Upload, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetUploadByIDFunc) appendCall(r0 StoreGetUploadByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetUploadByIDFuncCall objects
// describing the invocations of this function.
func (f *StoreGetUploadByIDFunc) History() []StoreGetUploadByIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetUploadByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetUploadByIDFuncCall is an object that describes an invocation of
// method GetUploadByID on an instance of MockStore.
type StoreGetUploadByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetUploadByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetUploadByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetUploadsFunc describes the behavior when the GetUploads method of
// the parent MockStore instance is invoked.
type StoreGetUploadsFunc struct {
	defaultHook func(context.Context, store.GetUploadsOptions) ([]store.Upload, int, error)
	hooks       []func(context.Context, store.GetUploadsOptions) ([]store.Upload, int, error)
	history     []StoreGetUploadsFuncCall
	mutex       sync.Mutex
}

// GetUploads delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) GetUploads(v0 context.Context, v1 store.GetUploadsOptions) ([]store.Upload, int, error) {
	r0, r1, r2 := m.GetUploadsFunc.nextHook()(v0, v1)
	m.GetUploadsFunc.appendCall(StoreGetUploadsFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetUploads method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreGetUploadsFunc) SetDefaultHook(hook func(context.Context, store.GetUploadsOptions) ([]store.Upload, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploads method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetUploadsFunc) PushHook(hook func(context.Context, store.GetUploadsOptions) ([]store.Upload, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreGetUploadsFunc) SetDefaultReturn(r0 []store.Upload, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, store.GetUploadsOptions) ([]store.Upload, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreGetUploadsFunc) PushReturn(r0 []store.Upload, r1 int, r2 error) {
	f.PushHook(func(context.Context, store.GetUploadsOptions) ([]store.Upload, int, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetUploadsFunc) nextHook() func(context.Context, store.GetUploadsOptions) ([]store.Upload, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetUploadsFunc) appendCall(r0 StoreGetUploadsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetUploadsFuncCall objects describing
// the invocations of this function.
func (f *StoreGetUploadsFunc) History() []StoreGetUploadsFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetUploadsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetUploadsFuncCall is an object that describes an invocation of
// method GetUploads on an instance of MockStore.
type StoreGetUploadsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 store.GetUploadsOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []store.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetUploadsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetUploadsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreHandleFunc describes the behavior when the Handle method of the
// parent MockStore instance is invoked.
type StoreHandleFunc struct {
	defaultHook func() *basestore.TransactableHandle
	hooks       []func() *basestore.TransactableHandle
	history     []StoreHandleFuncCall
	mutex       sync.Mutex
}

// Handle delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Handle() *basestore.TransactableHandle {
	r0 := m.HandleFunc.nextHook()()
	m.HandleFunc.appendCall(StoreHandleFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the Handle method of the
// parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreHandleFunc) SetDefaultHook(hook func() *basestore.TransactableHandle) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Handle method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreHandleFunc) PushHook(hook func() *basestore.TransactableHandle) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreHandleFunc) SetDefaultReturn(r0 *basestore.TransactableHandle) {
	f.SetDefaultHook(func() *basestore.TransactableHandle {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreHandleFunc) PushReturn(r0 *basestore.TransactableHandle) {
	f.PushHook(func() *basestore.TransactableHandle {
		return r0
	})
}

func (f *StoreHandleFunc) nextHook() func() *basestore.TransactableHandle {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreHandleFunc) appendCall(r0 StoreHandleFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreHandleFuncCall objects describing the
// invocations of this function.
func (f *StoreHandleFunc) History() []StoreHandleFuncCall {
	f.mutex.Lock()
	history := make([]StoreHandleFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreHandleFuncCall is an object that describes an invocation of method
// Handle on an instance of MockStore.
type StoreHandleFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *basestore.TransactableHandle
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreHandleFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreHandleFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreHardDeleteUploadByIDFunc describes the behavior when the
// HardDeleteUploadByID method of the parent MockStore instance is invoked.
type StoreHardDeleteUploadByIDFunc struct {
	defaultHook func(context.Context, ...int) error
	hooks       []func(context.Context, ...int) error
	history     []StoreHardDeleteUploadByIDFuncCall
	mutex       sync.Mutex
}

// HardDeleteUploadByID delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) HardDeleteUploadByID(v0 context.Context, v1 ...int) error {
	r0 := m.HardDeleteUploadByIDFunc.nextHook()(v0, v1...)
	m.HardDeleteUploadByIDFunc.appendCall(StoreHardDeleteUploadByIDFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the HardDeleteUploadByID
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreHardDeleteUploadByIDFunc) SetDefaultHook(hook func(context.Context, ...int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// HardDeleteUploadByID method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreHardDeleteUploadByIDFunc) PushHook(hook func(context.Context, ...int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreHardDeleteUploadByIDFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, ...int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreHardDeleteUploadByIDFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, ...int) error {
		return r0
	})
}

func (f *StoreHardDeleteUploadByIDFunc) nextHook() func(context.Context, ...int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreHardDeleteUploadByIDFunc) appendCall(r0 StoreHardDeleteUploadByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreHardDeleteUploadByIDFuncCall objects
// describing the invocations of this function.
func (f *StoreHardDeleteUploadByIDFunc) History() []StoreHardDeleteUploadByIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreHardDeleteUploadByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreHardDeleteUploadByIDFuncCall is an object that describes an
// invocation of method HardDeleteUploadByID on an instance of MockStore.
type StoreHardDeleteUploadByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c StoreHardDeleteUploadByIDFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreHardDeleteUploadByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreHasCommitFunc describes the behavior when the HasCommit method of
// the parent MockStore instance is invoked.
type StoreHasCommitFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []StoreHasCommitFuncCall
	mutex       sync.Mutex
}

// HasCommit delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) HasCommit(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.HasCommitFunc.nextHook()(v0, v1, v2)
	m.HasCommitFunc.appendCall(StoreHasCommitFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the HasCommit method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreHasCommitFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// HasCommit method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreHasCommitFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreHasCommitFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreHasCommitFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *StoreHasCommitFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreHasCommitFunc) appendCall(r0 StoreHasCommitFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreHasCommitFuncCall objects describing
// the invocations of this function.
func (f *StoreHasCommitFunc) History() []StoreHasCommitFuncCall {
	f.mutex.Lock()
	history := make([]StoreHasCommitFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreHasCommitFuncCall is an object that describes an invocation of
// method HasCommit on an instance of MockStore.
type StoreHasCommitFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreHasCommitFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreHasCommitFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreHasRepositoryFunc describes the behavior when the HasRepository
// method of the parent MockStore instance is invoked.
type StoreHasRepositoryFunc struct {
	defaultHook func(context.Context, int) (bool, error)
	hooks       []func(context.Context, int) (bool, error)
	history     []StoreHasRepositoryFuncCall
	mutex       sync.Mutex
}

// HasRepository delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) HasRepository(v0 context.Context, v1 int) (bool, error) {
	r0, r1 := m.HasRepositoryFunc.nextHook()(v0, v1)
	m.HasRepositoryFunc.appendCall(StoreHasRepositoryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the HasRepository method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreHasRepositoryFunc) SetDefaultHook(hook func(context.Context, int) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// HasRepository method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreHasRepositoryFunc) PushHook(hook func(context.Context, int) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreHasRepositoryFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreHasRepositoryFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int) (bool, error) {
		return r0, r1
	})
}

func (f *StoreHasRepositoryFunc) nextHook() func(context.Context, int) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreHasRepositoryFunc) appendCall(r0 StoreHasRepositoryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreHasRepositoryFuncCall objects
// describing the invocations of this function.
func (f *StoreHasRepositoryFunc) History() []StoreHasRepositoryFuncCall {
	f.mutex.Lock()
	history := make([]StoreHasRepositoryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreHasRepositoryFuncCall is an object that describes an invocation of
// method HasRepository on an instance of MockStore.
type StoreHasRepositoryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreHasRepositoryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreHasRepositoryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreIndexQueueSizeFunc describes the behavior when the IndexQueueSize
// method of the parent MockStore instance is invoked.
type StoreIndexQueueSizeFunc struct {
	defaultHook func(context.Context) (int, error)
	hooks       []func(context.Context) (int, error)
	history     []StoreIndexQueueSizeFuncCall
	mutex       sync.Mutex
}

// IndexQueueSize delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) IndexQueueSize(v0 context.Context) (int, error) {
	r0, r1 := m.IndexQueueSizeFunc.nextHook()(v0)
	m.IndexQueueSizeFunc.appendCall(StoreIndexQueueSizeFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the IndexQueueSize
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreIndexQueueSizeFunc) SetDefaultHook(hook func(context.Context) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// IndexQueueSize method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreIndexQueueSizeFunc) PushHook(hook func(context.Context) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreIndexQueueSizeFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreIndexQueueSizeFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

func (f *StoreIndexQueueSizeFunc) nextHook() func(context.Context) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreIndexQueueSizeFunc) appendCall(r0 StoreIndexQueueSizeFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreIndexQueueSizeFuncCall objects
// describing the invocations of this function.
func (f *StoreIndexQueueSizeFunc) History() []StoreIndexQueueSizeFuncCall {
	f.mutex.Lock()
	history := make([]StoreIndexQueueSizeFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreIndexQueueSizeFuncCall is an object that describes an invocation of
// method IndexQueueSize on an instance of MockStore.
type StoreIndexQueueSizeFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreIndexQueueSizeFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreIndexQueueSizeFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreIndexableRepositoriesFunc describes the behavior when the
// IndexableRepositories method of the parent MockStore instance is invoked.
type StoreIndexableRepositoriesFunc struct {
	defaultHook func(context.Context, store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error)
	hooks       []func(context.Context, store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error)
	history     []StoreIndexableRepositoriesFuncCall
	mutex       sync.Mutex
}

// IndexableRepositories delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) IndexableRepositories(v0 context.Context, v1 store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error) {
	r0, r1 := m.IndexableRepositoriesFunc.nextHook()(v0, v1)
	m.IndexableRepositoriesFunc.appendCall(StoreIndexableRepositoriesFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// IndexableRepositories method of the parent MockStore instance is invoked
// and the hook queue is empty.
func (f *StoreIndexableRepositoriesFunc) SetDefaultHook(hook func(context.Context, store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// IndexableRepositories method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreIndexableRepositoriesFunc) PushHook(hook func(context.Context, store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreIndexableRepositoriesFunc) SetDefaultReturn(r0 []store.IndexableRepository, r1 error) {
	f.SetDefaultHook(func(context.Context, store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreIndexableRepositoriesFunc) PushReturn(r0 []store.IndexableRepository, r1 error) {
	f.PushHook(func(context.Context, store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error) {
		return r0, r1
	})
}

func (f *StoreIndexableRepositoriesFunc) nextHook() func(context.Context, store.IndexableRepositoryQueryOptions) ([]store.IndexableRepository, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreIndexableRepositoriesFunc) appendCall(r0 StoreIndexableRepositoriesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreIndexableRepositoriesFuncCall objects
// describing the invocations of this function.
func (f *StoreIndexableRepositoriesFunc) History() []StoreIndexableRepositoriesFuncCall {
	f.mutex.Lock()
	history := make([]StoreIndexableRepositoriesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreIndexableRepositoriesFuncCall is an object that describes an
// invocation of method IndexableRepositories on an instance of MockStore.
type StoreIndexableRepositoriesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 store.IndexableRepositoryQueryOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []store.IndexableRepository
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreIndexableRepositoriesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreIndexableRepositoriesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreInsertIndexFunc describes the behavior when the InsertIndex method
// of the parent MockStore instance is invoked.
type StoreInsertIndexFunc struct {
	defaultHook func(context.Context, store.Index) (int, error)
	hooks       []func(context.Context, store.Index) (int, error)
	history     []StoreInsertIndexFuncCall
	mutex       sync.Mutex
}

// InsertIndex delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) InsertIndex(v0 context.Context, v1 store.Index) (int, error) {
	r0, r1 := m.InsertIndexFunc.nextHook()(v0, v1)
	m.InsertIndexFunc.appendCall(StoreInsertIndexFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the InsertIndex method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreInsertIndexFunc) SetDefaultHook(hook func(context.Context, store.Index) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertIndex method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreInsertIndexFunc) PushHook(hook func(context.Context, store.Index) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreInsertIndexFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, store.Index) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreInsertIndexFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, store.Index) (int, error) {
		return r0, r1
	})
}

func (f *StoreInsertIndexFunc) nextHook() func(context.Context, store.Index) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreInsertIndexFunc) appendCall(r0 StoreInsertIndexFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreInsertIndexFuncCall objects describing
// the invocations of this function.
func (f *StoreInsertIndexFunc) History() []StoreInsertIndexFuncCall {
	f.mutex.Lock()
	history := make([]StoreInsertIndexFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreInsertIndexFuncCall is an object that describes an invocation of
// method InsertIndex on an instance of MockStore.
type StoreInsertIndexFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 store.Index
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreInsertIndexFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreInsertIndexFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreInsertUploadFunc describes the behavior when the InsertUpload method
// of the parent MockStore instance is invoked.
type StoreInsertUploadFunc struct {
	defaultHook func(context.Context, store.Upload) (int, error)
	hooks       []func(context.Context, store.Upload) (int, error)
	history     []StoreInsertUploadFuncCall
	mutex       sync.Mutex
}

// InsertUpload delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) InsertUpload(v0 context.Context, v1 store.Upload) (int, error) {
	r0, r1 := m.InsertUploadFunc.nextHook()(v0, v1)
	m.InsertUploadFunc.appendCall(StoreInsertUploadFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the InsertUpload method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreInsertUploadFunc) SetDefaultHook(hook func(context.Context, store.Upload) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertUpload method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreInsertUploadFunc) PushHook(hook func(context.Context, store.Upload) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreInsertUploadFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, store.Upload) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreInsertUploadFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, store.Upload) (int, error) {
		return r0, r1
	})
}

func (f *StoreInsertUploadFunc) nextHook() func(context.Context, store.Upload) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreInsertUploadFunc) appendCall(r0 StoreInsertUploadFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreInsertUploadFuncCall objects
// describing the invocations of this function.
func (f *StoreInsertUploadFunc) History() []StoreInsertUploadFuncCall {
	f.mutex.Lock()
	history := make([]StoreInsertUploadFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreInsertUploadFuncCall is an object that describes an invocation of
// method InsertUpload on an instance of MockStore.
type StoreInsertUploadFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 store.Upload
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreInsertUploadFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreInsertUploadFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreIsQueuedFunc describes the behavior when the IsQueued method of the
// parent MockStore instance is invoked.
type StoreIsQueuedFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []StoreIsQueuedFuncCall
	mutex       sync.Mutex
}

// IsQueued delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) IsQueued(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.IsQueuedFunc.nextHook()(v0, v1, v2)
	m.IsQueuedFunc.appendCall(StoreIsQueuedFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the IsQueued method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreIsQueuedFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// IsQueued method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreIsQueuedFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreIsQueuedFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreIsQueuedFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *StoreIsQueuedFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreIsQueuedFunc) appendCall(r0 StoreIsQueuedFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreIsQueuedFuncCall objects describing
// the invocations of this function.
func (f *StoreIsQueuedFunc) History() []StoreIsQueuedFuncCall {
	f.mutex.Lock()
	history := make([]StoreIsQueuedFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreIsQueuedFuncCall is an object that describes an invocation of method
// IsQueued on an instance of MockStore.
type StoreIsQueuedFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreIsQueuedFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreIsQueuedFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreLockFunc describes the behavior when the Lock method of the parent
// MockStore instance is invoked.
type StoreLockFunc struct {
	defaultHook func(context.Context, int, bool) (bool, store.UnlockFunc, error)
	hooks       []func(context.Context, int, bool) (bool, store.UnlockFunc, error)
	history     []StoreLockFuncCall
	mutex       sync.Mutex
}

// Lock delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Lock(v0 context.Context, v1 int, v2 bool) (bool, store.UnlockFunc, error) {
	r0, r1, r2 := m.LockFunc.nextHook()(v0, v1, v2)
	m.LockFunc.appendCall(StoreLockFuncCall{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Lock method of the
// parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreLockFunc) SetDefaultHook(hook func(context.Context, int, bool) (bool, store.UnlockFunc, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Lock method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreLockFunc) PushHook(hook func(context.Context, int, bool) (bool, store.UnlockFunc, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreLockFunc) SetDefaultReturn(r0 bool, r1 store.UnlockFunc, r2 error) {
	f.SetDefaultHook(func(context.Context, int, bool) (bool, store.UnlockFunc, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreLockFunc) PushReturn(r0 bool, r1 store.UnlockFunc, r2 error) {
	f.PushHook(func(context.Context, int, bool) (bool, store.UnlockFunc, error) {
		return r0, r1, r2
	})
}

func (f *StoreLockFunc) nextHook() func(context.Context, int, bool) (bool, store.UnlockFunc, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreLockFunc) appendCall(r0 StoreLockFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreLockFuncCall objects describing the
// invocations of this function.
func (f *StoreLockFunc) History() []StoreLockFuncCall {
	f.mutex.Lock()
	history := make([]StoreLockFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreLockFuncCall is an object that describes an invocation of method
// Lock on an instance of MockStore.
type StoreLockFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 bool
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 store.UnlockFunc
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreLockFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreLockFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreMarkCompleteFunc describes the behavior when the MarkComplete method
// of the parent MockStore instance is invoked.
type StoreMarkCompleteFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []StoreMarkCompleteFuncCall
	mutex       sync.Mutex
}

// MarkComplete delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) MarkComplete(v0 context.Context, v1 int) error {
	r0 := m.MarkCompleteFunc.nextHook()(v0, v1)
	m.MarkCompleteFunc.appendCall(StoreMarkCompleteFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the MarkComplete method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreMarkCompleteFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkComplete method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreMarkCompleteFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreMarkCompleteFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreMarkCompleteFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *StoreMarkCompleteFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreMarkCompleteFunc) appendCall(r0 StoreMarkCompleteFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreMarkCompleteFuncCall objects
// describing the invocations of this function.
func (f *StoreMarkCompleteFunc) History() []StoreMarkCompleteFuncCall {
	f.mutex.Lock()
	history := make([]StoreMarkCompleteFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreMarkCompleteFuncCall is an object that describes an invocation of
// method MarkComplete on an instance of MockStore.
type StoreMarkCompleteFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreMarkCompleteFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreMarkCompleteFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreMarkErroredFunc describes the behavior when the MarkErrored method
// of the parent MockStore instance is invoked.
type StoreMarkErroredFunc struct {
	defaultHook func(context.Context, int, string) error
	hooks       []func(context.Context, int, string) error
	history     []StoreMarkErroredFuncCall
	mutex       sync.Mutex
}

// MarkErrored delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) MarkErrored(v0 context.Context, v1 int, v2 string) error {
	r0 := m.MarkErroredFunc.nextHook()(v0, v1, v2)
	m.MarkErroredFunc.appendCall(StoreMarkErroredFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the MarkErrored method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreMarkErroredFunc) SetDefaultHook(hook func(context.Context, int, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkErrored method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreMarkErroredFunc) PushHook(hook func(context.Context, int, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreMarkErroredFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreMarkErroredFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string) error {
		return r0
	})
}

func (f *StoreMarkErroredFunc) nextHook() func(context.Context, int, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreMarkErroredFunc) appendCall(r0 StoreMarkErroredFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreMarkErroredFuncCall objects describing
// the invocations of this function.
func (f *StoreMarkErroredFunc) History() []StoreMarkErroredFuncCall {
	f.mutex.Lock()
	history := make([]StoreMarkErroredFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreMarkErroredFuncCall is an object that describes an invocation of
// method MarkErrored on an instance of MockStore.
type StoreMarkErroredFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreMarkErroredFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreMarkErroredFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreMarkIndexCompleteFunc describes the behavior when the
// MarkIndexComplete method of the parent MockStore instance is invoked.
type StoreMarkIndexCompleteFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []StoreMarkIndexCompleteFuncCall
	mutex       sync.Mutex
}

// MarkIndexComplete delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) MarkIndexComplete(v0 context.Context, v1 int) error {
	r0 := m.MarkIndexCompleteFunc.nextHook()(v0, v1)
	m.MarkIndexCompleteFunc.appendCall(StoreMarkIndexCompleteFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the MarkIndexComplete
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreMarkIndexCompleteFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkIndexComplete method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreMarkIndexCompleteFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreMarkIndexCompleteFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreMarkIndexCompleteFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *StoreMarkIndexCompleteFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreMarkIndexCompleteFunc) appendCall(r0 StoreMarkIndexCompleteFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreMarkIndexCompleteFuncCall objects
// describing the invocations of this function.
func (f *StoreMarkIndexCompleteFunc) History() []StoreMarkIndexCompleteFuncCall {
	f.mutex.Lock()
	history := make([]StoreMarkIndexCompleteFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreMarkIndexCompleteFuncCall is an object that describes an invocation
// of method MarkIndexComplete on an instance of MockStore.
type StoreMarkIndexCompleteFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreMarkIndexCompleteFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreMarkIndexCompleteFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreMarkIndexErroredFunc describes the behavior when the
// MarkIndexErrored method of the parent MockStore instance is invoked.
type StoreMarkIndexErroredFunc struct {
	defaultHook func(context.Context, int, string) error
	hooks       []func(context.Context, int, string) error
	history     []StoreMarkIndexErroredFuncCall
	mutex       sync.Mutex
}

// MarkIndexErrored delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) MarkIndexErrored(v0 context.Context, v1 int, v2 string) error {
	r0 := m.MarkIndexErroredFunc.nextHook()(v0, v1, v2)
	m.MarkIndexErroredFunc.appendCall(StoreMarkIndexErroredFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the MarkIndexErrored
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreMarkIndexErroredFunc) SetDefaultHook(hook func(context.Context, int, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkIndexErrored method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreMarkIndexErroredFunc) PushHook(hook func(context.Context, int, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreMarkIndexErroredFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreMarkIndexErroredFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string) error {
		return r0
	})
}

func (f *StoreMarkIndexErroredFunc) nextHook() func(context.Context, int, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreMarkIndexErroredFunc) appendCall(r0 StoreMarkIndexErroredFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreMarkIndexErroredFuncCall objects
// describing the invocations of this function.
func (f *StoreMarkIndexErroredFunc) History() []StoreMarkIndexErroredFuncCall {
	f.mutex.Lock()
	history := make([]StoreMarkIndexErroredFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreMarkIndexErroredFuncCall is an object that describes an invocation
// of method MarkIndexErrored on an instance of MockStore.
type StoreMarkIndexErroredFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreMarkIndexErroredFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreMarkIndexErroredFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreMarkQueuedFunc describes the behavior when the MarkQueued method of
// the parent MockStore instance is invoked.
type StoreMarkQueuedFunc struct {
	defaultHook func(context.Context, int, *int) error
	hooks       []func(context.Context, int, *int) error
	history     []StoreMarkQueuedFuncCall
	mutex       sync.Mutex
}

// MarkQueued delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) MarkQueued(v0 context.Context, v1 int, v2 *int) error {
	r0 := m.MarkQueuedFunc.nextHook()(v0, v1, v2)
	m.MarkQueuedFunc.appendCall(StoreMarkQueuedFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the MarkQueued method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreMarkQueuedFunc) SetDefaultHook(hook func(context.Context, int, *int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkQueued method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreMarkQueuedFunc) PushHook(hook func(context.Context, int, *int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreMarkQueuedFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, *int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreMarkQueuedFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, *int) error {
		return r0
	})
}

func (f *StoreMarkQueuedFunc) nextHook() func(context.Context, int, *int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreMarkQueuedFunc) appendCall(r0 StoreMarkQueuedFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreMarkQueuedFuncCall objects describing
// the invocations of this function.
func (f *StoreMarkQueuedFunc) History() []StoreMarkQueuedFuncCall {
	f.mutex.Lock()
	history := make([]StoreMarkQueuedFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreMarkQueuedFuncCall is an object that describes an invocation of
// method MarkQueued on an instance of MockStore.
type StoreMarkQueuedFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 *int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreMarkQueuedFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreMarkQueuedFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreMarkRepositoryAsDirtyFunc describes the behavior when the
// MarkRepositoryAsDirty method of the parent MockStore instance is invoked.
type StoreMarkRepositoryAsDirtyFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []StoreMarkRepositoryAsDirtyFuncCall
	mutex       sync.Mutex
}

// MarkRepositoryAsDirty delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) MarkRepositoryAsDirty(v0 context.Context, v1 int) error {
	r0 := m.MarkRepositoryAsDirtyFunc.nextHook()(v0, v1)
	m.MarkRepositoryAsDirtyFunc.appendCall(StoreMarkRepositoryAsDirtyFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// MarkRepositoryAsDirty method of the parent MockStore instance is invoked
// and the hook queue is empty.
func (f *StoreMarkRepositoryAsDirtyFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkRepositoryAsDirty method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreMarkRepositoryAsDirtyFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreMarkRepositoryAsDirtyFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreMarkRepositoryAsDirtyFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *StoreMarkRepositoryAsDirtyFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreMarkRepositoryAsDirtyFunc) appendCall(r0 StoreMarkRepositoryAsDirtyFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreMarkRepositoryAsDirtyFuncCall objects
// describing the invocations of this function.
func (f *StoreMarkRepositoryAsDirtyFunc) History() []StoreMarkRepositoryAsDirtyFuncCall {
	f.mutex.Lock()
	history := make([]StoreMarkRepositoryAsDirtyFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreMarkRepositoryAsDirtyFuncCall is an object that describes an
// invocation of method MarkRepositoryAsDirty on an instance of MockStore.
type StoreMarkRepositoryAsDirtyFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreMarkRepositoryAsDirtyFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreMarkRepositoryAsDirtyFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StorePackageReferencePagerFunc describes the behavior when the
// PackageReferencePager method of the parent MockStore instance is invoked.
type StorePackageReferencePagerFunc struct {
	defaultHook func(context.Context, string, string, string, int, int) (int, store.ReferencePager, error)
	hooks       []func(context.Context, string, string, string, int, int) (int, store.ReferencePager, error)
	history     []StorePackageReferencePagerFuncCall
	mutex       sync.Mutex
}

// PackageReferencePager delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) PackageReferencePager(v0 context.Context, v1 string, v2 string, v3 string, v4 int, v5 int) (int, store.ReferencePager, error) {
	r0, r1, r2 := m.PackageReferencePagerFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.PackageReferencePagerFunc.appendCall(StorePackageReferencePagerFuncCall{v0, v1, v2, v3, v4, v5, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// PackageReferencePager method of the parent MockStore instance is invoked
// and the hook queue is empty.
func (f *StorePackageReferencePagerFunc) SetDefaultHook(hook func(context.Context, string, string, string, int, int) (int, store.ReferencePager, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// PackageReferencePager method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StorePackageReferencePagerFunc) PushHook(hook func(context.Context, string, string, string, int, int) (int, store.ReferencePager, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StorePackageReferencePagerFunc) SetDefaultReturn(r0 int, r1 store.ReferencePager, r2 error) {
	f.SetDefaultHook(func(context.Context, string, string, string, int, int) (int, store.ReferencePager, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StorePackageReferencePagerFunc) PushReturn(r0 int, r1 store.ReferencePager, r2 error) {
	f.PushHook(func(context.Context, string, string, string, int, int) (int, store.ReferencePager, error) {
		return r0, r1, r2
	})
}

func (f *StorePackageReferencePagerFunc) nextHook() func(context.Context, string, string, string, int, int) (int, store.ReferencePager, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StorePackageReferencePagerFunc) appendCall(r0 StorePackageReferencePagerFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StorePackageReferencePagerFuncCall objects
// describing the invocations of this function.
func (f *StorePackageReferencePagerFunc) History() []StorePackageReferencePagerFuncCall {
	f.mutex.Lock()
	history := make([]StorePackageReferencePagerFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StorePackageReferencePagerFuncCall is an object that describes an
// invocation of method PackageReferencePager on an instance of MockStore.
type StorePackageReferencePagerFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 int
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 store.ReferencePager
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StorePackageReferencePagerFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StorePackageReferencePagerFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreQueueSizeFunc describes the behavior when the QueueSize method of
// the parent MockStore instance is invoked.
type StoreQueueSizeFunc struct {
	defaultHook func(context.Context) (int, error)
	hooks       []func(context.Context) (int, error)
	history     []StoreQueueSizeFuncCall
	mutex       sync.Mutex
}

// QueueSize delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) QueueSize(v0 context.Context) (int, error) {
	r0, r1 := m.QueueSizeFunc.nextHook()(v0)
	m.QueueSizeFunc.appendCall(StoreQueueSizeFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the QueueSize method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreQueueSizeFunc) SetDefaultHook(hook func(context.Context) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// QueueSize method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreQueueSizeFunc) PushHook(hook func(context.Context) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreQueueSizeFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreQueueSizeFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context) (int, error) {
		return r0, r1
	})
}

func (f *StoreQueueSizeFunc) nextHook() func(context.Context) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreQueueSizeFunc) appendCall(r0 StoreQueueSizeFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreQueueSizeFuncCall objects describing
// the invocations of this function.
func (f *StoreQueueSizeFunc) History() []StoreQueueSizeFuncCall {
	f.mutex.Lock()
	history := make([]StoreQueueSizeFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreQueueSizeFuncCall is an object that describes an invocation of
// method QueueSize on an instance of MockStore.
type StoreQueueSizeFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreQueueSizeFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreQueueSizeFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreRepoNameFunc describes the behavior when the RepoName method of the
// parent MockStore instance is invoked.
type StoreRepoNameFunc struct {
	defaultHook func(context.Context, int) (string, error)
	hooks       []func(context.Context, int) (string, error)
	history     []StoreRepoNameFuncCall
	mutex       sync.Mutex
}

// RepoName delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) RepoName(v0 context.Context, v1 int) (string, error) {
	r0, r1 := m.RepoNameFunc.nextHook()(v0, v1)
	m.RepoNameFunc.appendCall(StoreRepoNameFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepoName method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreRepoNameFunc) SetDefaultHook(hook func(context.Context, int) (string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoName method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreRepoNameFunc) PushHook(hook func(context.Context, int) (string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreRepoNameFunc) SetDefaultReturn(r0 string, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreRepoNameFunc) PushReturn(r0 string, r1 error) {
	f.PushHook(func(context.Context, int) (string, error) {
		return r0, r1
	})
}

func (f *StoreRepoNameFunc) nextHook() func(context.Context, int) (string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreRepoNameFunc) appendCall(r0 StoreRepoNameFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreRepoNameFuncCall objects describing
// the invocations of this function.
func (f *StoreRepoNameFunc) History() []StoreRepoNameFuncCall {
	f.mutex.Lock()
	history := make([]StoreRepoNameFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreRepoNameFuncCall is an object that describes an invocation of method
// RepoName on an instance of MockStore.
type StoreRepoNameFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreRepoNameFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreRepoNameFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreRepoUsageStatisticsFunc describes the behavior when the
// RepoUsageStatistics method of the parent MockStore instance is invoked.
type StoreRepoUsageStatisticsFunc struct {
	defaultHook func(context.Context) ([]store.RepoUsageStatistics, error)
	hooks       []func(context.Context) ([]store.RepoUsageStatistics, error)
	history     []StoreRepoUsageStatisticsFuncCall
	mutex       sync.Mutex
}

// RepoUsageStatistics delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) RepoUsageStatistics(v0 context.Context) ([]store.RepoUsageStatistics, error) {
	r0, r1 := m.RepoUsageStatisticsFunc.nextHook()(v0)
	m.RepoUsageStatisticsFunc.appendCall(StoreRepoUsageStatisticsFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the RepoUsageStatistics
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreRepoUsageStatisticsFunc) SetDefaultHook(hook func(context.Context) ([]store.RepoUsageStatistics, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepoUsageStatistics method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreRepoUsageStatisticsFunc) PushHook(hook func(context.Context) ([]store.RepoUsageStatistics, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreRepoUsageStatisticsFunc) SetDefaultReturn(r0 []store.RepoUsageStatistics, r1 error) {
	f.SetDefaultHook(func(context.Context) ([]store.RepoUsageStatistics, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreRepoUsageStatisticsFunc) PushReturn(r0 []store.RepoUsageStatistics, r1 error) {
	f.PushHook(func(context.Context) ([]store.RepoUsageStatistics, error) {
		return r0, r1
	})
}

func (f *StoreRepoUsageStatisticsFunc) nextHook() func(context.Context) ([]store.RepoUsageStatistics, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreRepoUsageStatisticsFunc) appendCall(r0 StoreRepoUsageStatisticsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreRepoUsageStatisticsFuncCall objects
// describing the invocations of this function.
func (f *StoreRepoUsageStatisticsFunc) History() []StoreRepoUsageStatisticsFuncCall {
	f.mutex.Lock()
	history := make([]StoreRepoUsageStatisticsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreRepoUsageStatisticsFuncCall is an object that describes an
// invocation of method RepoUsageStatistics on an instance of MockStore.
type StoreRepoUsageStatisticsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []store.RepoUsageStatistics
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreRepoUsageStatisticsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreRepoUsageStatisticsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreRequeueFunc describes the behavior when the Requeue method of the
// parent MockStore instance is invoked.
type StoreRequeueFunc struct {
	defaultHook func(context.Context, int, time.Time) error
	hooks       []func(context.Context, int, time.Time) error
	history     []StoreRequeueFuncCall
	mutex       sync.Mutex
}

// Requeue delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Requeue(v0 context.Context, v1 int, v2 time.Time) error {
	r0 := m.RequeueFunc.nextHook()(v0, v1, v2)
	m.RequeueFunc.appendCall(StoreRequeueFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Requeue method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreRequeueFunc) SetDefaultHook(hook func(context.Context, int, time.Time) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Requeue method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreRequeueFunc) PushHook(hook func(context.Context, int, time.Time) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreRequeueFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreRequeueFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

func (f *StoreRequeueFunc) nextHook() func(context.Context, int, time.Time) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreRequeueFunc) appendCall(r0 StoreRequeueFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreRequeueFuncCall objects describing the
// invocations of this function.
func (f *StoreRequeueFunc) History() []StoreRequeueFuncCall {
	f.mutex.Lock()
	history := make([]StoreRequeueFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreRequeueFuncCall is an object that describes an invocation of method
// Requeue on an instance of MockStore.
type StoreRequeueFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreRequeueFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreRequeueFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreRequeueIndexFunc describes the behavior when the RequeueIndex method
// of the parent MockStore instance is invoked.
type StoreRequeueIndexFunc struct {
	defaultHook func(context.Context, int, time.Time) error
	hooks       []func(context.Context, int, time.Time) error
	history     []StoreRequeueIndexFuncCall
	mutex       sync.Mutex
}

// RequeueIndex delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) RequeueIndex(v0 context.Context, v1 int, v2 time.Time) error {
	r0 := m.RequeueIndexFunc.nextHook()(v0, v1, v2)
	m.RequeueIndexFunc.appendCall(StoreRequeueIndexFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the RequeueIndex method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreRequeueIndexFunc) SetDefaultHook(hook func(context.Context, int, time.Time) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RequeueIndex method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreRequeueIndexFunc) PushHook(hook func(context.Context, int, time.Time) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreRequeueIndexFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreRequeueIndexFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, time.Time) error {
		return r0
	})
}

func (f *StoreRequeueIndexFunc) nextHook() func(context.Context, int, time.Time) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreRequeueIndexFunc) appendCall(r0 StoreRequeueIndexFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreRequeueIndexFuncCall objects
// describing the invocations of this function.
func (f *StoreRequeueIndexFunc) History() []StoreRequeueIndexFuncCall {
	f.mutex.Lock()
	history := make([]StoreRequeueIndexFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreRequeueIndexFuncCall is an object that describes an invocation of
// method RequeueIndex on an instance of MockStore.
type StoreRequeueIndexFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreRequeueIndexFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreRequeueIndexFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreResetIndexableRepositoriesFunc describes the behavior when the
// ResetIndexableRepositories method of the parent MockStore instance is
// invoked.
type StoreResetIndexableRepositoriesFunc struct {
	defaultHook func(context.Context, time.Time) error
	hooks       []func(context.Context, time.Time) error
	history     []StoreResetIndexableRepositoriesFuncCall
	mutex       sync.Mutex
}

// ResetIndexableRepositories delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) ResetIndexableRepositories(v0 context.Context, v1 time.Time) error {
	r0 := m.ResetIndexableRepositoriesFunc.nextHook()(v0, v1)
	m.ResetIndexableRepositoriesFunc.appendCall(StoreResetIndexableRepositoriesFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// ResetIndexableRepositories method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreResetIndexableRepositoriesFunc) SetDefaultHook(hook func(context.Context, time.Time) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ResetIndexableRepositories method of the parent MockStore instance
// inovkes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreResetIndexableRepositoriesFunc) PushHook(hook func(context.Context, time.Time) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreResetIndexableRepositoriesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, time.Time) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreResetIndexableRepositoriesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, time.Time) error {
		return r0
	})
}

func (f *StoreResetIndexableRepositoriesFunc) nextHook() func(context.Context, time.Time) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreResetIndexableRepositoriesFunc) appendCall(r0 StoreResetIndexableRepositoriesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreResetIndexableRepositoriesFuncCall
// objects describing the invocations of this function.
func (f *StoreResetIndexableRepositoriesFunc) History() []StoreResetIndexableRepositoriesFuncCall {
	f.mutex.Lock()
	history := make([]StoreResetIndexableRepositoriesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreResetIndexableRepositoriesFuncCall is an object that describes an
// invocation of method ResetIndexableRepositories on an instance of
// MockStore.
type StoreResetIndexableRepositoriesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreResetIndexableRepositoriesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreResetIndexableRepositoriesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreResetStalledFunc describes the behavior when the ResetStalled method
// of the parent MockStore instance is invoked.
type StoreResetStalledFunc struct {
	defaultHook func(context.Context, time.Time) ([]int, []int, error)
	hooks       []func(context.Context, time.Time) ([]int, []int, error)
	history     []StoreResetStalledFuncCall
	mutex       sync.Mutex
}

// ResetStalled delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) ResetStalled(v0 context.Context, v1 time.Time) ([]int, []int, error) {
	r0, r1, r2 := m.ResetStalledFunc.nextHook()(v0, v1)
	m.ResetStalledFunc.appendCall(StoreResetStalledFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the ResetStalled method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreResetStalledFunc) SetDefaultHook(hook func(context.Context, time.Time) ([]int, []int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ResetStalled method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreResetStalledFunc) PushHook(hook func(context.Context, time.Time) ([]int, []int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreResetStalledFunc) SetDefaultReturn(r0 []int, r1 []int, r2 error) {
	f.SetDefaultHook(func(context.Context, time.Time) ([]int, []int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreResetStalledFunc) PushReturn(r0 []int, r1 []int, r2 error) {
	f.PushHook(func(context.Context, time.Time) ([]int, []int, error) {
		return r0, r1, r2
	})
}

func (f *StoreResetStalledFunc) nextHook() func(context.Context, time.Time) ([]int, []int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreResetStalledFunc) appendCall(r0 StoreResetStalledFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreResetStalledFuncCall objects
// describing the invocations of this function.
func (f *StoreResetStalledFunc) History() []StoreResetStalledFuncCall {
	f.mutex.Lock()
	history := make([]StoreResetStalledFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreResetStalledFuncCall is an object that describes an invocation of
// method ResetStalled on an instance of MockStore.
type StoreResetStalledFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 []int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreResetStalledFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreResetStalledFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreResetStalledIndexesFunc describes the behavior when the
// ResetStalledIndexes method of the parent MockStore instance is invoked.
type StoreResetStalledIndexesFunc struct {
	defaultHook func(context.Context, time.Time) ([]int, []int, error)
	hooks       []func(context.Context, time.Time) ([]int, []int, error)
	history     []StoreResetStalledIndexesFuncCall
	mutex       sync.Mutex
}

// ResetStalledIndexes delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) ResetStalledIndexes(v0 context.Context, v1 time.Time) ([]int, []int, error) {
	r0, r1, r2 := m.ResetStalledIndexesFunc.nextHook()(v0, v1)
	m.ResetStalledIndexesFunc.appendCall(StoreResetStalledIndexesFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the ResetStalledIndexes
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreResetStalledIndexesFunc) SetDefaultHook(hook func(context.Context, time.Time) ([]int, []int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ResetStalledIndexes method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreResetStalledIndexesFunc) PushHook(hook func(context.Context, time.Time) ([]int, []int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreResetStalledIndexesFunc) SetDefaultReturn(r0 []int, r1 []int, r2 error) {
	f.SetDefaultHook(func(context.Context, time.Time) ([]int, []int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreResetStalledIndexesFunc) PushReturn(r0 []int, r1 []int, r2 error) {
	f.PushHook(func(context.Context, time.Time) ([]int, []int, error) {
		return r0, r1, r2
	})
}

func (f *StoreResetStalledIndexesFunc) nextHook() func(context.Context, time.Time) ([]int, []int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreResetStalledIndexesFunc) appendCall(r0 StoreResetStalledIndexesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreResetStalledIndexesFuncCall objects
// describing the invocations of this function.
func (f *StoreResetStalledIndexesFunc) History() []StoreResetStalledIndexesFuncCall {
	f.mutex.Lock()
	history := make([]StoreResetStalledIndexesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreResetStalledIndexesFuncCall is an object that describes an
// invocation of method ResetStalledIndexes on an instance of MockStore.
type StoreResetStalledIndexesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 []int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreResetStalledIndexesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreResetStalledIndexesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreSameRepoPagerFunc describes the behavior when the SameRepoPager
// method of the parent MockStore instance is invoked.
type StoreSameRepoPagerFunc struct {
	defaultHook func(context.Context, int, string, string, string, string, int) (int, store.ReferencePager, error)
	hooks       []func(context.Context, int, string, string, string, string, int) (int, store.ReferencePager, error)
	history     []StoreSameRepoPagerFuncCall
	mutex       sync.Mutex
}

// SameRepoPager delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) SameRepoPager(v0 context.Context, v1 int, v2 string, v3 string, v4 string, v5 string, v6 int) (int, store.ReferencePager, error) {
	r0, r1, r2 := m.SameRepoPagerFunc.nextHook()(v0, v1, v2, v3, v4, v5, v6)
	m.SameRepoPagerFunc.appendCall(StoreSameRepoPagerFuncCall{v0, v1, v2, v3, v4, v5, v6, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the SameRepoPager method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreSameRepoPagerFunc) SetDefaultHook(hook func(context.Context, int, string, string, string, string, int) (int, store.ReferencePager, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SameRepoPager method of the parent MockStore instance inovkes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreSameRepoPagerFunc) PushHook(hook func(context.Context, int, string, string, string, string, int) (int, store.ReferencePager, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreSameRepoPagerFunc) SetDefaultReturn(r0 int, r1 store.ReferencePager, r2 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, string, string, int) (int, store.ReferencePager, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreSameRepoPagerFunc) PushReturn(r0 int, r1 store.ReferencePager, r2 error) {
	f.PushHook(func(context.Context, int, string, string, string, string, int) (int, store.ReferencePager, error) {
		return r0, r1, r2
	})
}

func (f *StoreSameRepoPagerFunc) nextHook() func(context.Context, int, string, string, string, string, int) (int, store.ReferencePager, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreSameRepoPagerFunc) appendCall(r0 StoreSameRepoPagerFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreSameRepoPagerFuncCall objects
// describing the invocations of this function.
func (f *StoreSameRepoPagerFunc) History() []StoreSameRepoPagerFuncCall {
	f.mutex.Lock()
	history := make([]StoreSameRepoPagerFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreSameRepoPagerFuncCall is an object that describes an invocation of
// method SameRepoPager on an instance of MockStore.
type StoreSameRepoPagerFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 string
	// Arg6 is the value of the 7th argument passed to this method
	// invocation.
	Arg6 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 store.ReferencePager
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreSameRepoPagerFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5, c.Arg6}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreSameRepoPagerFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreSetIndexLogContentsFunc describes the behavior when the
// SetIndexLogContents method of the parent MockStore instance is invoked.
type StoreSetIndexLogContentsFunc struct {
	defaultHook func(context.Context, int, string) error
	hooks       []func(context.Context, int, string) error
	history     []StoreSetIndexLogContentsFuncCall
	mutex       sync.Mutex
}

// SetIndexLogContents delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) SetIndexLogContents(v0 context.Context, v1 int, v2 string) error {
	r0 := m.SetIndexLogContentsFunc.nextHook()(v0, v1, v2)
	m.SetIndexLogContentsFunc.appendCall(StoreSetIndexLogContentsFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the SetIndexLogContents
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreSetIndexLogContentsFunc) SetDefaultHook(hook func(context.Context, int, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SetIndexLogContents method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreSetIndexLogContentsFunc) PushHook(hook func(context.Context, int, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreSetIndexLogContentsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreSetIndexLogContentsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string) error {
		return r0
	})
}

func (f *StoreSetIndexLogContentsFunc) nextHook() func(context.Context, int, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreSetIndexLogContentsFunc) appendCall(r0 StoreSetIndexLogContentsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreSetIndexLogContentsFuncCall objects
// describing the invocations of this function.
func (f *StoreSetIndexLogContentsFunc) History() []StoreSetIndexLogContentsFuncCall {
	f.mutex.Lock()
	history := make([]StoreSetIndexLogContentsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreSetIndexLogContentsFuncCall is an object that describes an
// invocation of method SetIndexLogContents on an instance of MockStore.
type StoreSetIndexLogContentsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreSetIndexLogContentsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreSetIndexLogContentsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreSoftDeleteOldDumpsFunc describes the behavior when the
// SoftDeleteOldDumps method of the parent MockStore instance is invoked.
type StoreSoftDeleteOldDumpsFunc struct {
	defaultHook func(context.Context, time.Duration, time.Time) (int, error)
	hooks       []func(context.Context, time.Duration, time.Time) (int, error)
	history     []StoreSoftDeleteOldDumpsFuncCall
	mutex       sync.Mutex
}

// SoftDeleteOldDumps delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) SoftDeleteOldDumps(v0 context.Context, v1 time.Duration, v2 time.Time) (int, error) {
	r0, r1 := m.SoftDeleteOldDumpsFunc.nextHook()(v0, v1, v2)
	m.SoftDeleteOldDumpsFunc.appendCall(StoreSoftDeleteOldDumpsFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the SoftDeleteOldDumps
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreSoftDeleteOldDumpsFunc) SetDefaultHook(hook func(context.Context, time.Duration, time.Time) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SoftDeleteOldDumps method of the parent MockStore instance inovkes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreSoftDeleteOldDumpsFunc) PushHook(hook func(context.Context, time.Duration, time.Time) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreSoftDeleteOldDumpsFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, time.Duration, time.Time) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreSoftDeleteOldDumpsFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, time.Duration, time.Time) (int, error) {
		return r0, r1
	})
}

func (f *StoreSoftDeleteOldDumpsFunc) nextHook() func(context.Context, time.Duration, time.Time) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreSoftDeleteOldDumpsFunc) appendCall(r0 StoreSoftDeleteOldDumpsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreSoftDeleteOldDumpsFuncCall objects
// describing the invocations of this function.
func (f *StoreSoftDeleteOldDumpsFunc) History() []StoreSoftDeleteOldDumpsFuncCall {
	f.mutex.Lock()
	history := make([]StoreSoftDeleteOldDumpsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreSoftDeleteOldDumpsFuncCall is an object that describes an invocation
// of method SoftDeleteOldDumps on an instance of MockStore.
type StoreSoftDeleteOldDumpsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 time.Duration
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreSoftDeleteOldDumpsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreSoftDeleteOldDumpsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreTransactFunc describes the behavior when the Transact method of the
// parent MockStore instance is invoked.
type StoreTransactFunc struct {
	defaultHook func(context.Context) (store.Store, error)
	hooks       []func(context.Context) (store.Store, error)
	history     []StoreTransactFuncCall
	mutex       sync.Mutex
}

// Transact delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) Transact(v0 context.Context) (store.Store, error) {
	r0, r1 := m.TransactFunc.nextHook()(v0)
	m.TransactFunc.appendCall(StoreTransactFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the Transact method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreTransactFunc) SetDefaultHook(hook func(context.Context) (store.Store, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Transact method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreTransactFunc) PushHook(hook func(context.Context) (store.Store, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreTransactFunc) SetDefaultReturn(r0 store.Store, r1 error) {
	f.SetDefaultHook(func(context.Context) (store.Store, error) {
		return r0, r1
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreTransactFunc) PushReturn(r0 store.Store, r1 error) {
	f.PushHook(func(context.Context) (store.Store, error) {
		return r0, r1
	})
}

func (f *StoreTransactFunc) nextHook() func(context.Context) (store.Store, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreTransactFunc) appendCall(r0 StoreTransactFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreTransactFuncCall objects describing
// the invocations of this function.
func (f *StoreTransactFunc) History() []StoreTransactFuncCall {
	f.mutex.Lock()
	history := make([]StoreTransactFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreTransactFuncCall is an object that describes an invocation of method
// Transact on an instance of MockStore.
type StoreTransactFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Store
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreTransactFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreTransactFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreUpdateIndexableRepositoryFunc describes the behavior when the
// UpdateIndexableRepository method of the parent MockStore instance is
// invoked.
type StoreUpdateIndexableRepositoryFunc struct {
	defaultHook func(context.Context, store.UpdateableIndexableRepository, time.Time) error
	hooks       []func(context.Context, store.UpdateableIndexableRepository, time.Time) error
	history     []StoreUpdateIndexableRepositoryFuncCall
	mutex       sync.Mutex
}

// UpdateIndexableRepository delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) UpdateIndexableRepository(v0 context.Context, v1 store.UpdateableIndexableRepository, v2 time.Time) error {
	r0 := m.UpdateIndexableRepositoryFunc.nextHook()(v0, v1, v2)
	m.UpdateIndexableRepositoryFunc.appendCall(StoreUpdateIndexableRepositoryFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdateIndexableRepository method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreUpdateIndexableRepositoryFunc) SetDefaultHook(hook func(context.Context, store.UpdateableIndexableRepository, time.Time) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateIndexableRepository method of the parent MockStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreUpdateIndexableRepositoryFunc) PushHook(hook func(context.Context, store.UpdateableIndexableRepository, time.Time) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreUpdateIndexableRepositoryFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, store.UpdateableIndexableRepository, time.Time) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreUpdateIndexableRepositoryFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, store.UpdateableIndexableRepository, time.Time) error {
		return r0
	})
}

func (f *StoreUpdateIndexableRepositoryFunc) nextHook() func(context.Context, store.UpdateableIndexableRepository, time.Time) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreUpdateIndexableRepositoryFunc) appendCall(r0 StoreUpdateIndexableRepositoryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreUpdateIndexableRepositoryFuncCall
// objects describing the invocations of this function.
func (f *StoreUpdateIndexableRepositoryFunc) History() []StoreUpdateIndexableRepositoryFuncCall {
	f.mutex.Lock()
	history := make([]StoreUpdateIndexableRepositoryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreUpdateIndexableRepositoryFuncCall is an object that describes an
// invocation of method UpdateIndexableRepository on an instance of
// MockStore.
type StoreUpdateIndexableRepositoryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 store.UpdateableIndexableRepository
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreUpdateIndexableRepositoryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreUpdateIndexableRepositoryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreUpdatePackageReferencesFunc describes the behavior when the
// UpdatePackageReferences method of the parent MockStore instance is
// invoked.
type StoreUpdatePackageReferencesFunc struct {
	defaultHook func(context.Context, []types.PackageReference) error
	hooks       []func(context.Context, []types.PackageReference) error
	history     []StoreUpdatePackageReferencesFuncCall
	mutex       sync.Mutex
}

// UpdatePackageReferences delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) UpdatePackageReferences(v0 context.Context, v1 []types.PackageReference) error {
	r0 := m.UpdatePackageReferencesFunc.nextHook()(v0, v1)
	m.UpdatePackageReferencesFunc.appendCall(StoreUpdatePackageReferencesFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdatePackageReferences method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreUpdatePackageReferencesFunc) SetDefaultHook(hook func(context.Context, []types.PackageReference) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdatePackageReferences method of the parent MockStore instance inovkes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreUpdatePackageReferencesFunc) PushHook(hook func(context.Context, []types.PackageReference) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreUpdatePackageReferencesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, []types.PackageReference) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreUpdatePackageReferencesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, []types.PackageReference) error {
		return r0
	})
}

func (f *StoreUpdatePackageReferencesFunc) nextHook() func(context.Context, []types.PackageReference) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreUpdatePackageReferencesFunc) appendCall(r0 StoreUpdatePackageReferencesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreUpdatePackageReferencesFuncCall
// objects describing the invocations of this function.
func (f *StoreUpdatePackageReferencesFunc) History() []StoreUpdatePackageReferencesFuncCall {
	f.mutex.Lock()
	history := make([]StoreUpdatePackageReferencesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreUpdatePackageReferencesFuncCall is an object that describes an
// invocation of method UpdatePackageReferences on an instance of MockStore.
type StoreUpdatePackageReferencesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []types.PackageReference
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreUpdatePackageReferencesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreUpdatePackageReferencesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreUpdatePackagesFunc describes the behavior when the UpdatePackages
// method of the parent MockStore instance is invoked.
type StoreUpdatePackagesFunc struct {
	defaultHook func(context.Context, []types.Package) error
	hooks       []func(context.Context, []types.Package) error
	history     []StoreUpdatePackagesFuncCall
	mutex       sync.Mutex
}

// UpdatePackages delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) UpdatePackages(v0 context.Context, v1 []types.Package) error {
	r0 := m.UpdatePackagesFunc.nextHook()(v0, v1)
	m.UpdatePackagesFunc.appendCall(StoreUpdatePackagesFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the UpdatePackages
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreUpdatePackagesFunc) SetDefaultHook(hook func(context.Context, []types.Package) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdatePackages method of the parent MockStore instance inovkes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreUpdatePackagesFunc) PushHook(hook func(context.Context, []types.Package) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreUpdatePackagesFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, []types.Package) error {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreUpdatePackagesFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, []types.Package) error {
		return r0
	})
}

func (f *StoreUpdatePackagesFunc) nextHook() func(context.Context, []types.Package) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreUpdatePackagesFunc) appendCall(r0 StoreUpdatePackagesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreUpdatePackagesFuncCall objects
// describing the invocations of this function.
func (f *StoreUpdatePackagesFunc) History() []StoreUpdatePackagesFuncCall {
	f.mutex.Lock()
	history := make([]StoreUpdatePackagesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreUpdatePackagesFuncCall is an object that describes an invocation of
// method UpdatePackages on an instance of MockStore.
type StoreUpdatePackagesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []types.Package
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreUpdatePackagesFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreUpdatePackagesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreWithFunc describes the behavior when the With method of the parent
// MockStore instance is invoked.
type StoreWithFunc struct {
	defaultHook func(basestore.ShareableStore) store.Store
	hooks       []func(basestore.ShareableStore) store.Store
	history     []StoreWithFuncCall
	mutex       sync.Mutex
}

// With delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) With(v0 basestore.ShareableStore) store.Store {
	r0 := m.WithFunc.nextHook()(v0)
	m.WithFunc.appendCall(StoreWithFuncCall{v0, r0})
	return r0
}

// SetDefaultHook sets function that is called when the With method of the
// parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreWithFunc) SetDefaultHook(hook func(basestore.ShareableStore) store.Store) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// With method of the parent MockStore instance inovkes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreWithFunc) PushHook(hook func(basestore.ShareableStore) store.Store) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultDefaultHook with a function that returns
// the given values.
func (f *StoreWithFunc) SetDefaultReturn(r0 store.Store) {
	f.SetDefaultHook(func(basestore.ShareableStore) store.Store {
		return r0
	})
}

// PushReturn calls PushDefaultHook with a function that returns the given
// values.
func (f *StoreWithFunc) PushReturn(r0 store.Store) {
	f.PushHook(func(basestore.ShareableStore) store.Store {
		return r0
	})
}

func (f *StoreWithFunc) nextHook() func(basestore.ShareableStore) store.Store {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreWithFunc) appendCall(r0 StoreWithFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreWithFuncCall objects describing the
// invocations of this function.
func (f *StoreWithFunc) History() []StoreWithFuncCall {
	f.mutex.Lock()
	history := make([]StoreWithFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreWithFuncCall is an object that describes an invocation of method
// With on an instance of MockStore.
type StoreWithFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 basestore.ShareableStore
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 store.Store
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreWithFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreWithFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}
