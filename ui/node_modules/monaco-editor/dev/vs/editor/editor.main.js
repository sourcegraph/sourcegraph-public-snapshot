/*!-----------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.5.3(793ede49d53dba79d39e52205f16321278f5183c)
 * Released under the MIT license
 * https://github.com/Microsoft/vscode/blob/master/LICENSE.txt
 *-----------------------------------------------------------*/

(function() {
var __m = ["require","exports","vs/base/common/winjs.base","vs/base/common/lifecycle","vs/editor/common/core/range","vs/nls","vs/nls!vs/editor/editor.main","vs/editor/common/editorCommon","vs/base/common/errors","vs/css!vs/editor/editor.main","vs/base/common/strings","vs/base/browser/dom","vs/base/common/keyCodes","vs/editor/common/editorCommonExtensions","vs/base/common/async","vs/platform/instantiation/common/instantiation","vs/base/common/event","vs/editor/common/modes","vs/base/common/platform","vs/platform/keybinding/common/keybindingService","vs/editor/common/editorAction","vs/editor/common/core/position","vs/editor/browser/editorBrowser","vs/base/common/eventEmitter","vs/editor/common/core/selection","vs/editor/common/editorActionEnablement","vs/base/common/types","vs/base/browser/styleMutator","vs/base/browser/browser","vs/base/common/uri","vs/editor/browser/editorBrowserExtensions","vs/base/common/objects","vs/base/common/severity","vs/platform/platform","vs/editor/common/services/modelService","vs/base/browser/builder","vs/platform/telemetry/common/telemetry","vs/base/common/arrays","vs/base/common/paths","vs/base/browser/mouseEvent","vs/editor/common/modes/languageConfigurationRegistry","vs/base/browser/ui/scrollbar/scrollableElementOptions","vs/platform/message/common/message","vs/platform/editor/common/editor","vs/base/browser/ui/widget","vs/editor/common/modes/modesRegistry","vs/editor/browser/view/viewPart","vs/base/common/assert","vs/base/common/collections","vs/editor/common/modes/supports","vs/base/common/actions","vs/platform/keybinding/common/keybindingsRegistry","vs/editor/common/services/editorWorkerService","vs/editor/common/viewModel/viewEventHandler","vs/editor/common/services/codeEditorService","vs/editor/common/config/defaultConfig","vs/base/browser/keyboardEvent","vs/platform/configuration/common/configuration","vs/base/browser/ui/actionbar/actionbar","vs/base/common/timer","vs/base/common/events","vs/platform/workspace/common/workspace","vs/editor/common/core/editOperation","vs/base/common/idGenerator","vs/editor/common/core/viewLineToken","vs/base/common/filters","vs/editor/browser/config/configuration","vs/platform/instantiation/common/serviceCollection","vs/platform/instantiation/common/descriptors","vs/base/browser/touch","vs/platform/contextview/browser/contextView","vs/base/browser/htmlContentRenderer","vs/editor/common/services/modeService","vs/platform/markers/common/markers","vs/editor/browser/view/dynamicViewOverlay","vs/base/parts/tree/browser/treeDefaults","vs/editor/common/model/wordHelper","vs/platform/configuration/common/configurationRegistry","vs/base/common/network","vs/platform/actions/common/actions","vs/editor/common/viewModel/prefixSumComputer","vs/base/browser/ui/aria/aria","vs/platform/event/common/event","vs/editor/common/modes/supports/richEditBrackets","vs/platform/extensions/common/extensions","vs/platform/jsonschemas/common/jsonContributionRegistry","vs/platform/extensions/common/extensionsRegistry","vs/base/browser/ui/scrollbar/scrollableElement","vs/editor/common/core/modeTransition","vs/editor/common/core/arrays","vs/editor/common/config/config","vs/base/parts/quickopen/common/quickOpen","vs/base/common/htmlContent","vs/editor/contrib/snippet/common/snippet","vs/editor/browser/widget/codeEditorWidget","vs/editor/contrib/zoneWidget/browser/peekViewWidget","vs/editor/contrib/referenceSearch/browser/referencesModel","vs/editor/common/controller/cursorMoveHelper","vs/base/browser/ui/inputbox/inputBox","vs/base/common/map","vs/base/browser/ui/scrollbar/scrollbarArrow","vs/platform/keybinding/common/keybindingResolver","vs/editor/common/view/renderingContext","vs/editor/common/viewLayout/viewLineRenderer","vs/base/common/cancellation","vs/base/parts/quickopen/browser/quickOpenModel","vs/base/parts/tree/browser/treeImpl","vs/editor/contrib/quickOpen/browser/editorQuickOpen","vs/editor/browser/standalone/standaloneServices","vs/base/common/iterator","vs/editor/common/commands/replaceCommand","vs/editor/common/config/commonEditorConfig","vs/base/browser/globalMouseMoveMonitor","vs/editor/common/services/compatWorkerService","vs/editor/common/modes/abstractState","vs/platform/request/common/request","vs/editor/common/viewModel/viewModel","vs/editor/common/modes/monarch/monarchCommon","vs/base/common/worker/workerClient","vs/editor/contrib/suggest/common/suggest","vs/editor/browser/standalone/simpleServices","vs/editor/common/modes/nullMode","vs/base/browser/ui/highlightedlabel/highlightedLabel","vs/base/browser/ui/sash/sash","vs/base/common/json","vs/editor/common/model/model","vs/editor/contrib/comment/common/blockCommentCommand","vs/editor/contrib/diffNavigator/common/diffNavigator","vs/editor/contrib/find/common/findModel","vs/editor/contrib/hover/browser/hoverOperation","vs/base/common/uuid","vs/editor/common/modes/monarch/monarchCompile","vs/base/common/glob","vs/editor/common/services/editorWorkerServiceImpl","vs/base/common/callbackList","vs/base/browser/ui/scrollbar/scrollbarState","vs/css!vs/base/browser/ui/progressbar/progressbar","vs/base/browser/event","vs/editor/common/modes/supports/tokenizationSupport","vs/platform/files/common/files","vs/editor/common/modes/monarch/monarchLexer","vs/platform/instantiation/common/instantiationService","vs/base/common/labels","vs/base/common/stopwatch","vs/base/common/mime","vs/base/browser/ui/contextview/contextview","vs/editor/common/viewModel/splitLinesCollection","vs/platform/opener/common/opener","vs/editor/common/controller/textAreaState","vs/base/browser/iframe","vs/base/common/diff/diff","vs/editor/browser/standalone/colorizer","vs/editor/browser/viewParts/glyphMargin/glyphMargin","vs/base/browser/ui/scrollbar/abstractScrollbar","vs/editor/common/model/tokensBinaryEncoding","vs/base/worker/defaultWorkerFactory","vs/editor/browser/editorDom","vs/editor/common/modes/supports/suggestSupport","vs/editor/common/modes/abstractMode","vs/editor/browser/view/viewLayer","vs/editor/browser/viewParts/overviewRuler/overviewRulerImpl","vs/platform/keybinding/browser/keybindingServiceImpl","vs/editor/contrib/hover/browser/hoverWidgets","vs/platform/storage/common/storage","vs/editor/contrib/zoneWidget/browser/zoneWidget","vs/editor/common/model/modelLine","vs/editor/contrib/parameterHints/common/parameterHints","vs/editor/contrib/quickFix/common/quickFix","vs/editor/contrib/quickOpen/common/quickOpen","vs/editor/common/standalone/standaloneBase","vs/editor/common/modes/lineStream","vs/editor/contrib/toggleTabFocusMode/common/toggleTabFocusMode","vs/editor/common/viewLayout/viewLineParts","vs/editor/common/controller/oneCursor","vs/editor/browser/widget/diffEditorWidget","vs/editor/browser/widget/embeddedCodeEditorWidget","vs/editor/common/model/textModelWithTokensHelpers","vs/editor/common/model/textModel","vs/editor/contrib/referenceSearch/browser/referencesWidget","vs/editor/contrib/referenceSearch/browser/referencesController","vs/editor/common/model/textModelWithTokens","vs/editor/browser/standalone/standaloneCodeEditor","vs/css!vs/editor/browser/viewParts/decorations/decorations","vs/nls!vs/base/browser/ui/aria/aria","vs/nls!vs/base/browser/ui/findinput/findInput","vs/nls!vs/base/browser/ui/inputbox/inputBox","vs/nls!vs/base/common/errors","vs/css!vs/editor/browser/viewParts/glyphMargin/glyphMargin","vs/css!vs/editor/browser/viewParts/lineNumbers/lineNumbers","vs/css!vs/editor/browser/viewParts/lines/viewLines","vs/css!vs/editor/browser/viewParts/linesDecorations/linesDecorations","vs/css!vs/editor/browser/viewParts/overlayWidgets/overlayWidgets","vs/css!vs/editor/browser/viewParts/rulers/rulers","vs/css!vs/editor/browser/viewParts/scrollDecoration/scrollDecoration","vs/css!vs/editor/browser/viewParts/selections/selections","vs/base/common/scrollable","vs/css!vs/editor/browser/viewParts/viewCursors/viewCursors","vs/css!vs/editor/browser/widget/media/diffEditor","vs/editor/contrib/indentation/common/indentation","vs/css!vs/editor/browser/widget/media/editor","vs/css!vs/editor/browser/widget/media/tokens","vs/base/browser/ui/scrollbar/scrollbarVisibilityController","vs/css!vs/editor/contrib/accessibility/browser/accessibility","vs/base/common/worker/simpleWorker","vs/css!vs/editor/contrib/clipboard/browser/clipboard","vs/base/parts/quickopen/browser/quickOpenViewer","vs/base/parts/tree/browser/treeModel","vs/base/parts/tree/browser/treeViewModel","vs/css!vs/editor/contrib/codelens/browser/codelens","vs/editor/browser/view/viewEventDispatcher","vs/css!vs/editor/contrib/defineKeybinding/browser/defineKeybinding","vs/editor/common/model/editStack","vs/css!vs/editor/contrib/find/browser/findWidget","vs/css!vs/editor/contrib/folding/browser/folding","vs/editor/common/modes/languageFeatureRegistry","vs/css!vs/editor/contrib/goToDeclaration/browser/goToDeclaration","vs/editor/common/modes/supports/onEnter","vs/css!vs/editor/contrib/gotoError/browser/gotoError","vs/editor/common/commands/shiftCommand","vs/css!vs/editor/contrib/hover/browser/hover","vs/editor/common/controller/cursorCollection","vs/css!vs/editor/contrib/iPadShowKeyboard/browser/iPadShowKeyboard","vs/editor/common/viewModel/viewModelImpl","vs/css!vs/editor/contrib/inPlaceReplace/browser/inPlaceReplace","vs/editor/contrib/comment/common/lineCommentCommand","vs/css!vs/editor/contrib/links/browser/links","vs/css!vs/editor/contrib/outlineMarker/browser/outlineMarker","vs/editor/contrib/find/common/findState","vs/css!vs/editor/contrib/parameterHints/browser/parameterHints","vs/editor/contrib/links/common/links","vs/css!vs/editor/contrib/quickFix/browser/quickFix","vs/editor/contrib/smartSelect/common/tokenTree","vs/editor/contrib/suggest/browser/completionModel","vs/nls!vs/base/common/json","vs/css!vs/editor/contrib/quickOpen/browser/gotoLine","vs/editor/contrib/defineKeybinding/common/smartSnippetInserter","vs/nls!vs/base/common/keyCodes","vs/css!vs/editor/contrib/quickOpen/browser/quickOutline","vs/css!vs/editor/contrib/referenceSearch/browser/referencesWidget","vs/css!vs/editor/contrib/rename/browser/renameInputField","vs/css!vs/editor/contrib/snippet/browser/snippet","vs/css!vs/editor/contrib/suggest/browser/suggest","vs/css!vs/editor/contrib/wordHighlighter/browser/wordHighlighter","vs/css!vs/editor/contrib/zoneWidget/browser/peekViewWidget","vs/css!vs/editor/contrib/zoneWidget/browser/zoneWidget","vs/css!vs/platform/contextview/browser/contextMenuHandler","vs/css!vs/platform/keybinding/browser/keybindings","vs/editor/browser/config/elementSizeObserver","vs/base/browser/ui/countBadge/countBadge","vs/base/common/diff/diffChange","vs/base/browser/ui/fileLabel/fileLabel","vs/base/browser/ui/leftRightWidget/leftRightWidget","vs/base/browser/ui/list/rowCache","vs/base/browser/ui/menu/menu","vs/base/browser/ui/progressbar/progressbar","vs/base/common/graph","vs/base/common/flags","vs/base/browser/ui/checkbox/checkbox","vs/base/browser/ui/list/rangeMap","vs/base/common/scorer","vs/base/browser/ui/findinput/findInput","vs/editor/common/commands/trimTrailingWhitespaceCommand","vs/base/browser/ui/scrollbar/horizontalScrollbar","vs/base/browser/ui/scrollbar/verticalScrollbar","vs/base/common/hash","vs/base/browser/ui/list/listView","vs/base/browser/ui/list/listWidget","vs/base/parts/tree/browser/treeView","vs/base/common/marshalling","vs/editor/browser/controller/mouseTarget","vs/editor/common/commands/surroundSelectionCommand","vs/editor/browser/controller/mouseHandler","vs/editor/browser/controller/pointerHandler","vs/base/browser/ui/octiconLabel/octiconLabel","vs/editor/browser/viewLayout/scrollManager","vs/editor/browser/viewLayout/layoutProvider","vs/editor/browser/viewParts/contentWidgets/contentWidgets","vs/editor/browser/viewParts/lines/viewLine","vs/editor/browser/viewParts/overlayWidgets/overlayWidgets","vs/base/common/worker/workerProtocol","vs/editor/browser/viewParts/overviewRuler/overviewRuler","vs/editor/browser/viewParts/rulers/rulers","vs/editor/browser/viewParts/scrollDecoration/scrollDecoration","vs/editor/browser/viewParts/viewZones/viewZones","vs/editor/common/controller/textAreaHandler","vs/editor/common/diff/diffComputer","vs/editor/contrib/hover/browser/modesGlyphHover","vs/editor/contrib/quickFix/browser/lightBulpWidget","vs/base/common/comparers","vs/nls!vs/base/common/severity","vs/base/parts/tree/browser/tree","vs/editor/browser/view/viewController","vs/editor/common/services/editorSimpleWorker","vs/nls!vs/base/parts/quickopen/browser/quickOpenModel","vs/nls!vs/base/parts/quickopen/browser/quickOpenWidget","vs/nls!vs/base/parts/tree/browser/treeDefaults","vs/base/parts/tree/browser/treeDnd","vs/editor/common/core/editorState","vs/editor/common/model/indentationGuesser","vs/base/parts/quickopen/browser/quickOpenWidget","vs/editor/contrib/quickOpen/browser/quickOpenEditorWidget","vs/nls!vs/editor/browser/standalone/standaloneSchemas","vs/editor/browser/standalone/standaloneSchemas","vs/nls!vs/editor/common/config/commonEditorConfig","vs/nls!vs/editor/common/config/defaultConfig","vs/editor/common/model/lineToken","vs/editor/common/model/tokenIterator","vs/nls!vs/editor/common/controller/cursor","vs/editor/common/controller/cursor","vs/nls!vs/editor/common/model/textModelWithTokens","vs/css!vs/base/browser/builder","vs/editor/common/model/textModelWithMarkers","vs/editor/common/model/textModelWithTrackedRanges","vs/editor/common/model/textModelWithDecorations","vs/editor/common/model/editableTextModel","vs/base/common/marked/marked","vs/nls!vs/editor/common/modes/modesRegistry","vs/nls!vs/editor/common/modes/supports/suggestSupport","vs/nls!vs/editor/common/services/bulkEdit","vs/nls!vs/editor/common/services/modeServiceImpl","vs/nls!vs/editor/common/services/modelServiceImpl","vs/nls!vs/editor/contrib/accessibility/browser/accessibility","vs/nls!vs/editor/contrib/carretOperations/common/carretOperations","vs/nls!vs/editor/contrib/clipboard/browser/clipboard","vs/nls!vs/editor/contrib/comment/common/comment","vs/nls!vs/editor/contrib/contextmenu/browser/contextmenu","vs/nls!vs/editor/contrib/defineKeybinding/browser/defineKeybinding","vs/nls!vs/editor/contrib/find/browser/findWidget","vs/editor/contrib/find/browser/findWidget","vs/nls!vs/editor/contrib/find/common/findController","vs/nls!vs/editor/contrib/folding/browser/folding","vs/nls!vs/editor/contrib/format/common/formatActions","vs/nls!vs/editor/contrib/goToDeclaration/browser/goToDeclaration","vs/nls!vs/editor/contrib/gotoError/browser/gotoError","vs/nls!vs/editor/contrib/hover/browser/hover","vs/nls!vs/editor/contrib/hover/browser/modesContentHover","vs/nls!vs/editor/contrib/inPlaceReplace/common/inPlaceReplace","vs/nls!vs/editor/contrib/indentation/common/indentation","vs/nls!vs/editor/contrib/linesOperations/common/linesOperations","vs/nls!vs/editor/contrib/links/browser/links","vs/nls!vs/editor/contrib/multicursor/common/multicursor","vs/nls!vs/editor/contrib/parameterHints/browser/parameterHints","vs/nls!vs/editor/contrib/parameterHints/browser/parameterHintsWidget","vs/nls!vs/editor/contrib/quickFix/browser/quickFix","vs/nls!vs/editor/contrib/quickFix/browser/quickFixSelectionWidget","vs/editor/contrib/quickFix/browser/quickFixSelectionWidget","vs/nls!vs/editor/contrib/quickOpen/browser/gotoLine","vs/nls!vs/editor/contrib/quickOpen/browser/gotoLine.contribution","vs/nls!vs/editor/contrib/quickOpen/browser/quickCommand","vs/nls!vs/editor/contrib/quickOpen/browser/quickCommand.contribution","vs/nls!vs/editor/contrib/quickOpen/browser/quickOutline","vs/nls!vs/editor/contrib/quickOpen/browser/quickOutline.contribution","vs/nls!vs/editor/contrib/referenceSearch/browser/referenceSearch","vs/nls!vs/editor/contrib/referenceSearch/browser/referencesController","vs/nls!vs/editor/contrib/referenceSearch/browser/referencesWidget","vs/nls!vs/editor/contrib/rename/browser/rename","vs/nls!vs/editor/contrib/rename/browser/renameInputField","vs/editor/contrib/rename/browser/renameInputField","vs/nls!vs/editor/contrib/rename/common/rename","vs/nls!vs/editor/contrib/smartSelect/common/jumpToBracket","vs/nls!vs/editor/contrib/smartSelect/common/smartSelect","vs/nls!vs/editor/contrib/suggest/browser/suggest","vs/nls!vs/editor/contrib/suggest/browser/suggestWidget","vs/nls!vs/editor/contrib/toggleTabFocusMode/common/toggleTabFocusMode","vs/nls!vs/editor/contrib/toggleWordWrap/common/toggleWordWrap","vs/nls!vs/editor/contrib/zoneWidget/browser/peekViewWidget","vs/nls!vs/languages/html/common/html.contribution","vs/nls!vs/platform/actions/browser/menuItemActionItem","vs/nls!vs/platform/configuration/common/configurationRegistry","vs/nls!vs/platform/extensions/common/abstractExtensionService","vs/nls!vs/platform/extensions/common/extensionsRegistry","vs/nls!vs/platform/jsonschemas/common/jsonContributionRegistry","vs/nls!vs/platform/keybinding/browser/keybindingServiceImpl","vs/nls!vs/platform/message/common/message","vs/platform/contextview/browser/contextMenuHandler","vs/editor/common/modes/languageSelector","vs/css!vs/base/browser/ui/actionbar/actionbar","vs/editor/common/modes/linkComputer","vs/editor/common/services/abstractCodeEditorService","vs/editor/browser/services/codeEditorServiceImpl","vs/css!vs/base/browser/ui/aria/aria","vs/css!vs/base/browser/ui/checkbox/checkbox","vs/css!vs/base/browser/ui/contextview/contextview","vs/css!vs/base/browser/ui/countBadge/countBadge","vs/editor/common/modes/supports/characterPair","vs/editor/contrib/smartSelect/common/tokenSelectionSupport","vs/editor/common/modes/supports/inplaceReplaceSupport","vs/css!vs/base/browser/ui/fileLabel/fileLabel","vs/platform/contextview/browser/contextMenuService","vs/editor/common/modes/supports/electricCharacter","vs/css!vs/base/browser/ui/findinput/findInput","vs/platform/event/common/eventService","vs/css!vs/base/browser/ui/inputbox/inputBox","vs/editor/common/modes/textToHtmlTokenizer","vs/editor/common/services/bulkEdit","vs/editor/common/view/overviewZoneManager","vs/css!vs/base/browser/ui/leftRightWidget/leftRightWidget","vs/editor/browser/viewParts/lines/rangeUtil","vs/editor/common/commonCodeEditor","vs/editor/common/view/viewContext","vs/platform/actions/browser/menuItemActionItem","vs/platform/actions/common/resourceContextKey","vs/platform/actions/browser/menuService","vs/editor/common/viewLayout/editorLayoutProvider","vs/css!vs/base/browser/ui/list/list","vs/platform/markers/common/markerService","vs/editor/common/viewLayout/viewLinesViewportData","vs/editor/common/viewLayout/whitespaceComputer","vs/editor/common/viewLayout/verticalObjects","vs/editor/common/viewLayout/linesLayout","vs/editor/common/viewModel/filteredLineTokens","vs/editor/common/services/languagesRegistry","vs/editor/contrib/iPadShowKeyboard/browser/iPadShowKeyboard","vs/css!vs/base/browser/ui/menu/menu","vs/editor/contrib/quickOpen/browser/gotoLine","vs/editor/contrib/quickOpen/browser/quickCommand","vs/languages/handlebars/common/handlebars.contribution","vs/languages/php/common/php.contribution","vs/languages/razor/common/razor.contribution","vs/editor/common/model/mirrorModel2","vs/editor/browser/editor.all","vs/editor/common/viewModel/characterHardWrappingLineMapper","vs/css!vs/base/browser/ui/sash/sash","vs/css!vs/base/browser/ui/scrollbar/media/scrollbars","vs/editor/browser/controller/keyboardHandler","vs/editor/browser/view/viewOverlays","vs/editor/browser/viewParts/lines/viewLines","vs/editor/browser/viewParts/viewCursors/viewCursor","vs/editor/browser/viewParts/viewCursors/viewCursors","vs/css!vs/base/parts/quickopen/browser/quickopen","vs/editor/browser/viewParts/currentLineHighlight/currentLineHighlight","vs/editor/common/services/modeServiceImpl","vs/languages/html/common/html.contribution","vs/languages/languages.main","vs/platform/configuration/common/model","vs/platform/configuration/common/configurationService","vs/platform/extensions/common/abstractExtensionService","vs/editor/browser/viewParts/decorations/decorations","vs/css!vs/base/parts/tree/browser/tree","vs/editor/browser/viewParts/lineNumbers/lineNumbers","vs/editor/browser/viewParts/linesDecorations/linesDecorations","vs/editor/browser/viewParts/selections/selections","vs/css!vs/editor/browser/standalone/media/standalone-tokens","vs/css!vs/editor/browser/viewParts/contentWidgets/contentWidgets","vs/editor/common/services/modelServiceImpl","vs/editor/contrib/carretOperations/common/carretOperations","vs/editor/contrib/clipboard/browser/clipboard","vs/editor/contrib/codelens/common/codelens","vs/editor/contrib/codelens/browser/codelens","vs/editor/contrib/comment/common/comment","vs/editor/contrib/contextmenu/browser/contextmenu","vs/editor/contrib/find/common/findController","vs/editor/contrib/find/browser/find","vs/editor/contrib/folding/browser/folding","vs/editor/contrib/format/common/format","vs/editor/contrib/format/common/formatActions","vs/editor/contrib/goToDeclaration/common/goToDeclaration","vs/editor/contrib/hover/common/hover","vs/editor/contrib/hover/browser/modesContentHover","vs/editor/contrib/hover/browser/hover","vs/editor/contrib/inPlaceReplace/common/inPlaceReplace","vs/editor/contrib/linesOperations/common/linesOperations","vs/editor/contrib/links/browser/links","vs/editor/contrib/multicursor/common/multicursor","vs/editor/common/viewModel/viewModelCursors","vs/editor/contrib/parameterHints/browser/parameterHintsWidget","vs/editor/contrib/parameterHints/browser/parameterHints","vs/editor/common/viewModel/viewModelDecorations","vs/editor/contrib/gotoError/browser/gotoError","vs/editor/contrib/quickFix/browser/quickFixModel","vs/editor/contrib/quickFix/browser/quickFix","vs/editor/contrib/quickOpen/browser/gotoLine.contribution","vs/editor/contrib/quickOpen/browser/quickCommand.contribution","vs/editor/contrib/carretOperations/common/moveCarretCommand","vs/editor/contrib/outlineMarker/browser/outlineMarker","vs/editor/contrib/quickOpen/browser/quickOutline","vs/editor/contrib/quickOpen/browser/quickOutline.contribution","vs/editor/contrib/referenceSearch/common/referenceSearch","vs/editor/contrib/rename/common/rename","vs/editor/contrib/rename/browser/rename","vs/editor/contrib/smartSelect/common/jumpToBracket","vs/editor/contrib/smartSelect/common/smartSelect","vs/editor/contrib/find/common/findDecorations","vs/editor/contrib/defineKeybinding/browser/defineKeybinding","vs/editor/contrib/find/common/replaceAllCommand","vs/editor/contrib/suggest/browser/suggestModel","vs/editor/contrib/suggest/browser/suggestWidget","vs/editor/contrib/suggest/browser/suggest","vs/editor/contrib/folding/common/indentFoldStrategy","vs/editor/contrib/accessibility/browser/accessibility","vs/editor/contrib/toggleWordWrap/common/toggleWordWrap","vs/editor/contrib/wordHighlighter/common/wordHighlighter","vs/platform/contextview/browser/contextViewService","vs/platform/request/common/baseRequestService","vs/editor/contrib/format/common/formatCommand","vs/platform/theme/common/themes","vs/editor/browser/viewParts/overviewRuler/decorationsOverviewRuler","vs/editor/browser/view/viewImpl","vs/editor/contrib/inPlaceReplace/common/inPlaceReplaceCommand","vs/editor/contrib/indentation/common/indentationCommands","vs/editor/contrib/linesOperations/common/copyLinesCommand","vs/editor/contrib/linesOperations/common/deleteLinesCommand","vs/editor/contrib/linesOperations/common/moveLinesCommand","vs/editor/common/languages.common","vs/editor/common/services/compatWorkerServiceMain","vs/editor/contrib/linesOperations/common/sortLinesCommand","vs/editor/contrib/snippet/browser/snippet","vs/editor/contrib/goToDeclaration/browser/goToDeclaration","vs/editor/contrib/referenceSearch/browser/referenceSearch","vs/platform/workspace/common/baseWorkspaceContextService","vs/nls!vs/base/browser/ui/actionbar/actionbar","vs/css!vs/editor/browser/viewParts/currentLineHighlight/currentLineHighlight","vs/editor/browser/standalone/standaloneEditor","vs/editor/browser/standalone/standaloneLanguages","vs/workbench/services/quickopen/common/quickOpenService","vs/base/common/winjs.base.raw","vs/base/common/marked/raw.marked","vs/editor/edcore.main"];
var __M = function(deps) {
  var result = [];
  for (var i = 0, len = deps.length; i < len; i++) {
    result[i] = __m[deps[i]];
  }
  return result;
};
define(__m[149], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var hasDifferentOriginAncestorFlag = false;
    var sameOriginWindowChainCache = null;
    function getParentWindowIfSameOrigin(w) {
        if (!w.parent || w.parent === w) {
            return null;
        }
        // Cannot really tell if we have access to the parent window unless we try to access something in it
        try {
            var location_1 = w.location;
            var parentLocation = w.parent.location;
            if (location_1.protocol !== parentLocation.protocol || location_1.hostname !== parentLocation.hostname || location_1.port !== parentLocation.port) {
                hasDifferentOriginAncestorFlag = true;
                return null;
            }
        }
        catch (e) {
            hasDifferentOriginAncestorFlag = true;
            return null;
        }
        return w.parent;
    }
    function findIframeElementInParentWindow(parentWindow, childWindow) {
        var parentWindowIframes = parentWindow.document.getElementsByTagName('iframe');
        var iframe;
        for (var i = 0, len = parentWindowIframes.length; i < len; i++) {
            iframe = parentWindowIframes[i];
            if (iframe.contentWindow === childWindow) {
                return iframe;
            }
        }
        return null;
    }
    var IframeUtils = (function () {
        function IframeUtils() {
        }
        /**
         * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).
         * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.
         * To distinguish if at one point the current execution environment is running inside a window with a different origin, see hasDifferentOriginAncestor()
         */
        IframeUtils.getSameOriginWindowChain = function () {
            if (!sameOriginWindowChainCache) {
                sameOriginWindowChainCache = [];
                var w = window, parent_1;
                do {
                    parent_1 = getParentWindowIfSameOrigin(w);
                    if (parent_1) {
                        sameOriginWindowChainCache.push({
                            window: w,
                            iframeElement: findIframeElementInParentWindow(parent_1, w)
                        });
                    }
                    else {
                        sameOriginWindowChainCache.push({
                            window: w,
                            iframeElement: null
                        });
                    }
                    w = parent_1;
                } while (w);
            }
            return sameOriginWindowChainCache.slice(0);
        };
        /**
         * Returns true if the current execution environment is chained in a list of iframes which at one point ends in a window with a different origin.
         * Returns false if the current execution environment is not running inside an iframe or if the entire chain of iframes have the same origin.
         */
        IframeUtils.hasDifferentOriginAncestor = function () {
            if (!sameOriginWindowChainCache) {
                this.getSameOriginWindowChain();
            }
            return hasDifferentOriginAncestorFlag;
        };
        /**
         * Returns the position of `childWindow` relative to `ancestorWindow`
         */
        IframeUtils.getPositionOfChildWindowRelativeToAncestorWindow = function (childWindow, ancestorWindow) {
            if (!ancestorWindow || childWindow === ancestorWindow) {
                return {
                    top: 0,
                    left: 0
                };
            }
            var top = 0, left = 0;
            var windowChain = this.getSameOriginWindowChain();
            for (var i = 0; i < windowChain.length; i++) {
                var windowChainEl = windowChain[i];
                if (windowChainEl.window === ancestorWindow) {
                    break;
                }
                if (!windowChainEl.iframeElement) {
                    break;
                }
                var boundingRect = windowChainEl.iframeElement.getBoundingClientRect();
                top += boundingRect.top;
                left += boundingRect.left;
            }
            return {
                top: top,
                left: left
            };
        };
        return IframeUtils;
    }());
    exports.IframeUtils = IframeUtils;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[258], __M([0,1]), function (require, exports) {
    "use strict";
    /**
     * Returns the intersection between two ranges as a range itself.
     * Returns `null` if the intersection is empty.
     */
    function intersect(one, other) {
        if (one.start >= other.end || other.start >= one.end) {
            return null;
        }
        var start = Math.max(one.start, other.start);
        var end = Math.min(one.end, other.end);
        if (end - start <= 0) {
            return null;
        }
        return { start: start, end: end };
    }
    exports.intersect = intersect;
    function isEmpty(range) {
        return range.end - range.start <= 0;
    }
    exports.isEmpty = isEmpty;
    function relativeComplement(one, other) {
        var result = [];
        var first = { start: one.start, end: Math.min(other.start, one.end) };
        var second = { start: Math.max(other.end, one.start), end: one.end };
        if (!isEmpty(first)) {
            result.push(first);
        }
        if (!isEmpty(second)) {
            result.push(second);
        }
        return result;
    }
    exports.relativeComplement = relativeComplement;
    function each(range, fn) {
        for (var i = range.start; i < range.end; i++) {
            fn(i);
        }
    }
    exports.each = each;
    /**
     * Returns the intersection between a ranged group and a range.
     * Returns `[]` if the intersection is empty.
     */
    function groupIntersect(range, groups) {
        var result = [];
        for (var _i = 0, groups_1 = groups; _i < groups_1.length; _i++) {
            var r = groups_1[_i];
            if (range.start >= r.range.end) {
                continue;
            }
            if (range.end < r.range.start) {
                break;
            }
            var intersection = intersect(range, r.range);
            if (!intersection) {
                continue;
            }
            result.push({
                range: intersection,
                size: r.size
            });
        }
        return result;
    }
    exports.groupIntersect = groupIntersect;
    /**
     * Shifts a range by that `much`.
     */
    function shift(_a, much) {
        var start = _a.start, end = _a.end;
        return { start: start + much, end: end + much };
    }
    /**
     * Consolidates a collection of ranged groups.
     *
     * Consolidation is the process of merging consecutive ranged groups
     * that share the same `size`.
     */
    function consolidate(groups) {
        var result = [];
        var previousGroup = null;
        for (var _i = 0, groups_2 = groups; _i < groups_2.length; _i++) {
            var group = groups_2[_i];
            var start = group.range.start;
            var end = group.range.end;
            var size = group.size;
            if (previousGroup && size === previousGroup.size) {
                previousGroup.range.end = end;
                continue;
            }
            previousGroup = { range: { start: start, end: end }, size: size };
            result.push(previousGroup);
        }
        return result;
    }
    exports.consolidate = consolidate;
    /**
     * Concatenates several collections of ranged groups into a single
     * collection.
     */
    function concat() {
        var groups = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            groups[_i - 0] = arguments[_i];
        }
        return consolidate(groups.reduce(function (r, g) { return r.concat(g); }, []));
    }
    var RangeMap = (function () {
        function RangeMap() {
            this.groups = [];
            this._size = 0;
        }
        RangeMap.prototype.splice = function (index, deleteCount) {
            var items = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                items[_i - 2] = arguments[_i];
            }
            var diff = items.length - deleteCount;
            var before = groupIntersect({ start: 0, end: index }, this.groups);
            var after = groupIntersect({ start: index + deleteCount, end: Number.POSITIVE_INFINITY }, this.groups)
                .map(function (g) { return ({ range: shift(g.range, diff), size: g.size }); });
            var middle = items.map(function (item, i) { return ({
                range: { start: index + i, end: index + i + 1 },
                size: item.size
            }); });
            this.groups = concat(before, middle, after);
            this._size = this.groups.reduce(function (t, g) { return t + (g.size * (g.range.end - g.range.start)); }, 0);
        };
        Object.defineProperty(RangeMap.prototype, "count", {
            /**
             * Returns the number of items in the range map.
             */
            get: function () {
                var len = this.groups.length;
                if (!len) {
                    return 0;
                }
                return this.groups[len - 1].range.end;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RangeMap.prototype, "size", {
            /**
             * Returns the sum of the sizes of all items in the range map.
             */
            get: function () {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns the index of the item at the given position.
         */
        RangeMap.prototype.indexAt = function (position) {
            if (position < 0) {
                return -1;
            }
            var index = 0;
            var size = 0;
            for (var _i = 0, _a = this.groups; _i < _a.length; _i++) {
                var group = _a[_i];
                var count = group.range.end - group.range.start;
                var newSize = size + (count * group.size);
                if (position < newSize) {
                    return index + Math.floor((position - size) / group.size);
                }
                index += count;
                size = newSize;
            }
            return index;
        };
        /**
         * Returns the index of the item right after the item at the
         * index of the given position.
         */
        RangeMap.prototype.indexAfter = function (position) {
            return Math.min(this.indexAt(position) + 1, this.count);
        };
        /**
         * Returns the start position of the item at the given index.
         */
        RangeMap.prototype.positionAt = function (index) {
            if (index < 0) {
                return -1;
            }
            var position = 0;
            var count = 0;
            for (var _i = 0, _a = this.groups; _i < _a.length; _i++) {
                var group = _a[_i];
                var groupCount = group.range.end - group.range.start;
                var newCount = count + groupCount;
                if (index < newCount) {
                    return position + ((index - count) * group.size);
                }
                position += groupCount * group.size;
                count = newCount;
            }
            return -1;
        };
        RangeMap.prototype.dispose = function () {
            this.groups = null;
        };
        return RangeMap;
    }());
    exports.RangeMap = RangeMap;
});

define(__m[41], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    (function (ScrollbarVisibility) {
        ScrollbarVisibility[ScrollbarVisibility["Auto"] = 1] = "Auto";
        ScrollbarVisibility[ScrollbarVisibility["Hidden"] = 2] = "Hidden";
        ScrollbarVisibility[ScrollbarVisibility["Visible"] = 3] = "Visible";
    })(exports.ScrollbarVisibility || (exports.ScrollbarVisibility = {}));
    var ScrollbarVisibility = exports.ScrollbarVisibility;
});

define(__m[135], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The minimal size of the slider (such that it can still be clickable) -- it is artificially enlarged.
     */
    var MINIMUM_SLIDER_SIZE = 20;
    var ScrollbarState = (function () {
        function ScrollbarState(arrowSize, scrollbarSize, oppositeScrollbarSize) {
            this._scrollbarSize = Math.round(scrollbarSize);
            this._oppositeScrollbarSize = Math.round(oppositeScrollbarSize);
            this._arrowSize = Math.round(arrowSize);
            this._visibleSize = 0;
            this._scrollSize = 0;
            this._scrollPosition = 0;
            this._computedAvailableSize = 0;
            this._computedRepresentableSize = 0;
            this._computedRatio = 0.1;
            this._computedIsNeeded = false;
            this._computedSliderSize = 0;
            this._computedSliderPosition = 0;
            this._refreshComputedValues();
        }
        ScrollbarState.prototype.setVisibleSize = function (visibleSize) {
            var iVisibleSize = Math.round(visibleSize);
            if (this._visibleSize !== iVisibleSize) {
                this._visibleSize = iVisibleSize;
                this._refreshComputedValues();
                return true;
            }
            return false;
        };
        ScrollbarState.prototype.setScrollSize = function (scrollSize) {
            var iScrollSize = Math.round(scrollSize);
            if (this._scrollSize !== iScrollSize) {
                this._scrollSize = iScrollSize;
                this._refreshComputedValues();
                return true;
            }
            return false;
        };
        ScrollbarState.prototype.setScrollPosition = function (scrollPosition) {
            var iScrollPosition = Math.round(scrollPosition);
            if (this._scrollPosition !== iScrollPosition) {
                this._scrollPosition = iScrollPosition;
                this._refreshComputedValues();
                return true;
            }
            return false;
        };
        ScrollbarState.prototype._refreshComputedValues = function () {
            var oppositeScrollbarSize = this._oppositeScrollbarSize;
            var arrowSize = this._arrowSize;
            var visibleSize = this._visibleSize;
            var scrollSize = this._scrollSize;
            var scrollPosition = this._scrollPosition;
            var computedAvailableSize = Math.max(0, visibleSize - oppositeScrollbarSize);
            var computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * arrowSize);
            var computedRatio = scrollSize > 0 ? (computedRepresentableSize / scrollSize) : 0;
            var computedIsNeeded = (scrollSize > visibleSize);
            var computedSliderSize;
            var computedSliderPosition;
            if (!computedIsNeeded) {
                computedSliderSize = computedRepresentableSize;
                computedSliderPosition = 0;
            }
            else {
                computedSliderSize = Math.floor(visibleSize * computedRatio);
                computedSliderPosition = Math.floor(scrollPosition * computedRatio);
                if (computedSliderSize < MINIMUM_SLIDER_SIZE) {
                    // We must artificially increase the size of the slider, since the slider would be too small otherwise
                    // The effort is to keep the slider centered around the original position, but we must take into
                    // account the cases when the slider is too close to the top or too close to the bottom
                    var sliderArtificialOffset = (MINIMUM_SLIDER_SIZE - computedSliderSize) / 2;
                    computedSliderSize = MINIMUM_SLIDER_SIZE;
                    computedSliderPosition -= sliderArtificialOffset;
                    if (computedSliderPosition + computedSliderSize > computedRepresentableSize) {
                        // Slider is too close to the bottom, so we glue it to the bottom
                        computedSliderPosition = computedRepresentableSize - computedSliderSize;
                    }
                    if (computedSliderPosition < 0) {
                        // Slider is too close to the top, so we glue it to the top
                        computedSliderPosition = 0;
                    }
                }
            }
            this._computedAvailableSize = Math.round(computedAvailableSize);
            this._computedRepresentableSize = Math.round(computedRepresentableSize);
            this._computedRatio = computedRatio;
            this._computedIsNeeded = computedIsNeeded;
            this._computedSliderSize = Math.round(computedSliderSize);
            this._computedSliderPosition = Math.round(computedSliderPosition);
        };
        ScrollbarState.prototype.getArrowSize = function () {
            return this._arrowSize;
        };
        ScrollbarState.prototype.getRectangleLargeSize = function () {
            return this._computedAvailableSize;
        };
        ScrollbarState.prototype.getRectangleSmallSize = function () {
            return this._scrollbarSize;
        };
        ScrollbarState.prototype.isNeeded = function () {
            return this._computedIsNeeded;
        };
        ScrollbarState.prototype.getSliderSize = function () {
            return this._computedSliderSize;
        };
        ScrollbarState.prototype.getSliderPosition = function () {
            return this._computedSliderPosition;
        };
        ScrollbarState.prototype.convertSliderPositionToScrollPosition = function (desiredSliderPosition) {
            return desiredSliderPosition / this._computedRatio;
        };
        ScrollbarState.prototype.validateScrollPosition = function (desiredScrollPosition) {
            desiredScrollPosition = Math.round(desiredScrollPosition);
            desiredScrollPosition = Math.max(desiredScrollPosition, 0);
            desiredScrollPosition = Math.min(desiredScrollPosition, this._scrollSize - this._visibleSize);
            return desiredScrollPosition;
        };
        return ScrollbarState;
    }());
    exports.ScrollbarState = ScrollbarState;
});

define(__m[37], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Returns the last element of an array.
     * @param array The array.
     * @param n Which element from the end (default ist zero).
     */
    function tail(array, n) {
        if (n === void 0) { n = 0; }
        return array[array.length - (1 + n)];
    }
    exports.tail = tail;
    /**
     * Iterates the provided array and allows to remove
     * elements while iterating.
     */
    function forEach(array, callback) {
        for (var i = 0, len = array.length; i < len; i++) {
            callback(array[i], function () {
                array.splice(i, 1);
                i--;
                len--;
            });
        }
    }
    exports.forEach = forEach;
    function equals(one, other, itemEquals) {
        if (itemEquals === void 0) { itemEquals = function (a, b) { return a === b; }; }
        if (one.length !== other.length) {
            return false;
        }
        for (var i = 0, len = one.length; i < len; i++) {
            if (!itemEquals(one[i], other[i])) {
                return false;
            }
        }
        return true;
    }
    exports.equals = equals;
    function binarySearch(array, key, comparator) {
        var low = 0, high = array.length - 1;
        while (low <= high) {
            var mid = ((low + high) / 2) | 0;
            var comp = comparator(array[mid], key);
            if (comp < 0) {
                low = mid + 1;
            }
            else if (comp > 0) {
                high = mid - 1;
            }
            else {
                return mid;
            }
        }
        return -(low + 1);
    }
    exports.binarySearch = binarySearch;
    /**
     * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false
     * are located before all elements where p(x) is true.
     * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.
     */
    function findFirst(array, p) {
        var low = 0, high = array.length;
        if (high === 0) {
            return 0; // no children
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (p(array[mid])) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        return low;
    }
    exports.findFirst = findFirst;
    function merge(arrays, hashFn) {
        var result = new Array();
        if (!hashFn) {
            for (var i = 0, len = arrays.length; i < len; i++) {
                result.push.apply(result, arrays[i]);
            }
        }
        else {
            var map = {};
            for (var i = 0; i < arrays.length; i++) {
                for (var j = 0; j < arrays[i].length; j++) {
                    var element = arrays[i][j], hash = hashFn(element);
                    if (!map.hasOwnProperty(hash)) {
                        map[hash] = true;
                        result.push(element);
                    }
                }
            }
        }
        return result;
    }
    exports.merge = merge;
    /**
     * @returns a new array with all undefined or null values removed. The original array is not modified at all.
     */
    function coalesce(array) {
        if (!array) {
            return array;
        }
        return array.filter(function (e) { return !!e; });
    }
    exports.coalesce = coalesce;
    /**
     * @returns true if the given item is contained in the array.
     */
    function contains(array, item) {
        return array.indexOf(item) >= 0;
    }
    exports.contains = contains;
    /**
     * Swaps the elements in the array for the provided positions.
     */
    function swap(array, pos1, pos2) {
        var element1 = array[pos1];
        var element2 = array[pos2];
        array[pos1] = element2;
        array[pos2] = element1;
    }
    exports.swap = swap;
    /**
     * Moves the element in the array for the provided positions.
     */
    function move(array, from, to) {
        array.splice(to, 0, array.splice(from, 1)[0]);
    }
    exports.move = move;
    /**
     * @returns {{false}} if the provided object is an array
     * 	and not empty.
     */
    function isFalsyOrEmpty(obj) {
        return !Array.isArray(obj) || obj.length === 0;
    }
    exports.isFalsyOrEmpty = isFalsyOrEmpty;
    /**
     * Removes duplicates from the given array. The optional keyFn allows to specify
     * how elements are checked for equalness by returning a unique string for each.
     */
    function distinct(array, keyFn) {
        if (!keyFn) {
            return array.filter(function (element, position) {
                return array.indexOf(element) === position;
            });
        }
        var seen = Object.create(null);
        return array.filter(function (elem) {
            var key = keyFn(elem);
            if (seen[key]) {
                return false;
            }
            seen[key] = true;
            return true;
        });
    }
    exports.distinct = distinct;
    function uniqueFilter(keyFn) {
        var seen = Object.create(null);
        return function (element) {
            var key = keyFn(element);
            if (seen[key]) {
                return false;
            }
            seen[key] = true;
            return true;
        };
    }
    exports.uniqueFilter = uniqueFilter;
    function firstIndex(array, fn) {
        for (var i = 0; i < array.length; i++) {
            var element = array[i];
            if (fn(element)) {
                return i;
            }
        }
        return -1;
    }
    exports.firstIndex = firstIndex;
    function first(array, fn, notFoundValue) {
        if (notFoundValue === void 0) { notFoundValue = null; }
        var index = firstIndex(array, fn);
        return index < 0 ? notFoundValue : array[index];
    }
    exports.first = first;
    function commonPrefixLength(one, other, equals) {
        if (equals === void 0) { equals = function (a, b) { return a === b; }; }
        var result = 0;
        for (var i = 0, len = Math.min(one.length, other.length); i < len && equals(one[i], other[i]); i++) {
            result++;
        }
        return result;
    }
    exports.commonPrefixLength = commonPrefixLength;
    function flatten(arr) {
        return arr.reduce(function (r, v) { return r.concat(v); }, []);
    }
    exports.flatten = flatten;
    function range(to, from) {
        if (from === void 0) { from = 0; }
        var result = [];
        for (var i = from; i < to; i++) {
            result.push(i);
        }
        return result;
    }
    exports.range = range;
    function fill(num, valueFn, arr) {
        if (arr === void 0) { arr = []; }
        for (var i = 0; i < num; i++) {
            arr[i] = valueFn();
        }
        return arr;
    }
    exports.fill = fill;
    function index(array, indexer) {
        var result = Object.create(null);
        array.forEach(function (t) { return result[indexer(t)] = t; });
        return result;
    }
    exports.index = index;
});

define(__m[47], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Throws an error with the provided message if the provided value does not evaluate to a true Javascript value.
     */
    function ok(value, message) {
        if (!value || value === null) {
            throw new Error(message ? 'Assertion failed (' + message + ')' : 'Assertion Failed');
        }
    }
    exports.ok = ok;
});

define(__m[48], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function createStringDictionary() {
        return Object.create(null);
    }
    exports.createStringDictionary = createStringDictionary;
    function createNumberDictionary() {
        return Object.create(null);
    }
    exports.createNumberDictionary = createNumberDictionary;
    function lookup(from, what, alternate) {
        if (alternate === void 0) { alternate = null; }
        var key = String(what);
        if (contains(from, key)) {
            return from[key];
        }
        return alternate;
    }
    exports.lookup = lookup;
    function lookupOrInsert(from, stringOrNumber, alternate) {
        var key = String(stringOrNumber);
        if (contains(from, key)) {
            return from[key];
        }
        else {
            if (typeof alternate === 'function') {
                alternate = alternate();
            }
            from[key] = alternate;
            return alternate;
        }
    }
    exports.lookupOrInsert = lookupOrInsert;
    function insert(into, data, hashFn) {
        into[hashFn(data)] = data;
    }
    exports.insert = insert;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function contains(from, what) {
        return hasOwnProperty.call(from, what);
    }
    exports.contains = contains;
    function values(from) {
        var result = [];
        for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
                result.push(from[key]);
            }
        }
        return result;
    }
    exports.values = values;
    function forEach(from, callback) {
        for (var key in from) {
            if (hasOwnProperty.call(from, key)) {
                var result = callback({ key: key, value: from[key] }, function () {
                    delete from[key];
                });
                if (result === false) {
                    return;
                }
            }
        }
    }
    exports.forEach = forEach;
    function remove(from, key) {
        if (!hasOwnProperty.call(from, key)) {
            return false;
        }
        delete from[key];
        return true;
    }
    exports.remove = remove;
    /**
     * Groups the collection into a dictionary based on the provided
     * group function.
     */
    function groupBy(data, groupFn) {
        var result = createStringDictionary();
        data.forEach(function (element) { return lookupOrInsert(result, groupFn(element), []).push(element); });
        return result;
    }
    exports.groupBy = groupBy;
});

define(__m[249], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.DifferenceType = {
        Add: 0,
        Remove: 1,
        Change: 2
    };
    /**
     * Represents information about a specific difference between two sequences.
     */
    var DiffChange = (function () {
        /**
         * Constructs a new DiffChange with the given sequence information
         * and content.
         */
        function DiffChange(originalStart, originalLength, modifiedStart, modifiedLength) {
            //Debug.Assert(originalLength > 0 || modifiedLength > 0, "originalLength and modifiedLength cannot both be <= 0");
            this.originalStart = originalStart;
            this.originalLength = originalLength;
            this.modifiedStart = modifiedStart;
            this.modifiedLength = modifiedLength;
        }
        /**
         * The type of difference.
         */
        DiffChange.prototype.getChangeType = function () {
            if (this.originalLength === 0) {
                return exports.DifferenceType.Add;
            }
            else if (this.modifiedLength === 0) {
                return exports.DifferenceType.Remove;
            }
            else {
                return exports.DifferenceType.Change;
            }
        };
        /**
         * The end point (exclusive) of the change in the original sequence.
         */
        DiffChange.prototype.getOriginalEnd = function () {
            return this.originalStart + this.originalLength;
        };
        /**
         * The end point (exclusive) of the change in the modified sequence.
         */
        DiffChange.prototype.getModifiedEnd = function () {
            return this.modifiedStart + this.modifiedLength;
        };
        return DiffChange;
    }());
    exports.DiffChange = DiffChange;
});

define(__m[150], __M([0,1,249]), function (require, exports, diffChange_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    //
    // The code below has been ported from a C# implementation in VS
    //
    var Debug = (function () {
        function Debug() {
        }
        Debug.Assert = function (condition, message) {
            if (!condition) {
                throw new Error(message);
            }
        };
        return Debug;
    }());
    exports.Debug = Debug;
    var MyArray = (function () {
        function MyArray() {
        }
        /**
         * Copies a range of elements from an Array starting at the specified source index and pastes
         * them to another Array starting at the specified destination index. The length and the indexes
         * are specified as 64-bit integers.
         * sourceArray:
         *		The Array that contains the data to copy.
         * sourceIndex:
         *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
         * destinationArray:
         *		The Array that receives the data.
         * destinationIndex:
         *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
         * length:
         *		A 64-bit integer that represents the number of elements to copy.
         */
        MyArray.Copy = function (sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
            for (var i = 0; i < length; i++) {
                destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
            }
        };
        return MyArray;
    }());
    exports.MyArray = MyArray;
    //*****************************************************************************
    // LcsDiff.cs
    //
    // An implementation of the difference algorithm described in
    // "An O(ND) Difference Algorithm and its letiations" by Eugene W. Myers
    //
    // Copyright (C) 2008 Microsoft Corporation @minifier_do_not_preserve
    //*****************************************************************************
    // Our total memory usage for storing history is (worst-case):
    // 2 * [(MaxDifferencesHistory + 1) * (MaxDifferencesHistory + 1) - 1] * sizeof(int)
    // 2 * [1448*1448 - 1] * 4 = 16773624 = 16MB
    var MaxDifferencesHistory = 1447;
    //let MaxDifferencesHistory = 100;
    /**
     * A utility class which helps to create the set of DiffChanges from
     * a difference operation. This class accepts original DiffElements and
     * modified DiffElements that are involved in a particular change. The
     * MarktNextChange() method can be called to mark the separation between
     * distinct changes. At the end, the Changes property can be called to retrieve
     * the constructed changes.
     */
    var DiffChangeHelper = (function () {
        /**
         * Constructs a new DiffChangeHelper for the given DiffSequences.
         */
        function DiffChangeHelper() {
            this.m_changes = [];
            this.m_originalStart = Number.MAX_VALUE;
            this.m_modifiedStart = Number.MAX_VALUE;
            this.m_originalCount = 0;
            this.m_modifiedCount = 0;
        }
        /**
         * Marks the beginning of the next change in the set of differences.
         */
        DiffChangeHelper.prototype.MarkNextChange = function () {
            // Only add to the list if there is something to add
            if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
                // Add the new change to our list
                this.m_changes.push(new diffChange_1.DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
            }
            // Reset for the next change
            this.m_originalCount = 0;
            this.m_modifiedCount = 0;
            this.m_originalStart = Number.MAX_VALUE;
            this.m_modifiedStart = Number.MAX_VALUE;
        };
        /**
         * Adds the original element at the given position to the elements
         * affected by the current change. The modified index gives context
         * to the change position with respect to the original sequence.
         * @param originalIndex The index of the original element to add.
         * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
         */
        DiffChangeHelper.prototype.AddOriginalElement = function (originalIndex, modifiedIndex) {
            // The 'true' start index is the smallest of the ones we've seen
            this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
            this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
            this.m_originalCount++;
        };
        /**
         * Adds the modified element at the given position to the elements
         * affected by the current change. The original index gives context
         * to the change position with respect to the modified sequence.
         * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
         * @param modifiedIndex The index of the modified element to add.
         */
        DiffChangeHelper.prototype.AddModifiedElement = function (originalIndex, modifiedIndex) {
            // The 'true' start index is the smallest of the ones we've seen
            this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
            this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
            this.m_modifiedCount++;
        };
        /**
         * Retrieves all of the changes marked by the class.
         */
        DiffChangeHelper.prototype.getChanges = function () {
            if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
                // Finish up on whatever is left
                this.MarkNextChange();
            }
            return this.m_changes;
        };
        DiffChangeHelper.prototype.getReverseChanges = function () {
            /// <summary>
            /// Retrieves all of the changes marked by the class in the reverse order
            /// </summary>
            if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
                // Finish up on whatever is left
                this.MarkNextChange();
            }
            this.m_changes.reverse();
            return this.m_changes;
        };
        return DiffChangeHelper;
    }());
    /**
     * An implementation of the difference algorithm described in
     * "An O(ND) Difference Algorithm and its letiations" by Eugene W. Myers
     */
    var LcsDiff = (function () {
        /**
         * Constructs the DiffFinder
         */
        function LcsDiff(originalSequence, newSequence, continueProcessingPredicate) {
            if (continueProcessingPredicate === void 0) { continueProcessingPredicate = null; }
            this.OriginalSequence = originalSequence;
            this.ModifiedSequence = newSequence;
            this.ContinueProcessingPredicate = continueProcessingPredicate;
            this.m_originalIds = [];
            this.m_modifiedIds = [];
            this.m_forwardHistory = [];
            this.m_reverseHistory = [];
            this.ComputeUniqueIdentifiers();
        }
        LcsDiff.prototype.ComputeUniqueIdentifiers = function () {
            var originalSequenceLength = this.OriginalSequence.getLength();
            var modifiedSequenceLength = this.ModifiedSequence.getLength();
            this.m_originalIds = new Array(originalSequenceLength);
            this.m_modifiedIds = new Array(modifiedSequenceLength);
            // Create a new hash table for unique elements from the original
            // sequence.
            var hashTable = {};
            var currentUniqueId = 1;
            var i;
            // Fill up the hash table for unique elements
            for (i = 0; i < originalSequenceLength; i++) {
                var originalElementHash = this.OriginalSequence.getElementHash(i);
                if (!hashTable.hasOwnProperty(originalElementHash)) {
                    // No entry in the hashtable so this is a new unique element.
                    // Assign the element a new unique identifier and add it to the
                    // hash table
                    this.m_originalIds[i] = currentUniqueId++;
                    hashTable[originalElementHash] = this.m_originalIds[i];
                }
                else {
                    this.m_originalIds[i] = hashTable[originalElementHash];
                }
            }
            // Now match up modified elements
            for (i = 0; i < modifiedSequenceLength; i++) {
                var modifiedElementHash = this.ModifiedSequence.getElementHash(i);
                if (!hashTable.hasOwnProperty(modifiedElementHash)) {
                    this.m_modifiedIds[i] = currentUniqueId++;
                    hashTable[modifiedElementHash] = this.m_modifiedIds[i];
                }
                else {
                    this.m_modifiedIds[i] = hashTable[modifiedElementHash];
                }
            }
        };
        LcsDiff.prototype.ElementsAreEqual = function (originalIndex, newIndex) {
            return this.m_originalIds[originalIndex] === this.m_modifiedIds[newIndex];
        };
        LcsDiff.prototype.ComputeDiff = function () {
            return this._ComputeDiff(0, this.OriginalSequence.getLength() - 1, 0, this.ModifiedSequence.getLength() - 1);
        };
        /**
         * Computes the differences between the original and modified input
         * sequences on the bounded range.
         * @returns An array of the differences between the two input sequences.
         */
        LcsDiff.prototype._ComputeDiff = function (originalStart, originalEnd, modifiedStart, modifiedEnd) {
            var quitEarlyArr = [false];
            return this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
        };
        /**
         * Private helper method which computes the differences on the bounded range
         * recursively.
         * @returns An array of the differences between the two input sequences.
         */
        LcsDiff.prototype.ComputeDiffRecursive = function (originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
            quitEarlyArr[0] = false;
            // Find the start of the differences
            while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
                originalStart++;
                modifiedStart++;
            }
            // Find the end of the differences
            while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
                originalEnd--;
                modifiedEnd--;
            }
            // In the special case where we either have all insertions or all deletions or the sequences are identical
            if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
                var changes = void 0;
                if (modifiedStart <= modifiedEnd) {
                    Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');
                    // All insertions
                    changes = [
                        new diffChange_1.DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
                    ];
                }
                else if (originalStart <= originalEnd) {
                    Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');
                    // All deletions
                    changes = [
                        new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
                    ];
                }
                else {
                    Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');
                    Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');
                    // Identical sequences - No differences
                    changes = [];
                }
                return changes;
            }
            // This problem can be solved using the Divide-And-Conquer technique.
            var midOriginalArr = [0], midModifiedArr = [0];
            var result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
            var midOriginal = midOriginalArr[0];
            var midModified = midModifiedArr[0];
            if (result !== null) {
                // Result is not-null when there was enough memory to compute the changes while
                // searching for the recursion point
                return result;
            }
            else if (!quitEarlyArr[0]) {
                // We can break the problem down recursively by finding the changes in the
                // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)
                // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)
                // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point
                var leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
                var rightChanges = [];
                if (!quitEarlyArr[0]) {
                    rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
                }
                else {
                    // We did't have time to finish the first half, so we don't have time to compute this half.
                    // Consider the entire rest of the sequence different.
                    rightChanges = [
                        new diffChange_1.DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
                    ];
                }
                return this.ConcatenateChanges(leftChanges, rightChanges);
            }
            // If we hit here, we quit early, and so can't return anything meaningful
            return [
                new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
            ];
        };
        LcsDiff.prototype.WALKTRACE = function (diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
            var forwardChanges = null, reverseChanges = null;
            // First, walk backward through the forward diagonals history
            var changeHelper = new DiffChangeHelper();
            var diagonalMin = diagonalForwardStart;
            var diagonalMax = diagonalForwardEnd;
            var diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;
            var lastOriginalIndex = Number.MIN_VALUE;
            var historyIndex = this.m_forwardHistory.length - 1;
            var diagonal;
            do {
                // Get the diagonal index from the relative diagonal number
                diagonal = diagonalRelative + diagonalForwardBase;
                // Figure out where we came from
                if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {
                    // Vertical line (the element is an insert)
                    originalIndex = forwardPoints[diagonal + 1];
                    modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
                    if (originalIndex < lastOriginalIndex) {
                        changeHelper.MarkNextChange();
                    }
                    lastOriginalIndex = originalIndex;
                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
                    diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration
                }
                else {
                    // Horizontal line (the element is a deletion)
                    originalIndex = forwardPoints[diagonal - 1] + 1;
                    modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
                    if (originalIndex < lastOriginalIndex) {
                        changeHelper.MarkNextChange();
                    }
                    lastOriginalIndex = originalIndex - 1;
                    changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
                    diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration
                }
                if (historyIndex >= 0) {
                    forwardPoints = this.m_forwardHistory[historyIndex];
                    diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot
                    diagonalMin = 1;
                    diagonalMax = forwardPoints.length - 1;
                }
            } while (--historyIndex >= -1);
            // Ironically, we get the forward changes as the reverse of the
            // order we added them since we technically added them backwards
            forwardChanges = changeHelper.getReverseChanges();
            if (quitEarlyArr[0]) {
                // TODO: Calculate a partial from the reverse diagonals.
                //       For now, just assume everything after the midOriginal/midModified point is a diff
                var originalStartPoint = midOriginalArr[0] + 1;
                var modifiedStartPoint = midModifiedArr[0] + 1;
                if (forwardChanges !== null && forwardChanges.length > 0) {
                    var lastForwardChange = forwardChanges[forwardChanges.length - 1];
                    originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
                    modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
                }
                reverseChanges = [
                    new diffChange_1.DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
                ];
            }
            else {
                // Now walk backward through the reverse diagonals history
                changeHelper = new DiffChangeHelper();
                diagonalMin = diagonalReverseStart;
                diagonalMax = diagonalReverseEnd;
                diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;
                lastOriginalIndex = Number.MAX_VALUE;
                historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
                do {
                    // Get the diagonal index from the relative diagonal number
                    diagonal = diagonalRelative + diagonalReverseBase;
                    // Figure out where we came from
                    if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {
                        // Horizontal line (the element is a deletion))
                        originalIndex = reversePoints[diagonal + 1] - 1;
                        modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                        if (originalIndex > lastOriginalIndex) {
                            changeHelper.MarkNextChange();
                        }
                        lastOriginalIndex = originalIndex + 1;
                        changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
                        diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration
                    }
                    else {
                        // Vertical line (the element is an insertion)
                        originalIndex = reversePoints[diagonal - 1];
                        modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                        if (originalIndex > lastOriginalIndex) {
                            changeHelper.MarkNextChange();
                        }
                        lastOriginalIndex = originalIndex;
                        changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
                        diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration
                    }
                    if (historyIndex >= 0) {
                        reversePoints = this.m_reverseHistory[historyIndex];
                        diagonalReverseBase = reversePoints[0]; //We stored this in the first spot
                        diagonalMin = 1;
                        diagonalMax = reversePoints.length - 1;
                    }
                } while (--historyIndex >= -1);
                // There are cases where the reverse history will find diffs that
                // are correct, but not intuitive, so we need shift them.
                reverseChanges = changeHelper.getChanges();
            }
            return this.ConcatenateChanges(forwardChanges, reverseChanges);
        };
        /**
         * Given the range to compute the diff on, this method finds the point:
         * (midOriginal, midModified)
         * that exists in the middle of the LCS of the two sequences and
         * is the point at which the LCS problem may be broken down recursively.
         * This method will try to keep the LCS trace in memory. If the LCS recursion
         * point is calculated and the full trace is available in memory, then this method
         * will return the change list.
         * @param originalStart The start bound of the original sequence range
         * @param originalEnd The end bound of the original sequence range
         * @param modifiedStart The start bound of the modified sequence range
         * @param modifiedEnd The end bound of the modified sequence range
         * @param midOriginal The middle point of the original sequence range
         * @param midModified The middle point of the modified sequence range
         * @returns The diff changes, if available, otherwise null
         */
        LcsDiff.prototype.ComputeRecursionPoint = function (originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
            var originalIndex, modifiedIndex;
            var diagonalForwardStart = 0, diagonalForwardEnd = 0;
            var diagonalReverseStart = 0, diagonalReverseEnd = 0;
            var numDifferences;
            // To traverse the edit graph and produce the proper LCS, our actual
            // start position is just outside the given boundary
            originalStart--;
            modifiedStart--;
            // We set these up to make the compiler happy, but they will
            // be replaced before we return with the actual recursion point
            midOriginalArr[0] = 0;
            midModifiedArr[0] = 0;
            // Clear out the history
            this.m_forwardHistory = [];
            this.m_reverseHistory = [];
            // Each cell in the two arrays corresponds to a diagonal in the edit graph.
            // The integer value in the cell represents the originalIndex of the furthest
            // reaching point found so far that ends in that diagonal.
            // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.
            var maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);
            var numDiagonals = maxDifferences + 1;
            var forwardPoints = new Array(numDiagonals);
            var reversePoints = new Array(numDiagonals);
            // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)
            // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)
            var diagonalForwardBase = (modifiedEnd - modifiedStart);
            var diagonalReverseBase = (originalEnd - originalStart);
            // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the
            //    diagonal number (relative to diagonalForwardBase)
            // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the
            //    diagonal number (relative to diagonalReverseBase)
            var diagonalForwardOffset = (originalStart - modifiedStart);
            var diagonalReverseOffset = (originalEnd - modifiedEnd);
            // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers
            //   relative to the start diagonal with diagonal numbers relative to the end diagonal.
            // The Even/Oddn-ness of this delta is important for determining when we should check for overlap
            var delta = diagonalReverseBase - diagonalForwardBase;
            var deltaIsEven = (delta % 2 === 0);
            // Here we set up the start and end points as the furthest points found so far
            // in both the forward and reverse directions, respectively
            forwardPoints[diagonalForwardBase] = originalStart;
            reversePoints[diagonalReverseBase] = originalEnd;
            // Remember if we quit early, and thus need to do a best-effort result instead of a real result.
            quitEarlyArr[0] = false;
            // A couple of points:
            // --With this method, we iterate on the number of differences between the two sequences.
            //   The more differences there actually are, the longer this will take.
            // --Also, as the number of differences increases, we have to search on diagonals further
            //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).
            // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences
            //   is even and odd diagonals only when numDifferences is odd.
            var diagonal, tempOriginalIndex;
            for (numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {
                var furthestOriginalIndex = 0;
                var furthestModifiedIndex = 0;
                // Run the algorithm in the forward direction
                diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
                diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
                for (diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
                    // STEP 1: We extend the furthest reaching point in the present diagonal
                    // by looking at the diagonals above and below and picking the one whose point
                    // is further away from the start point (originalStart, modifiedStart)
                    if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {
                        originalIndex = forwardPoints[diagonal + 1];
                    }
                    else {
                        originalIndex = forwardPoints[diagonal - 1] + 1;
                    }
                    modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
                    // Save the current originalIndex so we can test for false overlap in step 3
                    tempOriginalIndex = originalIndex;
                    // STEP 2: We can continue to extend the furthest reaching point in the present diagonal
                    // so long as the elements are equal.
                    while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
                        originalIndex++;
                        modifiedIndex++;
                    }
                    forwardPoints[diagonal] = originalIndex;
                    if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
                        furthestOriginalIndex = originalIndex;
                        furthestModifiedIndex = modifiedIndex;
                    }
                    // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)
                    // and diagonal is in the range of reverse diagonals computed for numDifferences-1
                    // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)
                    // then check for overlap.
                    if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {
                        if (originalIndex >= reversePoints[diagonal]) {
                            midOriginalArr[0] = originalIndex;
                            midModifiedArr[0] = modifiedIndex;
                            if (tempOriginalIndex <= reversePoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {
                                // BINGO! We overlapped, and we have the full trace in memory!
                                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                            }
                            else {
                                // Either false overlap, or we didn't have enough memory for the full trace
                                // Just return the recursion point
                                return null;
                            }
                        }
                    }
                }
                // Check to see if we should be quitting early, before moving on to the next iteration.
                var matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
                if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, this.OriginalSequence, matchLengthOfLongest)) {
                    // We can't finish, so skip ahead to generating a result from what we have.
                    quitEarlyArr[0] = true;
                    // Use the furthest distance we got in the forward direction.
                    midOriginalArr[0] = furthestOriginalIndex;
                    midModifiedArr[0] = furthestModifiedIndex;
                    if (matchLengthOfLongest > 0 && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {
                        // Enough of the history is in memory to walk it backwards
                        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                    }
                    else {
                        // We didn't actually remember enough of the history.
                        //Since we are quiting the diff early, we need to shift back the originalStart and modified start
                        //back into the boundary limits since we decremented their value above beyond the boundary limit.
                        originalStart++;
                        modifiedStart++;
                        return [
                            new diffChange_1.DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
                        ];
                    }
                }
                // Run the algorithm in the reverse direction
                diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
                diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
                for (diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
                    // STEP 1: We extend the furthest reaching point in the present diagonal
                    // by looking at the diagonals above and below and picking the one whose point
                    // is further away from the start point (originalEnd, modifiedEnd)
                    if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {
                        originalIndex = reversePoints[diagonal + 1] - 1;
                    }
                    else {
                        originalIndex = reversePoints[diagonal - 1];
                    }
                    modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
                    // Save the current originalIndex so we can test for false overlap
                    tempOriginalIndex = originalIndex;
                    // STEP 2: We can continue to extend the furthest reaching point in the present diagonal
                    // as long as the elements are equal.
                    while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
                        originalIndex--;
                        modifiedIndex--;
                    }
                    reversePoints[diagonal] = originalIndex;
                    // STEP 4: If delta is even (overlap first happens on reverse when delta is even)
                    // and diagonal is in the range of forward diagonals computed for numDifferences
                    // then check for overlap.
                    if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
                        if (originalIndex <= forwardPoints[diagonal]) {
                            midOriginalArr[0] = originalIndex;
                            midModifiedArr[0] = modifiedIndex;
                            if (tempOriginalIndex >= forwardPoints[diagonal] && MaxDifferencesHistory > 0 && numDifferences <= (MaxDifferencesHistory + 1)) {
                                // BINGO! We overlapped, and we have the full trace in memory!
                                return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                            }
                            else {
                                // Either false overlap, or we didn't have enough memory for the full trace
                                // Just return the recursion point
                                return null;
                            }
                        }
                    }
                }
                // Save current vectors to history before the next iteration
                if (numDifferences <= MaxDifferencesHistory) {
                    // We are allocating space for one extra int, which we fill with
                    // the index of the diagonal base index
                    var temp = new Array(diagonalForwardEnd - diagonalForwardStart + 2);
                    temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
                    MyArray.Copy(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
                    this.m_forwardHistory.push(temp);
                    temp = new Array(diagonalReverseEnd - diagonalReverseStart + 2);
                    temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
                    MyArray.Copy(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
                    this.m_reverseHistory.push(temp);
                }
            }
            // If we got here, then we have the full trace in history. We just have to convert it to a change list
            // NOTE: This part is a bit messy
            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
        };
        /**
         * Concatenates the two input DiffChange lists and returns the resulting
         * list.
         * @param The left changes
         * @param The right changes
         * @returns The concatenated list
         */
        LcsDiff.prototype.ConcatenateChanges = function (left, right) {
            var mergedChangeArr = [];
            var result = null;
            if (left.length === 0 || right.length === 0) {
                return (right.length > 0) ? right : left;
            }
            else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
                // Since we break the problem down recursively, it is possible that we
                // might recurse in the middle of a change thereby splitting it into
                // two changes. Here in the combining stage, we detect and fuse those
                // changes back together
                result = new Array(left.length + right.length - 1);
                MyArray.Copy(left, 0, result, 0, left.length - 1);
                result[left.length - 1] = mergedChangeArr[0];
                MyArray.Copy(right, 1, result, left.length, right.length - 1);
                return result;
            }
            else {
                result = new Array(left.length + right.length);
                MyArray.Copy(left, 0, result, 0, left.length);
                MyArray.Copy(right, 0, result, left.length, right.length);
                return result;
            }
        };
        /**
         * Returns true if the two changes overlap and can be merged into a single
         * change
         * @param left The left change
         * @param right The right change
         * @param mergedChange The merged change if the two overlap, null otherwise
         * @returns True if the two changes overlap
         */
        LcsDiff.prototype.ChangesOverlap = function (left, right, mergedChangeArr) {
            Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');
            Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');
            if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
                var originalStart = left.originalStart;
                var originalLength = left.originalLength;
                var modifiedStart = left.modifiedStart;
                var modifiedLength = left.modifiedLength;
                if (left.originalStart + left.originalLength >= right.originalStart) {
                    originalLength = right.originalStart + right.originalLength - left.originalStart;
                }
                if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
                    modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
                }
                mergedChangeArr[0] = new diffChange_1.DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
                return true;
            }
            else {
                mergedChangeArr[0] = null;
                return false;
            }
        };
        /**
         * Helper method used to clip a diagonal index to the range of valid
         * diagonals. This also decides whether or not the diagonal index,
         * if it exceeds the boundary, should be clipped to the boundary or clipped
         * one inside the boundary depending on the Even/Odd status of the boundary
         * and numDifferences.
         * @param diagonal The index of the diagonal to clip.
         * @param numDifferences The current number of differences being iterated upon.
         * @param diagonalBaseIndex The base reference diagonal.
         * @param numDiagonals The total number of diagonals.
         * @returns The clipped diagonal index.
         */
        LcsDiff.prototype.ClipDiagonalBound = function (diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
            if (diagonal >= 0 && diagonal < numDiagonals) {
                // Nothing to clip, its in range
                return diagonal;
            }
            // diagonalsBelow: The number of diagonals below the reference diagonal
            // diagonalsAbove: The number of diagonals above the reference diagonal
            var diagonalsBelow = diagonalBaseIndex;
            var diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
            var diffEven = (numDifferences % 2 === 0);
            if (diagonal < 0) {
                var lowerBoundEven = (diagonalsBelow % 2 === 0);
                return (diffEven === lowerBoundEven) ? 0 : 1;
            }
            else {
                var upperBoundEven = (diagonalsAbove % 2 === 0);
                return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;
            }
        };
        return LcsDiff;
    }());
    exports.LcsDiff = LcsDiff;
});

var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
define(__m[60], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Event = (function () {
        function Event(originalEvent) {
            this.time = (new Date()).getTime();
            this.originalEvent = originalEvent;
            this.source = null;
        }
        return Event;
    }());
    exports.Event = Event;
    var PropertyChangeEvent = (function (_super) {
        __extends(PropertyChangeEvent, _super);
        function PropertyChangeEvent(key, oldValue, newValue, originalEvent) {
            _super.call(this, originalEvent);
            this.key = key;
            this.oldValue = oldValue;
            this.newValue = newValue;
        }
        return PropertyChangeEvent;
    }(Event));
    exports.PropertyChangeEvent = PropertyChangeEvent;
    var ViewerEvent = (function (_super) {
        __extends(ViewerEvent, _super);
        function ViewerEvent(element, originalEvent) {
            _super.call(this, originalEvent);
            this.element = element;
        }
        return ViewerEvent;
    }(Event));
    exports.ViewerEvent = ViewerEvent;
    exports.EventType = {
        PROPERTY_CHANGED: 'propertyChanged',
        SELECTION: 'selection',
        FOCUS: 'focus',
        BLUR: 'blur',
        HIGHLIGHT: 'highlight',
        EXPAND: 'expand',
        COLLAPSE: 'collapse',
        TOGGLE: 'toggle',
        CONTENTS_CHANGED: 'contentsChanged',
        BEFORE_RUN: 'beforeRun',
        RUN: 'run',
        EDIT: 'edit',
        SAVE: 'save',
        CANCEL: 'cancel',
        CHANGE: 'change',
        DISPOSE: 'dispose',
    };
});

define(__m[264], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Return a hash value for an object.
     */
    function hash(obj, hashVal) {
        if (hashVal === void 0) { hashVal = 0; }
        switch (typeof obj) {
            case 'object':
                if (obj === null) {
                    return numberHash(349, hashVal);
                }
                else if (Array.isArray(obj)) {
                    return arrayHash(obj, hashVal);
                }
                return objectHash(obj, hashVal);
            case 'string':
                return stringHash(obj, hashVal);
            case 'boolean':
                return booleanHash(obj, hashVal);
            case 'number':
                return numberHash(obj, hashVal);
            case 'undefined':
                return numberHash(obj, 937);
            default:
                return numberHash(obj, 617);
        }
    }
    exports.hash = hash;
    function numberHash(val, initialHashVal) {
        return (((initialHashVal << 5) - initialHashVal) + val) | 0; // hashVal * 31 + ch, keep as int32
    }
    function booleanHash(b, initialHashVal) {
        return numberHash(b ? 433 : 863, initialHashVal);
    }
    function stringHash(s, hashVal) {
        hashVal = numberHash(149417, hashVal);
        for (var i = 0, length_1 = s.length; i < length_1; i++) {
            hashVal = numberHash(s.charCodeAt(i), hashVal);
        }
        return hashVal;
    }
    function arrayHash(arr, initialHashVal) {
        initialHashVal = numberHash(104579, initialHashVal);
        return arr.reduce(function (hashVal, item) { return hash(item, hashVal); }, initialHashVal);
    }
    function objectHash(obj, initialHashVal) {
        initialHashVal = numberHash(181387, initialHashVal);
        return Object.keys(obj).sort().reduce(function (hashVal, key) {
            hashVal = stringHash(key, hashVal);
            return hash(obj[key], hashVal);
        }, initialHashVal);
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[92], __M([0,1]), function (require, exports) {
    'use strict';
    function markedStringsEquals(a, b) {
        if (!a && !b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        if (Array.isArray(a)) {
            if (!Array.isArray(b)) {
                return false;
            }
            return markedStringArrEquals(a, b);
        }
        return markedStringEqual(a, b);
    }
    exports.markedStringsEquals = markedStringsEquals;
    function markedStringArrEquals(a, b) {
        var aLen = a.length, bLen = b.length;
        if (aLen !== bLen) {
            return false;
        }
        for (var i = 0; i < aLen; i++) {
            if (!markedStringEqual(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    function markedStringEqual(a, b) {
        if (!a && !b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        if (typeof a === 'string') {
            return typeof b === 'string' && a === b;
        }
        return (a['language'] === b['language']
            && a['value'] === b['value']);
    }
    function textToMarkedString(text) {
        return { language: 'string', value: text };
    }
    exports.textToMarkedString = textToMarkedString;
    function htmlContentElementCodeEqual(a, b) {
        if (!a && !b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        return (a.language === b.language
            && a.value === b.value);
    }
    function htmlContentElementEqual(a, b) {
        return (a.formattedText === b.formattedText
            && a.text === b.text
            && a.className === b.className
            && a.style === b.style
            && a.customStyle === b.customStyle
            && a.tagName === b.tagName
            && a.isText === b.isText
            && a.role === b.role
            && a.markdown === b.markdown
            && htmlContentElementCodeEqual(a.code, b.code)
            && htmlContentElementArrEquals(a.children, b.children));
    }
    function htmlContentElementArrEquals(a, b) {
        if (!a && !b) {
            return true;
        }
        if (!a || !b) {
            return false;
        }
        var aLen = a.length, bLen = b.length;
        if (aLen !== bLen) {
            return false;
        }
        for (var i = 0; i < aLen; i++) {
            if (!htmlContentElementEqual(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    exports.htmlContentElementArrEquals = htmlContentElementArrEquals;
});

define(__m[63], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var IdGenerator = (function () {
        function IdGenerator(prefix) {
            this._prefix = prefix;
            this._lastId = 0;
        }
        IdGenerator.prototype.nextId = function () {
            return this._prefix + (++this._lastId);
        };
        return IdGenerator;
    }());
    exports.IdGenerator = IdGenerator;
    exports.defaultGenerator = new IdGenerator('id#');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[109], __M([0,1]), function (require, exports) {
    'use strict';
    var ArrayIterator = (function () {
        function ArrayIterator(items, start, end) {
            if (start === void 0) { start = 0; }
            if (end === void 0) { end = items.length; }
            this.items = items;
            this.start = start;
            this.end = end;
            this.index = start - 1;
        }
        ArrayIterator.prototype.next = function () {
            this.index = Math.min(this.index + 1, this.end);
            if (this.index === this.end) {
                return null;
            }
            return this.items[this.index];
        };
        return ArrayIterator;
    }());
    exports.ArrayIterator = ArrayIterator;
    var MappedIterator = (function () {
        function MappedIterator(iterator, fn) {
            this.iterator = iterator;
            this.fn = fn;
            // noop
        }
        MappedIterator.prototype.next = function () { return this.fn(this.iterator.next()); };
        return MappedIterator;
    }());
    exports.MappedIterator = MappedIterator;
    var MappedNavigator = (function (_super) {
        __extends(MappedNavigator, _super);
        function MappedNavigator(navigator, fn) {
            _super.call(this, navigator, fn);
            this.navigator = navigator;
        }
        MappedNavigator.prototype.current = function () { return this.fn(this.navigator.current()); };
        MappedNavigator.prototype.previous = function () { return this.fn(this.navigator.previous()); };
        MappedNavigator.prototype.parent = function () { return this.fn(this.navigator.parent()); };
        MappedNavigator.prototype.first = function () { return this.fn(this.navigator.first()); };
        MappedNavigator.prototype.last = function () { return this.fn(this.navigator.last()); };
        return MappedNavigator;
    }(MappedIterator));
    exports.MappedNavigator = MappedNavigator;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[99], __M([0,1]), function (require, exports) {
    'use strict';
    /**
     * A simple map to store value by a key object. Key can be any object that has toString() function to get
     * string value of the key.
     */
    var SimpleMap = (function () {
        function SimpleMap() {
            this.map = Object.create(null);
            this._size = 0;
        }
        Object.defineProperty(SimpleMap.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        SimpleMap.prototype.get = function (k) {
            var value = this.peek(k);
            return value ? value : null;
        };
        SimpleMap.prototype.keys = function () {
            var keys = [];
            for (var key in this.map) {
                keys.push(this.map[key].key);
            }
            return keys;
        };
        SimpleMap.prototype.entries = function () {
            var entries = [];
            for (var key in this.map) {
                entries.push(this.map[key]);
            }
            return entries;
        };
        SimpleMap.prototype.set = function (k, t) {
            if (this.get(k)) {
                return false; // already present!
            }
            this.push(k, t);
            return true;
        };
        SimpleMap.prototype.delete = function (k) {
            var value = this.get(k);
            if (value) {
                this.pop(k);
                return value;
            }
            return null;
        };
        SimpleMap.prototype.has = function (k) {
            return !!this.get(k);
        };
        SimpleMap.prototype.clear = function () {
            this.map = Object.create(null);
            this._size = 0;
        };
        SimpleMap.prototype.push = function (key, value) {
            var entry = { key: key, value: value };
            this.map[key.toString()] = entry;
            this._size++;
        };
        SimpleMap.prototype.pop = function (k) {
            delete this.map[k.toString()];
            this._size--;
        };
        SimpleMap.prototype.peek = function (k) {
            var entry = this.map[k.toString()];
            return entry ? entry.value : null;
        };
        return SimpleMap;
    }());
    exports.SimpleMap = SimpleMap;
    /**
     * A simple Map<T> that optionally allows to set a limit of entries to store. Once the limit is hit,
     * the cache will remove the entry that was last recently added. Or, if a ratio is provided below 1,
     * all elements will be removed until the ratio is full filled (e.g. 0.75 to remove 25% of old elements).
     */
    var LinkedMap = (function () {
        function LinkedMap(limit, ratio) {
            if (limit === void 0) { limit = Number.MAX_VALUE; }
            if (ratio === void 0) { ratio = 1; }
            this.limit = limit;
            this.map = Object.create(null);
            this._size = 0;
            this.ratio = limit * ratio;
        }
        Object.defineProperty(LinkedMap.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        LinkedMap.prototype.set = function (key, value) {
            if (this.map[key]) {
                return false; // already present!
            }
            var entry = { key: key, value: value };
            this.push(entry);
            if (this._size > this.limit) {
                this.trim();
            }
            return true;
        };
        LinkedMap.prototype.get = function (key) {
            var entry = this.map[key];
            return entry ? entry.value : null;
        };
        LinkedMap.prototype.delete = function (key) {
            var entry = this.map[key];
            if (entry) {
                this.map[key] = void 0;
                this._size--;
                if (entry.next) {
                    entry.next.prev = entry.prev; // [A]<-[x]<-[C] = [A]<-[C]
                }
                else {
                    this.head = entry.prev; // [A]-[x] = [A]
                }
                if (entry.prev) {
                    entry.prev.next = entry.next; // [A]->[x]->[C] = [A]->[C]
                }
                else {
                    this.tail = entry.next; // [x]-[A] = [A]
                }
                return entry.value;
            }
            return null;
        };
        LinkedMap.prototype.has = function (key) {
            return !!this.map[key];
        };
        LinkedMap.prototype.clear = function () {
            this.map = Object.create(null);
            this._size = 0;
            this.head = null;
            this.tail = null;
        };
        LinkedMap.prototype.push = function (entry) {
            if (this.head) {
                // [A]-[B] = [A]-[B]->[X]
                entry.prev = this.head;
                this.head.next = entry;
            }
            if (!this.tail) {
                this.tail = entry;
            }
            this.head = entry;
            this.map[entry.key] = entry;
            this._size++;
        };
        LinkedMap.prototype.trim = function () {
            if (this.tail) {
                // Remove all elements until ratio is reached
                if (this.ratio < this.limit) {
                    var index = 0;
                    var current = this.tail;
                    while (current.next) {
                        // Remove the entry
                        this.map[current.key] = void 0;
                        this._size--;
                        // if we reached the element that overflows our ratio condition
                        // make its next element the new tail of the Map and adjust the size
                        if (index === this.ratio) {
                            this.tail = current.next;
                            this.tail.prev = null;
                            break;
                        }
                        // Move on
                        current = current.next;
                        index++;
                    }
                }
                else {
                    this.map[this.tail.key] = void 0;
                    this._size--;
                    // [x]-[B] = [B]
                    this.tail = this.tail.next;
                    this.tail.prev = null;
                }
            }
        };
        return LinkedMap;
    }());
    exports.LinkedMap = LinkedMap;
    /**
     * A subclass of Map<T> that makes an entry the MRU entry as soon
     * as it is being accessed. In combination with the limit for the
     * maximum number of elements in the cache, it helps to remove those
     * entries from the cache that are LRU.
     */
    var LRUCache = (function (_super) {
        __extends(LRUCache, _super);
        function LRUCache(limit) {
            _super.call(this, limit);
        }
        LRUCache.prototype.get = function (key) {
            // Upon access of an entry, make it the head of
            // the linked map so that it is the MRU element
            var entry = this.map[key];
            if (entry) {
                this.delete(key);
                this.push(entry);
                return entry.value;
            }
            return null;
        };
        return LRUCache;
    }(LinkedMap));
    exports.LRUCache = LRUCache;
});


/**
 * marked - a markdown parser
 * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */

// TODO MonacoChange: we have our own way of defining modules
// ;(function() {
// END MonacoChange

/**
 * Block-Level Grammar
 */

var block = {
  newline: /^\n+/,
  code: /^( {4}[^\n]+\n*)+/,
  fences: noop,
  hr: /^( *[-*_]){3,} *(?:\n+|$)/,
  heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
  nptable: noop,
  lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
  blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
  list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
  html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
  def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
  table: noop,
  paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
  text: /^[^\n]+/
};

block.bullet = /(?:[*+-]|\d+\.)/;
block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
block.item = replace(block.item, 'gm')
  (/bull/g, block.bullet)
  ();

block.list = replace(block.list)
  (/bull/g, block.bullet)
  ('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
  ('def', '\\n+(?=' + block.def.source + ')')
  ();

block.blockquote = replace(block.blockquote)
  ('def', block.def)
  ();

block._tag = '(?!(?:'
  + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
  + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
  + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

block.html = replace(block.html)
  ('comment', /<!--[\s\S]*?-->/)
  ('closed', /<(tag)[\s\S]+?<\/\1>/)
  ('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
  (/tag/g, block._tag)
  ();

block.paragraph = replace(block.paragraph)
  ('hr', block.hr)
  ('heading', block.heading)
  ('lheading', block.lheading)
  ('blockquote', block.blockquote)
  ('tag', '<' + block._tag)
  ('def', block.def)
  ();

/**
 * Normal Block Grammar
 */

block.normal = merge({}, block);

/**
 * GFM Block Grammar
 */

block.gfm = merge({}, block.normal, {
  fences: /^ *(`{3,}|~{3,}) *(\S+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/,
  paragraph: /^/
});

block.gfm.paragraph = replace(block.paragraph)
  ('(?!', '(?!'
    + block.gfm.fences.source.replace('\\1', '\\2') + '|'
    + block.list.source.replace('\\1', '\\3') + '|')
  ();

/**
 * GFM + Tables Block Grammar
 */

block.tables = merge({}, block.gfm, {
  nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
  table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
});

/**
 * Block Lexer
 */

function Lexer(options) {
  this.tokens = [];
  this.tokens.links = {};
  this.options = options || marked.defaults;
  this.rules = block.normal;

  if (this.options.gfm) {
    if (this.options.tables) {
      this.rules = block.tables;
    } else {
      this.rules = block.gfm;
    }
  }
}

/**
 * Expose Block Rules
 */

Lexer.rules = block;

/**
 * Static Lex Method
 */

Lexer.lex = function(src, options) {
  var lexer = new Lexer(options);
  return lexer.lex(src);
};

/**
 * Preprocessing
 */

Lexer.prototype.lex = function(src) {
  src = src
    .replace(/\r\n|\r/g, '\n')
    .replace(/\t/g, '    ')
    .replace(/\u00a0/g, ' ')
    .replace(/\u2424/g, '\n');

  return this.token(src, true);
};

/**
 * Lexing
 */

Lexer.prototype.token = function(src, top, bq) {
  var src = src.replace(/^ +$/gm, '')
    , next
    , loose
    , cap
    , bull
    , b
    , item
    , space
    , i
    , l;

  while (src) {
    // newline
    if (cap = this.rules.newline.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[0].length > 1) {
        this.tokens.push({
          type: 'space'
        });
      }
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      cap = cap[0].replace(/^ {4}/gm, '');
      this.tokens.push({
        type: 'code',
        text: !this.options.pedantic
          ? cap.replace(/\n+$/, '')
          : cap
      });
      continue;
    }

    // fences (gfm)
    if (cap = this.rules.fences.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'code',
        lang: cap[2],
        text: cap[3]
      });
      continue;
    }

    // heading
    if (cap = this.rules.heading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[1].length,
        text: cap[2]
      });
      continue;
    }

    // table no leading pipe (gfm)
    if (top && (cap = this.rules.nptable.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i].split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // lheading
    if (cap = this.rules.lheading.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'heading',
        depth: cap[2] === '=' ? 1 : 2,
        text: cap[1]
      });
      continue;
    }

    // hr
    if (cap = this.rules.hr.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'hr'
      });
      continue;
    }

    // blockquote
    if (cap = this.rules.blockquote.exec(src)) {
      src = src.substring(cap[0].length);

      this.tokens.push({
        type: 'blockquote_start'
      });

      cap = cap[0].replace(/^ *> ?/gm, '');

      // Pass `top` to keep the current
      // "toplevel" state. This is exactly
      // how markdown.pl works.
      this.token(cap, top, true);

      this.tokens.push({
        type: 'blockquote_end'
      });

      continue;
    }

    // list
    if (cap = this.rules.list.exec(src)) {
      src = src.substring(cap[0].length);
      bull = cap[2];

      this.tokens.push({
        type: 'list_start',
        ordered: bull.length > 1
      });

      // Get each top-level item.
      cap = cap[0].match(this.rules.item);

      next = false;
      l = cap.length;
      i = 0;

      for (; i < l; i++) {
        item = cap[i];

        // Remove the list item's bullet
        // so it is seen as the next token.
        space = item.length;
        item = item.replace(/^ *([*+-]|\d+\.) +/, '');

        // Outdent whatever the
        // list item contains. Hacky.
        if (~item.indexOf('\n ')) {
          space -= item.length;
          item = !this.options.pedantic
            ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
            : item.replace(/^ {1,4}/gm, '');
        }

        // Determine whether the next list item belongs here.
        // Backpedal if it does not belong in this list.
        if (this.options.smartLists && i !== l - 1) {
          b = block.bullet.exec(cap[i + 1])[0];
          if (bull !== b && !(bull.length > 1 && b.length > 1)) {
            src = cap.slice(i + 1).join('\n') + src;
            i = l - 1;
          }
        }

        // Determine whether item is loose or not.
        // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
        // for discount behavior.
        loose = next || /\n\n(?!\s*$)/.test(item);
        if (i !== l - 1) {
          next = item.charAt(item.length - 1) === '\n';
          if (!loose) loose = next;
        }

        this.tokens.push({
          type: loose
            ? 'loose_item_start'
            : 'list_item_start'
        });

        // Recurse.
        this.token(item, false, bq);

        this.tokens.push({
          type: 'list_item_end'
        });
      }

      this.tokens.push({
        type: 'list_end'
      });

      continue;
    }

    // html
    if (cap = this.rules.html.exec(src)) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: this.options.sanitize
          ? 'paragraph'
          : 'html',
        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',
        text: cap[0]
      });
      continue;
    }

    // def
    if ((!bq && top) && (cap = this.rules.def.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.links[cap[1].toLowerCase()] = {
        href: cap[2],
        title: cap[3]
      };
      continue;
    }

    // table (gfm)
    if (top && (cap = this.rules.table.exec(src))) {
      src = src.substring(cap[0].length);

      item = {
        type: 'table',
        header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
        align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
        cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
      };

      for (i = 0; i < item.align.length; i++) {
        if (/^ *-+: *$/.test(item.align[i])) {
          item.align[i] = 'right';
        } else if (/^ *:-+: *$/.test(item.align[i])) {
          item.align[i] = 'center';
        } else if (/^ *:-+ *$/.test(item.align[i])) {
          item.align[i] = 'left';
        } else {
          item.align[i] = null;
        }
      }

      for (i = 0; i < item.cells.length; i++) {
        item.cells[i] = item.cells[i]
          .replace(/^ *\| *| *\| *$/g, '')
          .split(/ *\| */);
      }

      this.tokens.push(item);

      continue;
    }

    // top-level paragraph
    if (top && (cap = this.rules.paragraph.exec(src))) {
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'paragraph',
        text: cap[1].charAt(cap[1].length - 1) === '\n'
          ? cap[1].slice(0, -1)
          : cap[1]
      });
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      // Top-level should never reach here.
      src = src.substring(cap[0].length);
      this.tokens.push({
        type: 'text',
        text: cap[0]
      });
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return this.tokens;
};

/**
 * Inline-Level Grammar
 */

var inline = {
  escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
  autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
  url: noop,
  tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
  link: /^!?\[(inside)\]\(href\)/,
  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
  br: /^ {2,}\n(?!\s*$)/,
  del: noop,
  text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
};

inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

inline.link = replace(inline.link)
  ('inside', inline._inside)
  ('href', inline._href)
  ();

inline.reflink = replace(inline.reflink)
  ('inside', inline._inside)
  ();

/**
 * Normal Inline Grammar
 */

inline.normal = merge({}, inline);

/**
 * Pedantic Inline Grammar
 */

inline.pedantic = merge({}, inline.normal, {
  strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
  em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
});

/**
 * GFM Inline Grammar
 */

inline.gfm = merge({}, inline.normal, {
  escape: replace(inline.escape)('])', '~|])')(),
  url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
  del: /^~~(?=\S)([\s\S]*?\S)~~/,
  text: replace(inline.text)
    (']|', '~]|')
    ('|', '|https?://|')
    ()
});

/**
 * GFM + Line Breaks Inline Grammar
 */

inline.breaks = merge({}, inline.gfm, {
  br: replace(inline.br)('{2,}', '*')(),
  text: replace(inline.gfm.text)('{2,}', '*')()
});

/**
 * Inline Lexer & Compiler
 */

function InlineLexer(links, options) {
  this.options = options || marked.defaults;
  this.links = links;
  this.rules = inline.normal;
  this.renderer = this.options.renderer || new Renderer;
  this.renderer.options = this.options;

  if (!this.links) {
    throw new
      Error('Tokens array requires a `links` property.');
  }

  if (this.options.gfm) {
    if (this.options.breaks) {
      this.rules = inline.breaks;
    } else {
      this.rules = inline.gfm;
    }
  } else if (this.options.pedantic) {
    this.rules = inline.pedantic;
  }
}

/**
 * Expose Inline Rules
 */

InlineLexer.rules = inline;

/**
 * Static Lexing/Compiling Method
 */

InlineLexer.output = function(src, links, options) {
  var inline = new InlineLexer(links, options);
  return inline.output(src);
};

/**
 * Lexing/Compiling
 */

InlineLexer.prototype.output = function(src) {
  var out = ''
    , link
    , text
    , href
    , cap;

  while (src) {
    // escape
    if (cap = this.rules.escape.exec(src)) {
      src = src.substring(cap[0].length);
      out += cap[1];
      continue;
    }

    // autolink
    if (cap = this.rules.autolink.exec(src)) {
      src = src.substring(cap[0].length);
      if (cap[2] === '@') {
        text = cap[1].charAt(6) === ':'
          ? this.mangle(cap[1].substring(7))
          : this.mangle(cap[1]);
        href = this.mangle('mailto:') + text;
      } else {
        text = escape(cap[1]);
        href = text;
      }
      out += this.renderer.link(href, null, text);
      continue;
    }

    // url (gfm)
    if (!this.inLink && (cap = this.rules.url.exec(src))) {
      src = src.substring(cap[0].length);
      text = escape(cap[1]);
      href = text;
      out += this.renderer.link(href, null, text);
      continue;
    }

    // tag
    if (cap = this.rules.tag.exec(src)) {
      if (!this.inLink && /^<a /i.test(cap[0])) {
        this.inLink = true;
      } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
        this.inLink = false;
      }
      src = src.substring(cap[0].length);
      out += this.options.sanitize
        ? escape(cap[0])
        : cap[0];
      continue;
    }

    // link
    if (cap = this.rules.link.exec(src)) {
      src = src.substring(cap[0].length);
      this.inLink = true;
      out += this.outputLink(cap, {
        href: cap[2],
        title: cap[3]
      });
      this.inLink = false;
      continue;
    }

    // reflink, nolink
    if ((cap = this.rules.reflink.exec(src))
        || (cap = this.rules.nolink.exec(src))) {
      src = src.substring(cap[0].length);
      link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
      link = this.links[link.toLowerCase()];
      if (!link || !link.href) {
        out += cap[0].charAt(0);
        src = cap[0].substring(1) + src;
        continue;
      }
      this.inLink = true;
      out += this.outputLink(cap, link);
      this.inLink = false;
      continue;
    }

    // strong
    if (cap = this.rules.strong.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.strong(this.output(cap[2] || cap[1]));
      continue;
    }

    // em
    if (cap = this.rules.em.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.em(this.output(cap[2] || cap[1]));
      continue;
    }

    // code
    if (cap = this.rules.code.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.codespan(escape(cap[2], true));
      continue;
    }

    // br
    if (cap = this.rules.br.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.br();
      continue;
    }

    // del (gfm)
    if (cap = this.rules.del.exec(src)) {
      src = src.substring(cap[0].length);
      out += this.renderer.del(this.output(cap[1]));
      continue;
    }

    // text
    if (cap = this.rules.text.exec(src)) {
      src = src.substring(cap[0].length);
      out += escape(this.smartypants(cap[0]));
      continue;
    }

    if (src) {
      throw new
        Error('Infinite loop on byte: ' + src.charCodeAt(0));
    }
  }

  return out;
};

/**
 * Compile Link
 */

InlineLexer.prototype.outputLink = function(cap, link) {
  var href = escape(link.href)
    , title = link.title ? escape(link.title) : null;

  return cap[0].charAt(0) !== '!'
    ? this.renderer.link(href, title, this.output(cap[1]))
    : this.renderer.image(href, title, escape(cap[1]));
};

/**
 * Smartypants Transformations
 */
// TODO MonacoChange: Our build fails over the following lines if they are not commented out
InlineLexer.prototype.smartypants = function(text) {
	return text;
//  if (!this.options.smartypants) return text;
//  return text
//    // em-dashes
//    .replace(/--/g, '\u2014')
//    // opening singles
//    .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
//    // closing singles & apostrophes
//    .replace(/'/g, '\u2019')
//    // opening doubles
//    .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
//    // closing doubles
//    .replace(/"/g, '\u201d')
//    // ellipses
//    .replace(/\.{3}/g, '\u2026');
// END MonacoChange
};

/**
 * Mangle Links
 */

InlineLexer.prototype.mangle = function(text) {
  var out = ''
    , l = text.length
    , i = 0
    , ch;

  for (; i < l; i++) {
    ch = text.charCodeAt(i);
    if (Math.random() > 0.5) {
      ch = 'x' + ch.toString(16);
    }
    out += '&#' + ch + ';';
  }

  return out;
};

/**
 * Renderer
 */

function Renderer(options) {
  this.options = options || {};
}

Renderer.prototype.code = function(code, lang, escaped) {
  if (this.options.highlight) {
    var out = this.options.highlight(code, lang);
    if (out != null && out !== code) {
      escaped = true;
      code = out;
    }
  }

  if (!lang) {
    return '<pre><code>'
      + (escaped ? code : escape(code, true))
      + '\n</code></pre>';
  }

  return '<pre><code class="'
    + this.options.langPrefix
    + escape(lang, true)
    + '">'
    + (escaped ? code : escape(code, true))
    + '\n</code></pre>\n';
};

Renderer.prototype.blockquote = function(quote) {
  return '<blockquote>\n' + quote + '</blockquote>\n';
};

Renderer.prototype.html = function(html) {
  return html;
};

Renderer.prototype.heading = function(text, level, raw) {
  return '<h'
    + level
    + ' id="'
    + this.options.headerPrefix
    + raw.toLowerCase().replace(/[^\w]+/g, '-')
    + '">'
    + text
    + '</h'
    + level
    + '>\n';
};

Renderer.prototype.hr = function() {
  return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
};

Renderer.prototype.list = function(body, ordered) {
  var type = ordered ? 'ol' : 'ul';
  return '<' + type + '>\n' + body + '</' + type + '>\n';
};

Renderer.prototype.listitem = function(text) {
  return '<li>' + text + '</li>\n';
};

Renderer.prototype.paragraph = function(text) {
  return '<p>' + text + '</p>\n';
};

Renderer.prototype.table = function(header, body) {
  return '<table>\n'
    + '<thead>\n'
    + header
    + '</thead>\n'
    + '<tbody>\n'
    + body
    + '</tbody>\n'
    + '</table>\n';
};

Renderer.prototype.tablerow = function(content) {
  return '<tr>\n' + content + '</tr>\n';
};

Renderer.prototype.tablecell = function(content, flags) {
  var type = flags.header ? 'th' : 'td';
  var tag = flags.align
    ? '<' + type + ' style="text-align:' + flags.align + '">'
    : '<' + type + '>';
  return tag + content + '</' + type + '>\n';
};

// span level renderer
Renderer.prototype.strong = function(text) {
  return '<strong>' + text + '</strong>';
};

Renderer.prototype.em = function(text) {
  return '<em>' + text + '</em>';
};

Renderer.prototype.codespan = function(text) {
  return '<code>' + text + '</code>';
};

Renderer.prototype.br = function() {
  return this.options.xhtml ? '<br/>' : '<br>';
};

Renderer.prototype.del = function(text) {
  return '<del>' + text + '</del>';
};

Renderer.prototype.link = function(href, title, text) {
  if (this.options.sanitize) {
    try {
      var prot = decodeURIComponent(unescape(href))
        .replace(/[^\w:]/g, '')
        .toLowerCase();
    } catch (e) {
      return '';
    }
    if (prot.indexOf('javascript:') === 0) {
      return '';
    }
  }
  var out = '<a href="' + href + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += '>' + text + '</a>';
  return out;
};

Renderer.prototype.image = function(href, title, text) {
  var out = '<img src="' + href + '" alt="' + text + '"';
  if (title) {
    out += ' title="' + title + '"';
  }
  out += this.options.xhtml ? '/>' : '>';
  return out;
};

/**
 * Parsing & Compiling
 */

function Parser(options) {
  this.tokens = [];
  this.token = null;
  this.options = options || marked.defaults;
  this.options.renderer = this.options.renderer || new Renderer;
  this.renderer = this.options.renderer;
  this.renderer.options = this.options;
}

/**
 * Static Parse Method
 */

Parser.parse = function(src, options, renderer) {
  var parser = new Parser(options, renderer);
  return parser.parse(src);
};

/**
 * Parse Loop
 */

Parser.prototype.parse = function(src) {
  this.inline = new InlineLexer(src.links, this.options, this.renderer);
  this.tokens = src.reverse();

  var out = '';
  while (this.next()) {
    out += this.tok();
  }

  return out;
};

/**
 * Next Token
 */

Parser.prototype.next = function() {
  return this.token = this.tokens.pop();
};

/**
 * Preview Next Token
 */

Parser.prototype.peek = function() {
  return this.tokens[this.tokens.length - 1] || 0;
};

/**
 * Parse Text Tokens
 */

Parser.prototype.parseText = function() {
  var body = this.token.text;

  while (this.peek().type === 'text') {
    body += '\n' + this.next().text;
  }

  return this.inline.output(body);
};

/**
 * Parse Current Token
 */

Parser.prototype.tok = function() {
  switch (this.token.type) {
    case 'space': {
      return '';
    }
    case 'hr': {
      return this.renderer.hr();
    }
    case 'heading': {
      return this.renderer.heading(
        this.inline.output(this.token.text),
        this.token.depth,
        this.token.text);
    }
    case 'code': {
      return this.renderer.code(this.token.text,
        this.token.lang,
        this.token.escaped);
    }
    case 'table': {
      var header = ''
        , body = ''
        , i
        , row
        , cell
        , flags
        , j;

      // header
      cell = '';
      for (i = 0; i < this.token.header.length; i++) {
        flags = { header: true, align: this.token.align[i] };
        cell += this.renderer.tablecell(
          this.inline.output(this.token.header[i]),
          { header: true, align: this.token.align[i] }
        );
      }
      header += this.renderer.tablerow(cell);

      for (i = 0; i < this.token.cells.length; i++) {
        row = this.token.cells[i];

        cell = '';
        for (j = 0; j < row.length; j++) {
          cell += this.renderer.tablecell(
            this.inline.output(row[j]),
            { header: false, align: this.token.align[j] }
          );
        }

        body += this.renderer.tablerow(cell);
      }
      return this.renderer.table(header, body);
    }
    case 'blockquote_start': {
      var body = '';

      while (this.next().type !== 'blockquote_end') {
        body += this.tok();
      }

      return this.renderer.blockquote(body);
    }
    case 'list_start': {
      var body = ''
        , ordered = this.token.ordered;

      while (this.next().type !== 'list_end') {
        body += this.tok();
      }

      return this.renderer.list(body, ordered);
    }
    case 'list_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.token.type === 'text'
          ? this.parseText()
          : this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'loose_item_start': {
      var body = '';

      while (this.next().type !== 'list_item_end') {
        body += this.tok();
      }

      return this.renderer.listitem(body);
    }
    case 'html': {
      var html = !this.token.pre && !this.options.pedantic
        ? this.inline.output(this.token.text)
        : this.token.text;
      return this.renderer.html(html);
    }
    case 'paragraph': {
      return this.renderer.paragraph(this.inline.output(this.token.text));
    }
    case 'text': {
      return this.renderer.paragraph(this.parseText());
    }
  }
};

/**
 * Helpers
 */

function escape(html, encode) {
  return html
    .replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function unescape(html) {
  return html.replace(/&([#\w]+);/g, function(_, n) {
    n = n.toLowerCase();
    if (n === 'colon') return ':';
    if (n.charAt(0) === '#') {
      return n.charAt(1) === 'x'
        ? String.fromCharCode(parseInt(n.substring(2), 16))
        : String.fromCharCode(+n.substring(1));
    }
    return '';
  });
}

function replace(regex, opt) {
  regex = regex.source;
  opt = opt || '';
  return function self(name, val) {
    if (!name) return new RegExp(regex, opt);
    val = val.source || val;
    val = val.replace(/(^|[^\[])\^/g, '$1');
    regex = regex.replace(name, val);
    return self;
  };
}

function noop() {}
noop.exec = noop;

function merge(obj) {
  var i = 1
    , target
    , key;

  for (; i < arguments.length; i++) {
    target = arguments[i];
    for (key in target) {
      if (Object.prototype.hasOwnProperty.call(target, key)) {
        obj[key] = target[key];
      }
    }
  }

  return obj;
}


/**
 * Marked
 */

function marked(src, opt, callback) {
  if (callback || typeof opt === 'function') {
    if (!callback) {
      callback = opt;
      opt = null;
    }

    opt = merge({}, marked.defaults, opt || {});

    var highlight = opt.highlight
      , tokens
      , pending
      , i = 0;

    try {
      tokens = Lexer.lex(src, opt)
    } catch (e) {
      return callback(e);
    }

    pending = tokens.length;

    var done = function(err) {
      if (err) {
        opt.highlight = highlight;
        return callback(err);
      }

      var out;

      try {
        out = Parser.parse(tokens, opt);
      } catch (e) {
        err = e;
      }

      opt.highlight = highlight;

      return err
        ? callback(err)
        : callback(null, out);
    };

    if (!highlight || highlight.length < 3) {
      return done();
    }

    delete opt.highlight;

    if (!pending) return done();

    for (; i < tokens.length; i++) {
      (function(token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        return highlight(token.text, token.lang, function(err, code) {
          if (err) return done(err);
          if (code == null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      })(tokens[i]);
    }

    return;
  }
  try {
    if (opt) opt = merge({}, marked.defaults, opt);
    return Parser.parse(Lexer.lex(src, opt), opt);
  } catch (e) {
    e.message += '\nPlease report this to https://github.com/chjj/marked.';
    if ((opt || marked.defaults).silent) {
      return '<p>An error occured:</p><pre>'
        + escape(e.message + '', true)
        + '</pre>';
    }
    throw e;
  }
}

/**
 * Options
 */

marked.options =
marked.setOptions = function(opt) {
  merge(marked.defaults, opt);
  return marked;
};

marked.defaults = {
  gfm: true,
  tables: true,
  breaks: false,
  pedantic: false,
  sanitize: false,
  smartLists: false,
  silent: false,
  highlight: null,
  langPrefix: 'lang-',
  smartypants: false,
  headerPrefix: '',
  renderer: new Renderer,
  xhtml: false
};

/**
 * Expose
 */

marked.Parser = Parser;
marked.parser = Parser.parse;

marked.Renderer = Renderer;

marked.Lexer = Lexer;
marked.lexer = Lexer.lex;

marked.InlineLexer = InlineLexer;
marked.inlineLexer = InlineLexer.output;

marked.parse = marked;

// TODO MonacoChange: we have our own way of defining modules
this.marked = marked;
//if (typeof module !== 'undefined' && typeof exports === 'object') {
//  module.exports = marked;
//} else if (typeof define === 'function' && define.amd) {
//  define(function() { return marked; });
//} else {
//  this.marked = marked;
//}
//
//}).call(function() {
//  return this || (typeof window !== 'undefined' ? window : global);
//}());
// END MonacoChange
;
define("vs/base/common/marked/raw.marked", [], function () {
				return this.marked;
			});
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

require.config({
	shim: {
		'vs/base/common/marked/raw.marked': {
			exports: function () {
				return this.marked;
			}
		}
	}
});

define(__m[315], __M([516]), function (marked) {
	return {
		marked: marked
	};
});
define(__m[18], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // --- THIS FILE IS TEMPORARY UNTIL ENV.TS IS CLEANED UP. IT CAN SAFELY BE USED IN ALL TARGET EXECUTION ENVIRONMENTS (node & dom) ---
    var _isWindows = false;
    var _isMacintosh = false;
    var _isLinux = false;
    var _isRootUser = false;
    var _isNative = false;
    var _isWeb = false;
    var _isQunit = false;
    var _locale = undefined;
    var _language = undefined;
    exports.LANGUAGE_DEFAULT = 'en';
    // OS detection
    if (typeof process === 'object') {
        _isWindows = (process.platform === 'win32');
        _isMacintosh = (process.platform === 'darwin');
        _isLinux = (process.platform === 'linux');
        _isRootUser = !_isWindows && (process.getuid() === 0);
        var vscode_nls_config = process.env['VSCODE_NLS_CONFIG'];
        if (vscode_nls_config) {
            try {
                var nlsConfig = JSON.parse(vscode_nls_config);
                var resolved = nlsConfig.availableLanguages['*'];
                _locale = nlsConfig.locale;
                // VSCode's default language is 'en'
                _language = resolved ? resolved : exports.LANGUAGE_DEFAULT;
            }
            catch (e) {
            }
        }
        _isNative = true;
    }
    else if (typeof navigator === 'object') {
        var userAgent = navigator.userAgent;
        _isWindows = userAgent.indexOf('Windows') >= 0;
        _isMacintosh = userAgent.indexOf('Macintosh') >= 0;
        _isLinux = userAgent.indexOf('Linux') >= 0;
        _isWeb = true;
        _locale = navigator.language;
        _language = _locale;
        _isQunit = !!self.QUnit;
    }
    (function (Platform) {
        Platform[Platform["Web"] = 0] = "Web";
        Platform[Platform["Mac"] = 1] = "Mac";
        Platform[Platform["Linux"] = 2] = "Linux";
        Platform[Platform["Windows"] = 3] = "Windows";
    })(exports.Platform || (exports.Platform = {}));
    var Platform = exports.Platform;
    exports._platform = Platform.Web;
    if (_isNative) {
        if (_isMacintosh) {
            exports._platform = Platform.Mac;
        }
        else if (_isWindows) {
            exports._platform = Platform.Windows;
        }
        else if (_isLinux) {
            exports._platform = Platform.Linux;
        }
    }
    exports.isWindows = _isWindows;
    exports.isMacintosh = _isMacintosh;
    exports.isLinux = _isLinux;
    exports.isRootUser = _isRootUser;
    exports.isNative = _isNative;
    exports.isWeb = _isWeb;
    exports.isQunit = _isQunit;
    exports.platform = exports._platform;
    /**
     * The language used for the user interface. The format of
     * the string is all lower case (e.g. zh-tw for Traditional
     * Chinese)
     */
    exports.language = _language;
    /**
     * The OS locale or the locale specified by --locale. The format of
     * the string is all lower case (e.g. zh-tw for Traditional
     * Chinese). The UI is not necessarily shown in the provided locale.
     */
    exports.locale = _locale;
    var _globals = (typeof self === 'object' ? self : global);
    exports.globals = _globals;
    function hasWebWorkerSupport() {
        return typeof _globals.Worker !== 'undefined';
    }
    exports.hasWebWorkerSupport = hasWebWorkerSupport;
    exports.setTimeout = _globals.setTimeout.bind(_globals);
    exports.clearTimeout = _globals.clearTimeout.bind(_globals);
    exports.setInterval = _globals.setInterval.bind(_globals);
    exports.clearInterval = _globals.clearInterval.bind(_globals);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[256], __M([0,1,18]), function (require, exports, platform_1) {
    'use strict';
    // Option for hosts to overwrite the worker script url (used in the standalone editor)
    exports.getCrossOriginWorkerScriptUrl = environment('getWorkerUrl', null);
    function environment(name, fallback) {
        if (fallback === void 0) { fallback = false; }
        if (platform_1.globals.MonacoEnvironment && platform_1.globals.MonacoEnvironment.hasOwnProperty(name)) {
            return platform_1.globals.MonacoEnvironment[name];
        }
        return fallback;
    }
});

define(__m[38], __M([0,1,18]), function (require, exports, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The forward slash path separator.
     */
    exports.sep = '/';
    /**
     * The native path separator depending on the OS.
     */
    exports.nativeSep = platform_1.isWindows ? '\\' : '/';
    function relative(from, to) {
        from = normalize(from);
        to = normalize(to);
        var fromParts = from.split(exports.sep), toParts = to.split(exports.sep);
        while (fromParts.length > 0 && toParts.length > 0) {
            if (fromParts[0] === toParts[0]) {
                fromParts.shift();
                toParts.shift();
            }
            else {
                break;
            }
        }
        for (var i = 0, len = fromParts.length; i < len; i++) {
            toParts.unshift('..');
        }
        return toParts.join(exports.sep);
    }
    exports.relative = relative;
    /**
     * @returns the directory name of a path.
     */
    function dirname(path) {
        var idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\');
        if (idx === 0) {
            return '.';
        }
        else if (~idx === 0) {
            return path[0];
        }
        else {
            return path.substring(0, ~idx);
        }
    }
    exports.dirname = dirname;
    /**
     * @returns the base name of a path.
     */
    function basename(path) {
        var idx = ~path.lastIndexOf('/') || ~path.lastIndexOf('\\');
        if (idx === 0) {
            return path;
        }
        else if (~idx === path.length - 1) {
            return basename(path.substring(0, path.length - 1));
        }
        else {
            return path.substr(~idx + 1);
        }
    }
    exports.basename = basename;
    /**
     * @returns {{.far}} from boo.far or the empty string.
     */
    function extname(path) {
        path = basename(path);
        var idx = ~path.lastIndexOf('.');
        return idx ? path.substring(~idx) : '';
    }
    exports.extname = extname;
    var _posixBadPath = /(\/\.\.?\/)|(\/\.\.?)$|^(\.\.?\/)|(\/\/+)|(\\)/;
    var _winBadPath = /(\\\.\.?\\)|(\\\.\.?)$|^(\.\.?\\)|(\\\\+)|(\/)/;
    function _isNormal(path, win) {
        return win
            ? !_winBadPath.test(path)
            : !_posixBadPath.test(path);
    }
    function normalize(path, toOSPath) {
        if (path === null || path === void 0) {
            return path;
        }
        var len = path.length;
        if (len === 0) {
            return '.';
        }
        var wantsBackslash = platform_1.isWindows && toOSPath;
        if (_isNormal(path, wantsBackslash)) {
            return path;
        }
        var sep = wantsBackslash ? '\\' : '/';
        var root = getRoot(path, sep);
        // skip the root-portion of the path
        var start = root.length;
        var skip = false;
        var res = '';
        for (var end = root.length; end <= len; end++) {
            // either at the end or at a path-separator character
            if (end === len || path.charCodeAt(end) === _slash || path.charCodeAt(end) === _backslash) {
                if (streql(path, start, end, '..')) {
                    // skip current and remove parent (if there is already something)
                    var prev_start = res.lastIndexOf(sep);
                    var prev_part = res.slice(prev_start + 1);
                    if ((root || prev_part.length > 0) && prev_part !== '..') {
                        res = prev_start === -1 ? '' : res.slice(0, prev_start);
                        skip = true;
                    }
                }
                else if (streql(path, start, end, '.') && (root || res || end < len - 1)) {
                    // skip current (if there is already something or if there is more to come)
                    skip = true;
                }
                if (!skip) {
                    var part = path.slice(start, end);
                    if (res !== '' && res[res.length - 1] !== sep) {
                        res += sep;
                    }
                    res += part;
                }
                start = end + 1;
                skip = false;
            }
        }
        return root + res;
    }
    exports.normalize = normalize;
    function streql(value, start, end, other) {
        return start + other.length === end && value.indexOf(other, start) === start;
    }
    /**
     * Computes the _root_ this path, like `getRoot('c:\files') === c:\`,
     * `getRoot('files:///files/path') === files:///`,
     * or `getRoot('\\server\shares\path') === \\server\shares\`
     */
    function getRoot(path, sep) {
        if (sep === void 0) { sep = '/'; }
        if (!path) {
            return '';
        }
        var len = path.length;
        var code = path.charCodeAt(0);
        if (code === _slash || code === _backslash) {
            code = path.charCodeAt(1);
            if (code === _slash || code === _backslash) {
                // UNC candidate \\localhost\shares\ddd
                //               ^^^^^^^^^^^^^^^^^^^
                code = path.charCodeAt(2);
                if (code !== _slash && code !== _backslash) {
                    var pos_1 = 3;
                    var start = pos_1;
                    for (; pos_1 < len; pos_1++) {
                        code = path.charCodeAt(pos_1);
                        if (code === _slash || code === _backslash) {
                            break;
                        }
                    }
                    code = path.charCodeAt(pos_1 + 1);
                    if (start !== pos_1 && code !== _slash && code !== _backslash) {
                        pos_1 += 1;
                        for (; pos_1 < len; pos_1++) {
                            code = path.charCodeAt(pos_1);
                            if (code === _slash || code === _backslash) {
                                return path.slice(0, pos_1 + 1) // consume this separator
                                    .replace(/[\\/]/g, sep);
                            }
                        }
                    }
                }
            }
            // /user/far
            // ^
            return sep;
        }
        else if ((code >= _A && code <= _Z) || (code >= _a && code <= _z)) {
            // check for windows drive letter c:\ or c:
            if (path.charCodeAt(1) === _colon) {
                code = path.charCodeAt(2);
                if (code === _slash || code === _backslash) {
                    // C:\fff
                    // ^^^
                    return path.slice(0, 2) + sep;
                }
                else {
                    // C:
                    // ^^
                    return path.slice(0, 2);
                }
            }
        }
        // check for URI
        // scheme://authority/path
        // ^^^^^^^^^^^^^^^^^^^
        var pos = path.indexOf('://');
        if (pos !== -1) {
            pos += 3; // 3 -> "://".length
            for (; pos < len; pos++) {
                code = path.charCodeAt(pos);
                if (code === _slash || code === _backslash) {
                    return path.slice(0, pos + 1); // consume this separator
                }
            }
        }
        return '';
    }
    exports.getRoot = getRoot;
    exports.join = function () {
        var value = '';
        for (var i = 0; i < arguments.length; i++) {
            var part = arguments[i];
            if (i > 0) {
                // add the separater between two parts unless
                // there already is one
                var last = value.charCodeAt(value.length - 1);
                if (last !== _slash && last !== _backslash) {
                    var next = part.charCodeAt(0);
                    if (next !== _slash && next !== _backslash) {
                        value += exports.sep;
                    }
                }
            }
            value += part;
        }
        return normalize(value);
    };
    /**
     * Check if the path follows this pattern: `\\hostname\sharename`.
     *
     * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx
     * @return A boolean indication if the path is a UNC path, on none-windows
     * always false.
     */
    function isUNC(path) {
        if (!platform_1.isWindows) {
            // UNC is a windows concept
            return false;
        }
        if (!path || path.length < 5) {
            // at least \\a\b
            return false;
        }
        var code = path.charCodeAt(0);
        if (code !== _backslash) {
            return false;
        }
        code = path.charCodeAt(1);
        if (code !== _backslash) {
            return false;
        }
        var pos = 2;
        var start = pos;
        for (; pos < path.length; pos++) {
            code = path.charCodeAt(pos);
            if (code === _backslash) {
                break;
            }
        }
        if (start === pos) {
            return false;
        }
        code = path.charCodeAt(pos + 1);
        if (isNaN(code) || code === _backslash) {
            return false;
        }
        return true;
    }
    exports.isUNC = isUNC;
    function isPosixAbsolute(path) {
        return path && path[0] === '/';
    }
    function makePosixAbsolute(path) {
        return isPosixAbsolute(normalize(path)) ? path : exports.sep + path;
    }
    exports.makePosixAbsolute = makePosixAbsolute;
    var _slash = '/'.charCodeAt(0);
    var _backslash = '\\'.charCodeAt(0);
    var _colon = ':'.charCodeAt(0);
    var _a = 'a'.charCodeAt(0);
    var _A = 'A'.charCodeAt(0);
    var _z = 'z'.charCodeAt(0);
    var _Z = 'Z'.charCodeAt(0);
    function isEqualOrParent(path, candidate) {
        if (path === candidate) {
            return true;
        }
        path = normalize(path);
        candidate = normalize(candidate);
        var candidateLen = candidate.length;
        var lastCandidateChar = candidate.charCodeAt(candidateLen - 1);
        if (lastCandidateChar === _slash) {
            candidate = candidate.substring(0, candidateLen - 1);
            candidateLen -= 1;
        }
        if (path === candidate) {
            return true;
        }
        if (!platform_1.isLinux) {
            // case insensitive
            path = path.toLowerCase();
            candidate = candidate.toLowerCase();
        }
        if (path === candidate) {
            return true;
        }
        if (path.indexOf(candidate) !== 0) {
            return false;
        }
        var char = path.charCodeAt(candidateLen);
        return char === _slash;
    }
    exports.isEqualOrParent = isEqualOrParent;
    // Reference: https://en.wikipedia.org/wiki/Filename
    var INVALID_FILE_CHARS = platform_1.isWindows ? /[\\/:\*\?"<>\|]/g : /[\\/]/g;
    var WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\$|nul|lpt[0-9]|com[0-9])$/i;
    function isValidBasename(name) {
        if (!name || name.length === 0 || /^\s+$/.test(name)) {
            return false; // require a name that is not just whitespace
        }
        INVALID_FILE_CHARS.lastIndex = 0; // the holy grail of software development
        if (INVALID_FILE_CHARS.test(name)) {
            return false; // check for certain invalid file characters
        }
        if (platform_1.isWindows && WINDOWS_FORBIDDEN_NAMES.test(name)) {
            return false; // check for certain invalid file names
        }
        if (name === '.' || name === '..') {
            return false; // check for reserved values
        }
        if (platform_1.isWindows && name[name.length - 1] === '.') {
            return false; // Windows: file cannot end with a "."
        }
        if (platform_1.isWindows && name.length !== name.trim().length) {
            return false; // Windows: file cannot end with a whitespace
        }
        return true;
    }
    exports.isValidBasename = isValidBasename;
    exports.isAbsoluteRegex = /^((\/|[a-zA-Z]:\\)[^\(\)<>\\'\"\[\]]+)/;
    /**
     * If you have access to node, it is recommended to use node's path.isAbsolute().
     * This is a simple regex based approach.
     */
    function isAbsolute(path) {
        return exports.isAbsoluteRegex.test(path);
    }
    exports.isAbsolute = isAbsolute;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[259], __M([0,1]), function (require, exports) {
    'use strict';
    // Based on material from:
    /*!
    BEGIN THIRD PARTY
    */
    /*!
    * string_score.js: String Scoring Algorithm 0.1.22
    *
    * http://joshaven.com/string_score
    * https://github.com/joshaven/string_score
    *
    * Copyright (C) 2009-2014 Joshaven Potter <yourtech@gmail.com>
    * Special thanks to all of the contributors listed here https://github.com/joshaven/string_score
    * MIT License: http://opensource.org/licenses/MIT
    *
    * Date: Tue Mar 1 2011
    * Updated: Tue Mar 10 2015
    */
    /**
     * Compute a score for the given string and the given query.
     *
     * Rules:
     * Character score: 1
     * Same case bonus: 1
     * Upper case bonus: 1
     * Consecutive match bonus: 5
     * Start of word/path bonus: 7
     * Start of string bonus: 8
     */
    var wordPathBoundary = ['-', '_', ' ', '/', '\\', '.'];
    function score(target, query, cache) {
        if (!target || !query) {
            return 0; // return early if target or query are undefined
        }
        var hash = target + query;
        var cached = cache && cache[hash];
        if (typeof cached === 'number') {
            return cached;
        }
        var queryLen = query.length;
        var targetLower = target.toLowerCase();
        var queryLower = query.toLowerCase();
        var index = 0;
        var startAt = 0;
        var score = 0;
        var _loop_1 = function() {
            var indexOf = targetLower.indexOf(queryLower[index], startAt);
            if (indexOf < 0) {
                score = 0; // This makes sure that the query is contained in the target
                return "break";
            }
            // Character match bonus
            score += 1;
            // Consecutive match bonus
            if (startAt === indexOf) {
                score += 5;
            }
            // Same case bonus
            if (target[indexOf] === query[indexOf]) {
                score += 1;
            }
            // Start of word bonus
            if (indexOf === 0) {
                score += 8;
            }
            else if (wordPathBoundary.some(function (w) { return w === target[indexOf - 1]; })) {
                score += 7;
            }
            else if (isUpper(target.charCodeAt(indexOf))) {
                score += 1;
            }
            startAt = indexOf + 1;
            index++;
        };
        while (index < queryLen) {
            var state_1 = _loop_1();
            if (state_1 === "break") break;
        }
        if (cache) {
            cache[hash] = score;
        }
        return score;
    }
    exports.score = score;
    function isUpper(code) {
        return 65 <= code && code <= 90;
    }
    /**
     * A fast method to check if a given string would produce a score > 0 for the given query.
     */
    function matches(target, queryLower) {
        if (!target || !queryLower) {
            return false; // return early if target or query are undefined
        }
        var queryLen = queryLower.length;
        var targetLower = target.toLowerCase();
        var index = 0;
        var lastIndexOf = -1;
        while (index < queryLen) {
            var indexOf = targetLower.indexOf(queryLower[index], lastIndexOf + 1);
            if (indexOf < 0) {
                return false;
            }
            lastIndexOf = indexOf;
            index++;
        }
        return true;
    }
    exports.matches = matches;
});
/*!
END THIRD PARTY
*/ 

define(__m[143], __M([0,1,18]), function (require, exports, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var hasPerformanceNow = (platform_1.globals.performance && typeof platform_1.globals.performance.now === 'function');
    var StopWatch = (function () {
        function StopWatch(highResolution) {
            this._highResolution = hasPerformanceNow && highResolution;
            this._startTime = this._now();
            this._stopTime = -1;
        }
        StopWatch.create = function (highResolution) {
            if (highResolution === void 0) { highResolution = true; }
            return new StopWatch(highResolution);
        };
        StopWatch.prototype.stop = function () {
            this._stopTime = this._now();
        };
        StopWatch.prototype.elapsed = function () {
            if (this._stopTime !== -1) {
                return this._stopTime - this._startTime;
            }
            return this._now() - this._startTime;
        };
        StopWatch.prototype._now = function () {
            return this._highResolution ? platform_1.globals.performance.now() : new Date().getTime();
        };
        return StopWatch;
    }());
    exports.StopWatch = StopWatch;
});

define(__m[10], __M([0,1,99]), function (require, exports, map_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The empty string.
     */
    exports.empty = '';
    /**
     * @returns the provided number with the given number of preceding zeros.
     */
    function pad(n, l, char) {
        if (char === void 0) { char = '0'; }
        var str = '' + n;
        var r = [str];
        for (var i = str.length; i < l; i++) {
            r.push(char);
        }
        return r.reverse().join('');
    }
    exports.pad = pad;
    var _formatRegexp = /{(\d+)}/g;
    /**
     * Helper to produce a string with a variable number of arguments. Insert variable segments
     * into the string using the {n} notation where N is the index of the argument following the string.
     * @param value string to which formatting is applied
     * @param args replacements for {n}-entries
     */
    function format(value) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (args.length === 0) {
            return value;
        }
        return value.replace(_formatRegexp, function (match, group) {
            var idx = parseInt(group, 10);
            return isNaN(idx) || idx < 0 || idx >= args.length ?
                match :
                args[idx];
        });
    }
    exports.format = format;
    /**
     * Converts HTML characters inside the string to use entities instead. Makes the string safe from
     * being used e.g. in HTMLElement.innerHTML.
     */
    function escape(html) {
        return html.replace(/[<|>|&]/g, function (match) {
            switch (match) {
                case '<': return '&lt;';
                case '>': return '&gt;';
                case '&': return '&amp;';
                default: return match;
            }
        });
    }
    exports.escape = escape;
    /**
     * Escapes regular expression characters in a given string
     */
    function escapeRegExpCharacters(value) {
        return value.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&');
    }
    exports.escapeRegExpCharacters = escapeRegExpCharacters;
    /**
     * Removes all occurrences of needle from the beginning and end of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim (default is a blank)
     */
    function trim(haystack, needle) {
        if (needle === void 0) { needle = ' '; }
        var trimmed = ltrim(haystack, needle);
        return rtrim(trimmed, needle);
    }
    exports.trim = trim;
    /**
     * Removes all occurrences of needle from the beginning of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim
     */
    function ltrim(haystack, needle) {
        if (!haystack || !needle) {
            return haystack;
        }
        var needleLen = needle.length;
        if (needleLen === 0 || haystack.length === 0) {
            return haystack;
        }
        var offset = 0, idx = -1;
        while ((idx = haystack.indexOf(needle, offset)) === offset) {
            offset = offset + needleLen;
        }
        return haystack.substring(offset);
    }
    exports.ltrim = ltrim;
    /**
     * Removes all occurrences of needle from the end of haystack.
     * @param haystack string to trim
     * @param needle the thing to trim
     */
    function rtrim(haystack, needle) {
        if (!haystack || !needle) {
            return haystack;
        }
        var needleLen = needle.length, haystackLen = haystack.length;
        if (needleLen === 0 || haystackLen === 0) {
            return haystack;
        }
        var offset = haystackLen, idx = -1;
        while (true) {
            idx = haystack.lastIndexOf(needle, offset - 1);
            if (idx === -1 || idx + needleLen !== offset) {
                break;
            }
            if (idx === 0) {
                return '';
            }
            offset = idx;
        }
        return haystack.substring(0, offset);
    }
    exports.rtrim = rtrim;
    function convertSimple2RegExpPattern(pattern) {
        return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&').replace(/[\*]/g, '.*');
    }
    exports.convertSimple2RegExpPattern = convertSimple2RegExpPattern;
    function stripWildcards(pattern) {
        return pattern.replace(/\*/g, '');
    }
    exports.stripWildcards = stripWildcards;
    /**
     * Determines if haystack starts with needle.
     */
    function startsWith(haystack, needle) {
        if (haystack.length < needle.length) {
            return false;
        }
        for (var i = 0; i < needle.length; i++) {
            if (haystack[i] !== needle[i]) {
                return false;
            }
        }
        return true;
    }
    exports.startsWith = startsWith;
    /**
     * Determines if haystack ends with needle.
     */
    function endsWith(haystack, needle) {
        var diff = haystack.length - needle.length;
        if (diff > 0) {
            return haystack.lastIndexOf(needle) === diff;
        }
        else if (diff === 0) {
            return haystack === needle;
        }
        else {
            return false;
        }
    }
    exports.endsWith = endsWith;
    function createRegExp(searchString, isRegex, matchCase, wholeWord, global) {
        if (searchString === '') {
            throw new Error('Cannot create regex from empty string');
        }
        if (!isRegex) {
            searchString = searchString.replace(/[\-\\\{\}\*\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&');
        }
        if (wholeWord) {
            if (!/\B/.test(searchString.charAt(0))) {
                searchString = '\\b' + searchString;
            }
            if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
                searchString = searchString + '\\b';
            }
        }
        var modifiers = '';
        if (global) {
            modifiers += 'g';
        }
        if (!matchCase) {
            modifiers += 'i';
        }
        return new RegExp(searchString, modifiers);
    }
    exports.createRegExp = createRegExp;
    /**
     * Create a regular expression only if it is valid and it doesn't lead to endless loop.
     */
    function createSafeRegExp(searchString, isRegex, matchCase, wholeWord) {
        if (searchString === '') {
            return null;
        }
        // Try to create a RegExp out of the params
        var regex = null;
        try {
            regex = createRegExp(searchString, isRegex, matchCase, wholeWord, true);
        }
        catch (err) {
            return null;
        }
        // Guard against endless loop RegExps & wrap around try-catch as very long regexes produce an exception when executed the first time
        try {
            if (regExpLeadsToEndlessLoop(regex)) {
                return null;
            }
        }
        catch (err) {
            return null;
        }
        return regex;
    }
    exports.createSafeRegExp = createSafeRegExp;
    function regExpLeadsToEndlessLoop(regexp) {
        // Exit early if it's one of these special cases which are meant to match
        // against an empty string
        if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$') {
            return false;
        }
        // We check against an empty string. If the regular expression doesn't advance
        // (e.g. ends in an endless loop) it will match an empty string.
        var match = regexp.exec('');
        return (match && regexp.lastIndex === 0);
    }
    exports.regExpLeadsToEndlessLoop = regExpLeadsToEndlessLoop;
    /**
     * The normalize() method returns the Unicode Normalization Form of a given string. The form will be
     * the Normalization Form Canonical Composition.
     *
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize}
     */
    exports.canNormalize = typeof (''.normalize) === 'function';
    var nonAsciiCharactersPattern = /[^\u0000-\u0080]/;
    var normalizedCache = new map_1.LinkedMap(10000); // bounded to 10000 elements
    function normalizeNFC(str) {
        if (!exports.canNormalize || !str) {
            return str;
        }
        var cached = normalizedCache.get(str);
        if (cached) {
            return cached;
        }
        var res;
        if (nonAsciiCharactersPattern.test(str)) {
            res = str.normalize('NFC');
        }
        else {
            res = str;
        }
        // Use the cache for fast lookup
        normalizedCache.set(str, res);
        return res;
    }
    exports.normalizeNFC = normalizeNFC;
    /**
     * Returns first index of the string that is not whitespace.
     * If string is empty or contains only whitespaces, returns -1
     */
    function firstNonWhitespaceIndex(str) {
        for (var i = 0, len = str.length; i < len; i++) {
            if (str.charAt(i) !== ' ' && str.charAt(i) !== '\t') {
                return i;
            }
        }
        return -1;
    }
    exports.firstNonWhitespaceIndex = firstNonWhitespaceIndex;
    /**
     * Returns the leading whitespace of the string.
     * If the string contains only whitespaces, returns entire string
     */
    function getLeadingWhitespace(str) {
        for (var i = 0, len = str.length; i < len; i++) {
            if (str.charAt(i) !== ' ' && str.charAt(i) !== '\t') {
                return str.substring(0, i);
            }
        }
        return str;
    }
    exports.getLeadingWhitespace = getLeadingWhitespace;
    /**
     * Returns last index of the string that is not whitespace.
     * If string is empty or contains only whitespaces, returns -1
     */
    function lastNonWhitespaceIndex(str, startIndex) {
        if (startIndex === void 0) { startIndex = str.length - 1; }
        for (var i = startIndex; i >= 0; i--) {
            if (str.charAt(i) !== ' ' && str.charAt(i) !== '\t') {
                return i;
            }
        }
        return -1;
    }
    exports.lastNonWhitespaceIndex = lastNonWhitespaceIndex;
    function localeCompare(strA, strB) {
        return strA.localeCompare(strB);
    }
    exports.localeCompare = localeCompare;
    function isAsciiChar(code) {
        return (code >= 97 && code <= 122) || (code >= 65 && code <= 90);
    }
    function equalsIgnoreCase(a, b) {
        var len1 = a.length, len2 = b.length;
        if (len1 !== len2) {
            return false;
        }
        for (var i = 0; i < len1; i++) {
            var codeA = a.charCodeAt(i), codeB = b.charCodeAt(i);
            if (codeA === codeB) {
                continue;
            }
            else if (isAsciiChar(codeA) && isAsciiChar(codeB)) {
                var diff = Math.abs(codeA - codeB);
                if (diff !== 0 && diff !== 32) {
                    return false;
                }
            }
            else {
                if (String.fromCharCode(codeA).toLocaleLowerCase() !== String.fromCharCode(codeB).toLocaleLowerCase()) {
                    return false;
                }
            }
        }
        return true;
    }
    exports.equalsIgnoreCase = equalsIgnoreCase;
    /**
     * @returns the length of the common prefix of the two strings.
     */
    function commonPrefixLength(a, b) {
        var i, len = Math.min(a.length, b.length);
        for (i = 0; i < len; i++) {
            if (a.charCodeAt(i) !== b.charCodeAt(i)) {
                return i;
            }
        }
        return len;
    }
    exports.commonPrefixLength = commonPrefixLength;
    /**
     * @returns the length of the common suffix of the two strings.
     */
    function commonSuffixLength(a, b) {
        var i, len = Math.min(a.length, b.length);
        var aLastIndex = a.length - 1;
        var bLastIndex = b.length - 1;
        for (i = 0; i < len; i++) {
            if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {
                return i;
            }
        }
        return len;
    }
    exports.commonSuffixLength = commonSuffixLength;
    // --- unicode
    // http://en.wikipedia.org/wiki/Surrogate_pair
    // Returns the code point starting at a specified index in a string
    // Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character
    // Code points U+10000 to U+10FFFF are represented on two consecutive characters
    //export function getUnicodePoint(str:string, index:number, len:number):number {
    //	let chrCode = str.charCodeAt(index);
    //	if (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {
    //		let nextChrCode = str.charCodeAt(index + 1);
    //		if (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {
    //			return (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;
    //		}
    //	}
    //	return chrCode;
    //}
    //export function isLeadSurrogate(chr:string) {
    //	let chrCode = chr.charCodeAt(0);
    //	return ;
    //}
    //
    //export function isTrailSurrogate(chr:string) {
    //	let chrCode = chr.charCodeAt(0);
    //	return 0xDC00 <= chrCode && chrCode <= 0xDFFF;
    //}
    function isFullWidthCharacter(charCode) {
        // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns
        // http://jrgraphix.net/research/unicode_blocks.php
        //          2E80  2EFF   CJK Radicals Supplement
        //          2F00  2FDF   Kangxi Radicals
        //          2FF0  2FFF   Ideographic Description Characters
        //          3000  303F   CJK Symbols and Punctuation
        //          3040  309F   Hiragana
        //          30A0  30FF   Katakana
        //          3100  312F   Bopomofo
        //          3130  318F   Hangul Compatibility Jamo
        //          3190  319F   Kanbun
        //          31A0  31BF   Bopomofo Extended
        //          31F0  31FF   Katakana Phonetic Extensions
        //          3200  32FF   Enclosed CJK Letters and Months
        //          3300  33FF   CJK Compatibility
        //          3400  4DBF   CJK Unified Ideographs Extension A
        //          4DC0  4DFF   Yijing Hexagram Symbols
        //          4E00  9FFF   CJK Unified Ideographs
        //          A000  A48F   Yi Syllables
        //          A490  A4CF   Yi Radicals
        //          AC00  D7AF   Hangul Syllables
        // [IGNORE] D800  DB7F   High Surrogates
        // [IGNORE] DB80  DBFF   High Private Use Surrogates
        // [IGNORE] DC00  DFFF   Low Surrogates
        // [IGNORE] E000  F8FF   Private Use Area
        //          F900  FAFF   CJK Compatibility Ideographs
        // [IGNORE] FB00  FB4F   Alphabetic Presentation Forms
        // [IGNORE] FB50  FDFF   Arabic Presentation Forms-A
        // [IGNORE] FE00  FE0F   Variation Selectors
        // [IGNORE] FE20  FE2F   Combining Half Marks
        // [IGNORE] FE30  FE4F   CJK Compatibility Forms
        // [IGNORE] FE50  FE6F   Small Form Variants
        // [IGNORE] FE70  FEFF   Arabic Presentation Forms-B
        //          FF00  FFEF   Halfwidth and Fullwidth Forms
        //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]
        //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E
        // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul
        // [IGNORE] FFF0  FFFF   Specials
        charCode = +charCode; // @perf
        return ((charCode >= 0x2E80 && charCode <= 0xD7AF)
            || (charCode >= 0xF900 && charCode <= 0xFAFF)
            || (charCode >= 0xFF01 && charCode <= 0xFF5E));
    }
    exports.isFullWidthCharacter = isFullWidthCharacter;
    /**
     * Computes the difference score for two strings. More similar strings have a higher score.
     * We use largest common subsequence dynamic programming approach but penalize in the end for length differences.
     * Strings that have a large length difference will get a bad default score 0.
     * Complexity - both time and space O(first.length * second.length)
     * Dynamic programming LCS computation http://en.wikipedia.org/wiki/Longest_common_subsequence_problem
     *
     * @param first a string
     * @param second a string
     */
    function difference(first, second, maxLenDelta) {
        if (maxLenDelta === void 0) { maxLenDelta = 4; }
        var lengthDifference = Math.abs(first.length - second.length);
        // We only compute score if length of the currentWord and length of entry.name are similar.
        if (lengthDifference > maxLenDelta) {
            return 0;
        }
        // Initialize LCS (largest common subsequence) matrix.
        var LCS = [];
        var zeroArray = [];
        var i, j;
        for (i = 0; i < second.length + 1; ++i) {
            zeroArray.push(0);
        }
        for (i = 0; i < first.length + 1; ++i) {
            LCS.push(zeroArray);
        }
        for (i = 1; i < first.length + 1; ++i) {
            for (j = 1; j < second.length + 1; ++j) {
                if (first[i - 1] === second[j - 1]) {
                    LCS[i][j] = LCS[i - 1][j - 1] + 1;
                }
                else {
                    LCS[i][j] = Math.max(LCS[i - 1][j], LCS[i][j - 1]);
                }
            }
        }
        return LCS[first.length][second.length] - Math.sqrt(lengthDifference);
    }
    exports.difference = difference;
    /**
     * Returns an array in which every entry is the offset of a
     * line. There is always one entry which is zero.
     */
    function computeLineStarts(text) {
        var regexp = /\r\n|\r|\n/g, ret = [0], match;
        while ((match = regexp.exec(text))) {
            ret.push(regexp.lastIndex);
        }
        return ret;
    }
    exports.computeLineStarts = computeLineStarts;
    /**
     * Given a string and a max length returns a shorted version. Shorting
     * happens at favorable positions - such as whitespace or punctuation characters.
     */
    function lcut(text, n) {
        if (text.length < n) {
            return text;
        }
        var segments = text.split(/\b/), count = 0;
        for (var i = segments.length - 1; i >= 0; i--) {
            count += segments[i].length;
            if (count > n) {
                segments.splice(0, i);
                break;
            }
        }
        return segments.join(exports.empty).replace(/^\s/, exports.empty);
    }
    exports.lcut = lcut;
    // Escape codes
    // http://en.wikipedia.org/wiki/ANSI_escape_code
    var EL = /\x1B\x5B[12]?K/g; // Erase in line
    var LF = /\xA/g; // line feed
    var COLOR_START = /\x1b\[\d+m/g; // Color
    var COLOR_END = /\x1b\[0?m/g; // Color
    function removeAnsiEscapeCodes(str) {
        if (str) {
            str = str.replace(EL, '');
            str = str.replace(LF, '\n');
            str = str.replace(COLOR_START, '');
            str = str.replace(COLOR_END, '');
        }
        return str;
    }
    exports.removeAnsiEscapeCodes = removeAnsiEscapeCodes;
    // -- UTF-8 BOM
    var __utf8_bom = 65279;
    exports.UTF8_BOM_CHARACTER = String.fromCharCode(__utf8_bom);
    function startsWithUTF8BOM(str) {
        return (str && str.length > 0 && str.charCodeAt(0) === __utf8_bom);
    }
    exports.startsWithUTF8BOM = startsWithUTF8BOM;
    /**
     * Appends two strings. If the appended result is longer than maxLength,
     * trims the start of the result and replaces it with '...'.
     */
    function appendWithLimit(first, second, maxLength) {
        var newLength = first.length + second.length;
        if (newLength > maxLength) {
            first = '...' + first.substr(newLength - maxLength);
        }
        if (second.length > maxLength) {
            first += second.substr(second.length - maxLength);
        }
        else {
            first += second;
        }
        return first;
    }
    exports.appendWithLimit = appendWithLimit;
    function safeBtoa(str) {
        return btoa(encodeURIComponent(str)); // we use encodeURIComponent because btoa fails for non Latin 1 values
    }
    exports.safeBtoa = safeBtoa;
    function repeat(s, count) {
        var result = '';
        for (var i = 0; i < count; i++) {
            result += s;
        }
        return result;
    }
    exports.repeat = repeat;
});

define(__m[273], __M([0,1,10]), function (require, exports, strings_1) {
    "use strict";
    function expand(text) {
        return text;
    }
    var MockOcticonLabel = (function () {
        function MockOcticonLabel(container) {
            this._container = container;
        }
        Object.defineProperty(MockOcticonLabel.prototype, "text", {
            set: function (text) {
                var innerHTML = text || '';
                innerHTML = strings_1.escape(innerHTML);
                innerHTML = expand(innerHTML);
                this._container.innerHTML = innerHTML;
            },
            enumerable: true,
            configurable: true
        });
        return MockOcticonLabel;
    }());
    var mock = {
        expand: expand,
        OcticonLabel: MockOcticonLabel
    };
    return mock;
});

define(__m[288], __M([0,1,10]), function (require, exports, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var FileNameMatch = /^(.*)\.([^.]*)|([^.]+)$/;
    function compareFileNames(one, other) {
        var oneMatch = FileNameMatch.exec(one.toLowerCase());
        var otherMatch = FileNameMatch.exec(other.toLowerCase());
        var oneName = oneMatch[1] || oneMatch[3] || '';
        var oneExtension = oneMatch[2] || '';
        var otherName = otherMatch[1] || otherMatch[3] || '';
        var otherExtension = otherMatch[2] || '';
        if (oneName !== otherName) {
            return oneName < otherName ? -1 : 1;
        }
        return oneExtension < otherExtension ? -1 : 1;
    }
    exports.compareFileNames = compareFileNames;
    function compareAnything(one, other, lookFor) {
        var elementAName = one.toLowerCase();
        var elementBName = other.toLowerCase();
        // Sort prefix matches over non prefix matches
        var prefixCompare = compareByPrefix(one, other, lookFor);
        if (prefixCompare) {
            return prefixCompare;
        }
        // Sort suffix matches over non suffix matches
        var elementASuffixMatch = strings.endsWith(elementAName, lookFor);
        var elementBSuffixMatch = strings.endsWith(elementBName, lookFor);
        if (elementASuffixMatch !== elementBSuffixMatch) {
            return elementASuffixMatch ? -1 : 1;
        }
        // Understand file names
        var r = compareFileNames(elementAName, elementBName);
        if (r !== 0) {
            return r;
        }
        // Compare by name
        return strings.localeCompare(elementAName, elementBName);
    }
    exports.compareAnything = compareAnything;
    function compareByPrefix(one, other, lookFor) {
        var elementAName = one.toLowerCase();
        var elementBName = other.toLowerCase();
        // Sort prefix matches over non prefix matches
        var elementAPrefixMatch = elementAName.indexOf(lookFor) === 0;
        var elementBPrefixMatch = elementBName.indexOf(lookFor) === 0;
        if (elementAPrefixMatch !== elementBPrefixMatch) {
            return elementAPrefixMatch ? -1 : 1;
        }
        else if (elementAPrefixMatch && elementBPrefixMatch) {
            if (elementAName.length < elementBName.length) {
                return -1;
            }
            if (elementAName.length > elementBName.length) {
                return 1;
            }
        }
        return 0;
    }
    exports.compareByPrefix = compareByPrefix;
});

define(__m[65], __M([0,1,10,99]), function (require, exports, strings, map_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // Combined filters
    /**
     * @returns A filter which combines the provided set
     * of filters with an or. The *first* filters that
     * matches defined the return value of the returned
     * filter.
     */
    function or() {
        var filter = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            filter[_i - 0] = arguments[_i];
        }
        return function (word, wordToMatchAgainst) {
            for (var i = 0, len = filter.length; i < len; i++) {
                var match = filter[i](word, wordToMatchAgainst);
                if (match) {
                    return match;
                }
            }
            return null;
        };
    }
    exports.or = or;
    /**
     * @returns A filter which combines the provided set
     * of filters with an and. The combines matches are
     * returned if *all* filters match.
     */
    function and() {
        var filter = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            filter[_i - 0] = arguments[_i];
        }
        return function (word, wordToMatchAgainst) {
            var result = [];
            for (var i = 0, len = filter.length; i < len; i++) {
                var match = filter[i](word, wordToMatchAgainst);
                if (!match) {
                    return null;
                }
                result = result.concat(match);
            }
            return result;
        };
    }
    exports.and = and;
    // Prefix
    exports.matchesStrictPrefix = function (word, wordToMatchAgainst) { return _matchesPrefix(false, word, wordToMatchAgainst); };
    exports.matchesPrefix = function (word, wordToMatchAgainst) { return _matchesPrefix(true, word, wordToMatchAgainst); };
    function _matchesPrefix(ignoreCase, word, wordToMatchAgainst) {
        if (!wordToMatchAgainst || wordToMatchAgainst.length === 0 || wordToMatchAgainst.length < word.length) {
            return null;
        }
        if (ignoreCase) {
            word = word.toLowerCase();
            wordToMatchAgainst = wordToMatchAgainst.toLowerCase();
        }
        for (var i = 0; i < word.length; i++) {
            if (word[i] !== wordToMatchAgainst[i]) {
                return null;
            }
        }
        return word.length > 0 ? [{ start: 0, end: word.length }] : [];
    }
    // Contiguous Substring
    function matchesContiguousSubString(word, wordToMatchAgainst) {
        var index = wordToMatchAgainst.toLowerCase().indexOf(word.toLowerCase());
        if (index === -1) {
            return null;
        }
        return [{ start: index, end: index + word.length }];
    }
    exports.matchesContiguousSubString = matchesContiguousSubString;
    // Substring
    function matchesSubString(word, wordToMatchAgainst) {
        return _matchesSubString(word.toLowerCase(), wordToMatchAgainst.toLowerCase(), 0, 0);
    }
    exports.matchesSubString = matchesSubString;
    function _matchesSubString(word, wordToMatchAgainst, i, j) {
        if (i === word.length) {
            return [];
        }
        else if (j === wordToMatchAgainst.length) {
            return null;
        }
        else {
            if (word[i] === wordToMatchAgainst[j]) {
                var result = null;
                if (result = _matchesSubString(word, wordToMatchAgainst, i + 1, j + 1)) {
                    return join({ start: j, end: j + 1 }, result);
                }
            }
            return _matchesSubString(word, wordToMatchAgainst, i, j + 1);
        }
    }
    // CamelCase
    function isLower(code) {
        return 97 <= code && code <= 122;
    }
    function isUpper(code) {
        return 65 <= code && code <= 90;
    }
    function isNumber(code) {
        return 48 <= code && code <= 57;
    }
    function isWhitespace(code) {
        return [32, 9, 10, 13].indexOf(code) > -1;
    }
    function isAlphanumeric(code) {
        return isLower(code) || isUpper(code) || isNumber(code);
    }
    function join(head, tail) {
        if (tail.length === 0) {
            tail = [head];
        }
        else if (head.end === tail[0].start) {
            tail[0].start = head.start;
        }
        else {
            tail.unshift(head);
        }
        return tail;
    }
    function nextAnchor(camelCaseWord, start) {
        for (var i = start; i < camelCaseWord.length; i++) {
            var c = camelCaseWord.charCodeAt(i);
            if (isUpper(c) || isNumber(c) || (i > 0 && !isAlphanumeric(camelCaseWord.charCodeAt(i - 1)))) {
                return i;
            }
        }
        return camelCaseWord.length;
    }
    function _matchesCamelCase(word, camelCaseWord, i, j) {
        if (i === word.length) {
            return [];
        }
        else if (j === camelCaseWord.length) {
            return null;
        }
        else if (word[i] !== camelCaseWord[j].toLowerCase()) {
            return null;
        }
        else {
            var result = null;
            var nextUpperIndex = j + 1;
            result = _matchesCamelCase(word, camelCaseWord, i + 1, j + 1);
            while (!result && (nextUpperIndex = nextAnchor(camelCaseWord, nextUpperIndex)) < camelCaseWord.length) {
                result = _matchesCamelCase(word, camelCaseWord, i + 1, nextUpperIndex);
                nextUpperIndex++;
            }
            return result === null ? null : join({ start: j, end: j + 1 }, result);
        }
    }
    // Heuristic to avoid computing camel case matcher for words that don't
    // look like camelCaseWords.
    function isCamelCaseWord(word) {
        if (word.length > 60) {
            return false;
        }
        var upper = 0, lower = 0, alpha = 0, numeric = 0, code = 0;
        for (var i = 0; i < word.length; i++) {
            code = word.charCodeAt(i);
            if (isUpper(code)) {
                upper++;
            }
            if (isLower(code)) {
                lower++;
            }
            if (isAlphanumeric(code)) {
                alpha++;
            }
            if (isNumber(code)) {
                numeric++;
            }
        }
        var upperPercent = upper / word.length;
        var lowerPercent = lower / word.length;
        var alphaPercent = alpha / word.length;
        var numericPercent = numeric / word.length;
        return lowerPercent > 0.2 && upperPercent < 0.8 && alphaPercent > 0.6 && numericPercent < 0.2;
    }
    // Heuristic to avoid computing camel case matcher for words that don't
    // look like camel case patterns.
    function isCamelCasePattern(word) {
        var upper = 0, lower = 0, code = 0, whitespace = 0;
        for (var i = 0; i < word.length; i++) {
            code = word.charCodeAt(i);
            if (isUpper(code)) {
                upper++;
            }
            if (isLower(code)) {
                lower++;
            }
            if (isWhitespace(code)) {
                whitespace++;
            }
        }
        if ((upper === 0 || lower === 0) && whitespace === 0) {
            return word.length <= 30;
        }
        else {
            return upper <= 5;
        }
    }
    function matchesCamelCase(word, camelCaseWord) {
        if (!camelCaseWord || camelCaseWord.length === 0) {
            return null;
        }
        if (!isCamelCasePattern(word)) {
            return null;
        }
        if (!isCamelCaseWord(camelCaseWord)) {
            return null;
        }
        var result = null;
        var i = 0;
        while (i < camelCaseWord.length && (result = _matchesCamelCase(word.toLowerCase(), camelCaseWord, 0, i)) === null) {
            i = nextAnchor(camelCaseWord, i + 1);
        }
        return result;
    }
    exports.matchesCamelCase = matchesCamelCase;
    // Matches beginning of words supporting non-ASCII languages
    // E.g. "gp" or "g p" will match "Git: Pull"
    // Useful in cases where the target is words (e.g. command labels)
    function matchesWords(word, target) {
        if (!target || target.length === 0) {
            return null;
        }
        var result = null;
        var i = 0;
        while (i < target.length && (result = _matchesWords(word.toLowerCase(), target, 0, i)) === null) {
            i = nextWord(target, i + 1);
        }
        return result;
    }
    exports.matchesWords = matchesWords;
    function _matchesWords(word, target, i, j) {
        if (i === word.length) {
            return [];
        }
        else if (j === target.length) {
            return null;
        }
        else if (word[i] !== target[j].toLowerCase()) {
            return null;
        }
        else {
            var result = null;
            var nextWordIndex = j + 1;
            result = _matchesWords(word, target, i + 1, j + 1);
            while (!result && (nextWordIndex = nextWord(target, nextWordIndex)) < target.length) {
                result = _matchesWords(word, target, i + 1, nextWordIndex);
                nextWordIndex++;
            }
            return result === null ? null : join({ start: j, end: j + 1 }, result);
        }
    }
    function nextWord(word, start) {
        for (var i = start; i < word.length; i++) {
            var c = word.charCodeAt(i);
            if (isWhitespace(c) || (i > 0 && isWhitespace(word.charCodeAt(i - 1)))) {
                return i;
            }
        }
        return word.length;
    }
    // Fuzzy
    (function (SubstringMatching) {
        SubstringMatching[SubstringMatching["Contiguous"] = 0] = "Contiguous";
        SubstringMatching[SubstringMatching["Separate"] = 1] = "Separate";
    })(exports.SubstringMatching || (exports.SubstringMatching = {}));
    var SubstringMatching = exports.SubstringMatching;
    exports.fuzzyContiguousFilter = or(exports.matchesPrefix, matchesCamelCase, matchesContiguousSubString);
    var fuzzySeparateFilter = or(exports.matchesPrefix, matchesCamelCase, matchesSubString);
    var fuzzyRegExpCache = new map_1.LinkedMap(10000); // bounded to 10000 elements
    function matchesFuzzy(word, wordToMatchAgainst, enableSeparateSubstringMatching) {
        if (enableSeparateSubstringMatching === void 0) { enableSeparateSubstringMatching = false; }
        if (typeof word !== 'string' || typeof wordToMatchAgainst !== 'string') {
            return null; // return early for invalid input
        }
        // Form RegExp for wildcard matches
        var regexp = fuzzyRegExpCache.get(word);
        if (!regexp) {
            regexp = new RegExp(strings.convertSimple2RegExpPattern(word), 'i');
            fuzzyRegExpCache.set(word, regexp);
        }
        // RegExp Filter
        var match = regexp.exec(wordToMatchAgainst);
        if (match) {
            return [{ start: match.index, end: match.index + match[0].length }];
        }
        // Default Filter
        return enableSeparateSubstringMatching ? fuzzySeparateFilter(word, wordToMatchAgainst) : exports.fuzzyContiguousFilter(word, wordToMatchAgainst);
    }
    exports.matchesFuzzy = matchesFuzzy;
});

define(__m[132], __M([0,1,10,38,99]), function (require, exports, strings, paths, map_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var PATH_REGEX = '[/\\\\]'; // any slash or backslash
    var NO_PATH_REGEX = '[^/\\\\]'; // any non-slash and non-backslash
    function starsToRegExp(starCount) {
        switch (starCount) {
            case 0:
                return '';
            case 1:
                return NO_PATH_REGEX + "*?"; // 1 star matches any number of characters except path separator (/ and \) - non greedy (?)
            default:
                // Matches:  (Path Sep OR Path Val followed by Path Sep OR Path Sep followed by Path Val) 0-many times
                // Group is non capturing because we don't need to capture at all (?:...)
                // Overall we use non-greedy matching because it could be that we match too much
                return "(?:" + PATH_REGEX + "|" + NO_PATH_REGEX + "+" + PATH_REGEX + "|" + PATH_REGEX + NO_PATH_REGEX + "+)*?";
        }
    }
    function splitGlobAware(pattern, splitChar) {
        if (!pattern) {
            return [];
        }
        var segments = [];
        var inBraces = false;
        var inBrackets = false;
        var char;
        var curVal = '';
        for (var i = 0; i < pattern.length; i++) {
            char = pattern[i];
            switch (char) {
                case splitChar:
                    if (!inBraces && !inBrackets) {
                        segments.push(curVal);
                        curVal = '';
                        continue;
                    }
                    break;
                case '{':
                    inBraces = true;
                    break;
                case '}':
                    inBraces = false;
                    break;
                case '[':
                    inBrackets = true;
                    break;
                case ']':
                    inBrackets = false;
                    break;
            }
            curVal += char;
        }
        // Tail
        if (curVal) {
            segments.push(curVal);
        }
        return segments;
    }
    exports.splitGlobAware = splitGlobAware;
    function parseRegExp(pattern) {
        if (!pattern) {
            return '';
        }
        var regEx = '';
        // Split up into segments for each slash found
        var segments = splitGlobAware(pattern, '/');
        // Special case where we only have globstars
        if (segments.every(function (s) { return s === '**'; })) {
            regEx = '.*';
        }
        else {
            var previousSegmentWasGlobStar_1 = false;
            segments.forEach(function (segment, index) {
                // Globstar is special
                if (segment === '**') {
                    // if we have more than one globstar after another, just ignore it
                    if (!previousSegmentWasGlobStar_1) {
                        regEx += starsToRegExp(2);
                        previousSegmentWasGlobStar_1 = true;
                    }
                    return;
                }
                // States
                var inBraces = false;
                var braceVal = '';
                var inBrackets = false;
                var bracketVal = '';
                var char;
                for (var i = 0; i < segment.length; i++) {
                    char = segment[i];
                    // Support brace expansion
                    if (char !== '}' && inBraces) {
                        braceVal += char;
                        continue;
                    }
                    // Support brackets
                    if (char !== ']' && inBrackets) {
                        var res = void 0;
                        switch (char) {
                            case '-':
                                res = char;
                                break;
                            case '^':
                                res = char;
                                break;
                            default:
                                res = strings.escapeRegExpCharacters(char);
                        }
                        bracketVal += res;
                        continue;
                    }
                    switch (char) {
                        case '{':
                            inBraces = true;
                            continue;
                        case '[':
                            inBrackets = true;
                            continue;
                        case '}':
                            var choices = splitGlobAware(braceVal, ',');
                            // Converts {foo,bar} => [foo|bar]
                            var braceRegExp = "(?:" + choices.map(function (c) { return parseRegExp(c); }).join('|') + ")";
                            regEx += braceRegExp;
                            inBraces = false;
                            braceVal = '';
                            break;
                        case ']':
                            regEx += ('[' + bracketVal + ']');
                            inBrackets = false;
                            bracketVal = '';
                            break;
                        case '?':
                            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \)
                            continue;
                        case '*':
                            regEx += starsToRegExp(1);
                            continue;
                        default:
                            regEx += strings.escapeRegExpCharacters(char);
                    }
                }
                // Tail: Add the slash we had split on if there is more to come and the next one is not a globstar
                if (index < segments.length - 1 && segments[index + 1] !== '**') {
                    regEx += PATH_REGEX;
                }
                // reset state
                previousSegmentWasGlobStar_1 = false;
            });
        }
        return regEx;
    }
    // regexes to check for trival glob patterns that just check for String#endsWith
    var T1 = /^\*\*\/\*\.[\w\.-]+$/; // **/*.something
    var T2 = /^\*\*\/[\w\.-]+$/; // **/something
    var T3 = /^{\*\*\/\*\.[\w\.-]+(,\*\*\/\*\.[\w\.-]+)*}$/; // {**/*.something,**/*.else}
    var Trivia;
    (function (Trivia) {
        Trivia[Trivia["T1"] = 0] = "T1";
        Trivia[Trivia["T2"] = 1] = "T2";
        Trivia[Trivia["T3"] = 2] = "T3"; // {**/*.something,**/*.else}
    })(Trivia || (Trivia = {}));
    var CACHE = new map_1.LinkedMap(10000); // bounded to 10000 elements
    function parsePattern(pattern) {
        if (!pattern) {
            return null;
        }
        // Whitespace trimming
        pattern = pattern.trim();
        // Check cache
        var parsedPattern = CACHE.get(pattern);
        if (parsedPattern) {
            if (parsedPattern.regexp) {
                parsedPattern.regexp.lastIndex = 0; // reset RegExp to its initial state to reuse it!
            }
            return parsedPattern;
        }
        parsedPattern = Object.create(null);
        // Check for Trivias
        if (T1.test(pattern)) {
            parsedPattern.trivia = Trivia.T1;
        }
        else if (T2.test(pattern)) {
            parsedPattern.trivia = Trivia.T2;
        }
        else if (T3.test(pattern)) {
            parsedPattern.trivia = Trivia.T3;
        }
        else {
            parsedPattern.regexp = toRegExp("^" + parseRegExp(pattern) + "$");
        }
        // Cache
        CACHE.set(pattern, parsedPattern);
        return parsedPattern;
    }
    function toRegExp(regEx) {
        try {
            return new RegExp(regEx);
        }
        catch (error) {
            return /.^/; // create a regex that matches nothing if we cannot parse the pattern
        }
    }
    function match(arg1, path, siblings) {
        if (!arg1 || !path) {
            return false;
        }
        // Glob with String
        if (typeof arg1 === 'string') {
            var parsedPattern = parsePattern(arg1);
            if (!parsedPattern) {
                return false;
            }
            // common pattern: **/*.txt just need endsWith check
            if (parsedPattern.trivia === Trivia.T1) {
                return strings.endsWith(path, arg1.substr(4)); // '**/*'.length === 4
            }
            // common pattern: **/some.txt just need basename check
            if (parsedPattern.trivia === Trivia.T2) {
                var base = arg1.substr(3); // '**/'.length === 3
                return path === base || strings.endsWith(path, "/" + base) || strings.endsWith(path, "\\" + base);
            }
            // repetition of common patterns (see above) {**/*.txt,**/*.png}
            if (parsedPattern.trivia === Trivia.T3) {
                return arg1.slice(1, -1).split(',').some(function (pattern) { return match(pattern, path); });
            }
            return parsedPattern.regexp.test(path);
        }
        // Glob with Expression
        return matchExpression(arg1, path, siblings);
    }
    exports.match = match;
    function matchExpression(expression, path, siblings) {
        var patterns = Object.getOwnPropertyNames(expression);
        var basename;
        var _loop_1 = function(i) {
            var pattern = patterns[i];
            var value = expression[pattern];
            if (value === false) {
                return "continue"; // pattern is disabled
            }
            // Pattern matches path
            if (match(pattern, path)) {
                // Expression Pattern is <boolean>
                if (typeof value === 'boolean') {
                    return { value: pattern };
                }
                // Expression Pattern is <SiblingClause>
                if (value && typeof value.when === 'string') {
                    if (!siblings || !siblings.length) {
                        return "continue"; // pattern is malformed or we don't have siblings
                    }
                    if (!basename) {
                        basename = strings.rtrim(paths.basename(path), paths.extname(path));
                    }
                    var clause = value;
                    var clausePattern_1 = clause.when.replace('$(basename)', basename);
                    if (siblings.some(function (sibling) { return sibling === clausePattern_1; })) {
                        return { value: pattern };
                    }
                    else {
                        return "continue"; // pattern does not match in the end because the when clause is not satisfied
                    }
                }
                // Expression is Anything
                return { value: pattern };
            }
        };
        for (var i = 0; i < patterns.length; i++) {
            var state_1 = _loop_1(i);
            if (typeof state_1 === "object") return state_1.value;
            if (state_1 === "continue") continue;
        }
        return null;
    }
});

define(__m[26], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var _typeof = {
        number: 'number',
        string: 'string',
        undefined: 'undefined',
        object: 'object',
        function: 'function'
    };
    /**
     * @returns whether the provided parameter is a JavaScript Array or not.
     */
    function isArray(array) {
        if (Array.isArray) {
            return Array.isArray(array);
        }
        if (array && typeof (array.length) === _typeof.number && array.constructor === Array) {
            return true;
        }
        return false;
    }
    exports.isArray = isArray;
    /**
     * @returns whether the provided parameter is a JavaScript String or not.
     */
    function isString(str) {
        if (typeof (str) === _typeof.string || str instanceof String) {
            return true;
        }
        return false;
    }
    exports.isString = isString;
    /**
     * @returns whether the provided parameter is a JavaScript Array and each element in the array is a string.
     */
    function isStringArray(value) {
        return isArray(value) && value.every(function (elem) { return isString(elem); });
    }
    exports.isStringArray = isStringArray;
    /**
     *
     * @returns whether the provided parameter is of type `object` but **not**
     *	`null`, an `array`, a `regexp`, nor a `date`.
     */
    function isObject(obj) {
        return typeof obj === _typeof.object
            && obj !== null
            && !Array.isArray(obj)
            && !(obj instanceof RegExp)
            && !(obj instanceof Date);
    }
    exports.isObject = isObject;
    /**
     * In **contrast** to just checking `typeof` this will return `false` for `NaN`.
     * @returns whether the provided parameter is a JavaScript Number or not.
     */
    function isNumber(obj) {
        if ((typeof (obj) === _typeof.number || obj instanceof Number) && !isNaN(obj)) {
            return true;
        }
        return false;
    }
    exports.isNumber = isNumber;
    /**
     * @returns whether the provided parameter is a JavaScript Boolean or not.
     */
    function isBoolean(obj) {
        return obj === true || obj === false;
    }
    exports.isBoolean = isBoolean;
    /**
     * @returns whether the provided parameter is undefined.
     */
    function isUndefined(obj) {
        return typeof (obj) === _typeof.undefined;
    }
    exports.isUndefined = isUndefined;
    /**
     * @returns whether the provided parameter is undefined or null.
     */
    function isUndefinedOrNull(obj) {
        return isUndefined(obj) || obj === null;
    }
    exports.isUndefinedOrNull = isUndefinedOrNull;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    /**
     * @returns whether the provided parameter is an empty JavaScript Object or not.
     */
    function isEmptyObject(obj) {
        if (!isObject(obj)) {
            return false;
        }
        for (var key in obj) {
            if (hasOwnProperty.call(obj, key)) {
                return false;
            }
        }
        return true;
    }
    exports.isEmptyObject = isEmptyObject;
    /**
     * @returns whether the provided parameter is a JavaScript Function or not.
     */
    function isFunction(obj) {
        return typeof obj === _typeof.function;
    }
    exports.isFunction = isFunction;
    /**
     * @returns whether the provided parameters is are JavaScript Function or not.
     */
    function areFunctions() {
        var objects = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            objects[_i - 0] = arguments[_i];
        }
        return objects && objects.length > 0 && objects.every(isFunction);
    }
    exports.areFunctions = areFunctions;
    function validateConstraints(args, constraints) {
        var len = Math.min(args.length, constraints.length);
        for (var i = 0; i < len; i++) {
            validateConstraint(args[i], constraints[i]);
        }
    }
    exports.validateConstraints = validateConstraints;
    function validateConstraint(arg, constraint) {
        if (isString(constraint)) {
            if (typeof arg !== constraint) {
                throw new Error("argument does not match constraint: typeof " + constraint);
            }
        }
        else if (isFunction(constraint)) {
            if (arg instanceof constraint) {
                return;
            }
            if (arg && arg.constructor === constraint) {
                return;
            }
            if (constraint.length === 1 && constraint.call(undefined, arg) === true) {
                return;
            }
            throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
        }
    }
    exports.validateConstraint = validateConstraint;
    /**
     * Creates a new object of the provided class and will call the constructor with
     * any additional argument supplied.
     */
    function create(ctor) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var obj = Object.create(ctor.prototype);
        ctor.apply(obj, args);
        return obj;
    }
    exports.create = create;
});

define(__m[255], __M([0,1,26,48]), function (require, exports, types_1, collections_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function newNode(data) {
        return {
            data: data,
            incoming: Object.create(null),
            outgoing: Object.create(null)
        };
    }
    var Graph = (function () {
        function Graph(_hashFn) {
            this._hashFn = _hashFn;
            this._nodes = Object.create(null);
            // empty
        }
        Graph.prototype.roots = function () {
            var ret = [];
            collections_1.forEach(this._nodes, function (entry) {
                if (types_1.isEmptyObject(entry.value.outgoing)) {
                    ret.push(entry.value);
                }
            });
            return ret;
        };
        Graph.prototype.traverse = function (start, inwards, callback) {
            var startNode = this.lookup(start);
            if (!startNode) {
                return;
            }
            this._traverse(startNode, inwards, Object.create(null), callback);
        };
        Graph.prototype._traverse = function (node, inwards, seen, callback) {
            var _this = this;
            var key = this._hashFn(node.data);
            if (collections_1.contains(seen, key)) {
                return;
            }
            seen[key] = true;
            callback(node.data);
            var nodes = inwards ? node.outgoing : node.incoming;
            collections_1.forEach(nodes, function (entry) { return _this._traverse(entry.value, inwards, seen, callback); });
        };
        Graph.prototype.insertEdge = function (from, to) {
            var fromNode = this.lookupOrInsertNode(from), toNode = this.lookupOrInsertNode(to);
            fromNode.outgoing[this._hashFn(to)] = toNode;
            toNode.incoming[this._hashFn(from)] = fromNode;
        };
        Graph.prototype.removeNode = function (data) {
            var key = this._hashFn(data);
            delete this._nodes[key];
            collections_1.forEach(this._nodes, function (entry) {
                delete entry.value.outgoing[key];
                delete entry.value.incoming[key];
            });
        };
        Graph.prototype.lookupOrInsertNode = function (data) {
            var key = this._hashFn(data), node = collections_1.lookup(this._nodes, key);
            if (!node) {
                node = newNode(data);
                this._nodes[key] = node;
            }
            return node;
        };
        Graph.prototype.lookup = function (data) {
            return collections_1.lookup(this._nodes, this._hashFn(data));
        };
        Object.defineProperty(Graph.prototype, "length", {
            get: function () {
                return Object.keys(this._nodes).length;
            },
            enumerable: true,
            configurable: true
        });
        Graph.prototype.toString = function () {
            var data = [];
            collections_1.forEach(this._nodes, function (entry) {
                data.push(entry.key + ", (incoming)[" + Object.keys(entry.value.incoming).join(', ') + "], (outgoing)[" + Object.keys(entry.value.outgoing).join(',') + "]");
            });
            return data.join('\n');
        };
        return Graph;
    }());
    exports.Graph = Graph;
});

define(__m[142], __M([0,1,18,26,10,38]), function (require, exports, platform, types, strings, paths) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var PathLabelProvider = (function () {
        function PathLabelProvider(arg1) {
            this.root = arg1 && getPath(arg1);
        }
        PathLabelProvider.prototype.getLabel = function (arg1) {
            return getPathLabel(getPath(arg1), this.root);
        };
        return PathLabelProvider;
    }());
    exports.PathLabelProvider = PathLabelProvider;
    function getPathLabel(arg1, arg2) {
        var basepath = arg2 && getPath(arg2);
        var absolutePath = getPath(arg1);
        if (basepath && paths.isEqualOrParent(absolutePath, basepath)) {
            if (basepath === absolutePath) {
                return ''; // no label if pathes are identical
            }
            return paths.normalize(strings.ltrim(absolutePath.substr(basepath.length), paths.nativeSep), true);
        }
        if (platform.isWindows && absolutePath[1] === ':') {
            return paths.normalize(absolutePath.charAt(0).toUpperCase() + absolutePath.slice(1), true);
        }
        return paths.normalize(absolutePath, true);
    }
    exports.getPathLabel = getPathLabel;
    function getPath(arg1) {
        if (!arg1) {
            return null;
        }
        if (typeof arg1 === 'string') {
            return arg1;
        }
        if (types.isFunction(arg1.getWorkspace)) {
            var ws = arg1.getWorkspace();
            return ws ? ws.resource.fsPath : void 0;
        }
        return arg1.fsPath;
    }
});






define(__m[3], __M([0,1,26]), function (require, exports, types_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.empty = Object.freeze({
        dispose: function () { }
    });
    function dispose() {
        var disposables = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            disposables[_i - 0] = arguments[_i];
        }
        var first = disposables[0];
        if (types_1.isArray(first)) {
            disposables = first;
        }
        disposables.forEach(function (d) { return d && d.dispose(); });
        return [];
    }
    exports.dispose = dispose;
    function combinedDisposable(disposables) {
        return { dispose: function () { return dispose(disposables); } };
    }
    exports.combinedDisposable = combinedDisposable;
    function toDisposable() {
        var fns = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fns[_i - 0] = arguments[_i];
        }
        return combinedDisposable(fns.map(function (fn) { return ({ dispose: fn }); }));
    }
    exports.toDisposable = toDisposable;
    var Disposable = (function () {
        function Disposable() {
            this._toDispose = [];
        }
        Disposable.prototype.dispose = function () {
            this._toDispose = dispose(this._toDispose);
        };
        Disposable.prototype._register = function (t) {
            this._toDispose.push(t);
            return t;
        };
        return Disposable;
    }());
    exports.Disposable = Disposable;
    var Disposables = (function (_super) {
        __extends(Disposables, _super);
        function Disposables() {
            _super.apply(this, arguments);
        }
        Disposables.prototype.add = function (arg) {
            if (!Array.isArray(arg)) {
                return this._register(arg);
            }
            else {
                for (var _i = 0, arg_1 = arg; _i < arg_1.length; _i++) {
                    var element = arg_1[_i];
                    return this._register(element);
                }
            }
        };
        return Disposables;
    }(Disposable));
    exports.Disposables = Disposables;
});

define(__m[144], __M([0,1,38,26,10,132]), function (require, exports, paths, types, strings, glob_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.MIME_TEXT = 'text/plain';
    exports.MIME_BINARY = 'application/octet-stream';
    exports.MIME_UNKNOWN = 'application/unknown';
    var registeredAssociations = [];
    /**
     * Associate a text mime to the registry.
     */
    function registerTextMime(association) {
        // Register
        registeredAssociations.push(association);
        // Check for conflicts unless this is a user configured association
        if (!association.userConfigured) {
            registeredAssociations.forEach(function (a) {
                if (a.mime === association.mime || a.userConfigured) {
                    return; // same mime or userConfigured is ok
                }
                if (association.extension && a.extension === association.extension) {
                    console.warn("Overwriting extension <<" + association.extension + ">> to now point to mime <<" + association.mime + ">>");
                }
                if (association.filename && a.filename === association.filename) {
                    console.warn("Overwriting filename <<" + association.filename + ">> to now point to mime <<" + association.mime + ">>");
                }
                if (association.filepattern && a.filepattern === association.filepattern) {
                    console.warn("Overwriting filepattern <<" + association.filepattern + ">> to now point to mime <<" + association.mime + ">>");
                }
                if (association.firstline && a.firstline === association.firstline) {
                    console.warn("Overwriting firstline <<" + association.firstline + ">> to now point to mime <<" + association.mime + ">>");
                }
            });
        }
    }
    exports.registerTextMime = registerTextMime;
    /**
     * Clear text mimes from the registry.
     */
    function clearTextMimes(onlyUserConfigured) {
        if (!onlyUserConfigured) {
            registeredAssociations = [];
        }
        else {
            registeredAssociations = registeredAssociations.filter(function (a) { return !a.userConfigured; });
        }
    }
    exports.clearTextMimes = clearTextMimes;
    /**
     * Given a file, return the best matching mime type for it
     */
    function guessMimeTypes(path, firstLine) {
        if (!path) {
            return [exports.MIME_UNKNOWN];
        }
        path = path.toLowerCase();
        // 1.) User configured mappings have highest priority
        var configuredMime = guessMimeTypeByPath(path, registeredAssociations.filter(function (a) { return a.userConfigured; }));
        if (configuredMime) {
            return [configuredMime, exports.MIME_TEXT];
        }
        // 2.) Registered mappings have middle priority
        var registeredMime = guessMimeTypeByPath(path, registeredAssociations.filter(function (a) { return !a.userConfigured; }));
        if (registeredMime) {
            return [registeredMime, exports.MIME_TEXT];
        }
        // 3.) Firstline has lowest priority
        if (firstLine) {
            var firstlineMime = guessMimeTypeByFirstline(firstLine);
            if (firstlineMime) {
                return [firstlineMime, exports.MIME_TEXT];
            }
        }
        return [exports.MIME_UNKNOWN];
    }
    exports.guessMimeTypes = guessMimeTypes;
    function guessMimeTypeByPath(path, associations) {
        var filename = paths.basename(path);
        var filenameMatch;
        var patternMatch;
        var extensionMatch;
        for (var i = 0; i < associations.length; i++) {
            var association = associations[i];
            // First exact name match
            if (association.filename && filename === association.filename.toLowerCase()) {
                filenameMatch = association;
                break; // take it!
            }
            // Longest pattern match
            if (association.filepattern) {
                var target = association.filepattern.indexOf(paths.sep) >= 0 ? path : filename; // match on full path if pattern contains path separator
                if (glob_1.match(association.filepattern.toLowerCase(), target)) {
                    if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {
                        patternMatch = association;
                    }
                }
            }
            // Longest extension match
            if (association.extension) {
                if (strings.endsWith(filename, association.extension.toLowerCase())) {
                    if (!extensionMatch || association.extension.length > extensionMatch.extension.length) {
                        extensionMatch = association;
                    }
                }
            }
        }
        // 1.) Exact name match has second highest prio
        if (filenameMatch) {
            return filenameMatch.mime;
        }
        // 2.) Match on pattern
        if (patternMatch) {
            return patternMatch.mime;
        }
        // 3.) Match on extension comes next
        if (extensionMatch) {
            return extensionMatch.mime;
        }
        return null;
    }
    function guessMimeTypeByFirstline(firstLine) {
        if (strings.startsWithUTF8BOM(firstLine)) {
            firstLine = firstLine.substr(1);
        }
        if (firstLine.length > 0) {
            for (var i = 0; i < registeredAssociations.length; ++i) {
                var association = registeredAssociations[i];
                if (!association.firstline) {
                    continue;
                }
                // Make sure the entire line matches, not just a subpart.
                var matches = firstLine.match(association.firstline);
                if (matches && matches.length > 0 && matches[0].length === firstLine.length) {
                    return association.mime;
                }
            }
        }
        return null;
    }
    function isBinaryMime(mimes) {
        if (!mimes) {
            return false;
        }
        var mimeVals;
        if (types.isArray(mimes)) {
            mimeVals = mimes;
        }
        else {
            mimeVals = mimes.split(',').map(function (mime) { return mime.trim(); });
        }
        return mimeVals.indexOf(exports.MIME_BINARY) >= 0;
    }
    exports.isBinaryMime = isBinaryMime;
    function isUnspecific(mime) {
        if (!mime) {
            return true;
        }
        if (typeof mime === 'string') {
            return mime === exports.MIME_BINARY || mime === exports.MIME_TEXT || mime === exports.MIME_UNKNOWN;
        }
        return mime.length === 1 && isUnspecific(mime[0]);
    }
    exports.isUnspecific = isUnspecific;
    function suggestFilename(theMime, prefix) {
        for (var i = 0; i < registeredAssociations.length; i++) {
            var association = registeredAssociations[i];
            if (association.userConfigured) {
                continue; // only support registered ones
            }
            if (association.mime === theMime && association.extension) {
                return prefix + association.extension;
            }
        }
        return null;
    }
    exports.suggestFilename = suggestFilename;
});

define(__m[31], __M([0,1,26]), function (require, exports, Types) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function clone(obj) {
        if (!obj || typeof obj !== 'object') {
            return obj;
        }
        if (obj instanceof RegExp) {
            return obj;
        }
        var result = (Array.isArray(obj)) ? [] : {};
        Object.keys(obj).forEach(function (key) {
            if (obj[key] && typeof obj[key] === 'object') {
                result[key] = clone(obj[key]);
            }
            else {
                result[key] = obj[key];
            }
        });
        return result;
    }
    exports.clone = clone;
    function deepClone(obj) {
        if (!obj || typeof obj !== 'object') {
            return obj;
        }
        var result = (Array.isArray(obj)) ? [] : {};
        Object.getOwnPropertyNames(obj).forEach(function (key) {
            if (obj[key] && typeof obj[key] === 'object') {
                result[key] = deepClone(obj[key]);
            }
            else {
                result[key] = obj[key];
            }
        });
        return result;
    }
    exports.deepClone = deepClone;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function cloneAndChange(obj, changer) {
        return _cloneAndChange(obj, changer, []);
    }
    exports.cloneAndChange = cloneAndChange;
    function _cloneAndChange(obj, changer, encounteredObjects) {
        if (Types.isUndefinedOrNull(obj)) {
            return obj;
        }
        var changed = changer(obj);
        if (typeof changed !== 'undefined') {
            return changed;
        }
        if (Types.isArray(obj)) {
            var r1 = [];
            for (var i1 = 0; i1 < obj.length; i1++) {
                r1.push(_cloneAndChange(obj[i1], changer, encounteredObjects));
            }
            return r1;
        }
        if (Types.isObject(obj)) {
            if (encounteredObjects.indexOf(obj) >= 0) {
                throw new Error('Cannot clone recursive data-structure');
            }
            encounteredObjects.push(obj);
            var r2 = {};
            for (var i2 in obj) {
                if (hasOwnProperty.call(obj, i2)) {
                    r2[i2] = _cloneAndChange(obj[i2], changer, encounteredObjects);
                }
            }
            encounteredObjects.pop();
            return r2;
        }
        return obj;
    }
    // DON'T USE THESE FUNCTION UNLESS YOU KNOW HOW CHROME
    // WORKS... WE HAVE SEEN VERY WEIRD BEHAVIOUR WITH CHROME >= 37
    ///**
    // * Recursively call Object.freeze on object and any properties that are objects.
    // */
    //export function deepFreeze(obj:any):void {
    //	Object.freeze(obj);
    //	Object.keys(obj).forEach((key) => {
    //		if(!(typeof obj[key] === 'object') || Object.isFrozen(obj[key])) {
    //			return;
    //		}
    //
    //		deepFreeze(obj[key]);
    //	});
    //	if(!Object.isFrozen(obj)) {
    //		console.log('too warm');
    //	}
    //}
    //
    //export function deepSeal(obj:any):void {
    //	Object.seal(obj);
    //	Object.keys(obj).forEach((key) => {
    //		if(!(typeof obj[key] === 'object') || Object.isSealed(obj[key])) {
    //			return;
    //		}
    //
    //		deepSeal(obj[key]);
    //	});
    //	if(!Object.isSealed(obj)) {
    //		console.log('NOT sealed');
    //	}
    //}
    /**
     * Copies all properties of source into destination. The optional parameter "overwrite" allows to control
     * if existing properties on the destination should be overwritten or not. Defaults to true (overwrite).
     */
    function mixin(destination, source, overwrite) {
        if (overwrite === void 0) { overwrite = true; }
        if (!Types.isObject(destination)) {
            return source;
        }
        if (Types.isObject(source)) {
            Object.keys(source).forEach(function (key) {
                if (key in destination) {
                    if (overwrite) {
                        if (Types.isObject(destination[key]) && Types.isObject(source[key])) {
                            mixin(destination[key], source[key], overwrite);
                        }
                        else {
                            destination[key] = source[key];
                        }
                    }
                }
                else {
                    destination[key] = source[key];
                }
            });
        }
        return destination;
    }
    exports.mixin = mixin;
    function assign(destination) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        sources.forEach(function (source) { return Object.keys(source).forEach(function (key) { return destination[key] = source[key]; }); });
        return destination;
    }
    exports.assign = assign;
    function toObject(arr, keyMap, valueMap) {
        if (valueMap === void 0) { valueMap = function (x) { return x; }; }
        return arr.reduce(function (o, d) { return assign(o, (_a = {}, _a[keyMap(d)] = valueMap(d), _a)); var _a; }, Object.create(null));
    }
    exports.toObject = toObject;
    function equals(one, other) {
        if (one === other) {
            return true;
        }
        if (one === null || one === undefined || other === null || other === undefined) {
            return false;
        }
        if (typeof one !== typeof other) {
            return false;
        }
        if (typeof one !== 'object') {
            return false;
        }
        if ((Array.isArray(one)) !== (Array.isArray(other))) {
            return false;
        }
        var i, key;
        if (Array.isArray(one)) {
            if (one.length !== other.length) {
                return false;
            }
            for (i = 0; i < one.length; i++) {
                if (!equals(one[i], other[i])) {
                    return false;
                }
            }
        }
        else {
            var oneKeys = [];
            for (key in one) {
                oneKeys.push(key);
            }
            oneKeys.sort();
            var otherKeys = [];
            for (key in other) {
                otherKeys.push(key);
            }
            otherKeys.sort();
            if (!equals(oneKeys, otherKeys)) {
                return false;
            }
            for (i = 0; i < oneKeys.length; i++) {
                if (!equals(one[oneKeys[i]], other[oneKeys[i]])) {
                    return false;
                }
            }
        }
        return true;
    }
    exports.equals = equals;
    function ensureProperty(obj, property, defaultValue) {
        if (typeof obj[property] === 'undefined') {
            obj[property] = defaultValue;
        }
    }
    exports.ensureProperty = ensureProperty;
    function arrayToHash(array) {
        var result = {};
        for (var i = 0; i < array.length; ++i) {
            result[array[i]] = true;
        }
        return result;
    }
    exports.arrayToHash = arrayToHash;
    /**
     * Given an array of strings, returns a function which, given a string
     * returns true or false whether the string is in that array.
     */
    function createKeywordMatcher(arr, caseInsensitive) {
        if (caseInsensitive === void 0) { caseInsensitive = false; }
        if (caseInsensitive) {
            arr = arr.map(function (x) { return x.toLowerCase(); });
        }
        var hash = arrayToHash(arr);
        if (caseInsensitive) {
            return function (word) {
                return hash[word.toLowerCase()] !== undefined && hash.hasOwnProperty(word.toLowerCase());
            };
        }
        else {
            return function (word) {
                return hash[word] !== undefined && hash.hasOwnProperty(word);
            };
        }
    }
    exports.createKeywordMatcher = createKeywordMatcher;
    /**
     * Started from TypeScript's __extends function to make a type a subclass of a specific class.
     * Modified to work with properties already defined on the derivedClass, since we can't get TS
     * to call this method before the constructor definition.
     */
    function derive(baseClass, derivedClass) {
        for (var prop in baseClass) {
            if (baseClass.hasOwnProperty(prop)) {
                derivedClass[prop] = baseClass[prop];
            }
        }
        derivedClass = derivedClass || function () { };
        var basePrototype = baseClass.prototype;
        var derivedPrototype = derivedClass.prototype;
        derivedClass.prototype = Object.create(basePrototype);
        for (var prop in derivedPrototype) {
            if (derivedPrototype.hasOwnProperty(prop)) {
                // handle getters and setters properly
                Object.defineProperty(derivedClass.prototype, prop, Object.getOwnPropertyDescriptor(derivedPrototype, prop));
            }
        }
        // Cast to any due to Bug 16188:PropertyDescriptor set and get function should be optional.
        Object.defineProperty(derivedClass.prototype, 'constructor', { value: derivedClass, writable: true, configurable: true, enumerable: true });
    }
    exports.derive = derive;
    /**
     * Calls JSON.Stringify with a replacer to break apart any circular references.
     * This prevents JSON.stringify from throwing the exception
     *  "Uncaught TypeError: Converting circular structure to JSON"
     */
    function safeStringify(obj) {
        var seen = [];
        return JSON.stringify(obj, function (key, value) {
            if (Types.isObject(value) || Array.isArray(value)) {
                if (seen.indexOf(value) !== -1) {
                    return '[Circular]';
                }
                else {
                    seen.push(value);
                }
            }
            return value;
        });
    }
    exports.safeStringify = safeStringify;
    function getOrDefault(obj, fn, defaultValue) {
        if (defaultValue === void 0) { defaultValue = null; }
        var result = fn(obj);
        return typeof result === 'undefined' ? defaultValue : result;
    }
    exports.getOrDefault = getOrDefault;
});

define(__m[29], __M([0,1,18]), function (require, exports, platform) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function _encode(ch) {
        return '%' + ch.charCodeAt(0).toString(16).toUpperCase();
    }
    // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent
    function encodeURIComponent2(str) {
        return encodeURIComponent(str).replace(/[!'()*]/g, _encode);
    }
    function encodeNoop(str) {
        return str;
    }
    /**
     * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
     * This class is a simple parser which creates the basic component paths
     * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
     * and encoding.
     *
     *       foo://example.com:8042/over/there?name=ferret#nose
     *       \_/   \______________/\_________/ \_________/ \__/
     *        |           |            |            |        |
     *     scheme     authority       path        query   fragment
     *        |   _____________________|__
     *       / \ /                        \
     *       urn:example:animal:ferret:nose
     *
     *
     */
    var URI = (function () {
        function URI() {
            this._scheme = URI._empty;
            this._authority = URI._empty;
            this._path = URI._empty;
            this._query = URI._empty;
            this._fragment = URI._empty;
            this._formatted = null;
            this._fsPath = null;
        }
        Object.defineProperty(URI.prototype, "scheme", {
            /**
             * scheme is the 'http' part of 'http://www.msft.com/some/path?query#fragment'.
             * The part before the first colon.
             */
            get: function () {
                return this._scheme;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "authority", {
            /**
             * authority is the 'www.msft.com' part of 'http://www.msft.com/some/path?query#fragment'.
             * The part between the first double slashes and the next slash.
             */
            get: function () {
                return this._authority;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "path", {
            /**
             * path is the '/some/path' part of 'http://www.msft.com/some/path?query#fragment'.
             */
            get: function () {
                return this._path;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "query", {
            /**
             * query is the 'query' part of 'http://www.msft.com/some/path?query#fragment'.
             */
            get: function () {
                return this._query;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "fragment", {
            /**
             * fragment is the 'fragment' part of 'http://www.msft.com/some/path?query#fragment'.
             */
            get: function () {
                return this._fragment;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(URI.prototype, "fsPath", {
            // ---- filesystem path -----------------------
            /**
             * Returns a string representing the corresponding file system path of this URI.
             * Will handle UNC paths and normalize windows drive letters to lower-case. Also
             * uses the platform specific path separator. Will *not* validate the path for
             * invalid characters and semantics. Will *not* look at the scheme of this URI.
             */
            get: function () {
                if (!this._fsPath) {
                    var value;
                    if (this._authority && this.scheme === 'file') {
                        // unc path: file://shares/c$/far/boo
                        value = "//" + this._authority + this._path;
                    }
                    else if (URI._driveLetterPath.test(this._path)) {
                        // windows drive letter: file:///c:/far/boo
                        value = this._path[1].toLowerCase() + this._path.substr(2);
                    }
                    else {
                        // other path
                        value = this._path;
                    }
                    if (platform.isWindows) {
                        value = value.replace(/\//g, '\\');
                    }
                    this._fsPath = value;
                }
                return this._fsPath;
            },
            enumerable: true,
            configurable: true
        });
        // ---- modify to new -------------------------
        URI.prototype.with = function (change) {
            if (!change) {
                return this;
            }
            var scheme = change.scheme || this.scheme;
            var authority = change.authority || this.authority;
            var path = change.path || this.path;
            var query = change.query || this.query;
            var fragment = change.fragment || this.fragment;
            if (scheme === this.scheme
                && authority === this.authority
                && path === this.path
                && query === this.query
                && fragment === this.fragment) {
                return this;
            }
            var ret = new URI();
            ret._scheme = scheme;
            ret._authority = authority;
            ret._path = path;
            ret._query = query;
            ret._fragment = fragment;
            URI._validate(ret);
            return ret;
        };
        // ---- parse & validate ------------------------
        URI.parse = function (value) {
            var ret = new URI();
            var data = URI._parseComponents(value);
            ret._scheme = data.scheme;
            ret._authority = decodeURIComponent(data.authority);
            ret._path = decodeURIComponent(data.path);
            ret._query = decodeURIComponent(data.query);
            ret._fragment = decodeURIComponent(data.fragment);
            URI._validate(ret);
            return ret;
        };
        URI.file = function (path) {
            var ret = new URI();
            ret._scheme = 'file';
            // normalize to fwd-slashes
            path = path.replace(/\\/g, URI._slash);
            // check for authority as used in UNC shares
            // or use the path as given
            if (path[0] === URI._slash && path[0] === path[1]) {
                var idx = path.indexOf(URI._slash, 2);
                if (idx === -1) {
                    ret._authority = path.substring(2);
                }
                else {
                    ret._authority = path.substring(2, idx);
                    ret._path = path.substring(idx);
                }
            }
            else {
                ret._path = path;
            }
            // Ensure that path starts with a slash
            // or that it is at least a slash
            if (ret._path[0] !== URI._slash) {
                ret._path = URI._slash + ret._path;
            }
            URI._validate(ret);
            return ret;
        };
        URI._parseComponents = function (value) {
            var ret = {
                scheme: URI._empty,
                authority: URI._empty,
                path: URI._empty,
                query: URI._empty,
                fragment: URI._empty,
            };
            var match = URI._regexp.exec(value);
            if (match) {
                ret.scheme = match[2] || ret.scheme;
                ret.authority = match[4] || ret.authority;
                ret.path = match[5] || ret.path;
                ret.query = match[7] || ret.query;
                ret.fragment = match[9] || ret.fragment;
            }
            return ret;
        };
        URI.from = function (components) {
            return new URI().with(components);
        };
        URI._validate = function (ret) {
            // validation
            // path, http://tools.ietf.org/html/rfc3986#section-3.3
            // If a URI contains an authority component, then the path component
            // must either be empty or begin with a slash ("/") character.  If a URI
            // does not contain an authority component, then the path cannot begin
            // with two slash characters ("//").
            if (ret.authority && ret.path && ret.path[0] !== '/') {
                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            }
            if (!ret.authority && ret.path.indexOf('//') === 0) {
                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
            }
        };
        // ---- printing/externalize ---------------------------
        /**
         *
         * @param skipEncoding Do not encode the result, default is `false`
         */
        URI.prototype.toString = function (skipEncoding) {
            if (skipEncoding === void 0) { skipEncoding = false; }
            if (!skipEncoding) {
                if (!this._formatted) {
                    this._formatted = URI._asFormatted(this, false);
                }
                return this._formatted;
            }
            else {
                // we don't cache that
                return URI._asFormatted(this, true);
            }
        };
        URI._asFormatted = function (uri, skipEncoding) {
            var encoder = !skipEncoding
                ? encodeURIComponent2
                : encodeNoop;
            var parts = [];
            var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;
            if (scheme) {
                parts.push(scheme, ':');
            }
            if (authority || scheme === 'file') {
                parts.push('//');
            }
            if (authority) {
                authority = authority.toLowerCase();
                var idx = authority.indexOf(':');
                if (idx === -1) {
                    parts.push(encoder(authority));
                }
                else {
                    parts.push(encoder(authority.substr(0, idx)), authority.substr(idx));
                }
            }
            if (path) {
                // lower-case windown drive letters in /C:/fff
                var m = URI._upperCaseDrive.exec(path);
                if (m) {
                    path = m[1] + m[2].toLowerCase() + path.substr(m[1].length + m[2].length);
                }
                // encode every segement but not slashes
                // make sure that # and ? are always encoded
                // when occurring in paths - otherwise the result
                // cannot be parsed back again
                var lastIdx = 0;
                while (true) {
                    var idx = path.indexOf(URI._slash, lastIdx);
                    if (idx === -1) {
                        parts.push(encoder(path.substring(lastIdx)).replace(/[#?]/, _encode));
                        break;
                    }
                    parts.push(encoder(path.substring(lastIdx, idx)).replace(/[#?]/, _encode), URI._slash);
                    lastIdx = idx + 1;
                }
                ;
            }
            if (query) {
                parts.push('?', encoder(query));
            }
            if (fragment) {
                parts.push('#', encoder(fragment));
            }
            return parts.join(URI._empty);
        };
        URI.prototype.toJSON = function () {
            return {
                scheme: this.scheme,
                authority: this.authority,
                path: this.path,
                fsPath: this.fsPath,
                query: this.query,
                fragment: this.fragment,
                external: this.toString(),
                $mid: 1
            };
        };
        URI.revive = function (data) {
            var result = new URI();
            result._scheme = data.scheme;
            result._authority = data.authority;
            result._path = data.path;
            result._query = data.query;
            result._fragment = data.fragment;
            result._fsPath = data.fsPath;
            result._formatted = data.external;
            URI._validate(result);
            return result;
        };
        URI._empty = '';
        URI._slash = '/';
        URI._regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
        URI._driveLetterPath = /^\/[a-zA-z]:/;
        URI._upperCaseDrive = /^(\/)?([A-Z]:)/;
        return URI;
    }());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = URI;
});

define(__m[268], __M([0,1,29]), function (require, exports, uri_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function stringify(obj) {
        return JSON.stringify(obj, replacer);
    }
    exports.stringify = stringify;
    function parse(text) {
        return JSON.parse(text, reviver);
    }
    exports.parse = parse;
    function replacer(key, value) {
        // URI is done via toJSON-member
        if (value instanceof RegExp) {
            return {
                $mid: 2,
                source: value.source,
                flags: (value.global ? 'g' : '') + (value.ignoreCase ? 'i' : '') + (value.multiline ? 'm' : ''),
            };
        }
        return value;
    }
    function reviver(key, value) {
        var marshallingConst;
        if (value !== void 0 && value !== null) {
            marshallingConst = value.$mid;
        }
        if (marshallingConst === 1) {
            return uri_1.default.revive(value);
        }
        else if (marshallingConst === 2) {
            return new RegExp(value.source, value.flags);
        }
        else {
            return value;
        }
    }
});






define(__m[130], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ValueUUID = (function () {
        function ValueUUID(_value) {
            this._value = _value;
            // empty
        }
        ValueUUID.prototype.asHex = function () {
            return this._value;
        };
        ValueUUID.prototype.equals = function (other) {
            return this.asHex() === other.asHex();
        };
        return ValueUUID;
    }());
    var V4UUID = (function (_super) {
        __extends(V4UUID, _super);
        function V4UUID() {
            _super.call(this, [
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                '4',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._oneOf(V4UUID._timeHighBits),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                '-',
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
                V4UUID._randomHex(),
            ].join(''));
        }
        V4UUID._oneOf = function (array) {
            var idx = Math.floor(array.length * Math.random());
            return array[idx];
        };
        V4UUID._randomHex = function () {
            return V4UUID._oneOf(V4UUID._chars);
        };
        V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
        return V4UUID;
    }(ValueUUID));
    /**
     * An empty UUID that contains only zeros.
     */
    exports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');
    function v4() {
        return new V4UUID();
    }
    exports.v4 = v4;
    var _UUIDPattern = /^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$/;
    /**
     * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
     * @param value A uuid string.
     */
    function parse(value) {
        if (!_UUIDPattern.test(value)) {
            throw new Error('invalid uuid');
        }
        return new ValueUUID(value);
    }
    exports.parse = parse;
    function generateUuid() {
        return v4().asHex();
    }
    exports.generateUuid = generateUuid;
});

/**
 * Extracted from https://github.com/winjs/winjs
 * Version: 4.4.0(ec3258a9f3a36805a187848984e3bb938044178d)
 * Copyright (c) Microsoft Corporation.
 * All Rights Reserved.
 * Licensed under the MIT License.
 */
(function() {

var _modules = {};
_modules["WinJS/Core/_WinJS"] = {};

var _winjs = function(moduleId, deps, factory) {
    var exports = {};
    var exportsPassedIn = false;

    var depsValues = deps.map(function(dep) {
        if (dep === 'exports') {
            exportsPassedIn = true;
            return exports;
        }
        return _modules[dep];
    });

    var result = factory.apply({}, depsValues);

    _modules[moduleId] = exportsPassedIn ? exports : result;
};


_winjs("WinJS/Core/_Global", [], function () {
    "use strict";

    // Appease jshint
    /* global window, self, global */

    var globalObject =
        typeof window !== 'undefined' ? window :
        typeof self !== 'undefined' ? self :
        typeof global !== 'undefined' ? global :
        {};
    return globalObject;
});

_winjs("WinJS/Core/_BaseCoreUtils", ["WinJS/Core/_Global"], function baseCoreUtilsInit(_Global) {
    "use strict";

    var hasWinRT = !!_Global.Windows;

    function markSupportedForProcessing(func) {
        /// <signature helpKeyword="WinJS.Utilities.markSupportedForProcessing">
        /// <summary locid="WinJS.Utilities.markSupportedForProcessing">
        /// Marks a function as being compatible with declarative processing, such as WinJS.UI.processAll
        /// or WinJS.Binding.processAll.
        /// </summary>
        /// <param name="func" type="Function" locid="WinJS.Utilities.markSupportedForProcessing_p:func">
        /// The function to be marked as compatible with declarative processing.
        /// </param>
        /// <returns type="Function" locid="WinJS.Utilities.markSupportedForProcessing_returnValue">
        /// The input function.
        /// </returns>
        /// </signature>
        func.supportedForProcessing = true;
        return func;
    }

    return {
        hasWinRT: hasWinRT,
        markSupportedForProcessing: markSupportedForProcessing,
        _setImmediate: _Global.setImmediate ? _Global.setImmediate.bind(_Global) : function (handler) {
            _Global.setTimeout(handler, 0);
        }
    };
});
_winjs("WinJS/Core/_WriteProfilerMark", ["WinJS/Core/_Global"], function profilerInit(_Global) {
    "use strict";

    return _Global.msWriteProfilerMark || function () { };
});
_winjs("WinJS/Core/_Base", ["WinJS/Core/_WinJS","WinJS/Core/_Global","WinJS/Core/_BaseCoreUtils","WinJS/Core/_WriteProfilerMark"], function baseInit(_WinJS, _Global, _BaseCoreUtils, _WriteProfilerMark) {
    "use strict";

    function initializeProperties(target, members, prefix) {
        var keys = Object.keys(members);
        var isArray = Array.isArray(target);
        var properties;
        var i, len;
        for (i = 0, len = keys.length; i < len; i++) {
            var key = keys[i];
            var enumerable = key.charCodeAt(0) !== /*_*/95;
            var member = members[key];
            if (member && typeof member === 'object') {
                if (member.value !== undefined || typeof member.get === 'function' || typeof member.set === 'function') {
                    if (member.enumerable === undefined) {
                        member.enumerable = enumerable;
                    }
                    if (prefix && member.setName && typeof member.setName === 'function') {
                        member.setName(prefix + "." + key);
                    }
                    properties = properties || {};
                    properties[key] = member;
                    continue;
                }
            }
            if (!enumerable) {
                properties = properties || {};
                properties[key] = { value: member, enumerable: enumerable, configurable: true, writable: true };
                continue;
            }
            if (isArray) {
                target.forEach(function (target) {
                    target[key] = member;
                });
            } else {
                target[key] = member;
            }
        }
        if (properties) {
            if (isArray) {
                target.forEach(function (target) {
                    Object.defineProperties(target, properties);
                });
            } else {
                Object.defineProperties(target, properties);
            }
        }
    }

    (function () {

        var _rootNamespace = _WinJS;
        if (!_rootNamespace.Namespace) {
            _rootNamespace.Namespace = Object.create(Object.prototype);
        }

        function createNamespace(parentNamespace, name) {
            var currentNamespace = parentNamespace || {};
            if (name) {
                var namespaceFragments = name.split(".");
                if (currentNamespace === _Global && namespaceFragments[0] === "WinJS") {
                    currentNamespace = _WinJS;
                    namespaceFragments.splice(0, 1);
                }
                for (var i = 0, len = namespaceFragments.length; i < len; i++) {
                    var namespaceName = namespaceFragments[i];
                    if (!currentNamespace[namespaceName]) {
                        Object.defineProperty(currentNamespace, namespaceName,
                            { value: {}, writable: false, enumerable: true, configurable: true }
                        );
                    }
                    currentNamespace = currentNamespace[namespaceName];
                }
            }
            return currentNamespace;
        }

        function defineWithParent(parentNamespace, name, members) {
            /// <signature helpKeyword="WinJS.Namespace.defineWithParent">
            /// <summary locid="WinJS.Namespace.defineWithParent">
            /// Defines a new namespace with the specified name under the specified parent namespace.
            /// </summary>
            /// <param name="parentNamespace" type="Object" locid="WinJS.Namespace.defineWithParent_p:parentNamespace">
            /// The parent namespace.
            /// </param>
            /// <param name="name" type="String" locid="WinJS.Namespace.defineWithParent_p:name">
            /// The name of the new namespace.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.defineWithParent_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.defineWithParent_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            var currentNamespace = createNamespace(parentNamespace, name);

            if (members) {
                initializeProperties(currentNamespace, members, name || "<ANONYMOUS>");
            }

            return currentNamespace;
        }

        function define(name, members) {
            /// <signature helpKeyword="WinJS.Namespace.define">
            /// <summary locid="WinJS.Namespace.define">
            /// Defines a new namespace with the specified name.
            /// </summary>
            /// <param name="name" type="String" locid="WinJS.Namespace.define_p:name">
            /// The name of the namespace. This could be a dot-separated name for nested namespaces.
            /// </param>
            /// <param name="members" type="Object" locid="WinJS.Namespace.define_p:members">
            /// The members of the new namespace.
            /// </param>
            /// <returns type="Object" locid="WinJS.Namespace.define_returnValue">
            /// The newly-defined namespace.
            /// </returns>
            /// </signature>
            return defineWithParent(_Global, name, members);
        }

        var LazyStates = {
            uninitialized: 1,
            working: 2,
            initialized: 3,
        };

        function lazy(f) {
            var name;
            var state = LazyStates.uninitialized;
            var result;
            return {
                setName: function (value) {
                    name = value;
                },
                get: function () {
                    switch (state) {
                        case LazyStates.initialized:
                            return result;

                        case LazyStates.uninitialized:
                            state = LazyStates.working;
                            try {
                                _WriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StartTM");
                                result = f();
                            } finally {
                                _WriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StopTM");
                                state = LazyStates.uninitialized;
                            }
                            f = null;
                            state = LazyStates.initialized;
                            return result;

                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";

                        default:
                            throw "Illegal";
                    }
                },
                set: function (value) {
                    switch (state) {
                        case LazyStates.working:
                            throw "Illegal: reentrancy on initialization";

                        default:
                            state = LazyStates.initialized;
                            result = value;
                            break;
                    }
                },
                enumerable: true,
                configurable: true,
            };
        }

        // helper for defining AMD module members
        function moduleDefine(exports, name, members) {
            var target = [exports];
            var publicNS = null;
            if (name) {
                publicNS = createNamespace(_Global, name);
                target.push(publicNS);
            }
            initializeProperties(target, members, name || "<ANONYMOUS>");
            return publicNS;
        }

        // Establish members of the "WinJS.Namespace" namespace
        Object.defineProperties(_rootNamespace.Namespace, {

            defineWithParent: { value: defineWithParent, writable: true, enumerable: true, configurable: true },

            define: { value: define, writable: true, enumerable: true, configurable: true },

            _lazy: { value: lazy, writable: true, enumerable: true, configurable: true },

            _moduleDefine: { value: moduleDefine, writable: true, enumerable: true, configurable: true }

        });

    })();

    (function () {

        function define(constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.define">
            /// <summary locid="WinJS.Class.define">
            /// Defines a class using the given constructor and the specified instance members.
            /// </summary>
            /// <param name="constructor" type="Function" locid="WinJS.Class.define_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.define_p:instanceMembers">
            /// The set of instance fields, properties, and methods made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.define_p:staticMembers">
            /// The set of static fields, properties, and methods made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.define_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            _BaseCoreUtils.markSupportedForProcessing(constructor);
            if (instanceMembers) {
                initializeProperties(constructor.prototype, instanceMembers);
            }
            if (staticMembers) {
                initializeProperties(constructor, staticMembers);
            }
            return constructor;
        }

        function derive(baseClass, constructor, instanceMembers, staticMembers) {
            /// <signature helpKeyword="WinJS.Class.derive">
            /// <summary locid="WinJS.Class.derive">
            /// Creates a sub-class based on the supplied baseClass parameter, using prototypal inheritance.
            /// </summary>
            /// <param name="baseClass" type="Function" locid="WinJS.Class.derive_p:baseClass">
            /// The class to inherit from.
            /// </param>
            /// <param name="constructor" type="Function" locid="WinJS.Class.derive_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <param name="instanceMembers" type="Object" locid="WinJS.Class.derive_p:instanceMembers">
            /// The set of instance fields, properties, and methods to be made available on the class.
            /// </param>
            /// <param name="staticMembers" type="Object" locid="WinJS.Class.derive_p:staticMembers">
            /// The set of static fields, properties, and methods to be made available on the class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.derive_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            if (baseClass) {
                constructor = constructor || function () { };
                var basePrototype = baseClass.prototype;
                constructor.prototype = Object.create(basePrototype);
                _BaseCoreUtils.markSupportedForProcessing(constructor);
                Object.defineProperty(constructor.prototype, "constructor", { value: constructor, writable: true, configurable: true, enumerable: true });
                if (instanceMembers) {
                    initializeProperties(constructor.prototype, instanceMembers);
                }
                if (staticMembers) {
                    initializeProperties(constructor, staticMembers);
                }
                return constructor;
            } else {
                return define(constructor, instanceMembers, staticMembers);
            }
        }

        function mix(constructor) {
            /// <signature helpKeyword="WinJS.Class.mix">
            /// <summary locid="WinJS.Class.mix">
            /// Defines a class using the given constructor and the union of the set of instance members
            /// specified by all the mixin objects. The mixin parameter list is of variable length.
            /// </summary>
            /// <param name="constructor" locid="WinJS.Class.mix_p:constructor">
            /// A constructor function that is used to instantiate this class.
            /// </param>
            /// <returns type="Function" locid="WinJS.Class.mix_returnValue">
            /// The newly-defined class.
            /// </returns>
            /// </signature>
            constructor = constructor || function () { };
            var i, len;
            for (i = 1, len = arguments.length; i < len; i++) {
                initializeProperties(constructor.prototype, arguments[i]);
            }
            return constructor;
        }

        // Establish members of "WinJS.Class" namespace
        _WinJS.Namespace.define("WinJS.Class", {
            define: define,
            derive: derive,
            mix: mix
        });

    })();

    return {
        Namespace: _WinJS.Namespace,
        Class: _WinJS.Class
    };

});
_winjs("WinJS/Core/_ErrorFromName", ["WinJS/Core/_Base"], function errorsInit(_Base) {
    "use strict";

    var ErrorFromName = _Base.Class.derive(Error, function (name, message) {
        /// <signature helpKeyword="WinJS.ErrorFromName">
        /// <summary locid="WinJS.ErrorFromName">
        /// Creates an Error object with the specified name and message properties.
        /// </summary>
        /// <param name="name" type="String" locid="WinJS.ErrorFromName_p:name">The name of this error. The name is meant to be consumed programmatically and should not be localized.</param>
        /// <param name="message" type="String" optional="true" locid="WinJS.ErrorFromName_p:message">The message for this error. The message is meant to be consumed by humans and should be localized.</param>
        /// <returns type="Error" locid="WinJS.ErrorFromName_returnValue">Error instance with .name and .message properties populated</returns>
        /// </signature>
        this.name = name;
        this.message = message || name;
    }, {
        /* empty */
    }, {
        supportedForProcessing: false,
    });

    _Base.Namespace.define("WinJS", {
        // ErrorFromName establishes a simple pattern for returning error codes.
        //
        ErrorFromName: ErrorFromName
    });

    return ErrorFromName;

});


_winjs("WinJS/Core/_Events", ["exports","WinJS/Core/_Base"], function eventsInit(exports, _Base) {
    "use strict";


    function createEventProperty(name) {
        var eventPropStateName = "_on" + name + "state";

        return {
            get: function () {
                var state = this[eventPropStateName];
                return state && state.userHandler;
            },
            set: function (handler) {
                var state = this[eventPropStateName];
                if (handler) {
                    if (!state) {
                        state = { wrapper: function (evt) { return state.userHandler(evt); }, userHandler: handler };
                        Object.defineProperty(this, eventPropStateName, { value: state, enumerable: false, writable:true, configurable: true });
                        this.addEventListener(name, state.wrapper, false);
                    }
                    state.userHandler = handler;
                } else if (state) {
                    this.removeEventListener(name, state.wrapper, false);
                    this[eventPropStateName] = null;
                }
            },
            enumerable: true
        };
    }

    function createEventProperties() {
        /// <signature helpKeyword="WinJS.Utilities.createEventProperties">
        /// <summary locid="WinJS.Utilities.createEventProperties">
        /// Creates an object that has one property for each name passed to the function.
        /// </summary>
        /// <param name="events" locid="WinJS.Utilities.createEventProperties_p:events">
        /// A variable list of property names.
        /// </param>
        /// <returns type="Object" locid="WinJS.Utilities.createEventProperties_returnValue">
        /// The object with the specified properties. The names of the properties are prefixed with 'on'.
        /// </returns>
        /// </signature>
        var props = {};
        for (var i = 0, len = arguments.length; i < len; i++) {
            var name = arguments[i];
            props["on" + name] = createEventProperty(name);
        }
        return props;
    }

    var EventMixinEvent = _Base.Class.define(
        function EventMixinEvent_ctor(type, detail, target) {
            this.detail = detail;
            this.target = target;
            this.timeStamp = Date.now();
            this.type = type;
        },
        {
            bubbles: { value: false, writable: false },
            cancelable: { value: false, writable: false },
            currentTarget: {
                get: function () { return this.target; }
            },
            defaultPrevented: {
                get: function () { return this._preventDefaultCalled; }
            },
            trusted: { value: false, writable: false },
            eventPhase: { value: 0, writable: false },
            target: null,
            timeStamp: null,
            type: null,

            preventDefault: function () {
                this._preventDefaultCalled = true;
            },
            stopImmediatePropagation: function () {
                this._stopImmediatePropagationCalled = true;
            },
            stopPropagation: function () {
            }
        }, {
            supportedForProcessing: false,
        }
    );

    var eventMixin = {
        _listeners: null,

        addEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.addEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.addEventListener">
            /// Adds an event listener to the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.addEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.addEventListener_p:listener">
            /// The listener to invoke when the event is raised.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.addEventListener_p:useCapture">
            /// if true initiates capture, otherwise false.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            this._listeners = this._listeners || {};
            var eventListeners = (this._listeners[type] = this._listeners[type] || []);
            for (var i = 0, len = eventListeners.length; i < len; i++) {
                var l = eventListeners[i];
                if (l.useCapture === useCapture && l.listener === listener) {
                    return;
                }
            }
            eventListeners.push({ listener: listener, useCapture: useCapture });
        },
        dispatchEvent: function (type, details) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.dispatchEvent">
            /// <summary locid="WinJS.Utilities.eventMixin.dispatchEvent">
            /// Raises an event of the specified type and with the specified additional properties.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="details" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:details">
            /// The set of additional properties to be attached to the event object when the event is raised.
            /// </param>
            /// <returns type="Boolean" locid="WinJS.Utilities.eventMixin.dispatchEvent_returnValue">
            /// true if preventDefault was called on the event.
            /// </returns>
            /// </signature>
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                var eventValue = new EventMixinEvent(type, details, this);
                // Need to copy the array to protect against people unregistering while we are dispatching
                listeners = listeners.slice(0, listeners.length);
                for (var i = 0, len = listeners.length; i < len && !eventValue._stopImmediatePropagationCalled; i++) {
                    listeners[i].listener(eventValue);
                }
                return eventValue.defaultPrevented || false;
            }
            return false;
        },
        removeEventListener: function (type, listener, useCapture) {
            /// <signature helpKeyword="WinJS.Utilities.eventMixin.removeEventListener">
            /// <summary locid="WinJS.Utilities.eventMixin.removeEventListener">
            /// Removes an event listener from the control.
            /// </summary>
            /// <param name="type" locid="WinJS.Utilities.eventMixin.removeEventListener_p:type">
            /// The type (name) of the event.
            /// </param>
            /// <param name="listener" locid="WinJS.Utilities.eventMixin.removeEventListener_p:listener">
            /// The listener to remove.
            /// </param>
            /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.removeEventListener_p:useCapture">
            /// Specifies whether to initiate capture.
            /// </param>
            /// </signature>
            useCapture = useCapture || false;
            var listeners = this._listeners && this._listeners[type];
            if (listeners) {
                for (var i = 0, len = listeners.length; i < len; i++) {
                    var l = listeners[i];
                    if (l.listener === listener && l.useCapture === useCapture) {
                        listeners.splice(i, 1);
                        if (listeners.length === 0) {
                            delete this._listeners[type];
                        }
                        // Only want to remove one element for each call to removeEventListener
                        break;
                    }
                }
            }
        }
    };

    _Base.Namespace._moduleDefine(exports, "WinJS.Utilities", {
        _createEventProperty: createEventProperty,
        createEventProperties: createEventProperties,
        eventMixin: eventMixin
    });

});


_winjs("WinJS/Core/_Trace", ["WinJS/Core/_Global"], function traceInit(_Global) {
    "use strict";

    function nop(v) {
        return v;
    }

    return {
        _traceAsyncOperationStarting: (_Global.Debug && _Global.Debug.msTraceAsyncOperationStarting && _Global.Debug.msTraceAsyncOperationStarting.bind(_Global.Debug)) || nop,
        _traceAsyncOperationCompleted: (_Global.Debug && _Global.Debug.msTraceAsyncOperationCompleted && _Global.Debug.msTraceAsyncOperationCompleted.bind(_Global.Debug)) || nop,
        _traceAsyncCallbackStarting: (_Global.Debug && _Global.Debug.msTraceAsyncCallbackStarting && _Global.Debug.msTraceAsyncCallbackStarting.bind(_Global.Debug)) || nop,
        _traceAsyncCallbackCompleted: (_Global.Debug && _Global.Debug.msTraceAsyncCallbackCompleted && _Global.Debug.msTraceAsyncCallbackCompleted.bind(_Global.Debug)) || nop
    };
});
_winjs("WinJS/Promise/_StateMachine", ["WinJS/Core/_Global","WinJS/Core/_BaseCoreUtils","WinJS/Core/_Base","WinJS/Core/_ErrorFromName","WinJS/Core/_Events","WinJS/Core/_Trace"], function promiseStateMachineInit(_Global, _BaseCoreUtils, _Base, _ErrorFromName, _Events, _Trace) {
    "use strict";

    _Global.Debug && (_Global.Debug.setNonUserCodeExceptions = true);

    var ListenerType = _Base.Class.mix(_Base.Class.define(null, { /*empty*/ }, { supportedForProcessing: false }), _Events.eventMixin);
    var promiseEventListeners = new ListenerType();
    // make sure there is a listeners collection so that we can do a more trivial check below
    promiseEventListeners._listeners = {};
    var errorET = "error";
    var canceledName = "Canceled";
    var tagWithStack = false;
    var tag = {
        promise: 0x01,
        thenPromise: 0x02,
        errorPromise: 0x04,
        exceptionPromise: 0x08,
        completePromise: 0x10,
    };
    tag.all = tag.promise | tag.thenPromise | tag.errorPromise | tag.exceptionPromise | tag.completePromise;

    //
    // Global error counter, for each error which enters the system we increment this once and then
    // the error number travels with the error as it traverses the tree of potential handlers.
    //
    // When someone has registered to be told about errors (WinJS.Promise.callonerror) promises
    // which are in error will get tagged with a ._errorId field. This tagged field is the
    // contract by which nested promises with errors will be identified as chaining for the
    // purposes of the callonerror semantics. If a nested promise in error is encountered without
    // a ._errorId it will be assumed to be foreign and treated as an interop boundary and
    // a new error id will be minted.
    //
    var error_number = 1;

    //
    // The state machine has a interesting hiccup in it with regards to notification, in order
    // to flatten out notification and avoid recursion for synchronous completion we have an
    // explicit set of *_notify states which are responsible for notifying their entire tree
    // of children. They can do this because they know that immediate children are always
    // ThenPromise instances and we can therefore reach into their state to access the
    // _listeners collection.
    //
    // So, what happens is that a Promise will be fulfilled through the _completed or _error
    // messages at which point it will enter a *_notify state and be responsible for to move
    // its children into an (as appropriate) success or error state and also notify that child's
    // listeners of the state transition, until leaf notes are reached.
    //

    var state_created,              // -> working
        state_working,              // -> error | error_notify | success | success_notify | canceled | waiting
        state_waiting,              // -> error | error_notify | success | success_notify | waiting_canceled
        state_waiting_canceled,     // -> error | error_notify | success | success_notify | canceling
        state_canceled,             // -> error | error_notify | success | success_notify | canceling
        state_canceling,            // -> error_notify
        state_success_notify,       // -> success
        state_success,              // -> .
        state_error_notify,         // -> error
        state_error;                // -> .

    // Noop function, used in the various states to indicate that they don't support a given
    // message. Named with the somewhat cute name '_' because it reads really well in the states.

    function _() { }

    // Initial state
    //
    state_created = {
        name: "created",
        enter: function (promise) {
            promise._setState(state_working);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Ready state, waiting for a message (completed/error/progress), able to be canceled
    //
    state_working = {
        name: "working",
        enter: _,
        cancel: function (promise) {
            promise._setState(state_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting state, if a promise is completed with a value which is itself a promise
    // (has a then() method) it signs up to be informed when that child promise is
    // fulfilled at which point it will be fulfilled with that value.
    //
    state_waiting = {
        name: "waiting",
        enter: function (promise) {
            var waitedUpon = promise._value;
            // We can special case our own intermediate promises which are not in a
            //  terminal state by just pushing this promise as a listener without
            //  having to create new indirection functions
            if (waitedUpon instanceof ThenPromise &&
                waitedUpon._state !== state_error &&
                waitedUpon._state !== state_success) {
                pushListener(waitedUpon, { promise: promise });
            } else {
                var error = function (value) {
                    if (waitedUpon._errorId) {
                        promise._chainedError(value, waitedUpon);
                    } else {
                        // Because this is an interop boundary we want to indicate that this
                        //  error has been handled by the promise infrastructure before we
                        //  begin a new handling chain.
                        //
                        callonerror(promise, value, detailsForHandledError, waitedUpon, error);
                        promise._error(value);
                    }
                };
                error.handlesOnError = true;
                waitedUpon.then(
                    promise._completed.bind(promise),
                    error,
                    promise._progress.bind(promise)
                );
            }
        },
        cancel: function (promise) {
            promise._setState(state_waiting_canceled);
        },
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Waiting canceled state, when a promise has been in a waiting state and receives a
    // request to cancel its pending work it will forward that request to the child promise
    // and then waits to be informed of the result. This promise moves itself into the
    // canceling state but understands that the child promise may instead push it to a
    // different state.
    //
    state_waiting_canceled = {
        name: "waiting_canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. Triggering a cancel on the promise
            // that we are waiting upon may result in a different state transition
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            var waitedUpon = promise._value;
            if (waitedUpon.cancel) {
                waitedUpon.cancel();
            }
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceled state, moves to the canceling state and then tells the promise to do
    // whatever it might need to do on cancelation.
    //
    state_canceled = {
        name: "canceled",
        enter: function (promise) {
            // Initiate a transition to canceling. The _cancelAction may change the state
            // before the state machine pump runs again.
            promise._setState(state_canceling);
            promise._cancelAction();
        },
        cancel: _,
        done: done,
        then: then,
        _completed: completed,
        _error: error,
        _notify: _,
        _progress: progress,
        _setCompleteValue: setCompleteValue,
        _setErrorValue: setErrorValue
    };

    // Canceling state, commits to the promise moving to an error state with an error
    // object whose 'name' and 'message' properties contain the string "Canceled"
    //
    state_canceling = {
        name: "canceling",
        enter: function (promise) {
            var error = new Error(canceledName);
            error.name = error.message;
            promise._value = error;
            promise._setState(state_error_notify);
        },
        cancel: _,
        done: _,
        then: _,
        _completed: _,
        _error: _,
        _notify: _,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success notify state, moves a promise to the success state and notifies all children
    //
    state_success_notify = {
        name: "complete_notify",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_success);
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Success state, moves a promise to the success state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_success = {
        name: "success",
        enter: function (promise) {
            promise.done = CompletePromise.prototype.done;
            promise.then = CompletePromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here */
        then: null, /*error to get here */
        _completed: _,
        _error: _,
        _notify: notifySuccess,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error notify state, moves a promise to the error state and notifies all children
    //
    state_error_notify = {
        name: "error_notify",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            if (promise._listeners) {
                var queue = [promise];
                var p;
                while (queue.length) {
                    p = queue.shift();
                    p._state._notify(p, queue);
                }
            }
            promise._setState(state_error);
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    // Error state, moves a promise to the error state and does NOT notify any children.
    // Some upstream promise is owning the notification pass.
    //
    state_error = {
        name: "error",
        enter: function (promise) {
            promise.done = ErrorPromise.prototype.done;
            promise.then = ErrorPromise.prototype.then;
            promise._cleanupAction();
        },
        cancel: _,
        done: null, /*error to get here*/
        then: null, /*error to get here*/
        _completed: _,
        _error: _,
        _notify: notifyError,
        _progress: _,
        _setCompleteValue: _,
        _setErrorValue: _
    };

    //
    // The statemachine implementation follows a very particular pattern, the states are specified
    // as static stateless bags of functions which are then indirected through the state machine
    // instance (a Promise). As such all of the functions on each state have the promise instance
    // passed to them explicitly as a parameter and the Promise instance members do a little
    // dance where they indirect through the state and insert themselves in the argument list.
    //
    // We could instead call directly through the promise states however then every caller
    // would have to remember to do things like pumping the state machine to catch state transitions.
    //

    var PromiseStateMachine = _Base.Class.define(null, {
        _listeners: null,
        _nextState: null,
        _state: null,
        _value: null,

        cancel: function () {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
            /// <summary locid="WinJS.PromiseStateMachine.cancel">
            /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
            /// already been fulfilled and cancellation is supported, the promise enters
            /// the error state with a value of Error("Canceled").
            /// </summary>
            /// </signature>
            this._state.cancel(this);
            this._run();
        },
        done: function Promise_done(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
            /// <summary locid="WinJS.PromiseStateMachine.done">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            ///
            /// After the handlers have finished executing, this function throws any error that would have been returned
            /// from then() as a promise in the error state.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The fulfilled value is passed as the single argument. If the value is null,
            /// the fulfilled value is returned. The value returned
            /// from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while executing the function, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function is the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
            /// the function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// </signature>
            this._state.done(this, onComplete, onError, onProgress);
        },
        then: function Promise_then(onComplete, onError, onProgress) {
            /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
            /// <summary locid="WinJS.PromiseStateMachine.then">
            /// Allows you to specify the work to be done on the fulfillment of the promised value,
            /// the error handling to be performed if the promise fails to fulfill
            /// a value, and the handling of progress notifications along the way.
            /// </summary>
            /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
            /// The function to be called if the promise is fulfilled successfully with a value.
            /// The value is passed as the single argument. If the value is null, the value is returned.
            /// The value returned from the function becomes the fulfilled value of the promise returned by
            /// then(). If an exception is thrown while this function is being executed, the promise returned
            /// by then() moves into the error state.
            /// </param>
            /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
            /// The function to be called if the promise is fulfilled with an error. The error
            /// is passed as the single argument. If it is null, the error is forwarded.
            /// The value returned from the function becomes the fulfilled value of the promise returned by then().
            /// </param>
            /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
            /// The function to be called if the promise reports progress. Data about the progress
            /// is passed as the single argument. Promises are not required to support
            /// progress.
            /// </param>
            /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
            /// The promise whose value is the result of executing the complete or
            /// error function.
            /// </returns>
            /// </signature>
            return this._state.then(this, onComplete, onError, onProgress);
        },

        _chainedError: function (value, context) {
            var result = this._state._error(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _completed: function (value) {
            var result = this._state._completed(this, value);
            this._run();
            return result;
        },
        _error: function (value) {
            var result = this._state._error(this, value, detailsForError);
            this._run();
            return result;
        },
        _progress: function (value) {
            this._state._progress(this, value);
        },
        _setState: function (state) {
            this._nextState = state;
        },
        _setCompleteValue: function (value) {
            this._state._setCompleteValue(this, value);
            this._run();
        },
        _setChainedErrorValue: function (value, context) {
            var result = this._state._setErrorValue(this, value, detailsForChainedError, context);
            this._run();
            return result;
        },
        _setExceptionValue: function (value) {
            var result = this._state._setErrorValue(this, value, detailsForException);
            this._run();
            return result;
        },
        _run: function () {
            while (this._nextState) {
                this._state = this._nextState;
                this._nextState = null;
                this._state.enter(this);
            }
        }
    }, {
        supportedForProcessing: false
    });

    //
    // Implementations of shared state machine code.
    //

    function completed(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success_notify;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function createErrorDetails(exception, error, promise, id, parent, handler) {
        return {
            exception: exception,
            error: error,
            promise: promise,
            handler: handler,
            id: id,
            parent: parent
        };
    }
    function detailsForHandledError(promise, errorValue, context, handler) {
        var exception = context._isException;
        var errorId = context._errorId;
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context,
            handler
        );
    }
    function detailsForChainedError(promise, errorValue, context) {
        var exception = context._isException;
        var errorId = context._errorId;
        setErrorInfo(promise, errorId, exception);
        return createErrorDetails(
            exception ? errorValue : null,
            exception ? null : errorValue,
            promise,
            errorId,
            context
        );
    }
    function detailsForError(promise, errorValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId);
        return createErrorDetails(
            null,
            errorValue,
            promise,
            errorId
        );
    }
    function detailsForException(promise, exceptionValue) {
        var errorId = ++error_number;
        setErrorInfo(promise, errorId, true);
        return createErrorDetails(
            exceptionValue,
            null,
            promise,
            errorId
        );
    }
    function done(promise, onComplete, onError, onProgress) {
        var asyncOpID = _Trace._traceAsyncOperationStarting("WinJS.Promise.done");
        pushListener(promise, { c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
    }
    function error(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error_notify);
    }
    function notifySuccess(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onComplete = listener.c;
            var target = listener.promise;

            _Trace._traceAsyncOperationCompleted(listener.asyncOpID, _Global.Debug && _Global.Debug.MS_ASYNC_OP_STATUS_SUCCESS);

            if (target) {
                _Trace._traceAsyncCallbackStarting(listener.asyncOpID);
                try {
                    target._setCompleteValue(onComplete ? onComplete(value) : value);
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                    _Trace._traceAsyncCallbackCompleted();
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                CompletePromise.prototype.done.call(promise, onComplete);
            }
        }
    }
    function notifyError(promise, queue) {
        var value = promise._value;
        var listeners = promise._listeners;
        if (!listeners) {
            return;
        }
        promise._listeners = null;
        var i, len;
        for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
            var listener = len === 1 ? listeners : listeners[i];
            var onError = listener.e;
            var target = listener.promise;

            var errorID = _Global.Debug && (value && value.name === canceledName ? _Global.Debug.MS_ASYNC_OP_STATUS_CANCELED : _Global.Debug.MS_ASYNC_OP_STATUS_ERROR);
            _Trace._traceAsyncOperationCompleted(listener.asyncOpID, errorID);

            if (target) {
                var asyncCallbackStarted = false;
                try {
                    if (onError) {
                        _Trace._traceAsyncCallbackStarting(listener.asyncOpID);
                        asyncCallbackStarted = true;
                        if (!onError.handlesOnError) {
                            callonerror(target, value, detailsForHandledError, promise, onError);
                        }
                        target._setCompleteValue(onError(value));
                    } else {
                        target._setChainedErrorValue(value, promise);
                    }
                } catch (ex) {
                    target._setExceptionValue(ex);
                } finally {
                    if (asyncCallbackStarted) {
                        _Trace._traceAsyncCallbackCompleted();
                    }
                }
                if (target._state !== state_waiting && target._listeners) {
                    queue.push(target);
                }
            } else {
                ErrorPromise.prototype.done.call(promise, null, onError);
            }
        }
    }
    function callonerror(promise, value, onerrorDetailsGenerator, context, handler) {
        if (promiseEventListeners._listeners[errorET]) {
            if (value instanceof Error && value.message === canceledName) {
                return;
            }
            promiseEventListeners.dispatchEvent(errorET, onerrorDetailsGenerator(promise, value, context, handler));
        }
    }
    function progress(promise, value) {
        var listeners = promise._listeners;
        if (listeners) {
            var i, len;
            for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
                var listener = len === 1 ? listeners : listeners[i];
                var onProgress = listener.p;
                if (onProgress) {
                    try { onProgress(value); } catch (ex) { }
                }
                if (!(listener.c || listener.e) && listener.promise) {
                    listener.promise._progress(value);
                }
            }
        }
    }
    function pushListener(promise, listener) {
        var listeners = promise._listeners;
        if (listeners) {
            // We may have either a single listener (which will never be wrapped in an array)
            // or 2+ listeners (which will be wrapped). Since we are now adding one more listener
            // we may have to wrap the single listener before adding the second.
            listeners = Array.isArray(listeners) ? listeners : [listeners];
            listeners.push(listener);
        } else {
            listeners = listener;
        }
        promise._listeners = listeners;
    }
    // The difference beween setCompleteValue()/setErrorValue() and complete()/error() is that setXXXValue() moves
    // a promise directly to the success/error state without starting another notification pass (because one
    // is already ongoing).
    function setErrorInfo(promise, errorId, isException) {
        promise._isException = isException || false;
        promise._errorId = errorId;
    }
    function setErrorValue(promise, value, onerrorDetails, context) {
        promise._value = value;
        callonerror(promise, value, onerrorDetails, context);
        promise._setState(state_error);
    }
    function setCompleteValue(promise, value) {
        var targetState;
        if (value && typeof value === "object" && typeof value.then === "function") {
            targetState = state_waiting;
        } else {
            targetState = state_success;
        }
        promise._value = value;
        promise._setState(targetState);
    }
    function then(promise, onComplete, onError, onProgress) {
        var result = new ThenPromise(promise);
        var asyncOpID = _Trace._traceAsyncOperationStarting("WinJS.Promise.then");
        pushListener(promise, { promise: result, c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
        return result;
    }

    //
    // Internal implementation detail promise, ThenPromise is created when a promise needs
    // to be returned from a then() method.
    //
    var ThenPromise = _Base.Class.derive(PromiseStateMachine,
        function (creator) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.thenPromise))) {
                this._stack = Promise._getStack();
            }

            this._creator = creator;
            this._setState(state_created);
            this._run();
        }, {
            _creator: null,

            _cancelAction: function () { if (this._creator) { this._creator.cancel(); } },
            _cleanupAction: function () { this._creator = null; }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Slim promise implementations for already completed promises, these are created
    // under the hood on synchronous completion paths as well as by WinJS.Promise.wrap
    // and WinJS.Promise.wrapError.
    //

    var ErrorPromise = _Base.Class.define(
        function ErrorPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.errorPromise))) {
                this._stack = Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForError);
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function ErrorPromise_done(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                var value = this._value;
                if (onError) {
                    try {
                        if (!onError.handlesOnError) {
                            callonerror(null, value, detailsForHandledError, this, onError);
                        }
                        var result = onError(value);
                        if (result && typeof result === "object" && typeof result.done === "function") {
                            // If a promise is returned we need to wait on it.
                            result.done();
                        }
                        return;
                    } catch (ex) {
                        value = ex;
                    }
                }
                if (value instanceof Error && value.message === canceledName) {
                    // suppress cancel
                    return;
                }
                // force the exception to be thrown asyncronously to avoid any try/catch blocks
                //
                Promise._doneHandler(value);
            },
            then: function ErrorPromise_then(unused, onError) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>

                // If the promise is already in a error state and no error handler is provided
                // we optimize by simply returning the promise instead of creating a new one.
                //
                if (!onError) { return this; }
                var result;
                var value = this._value;
                try {
                    if (!onError.handlesOnError) {
                        callonerror(null, value, detailsForHandledError, this, onError);
                    }
                    result = new CompletePromise(onError(value));
                } catch (ex) {
                    // If the value throw from the error handler is the same as the value
                    // provided to the error handler then there is no need for a new promise.
                    //
                    if (ex === value) {
                        result = this;
                    } else {
                        result = new ExceptionPromise(ex);
                    }
                }
                return result;
            }
        }, {
            supportedForProcessing: false
        }
    );

    var ExceptionPromise = _Base.Class.derive(ErrorPromise,
        function ExceptionPromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.exceptionPromise))) {
                this._stack = Promise._getStack();
            }

            this._value = value;
            callonerror(this, value, detailsForException);
        }, {
            /* empty */
        }, {
            supportedForProcessing: false
        }
    );

    var CompletePromise = _Base.Class.define(
        function CompletePromise_ctor(value) {

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.completePromise))) {
                this._stack = Promise._getStack();
            }

            if (value && typeof value === "object" && typeof value.then === "function") {
                var result = new ThenPromise(null);
                result._setCompleteValue(value);
                return result;
            }
            this._value = value;
        }, {
            cancel: function () {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
                /// <summary locid="WinJS.PromiseStateMachine.cancel">
                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
                /// already been fulfilled and cancellation is supported, the promise enters
                /// the error state with a value of Error("Canceled").
                /// </summary>
                /// </signature>
            },
            done: function CompletePromise_done(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
                /// <summary locid="WinJS.PromiseStateMachine.done">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                ///
                /// After the handlers have finished executing, this function throws any error that would have been returned
                /// from then() as a promise in the error state.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The fulfilled value is passed as the single argument. If the value is null,
                /// the fulfilled value is returned. The value returned
                /// from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while executing the function, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function is the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
                /// the function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// </signature>
                if (!onComplete) { return; }
                try {
                    var result = onComplete(this._value);
                    if (result && typeof result === "object" && typeof result.done === "function") {
                        result.done();
                    }
                } catch (ex) {
                    // force the exception to be thrown asynchronously to avoid any try/catch blocks
                    Promise._doneHandler(ex);
                }
            },
            then: function CompletePromise_then(onComplete) {
                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
                /// <summary locid="WinJS.PromiseStateMachine.then">
                /// Allows you to specify the work to be done on the fulfillment of the promised value,
                /// the error handling to be performed if the promise fails to fulfill
                /// a value, and the handling of progress notifications along the way.
                /// </summary>
                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
                /// The function to be called if the promise is fulfilled successfully with a value.
                /// The value is passed as the single argument. If the value is null, the value is returned.
                /// The value returned from the function becomes the fulfilled value of the promise returned by
                /// then(). If an exception is thrown while this function is being executed, the promise returned
                /// by then() moves into the error state.
                /// </param>
                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument. If it is null, the error is forwarded.
                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
                /// </param>
                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
                /// The promise whose value is the result of executing the complete or
                /// error function.
                /// </returns>
                /// </signature>
                try {
                    // If the value returned from the completion handler is the same as the value
                    // provided to the completion handler then there is no need for a new promise.
                    //
                    var newValue = onComplete ? onComplete(this._value) : this._value;
                    return newValue === this._value ? this : new CompletePromise(newValue);
                } catch (ex) {
                    return new ExceptionPromise(ex);
                }
            }
        }, {
            supportedForProcessing: false
        }
    );

    //
    // Promise is the user-creatable WinJS.Promise object.
    //

    function timeout(timeoutMS) {
        var id;
        return new Promise(
            function (c) {
                if (timeoutMS) {
                    id = _Global.setTimeout(c, timeoutMS);
                } else {
                    _BaseCoreUtils._setImmediate(c);
                }
            },
            function () {
                if (id) {
                    _Global.clearTimeout(id);
                }
            }
        );
    }

    function timeoutWithPromise(timeout, promise) {
        var cancelPromise = function () { promise.cancel(); };
        var cancelTimeout = function () { timeout.cancel(); };
        timeout.then(cancelPromise);
        promise.then(cancelTimeout, cancelTimeout);
        return promise;
    }

    var staticCanceledPromise;

    var Promise = _Base.Class.derive(PromiseStateMachine,
        function Promise_ctor(init, oncancel) {
            /// <signature helpKeyword="WinJS.Promise">
            /// <summary locid="WinJS.Promise">
            /// A promise provides a mechanism to schedule work to be done on a value that
            /// has not yet been computed. It is a convenient abstraction for managing
            /// interactions with asynchronous APIs.
            /// </summary>
            /// <param name="init" type="Function" locid="WinJS.Promise_p:init">
            /// The function that is called during construction of the  promise. The function
            /// is given three arguments (complete, error, progress). Inside this function
            /// you should add event listeners for the notifications supported by this value.
            /// </param>
            /// <param name="oncancel" optional="true" locid="WinJS.Promise_p:oncancel">
            /// The function to call if a consumer of this promise wants
            /// to cancel its undone work. Promises are not required to
            /// support cancellation.
            /// </param>
            /// </signature>

            if (tagWithStack && (tagWithStack === true || (tagWithStack & tag.promise))) {
                this._stack = Promise._getStack();
            }

            this._oncancel = oncancel;
            this._setState(state_created);
            this._run();

            try {
                var complete = this._completed.bind(this);
                var error = this._error.bind(this);
                var progress = this._progress.bind(this);
                init(complete, error, progress);
            } catch (ex) {
                this._setExceptionValue(ex);
            }
        }, {
            _oncancel: null,

            _cancelAction: function () {
                // BEGIN monaco change
                try {
                    if (this._oncancel) {
                        this._oncancel();
                    } else {
                        throw new Error('Promise did not implement oncancel');
                    }
                } catch (ex) {
                    // Access fields to get them created
                    var msg = ex.message;
                    var stack = ex.stack;
                    promiseEventListeners.dispatchEvent('error', ex);
                }
                // END monaco change
            },
            _cleanupAction: function () { this._oncancel = null; }
        }, {

            addEventListener: function Promise_addEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.addEventListener">
                /// <summary locid="WinJS.Promise.addEventListener">
                /// Adds an event listener to the control.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.addEventListener_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="listener" locid="WinJS.Promise.addEventListener_p:listener">
                /// The listener to invoke when the event is raised.
                /// </param>
                /// <param name="capture" locid="WinJS.Promise.addEventListener_p:capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.addEventListener(eventType, listener, capture);
            },
            any: function Promise_any(values) {
                /// <signature helpKeyword="WinJS.Promise.any">
                /// <summary locid="WinJS.Promise.any">
                /// Returns a promise that is fulfilled when one of the input promises
                /// has been fulfilled.
                /// </summary>
                /// <param name="values" type="Array" locid="WinJS.Promise.any_p:values">
                /// An array that contains promise objects or objects whose property
                /// values include promise objects.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.any_returnValue">
                /// A promise that on fulfillment yields the value of the input (complete or error).
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error) {
                        var keys = Object.keys(values);
                        if (keys.length === 0) {
                            complete();
                        }
                        var canceled = 0;
                        keys.forEach(function (key) {
                            Promise.as(values[key]).then(
                                function () { complete({ key: key, value: values[key] }); },
                                function (e) {
                                    if (e instanceof Error && e.name === canceledName) {
                                        if ((++canceled) === keys.length) {
                                            complete(Promise.cancel);
                                        }
                                        return;
                                    }
                                    error({ key: key, value: values[key] });
                                }
                            );
                        });
                    },
                    function () {
                        var keys = Object.keys(values);
                        keys.forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            as: function Promise_as(value) {
                /// <signature helpKeyword="WinJS.Promise.as">
                /// <summary locid="WinJS.Promise.as">
                /// Returns a promise. If the object is already a promise it is returned;
                /// otherwise the object is wrapped in a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.as_p:value">
                /// The value to be treated as a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.as_returnValue">
                /// A promise.
                /// </returns>
                /// </signature>
                if (value && typeof value === "object" && typeof value.then === "function") {
                    return value;
                }
                return new CompletePromise(value);
            },
            /// <field type="WinJS.Promise" helpKeyword="WinJS.Promise.cancel" locid="WinJS.Promise.cancel">
            /// Canceled promise value, can be returned from a promise completion handler
            /// to indicate cancelation of the promise chain.
            /// </field>
            cancel: {
                get: function () {
                    return (staticCanceledPromise = staticCanceledPromise || new ErrorPromise(new _ErrorFromName(canceledName)));
                }
            },
            dispatchEvent: function Promise_dispatchEvent(eventType, details) {
                /// <signature helpKeyword="WinJS.Promise.dispatchEvent">
                /// <summary locid="WinJS.Promise.dispatchEvent">
                /// Raises an event of the specified type and properties.
                /// </summary>
                /// <param name="eventType" locid="WinJS.Promise.dispatchEvent_p:eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name="details" locid="WinJS.Promise.dispatchEvent_p:details">
                /// The set of additional properties to be attached to the event object.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.dispatchEvent_returnValue">
                /// Specifies whether preventDefault was called on the event.
                /// </returns>
                /// </signature>
                return promiseEventListeners.dispatchEvent(eventType, details);
            },
            is: function Promise_is(value) {
                /// <signature helpKeyword="WinJS.Promise.is">
                /// <summary locid="WinJS.Promise.is">
                /// Determines whether a value fulfills the promise contract.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.is_p:value">
                /// A value that may be a promise.
                /// </param>
                /// <returns type="Boolean" locid="WinJS.Promise.is_returnValue">
                /// true if the specified value is a promise, otherwise false.
                /// </returns>
                /// </signature>
                return value && typeof value === "object" && typeof value.then === "function";
            },
            join: function Promise_join(values) {
                /// <signature helpKeyword="WinJS.Promise.join">
                /// <summary locid="WinJS.Promise.join">
                /// Creates a promise that is fulfilled when all the values are fulfilled.
                /// </summary>
                /// <param name="values" type="Object" locid="WinJS.Promise.join_p:values">
                /// An object whose fields contain values, some of which may be promises.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.join_returnValue">
                /// A promise whose value is an object with the same field names as those of the object in the values parameter, where
                /// each field value is the fulfilled value of a promise.
                /// </returns>
                /// </signature>
                return new Promise(
                    function (complete, error, progress) {
                        var keys = Object.keys(values);
                        var errors = Array.isArray(values) ? [] : {};
                        var results = Array.isArray(values) ? [] : {};
                        var undefineds = 0;
                        var pending = keys.length;
                        var argDone = function (key) {
                            if ((--pending) === 0) {
                                var errorCount = Object.keys(errors).length;
                                if (errorCount === 0) {
                                    complete(results);
                                } else {
                                    var canceledCount = 0;
                                    keys.forEach(function (key) {
                                        var e = errors[key];
                                        if (e instanceof Error && e.name === canceledName) {
                                            canceledCount++;
                                        }
                                    });
                                    if (canceledCount === errorCount) {
                                        complete(Promise.cancel);
                                    } else {
                                        error(errors);
                                    }
                                }
                            } else {
                                progress({ Key: key, Done: true });
                            }
                        };
                        keys.forEach(function (key) {
                            var value = values[key];
                            if (value === undefined) {
                                undefineds++;
                            } else {
                                Promise.then(value,
                                    function (value) { results[key] = value; argDone(key); },
                                    function (value) { errors[key] = value; argDone(key); }
                                );
                            }
                        });
                        pending -= undefineds;
                        if (pending === 0) {
                            complete(results);
                            return;
                        }
                    },
                    function () {
                        Object.keys(values).forEach(function (key) {
                            var promise = Promise.as(values[key]);
                            if (typeof promise.cancel === "function") {
                                promise.cancel();
                            }
                        });
                    }
                );
            },
            removeEventListener: function Promise_removeEventListener(eventType, listener, capture) {
                /// <signature helpKeyword="WinJS.Promise.removeEventListener">
                /// <summary locid="WinJS.Promise.removeEventListener">
                /// Removes an event listener from the control.
                /// </summary>
                /// <param name='eventType' locid="WinJS.Promise.removeEventListener_eventType">
                /// The type (name) of the event.
                /// </param>
                /// <param name='listener' locid="WinJS.Promise.removeEventListener_listener">
                /// The listener to remove.
                /// </param>
                /// <param name='capture' locid="WinJS.Promise.removeEventListener_capture">
                /// Specifies whether or not to initiate capture.
                /// </param>
                /// </signature>
                promiseEventListeners.removeEventListener(eventType, listener, capture);
            },
            supportedForProcessing: false,
            then: function Promise_then(value, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.then">
                /// <summary locid="WinJS.Promise.then">
                /// A static version of the promise instance method then().
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.then_p:value">
                /// the value to be treated as a promise.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.then_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If it is null, the promise simply
                /// returns the value. The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.then_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.then_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.then_returnValue">
                /// A promise whose value is the result of executing the provided complete function.
                /// </returns>
                /// </signature>
                return Promise.as(value).then(onComplete, onError, onProgress);
            },
            thenEach: function Promise_thenEach(values, onComplete, onError, onProgress) {
                /// <signature helpKeyword="WinJS.Promise.thenEach">
                /// <summary locid="WinJS.Promise.thenEach">
                /// Performs an operation on all the input promises and returns a promise
                /// that has the shape of the input and contains the result of the operation
                /// that has been performed on each input.
                /// </summary>
                /// <param name="values" locid="WinJS.Promise.thenEach_p:values">
                /// A set of values (which could be either an array or an object) of which some or all are promises.
                /// </param>
                /// <param name="onComplete" type="Function" locid="WinJS.Promise.thenEach_p:complete">
                /// The function to be called if the promise is fulfilled with a value.
                /// If the value is null, the promise returns the value.
                /// The value is passed as the single argument.
                /// </param>
                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:error">
                /// The function to be called if the promise is fulfilled with an error. The error
                /// is passed as the single argument.
                /// </param>
                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:progress">
                /// The function to be called if the promise reports progress. Data about the progress
                /// is passed as the single argument. Promises are not required to support
                /// progress.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.thenEach_returnValue">
                /// A promise that is the result of calling Promise.join on the values parameter.
                /// </returns>
                /// </signature>
                var result = Array.isArray(values) ? [] : {};
                Object.keys(values).forEach(function (key) {
                    result[key] = Promise.as(values[key]).then(onComplete, onError, onProgress);
                });
                return Promise.join(result);
            },
            timeout: function Promise_timeout(time, promise) {
                /// <signature helpKeyword="WinJS.Promise.timeout">
                /// <summary locid="WinJS.Promise.timeout">
                /// Creates a promise that is fulfilled after a timeout.
                /// </summary>
                /// <param name="timeout" type="Number" optional="true" locid="WinJS.Promise.timeout_p:timeout">
                /// The timeout period in milliseconds. If this value is zero or not specified
                /// setImmediate is called, otherwise setTimeout is called.
                /// </param>
                /// <param name="promise" type="Promise" optional="true" locid="WinJS.Promise.timeout_p:promise">
                /// A promise that will be canceled if it doesn't complete before the
                /// timeout has expired.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.timeout_returnValue">
                /// A promise that is completed asynchronously after the specified timeout.
                /// </returns>
                /// </signature>
                var to = timeout(time);
                return promise ? timeoutWithPromise(to, promise) : to;
            },
            wrap: function Promise_wrap(value) {
                /// <signature helpKeyword="WinJS.Promise.wrap">
                /// <summary locid="WinJS.Promise.wrap">
                /// Wraps a non-promise value in a promise. You can use this function if you need
                /// to pass a value to a function that requires a promise.
                /// </summary>
                /// <param name="value" locid="WinJS.Promise.wrap_p:value">
                /// Some non-promise value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrap_returnValue">
                /// A promise that is successfully fulfilled with the specified value
                /// </returns>
                /// </signature>
                return new CompletePromise(value);
            },
            wrapError: function Promise_wrapError(error) {
                /// <signature helpKeyword="WinJS.Promise.wrapError">
                /// <summary locid="WinJS.Promise.wrapError">
                /// Wraps a non-promise error value in a promise. You can use this function if you need
                /// to pass an error to a function that requires a promise.
                /// </summary>
                /// <param name="error" locid="WinJS.Promise.wrapError_p:error">
                /// A non-promise error value to be wrapped in a promise.
                /// </param>
                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrapError_returnValue">
                /// A promise that is in an error state with the specified value.
                /// </returns>
                /// </signature>
                return new ErrorPromise(error);
            },

            _veryExpensiveTagWithStack: {
                get: function () { return tagWithStack; },
                set: function (value) { tagWithStack = value; }
            },
            _veryExpensiveTagWithStack_tag: tag,
            _getStack: function () {
                if (_Global.Debug && _Global.Debug.debuggerEnabled) {
                    try { throw new Error(); } catch (e) { return e.stack; }
                }
            },

            _cancelBlocker: function Promise__cancelBlocker(input, oncancel) {
                //
                // Returns a promise which on cancelation will still result in downstream cancelation while
                //  protecting the promise 'input' from being  canceled which has the effect of allowing
                //  'input' to be shared amoung various consumers.
                //
                if (!Promise.is(input)) {
                    return Promise.wrap(input);
                }
                var complete;
                var error;
                var output = new Promise(
                    function (c, e) {
                        complete = c;
                        error = e;
                    },
                    function () {
                        complete = null;
                        error = null;
                        oncancel && oncancel();
                    }
                );
                input.then(
                    function (v) { complete && complete(v); },
                    function (e) { error && error(e); }
                );
                return output;
            },

        }
    );
    Object.defineProperties(Promise, _Events.createEventProperties(errorET));

    Promise._doneHandler = function (value) {
        _BaseCoreUtils._setImmediate(function Promise_done_rethrow() {
            throw value;
        });
    };

    return {
        PromiseStateMachine: PromiseStateMachine,
        Promise: Promise,
        state_created: state_created
    };
});

_winjs("WinJS/Promise", ["WinJS/Core/_Base","WinJS/Promise/_StateMachine"], function promiseInit( _Base, _StateMachine) {
    "use strict";

    _Base.Namespace.define("WinJS", {
        Promise: _StateMachine.Promise
    });

    return _StateMachine.Promise;
});

var exported = _modules["WinJS/Core/_WinJS"];

if (typeof exports === 'undefined' && typeof define === 'function' && define.amd) {
    define("vs/base/common/winjs.base.raw", exported);
} else {
    module.exports = exported;
}

if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {
    _modules["WinJS/Core/_BaseCoreUtils"]._setImmediate = function(handler) {
        return process.nextTick(handler);
    };
}

})();
define(__m[279], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.MessageType = {
        INITIALIZE: '$initialize',
        REPLY: '$reply',
        PRINT: '$print'
    };
    exports.ReplyType = {
        COMPLETE: 'complete',
        ERROR: 'error',
        PROGRESS: 'progress'
    };
    exports.PrintType = {
        LOG: 'log',
        DEBUG: 'debug',
        INFO: 'info',
        WARN: 'warn',
        ERROR: 'error'
    };
});

define(__m[91], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    (function (Mode) {
        Mode[Mode["PREVIEW"] = 0] = "PREVIEW";
        Mode[Mode["OPEN"] = 1] = "OPEN";
    })(exports.Mode || (exports.Mode = {}));
    var Mode = exports.Mode;
});






define(__m[290], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ContextMenuEvent = (function () {
        function ContextMenuEvent(posx, posy, target) {
            this._posx = posx;
            this._posy = posy;
            this._target = target;
        }
        ContextMenuEvent.prototype.preventDefault = function () {
            // no-op
        };
        ContextMenuEvent.prototype.stopPropagation = function () {
            // no-op
        };
        Object.defineProperty(ContextMenuEvent.prototype, "posx", {
            get: function () {
                return this._posx;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ContextMenuEvent.prototype, "posy", {
            get: function () {
                return this._posy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ContextMenuEvent.prototype, "target", {
            get: function () {
                return this._target;
            },
            enumerable: true,
            configurable: true
        });
        return ContextMenuEvent;
    }());
    exports.ContextMenuEvent = ContextMenuEvent;
    var MouseContextMenuEvent = (function (_super) {
        __extends(MouseContextMenuEvent, _super);
        function MouseContextMenuEvent(originalEvent) {
            _super.call(this, originalEvent.posx, originalEvent.posy, originalEvent.target);
            this.originalEvent = originalEvent;
        }
        MouseContextMenuEvent.prototype.preventDefault = function () {
            this.originalEvent.preventDefault();
        };
        MouseContextMenuEvent.prototype.stopPropagation = function () {
            this.originalEvent.stopPropagation();
        };
        return MouseContextMenuEvent;
    }(ContextMenuEvent));
    exports.MouseContextMenuEvent = MouseContextMenuEvent;
    var KeyboardContextMenuEvent = (function (_super) {
        __extends(KeyboardContextMenuEvent, _super);
        function KeyboardContextMenuEvent(posx, posy, originalEvent) {
            _super.call(this, posx, posy, originalEvent.target);
            this.originalEvent = originalEvent;
        }
        KeyboardContextMenuEvent.prototype.preventDefault = function () {
            this.originalEvent.preventDefault();
        };
        KeyboardContextMenuEvent.prototype.stopPropagation = function () {
            this.originalEvent.stopPropagation();
        };
        return KeyboardContextMenuEvent;
    }(ContextMenuEvent));
    exports.KeyboardContextMenuEvent = KeyboardContextMenuEvent;
    (function (DragOverEffect) {
        DragOverEffect[DragOverEffect["COPY"] = 0] = "COPY";
        DragOverEffect[DragOverEffect["MOVE"] = 1] = "MOVE";
    })(exports.DragOverEffect || (exports.DragOverEffect = {}));
    var DragOverEffect = exports.DragOverEffect;
    (function (DragOverBubble) {
        DragOverBubble[DragOverBubble["BUBBLE_DOWN"] = 0] = "BUBBLE_DOWN";
        DragOverBubble[DragOverBubble["BUBBLE_UP"] = 1] = "BUBBLE_UP";
    })(exports.DragOverBubble || (exports.DragOverBubble = {}));
    var DragOverBubble = exports.DragOverBubble;
    exports.DRAG_OVER_REJECT = { accept: false };
    exports.DRAG_OVER_ACCEPT = { accept: true };
    exports.DRAG_OVER_ACCEPT_BUBBLE_UP = { accept: true, bubble: DragOverBubble.BUBBLE_UP };
    exports.DRAG_OVER_ACCEPT_BUBBLE_DOWN = { accept: true, bubble: DragOverBubble.BUBBLE_DOWN };
    exports.DRAG_OVER_ACCEPT_BUBBLE_UP_COPY = { accept: true, bubble: DragOverBubble.BUBBLE_UP, effect: DragOverEffect.COPY };
    exports.DRAG_OVER_ACCEPT_BUBBLE_DOWN_COPY = { accept: true, bubble: DragOverBubble.BUBBLE_DOWN, effect: DragOverEffect.COPY };
});

define(__m[296], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ElementsDragAndDropData = (function () {
        function ElementsDragAndDropData(elements) {
            this.elements = elements;
        }
        ElementsDragAndDropData.prototype.update = function (event) {
            // no-op
        };
        ElementsDragAndDropData.prototype.getData = function () {
            return this.elements;
        };
        return ElementsDragAndDropData;
    }());
    exports.ElementsDragAndDropData = ElementsDragAndDropData;
    var ExternalElementsDragAndDropData = (function () {
        function ExternalElementsDragAndDropData(elements) {
            this.elements = elements;
        }
        ExternalElementsDragAndDropData.prototype.update = function (event) {
            // no-op
        };
        ExternalElementsDragAndDropData.prototype.getData = function () {
            return this.elements;
        };
        return ExternalElementsDragAndDropData;
    }());
    exports.ExternalElementsDragAndDropData = ExternalElementsDragAndDropData;
    var DesktopDragAndDropData = (function () {
        function DesktopDragAndDropData() {
            this.types = [];
            this.files = [];
        }
        DesktopDragAndDropData.prototype.update = function (event) {
            if (event.dataTransfer.types) {
                this.types = [];
                Array.prototype.push.apply(this.types, event.dataTransfer.types);
            }
            if (event.dataTransfer.files) {
                this.files = [];
                Array.prototype.push.apply(this.files, event.dataTransfer.files);
                this.files = this.files.filter(function (f) { return f.size || f.type; });
            }
        };
        DesktopDragAndDropData.prototype.getData = function () {
            return {
                types: this.types,
                files: this.files
            };
        };
        return DesktopDragAndDropData;
    }());
    exports.DesktopDragAndDropData = DesktopDragAndDropData;
});

define(__m[310], __M([9]), {});
define(__m[376], __M([9]), {});
define(__m[380], __M([9]), {});
define(__m[381], __M([9]), {});
define(__m[382], __M([9]), {});
define(__m[383], __M([9]), {});
define(__m[387], __M([9]), {});
define(__m[390], __M([9]), {});
define(__m[392], __M([9]), {});
define(__m[396], __M([9]), {});
define(__m[404], __M([9]), {});
define(__m[413], __M([9]), {});
define(__m[136], __M([9]), {});
define(__m[422], __M([9]), {});
define(__m[423], __M([9]), {});
define(__m[429], __M([9]), {});
define(__m[438], __M([9]), {});
define(__m[442], __M([9]), {});
define(__m[443], __M([9]), {});
define(__m[511], __M([9]), {});
define(__m[182], __M([9]), {});
define(__m[187], __M([9]), {});
define(__m[188], __M([9]), {});
define(__m[189], __M([9]), {});
define(__m[190], __M([9]), {});
define(__m[191], __M([9]), {});
define(__m[192], __M([9]), {});
define(__m[193], __M([9]), {});
define(__m[194], __M([9]), {});
define(__m[196], __M([9]), {});
define(__m[197], __M([9]), {});
define(__m[199], __M([9]), {});
define(__m[200], __M([9]), {});
define(__m[202], __M([9]), {});
define(__m[204], __M([9]), {});
define(__m[208], __M([9]), {});
define(__m[210], __M([9]), {});
define(__m[212], __M([9]), {});
define(__m[213], __M([9]), {});
define(__m[215], __M([9]), {});
define(__m[217], __M([9]), {});
define(__m[219], __M([9]), {});
define(__m[221], __M([9]), {});
define(__m[223], __M([9]), {});
define(__m[225], __M([9]), {});
define(__m[226], __M([9]), {});
define(__m[228], __M([9]), {});
define(__m[230], __M([9]), {});
define(__m[234], __M([9]), {});
define(__m[237], __M([9]), {});
define(__m[238], __M([9]), {});
define(__m[239], __M([9]), {});
define(__m[240], __M([9]), {});
define(__m[241], __M([9]), {});
define(__m[242], __M([9]), {});
define(__m[243], __M([9]), {});
define(__m[244], __M([9]), {});
define(__m[245], __M([9]), {});
define(__m[246], __M([9]), {});





define(__m[247], __M([0,1,3]), function (require, exports, lifecycle_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ElementSizeObserver = (function (_super) {
        __extends(ElementSizeObserver, _super);
        function ElementSizeObserver(referenceDomElement, changeCallback) {
            _super.call(this);
            this.referenceDomElement = referenceDomElement;
            this.changeCallback = changeCallback;
            this.measureReferenceDomElementToken = -1;
            this.width = -1;
            this.height = -1;
            this.measureReferenceDomElement(false);
        }
        ElementSizeObserver.prototype.dispose = function () {
            this.stopObserving();
            _super.prototype.dispose.call(this);
        };
        ElementSizeObserver.prototype.getWidth = function () {
            return this.width;
        };
        ElementSizeObserver.prototype.getHeight = function () {
            return this.height;
        };
        ElementSizeObserver.prototype.startObserving = function () {
            var _this = this;
            if (this.measureReferenceDomElementToken === -1) {
                this.measureReferenceDomElementToken = setInterval(function () { return _this.measureReferenceDomElement(true); }, 100);
            }
        };
        ElementSizeObserver.prototype.stopObserving = function () {
            if (this.measureReferenceDomElementToken !== -1) {
                clearInterval(this.measureReferenceDomElementToken);
                this.measureReferenceDomElementToken = -1;
            }
        };
        ElementSizeObserver.prototype.observe = function (dimension) {
            this.measureReferenceDomElement(true, dimension);
        };
        ElementSizeObserver.prototype.measureReferenceDomElement = function (callChangeCallback, dimension) {
            var observedWidth = 0;
            var observedHeight = 0;
            if (dimension) {
                observedWidth = dimension.width;
                observedHeight = dimension.height;
            }
            else if (this.referenceDomElement) {
                observedWidth = this.referenceDomElement.clientWidth;
                observedHeight = this.referenceDomElement.clientHeight;
            }
            observedWidth = Math.max(5, observedWidth);
            observedHeight = Math.max(5, observedHeight);
            if (this.width !== observedWidth || this.height !== observedHeight) {
                this.width = observedWidth;
                this.height = observedHeight;
                if (callChangeCallback) {
                    this.changeCallback();
                }
            }
        };
        return ElementSizeObserver;
    }(lifecycle_1.Disposable));
    exports.ElementSizeObserver = ElementSizeObserver;
});

define(__m[22], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * @internal
     */
    exports.ClassNames = {
        TEXTAREA_COVER: 'textAreaCover',
        TEXTAREA: 'inputarea',
        LINES_CONTENT: 'lines-content',
        OVERFLOW_GUARD: 'overflow-guard',
        VIEW_LINES: 'view-lines',
        VIEW_LINE: 'view-line',
        SCROLLABLE_ELEMENT: 'editor-scrollable',
        CONTENT_WIDGETS: 'contentWidgets',
        OVERFLOWING_CONTENT_WIDGETS: 'overflowingContentWidgets',
        OVERLAY_WIDGETS: 'overlayWidgets',
        MARGIN_VIEW_OVERLAYS: 'margin-view-overlays',
        LINE_NUMBERS: 'line-numbers',
        GLYPH_MARGIN: 'glyph-margin',
        SCROLL_DECORATION: 'scroll-decoration',
        VIEW_CURSORS_LAYER: 'cursors-layer',
        VIEW_ZONES: 'view-zones'
    };
    /**
     * A positioning preference for rendering content widgets.
     */
    (function (ContentWidgetPositionPreference) {
        /**
         * Place the content widget exactly at a position
         */
        ContentWidgetPositionPreference[ContentWidgetPositionPreference["EXACT"] = 0] = "EXACT";
        /**
         * Place the content widget above a position
         */
        ContentWidgetPositionPreference[ContentWidgetPositionPreference["ABOVE"] = 1] = "ABOVE";
        /**
         * Place the content widget below a position
         */
        ContentWidgetPositionPreference[ContentWidgetPositionPreference["BELOW"] = 2] = "BELOW";
    })(exports.ContentWidgetPositionPreference || (exports.ContentWidgetPositionPreference = {}));
    var ContentWidgetPositionPreference = exports.ContentWidgetPositionPreference;
    /**
     * A positioning preference for rendering overlay widgets.
     */
    (function (OverlayWidgetPositionPreference) {
        /**
         * Position the overlay widget in the top right corner
         */
        OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
        /**
         * Position the overlay widget in the bottom right corner
         */
        OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
        /**
         * Position the overlay widget in the top center
         */
        OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["TOP_CENTER"] = 2] = "TOP_CENTER";
    })(exports.OverlayWidgetPositionPreference || (exports.OverlayWidgetPositionPreference = {}));
    var OverlayWidgetPositionPreference = exports.OverlayWidgetPositionPreference;
});

define(__m[89], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Arrays;
    (function (Arrays) {
        /**
         * Given a sorted array of natural number segments, find the segment containing a natural number.
         *    For example, the segments [0, 5), [5, 9), [9, infinity) will be represented in the following manner:
         *       [{ startIndex: 0 }, { startIndex: 5 }, { startIndex: 9 }]
         *    Searching for 0, 1, 2, 3 or 4 will return 0.
         *    Searching for 5, 6, 7 or 8 will return 1.
         *    Searching for 9, 10, 11, ... will return 2.
         * @param arr A sorted array representing natural number segments
         * @param desiredIndex The search
         * @return The index of the containing segment in the array.
         */
        function findIndexInSegmentsArray(arr, desiredIndex) {
            var low = 0;
            var high = arr.length - 1;
            if (high <= 0) {
                return 0;
            }
            while (low < high) {
                var mid = low + Math.ceil((high - low) / 2);
                if (arr[mid].startIndex > desiredIndex) {
                    high = mid - 1;
                }
                else {
                    low = mid;
                }
            }
            return low;
        }
        Arrays.findIndexInSegmentsArray = findIndexInSegmentsArray;
    })(Arrays = exports.Arrays || (exports.Arrays = {}));
});

define(__m[88], __M([0,1,89]), function (require, exports, arrays_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ModeTransition = (function () {
        function ModeTransition(startIndex, mode) {
            this.startIndex = startIndex | 0;
            this.mode = mode;
            this.modeId = mode.getId();
        }
        ModeTransition.findIndexInSegmentsArray = function (arr, desiredIndex) {
            return arrays_1.Arrays.findIndexInSegmentsArray(arr, desiredIndex);
        };
        ModeTransition.create = function (modeTransitions) {
            var result = [];
            for (var i = 0, len = modeTransitions.length; i < len; i++) {
                var modeTransition = modeTransitions[i];
                result.push(new ModeTransition(modeTransition.startIndex, modeTransition.mode));
            }
            return result;
        };
        return ModeTransition;
    }());
    exports.ModeTransition = ModeTransition;
});

define(__m[21], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * A position in the editor.
     */
    var Position = (function () {
        function Position(lineNumber, column) {
            this.lineNumber = lineNumber;
            this.column = column;
        }
        /**
         * Test if this position equals other position
         */
        Position.prototype.equals = function (other) {
            return Position.equals(this, other);
        };
        /**
         * Test if position `a` equals position `b`
         */
        Position.equals = function (a, b) {
            if (!a && !b) {
                return true;
            }
            return (!!a &&
                !!b &&
                a.lineNumber === b.lineNumber &&
                a.column === b.column);
        };
        /**
         * Test if this position is before other position.
         * If the two positions are equal, the result will be false.
         */
        Position.prototype.isBefore = function (other) {
            return Position.isBefore(this, other);
        };
        /**
         * Test if position `a` is before position `b`.
         * If the two positions are equal, the result will be false.
         */
        Position.isBefore = function (a, b) {
            if (a.lineNumber < b.lineNumber) {
                return true;
            }
            if (b.lineNumber < a.lineNumber) {
                return false;
            }
            return a.column < b.column;
        };
        /**
         * Test if this position is before other position.
         * If the two positions are equal, the result will be true.
         */
        Position.prototype.isBeforeOrEqual = function (other) {
            return Position.isBeforeOrEqual(this, other);
        };
        /**
         * Test if position `a` is before position `b`.
         * If the two positions are equal, the result will be true.
         */
        Position.isBeforeOrEqual = function (a, b) {
            if (a.lineNumber < b.lineNumber) {
                return true;
            }
            if (b.lineNumber < a.lineNumber) {
                return false;
            }
            return a.column <= b.column;
        };
        /**
         * Clone this position.
         */
        Position.prototype.clone = function () {
            return new Position(this.lineNumber, this.column);
        };
        /**
         * Convert to a human-readable representation.
         */
        Position.prototype.toString = function () {
            return '(' + this.lineNumber + ',' + this.column + ')';
        };
        // ---
        /**
         * Create a `Position` from an `IPosition`.
         */
        Position.lift = function (pos) {
            return new Position(pos.lineNumber, pos.column);
        };
        /**
         * Test if `obj` is an `IPosition`.
         */
        Position.isIPosition = function (obj) {
            return (obj
                && (typeof obj.lineNumber === 'number')
                && (typeof obj.column === 'number'));
        };
        return Position;
    }());
    exports.Position = Position;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[4], __M([0,1,21]), function (require, exports, position_1) {
    'use strict';
    /**
     * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)
     */
    var Range = (function () {
        function Range(startLineNumber, startColumn, endLineNumber, endColumn) {
            if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {
                this.startLineNumber = endLineNumber;
                this.startColumn = endColumn;
                this.endLineNumber = startLineNumber;
                this.endColumn = startColumn;
            }
            else {
                this.startLineNumber = startLineNumber;
                this.startColumn = startColumn;
                this.endLineNumber = endLineNumber;
                this.endColumn = endColumn;
            }
        }
        /**
         * Test if this range is empty.
         */
        Range.prototype.isEmpty = function () {
            return Range.isEmpty(this);
        };
        /**
         * Test if `range` is empty.
         */
        Range.isEmpty = function (range) {
            return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);
        };
        /**
         * Test if position is in this range. If the position is at the edges, will return true.
         */
        Range.prototype.containsPosition = function (position) {
            return Range.containsPosition(this, position);
        };
        /**
         * Test if `position` is in `range`. If the position is at the edges, will return true.
         */
        Range.containsPosition = function (range, position) {
            if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
                return false;
            }
            if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
                return false;
            }
            if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
                return false;
            }
            return true;
        };
        /**
         * Test if range is in this range. If the range is equal to this range, will return true.
         */
        Range.prototype.containsRange = function (range) {
            return Range.containsRange(this, range);
        };
        /**
         * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
         */
        Range.containsRange = function (range, otherRange) {
            if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
                return false;
            }
            if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
                return false;
            }
            if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
                return false;
            }
            if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
                return false;
            }
            return true;
        };
        /**
         * A reunion of the two ranges.
         * The smallest position will be used as the start point, and the largest one as the end point.
         */
        Range.prototype.plusRange = function (range) {
            return Range.plusRange(this, range);
        };
        /**
         * A reunion of the two ranges.
         * The smallest position will be used as the start point, and the largest one as the end point.
         */
        Range.plusRange = function (a, b) {
            var startLineNumber, startColumn, endLineNumber, endColumn;
            if (b.startLineNumber < a.startLineNumber) {
                startLineNumber = b.startLineNumber;
                startColumn = b.startColumn;
            }
            else if (b.startLineNumber === a.startLineNumber) {
                startLineNumber = b.startLineNumber;
                startColumn = Math.min(b.startColumn, a.startColumn);
            }
            else {
                startLineNumber = a.startLineNumber;
                startColumn = a.startColumn;
            }
            if (b.endLineNumber > a.endLineNumber) {
                endLineNumber = b.endLineNumber;
                endColumn = b.endColumn;
            }
            else if (b.endLineNumber === a.endLineNumber) {
                endLineNumber = b.endLineNumber;
                endColumn = Math.max(b.endColumn, a.endColumn);
            }
            else {
                endLineNumber = a.endLineNumber;
                endColumn = a.endColumn;
            }
            return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
        };
        /**
         * A intersection of the two ranges.
         */
        Range.prototype.intersectRanges = function (range) {
            return Range.intersectRanges(this, range);
        };
        /**
         * A intersection of the two ranges.
         */
        Range.intersectRanges = function (a, b) {
            var resultStartLineNumber = a.startLineNumber, resultStartColumn = a.startColumn, resultEndLineNumber = a.endLineNumber, resultEndColumn = a.endColumn, otherStartLineNumber = b.startLineNumber, otherStartColumn = b.startColumn, otherEndLineNumber = b.endLineNumber, otherEndColumn = b.endColumn;
            if (resultStartLineNumber < otherStartLineNumber) {
                resultStartLineNumber = otherStartLineNumber;
                resultStartColumn = otherStartColumn;
            }
            else if (resultStartLineNumber === otherStartLineNumber) {
                resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
            }
            if (resultEndLineNumber > otherEndLineNumber) {
                resultEndLineNumber = otherEndLineNumber;
                resultEndColumn = otherEndColumn;
            }
            else if (resultEndLineNumber === otherEndLineNumber) {
                resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
            }
            // Check if selection is now empty
            if (resultStartLineNumber > resultEndLineNumber) {
                return null;
            }
            if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
                return null;
            }
            return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
        };
        /**
         * Test if this range equals other.
         */
        Range.prototype.equalsRange = function (other) {
            return Range.equalsRange(this, other);
        };
        /**
         * Test if range `a` equals `b`.
         */
        Range.equalsRange = function (a, b) {
            return (!!a &&
                !!b &&
                a.startLineNumber === b.startLineNumber &&
                a.startColumn === b.startColumn &&
                a.endLineNumber === b.endLineNumber &&
                a.endColumn === b.endColumn);
        };
        /**
         * Return the end position (which will be after or equal to the start position)
         */
        Range.prototype.getEndPosition = function () {
            return new position_1.Position(this.endLineNumber, this.endColumn);
        };
        /**
         * Return the start position (which will be before or equal to the end position)
         */
        Range.prototype.getStartPosition = function () {
            return new position_1.Position(this.startLineNumber, this.startColumn);
        };
        /**
         * Clone this range.
         */
        Range.prototype.cloneRange = function () {
            return new Range(this.startLineNumber, this.startColumn, this.endLineNumber, this.endColumn);
        };
        /**
         * Transform to a user presentable string representation.
         */
        Range.prototype.toString = function () {
            return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';
        };
        /**
         * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
         */
        Range.prototype.setEndPosition = function (endLineNumber, endColumn) {
            return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
        };
        /**
         * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
         */
        Range.prototype.setStartPosition = function (startLineNumber, startColumn) {
            return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
        };
        /**
         * Create a new empty range using this range's start position.
         */
        Range.prototype.collapseToStart = function () {
            return Range.collapseToStart(this);
        };
        /**
         * Create a new empty range using this range's start position.
         */
        Range.collapseToStart = function (range) {
            return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
        };
        // ---
        /**
         * Create a `Range` from an `IRange`.
         */
        Range.lift = function (range) {
            if (!range) {
                return null;
            }
            return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
        };
        /**
         * Test if `obj` is an `IRange`.
         */
        Range.isIRange = function (obj) {
            return (obj
                && (typeof obj.startLineNumber === 'number')
                && (typeof obj.startColumn === 'number')
                && (typeof obj.endLineNumber === 'number')
                && (typeof obj.endColumn === 'number'));
        };
        /**
         * Test if the two ranges are touching in any way.
         */
        Range.areIntersectingOrTouching = function (a, b) {
            // Check if `a` is before `b`
            if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {
                return false;
            }
            // Check if `b` is before `a`
            if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {
                return false;
            }
            // These ranges must intersect
            return true;
        };
        /**
         * A function that compares ranges, useful for sorting ranges
         * It will first compare ranges on the startPosition and then on the endPosition
         */
        Range.compareRangesUsingStarts = function (a, b) {
            var aStartLineNumber = a.startLineNumber | 0;
            var bStartLineNumber = b.startLineNumber | 0;
            var aStartColumn = a.startColumn | 0;
            var bStartColumn = b.startColumn | 0;
            var aEndLineNumber = a.endLineNumber | 0;
            var bEndLineNumber = b.endLineNumber | 0;
            var aEndColumn = a.endColumn | 0;
            var bEndColumn = b.endColumn | 0;
            if (aStartLineNumber === bStartLineNumber) {
                if (aStartColumn === bStartColumn) {
                    if (aEndLineNumber === bEndLineNumber) {
                        return aEndColumn - bEndColumn;
                    }
                    return aEndLineNumber - bEndLineNumber;
                }
                return aStartColumn - bStartColumn;
            }
            return aStartLineNumber - bStartLineNumber;
        };
        /**
         * A function that compares ranges, useful for sorting ranges
         * It will first compare ranges on the endPosition and then on the startPosition
         */
        Range.compareRangesUsingEnds = function (a, b) {
            if (a.endLineNumber === b.endLineNumber) {
                if (a.endColumn === b.endColumn) {
                    if (a.startLineNumber === b.startLineNumber) {
                        return a.startColumn - b.startColumn;
                    }
                    return a.startLineNumber - b.startLineNumber;
                }
                return a.endColumn - b.endColumn;
            }
            return a.endLineNumber - b.endLineNumber;
        };
        /**
         * Test if the range spans multiple lines.
         */
        Range.spansMultipleLines = function (range) {
            return range.endLineNumber > range.startLineNumber;
        };
        return Range;
    }());
    exports.Range = Range;
});

define(__m[62], __M([0,1,4]), function (require, exports, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditOperation = (function () {
        function EditOperation() {
        }
        EditOperation.insert = function (position, text) {
            return {
                identifier: null,
                range: new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column),
                text: text,
                forceMoveMarkers: true
            };
        };
        EditOperation.delete = function (range) {
            return {
                identifier: null,
                range: range,
                text: null,
                forceMoveMarkers: true
            };
        };
        EditOperation.replace = function (range, text) {
            return {
                identifier: null,
                range: range,
                text: text,
                forceMoveMarkers: false
            };
        };
        EditOperation.replaceMove = function (range, text) {
            return {
                identifier: null,
                range: range,
                text: text,
                forceMoveMarkers: true
            };
        };
        return EditOperation;
    }());
    exports.EditOperation = EditOperation;
});

define(__m[261], __M([0,1,10,62,4]), function (require, exports, strings, editOperation_1, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var TrimTrailingWhitespaceCommand = (function () {
        function TrimTrailingWhitespaceCommand(selection) {
            this.selection = selection;
        }
        TrimTrailingWhitespaceCommand.prototype.getEditOperations = function (model, builder) {
            var ops = trimTrailingWhitespace(model, []);
            for (var i = 0, len = ops.length; i < len; i++) {
                var op = ops[i];
                builder.addEditOperation(op.range, op.text);
            }
            this.selectionId = builder.trackSelection(this.selection);
        };
        TrimTrailingWhitespaceCommand.prototype.computeCursorState = function (model, helper) {
            return helper.getTrackedSelection(this.selectionId);
        };
        return TrimTrailingWhitespaceCommand;
    }());
    exports.TrimTrailingWhitespaceCommand = TrimTrailingWhitespaceCommand;
    /**
     * Generate commands for trimming trailing whitespace on a model and ignore lines on which cursors are sitting.
     */
    function trimTrailingWhitespace(model, cursors) {
        // Sort cursors ascending
        cursors.sort(function (a, b) {
            if (a.lineNumber === b.lineNumber) {
                return a.column - b.column;
            }
            return a.lineNumber - b.lineNumber;
        });
        // Reduce multiple cursors on the same line and only keep the last one on the line
        for (var i = cursors.length - 2; i >= 0; i--) {
            if (cursors[i].lineNumber === cursors[i + 1].lineNumber) {
                // Remove cursor at `i`
                cursors.splice(i, 1);
            }
        }
        var r = [], cursorIndex = 0, cursorLen = cursors.length, lineNumber, lineCount, lineContent, minEditColumn, maxLineColumn, fromColumn, 
        // toColumn:number,
        lastNonWhitespaceIndex;
        for (lineNumber = 1, lineCount = model.getLineCount(); lineNumber <= lineCount; lineNumber++) {
            lineContent = model.getLineContent(lineNumber);
            maxLineColumn = lineContent.length + 1;
            minEditColumn = 0;
            if (cursorIndex < cursorLen && cursors[cursorIndex].lineNumber === lineNumber) {
                minEditColumn = cursors[cursorIndex].column;
                cursorIndex++;
                if (minEditColumn === maxLineColumn) {
                    // The cursor is at the end of the line => no edits for sure on this line
                    continue;
                }
            }
            if (lineContent.length === 0) {
                continue;
            }
            lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);
            fromColumn = 0;
            if (lastNonWhitespaceIndex === -1) {
                // Entire line is whitespace
                fromColumn = 1;
            }
            else if (lastNonWhitespaceIndex !== lineContent.length - 1) {
                // There is trailing whitespace
                fromColumn = lastNonWhitespaceIndex + 2;
            }
            else {
                // There is no trailing whitespace
                continue;
            }
            fromColumn = Math.max(minEditColumn, fromColumn);
            r.push(editOperation_1.EditOperation.delete(new range_1.Range(lineNumber, fromColumn, lineNumber, maxLineColumn)));
        }
        return r;
    }
    exports.trimTrailingWhitespace = trimTrailingWhitespace;
});






define(__m[24], __M([0,1,4]), function (require, exports, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The direction of a selection.
     */
    (function (SelectionDirection) {
        /**
         * The selection starts above where it ends.
         */
        SelectionDirection[SelectionDirection["LTR"] = 0] = "LTR";
        /**
         * The selection starts below where it ends.
         */
        SelectionDirection[SelectionDirection["RTL"] = 1] = "RTL";
    })(exports.SelectionDirection || (exports.SelectionDirection = {}));
    var SelectionDirection = exports.SelectionDirection;
    /**
     * A selection in the editor.
     * The selection is a range that has an orientation.
     */
    var Selection = (function (_super) {
        __extends(Selection, _super);
        function Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
            _super.call(this, selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
            this.selectionStartLineNumber = selectionStartLineNumber;
            this.selectionStartColumn = selectionStartColumn;
            this.positionLineNumber = positionLineNumber;
            this.positionColumn = positionColumn;
        }
        /**
         * Clone this selection.
         */
        Selection.prototype.clone = function () {
            return new Selection(this.selectionStartLineNumber, this.selectionStartColumn, this.positionLineNumber, this.positionColumn);
        };
        /**
         * Transform to a human-readable representation.
         */
        Selection.prototype.toString = function () {
            return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';
        };
        /**
         * Test if equals other selection.
         */
        Selection.prototype.equalsSelection = function (other) {
            return (Selection.selectionsEqual(this, other));
        };
        /**
         * Test if the two selections are equal.
         */
        Selection.selectionsEqual = function (a, b) {
            return (a.selectionStartLineNumber === b.selectionStartLineNumber &&
                a.selectionStartColumn === b.selectionStartColumn &&
                a.positionLineNumber === b.positionLineNumber &&
                a.positionColumn === b.positionColumn);
        };
        /**
         * Get directions (LTR or RTL).
         */
        Selection.prototype.getDirection = function () {
            if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
                return SelectionDirection.LTR;
            }
            return SelectionDirection.RTL;
        };
        /**
         * Create a new selection with a different `positionLineNumber` and `positionColumn`.
         */
        Selection.prototype.setEndPosition = function (endLineNumber, endColumn) {
            if (this.getDirection() === SelectionDirection.LTR) {
                return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
            }
            return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
        };
        /**
         * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
         */
        Selection.prototype.setStartPosition = function (startLineNumber, startColumn) {
            if (this.getDirection() === SelectionDirection.LTR) {
                return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
            }
            return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
        };
        // ----
        /**
         * Create a `Selection` from an `ISelection`.
         */
        Selection.liftSelection = function (sel) {
            return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
        };
        /**
         * `a` equals `b`.
         */
        Selection.selectionsArrEqual = function (a, b) {
            if (a && !b || !a && b) {
                return false;
            }
            if (!a && !b) {
                return true;
            }
            if (a.length !== b.length) {
                return false;
            }
            for (var i = 0, len = a.length; i < len; i++) {
                if (!this.selectionsEqual(a[i], b[i])) {
                    return false;
                }
            }
            return true;
        };
        /**
         * Test if `obj` is an `ISelection`.
         */
        Selection.isISelection = function (obj) {
            return (obj
                && (typeof obj.selectionStartLineNumber === 'number')
                && (typeof obj.selectionStartColumn === 'number')
                && (typeof obj.positionLineNumber === 'number')
                && (typeof obj.positionColumn === 'number'));
        };
        /**
         * Create with a direction.
         */
        Selection.createWithDirection = function (startLineNumber, startColumn, endLineNumber, endColumn, direction) {
            if (direction === SelectionDirection.LTR) {
                return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);
            }
            return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);
        };
        return Selection;
    }(range_1.Range));
    exports.Selection = Selection;
});






define(__m[110], __M([0,1,24]), function (require, exports, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ReplaceCommand = (function () {
        function ReplaceCommand(range, text) {
            this._range = range;
            this._text = text;
        }
        ReplaceCommand.prototype.getText = function () {
            return this._text;
        };
        ReplaceCommand.prototype.getRange = function () {
            return this._range;
        };
        ReplaceCommand.prototype.setRange = function (newRange) {
            this._range = newRange;
        };
        ReplaceCommand.prototype.getEditOperations = function (model, builder) {
            builder.addEditOperation(this._range, this._text);
        };
        ReplaceCommand.prototype.computeCursorState = function (model, helper) {
            var inverseEditOperations = helper.getInverseEditOperations();
            var srcRange = inverseEditOperations[0].range;
            return new selection_1.Selection(srcRange.endLineNumber, srcRange.endColumn, srcRange.endLineNumber, srcRange.endColumn);
        };
        return ReplaceCommand;
    }());
    exports.ReplaceCommand = ReplaceCommand;
    var ReplaceCommandWithoutChangingPosition = (function (_super) {
        __extends(ReplaceCommandWithoutChangingPosition, _super);
        function ReplaceCommandWithoutChangingPosition(range, text) {
            _super.call(this, range, text);
        }
        ReplaceCommandWithoutChangingPosition.prototype.computeCursorState = function (model, helper) {
            var inverseEditOperations = helper.getInverseEditOperations();
            var srcRange = inverseEditOperations[0].range;
            return new selection_1.Selection(srcRange.startLineNumber, srcRange.startColumn, srcRange.startLineNumber, srcRange.startColumn);
        };
        return ReplaceCommandWithoutChangingPosition;
    }(ReplaceCommand));
    exports.ReplaceCommandWithoutChangingPosition = ReplaceCommandWithoutChangingPosition;
    var ReplaceCommandWithOffsetCursorState = (function (_super) {
        __extends(ReplaceCommandWithOffsetCursorState, _super);
        function ReplaceCommandWithOffsetCursorState(range, text, lineNumberDeltaOffset, columnDeltaOffset) {
            _super.call(this, range, text);
            this._columnDeltaOffset = columnDeltaOffset;
            this._lineNumberDeltaOffset = lineNumberDeltaOffset;
        }
        ReplaceCommandWithOffsetCursorState.prototype.computeCursorState = function (model, helper) {
            var inverseEditOperations = helper.getInverseEditOperations();
            var srcRange = inverseEditOperations[0].range;
            return new selection_1.Selection(srcRange.endLineNumber + this._lineNumberDeltaOffset, srcRange.endColumn + this._columnDeltaOffset, srcRange.endLineNumber + this._lineNumberDeltaOffset, srcRange.endColumn + this._columnDeltaOffset);
        };
        return ReplaceCommandWithOffsetCursorState;
    }(ReplaceCommand));
    exports.ReplaceCommandWithOffsetCursorState = ReplaceCommandWithOffsetCursorState;
    var ReplaceCommandThatPreservesSelection = (function (_super) {
        __extends(ReplaceCommandThatPreservesSelection, _super);
        function ReplaceCommandThatPreservesSelection(editRange, text, initialSelection) {
            _super.call(this, editRange, text);
            this._initialSelection = initialSelection;
        }
        ReplaceCommandThatPreservesSelection.prototype.getEditOperations = function (model, builder) {
            _super.prototype.getEditOperations.call(this, model, builder);
            this._selectionId = builder.trackSelection(this._initialSelection);
        };
        ReplaceCommandThatPreservesSelection.prototype.computeCursorState = function (model, helper) {
            return helper.getTrackedSelection(this._selectionId);
        };
        return ReplaceCommandThatPreservesSelection;
    }(ReplaceCommand));
    exports.ReplaceCommandThatPreservesSelection = ReplaceCommandThatPreservesSelection;
});

define(__m[270], __M([0,1,4,24]), function (require, exports, range_1, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var SurroundSelectionCommand = (function () {
        function SurroundSelectionCommand(range, charBeforeSelection, charAfterSelection) {
            this._range = range;
            this._charBeforeSelection = charBeforeSelection;
            this._charAfterSelection = charAfterSelection;
        }
        SurroundSelectionCommand.prototype.getEditOperations = function (model, builder) {
            builder.addEditOperation(new range_1.Range(this._range.startLineNumber, this._range.startColumn, this._range.startLineNumber, this._range.startColumn), this._charBeforeSelection);
            builder.addEditOperation(new range_1.Range(this._range.endLineNumber, this._range.endColumn, this._range.endLineNumber, this._range.endColumn), this._charAfterSelection);
        };
        SurroundSelectionCommand.prototype.computeCursorState = function (model, helper) {
            var inverseEditOperations = helper.getInverseEditOperations();
            var firstOperationRange = inverseEditOperations[0].range;
            var secondOperationRange = inverseEditOperations[1].range;
            return new selection_1.Selection(firstOperationRange.endLineNumber, firstOperationRange.endColumn, secondOperationRange.endLineNumber, secondOperationRange.endColumn - this._charAfterSelection.length);
        };
        return SurroundSelectionCommand;
    }());
    exports.SurroundSelectionCommand = SurroundSelectionCommand;
});

define(__m[97], __M([0,1,24]), function (require, exports, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function isHighSurrogate(model, lineNumber, column) {
        var code = model.getLineContent(lineNumber).charCodeAt(column - 1);
        return 0xD800 <= code && code <= 0xDBFF;
    }
    function isLowSurrogate(model, lineNumber, column) {
        var code = model.getLineContent(lineNumber).charCodeAt(column - 1);
        return 0xDC00 <= code && code <= 0xDFFF;
    }
    var CursorMoveHelper = (function () {
        function CursorMoveHelper(configuration) {
            this.configuration = configuration;
        }
        CursorMoveHelper.prototype.getLeftOfPosition = function (model, lineNumber, column) {
            if (column > model.getLineMinColumn(lineNumber)) {
                column = column - (isLowSurrogate(model, lineNumber, column - 1) ? 2 : 1);
            }
            else if (lineNumber > 1) {
                lineNumber = lineNumber - 1;
                column = model.getLineMaxColumn(lineNumber);
            }
            return {
                lineNumber: lineNumber,
                column: column
            };
        };
        CursorMoveHelper.prototype.getRightOfPosition = function (model, lineNumber, column) {
            if (column < model.getLineMaxColumn(lineNumber)) {
                column = column + (isHighSurrogate(model, lineNumber, column) ? 2 : 1);
            }
            else if (lineNumber < model.getLineCount()) {
                lineNumber = lineNumber + 1;
                column = model.getLineMinColumn(lineNumber);
            }
            return {
                lineNumber: lineNumber,
                column: column
            };
        };
        CursorMoveHelper.prototype.getPositionUp = function (model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {
            var currentVisibleColumn = this.visibleColumnFromColumn(model, lineNumber, column) + leftoverVisibleColumns;
            lineNumber = lineNumber - count;
            if (lineNumber < 1) {
                lineNumber = 1;
                if (allowMoveOnFirstLine) {
                    column = model.getLineMinColumn(lineNumber);
                }
                else {
                    column = Math.min(model.getLineMaxColumn(lineNumber), column);
                }
            }
            else {
                column = this.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);
            }
            leftoverVisibleColumns = currentVisibleColumn - this.visibleColumnFromColumn(model, lineNumber, column);
            return {
                lineNumber: lineNumber,
                column: column,
                leftoverVisibleColumns: leftoverVisibleColumns
            };
        };
        CursorMoveHelper.prototype.getPositionDown = function (model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {
            var currentVisibleColumn = this.visibleColumnFromColumn(model, lineNumber, column) + leftoverVisibleColumns;
            lineNumber = lineNumber + count;
            var lineCount = model.getLineCount();
            if (lineNumber > lineCount) {
                lineNumber = lineCount;
                if (allowMoveOnLastLine) {
                    column = model.getLineMaxColumn(lineNumber);
                }
                else {
                    column = Math.min(model.getLineMaxColumn(lineNumber), column);
                }
            }
            else {
                column = this.columnFromVisibleColumn(model, lineNumber, currentVisibleColumn);
            }
            leftoverVisibleColumns = currentVisibleColumn - this.visibleColumnFromColumn(model, lineNumber, column);
            return {
                lineNumber: lineNumber,
                column: column,
                leftoverVisibleColumns: leftoverVisibleColumns
            };
        };
        CursorMoveHelper.prototype.columnSelect = function (model, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn) {
            var lineCount = Math.abs(toLineNumber - fromLineNumber) + 1;
            var reversed = (fromLineNumber > toLineNumber);
            var isRTL = (fromVisibleColumn > toVisibleColumn);
            var isLTR = (fromVisibleColumn < toVisibleColumn);
            var result = [];
            // console.log(`fromVisibleColumn: ${fromVisibleColumn}, toVisibleColumn: ${toVisibleColumn}`);
            for (var i = 0; i < lineCount; i++) {
                var lineNumber = fromLineNumber + (reversed ? -i : i);
                var startColumn = this.columnFromVisibleColumn(model, lineNumber, fromVisibleColumn);
                var endColumn = this.columnFromVisibleColumn(model, lineNumber, toVisibleColumn);
                var visibleStartColumn = this.visibleColumnFromColumn(model, lineNumber, startColumn);
                var visibleEndColumn = this.visibleColumnFromColumn(model, lineNumber, endColumn);
                // console.log(`lineNumber: ${lineNumber}: visibleStartColumn: ${visibleStartColumn}, visibleEndColumn: ${visibleEndColumn}`);
                if (isLTR) {
                    if (visibleStartColumn > toVisibleColumn) {
                        continue;
                    }
                    if (visibleEndColumn < fromVisibleColumn) {
                        continue;
                    }
                }
                if (isRTL) {
                    if (visibleEndColumn > fromVisibleColumn) {
                        continue;
                    }
                    if (visibleStartColumn < toVisibleColumn) {
                        continue;
                    }
                }
                result.push(new selection_1.Selection(lineNumber, startColumn, lineNumber, endColumn));
            }
            return {
                viewSelections: result,
                reversed: reversed
            };
        };
        CursorMoveHelper.prototype.getColumnAtBeginningOfLine = function (model, lineNumber, column) {
            var firstNonBlankColumn = model.getLineFirstNonWhitespaceColumn(lineNumber) || 1;
            var minColumn = model.getLineMinColumn(lineNumber);
            if (column !== minColumn && column <= firstNonBlankColumn) {
                column = minColumn;
            }
            else {
                column = firstNonBlankColumn;
            }
            return column;
        };
        CursorMoveHelper.prototype.getColumnAtEndOfLine = function (model, lineNumber, column) {
            var maxColumn = model.getLineMaxColumn(lineNumber);
            var lastNonBlankColumn = model.getLineLastNonWhitespaceColumn(lineNumber) || maxColumn;
            if (column !== maxColumn && column >= lastNonBlankColumn) {
                column = maxColumn;
            }
            else {
                column = lastNonBlankColumn;
            }
            return column;
        };
        CursorMoveHelper.prototype.visibleColumnFromColumn = function (model, lineNumber, column) {
            return CursorMoveHelper.visibleColumnFromColumn(model, lineNumber, column, this.configuration.getIndentationOptions().tabSize);
        };
        CursorMoveHelper.visibleColumnFromColumn = function (model, lineNumber, column, tabSize) {
            return CursorMoveHelper.visibleColumnFromColumn2(model.getLineContent(lineNumber), column, tabSize);
        };
        CursorMoveHelper.visibleColumnFromColumn2 = function (line, column, tabSize) {
            var result = 0;
            for (var i = 0; i < column - 1; i++) {
                result = (line.charAt(i) === '\t') ? CursorMoveHelper.nextTabColumn(result, tabSize) : result + 1;
            }
            return result;
        };
        CursorMoveHelper.prototype.columnFromVisibleColumn = function (model, lineNumber, visibleColumn) {
            var line = model.getLineContent(lineNumber);
            var lastVisibleColumn = -1;
            var thisVisibleColumn = 0;
            for (var i = 0; i < line.length && thisVisibleColumn <= visibleColumn; i++) {
                lastVisibleColumn = thisVisibleColumn;
                thisVisibleColumn = (line.charAt(i) === '\t') ? CursorMoveHelper.nextTabColumn(thisVisibleColumn, this.configuration.getIndentationOptions().tabSize) : thisVisibleColumn + 1;
            }
            // Choose the closest
            thisVisibleColumn = Math.abs(visibleColumn - thisVisibleColumn);
            lastVisibleColumn = Math.abs(visibleColumn - lastVisibleColumn);
            var result;
            if (thisVisibleColumn < lastVisibleColumn) {
                result = i + 1;
            }
            else {
                result = i;
            }
            var minColumn = model.getLineMinColumn(lineNumber);
            if (result < minColumn) {
                result = minColumn;
            }
            return result;
        };
        /**
         * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)
         */
        CursorMoveHelper.nextTabColumn = function (column, tabSize) {
            return column + tabSize - column % tabSize;
        };
        /**
         * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)
         */
        CursorMoveHelper.prevTabColumn = function (column, tabSize) {
            return column - 1 - (column - 1) % tabSize;
        };
        return CursorMoveHelper;
    }());
    exports.CursorMoveHelper = CursorMoveHelper;
});

define(__m[64], __M([0,1,89]), function (require, exports, arrays_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * A token on a line.
     */
    var ViewLineToken = (function () {
        function ViewLineToken(startIndex, type) {
            this.startIndex = startIndex | 0; // @perf
            this.type = type.replace(/[^a-z0-9\-]/gi, ' ');
        }
        ViewLineToken.prototype.equals = function (other) {
            return (this.startIndex === other.startIndex
                && this.type === other.type);
        };
        ViewLineToken.findIndexInSegmentsArray = function (arr, desiredIndex) {
            return arrays_1.Arrays.findIndexInSegmentsArray(arr, desiredIndex);
        };
        ViewLineToken.equalsArray = function (a, b) {
            var aLen = a.length;
            var bLen = b.length;
            if (aLen !== bLen) {
                return false;
            }
            for (var i = 0; i < aLen; i++) {
                if (!a[i].equals(b[i])) {
                    return false;
                }
            }
            return true;
        };
        return ViewLineToken;
    }());
    exports.ViewLineToken = ViewLineToken;
    var ViewLineTokens = (function () {
        function ViewLineTokens(lineTokens, fauxIndentLength, textLength) {
            this._lineTokens = lineTokens;
            this._fauxIndentLength = fauxIndentLength | 0;
            this._textLength = textLength | 0;
        }
        ViewLineTokens.prototype.getTokens = function () {
            return this._lineTokens;
        };
        ViewLineTokens.prototype.getFauxIndentLength = function () {
            return this._fauxIndentLength;
        };
        ViewLineTokens.prototype.getTextLength = function () {
            return this._textLength;
        };
        ViewLineTokens.prototype.equals = function (other) {
            return (this._fauxIndentLength === other._fauxIndentLength
                && this._textLength === other._textLength
                && ViewLineToken.equalsArray(this._lineTokens, other._lineTokens));
        };
        ViewLineTokens.prototype.findIndexOfOffset = function (offset) {
            return ViewLineToken.findIndexInSegmentsArray(this._lineTokens, offset);
        };
        return ViewLineTokens;
    }());
    exports.ViewLineTokens = ViewLineTokens;
});






define(__m[285], __M([0,1,150,10]), function (require, exports, diff_1, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MAXIMUM_RUN_TIME = 5000; // 5 seconds
    var MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
    function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate) {
        var diffAlgo = new diff_1.LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
        return diffAlgo.ComputeDiff();
    }
    var MarkerSequence = (function () {
        function MarkerSequence(buffer, startMarkers, endMarkers) {
            this.buffer = buffer;
            this.startMarkers = startMarkers;
            this.endMarkers = endMarkers;
        }
        MarkerSequence.prototype.equals = function (other) {
            if (!(other instanceof MarkerSequence)) {
                return false;
            }
            var otherMarkerSequence = other;
            if (this.getLength() !== otherMarkerSequence.getLength()) {
                return false;
            }
            for (var i = 0, len = this.getLength(); i < len; i++) {
                var myElement = this.getElementHash(i);
                var otherElement = otherMarkerSequence.getElementHash(i);
                if (myElement !== otherElement) {
                    return false;
                }
            }
            return true;
        };
        MarkerSequence.prototype.getLength = function () {
            return this.startMarkers.length;
        };
        MarkerSequence.prototype.getElementHash = function (i) {
            return this.buffer.substring(this.startMarkers[i].offset, this.endMarkers[i].offset);
        };
        MarkerSequence.prototype.getStartLineNumber = function (i) {
            if (i === this.startMarkers.length) {
                // This is the special case where a change happened after the last marker
                return this.startMarkers[i - 1].lineNumber + 1;
            }
            return this.startMarkers[i].lineNumber;
        };
        MarkerSequence.prototype.getStartColumn = function (i) {
            return this.startMarkers[i].column;
        };
        MarkerSequence.prototype.getEndLineNumber = function (i) {
            return this.endMarkers[i].lineNumber;
        };
        MarkerSequence.prototype.getEndColumn = function (i) {
            return this.endMarkers[i].column;
        };
        return MarkerSequence;
    }());
    var LineMarkerSequence = (function (_super) {
        __extends(LineMarkerSequence, _super);
        function LineMarkerSequence(lines, shouldIgnoreTrimWhitespace) {
            var i, length, pos;
            var buffer = '';
            var startMarkers = [], endMarkers = [], startColumn, endColumn;
            for (pos = 0, i = 0, length = lines.length; i < length; i++) {
                buffer += lines[i];
                startColumn = 1;
                endColumn = lines[i].length + 1;
                if (shouldIgnoreTrimWhitespace) {
                    startColumn = LineMarkerSequence._getFirstNonBlankColumn(lines[i], 1);
                    endColumn = LineMarkerSequence._getLastNonBlankColumn(lines[i], 1);
                }
                startMarkers.push({
                    offset: pos + startColumn - 1,
                    lineNumber: i + 1,
                    column: startColumn
                });
                endMarkers.push({
                    offset: pos + endColumn - 1,
                    lineNumber: i + 1,
                    column: endColumn
                });
                pos += lines[i].length;
            }
            _super.call(this, buffer, startMarkers, endMarkers);
        }
        LineMarkerSequence._getFirstNonBlankColumn = function (txt, defaultValue) {
            var r = strings.firstNonWhitespaceIndex(txt);
            if (r === -1) {
                return defaultValue;
            }
            return r + 1;
        };
        LineMarkerSequence._getLastNonBlankColumn = function (txt, defaultValue) {
            var r = strings.lastNonWhitespaceIndex(txt);
            if (r === -1) {
                return defaultValue;
            }
            return r + 2;
        };
        LineMarkerSequence.prototype.getCharSequence = function (startIndex, endIndex) {
            var startMarkers = [], endMarkers = [], index, i, startMarker, endMarker;
            for (index = startIndex; index <= endIndex; index++) {
                startMarker = this.startMarkers[index];
                endMarker = this.endMarkers[index];
                for (i = startMarker.offset; i < endMarker.offset; i++) {
                    startMarkers.push({
                        offset: i,
                        lineNumber: startMarker.lineNumber,
                        column: startMarker.column + (i - startMarker.offset)
                    });
                    endMarkers.push({
                        offset: i + 1,
                        lineNumber: startMarker.lineNumber,
                        column: startMarker.column + (i - startMarker.offset) + 1
                    });
                }
            }
            return new MarkerSequence(this.buffer, startMarkers, endMarkers);
        };
        return LineMarkerSequence;
    }(MarkerSequence));
    var CharChange = (function () {
        function CharChange(diffChange, originalCharSequence, modifiedCharSequence) {
            if (diffChange.originalLength === 0) {
                this.originalStartLineNumber = 0;
                this.originalStartColumn = 0;
                this.originalEndLineNumber = 0;
                this.originalEndColumn = 0;
            }
            else {
                this.originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
                this.originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
                this.originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
                this.originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
            }
            if (diffChange.modifiedLength === 0) {
                this.modifiedStartLineNumber = 0;
                this.modifiedStartColumn = 0;
                this.modifiedEndLineNumber = 0;
                this.modifiedEndColumn = 0;
            }
            else {
                this.modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
                this.modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
                this.modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
                this.modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
            }
        }
        return CharChange;
    }());
    function postProcessCharChanges(rawChanges) {
        if (rawChanges.length <= 1) {
            return rawChanges;
        }
        var result = [rawChanges[0]];
        var i, len, originalMatchingLength, modifiedMatchingLength, matchingLength, prevChange = result[0], currChange;
        for (i = 1, len = rawChanges.length; i < len; i++) {
            currChange = rawChanges[i];
            originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
            modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
            // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true
            matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
            if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
                // Merge the current change into the previous one
                prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;
                prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;
            }
            else {
                // Add the current change
                result.push(currChange);
                prevChange = currChange;
            }
        }
        return result;
    }
    var LineChange = (function () {
        function LineChange(diffChange, originalLineSequence, modifiedLineSequence, continueProcessingPredicate, shouldPostProcessCharChanges) {
            if (diffChange.originalLength === 0) {
                this.originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
                this.originalEndLineNumber = 0;
            }
            else {
                this.originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
                this.originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
            }
            if (diffChange.modifiedLength === 0) {
                this.modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
                this.modifiedEndLineNumber = 0;
            }
            else {
                this.modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
                this.modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
            }
            if (diffChange.originalLength !== 0 && diffChange.modifiedLength !== 0 && continueProcessingPredicate()) {
                var originalCharSequence = originalLineSequence.getCharSequence(diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
                var modifiedCharSequence = modifiedLineSequence.getCharSequence(diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
                var rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueProcessingPredicate);
                if (shouldPostProcessCharChanges) {
                    rawChanges = postProcessCharChanges(rawChanges);
                }
                this.charChanges = [];
                for (var i = 0, length = rawChanges.length; i < length; i++) {
                    this.charChanges.push(new CharChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
                }
            }
        }
        return LineChange;
    }());
    var DiffComputer = (function () {
        function DiffComputer(originalLines, modifiedLines, opts) {
            this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
            this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
            this.maximumRunTimeMs = MAXIMUM_RUN_TIME;
            this.original = new LineMarkerSequence(originalLines, this.shouldIgnoreTrimWhitespace);
            this.modified = new LineMarkerSequence(modifiedLines, this.shouldIgnoreTrimWhitespace);
            if (opts.shouldConsiderTrimWhitespaceInEmptyCase && this.shouldIgnoreTrimWhitespace && this.original.equals(this.modified)) {
                // Diff would be empty with `shouldIgnoreTrimWhitespace`
                this.shouldIgnoreTrimWhitespace = false;
                this.original = new LineMarkerSequence(originalLines, this.shouldIgnoreTrimWhitespace);
                this.modified = new LineMarkerSequence(modifiedLines, this.shouldIgnoreTrimWhitespace);
            }
        }
        DiffComputer.prototype.computeDiff = function () {
            this.computationStartTime = (new Date()).getTime();
            var rawChanges = computeDiff(this.original, this.modified, this._continueProcessingPredicate.bind(this));
            var lineChanges = [];
            for (var i = 0, length = rawChanges.length; i < length; i++) {
                lineChanges.push(new LineChange(rawChanges[i], this.original, this.modified, this._continueProcessingPredicate.bind(this), this.shouldPostProcessCharChanges));
            }
            return lineChanges;
        };
        DiffComputer.prototype._continueProcessingPredicate = function () {
            if (this.maximumRunTimeMs === 0) {
                return true;
            }
            var now = (new Date()).getTime();
            return now - this.computationStartTime < this.maximumRunTimeMs;
        };
        return DiffComputer;
    }());
    exports.DiffComputer = DiffComputer;
});






define(__m[25], __M([0,1,3]), function (require, exports, lifecycle_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    (function (Behaviour) {
        Behaviour[Behaviour["TextFocus"] = 1] = "TextFocus";
        Behaviour[Behaviour["WidgetFocus"] = 2] = "WidgetFocus";
        Behaviour[Behaviour["Writeable"] = 4] = "Writeable";
        Behaviour[Behaviour["UpdateOnModelChange"] = 8] = "UpdateOnModelChange";
        Behaviour[Behaviour["UpdateOnConfigurationChange"] = 16] = "UpdateOnConfigurationChange";
        Behaviour[Behaviour["ShowInContextMenu"] = 32] = "ShowInContextMenu";
        Behaviour[Behaviour["UpdateOnCursorPositionChange"] = 64] = "UpdateOnCursorPositionChange";
    })(exports.Behaviour || (exports.Behaviour = {}));
    var Behaviour = exports.Behaviour;
    function createActionEnablement(editor, condition, action) {
        return new CompositeEnablementState([new InternalEnablementState(condition, editor), new DescentEnablementState(condition, editor, action)]);
    }
    exports.createActionEnablement = createActionEnablement;
    /**
     * A composite that acts like a logical AND on
     * enablement states
     */
    var CompositeEnablementState = (function () {
        function CompositeEnablementState(_delegates) {
            this._delegates = _delegates;
            // empty
        }
        CompositeEnablementState.prototype.value = function () {
            return this._delegates.every(function (d) { return d.value(); });
        };
        CompositeEnablementState.prototype.reset = function () {
            this._delegates.forEach(function (d) {
                if (d instanceof CachingEnablementState) {
                    d.reset();
                }
            });
        };
        CompositeEnablementState.prototype.dispose = function () {
            this._delegates.forEach(function (d) { return d.dispose(); });
        };
        return CompositeEnablementState;
    }());
    /**
     * A enablement state that caches its result until
     * reset is called.
     */
    var CachingEnablementState = (function () {
        function CachingEnablementState() {
            this._value = null;
        }
        CachingEnablementState.prototype.reset = function () {
            this._value = null;
        };
        CachingEnablementState.prototype.dispose = function () {
            //
        };
        CachingEnablementState.prototype.value = function () {
            if (this._value === null) {
                this._value = this._computeValue();
            }
            return this._value;
        };
        CachingEnablementState.prototype._computeValue = function () {
            return false;
        };
        return CachingEnablementState;
    }());
    /**
     * An enablement state that checks behaviours of the
     * editor action that can be check inside the action,
     * for instance: widget focus, text focus, readonly-ness
     */
    var InternalEnablementState = (function (_super) {
        __extends(InternalEnablementState, _super);
        function InternalEnablementState(_behaviour, editor) {
            var _this = this;
            _super.call(this);
            this._behaviour = _behaviour;
            this.editor = editor;
            this.hasTextFocus = false;
            this.hasWidgetFocus = false;
            this.isReadOnly = false;
            this._callOnDispose = [];
            if (this._behaviour & Behaviour.TextFocus) {
                this._callOnDispose.push(this.editor.onDidFocusEditorText(function () { return _this._updateTextFocus(true); }));
                this._callOnDispose.push(this.editor.onDidBlurEditorText(function () { return _this._updateTextFocus(false); }));
            }
            if (this._behaviour & Behaviour.WidgetFocus) {
                this._callOnDispose.push(this.editor.onDidFocusEditor(function () { return _this._updateWidgetFocus(true); }));
                this._callOnDispose.push(this.editor.onDidBlurEditor(function () { return _this._updateWidgetFocus(false); }));
            }
            if (this._behaviour & Behaviour.Writeable) {
                this._callOnDispose.push(this.editor.onDidChangeConfiguration(function (e) { return _this._update(); }));
            }
        }
        InternalEnablementState.prototype._updateTextFocus = function (hasTextFocus) {
            this.hasTextFocus = hasTextFocus;
            this.reset();
        };
        InternalEnablementState.prototype._updateWidgetFocus = function (hasWidgetFocus) {
            this.hasWidgetFocus = hasWidgetFocus;
            this.reset();
        };
        InternalEnablementState.prototype._update = function () {
            this.isReadOnly = this.editor.getConfiguration().readOnly;
            this.reset();
        };
        InternalEnablementState.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            lifecycle_1.dispose(this._callOnDispose);
        };
        InternalEnablementState.prototype._computeValue = function () {
            if (this._behaviour & Behaviour.TextFocus && !this.hasTextFocus) {
                return false;
            }
            if (this._behaviour & Behaviour.WidgetFocus && !this.hasWidgetFocus) {
                return false;
            }
            if (this._behaviour & Behaviour.Writeable && this.isReadOnly) {
                return false;
            }
            return true;
        };
        return InternalEnablementState;
    }(CachingEnablementState));
    /**
     * An enablement state that makes uses of the
     * {{isSupported}} and {{getEnablementState}}
     * functions that are supposed to be overwritten.
     */
    var DescentEnablementState = (function (_super) {
        __extends(DescentEnablementState, _super);
        function DescentEnablementState(behaviour, editor, _action) {
            var _this = this;
            _super.call(this);
            this.editor = editor;
            this._action = _action;
            this._callOnDispose = [];
            if (behaviour & Behaviour.UpdateOnModelChange) {
                this._callOnDispose.push(this.editor.onDidChangeModel(function () { return _this.reset(); }));
                this._callOnDispose.push(this.editor.onDidChangeModelMode(function () { return _this.reset(); }));
                this._callOnDispose.push(this.editor.onDidChangeModelModeSupport(function () { return _this.reset(); }));
            }
            if (behaviour & Behaviour.UpdateOnCursorPositionChange) {
                this._callOnDispose.push(this.editor.onDidChangeCursorPosition(function () { return _this.reset(); }));
            }
        }
        DescentEnablementState.prototype._computeValue = function () {
            if (!this.editor.getModel()) {
                return false;
            }
            if (!this._action.isSupported()) {
                return false;
            }
            if (!this._action.getEnablementState()) {
                return false;
            }
            return true;
        };
        return DescentEnablementState;
    }(CachingEnablementState));
});






define(__m[7], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Describes how to indent wrapped lines.
     */
    (function (WrappingIndent) {
        /**
         * No indentation => wrapped lines begin at column 1.
         */
        WrappingIndent[WrappingIndent["None"] = 0] = "None";
        /**
         * Same => wrapped lines get the same indentation as the parent.
         */
        WrappingIndent[WrappingIndent["Same"] = 1] = "Same";
        /**
         * Indent => wrapped lines get +1 indentation as the parent.
         */
        WrappingIndent[WrappingIndent["Indent"] = 2] = "Indent";
    })(exports.WrappingIndent || (exports.WrappingIndent = {}));
    var WrappingIndent = exports.WrappingIndent;
    var InternalEditorScrollbarOptions = (function () {
        /**
         * @internal
         */
        function InternalEditorScrollbarOptions(source) {
            this.arrowSize = source.arrowSize | 0;
            this.vertical = source.vertical | 0;
            this.horizontal = source.horizontal | 0;
            this.useShadows = Boolean(source.useShadows);
            this.verticalHasArrows = Boolean(source.verticalHasArrows);
            this.horizontalHasArrows = Boolean(source.horizontalHasArrows);
            this.handleMouseWheel = Boolean(source.handleMouseWheel);
            this.horizontalScrollbarSize = source.horizontalScrollbarSize | 0;
            this.horizontalSliderSize = source.horizontalSliderSize | 0;
            this.verticalScrollbarSize = source.verticalScrollbarSize | 0;
            this.verticalSliderSize = source.verticalSliderSize | 0;
            this.mouseWheelScrollSensitivity = Number(source.mouseWheelScrollSensitivity);
        }
        /**
         * @internal
         */
        InternalEditorScrollbarOptions.prototype.equals = function (other) {
            return (this.arrowSize === other.arrowSize
                && this.vertical === other.vertical
                && this.horizontal === other.horizontal
                && this.useShadows === other.useShadows
                && this.verticalHasArrows === other.verticalHasArrows
                && this.horizontalHasArrows === other.horizontalHasArrows
                && this.handleMouseWheel === other.handleMouseWheel
                && this.horizontalScrollbarSize === other.horizontalScrollbarSize
                && this.horizontalSliderSize === other.horizontalSliderSize
                && this.verticalScrollbarSize === other.verticalScrollbarSize
                && this.verticalSliderSize === other.verticalSliderSize
                && this.mouseWheelScrollSensitivity === other.mouseWheelScrollSensitivity);
        };
        /**
         * @internal
         */
        InternalEditorScrollbarOptions.prototype.clone = function () {
            return new InternalEditorScrollbarOptions(this);
        };
        return InternalEditorScrollbarOptions;
    }());
    exports.InternalEditorScrollbarOptions = InternalEditorScrollbarOptions;
    var EditorWrappingInfo = (function () {
        /**
         * @internal
         */
        function EditorWrappingInfo(source) {
            this.isViewportWrapping = Boolean(source.isViewportWrapping);
            this.wrappingColumn = source.wrappingColumn | 0;
            this.wrappingIndent = source.wrappingIndent | 0;
            this.wordWrapBreakBeforeCharacters = String(source.wordWrapBreakBeforeCharacters);
            this.wordWrapBreakAfterCharacters = String(source.wordWrapBreakAfterCharacters);
            this.wordWrapBreakObtrusiveCharacters = String(source.wordWrapBreakObtrusiveCharacters);
        }
        /**
         * @internal
         */
        EditorWrappingInfo.prototype.equals = function (other) {
            return (this.isViewportWrapping === other.isViewportWrapping
                && this.wrappingColumn === other.wrappingColumn
                && this.wrappingIndent === other.wrappingIndent
                && this.wordWrapBreakBeforeCharacters === other.wordWrapBreakBeforeCharacters
                && this.wordWrapBreakAfterCharacters === other.wordWrapBreakAfterCharacters
                && this.wordWrapBreakObtrusiveCharacters === other.wordWrapBreakObtrusiveCharacters);
        };
        /**
         * @internal
         */
        EditorWrappingInfo.prototype.clone = function () {
            return new EditorWrappingInfo(this);
        };
        return EditorWrappingInfo;
    }());
    exports.EditorWrappingInfo = EditorWrappingInfo;
    var InternalEditorViewOptions = (function () {
        /**
         * @internal
         */
        function InternalEditorViewOptions(source) {
            this.theme = String(source.theme);
            this.canUseTranslate3d = Boolean(source.canUseTranslate3d);
            this.experimentalScreenReader = Boolean(source.experimentalScreenReader);
            this.rulers = InternalEditorViewOptions._toSortedIntegerArray(source.rulers);
            this.ariaLabel = String(source.ariaLabel);
            this.lineNumbers = source.lineNumbers;
            this.selectOnLineNumbers = Boolean(source.selectOnLineNumbers);
            this.glyphMargin = Boolean(source.glyphMargin);
            this.revealHorizontalRightPadding = source.revealHorizontalRightPadding | 0;
            this.roundedSelection = Boolean(source.roundedSelection);
            this.overviewRulerLanes = source.overviewRulerLanes | 0;
            this.cursorBlinking = String(source.cursorBlinking);
            this.cursorStyle = source.cursorStyle | 0;
            this.hideCursorInOverviewRuler = Boolean(source.hideCursorInOverviewRuler);
            this.scrollBeyondLastLine = Boolean(source.scrollBeyondLastLine);
            this.editorClassName = String(source.editorClassName);
            this.stopRenderingLineAfter = source.stopRenderingLineAfter | 0;
            this.renderWhitespace = Boolean(source.renderWhitespace);
            this.indentGuides = Boolean(source.indentGuides);
            this.scrollbar = source.scrollbar.clone();
        }
        InternalEditorViewOptions._toSortedIntegerArray = function (source) {
            if (!Array.isArray(source)) {
                return [];
            }
            var arrSource = source;
            var result = arrSource.map(function (el) {
                var r = parseInt(el, 10);
                if (isNaN(r)) {
                    return 0;
                }
                return r;
            });
            result.sort();
            return result;
        };
        InternalEditorViewOptions._numberArraysEqual = function (a, b) {
            if (a.length !== b.length) {
                return false;
            }
            for (var i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return false;
                }
            }
            return true;
        };
        /**
         * @internal
         */
        InternalEditorViewOptions.prototype.equals = function (other) {
            return (this.theme === other.theme
                && this.canUseTranslate3d === other.canUseTranslate3d
                && this.experimentalScreenReader === other.experimentalScreenReader
                && InternalEditorViewOptions._numberArraysEqual(this.rulers, other.rulers)
                && this.ariaLabel === other.ariaLabel
                && this.lineNumbers === other.lineNumbers
                && this.selectOnLineNumbers === other.selectOnLineNumbers
                && this.glyphMargin === other.glyphMargin
                && this.revealHorizontalRightPadding === other.revealHorizontalRightPadding
                && this.roundedSelection === other.roundedSelection
                && this.overviewRulerLanes === other.overviewRulerLanes
                && this.cursorBlinking === other.cursorBlinking
                && this.cursorStyle === other.cursorStyle
                && this.hideCursorInOverviewRuler === other.hideCursorInOverviewRuler
                && this.scrollBeyondLastLine === other.scrollBeyondLastLine
                && this.editorClassName === other.editorClassName
                && this.stopRenderingLineAfter === other.stopRenderingLineAfter
                && this.renderWhitespace === other.renderWhitespace
                && this.indentGuides === other.indentGuides
                && this.scrollbar.equals(other.scrollbar));
        };
        /**
         * @internal
         */
        InternalEditorViewOptions.prototype.createChangeEvent = function (newOpts) {
            return {
                theme: this.theme !== newOpts.theme,
                canUseTranslate3d: this.canUseTranslate3d !== newOpts.canUseTranslate3d,
                experimentalScreenReader: this.experimentalScreenReader !== newOpts.experimentalScreenReader,
                rulers: (!InternalEditorViewOptions._numberArraysEqual(this.rulers, newOpts.rulers)),
                ariaLabel: this.ariaLabel !== newOpts.ariaLabel,
                lineNumbers: this.lineNumbers !== newOpts.lineNumbers,
                selectOnLineNumbers: this.selectOnLineNumbers !== newOpts.selectOnLineNumbers,
                glyphMargin: this.glyphMargin !== newOpts.glyphMargin,
                revealHorizontalRightPadding: this.revealHorizontalRightPadding !== newOpts.revealHorizontalRightPadding,
                roundedSelection: this.roundedSelection !== newOpts.roundedSelection,
                overviewRulerLanes: this.overviewRulerLanes !== newOpts.overviewRulerLanes,
                cursorBlinking: this.cursorBlinking !== newOpts.cursorBlinking,
                cursorStyle: this.cursorStyle !== newOpts.cursorStyle,
                hideCursorInOverviewRuler: this.hideCursorInOverviewRuler !== newOpts.hideCursorInOverviewRuler,
                scrollBeyondLastLine: this.scrollBeyondLastLine !== newOpts.scrollBeyondLastLine,
                editorClassName: this.editorClassName !== newOpts.editorClassName,
                stopRenderingLineAfter: this.stopRenderingLineAfter !== newOpts.stopRenderingLineAfter,
                renderWhitespace: this.renderWhitespace !== newOpts.renderWhitespace,
                indentGuides: this.indentGuides !== newOpts.indentGuides,
                scrollbar: (!this.scrollbar.equals(newOpts.scrollbar)),
            };
        };
        /**
         * @internal
         */
        InternalEditorViewOptions.prototype.clone = function () {
            return new InternalEditorViewOptions(this);
        };
        return InternalEditorViewOptions;
    }());
    exports.InternalEditorViewOptions = InternalEditorViewOptions;
    var EditorContribOptions = (function () {
        /**
         * @internal
         */
        function EditorContribOptions(source) {
            this.selectionClipboard = Boolean(source.selectionClipboard);
            this.hover = Boolean(source.hover);
            this.contextmenu = Boolean(source.contextmenu);
            this.quickSuggestions = Boolean(source.quickSuggestions);
            this.quickSuggestionsDelay = source.quickSuggestionsDelay || 0;
            this.parameterHints = Boolean(source.parameterHints);
            this.iconsInSuggestions = Boolean(source.iconsInSuggestions);
            this.formatOnType = Boolean(source.formatOnType);
            this.suggestOnTriggerCharacters = Boolean(source.suggestOnTriggerCharacters);
            this.acceptSuggestionOnEnter = Boolean(source.acceptSuggestionOnEnter);
            this.selectionHighlight = Boolean(source.selectionHighlight);
            this.outlineMarkers = Boolean(source.outlineMarkers);
            this.referenceInfos = Boolean(source.referenceInfos);
            this.folding = Boolean(source.folding);
        }
        /**
         * @internal
         */
        EditorContribOptions.prototype.equals = function (other) {
            return (this.selectionClipboard === other.selectionClipboard
                && this.hover === other.hover
                && this.contextmenu === other.contextmenu
                && this.quickSuggestions === other.quickSuggestions
                && this.quickSuggestionsDelay === other.quickSuggestionsDelay
                && this.parameterHints === other.parameterHints
                && this.iconsInSuggestions === other.iconsInSuggestions
                && this.formatOnType === other.formatOnType
                && this.suggestOnTriggerCharacters === other.suggestOnTriggerCharacters
                && this.acceptSuggestionOnEnter === other.acceptSuggestionOnEnter
                && this.selectionHighlight === other.selectionHighlight
                && this.outlineMarkers === other.outlineMarkers
                && this.referenceInfos === other.referenceInfos
                && this.folding === other.folding);
        };
        /**
         * @internal
         */
        EditorContribOptions.prototype.clone = function () {
            return new EditorContribOptions(this);
        };
        return EditorContribOptions;
    }());
    exports.EditorContribOptions = EditorContribOptions;
    /**
     * Internal configuration options (transformed or computed) for the editor.
     */
    var InternalEditorOptions = (function () {
        /**
         * @internal
         */
        function InternalEditorOptions(source) {
            this.lineHeight = source.lineHeight | 0;
            this.readOnly = Boolean(source.readOnly);
            this.wordSeparators = String(source.wordSeparators);
            this.autoClosingBrackets = Boolean(source.autoClosingBrackets);
            this.useTabStops = Boolean(source.useTabStops);
            this.tabFocusMode = Boolean(source.tabFocusMode);
            this.layoutInfo = source.layoutInfo.clone();
            this.fontInfo = source.fontInfo.clone();
            this.viewInfo = source.viewInfo.clone();
            this.wrappingInfo = source.wrappingInfo.clone();
            this.contribInfo = source.contribInfo.clone();
        }
        /**
         * @internal
         */
        InternalEditorOptions.prototype.equals = function (other) {
            return (this.lineHeight === other.lineHeight
                && this.readOnly === other.readOnly
                && this.wordSeparators === other.wordSeparators
                && this.autoClosingBrackets === other.autoClosingBrackets
                && this.useTabStops === other.useTabStops
                && this.tabFocusMode === other.tabFocusMode
                && this.layoutInfo.equals(other.layoutInfo)
                && this.fontInfo.equals(other.fontInfo)
                && this.viewInfo.equals(other.viewInfo)
                && this.wrappingInfo.equals(other.wrappingInfo)
                && this.contribInfo.equals(other.contribInfo));
        };
        /**
         * @internal
         */
        InternalEditorOptions.prototype.createChangeEvent = function (newOpts) {
            return {
                lineHeight: (this.lineHeight !== newOpts.lineHeight),
                readOnly: (this.readOnly !== newOpts.readOnly),
                wordSeparators: (this.wordSeparators !== newOpts.wordSeparators),
                autoClosingBrackets: (this.autoClosingBrackets !== newOpts.autoClosingBrackets),
                useTabStops: (this.useTabStops !== newOpts.useTabStops),
                tabFocusMode: (this.tabFocusMode !== newOpts.tabFocusMode),
                layoutInfo: (!this.layoutInfo.equals(newOpts.layoutInfo)),
                fontInfo: (!this.fontInfo.equals(newOpts.fontInfo)),
                viewInfo: this.viewInfo.createChangeEvent(newOpts.viewInfo),
                wrappingInfo: (!this.wrappingInfo.equals(newOpts.wrappingInfo)),
                contribInfo: (!this.contribInfo.equals(newOpts.contribInfo)),
            };
        };
        /**
         * @internal
         */
        InternalEditorOptions.prototype.clone = function () {
            return new InternalEditorOptions(this);
        };
        return InternalEditorOptions;
    }());
    exports.InternalEditorOptions = InternalEditorOptions;
    /**
     * Vertical Lane in the overview ruler of the editor.
     */
    (function (OverviewRulerLane) {
        OverviewRulerLane[OverviewRulerLane["Left"] = 1] = "Left";
        OverviewRulerLane[OverviewRulerLane["Center"] = 2] = "Center";
        OverviewRulerLane[OverviewRulerLane["Right"] = 4] = "Right";
        OverviewRulerLane[OverviewRulerLane["Full"] = 7] = "Full";
    })(exports.OverviewRulerLane || (exports.OverviewRulerLane = {}));
    var OverviewRulerLane = exports.OverviewRulerLane;
    /**
     * End of line character preference.
     */
    (function (EndOfLinePreference) {
        /**
         * Use the end of line character identified in the text buffer.
         */
        EndOfLinePreference[EndOfLinePreference["TextDefined"] = 0] = "TextDefined";
        /**
         * Use line feed (\n) as the end of line character.
         */
        EndOfLinePreference[EndOfLinePreference["LF"] = 1] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        EndOfLinePreference[EndOfLinePreference["CRLF"] = 2] = "CRLF";
    })(exports.EndOfLinePreference || (exports.EndOfLinePreference = {}));
    var EndOfLinePreference = exports.EndOfLinePreference;
    /**
     * The default end of line to use when instantiating models.
     */
    (function (DefaultEndOfLine) {
        /**
         * Use line feed (\n) as the end of line character.
         */
        DefaultEndOfLine[DefaultEndOfLine["LF"] = 1] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        DefaultEndOfLine[DefaultEndOfLine["CRLF"] = 2] = "CRLF";
    })(exports.DefaultEndOfLine || (exports.DefaultEndOfLine = {}));
    var DefaultEndOfLine = exports.DefaultEndOfLine;
    /**
     * End of line character preference.
     */
    (function (EndOfLineSequence) {
        /**
         * Use line feed (\n) as the end of line character.
         */
        EndOfLineSequence[EndOfLineSequence["LF"] = 0] = "LF";
        /**
         * Use carriage return and line feed (\r\n) as the end of line character.
         */
        EndOfLineSequence[EndOfLineSequence["CRLF"] = 1] = "CRLF";
    })(exports.EndOfLineSequence || (exports.EndOfLineSequence = {}));
    var EndOfLineSequence = exports.EndOfLineSequence;
    /**
     * Describes the behaviour of decorations when typing/editing near their edges.
     */
    (function (TrackedRangeStickiness) {
        TrackedRangeStickiness[TrackedRangeStickiness["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
        TrackedRangeStickiness[TrackedRangeStickiness["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
        TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
        TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
    })(exports.TrackedRangeStickiness || (exports.TrackedRangeStickiness = {}));
    var TrackedRangeStickiness = exports.TrackedRangeStickiness;
    /**
     * Describes the reason the cursor has changed its position.
     */
    (function (CursorChangeReason) {
        /**
         * Unknown or not set.
         */
        CursorChangeReason[CursorChangeReason["NotSet"] = 0] = "NotSet";
        /**
         * A `model.setValue()` was called.
         */
        CursorChangeReason[CursorChangeReason["ContentFlush"] = 1] = "ContentFlush";
        /**
         * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.
         */
        CursorChangeReason[CursorChangeReason["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
        /**
         * There was an explicit user gesture.
         */
        CursorChangeReason[CursorChangeReason["Explicit"] = 3] = "Explicit";
        /**
         * There was a Paste.
         */
        CursorChangeReason[CursorChangeReason["Paste"] = 4] = "Paste";
        /**
         * There was an Undo.
         */
        CursorChangeReason[CursorChangeReason["Undo"] = 5] = "Undo";
        /**
         * There was a Redo.
         */
        CursorChangeReason[CursorChangeReason["Redo"] = 6] = "Redo";
    })(exports.CursorChangeReason || (exports.CursorChangeReason = {}));
    var CursorChangeReason = exports.CursorChangeReason;
    /**
     * @internal
     */
    (function (VerticalRevealType) {
        VerticalRevealType[VerticalRevealType["Simple"] = 0] = "Simple";
        VerticalRevealType[VerticalRevealType["Center"] = 1] = "Center";
        VerticalRevealType[VerticalRevealType["CenterIfOutsideViewport"] = 2] = "CenterIfOutsideViewport";
    })(exports.VerticalRevealType || (exports.VerticalRevealType = {}));
    var VerticalRevealType = exports.VerticalRevealType;
    /**
     * A description for the overview ruler position.
     */
    var OverviewRulerPosition = (function () {
        /**
         * @internal
         */
        function OverviewRulerPosition(source) {
            this.width = source.width | 0;
            this.height = source.height | 0;
            this.top = source.top | 0;
            this.right = source.right | 0;
        }
        /**
         * @internal
         */
        OverviewRulerPosition.prototype.equals = function (other) {
            return (this.width === other.width
                && this.height === other.height
                && this.top === other.top
                && this.right === other.right);
        };
        /**
         * @internal
         */
        OverviewRulerPosition.prototype.clone = function () {
            return new OverviewRulerPosition(this);
        };
        return OverviewRulerPosition;
    }());
    exports.OverviewRulerPosition = OverviewRulerPosition;
    /**
     * The internal layout details of the editor.
     */
    var EditorLayoutInfo = (function () {
        /**
         * @internal
         */
        function EditorLayoutInfo(source) {
            this.width = source.width | 0;
            this.height = source.height | 0;
            this.glyphMarginLeft = source.glyphMarginLeft | 0;
            this.glyphMarginWidth = source.glyphMarginWidth | 0;
            this.glyphMarginHeight = source.glyphMarginHeight | 0;
            this.lineNumbersLeft = source.lineNumbersLeft | 0;
            this.lineNumbersWidth = source.lineNumbersWidth | 0;
            this.lineNumbersHeight = source.lineNumbersHeight | 0;
            this.decorationsLeft = source.decorationsLeft | 0;
            this.decorationsWidth = source.decorationsWidth | 0;
            this.decorationsHeight = source.decorationsHeight | 0;
            this.contentLeft = source.contentLeft | 0;
            this.contentWidth = source.contentWidth | 0;
            this.contentHeight = source.contentHeight | 0;
            this.verticalScrollbarWidth = source.verticalScrollbarWidth | 0;
            this.horizontalScrollbarHeight = source.horizontalScrollbarHeight | 0;
            this.overviewRuler = source.overviewRuler.clone();
        }
        /**
         * @internal
         */
        EditorLayoutInfo.prototype.equals = function (other) {
            return (this.width === other.width
                && this.height === other.height
                && this.glyphMarginLeft === other.glyphMarginLeft
                && this.glyphMarginWidth === other.glyphMarginWidth
                && this.glyphMarginHeight === other.glyphMarginHeight
                && this.lineNumbersLeft === other.lineNumbersLeft
                && this.lineNumbersWidth === other.lineNumbersWidth
                && this.lineNumbersHeight === other.lineNumbersHeight
                && this.decorationsLeft === other.decorationsLeft
                && this.decorationsWidth === other.decorationsWidth
                && this.decorationsHeight === other.decorationsHeight
                && this.contentLeft === other.contentLeft
                && this.contentWidth === other.contentWidth
                && this.contentHeight === other.contentHeight
                && this.verticalScrollbarWidth === other.verticalScrollbarWidth
                && this.horizontalScrollbarHeight === other.horizontalScrollbarHeight
                && this.overviewRuler.equals(other.overviewRuler));
        };
        /**
         * @internal
         */
        EditorLayoutInfo.prototype.clone = function () {
            return new EditorLayoutInfo(this);
        };
        return EditorLayoutInfo;
    }());
    exports.EditorLayoutInfo = EditorLayoutInfo;
    /**
     * Type of hit element with the mouse in the editor.
     */
    (function (MouseTargetType) {
        /**
         * Mouse is on top of an unknown element.
         */
        MouseTargetType[MouseTargetType["UNKNOWN"] = 0] = "UNKNOWN";
        /**
         * Mouse is on top of the textarea used for input.
         */
        MouseTargetType[MouseTargetType["TEXTAREA"] = 1] = "TEXTAREA";
        /**
         * Mouse is on top of the glyph margin
         */
        MouseTargetType[MouseTargetType["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
        /**
         * Mouse is on top of the line numbers
         */
        MouseTargetType[MouseTargetType["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
        /**
         * Mouse is on top of the line decorations
         */
        MouseTargetType[MouseTargetType["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
        /**
         * Mouse is on top of the whitespace left in the gutter by a view zone.
         */
        MouseTargetType[MouseTargetType["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
        /**
         * Mouse is on top of text in the content.
         */
        MouseTargetType[MouseTargetType["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
        /**
         * Mouse is on top of empty space in the content (e.g. after line text or below last line)
         */
        MouseTargetType[MouseTargetType["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
        /**
         * Mouse is on top of a view zone in the content.
         */
        MouseTargetType[MouseTargetType["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
        /**
         * Mouse is on top of a content widget.
         */
        MouseTargetType[MouseTargetType["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
        /**
         * Mouse is on top of the decorations overview ruler.
         */
        MouseTargetType[MouseTargetType["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
        /**
         * Mouse is on top of a scrollbar.
         */
        MouseTargetType[MouseTargetType["SCROLLBAR"] = 11] = "SCROLLBAR";
        /**
         * Mouse is on top of an overlay widget.
         */
        MouseTargetType[MouseTargetType["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
    })(exports.MouseTargetType || (exports.MouseTargetType = {}));
    var MouseTargetType = exports.MouseTargetType;
    /**
     * A context key that is set when the editor's text has focus (cursor is blinking).
     */
    exports.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS = 'editorTextFocus';
    /**
     * A context key that is set when the editor's text or an editor's widget has focus.
     */
    exports.KEYBINDING_CONTEXT_EDITOR_FOCUS = 'editorFocus';
    /**
     * @internal
     */
    exports.KEYBINDING_CONTEXT_EDITOR_TAB_MOVES_FOCUS = 'editorTabMovesFocus';
    /**
     * A context key that is set when the editor has multiple selections (multiple cursors).
     */
    exports.KEYBINDING_CONTEXT_EDITOR_HAS_MULTIPLE_SELECTIONS = 'editorHasMultipleSelections';
    /**
     * A context key that is set when the editor has a non-collapsed selection.
     */
    exports.KEYBINDING_CONTEXT_EDITOR_HAS_NON_EMPTY_SELECTION = 'editorHasSelection';
    /**
     * A context key that is set to the language associated with the model associated with the editor.
     */
    exports.KEYBINDING_CONTEXT_EDITOR_LANGUAGE_ID = 'editorLangId';
    /**
     * @internal
     */
    exports.SHOW_ACCESSIBILITY_HELP_ACTION_ID = 'editor.action.showAccessibilityHelp';
    var BareFontInfo = (function () {
        /**
         * @internal
         */
        function BareFontInfo(opts) {
            this.fontFamily = String(opts.fontFamily);
            this.fontSize = opts.fontSize | 0;
            this.lineHeight = opts.lineHeight | 0;
        }
        /**
         * @internal
         */
        BareFontInfo.prototype.getId = function () {
            return this.fontFamily + '-' + this.fontSize + '-' + this.lineHeight;
        };
        return BareFontInfo;
    }());
    exports.BareFontInfo = BareFontInfo;
    var FontInfo = (function (_super) {
        __extends(FontInfo, _super);
        /**
         * @internal
         */
        function FontInfo(opts) {
            _super.call(this, opts);
            this.typicalHalfwidthCharacterWidth = opts.typicalHalfwidthCharacterWidth;
            this.typicalFullwidthCharacterWidth = opts.typicalFullwidthCharacterWidth;
            this.spaceWidth = opts.spaceWidth;
            this.maxDigitWidth = opts.maxDigitWidth;
        }
        /**
         * @internal
         */
        FontInfo.prototype.equals = function (other) {
            return (this.fontFamily === other.fontFamily
                && this.fontSize === other.fontSize
                && this.lineHeight === other.lineHeight
                && this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth
                && this.typicalFullwidthCharacterWidth === other.typicalFullwidthCharacterWidth
                && this.spaceWidth === other.spaceWidth
                && this.maxDigitWidth === other.maxDigitWidth);
        };
        /**
         * @internal
         */
        FontInfo.prototype.clone = function () {
            return new FontInfo(this);
        };
        return FontInfo;
    }(BareFontInfo));
    exports.FontInfo = FontInfo;
    /**
     * @internal
     */
    exports.ViewEventNames = {
        ModelFlushedEvent: 'modelFlushedEvent',
        LinesDeletedEvent: 'linesDeletedEvent',
        LinesInsertedEvent: 'linesInsertedEvent',
        LineChangedEvent: 'lineChangedEvent',
        TokensChangedEvent: 'tokensChangedEvent',
        DecorationsChangedEvent: 'decorationsChangedEvent',
        CursorPositionChangedEvent: 'cursorPositionChangedEvent',
        CursorSelectionChangedEvent: 'cursorSelectionChangedEvent',
        RevealRangeEvent: 'revealRangeEvent',
        LineMappingChangedEvent: 'lineMappingChangedEvent',
        ScrollRequestEvent: 'scrollRequestEvent'
    };
    /**
     * @internal
     */
    var Viewport = (function () {
        function Viewport(top, left, width, height) {
            this.top = top | 0;
            this.left = left | 0;
            this.width = width | 0;
            this.height = height | 0;
        }
        return Viewport;
    }());
    exports.Viewport = Viewport;
    /**
     * @internal
     */
    (function (CodeEditorStateFlag) {
        CodeEditorStateFlag[CodeEditorStateFlag["Value"] = 0] = "Value";
        CodeEditorStateFlag[CodeEditorStateFlag["Selection"] = 1] = "Selection";
        CodeEditorStateFlag[CodeEditorStateFlag["Position"] = 2] = "Position";
        CodeEditorStateFlag[CodeEditorStateFlag["Scroll"] = 3] = "Scroll";
    })(exports.CodeEditorStateFlag || (exports.CodeEditorStateFlag = {}));
    var CodeEditorStateFlag = exports.CodeEditorStateFlag;
    /**
     * The type of the `IEditor`.
     */
    exports.EditorType = {
        ICodeEditor: 'vs.editor.ICodeEditor',
        IDiffEditor: 'vs.editor.IDiffEditor'
    };
    /**
     * @internal
     */
    exports.ClassName = {
        EditorWarningDecoration: 'greensquiggly',
        EditorErrorDecoration: 'redsquiggly'
    };
    /**
     * @internal
     */
    exports.EventType = {
        Disposed: 'disposed',
        ConfigurationChanged: 'configurationChanged',
        ModelDispose: 'modelDispose',
        ModelChanged: 'modelChanged',
        ModelTokensChanged: 'modelTokensChanged',
        ModelModeChanged: 'modelsModeChanged',
        ModelModeSupportChanged: 'modelsModeSupportChanged',
        ModelOptionsChanged: 'modelOptionsChanged',
        ModelRawContentChanged: 'contentChanged',
        ModelContentChanged2: 'contentChanged2',
        ModelRawContentChangedFlush: 'flush',
        ModelRawContentChangedLinesDeleted: 'linesDeleted',
        ModelRawContentChangedLinesInserted: 'linesInserted',
        ModelRawContentChangedLineChanged: 'lineChanged',
        EditorTextBlur: 'blur',
        EditorTextFocus: 'focus',
        EditorFocus: 'widgetFocus',
        EditorBlur: 'widgetBlur',
        ModelDecorationsChanged: 'decorationsChanged',
        CursorPositionChanged: 'positionChanged',
        CursorSelectionChanged: 'selectionChanged',
        CursorRevealRange: 'revealRange',
        CursorScrollRequest: 'scrollRequest',
        ViewFocusGained: 'focusGained',
        ViewFocusLost: 'focusLost',
        ViewFocusChanged: 'focusChanged',
        ViewScrollChanged: 'scrollChanged',
        ViewZonesChanged: 'zonesChanged',
        ViewLayoutChanged: 'viewLayoutChanged',
        ContextMenu: 'contextMenu',
        MouseDown: 'mousedown',
        MouseUp: 'mouseup',
        MouseMove: 'mousemove',
        MouseLeave: 'mouseleave',
        KeyDown: 'keydown',
        KeyUp: 'keyup',
        EditorLayout: 'editorLayout',
        DiffUpdated: 'diffUpdated'
    };
    /**
     * Built-in commands.
     */
    exports.Handler = {
        ExecuteCommand: 'executeCommand',
        ExecuteCommands: 'executeCommands',
        CursorLeft: 'cursorLeft',
        CursorLeftSelect: 'cursorLeftSelect',
        CursorWordLeft: 'cursorWordLeft',
        CursorWordStartLeft: 'cursorWordStartLeft',
        CursorWordEndLeft: 'cursorWordEndLeft',
        CursorWordLeftSelect: 'cursorWordLeftSelect',
        CursorWordStartLeftSelect: 'cursorWordStartLeftSelect',
        CursorWordEndLeftSelect: 'cursorWordEndLeftSelect',
        CursorRight: 'cursorRight',
        CursorRightSelect: 'cursorRightSelect',
        CursorWordRight: 'cursorWordRight',
        CursorWordStartRight: 'cursorWordStartRight',
        CursorWordEndRight: 'cursorWordEndRight',
        CursorWordRightSelect: 'cursorWordRightSelect',
        CursorWordStartRightSelect: 'cursorWordStartRightSelect',
        CursorWordEndRightSelect: 'cursorWordEndRightSelect',
        CursorUp: 'cursorUp',
        CursorUpSelect: 'cursorUpSelect',
        CursorDown: 'cursorDown',
        CursorDownSelect: 'cursorDownSelect',
        CursorPageUp: 'cursorPageUp',
        CursorPageUpSelect: 'cursorPageUpSelect',
        CursorPageDown: 'cursorPageDown',
        CursorPageDownSelect: 'cursorPageDownSelect',
        CursorHome: 'cursorHome',
        CursorHomeSelect: 'cursorHomeSelect',
        CursorEnd: 'cursorEnd',
        CursorEndSelect: 'cursorEndSelect',
        ExpandLineSelection: 'expandLineSelection',
        CursorTop: 'cursorTop',
        CursorTopSelect: 'cursorTopSelect',
        CursorBottom: 'cursorBottom',
        CursorBottomSelect: 'cursorBottomSelect',
        CursorColumnSelectLeft: 'cursorColumnSelectLeft',
        CursorColumnSelectRight: 'cursorColumnSelectRight',
        CursorColumnSelectUp: 'cursorColumnSelectUp',
        CursorColumnSelectPageUp: 'cursorColumnSelectPageUp',
        CursorColumnSelectDown: 'cursorColumnSelectDown',
        CursorColumnSelectPageDown: 'cursorColumnSelectPageDown',
        AddCursorDown: 'addCursorDown',
        AddCursorUp: 'addCursorUp',
        CursorUndo: 'cursorUndo',
        MoveTo: 'moveTo',
        MoveToSelect: 'moveToSelect',
        ColumnSelect: 'columnSelect',
        CreateCursor: 'createCursor',
        LastCursorMoveToSelect: 'lastCursorMoveToSelect',
        JumpToBracket: 'jumpToBracket',
        Type: 'type',
        ReplacePreviousChar: 'replacePreviousChar',
        Paste: 'paste',
        Tab: 'tab',
        Indent: 'indent',
        Outdent: 'outdent',
        DeleteLeft: 'deleteLeft',
        DeleteRight: 'deleteRight',
        DeleteWordLeft: 'deleteWordLeft',
        DeleteWordStartLeft: 'deleteWordStartLeft',
        DeleteWordEndLeft: 'deleteWordEndLeft',
        DeleteWordRight: 'deleteWordRight',
        DeleteWordStartRight: 'deleteWordStartRight',
        DeleteWordEndRight: 'deleteWordEndRight',
        DeleteAllLeft: 'deleteAllLeft',
        DeleteAllRight: 'deleteAllRight',
        RemoveSecondaryCursors: 'removeSecondaryCursors',
        CancelSelection: 'cancelSelection',
        Cut: 'cut',
        Undo: 'undo',
        Redo: 'redo',
        WordSelect: 'wordSelect',
        WordSelectDrag: 'wordSelectDrag',
        LastCursorWordSelect: 'lastCursorWordSelect',
        LineSelect: 'lineSelect',
        LineSelectDrag: 'lineSelectDrag',
        LastCursorLineSelect: 'lastCursorLineSelect',
        LastCursorLineSelectDrag: 'lastCursorLineSelectDrag',
        LineInsertBefore: 'lineInsertBefore',
        LineInsertAfter: 'lineInsertAfter',
        LineBreakInsert: 'lineBreakInsert',
        SelectAll: 'selectAll',
        ScrollLineUp: 'scrollLineUp',
        ScrollLineDown: 'scrollLineDown',
        ScrollPageUp: 'scrollPageUp',
        ScrollPageDown: 'scrollPageDown'
    };
    /**
     * The style in which the editor's cursor should be rendered.
     */
    (function (TextEditorCursorStyle) {
        /**
         * As a vertical line (sitting between two characters).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Line"] = 1] = "Line";
        /**
         * As a block (sitting on top of a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Block"] = 2] = "Block";
        /**
         * As a horizontal line (sitting under a character).
         */
        TextEditorCursorStyle[TextEditorCursorStyle["Underline"] = 3] = "Underline";
    })(exports.TextEditorCursorStyle || (exports.TextEditorCursorStyle = {}));
    var TextEditorCursorStyle = exports.TextEditorCursorStyle;
    /**
     * @internal
     */
    function cursorStyleToString(cursorStyle) {
        if (cursorStyle === TextEditorCursorStyle.Line) {
            return 'line';
        }
        else if (cursorStyle === TextEditorCursorStyle.Block) {
            return 'block';
        }
        else if (cursorStyle === TextEditorCursorStyle.Underline) {
            return 'underline';
        }
        else {
            throw new Error('cursorStyleToString: Unknown cursorStyle');
        }
    }
    exports.cursorStyleToString = cursorStyleToString;
    /**
     * @internal
     */
    var ColorZone = (function () {
        function ColorZone(from, to, colorId, position) {
            this.from = from | 0;
            this.to = to | 0;
            this.colorId = colorId | 0;
            this.position = position | 0;
        }
        return ColorZone;
    }());
    exports.ColorZone = ColorZone;
    /**
     * A zone in the overview ruler
     * @internal
     */
    var OverviewRulerZone = (function () {
        function OverviewRulerZone(startLineNumber, endLineNumber, position, forceHeight, color, darkColor) {
            this.startLineNumber = startLineNumber;
            this.endLineNumber = endLineNumber;
            this.position = position;
            this.forceHeight = forceHeight;
            this._color = color;
            this._darkColor = darkColor;
            this._colorZones = null;
        }
        OverviewRulerZone.prototype.getColor = function (useDarkColor) {
            if (useDarkColor) {
                return this._darkColor;
            }
            return this._color;
        };
        OverviewRulerZone.prototype.equals = function (other) {
            return (this.startLineNumber === other.startLineNumber
                && this.endLineNumber === other.endLineNumber
                && this.position === other.position
                && this.forceHeight === other.forceHeight
                && this._color === other._color
                && this._darkColor === other._darkColor);
        };
        OverviewRulerZone.prototype.compareTo = function (other) {
            if (this.startLineNumber === other.startLineNumber) {
                if (this.endLineNumber === other.endLineNumber) {
                    if (this.forceHeight === other.forceHeight) {
                        if (this.position === other.position) {
                            if (this._darkColor === other._darkColor) {
                                if (this._color === other._color) {
                                    return 0;
                                }
                                return this._color < other._color ? -1 : 1;
                            }
                            return this._darkColor < other._darkColor ? -1 : 1;
                        }
                        return this.position - other.position;
                    }
                    return this.forceHeight - other.forceHeight;
                }
                return this.endLineNumber - other.endLineNumber;
            }
            return this.startLineNumber - other.startLineNumber;
        };
        OverviewRulerZone.prototype.setColorZones = function (colorZones) {
            this._colorZones = colorZones;
        };
        OverviewRulerZone.prototype.getColorZones = function () {
            return this._colorZones;
        };
        return OverviewRulerZone;
    }());
    exports.OverviewRulerZone = OverviewRulerZone;
});

define(__m[291], __M([0,1,21,7]), function (require, exports, position_1, editorCommon) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewController = (function () {
        function ViewController(viewModel, triggerCursorHandler, outgoingEventBus, keybindingService) {
            this.viewModel = viewModel;
            this.triggerCursorHandler = triggerCursorHandler;
            this.outgoingEventBus = outgoingEventBus;
            this.keybindingService = keybindingService;
        }
        ViewController.prototype.paste = function (source, text, pasteOnNewLine) {
            this.keybindingService.executeCommand(editorCommon.Handler.Paste, {
                text: text,
                pasteOnNewLine: pasteOnNewLine,
            });
        };
        ViewController.prototype.type = function (source, text) {
            this.keybindingService.executeCommand(editorCommon.Handler.Type, {
                text: text
            });
        };
        ViewController.prototype.replacePreviousChar = function (source, text, replaceCharCnt) {
            this.keybindingService.executeCommand(editorCommon.Handler.ReplacePreviousChar, {
                text: text,
                replaceCharCnt: replaceCharCnt
            });
        };
        ViewController.prototype.cut = function (source) {
            this.keybindingService.executeCommand(editorCommon.Handler.Cut, {});
        };
        ViewController.prototype._validateViewColumn = function (viewPosition) {
            var minColumn = this.viewModel.getLineMinColumn(viewPosition.lineNumber);
            if (viewPosition.column < minColumn) {
                return new position_1.Position(viewPosition.lineNumber, minColumn);
            }
            return viewPosition;
        };
        ViewController.prototype.dispatchMouse = function (data) {
            if (data.startedOnLineNumbers) {
                // If the dragging started on the gutter, then have operations work on the entire line
                if (data.altKey) {
                    if (data.inSelectionMode) {
                        this.lastCursorLineSelect('mouse', data.position);
                    }
                    else {
                        this.createCursor('mouse', data.position, true);
                    }
                }
                else {
                    if (data.inSelectionMode) {
                        this.lineSelectDrag('mouse', data.position);
                    }
                    else {
                        this.lineSelect('mouse', data.position);
                    }
                }
            }
            else if (data.mouseDownCount >= 4) {
                this.selectAll('mouse');
            }
            else if (data.mouseDownCount === 3) {
                if (data.altKey) {
                    if (data.inSelectionMode) {
                        this.lastCursorLineSelectDrag('mouse', data.position);
                    }
                    else {
                        this.lastCursorLineSelect('mouse', data.position);
                    }
                }
                else {
                    if (data.inSelectionMode) {
                        this.lineSelectDrag('mouse', data.position);
                    }
                    else {
                        this.lineSelect('mouse', data.position);
                    }
                }
            }
            else if (data.mouseDownCount === 2) {
                if (data.altKey) {
                    this.lastCursorWordSelect('mouse', data.position);
                }
                else {
                    if (data.inSelectionMode) {
                        this.wordSelectDrag('mouse', data.position);
                    }
                    else {
                        this.wordSelect('mouse', data.position);
                    }
                }
            }
            else {
                if (data.altKey) {
                    if (!data.ctrlKey && !data.metaKey) {
                        if (data.shiftKey) {
                            this.columnSelect('mouse', data.position, data.mouseColumn);
                        }
                        else {
                            // Do multi-cursor operations only when purely alt is pressed
                            if (data.inSelectionMode) {
                                this.lastCursorMoveToSelect('mouse', data.position);
                            }
                            else {
                                this.createCursor('mouse', data.position, false);
                            }
                        }
                    }
                }
                else {
                    if (data.inSelectionMode) {
                        this.moveToSelect('mouse', data.position);
                    }
                    else {
                        this.moveTo('mouse', data.position);
                    }
                }
            }
        };
        ViewController.prototype.moveTo = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.MoveTo, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition
            });
        };
        ViewController.prototype.moveToSelect = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.MoveToSelect, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition
            });
        };
        ViewController.prototype.columnSelect = function (source, viewPosition, mouseColumn) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.ColumnSelect, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition,
                mouseColumn: mouseColumn
            });
        };
        ViewController.prototype.createCursor = function (source, viewPosition, wholeLine) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.CreateCursor, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition,
                wholeLine: wholeLine
            });
        };
        ViewController.prototype.lastCursorMoveToSelect = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.LastCursorMoveToSelect, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition
            });
        };
        ViewController.prototype.wordSelect = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.WordSelect, {
                position: this.convertViewToModelPosition(viewPosition)
            });
        };
        ViewController.prototype.wordSelectDrag = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.WordSelectDrag, {
                position: this.convertViewToModelPosition(viewPosition)
            });
        };
        ViewController.prototype.lastCursorWordSelect = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.LastCursorWordSelect, {
                position: this.convertViewToModelPosition(viewPosition)
            });
        };
        ViewController.prototype.lineSelect = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.LineSelect, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition
            });
        };
        ViewController.prototype.lineSelectDrag = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.LineSelectDrag, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition
            });
        };
        ViewController.prototype.lastCursorLineSelect = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.LastCursorLineSelect, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition
            });
        };
        ViewController.prototype.lastCursorLineSelectDrag = function (source, viewPosition) {
            viewPosition = this._validateViewColumn(viewPosition);
            this.triggerCursorHandler(source, editorCommon.Handler.LastCursorLineSelectDrag, {
                position: this.convertViewToModelPosition(viewPosition),
                viewPosition: viewPosition
            });
        };
        ViewController.prototype.selectAll = function (source) {
            this.triggerCursorHandler(source, editorCommon.Handler.SelectAll, null);
        };
        // ----------------------
        ViewController.prototype.convertViewToModelPosition = function (viewPosition) {
            return this.viewModel.convertViewPositionToModelPosition(viewPosition.lineNumber, viewPosition.column);
        };
        ViewController.prototype.convertViewToModelRange = function (viewRange) {
            return this.viewModel.convertViewRangeToModelRange(viewRange);
        };
        ViewController.prototype.convertViewToModelMouseEvent = function (e) {
            if (e.target) {
                if (e.target.position) {
                    e.target.position = this.convertViewToModelPosition(e.target.position);
                }
                if (e.target.range) {
                    e.target.range = this.convertViewToModelRange(e.target.range);
                }
            }
        };
        ViewController.prototype.emitKeyDown = function (e) {
            this.outgoingEventBus.emit(editorCommon.EventType.KeyDown, e);
        };
        ViewController.prototype.emitKeyUp = function (e) {
            this.outgoingEventBus.emit(editorCommon.EventType.KeyUp, e);
        };
        ViewController.prototype.emitContextMenu = function (e) {
            this.convertViewToModelMouseEvent(e);
            this.outgoingEventBus.emit(editorCommon.EventType.ContextMenu, e);
        };
        ViewController.prototype.emitMouseMove = function (e) {
            this.convertViewToModelMouseEvent(e);
            this.outgoingEventBus.emit(editorCommon.EventType.MouseMove, e);
        };
        ViewController.prototype.emitMouseLeave = function (e) {
            this.convertViewToModelMouseEvent(e);
            this.outgoingEventBus.emit(editorCommon.EventType.MouseLeave, e);
        };
        ViewController.prototype.emitMouseUp = function (e) {
            this.convertViewToModelMouseEvent(e);
            this.outgoingEventBus.emit(editorCommon.EventType.MouseUp, e);
        };
        ViewController.prototype.emitMouseDown = function (e) {
            this.convertViewToModelMouseEvent(e);
            this.outgoingEventBus.emit(editorCommon.EventType.MouseDown, e);
        };
        return ViewController;
    }());
    exports.ViewController = ViewController;
});






define(__m[148], __M([0,1,10,4,7]), function (require, exports, strings_1, range_1, editorCommon_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    (function (TextAreaStrategy) {
        TextAreaStrategy[TextAreaStrategy["IENarrator"] = 0] = "IENarrator";
        TextAreaStrategy[TextAreaStrategy["NVDA"] = 1] = "NVDA";
    })(exports.TextAreaStrategy || (exports.TextAreaStrategy = {}));
    var TextAreaStrategy = exports.TextAreaStrategy;
    var USE_NVDA_FULL_TEXT = false;
    function createTextAreaState(strategy) {
        if (strategy === TextAreaStrategy.IENarrator) {
            return IENarratorTextAreaState.EMPTY;
        }
        if (USE_NVDA_FULL_TEXT) {
            return NVDAFullTextAreaState.EMPTY;
        }
        return NVDAPagedTextAreaState.EMPTY;
    }
    exports.createTextAreaState = createTextAreaState;
    var TextAreaState = (function () {
        function TextAreaState(previousState, value, selectionStart, selectionEnd, isInOverwriteMode) {
            this.previousState = previousState ? previousState.shallowClone() : null;
            this.value = value;
            this.selectionStart = selectionStart;
            this.selectionEnd = selectionEnd;
            this.isInOverwriteMode = isInOverwriteMode;
        }
        TextAreaState.prototype.updateComposition = function () {
            if (!this.previousState) {
                // This is the EMPTY state
                return {
                    text: '',
                    replaceCharCnt: 0
                };
            }
            return {
                text: this.value,
                replaceCharCnt: this.previousState.selectionEnd - this.previousState.selectionStart
            };
        };
        TextAreaState.prototype.getSelectionStart = function () {
            return this.selectionStart;
        };
        TextAreaState.prototype.getValue = function () {
            return this.value;
        };
        TextAreaState.prototype.applyToTextArea = function (reason, textArea, select) {
            // console.log(Date.now() + ': applyToTextArea ' + reason + ': ' + this.toString());
            if (textArea.getValue() !== this.value) {
                textArea.setValue(reason, this.value);
            }
            if (select) {
                textArea.setSelectionRange(this.selectionStart, this.selectionEnd);
            }
        };
        TextAreaState.prototype.deduceInput = function () {
            if (!this.previousState) {
                // This is the EMPTY state
                return {
                    text: '',
                    replaceCharCnt: 0
                };
            }
            // console.log('------------------------deduceInput');
            // console.log('CURRENT STATE: ' + this.toString());
            // console.log('PREVIOUS STATE: ' + this.previousState.toString());
            var previousValue = this.previousState.value;
            var previousSelectionStart = this.previousState.selectionStart;
            var previousSelectionEnd = this.previousState.selectionEnd;
            var currentValue = this.value;
            var currentSelectionStart = this.selectionStart;
            var currentSelectionEnd = this.selectionEnd;
            // Strip the previous suffix from the value (without interfering with the current selection)
            var previousSuffix = previousValue.substring(previousSelectionEnd);
            var currentSuffix = currentValue.substring(currentSelectionEnd);
            var suffixLength = strings_1.commonSuffixLength(previousSuffix, currentSuffix);
            currentValue = currentValue.substring(0, currentValue.length - suffixLength);
            previousValue = previousValue.substring(0, previousValue.length - suffixLength);
            var previousPrefix = previousValue.substring(0, previousSelectionStart);
            var currentPrefix = currentValue.substring(0, currentSelectionStart);
            var prefixLength = strings_1.commonPrefixLength(previousPrefix, currentPrefix);
            currentValue = currentValue.substring(prefixLength);
            previousValue = previousValue.substring(prefixLength);
            currentSelectionStart -= prefixLength;
            previousSelectionStart -= prefixLength;
            currentSelectionEnd -= prefixLength;
            previousSelectionEnd -= prefixLength;
            // console.log('AFTER DIFFING CURRENT STATE: <' + currentValue + '>, selectionStart: ' + currentSelectionStart + ', selectionEnd: ' + currentSelectionEnd);
            // console.log('AFTER DIFFING PREVIOUS STATE: <' + previousValue + '>, selectionStart: ' + previousSelectionStart + ', selectionEnd: ' + previousSelectionEnd);
            if (currentSelectionStart === currentSelectionEnd) {
                // composition accept case
                // [blahblah] => blahblah|
                if (previousValue === currentValue
                    && previousSelectionStart === 0
                    && previousSelectionEnd === previousValue.length
                    && currentSelectionStart === currentValue.length
                    && currentValue.indexOf('\n') === -1) {
                    return {
                        text: '',
                        replaceCharCnt: 0
                    };
                }
                // no current selection
                var replacePreviousCharacters_1 = (previousPrefix.length - prefixLength);
                // console.log('REMOVE PREVIOUS: ' + (previousPrefix.length - prefixLength) + ' chars');
                return {
                    text: currentValue,
                    replaceCharCnt: replacePreviousCharacters_1
                };
            }
            // there is a current selection => composition case
            var replacePreviousCharacters = previousSelectionEnd - previousSelectionStart;
            return {
                text: currentValue,
                replaceCharCnt: replacePreviousCharacters
            };
        };
        return TextAreaState;
    }());
    exports.TextAreaState = TextAreaState;
    var IENarratorTextAreaState = (function (_super) {
        __extends(IENarratorTextAreaState, _super);
        function IENarratorTextAreaState(previousState, value, selectionStart, selectionEnd, isInOverwriteMode, selectionToken) {
            _super.call(this, previousState, value, selectionStart, selectionEnd, isInOverwriteMode);
            this.selectionToken = selectionToken;
        }
        IENarratorTextAreaState.prototype.shallowClone = function () {
            return new IENarratorTextAreaState(null, this.value, this.selectionStart, this.selectionEnd, this.isInOverwriteMode, this.selectionToken);
        };
        IENarratorTextAreaState.prototype.toEmpty = function () {
            return IENarratorTextAreaState.EMPTY;
        };
        IENarratorTextAreaState.prototype.toString = function () {
            return '[ <' + this.value + '>, selectionStart: ' + this.selectionStart + ', selectionEnd: ' + this.selectionEnd + ', isInOverwriteMode: ' + this.isInOverwriteMode + ', selectionToken: ' + this.selectionToken + ']';
        };
        IENarratorTextAreaState.prototype.toStrategy = function (strategy) {
            if (strategy === TextAreaStrategy.IENarrator) {
                return this;
            }
            if (USE_NVDA_FULL_TEXT) {
                return new NVDAFullTextAreaState(this.previousState, this.value, this.selectionStart, this.selectionEnd, this.isInOverwriteMode);
            }
            return new NVDAPagedTextAreaState(this.previousState, this.value, this.selectionStart, this.selectionEnd, this.isInOverwriteMode);
        };
        IENarratorTextAreaState.prototype.equals = function (other) {
            if (other instanceof IENarratorTextAreaState) {
                return (this.value === other.value
                    && this.selectionStart === other.selectionStart
                    && this.selectionEnd === other.selectionEnd
                    && this.isInOverwriteMode === other.isInOverwriteMode
                    && this.selectionToken === other.selectionToken);
            }
            return false;
        };
        IENarratorTextAreaState.prototype.fromTextArea = function (textArea) {
            return new IENarratorTextAreaState(this, textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), textArea.isInOverwriteMode(), this.selectionToken);
        };
        IENarratorTextAreaState.prototype.fromEditorSelection = function (model, selection) {
            var LIMIT_CHARS = 100;
            var PADDING_LINES_COUNT = 0;
            var selectionStartLineNumber = selection.startLineNumber, selectionStartColumn = selection.startColumn, selectionEndLineNumber = selection.endLineNumber, selectionEndColumn = selection.endColumn, selectionEndLineNumberMaxColumn = model.getLineMaxColumn(selectionEndLineNumber);
            // If the selection is empty and we have switched line numbers, expand selection to full line (helps Narrator trigger a full line read)
            if (selection.isEmpty() && this.selectionToken !== selectionStartLineNumber) {
                selectionStartColumn = 1;
                selectionEndColumn = selectionEndLineNumberMaxColumn;
            }
            // `pretext` contains the text before the selection
            var pretext = '';
            var startLineNumber = Math.max(1, selectionStartLineNumber - PADDING_LINES_COUNT);
            if (startLineNumber < selectionStartLineNumber) {
                pretext = model.getValueInRange(new range_1.Range(startLineNumber, 1, selectionStartLineNumber, 1), editorCommon_1.EndOfLinePreference.LF);
            }
            pretext += model.getValueInRange(new range_1.Range(selectionStartLineNumber, 1, selectionStartLineNumber, selectionStartColumn), editorCommon_1.EndOfLinePreference.LF);
            if (pretext.length > LIMIT_CHARS) {
                pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);
            }
            // `posttext` contains the text after the selection
            var posttext = '';
            var endLineNumber = Math.min(selectionEndLineNumber + PADDING_LINES_COUNT, model.getLineCount());
            posttext += model.getValueInRange(new range_1.Range(selectionEndLineNumber, selectionEndColumn, selectionEndLineNumber, selectionEndLineNumberMaxColumn), editorCommon_1.EndOfLinePreference.LF);
            if (endLineNumber > selectionEndLineNumber) {
                posttext = '\n' + model.getValueInRange(new range_1.Range(selectionEndLineNumber + 1, 1, endLineNumber, model.getLineMaxColumn(endLineNumber)), editorCommon_1.EndOfLinePreference.LF);
            }
            if (posttext.length > LIMIT_CHARS) {
                posttext = posttext.substring(0, LIMIT_CHARS);
            }
            // `text` contains the text of the selection
            var text = model.getValueInRange(new range_1.Range(selectionStartLineNumber, selectionStartColumn, selectionEndLineNumber, selectionEndColumn), editorCommon_1.EndOfLinePreference.LF);
            if (text.length > 2 * LIMIT_CHARS) {
                text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);
            }
            return new IENarratorTextAreaState(this, pretext + text + posttext, pretext.length, pretext.length + text.length, false, selectionStartLineNumber);
        };
        IENarratorTextAreaState.prototype.fromText = function (text) {
            return new IENarratorTextAreaState(this, text, 0, text.length, false, 0);
        };
        IENarratorTextAreaState.prototype.resetSelection = function () {
            return new IENarratorTextAreaState(this.previousState, this.value, this.value.length, this.value.length, this.isInOverwriteMode, this.selectionToken);
        };
        IENarratorTextAreaState.EMPTY = new IENarratorTextAreaState(null, '', 0, 0, false, 0);
        return IENarratorTextAreaState;
    }(TextAreaState));
    exports.IENarratorTextAreaState = IENarratorTextAreaState;
    var NVDAPagedTextAreaState = (function (_super) {
        __extends(NVDAPagedTextAreaState, _super);
        function NVDAPagedTextAreaState(previousState, value, selectionStart, selectionEnd, isInOverwriteMode) {
            _super.call(this, previousState, value, selectionStart, selectionEnd, isInOverwriteMode);
        }
        NVDAPagedTextAreaState.prototype.shallowClone = function () {
            return new NVDAPagedTextAreaState(null, this.value, this.selectionStart, this.selectionEnd, this.isInOverwriteMode);
        };
        NVDAPagedTextAreaState.prototype.toEmpty = function () {
            return NVDAPagedTextAreaState.EMPTY;
        };
        NVDAPagedTextAreaState.prototype.toString = function () {
            return '[ <' + this.value + '>, selectionStart: ' + this.selectionStart + ', selectionEnd: ' + this.selectionEnd + ', isInOverwriteMode: ' + this.isInOverwriteMode + ']';
        };
        NVDAPagedTextAreaState.prototype.toStrategy = function (strategy) {
            if (strategy === TextAreaStrategy.NVDA) {
                return this;
            }
            return new IENarratorTextAreaState(this.previousState, this.value, this.selectionStart, this.selectionEnd, this.isInOverwriteMode, 0);
        };
        NVDAPagedTextAreaState.prototype.equals = function (other) {
            if (other instanceof NVDAPagedTextAreaState) {
                return (this.value === other.value
                    && this.selectionStart === other.selectionStart
                    && this.selectionEnd === other.selectionEnd
                    && this.isInOverwriteMode === other.isInOverwriteMode);
            }
            return false;
        };
        NVDAPagedTextAreaState.prototype.fromTextArea = function (textArea) {
            return new NVDAPagedTextAreaState(this, textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), textArea.isInOverwriteMode());
        };
        NVDAPagedTextAreaState._getPageOfLine = function (lineNumber) {
            return Math.floor((lineNumber - 1) / NVDAPagedTextAreaState._LINES_PER_PAGE);
        };
        NVDAPagedTextAreaState._getRangeForPage = function (page) {
            var offset = page * NVDAPagedTextAreaState._LINES_PER_PAGE;
            var startLineNumber = offset + 1;
            var endLineNumber = offset + NVDAPagedTextAreaState._LINES_PER_PAGE;
            return new range_1.Range(startLineNumber, 1, endLineNumber, Number.MAX_VALUE);
        };
        NVDAPagedTextAreaState.prototype.fromEditorSelection = function (model, selection) {
            var selectionStartPage = NVDAPagedTextAreaState._getPageOfLine(selection.startLineNumber);
            var selectionStartPageRange = NVDAPagedTextAreaState._getRangeForPage(selectionStartPage);
            var selectionEndPage = NVDAPagedTextAreaState._getPageOfLine(selection.endLineNumber);
            var selectionEndPageRange = NVDAPagedTextAreaState._getRangeForPage(selectionEndPage);
            var pretextRange = selectionStartPageRange.intersectRanges(new range_1.Range(1, 1, selection.startLineNumber, selection.startColumn));
            var pretext = model.getValueInRange(pretextRange, editorCommon_1.EndOfLinePreference.LF);
            var lastLine = model.getLineCount();
            var lastLineMaxColumn = model.getLineMaxColumn(lastLine);
            var posttextRange = selectionEndPageRange.intersectRanges(new range_1.Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn));
            var posttext = model.getValueInRange(posttextRange, editorCommon_1.EndOfLinePreference.LF);
            var text = null;
            if (selectionStartPage === selectionEndPage || selectionStartPage + 1 === selectionEndPage) {
                // take full selection
                text = model.getValueInRange(selection, editorCommon_1.EndOfLinePreference.LF);
            }
            else {
                var selectionRange1 = selectionStartPageRange.intersectRanges(selection);
                var selectionRange2 = selectionEndPageRange.intersectRanges(selection);
                text = (model.getValueInRange(selectionRange1, editorCommon_1.EndOfLinePreference.LF)
                    + String.fromCharCode(8230)
                    + model.getValueInRange(selectionRange2, editorCommon_1.EndOfLinePreference.LF));
            }
            // Chromium handles very poorly text even of a few thousand chars
            // Cut text to avoid stalling the entire UI
            var LIMIT_CHARS = 500;
            if (pretext.length > LIMIT_CHARS) {
                pretext = pretext.substring(pretext.length - LIMIT_CHARS, pretext.length);
            }
            if (posttext.length > LIMIT_CHARS) {
                posttext = posttext.substring(0, LIMIT_CHARS);
            }
            if (text.length > 2 * LIMIT_CHARS) {
                text = text.substring(0, LIMIT_CHARS) + String.fromCharCode(8230) + text.substring(text.length - LIMIT_CHARS, text.length);
            }
            return new NVDAPagedTextAreaState(this, pretext + text + posttext, pretext.length, pretext.length + text.length, false);
        };
        NVDAPagedTextAreaState.prototype.fromText = function (text) {
            return new NVDAPagedTextAreaState(this, text, 0, text.length, false);
        };
        NVDAPagedTextAreaState.prototype.resetSelection = function () {
            return new NVDAPagedTextAreaState(this.previousState, this.value, this.value.length, this.value.length, this.isInOverwriteMode);
        };
        NVDAPagedTextAreaState.EMPTY = new NVDAPagedTextAreaState(null, '', 0, 0, false);
        NVDAPagedTextAreaState._LINES_PER_PAGE = 10;
        return NVDAPagedTextAreaState;
    }(TextAreaState));
    exports.NVDAPagedTextAreaState = NVDAPagedTextAreaState;
    var NVDAFullTextAreaState = (function (_super) {
        __extends(NVDAFullTextAreaState, _super);
        function NVDAFullTextAreaState(previousState, value, selectionStart, selectionEnd, isInOverwriteMode) {
            _super.call(this, previousState, value, selectionStart, selectionEnd, isInOverwriteMode);
        }
        NVDAFullTextAreaState.prototype.shallowClone = function () {
            return new NVDAFullTextAreaState(null, this.value, this.selectionStart, this.selectionEnd, this.isInOverwriteMode);
        };
        NVDAFullTextAreaState.prototype.toEmpty = function () {
            return NVDAFullTextAreaState.EMPTY;
        };
        NVDAFullTextAreaState.prototype.toString = function () {
            return '[ <ENTIRE TEXT' + '>, selectionStart: ' + this.selectionStart + ', selectionEnd: ' + this.selectionEnd + ', isInOverwriteMode: ' + this.isInOverwriteMode + ']';
        };
        NVDAFullTextAreaState.prototype.toStrategy = function (strategy) {
            if (strategy === TextAreaStrategy.NVDA) {
                return this;
            }
            return new IENarratorTextAreaState(this.previousState, this.value, this.selectionStart, this.selectionEnd, this.isInOverwriteMode, 0);
        };
        NVDAFullTextAreaState.prototype.equals = function (other) {
            if (other instanceof NVDAFullTextAreaState) {
                return (this.value === other.value
                    && this.selectionStart === other.selectionStart
                    && this.selectionEnd === other.selectionEnd
                    && this.isInOverwriteMode === other.isInOverwriteMode);
            }
            return false;
        };
        NVDAFullTextAreaState.prototype.fromTextArea = function (textArea) {
            return new NVDAFullTextAreaState(this, textArea.getValue(), textArea.getSelectionStart(), textArea.getSelectionEnd(), textArea.isInOverwriteMode());
        };
        NVDAFullTextAreaState.prototype.fromEditorSelection = function (model, selection) {
            var pretext = model.getValueInRange(new range_1.Range(1, 1, selection.startLineNumber, selection.startColumn), editorCommon_1.EndOfLinePreference.LF);
            var text = model.getValueInRange(selection, editorCommon_1.EndOfLinePreference.LF);
            var lastLine = model.getLineCount();
            var lastLineMaxColumn = model.getLineMaxColumn(lastLine);
            var posttext = model.getValueInRange(new range_1.Range(selection.endLineNumber, selection.endColumn, lastLine, lastLineMaxColumn), editorCommon_1.EndOfLinePreference.LF);
            return new NVDAFullTextAreaState(this, pretext + text + posttext, pretext.length, pretext.length + text.length, false);
        };
        NVDAFullTextAreaState.prototype.fromText = function (text) {
            return new NVDAFullTextAreaState(this, text, 0, text.length, false);
        };
        NVDAFullTextAreaState.prototype.resetSelection = function () {
            return new NVDAFullTextAreaState(this.previousState, this.value, this.value.length, this.value.length, this.isInOverwriteMode);
        };
        NVDAFullTextAreaState.EMPTY = new NVDAFullTextAreaState(null, '', 0, 0, false);
        return NVDAFullTextAreaState;
    }(TextAreaState));
    exports.NVDAFullTextAreaState = NVDAFullTextAreaState;
});

define(__m[297], __M([0,1,10,7]), function (require, exports, strings, editorCommon_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditorState = (function () {
        function EditorState(editor, flags) {
            var _this = this;
            this.flags = flags;
            flags.forEach(function (flag) {
                switch (flag) {
                    case editorCommon_1.CodeEditorStateFlag.Value:
                        var model = editor.getModel();
                        _this.modelVersionId = model ? strings.format('{0}#{1}', model.uri.toString(), model.getVersionId()) : null;
                        break;
                    case editorCommon_1.CodeEditorStateFlag.Position:
                        _this.position = editor.getPosition();
                        break;
                    case editorCommon_1.CodeEditorStateFlag.Selection:
                        _this.selection = editor.getSelection();
                        break;
                    case editorCommon_1.CodeEditorStateFlag.Scroll:
                        _this.scrollLeft = editor.getScrollLeft();
                        _this.scrollTop = editor.getScrollTop();
                        break;
                }
            });
        }
        EditorState.prototype._equals = function (other) {
            if (!(other instanceof EditorState)) {
                return false;
            }
            var state = other;
            if (this.modelVersionId !== state.modelVersionId) {
                return false;
            }
            if (this.scrollLeft !== state.scrollLeft || this.scrollTop !== state.scrollTop) {
                return false;
            }
            if (!this.position && state.position || this.position && !state.position || this.position && state.position && !this.position.equals(state.position)) {
                return false;
            }
            if (!this.selection && state.selection || this.selection && !state.selection || this.selection && state.selection && !this.selection.equalsRange(state.selection)) {
                return false;
            }
            return true;
        };
        EditorState.prototype.validate = function (editor) {
            return this._equals(new EditorState(editor, this.flags));
        };
        return EditorState;
    }());
    exports.EditorState = EditorState;
});

define(__m[298], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var __space = ' '.charCodeAt(0);
    var __tab = '\t'.charCodeAt(0);
    /**
     * Compute the diff in spaces between two line's indentation.
     */
    function spacesDiff(a, aLength, b, bLength) {
        // This can go both ways (e.g.):
        //  - a: "\t"
        //  - b: "\t    "
        //  => This should count 1 tab and 4 spaces
        var i;
        for (i = 0; i < aLength && i < bLength; i++) {
            var aCharCode = a.charCodeAt(i);
            var bCharCode = b.charCodeAt(i);
            if (aCharCode !== bCharCode) {
                break;
            }
        }
        var aSpacesCnt = 0, aTabsCount = 0;
        for (var j = i; j < aLength; j++) {
            var aCharCode = a.charCodeAt(j);
            if (aCharCode === __space) {
                aSpacesCnt++;
            }
            else {
                aTabsCount++;
            }
        }
        var bSpacesCnt = 0, bTabsCount = 0;
        for (var j = i; j < bLength; j++) {
            var bCharCode = b.charCodeAt(j);
            if (bCharCode === __space) {
                bSpacesCnt++;
            }
            else {
                bTabsCount++;
            }
        }
        if (aSpacesCnt > 0 && aTabsCount > 0) {
            return 0;
        }
        if (bSpacesCnt > 0 && bTabsCount > 0) {
            return 0;
        }
        var tabsDiff = Math.abs(aTabsCount - bTabsCount);
        var spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);
        if (tabsDiff === 0) {
            return spacesDiff;
        }
        if (spacesDiff % tabsDiff === 0) {
            return spacesDiff / tabsDiff;
        }
        return 0;
    }
    function guessIndentation(lines, defaultTabSize, defaultInsertSpaces) {
        var linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation
        var linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation
        var previousLineText = ''; // content of latest line that contained non-whitespace chars
        var previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char
        var ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8]; // limit guesses for `tabSize` to 2, 4, 6 or 8.
        var MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(2,4,6,8) = 8
        var spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores
        for (var i = 0, len = lines.length; i < len; i++) {
            var currentLineText = lines[i];
            var currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars
            var currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char
            var currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation
            var currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation
            for (var j = 0, lenJ = currentLineText.length; j < lenJ; j++) {
                var charCode = currentLineText.charCodeAt(j);
                if (charCode === __tab) {
                    currentLineTabsCount++;
                }
                else if (charCode === __space) {
                    currentLineSpacesCount++;
                }
                else {
                    // Hit non whitespace character on this line
                    currentLineHasContent = true;
                    currentLineIndentation = j;
                    break;
                }
            }
            // Ignore empty or only whitespace lines
            if (!currentLineHasContent) {
                continue;
            }
            if (currentLineTabsCount > 0) {
                linesIndentedWithTabsCount++;
            }
            else if (currentLineSpacesCount > 1) {
                linesIndentedWithSpacesCount++;
            }
            var currentSpacesDiff = spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation);
            if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {
                spacesDiffCount[currentSpacesDiff]++;
            }
            previousLineText = currentLineText;
            previousLineIndentation = currentLineIndentation;
        }
        // Take into account the last line as well
        var deltaSpacesCount = spacesDiff(previousLineText, previousLineIndentation, '', 0);
        if (deltaSpacesCount <= MAX_ALLOWED_TAB_SIZE_GUESS) {
            spacesDiffCount[deltaSpacesCount]++;
        }
        var insertSpaces = defaultInsertSpaces;
        if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {
            insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);
        }
        var tabSize = defaultTabSize;
        var tabSizeScore = (insertSpaces ? 0 : 0.1 * lines.length);
        // console.log("score threshold: " + tabSizeScore);
        ALLOWED_TAB_SIZE_GUESSES.forEach(function (possibleTabSize) {
            var possibleTabSizeScore = spacesDiffCount[possibleTabSize];
            if (possibleTabSizeScore > tabSizeScore) {
                tabSizeScore = possibleTabSizeScore;
                tabSize = possibleTabSize;
            }
        });
        // console.log('--------------------------');
        // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);
        // console.log('spacesDiffCount: ' + spacesDiffCount);
        // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);
        return {
            insertSpaces: insertSpaces,
            tabSize: tabSize
        };
    }
    exports.guessIndentation = guessIndentation;
});

define(__m[305], __M([0,1,89]), function (require, exports, arrays_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * A token on a line.
     */
    var LineToken = (function () {
        function LineToken(startIndex, type) {
            this.startIndex = startIndex | 0; // @perf
            this.type = type;
        }
        LineToken.prototype.equals = function (other) {
            return (this.startIndex === other.startIndex
                && this.type === other.type);
        };
        LineToken.findIndexInSegmentsArray = function (arr, desiredIndex) {
            return arrays_1.Arrays.findIndexInSegmentsArray(arr, desiredIndex);
        };
        LineToken.equalsArray = function (a, b) {
            var aLen = a.length;
            var bLen = b.length;
            if (aLen !== bLen) {
                return false;
            }
            for (var i = 0; i < aLen; i++) {
                if (!a[i].equals(b[i])) {
                    return false;
                }
            }
            return true;
        };
        return LineToken;
    }());
    exports.LineToken = LineToken;
});

define(__m[306], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var TokenIterator = (function () {
        function TokenIterator(model, position) {
            this._model = model;
            this._currentLineNumber = position.lineNumber;
            this._currentTokenIndex = 0;
            this._readLineTokens(this._currentLineNumber);
            this._next = null;
            this._prev = null;
            // start with a position to next/prev run
            var columnIndex = position.column - 1, tokenEndIndex = Number.MAX_VALUE;
            for (var i = this._currentLineTokens.getTokenCount() - 1; i >= 0; i--) {
                var tokenStartIndex = this._currentLineTokens.getTokenStartIndex(i);
                if (tokenStartIndex <= columnIndex && columnIndex <= tokenEndIndex) {
                    this._currentTokenIndex = i;
                    this._next = this._current();
                    this._prev = this._current();
                    break;
                }
                tokenEndIndex = tokenStartIndex;
            }
        }
        TokenIterator.prototype._readLineTokens = function (lineNumber) {
            this._currentLineTokens = this._model.getLineTokens(lineNumber, false);
        };
        TokenIterator.prototype._advanceNext = function () {
            this._prev = this._next;
            this._next = null;
            if (this._currentTokenIndex + 1 < this._currentLineTokens.getTokenCount()) {
                // There are still tokens on current line
                this._currentTokenIndex++;
                this._next = this._current();
            }
            else {
                // find the next line with tokens
                while (this._currentLineNumber + 1 <= this._model.getLineCount()) {
                    this._currentLineNumber++;
                    this._readLineTokens(this._currentLineNumber);
                    if (this._currentLineTokens.getTokenCount() > 0) {
                        this._currentTokenIndex = 0;
                        this._next = this._current();
                        break;
                    }
                }
                if (this._next === null) {
                    // prepare of a previous run
                    this._readLineTokens(this._currentLineNumber);
                    this._currentTokenIndex = this._currentLineTokens.getTokenCount();
                    this._advancePrev();
                    this._next = null;
                }
            }
        };
        TokenIterator.prototype._advancePrev = function () {
            this._next = this._prev;
            this._prev = null;
            if (this._currentTokenIndex > 0) {
                // There are still tokens on current line
                this._currentTokenIndex--;
                this._prev = this._current();
            }
            else {
                // find previous line with tokens
                while (this._currentLineNumber > 1) {
                    this._currentLineNumber--;
                    this._readLineTokens(this._currentLineNumber);
                    if (this._currentLineTokens.getTokenCount() > 0) {
                        this._currentTokenIndex = this._currentLineTokens.getTokenCount() - 1;
                        this._prev = this._current();
                        break;
                    }
                }
            }
        };
        TokenIterator.prototype._current = function () {
            var startIndex = this._currentLineTokens.getTokenStartIndex(this._currentTokenIndex);
            var type = this._currentLineTokens.getTokenType(this._currentTokenIndex);
            var endIndex = this._currentLineTokens.getTokenEndIndex(this._currentTokenIndex, this._model.getLineContent(this._currentLineNumber).length);
            return {
                token: {
                    startIndex: startIndex,
                    type: type
                },
                lineNumber: this._currentLineNumber,
                startColumn: startIndex + 1,
                endColumn: endIndex + 1
            };
        };
        TokenIterator.prototype.hasNext = function () {
            return this._next !== null;
        };
        TokenIterator.prototype.next = function () {
            var result = this._next;
            this._advanceNext();
            return result;
        };
        TokenIterator.prototype.hasPrev = function () {
            return this._prev !== null;
        };
        TokenIterator.prototype.prev = function () {
            var result = this._prev;
            this._advancePrev();
            return result;
        };
        TokenIterator.prototype._invalidate = function () {
            // replace all public functions with errors
            var errorFn = function () {
                throw new Error('iteration isn\'t valid anymore');
            };
            this.hasNext = errorFn;
            this.next = errorFn;
            this.hasPrev = errorFn;
            this.prev = errorFn;
        };
        return TokenIterator;
    }());
    exports.TokenIterator = TokenIterator;
});

define(__m[76], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?';
    /**
     * Create a word definition regular expression based on default word separators.
     * Optionally provide allowed separators that should be included in words.
     *
     * The default would look like this:
     * /(-?\d*\.\d\w*)|([^\`\~\!\@\#\$\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g
     */
    function createWordRegExp(allowInWords) {
        if (allowInWords === void 0) { allowInWords = ''; }
        var usualSeparators = exports.USUAL_WORD_SEPARATORS;
        var source = '(-?\\d*\\.\\d\\w*)|([^';
        for (var i = 0; i < usualSeparators.length; i++) {
            if (allowInWords.indexOf(usualSeparators[i]) >= 0) {
                continue;
            }
            source += '\\' + usualSeparators[i];
        }
        source += '\\s]+)';
        return new RegExp(source, 'g');
    }
    exports.createWordRegExp = createWordRegExp;
    // catches numbers (including floating numbers) in the first group, and alphanum in the second
    exports.DEFAULT_WORD_REGEXP = createWordRegExp();
    function ensureValidWordDefinition(wordDefinition) {
        var result = exports.DEFAULT_WORD_REGEXP;
        if (wordDefinition && (wordDefinition instanceof RegExp)) {
            if (!wordDefinition.global) {
                var flags = 'g';
                if (wordDefinition.ignoreCase) {
                    flags += 'i';
                }
                if (wordDefinition.multiline) {
                    flags += 'm';
                }
                result = new RegExp(wordDefinition.source, flags);
            }
            else {
                result = wordDefinition;
            }
        }
        result.lastIndex = 0;
        return result;
    }
    exports.ensureValidWordDefinition = ensureValidWordDefinition;
    function getWordAtText(column, wordDefinition, text, textOffset) {
        // console.log('_getWordAtText: ', column, text, textOffset);
        var words = text.match(wordDefinition), k, startWord, endWord, startColumn, endColumn, word;
        if (words) {
            for (k = 0; k < words.length; k++) {
                word = words[k].trim();
                if (word.length > 0) {
                    startWord = text.indexOf(word, endWord);
                    endWord = startWord + word.length;
                    startColumn = textOffset + startWord + 1;
                    endColumn = textOffset + endWord + 1;
                    if (startColumn <= column && column <= endColumn) {
                        return {
                            word: word,
                            startColumn: startColumn,
                            endColumn: endColumn
                        };
                    }
                }
            }
        }
        return null;
    }
    exports.getWordAtText = getWordAtText;
});

define(__m[114], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var AbstractState = (function () {
        function AbstractState(mode, stateData) {
            if (stateData === void 0) { stateData = null; }
            this.mode = mode;
            this.stateData = stateData;
        }
        AbstractState.prototype.getMode = function () {
            return this.mode;
        };
        AbstractState.prototype.clone = function () {
            var result = this.makeClone();
            result.initializeFrom(this);
            return result;
        };
        AbstractState.prototype.makeClone = function () {
            throw new Error('Abstract Method');
        };
        AbstractState.prototype.initializeFrom = function (other) {
            this.stateData = other.stateData !== null ? other.stateData.clone() : null;
        };
        AbstractState.prototype.getStateData = function () {
            return this.stateData;
        };
        AbstractState.prototype.setStateData = function (state) {
            this.stateData = state;
        };
        AbstractState.prototype.equals = function (other) {
            if (other === null || this.mode !== other.getMode()) {
                return false;
            }
            if (other instanceof AbstractState) {
                return AbstractState.safeEquals(this.stateData, other.stateData);
            }
            return false;
        };
        AbstractState.prototype.tokenize = function (stream) {
            throw new Error('Abstract Method');
        };
        AbstractState.safeEquals = function (a, b) {
            if (a === null && b === null) {
                return true;
            }
            if (a === null || b === null) {
                return false;
            }
            return a.equals(b);
        };
        AbstractState.safeClone = function (state) {
            if (state) {
                return state.clone();
            }
            return null;
        };
        return AbstractState;
    }());
    exports.AbstractState = AbstractState;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[375], __M([0,1,132]), function (require, exports, glob_1) {
    'use strict';
    function matches(selection, uri, language) {
        return score(selection, uri, language) > 0;
    }
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = matches;
    function score(selector, uri, language) {
        if (Array.isArray(selector)) {
            // for each
            var values = selector.map(function (item) { return score(item, uri, language); });
            return Math.max.apply(Math, values);
        }
        else if (typeof selector === 'string') {
            // compare language id
            if (selector === language) {
                return 10;
            }
            else if (selector === '*') {
                return 5;
            }
            else {
                return 0;
            }
        }
        else if (selector) {
            var filter = selector;
            var value = 0;
            // language id
            if (filter.language) {
                if (filter.language === language) {
                    value += 10;
                }
                else if (filter.language === '*') {
                    value += 5;
                }
                else {
                    return 0;
                }
            }
            // scheme
            if (filter.scheme) {
                if (filter.scheme === uri.scheme) {
                    value += 10;
                }
                else {
                    return 0;
                }
            }
            // match fsPath with pattern
            if (filter.pattern) {
                if (filter.pattern === uri.fsPath) {
                    value += 10;
                }
                else if (glob_1.match(filter.pattern, uri.fsPath)) {
                    value += 5;
                }
                else {
                    return 0;
                }
            }
            return value;
        }
    }
    exports.score = score;
});

define(__m[170], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LineStream = (function () {
        function LineStream(source) {
            this._source = source;
            this.sourceLength = source.length;
            this._pos = 0;
            this.whitespace = '\t \u00a0';
            this.whitespaceArr = this.stringToArray(this.whitespace);
            this.separators = '';
            this.separatorsArr = this.stringToArray(this.separators);
            this.tokenStart = -1;
            this.tokenEnd = -1;
        }
        LineStream.prototype.stringToArray = function (str) {
            if (!LineStream.STRING_TO_ARRAY_CACHE.hasOwnProperty(str)) {
                LineStream.STRING_TO_ARRAY_CACHE[str] = this.actualStringToArray(str);
            }
            return LineStream.STRING_TO_ARRAY_CACHE[str];
        };
        LineStream.prototype.actualStringToArray = function (str) {
            var maxCharCode = 0;
            for (var i = 0; i < str.length; i++) {
                maxCharCode = Math.max(maxCharCode, str.charCodeAt(i));
            }
            var r = [];
            for (var i = 0; i <= maxCharCode; i++) {
                r[i] = false;
            }
            for (var i = 0; i < str.length; i++) {
                r[str.charCodeAt(i)] = true;
            }
            return r;
        };
        LineStream.prototype.pos = function () {
            return this._pos;
        };
        LineStream.prototype.eos = function () {
            return this._pos >= this.sourceLength;
        };
        LineStream.prototype.peek = function () {
            // Check EOS
            if (this._pos >= this.sourceLength) {
                throw new Error('Stream is at the end');
            }
            return this._source[this._pos];
        };
        LineStream.prototype.next = function () {
            // Check EOS
            if (this._pos >= this.sourceLength) {
                throw new Error('Stream is at the end');
            }
            // Reset peeked token
            this.tokenStart = -1;
            this.tokenEnd = -1;
            return this._source[this._pos++];
        };
        LineStream.prototype.next2 = function () {
            // Check EOS
            if (this._pos >= this.sourceLength) {
                throw new Error('Stream is at the end');
            }
            // Reset peeked token
            this.tokenStart = -1;
            this.tokenEnd = -1;
            this._pos++;
        };
        LineStream.prototype.advance = function (n) {
            if (n === 0) {
                return '';
            }
            var oldPos = this._pos;
            this._pos += n;
            // Reset peeked token
            this.tokenStart = -1;
            this.tokenEnd = -1;
            return this._source.substring(oldPos, this._pos);
        };
        LineStream.prototype._advance2 = function (n) {
            if (n === 0) {
                return n;
            }
            this._pos += n;
            // Reset peeked token
            this.tokenStart = -1;
            this.tokenEnd = -1;
            return n;
        };
        LineStream.prototype.advanceToEOS = function () {
            var oldPos = this._pos;
            this._pos = this.sourceLength;
            this.resetPeekedToken();
            return this._source.substring(oldPos, this._pos);
        };
        LineStream.prototype.goBack = function (n) {
            this._pos -= n;
            this.resetPeekedToken();
        };
        LineStream.prototype.createPeeker = function (condition) {
            var _this = this;
            if (condition instanceof RegExp) {
                return function () {
                    var result = condition.exec(_this._source.substr(_this._pos));
                    if (result === null) {
                        return 0;
                    }
                    else if (result.index !== 0) {
                        throw new Error('Regular expression must begin with the character "^"');
                    }
                    return result[0].length;
                };
            }
            else if ((condition instanceof String || (typeof condition) === 'string') && condition) {
                return function () {
                    var len = condition.length, match = _this._pos + len <= _this.sourceLength;
                    for (var i = 0; match && i < len; i++) {
                        match = _this._source.charCodeAt(_this._pos + i) === condition.charCodeAt(i);
                    }
                    return match ? len : 0;
                };
            }
            throw new Error('Condition must be either a regular expression, function or a non-empty string');
        };
        // --- BEGIN `_advanceIfStringCaseInsensitive`
        LineStream.prototype._advanceIfStringCaseInsensitive = function (condition) {
            var oldPos = this._pos, source = this._source, len = condition.length, i;
            if (len < 1 || oldPos + len > this.sourceLength) {
                return 0;
            }
            for (i = 0; i < len; i++) {
                if (source.charAt(oldPos + i).toLowerCase() !== condition.charAt(i).toLowerCase()) {
                    return 0;
                }
            }
            return len;
        };
        LineStream.prototype.advanceIfStringCaseInsensitive = function (condition) {
            return this.advance(this._advanceIfStringCaseInsensitive(condition));
        };
        LineStream.prototype.advanceIfStringCaseInsensitive2 = function (condition) {
            return this._advance2(this._advanceIfStringCaseInsensitive(condition));
        };
        // --- END
        // --- BEGIN `advanceIfString`
        LineStream.prototype._advanceIfString = function (condition) {
            var oldPos = this._pos, source = this._source, len = condition.length, i;
            if (len < 1 || oldPos + len > this.sourceLength) {
                return 0;
            }
            for (i = 0; i < len; i++) {
                if (source.charCodeAt(oldPos + i) !== condition.charCodeAt(i)) {
                    return 0;
                }
            }
            return len;
        };
        LineStream.prototype.advanceIfString = function (condition) {
            return this.advance(this._advanceIfString(condition));
        };
        LineStream.prototype.advanceIfString2 = function (condition) {
            return this._advance2(this._advanceIfString(condition));
        };
        // --- END
        // --- BEGIN `advanceIfString`
        LineStream.prototype._advanceIfCharCode = function (charCode) {
            if (this._pos < this.sourceLength && this._source.charCodeAt(this._pos) === charCode) {
                return 1;
            }
            return 0;
        };
        LineStream.prototype.advanceIfCharCode = function (charCode) {
            return this.advance(this._advanceIfCharCode(charCode));
        };
        LineStream.prototype.advanceIfCharCode2 = function (charCode) {
            return this._advance2(this._advanceIfCharCode(charCode));
        };
        // --- END
        // --- BEGIN `advanceIfRegExp`
        LineStream.prototype._advanceIfRegExp = function (condition) {
            if (this._pos >= this.sourceLength) {
                return 0;
            }
            if (!condition.test(this._source.substr(this._pos))) {
                return 0;
            }
            return RegExp.lastMatch.length;
        };
        LineStream.prototype.advanceIfRegExp = function (condition) {
            return this.advance(this._advanceIfRegExp(condition));
        };
        LineStream.prototype.advanceIfRegExp2 = function (condition) {
            return this._advance2(this._advanceIfRegExp(condition));
        };
        // --- END
        LineStream.prototype.advanceLoop = function (condition, isWhile, including) {
            if (this.eos()) {
                return '';
            }
            var peeker = this.createPeeker(condition);
            var oldPos = this._pos;
            var n = 0;
            var f = null;
            if (isWhile) {
                f = function (n) {
                    return n > 0;
                };
            }
            else {
                f = function (n) {
                    return n === 0;
                };
            }
            while (!this.eos() && f(n = peeker())) {
                if (n > 0) {
                    this.advance(n);
                }
                else {
                    this.next();
                }
            }
            if (including && !this.eos()) {
                this.advance(n);
            }
            return this._source.substring(oldPos, this._pos);
        };
        LineStream.prototype.advanceWhile = function (condition) {
            return this.advanceLoop(condition, true, false);
        };
        LineStream.prototype.advanceUntil = function (condition, including) {
            return this.advanceLoop(condition, false, including);
        };
        // --- BEGIN `advanceUntilString`
        LineStream.prototype._advanceUntilString = function (condition, including) {
            if (this.eos() || condition.length === 0) {
                return 0;
            }
            var oldPos = this._pos;
            var index = this._source.indexOf(condition, oldPos);
            if (index === -1) {
                // String was not found => advanced to `eos`
                return (this.sourceLength - oldPos);
            }
            if (including) {
                // String was found => advance to include `condition`
                return (index + condition.length - oldPos);
            }
            // String was found => advance right before `condition`
            return (index - oldPos);
        };
        LineStream.prototype.advanceUntilString = function (condition, including) {
            return this.advance(this._advanceUntilString(condition, including));
        };
        LineStream.prototype.advanceUntilString2 = function (condition, including) {
            return this._advance2(this._advanceUntilString(condition, including));
        };
        // --- END
        LineStream.prototype.resetPeekedToken = function () {
            this.tokenStart = -1;
            this.tokenEnd = -1;
        };
        LineStream.prototype.setTokenRules = function (separators, whitespace) {
            if (this.separators !== separators || this.whitespace !== whitespace) {
                this.separators = separators;
                this.separatorsArr = this.stringToArray(this.separators);
                this.whitespace = whitespace;
                this.whitespaceArr = this.stringToArray(this.whitespace);
                this.resetPeekedToken();
            }
        };
        // --- tokens
        LineStream.prototype.peekToken = function () {
            if (this.tokenStart !== -1) {
                return this._source.substring(this.tokenStart, this.tokenEnd);
            }
            var source = this._source, sourceLength = this.sourceLength, whitespaceArr = this.whitespaceArr, separatorsArr = this.separatorsArr, tokenStart = this._pos;
            // Check EOS
            if (tokenStart >= sourceLength) {
                throw new Error('Stream is at the end');
            }
            // Skip whitespace
            while (whitespaceArr[source.charCodeAt(tokenStart)] && tokenStart < sourceLength) {
                tokenStart++;
            }
            var tokenEnd = tokenStart;
            // If a separator is hit, it is a token
            if (separatorsArr[source.charCodeAt(tokenEnd)] && tokenEnd < sourceLength) {
                tokenEnd++;
            }
            else {
                // Advance until a separator or a whitespace is hit
                while (!separatorsArr[source.charCodeAt(tokenEnd)] && !whitespaceArr[source.charCodeAt(tokenEnd)] && tokenEnd < sourceLength) {
                    tokenEnd++;
                }
            }
            // Cache peeked token
            this.tokenStart = tokenStart;
            this.tokenEnd = tokenEnd;
            return source.substring(tokenStart, tokenEnd);
        };
        LineStream.prototype.nextToken = function () {
            // Check EOS
            if (this._pos >= this.sourceLength) {
                throw new Error('Stream is at the end');
            }
            // Peek token if necessary
            var result;
            if (this.tokenStart === -1) {
                result = this.peekToken();
            }
            else {
                result = this._source.substring(this.tokenStart, this.tokenEnd);
            }
            // Advance to tokenEnd
            this._pos = this.tokenEnd;
            // Reset peeked token
            this.tokenStart = -1;
            this.tokenEnd = -1;
            return result;
        };
        // -- whitespace
        LineStream.prototype.peekWhitespace = function () {
            var source = this._source, sourceLength = this.sourceLength, whitespaceArr = this.whitespaceArr, peek = this._pos;
            while (whitespaceArr[source.charCodeAt(peek)] && peek < sourceLength) {
                peek++;
            }
            return source.substring(this._pos, peek);
        };
        // --- BEGIN `advanceIfRegExp`
        LineStream.prototype._skipWhitespace = function () {
            var source = this._source, sourceLength = this.sourceLength, whitespaceArr = this.whitespaceArr, oldPos = this._pos, peek = this._pos;
            while (whitespaceArr[source.charCodeAt(peek)] && peek < sourceLength) {
                peek++;
            }
            return (peek - oldPos);
        };
        LineStream.prototype.skipWhitespace = function () {
            return this.advance(this._skipWhitespace());
        };
        LineStream.prototype.skipWhitespace2 = function () {
            return this._advance2(this._skipWhitespace());
        };
        LineStream.STRING_TO_ARRAY_CACHE = {};
        return LineStream;
    }());
    exports.LineStream = LineStream;
});

define(__m[377], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // State machine for http:// or https://
    var STATE_MAP = [], START_STATE = 1, END_STATE = 9, ACCEPT_STATE = 10;
    STATE_MAP[1] = { 'h': 2, 'H': 2, 'f': 11, 'F': 11 };
    STATE_MAP[2] = { 't': 3, 'T': 3 };
    STATE_MAP[3] = { 't': 4, 'T': 4 };
    STATE_MAP[4] = { 'p': 5, 'P': 5 };
    STATE_MAP[5] = { 's': 6, 'S': 6, ':': 7 };
    STATE_MAP[6] = { ':': 7 };
    STATE_MAP[7] = { '/': 8 };
    STATE_MAP[8] = { '/': 9 };
    STATE_MAP[11] = { 'i': 12, 'I': 12 };
    STATE_MAP[12] = { 'l': 13, 'L': 13 };
    STATE_MAP[13] = { 'e': 6, 'E': 6 };
    var CharacterClass;
    (function (CharacterClass) {
        CharacterClass[CharacterClass["None"] = 0] = "None";
        CharacterClass[CharacterClass["ForceTermination"] = 1] = "ForceTermination";
        CharacterClass[CharacterClass["CannotEndIn"] = 2] = "CannotEndIn";
    })(CharacterClass || (CharacterClass = {}));
    var _openParens = '('.charCodeAt(0);
    var _closeParens = ')'.charCodeAt(0);
    var _openSquareBracket = '['.charCodeAt(0);
    var _closeSquareBracket = ']'.charCodeAt(0);
    var _openCurlyBracket = '{'.charCodeAt(0);
    var _closeCurlyBracket = '}'.charCodeAt(0);
    var CharacterClassifier = (function () {
        function CharacterClassifier() {
            var FORCE_TERMINATION_CHARACTERS = ' \t<>\'\"';
            var CANNOT_END_WITH_CHARACTERS = '.,;';
            this._asciiMap = [];
            for (var i = 0; i < 256; i++) {
                this._asciiMap[i] = CharacterClass.None;
            }
            this._map = [];
            for (var i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
                this._set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), CharacterClass.ForceTermination);
            }
            for (var i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
                this._set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), CharacterClass.CannotEndIn);
            }
        }
        CharacterClassifier.prototype._set = function (charCode, charClass) {
            if (charCode < 256) {
                this._asciiMap[charCode] = charClass;
            }
            this._map[charCode] = charClass;
        };
        CharacterClassifier.prototype.classify = function (charCode) {
            if (charCode < 256) {
                return this._asciiMap[charCode];
            }
            var charClass = this._map[charCode];
            if (charClass) {
                return charClass;
            }
            return CharacterClass.None;
        };
        return CharacterClassifier;
    }());
    var LinkComputer = (function () {
        function LinkComputer() {
        }
        LinkComputer._createLink = function (line, lineNumber, linkBeginIndex, linkEndIndex) {
            return {
                range: {
                    startLineNumber: lineNumber,
                    startColumn: linkBeginIndex + 1,
                    endLineNumber: lineNumber,
                    endColumn: linkEndIndex + 1
                },
                url: line.substring(linkBeginIndex, linkEndIndex)
            };
        };
        LinkComputer.computeLinks = function (model) {
            var i, lineCount, result = [];
            var line, j, lastIncludedCharIndex, len, linkBeginIndex, state, ch, chCode, chClass, resetStateMachine, hasOpenParens, hasOpenSquareBracket, hasOpenCurlyBracket, characterClassifier = LinkComputer._characterClassifier;
            for (i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
                line = model.getLineContent(i);
                j = 0;
                len = line.length;
                linkBeginIndex = 0;
                state = START_STATE;
                hasOpenParens = false;
                hasOpenSquareBracket = false;
                hasOpenCurlyBracket = false;
                while (j < len) {
                    ch = line.charAt(j);
                    chCode = line.charCodeAt(j);
                    resetStateMachine = false;
                    if (state === ACCEPT_STATE) {
                        switch (chCode) {
                            case _openParens:
                                hasOpenParens = true;
                                chClass = CharacterClass.None;
                                break;
                            case _closeParens:
                                chClass = (hasOpenParens ? CharacterClass.None : CharacterClass.ForceTermination);
                                break;
                            case _openSquareBracket:
                                hasOpenSquareBracket = true;
                                chClass = CharacterClass.None;
                                break;
                            case _closeSquareBracket:
                                chClass = (hasOpenSquareBracket ? CharacterClass.None : CharacterClass.ForceTermination);
                                break;
                            case _openCurlyBracket:
                                hasOpenCurlyBracket = true;
                                chClass = CharacterClass.None;
                                break;
                            case _closeCurlyBracket:
                                chClass = (hasOpenCurlyBracket ? CharacterClass.None : CharacterClass.ForceTermination);
                                break;
                            default:
                                chClass = characterClassifier.classify(chCode);
                        }
                        // Check if character terminates link
                        if (chClass === CharacterClass.ForceTermination) {
                            // Do not allow to end link in certain characters...
                            lastIncludedCharIndex = j - 1;
                            do {
                                chCode = line.charCodeAt(lastIncludedCharIndex);
                                chClass = characterClassifier.classify(chCode);
                                if (chClass !== CharacterClass.CannotEndIn) {
                                    break;
                                }
                                lastIncludedCharIndex--;
                            } while (lastIncludedCharIndex > linkBeginIndex);
                            result.push(LinkComputer._createLink(line, i, linkBeginIndex, lastIncludedCharIndex + 1));
                            resetStateMachine = true;
                        }
                    }
                    else if (state === END_STATE) {
                        chClass = characterClassifier.classify(chCode);
                        // Check if character terminates link
                        if (chClass === CharacterClass.ForceTermination) {
                            resetStateMachine = true;
                        }
                        else {
                            state = ACCEPT_STATE;
                        }
                    }
                    else {
                        if (STATE_MAP[state].hasOwnProperty(ch)) {
                            state = STATE_MAP[state][ch];
                        }
                        else {
                            resetStateMachine = true;
                        }
                    }
                    if (resetStateMachine) {
                        state = START_STATE;
                        hasOpenParens = false;
                        hasOpenSquareBracket = false;
                        hasOpenCurlyBracket = false;
                        // Record where the link started
                        linkBeginIndex = j + 1;
                    }
                    j++;
                }
                if (state === ACCEPT_STATE) {
                    result.push(LinkComputer._createLink(line, i, linkBeginIndex, len));
                }
            }
            return result;
        };
        LinkComputer._characterClassifier = new CharacterClassifier();
        return LinkComputer;
    }());
    /**
     * Returns an array of all links contains in the provided
     * document. *Note* that this operation is computational
     * expensive and should not run in the UI thread.
     */
    function computeLinks(model) {
        if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {
            // Unknown caller!
            return [];
        }
        return LinkComputer.computeLinks(model);
    }
    exports.computeLinks = computeLinks;
});

define(__m[117], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /*
     * This module exports common types and functionality shared between
     * the Monarch compiler that compiles JSON to ILexer, and the Monarch
     * Tokenizer (that highlights at runtime)
     */
    /*
     * Type definitions to be used internally to Monarch.
     * Inside monarch we use fully typed definitions and compiled versions of the more abstract JSON descriptions.
     */
    (function (MonarchBracket) {
        MonarchBracket[MonarchBracket["None"] = 0] = "None";
        MonarchBracket[MonarchBracket["Open"] = 1] = "Open";
        MonarchBracket[MonarchBracket["Close"] = -1] = "Close";
    })(exports.MonarchBracket || (exports.MonarchBracket = {}));
    var MonarchBracket = exports.MonarchBracket;
    // Small helper functions
    /**
     * Is a string null, undefined, or empty?
     */
    function empty(s) {
        return (s ? false : true);
    }
    exports.empty = empty;
    /**
     * Puts a string to lower case if 'ignoreCase' is set.
     */
    function fixCase(lexer, str) {
        return (lexer.ignoreCase && str ? str.toLowerCase() : str);
    }
    exports.fixCase = fixCase;
    /**
     * Ensures there are no bad characters in a CSS token class.
     */
    function sanitize(s) {
        return s.replace(/[&<>'"_]/g, '-'); // used on all output token CSS classes
    }
    exports.sanitize = sanitize;
    // Logging
    /**
     * Logs a message.
     */
    function log(lexer, msg) {
        console.log(lexer.languageId + ": " + msg);
    }
    exports.log = log;
    // Throwing errors
    /**
     * Throws error. May actually just log the error and continue.
     */
    function throwError(lexer, msg) {
        throw new Error(lexer.languageId + ": " + msg);
    }
    exports.throwError = throwError;
    // Helper functions for rule finding and substitution
    /**
     * substituteMatches is used on lexer strings and can substitutes predefined patterns:
     * 		$$  => $
     * 		$#  => id
     * 		$n  => matched entry n
     * 		@attr => contents of lexer[attr]
     *
     * See documentation for more info
     */
    function substituteMatches(lexer, str, id, matches, state) {
        var re = /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g;
        var stateMatches = null;
        return str.replace(re, function (full, sub, dollar, hash, n, s, attr, ofs, total) {
            if (!empty(dollar)) {
                return '$'; // $$
            }
            if (!empty(hash)) {
                return fixCase(lexer, id); // default $#
            }
            if (!empty(n) && n < matches.length) {
                return fixCase(lexer, matches[n]); // $n
            }
            if (!empty(attr) && lexer && typeof (lexer[attr]) === 'string') {
                return lexer[attr]; //@attribute
            }
            if (stateMatches === null) {
                stateMatches = state.split('.');
                stateMatches.unshift(state);
            }
            if (!empty(s) && s < stateMatches.length) {
                return fixCase(lexer, stateMatches[s]); //$Sn
            }
            return '';
        });
    }
    exports.substituteMatches = substituteMatches;
    /**
     * Find the tokenizer rules for a specific state (i.e. next action)
     */
    function findRules(lexer, state) {
        while (state && state.length > 0) {
            var rules = lexer.tokenizer[state];
            if (rules) {
                return rules;
            }
            var idx = state.lastIndexOf('.');
            if (idx < 0) {
                state = null; // no further parent
            }
            else {
                state = state.substr(0, idx);
            }
        }
        return null;
    }
    exports.findRules = findRules;
    /**
     * Is a certain state defined? In contrast to 'findRules' this works on a ILexerMin.
     * This is used during compilation where we may know the defined states
     * but not yet whether the corresponding rules are correct.
     */
    function stateExists(lexer, state) {
        while (state && state.length > 0) {
            var exist = lexer.stateNames[state];
            if (exist) {
                return true;
            }
            var idx = state.lastIndexOf('.');
            if (idx < 0) {
                state = null; // no further parent
            }
            else {
                state = state.substr(0, idx);
            }
        }
        return false;
    }
    exports.stateExists = stateExists;
});

define(__m[131], __M([0,1,31,117]), function (require, exports, objects, monarchCommon) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /*
     * Type helpers
     *
     * Note: this is just for sanity checks on the JSON description which is
     * helpful for the programmer. No checks are done anymore once the lexer is
     * already 'compiled and checked'.
     *
     */
    function isArrayOf(elemType, obj) {
        if (!obj) {
            return false;
        }
        if (!(Array.isArray(obj))) {
            return false;
        }
        var idx;
        for (idx in obj) {
            if (obj.hasOwnProperty(idx)) {
                if (!(elemType(obj[idx]))) {
                    return false;
                }
            }
        }
        return true;
    }
    function bool(prop, def, onerr) {
        if (typeof (prop) === 'boolean') {
            return prop;
        }
        if (onerr && (prop || def === undefined)) {
            onerr(); // type is wrong, or there is no default
        }
        return (def === undefined ? null : def);
    }
    function string(prop, def, onerr) {
        if (typeof (prop) === 'string') {
            return prop;
        }
        if (onerr && (prop || def === undefined)) {
            onerr(); // type is wrong, or there is no default
        }
        return (def === undefined ? null : def);
    }
    // Lexer helpers
    /**
     * Compiles a regular expression string, adding the 'i' flag if 'ignoreCase' is set.
     * Also replaces @\w+ or sequences with the content of the specified attribute
     */
    function compileRegExp(lexer, str) {
        if (typeof (str) !== 'string') {
            return null;
        }
        var n = 0;
        while (str.indexOf('@') >= 0 && n < 5) {
            n++;
            str = str.replace(/@(\w+)/g, function (s, attr) {
                var sub = '';
                if (typeof (lexer[attr]) === 'string') {
                    sub = lexer[attr];
                }
                else if (lexer[attr] && lexer[attr] instanceof RegExp) {
                    sub = lexer[attr].source;
                }
                else {
                    if (lexer[attr] === undefined) {
                        monarchCommon.throwError(lexer, 'language definition does not contain attribute \'' + attr + '\', used at: ' + str);
                    }
                    else {
                        monarchCommon.throwError(lexer, 'attribute reference \'' + attr + '\' must be a string, used at: ' + str);
                    }
                }
                return (monarchCommon.empty(sub) ? '' : '(?:' + sub + ')');
            });
        }
        return new RegExp(str, (lexer.ignoreCase ? 'i' : ''));
    }
    /**
     * Compiles guard functions for case matches.
     * This compiles 'cases' attributes into efficient match functions.
     *
     */
    function selectScrutinee(id, matches, state, num) {
        if (num < 0) {
            return id;
        }
        if (num < matches.length) {
            return matches[num];
        }
        if (num >= 100) {
            num = num - 100;
            var parts = state.split('.');
            parts.unshift(state);
            if (num < parts.length) {
                return parts[num];
            }
        }
        return null;
    }
    function createGuard(lexer, ruleName, tkey, val) {
        // get the scrutinee and pattern
        var scrut = -1; // -1: $!, 0-99: $n, 100+n: $Sn
        var oppat = tkey;
        var matches = tkey.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
        if (matches) {
            if (matches[3]) {
                scrut = parseInt(matches[3]);
                if (matches[2]) {
                    scrut = scrut + 100; // if [sS] present
                }
            }
            oppat = matches[4];
        }
        // get operator
        var op = '~';
        var pat = oppat;
        if (!oppat || oppat.length === 0) {
            op = '!=';
            pat = '';
        }
        else if (/^\w*$/.test(pat)) {
            op = '==';
        }
        else {
            matches = oppat.match(/^(@|!@|~|!~|==|!=)(.*)$/);
            if (matches) {
                op = matches[1];
                pat = matches[2];
            }
        }
        // set the tester function
        var tester;
        // special case a regexp that matches just words
        if ((op === '~' || op === '!~') && /^(\w|\|)*$/.test(pat)) {
            var inWords = objects.createKeywordMatcher(pat.split('|'), lexer.ignoreCase);
            tester = function (s) { return (op === '~' ? inWords(s) : !inWords(s)); };
        }
        else if (op === '@' || op === '!@') {
            var words = lexer[pat];
            if (!words) {
                monarchCommon.throwError(lexer, 'the @ match target \'' + pat + '\' is not defined, in rule: ' + ruleName);
            }
            if (!(isArrayOf(function (elem) { return (typeof (elem) === 'string'); }, words))) {
                monarchCommon.throwError(lexer, 'the @ match target \'' + pat + '\' must be an array of strings, in rule: ' + ruleName);
            }
            var inWords = objects.createKeywordMatcher(words, lexer.ignoreCase);
            tester = function (s) { return (op === '@' ? inWords(s) : !inWords(s)); };
        }
        else if (op === '~' || op === '!~') {
            if (pat.indexOf('$') < 0) {
                // precompile regular expression
                var re = compileRegExp(lexer, '^' + pat + '$');
                tester = function (s) { return (op === '~' ? re.test(s) : !re.test(s)); };
            }
            else {
                tester = function (s, id, matches, state) {
                    var re = compileRegExp(lexer, '^' + monarchCommon.substituteMatches(lexer, pat, id, matches, state) + '$');
                    return re.test(s);
                };
            }
        }
        else {
            if (pat.indexOf('$') < 0) {
                var patx = monarchCommon.fixCase(lexer, pat);
                tester = function (s) { return (op === '==' ? s === patx : s !== patx); };
            }
            else {
                var patx = monarchCommon.fixCase(lexer, pat);
                tester = function (s, id, matches, state, eos) {
                    var patexp = monarchCommon.substituteMatches(lexer, patx, id, matches, state);
                    return (op === '==' ? s === patexp : s !== patexp);
                };
            }
        }
        // return the branch object
        if (scrut === -1) {
            return {
                name: tkey, value: val, test: function (id, matches, state, eos) {
                    return tester(id, id, matches, state, eos);
                }
            };
        }
        else {
            return {
                name: tkey, value: val, test: function (id, matches, state, eos) {
                    var scrutinee = selectScrutinee(id, matches, state, scrut);
                    return tester(!scrutinee ? '' : scrutinee, id, matches, state, eos);
                }
            };
        }
    }
    /**
     * Compiles an action: i.e. optimize regular expressions and case matches
     * and do many sanity checks.
     *
     * This is called only during compilation but if the lexer definition
     * contains user functions as actions (which is usually not allowed), then this
     * may be called during lexing. It is important therefore to compile common cases efficiently
     */
    function compileAction(lexer, ruleName, action) {
        if (!action) {
            return { token: '' };
        }
        else if (typeof (action) === 'string') {
            return action; // { token: action };
        }
        else if (action.token || action.token === '') {
            if (typeof (action.token) !== 'string') {
                monarchCommon.throwError(lexer, 'a \'token\' attribute must be of type string, in rule: ' + ruleName);
                return { token: '' };
            }
            else {
                // only copy specific typed fields (only happens once during compile Lexer)
                var newAction = { token: action.token };
                if (action.token.indexOf('$') >= 0) {
                    newAction.tokenSubst = true;
                }
                if (typeof (action.bracket) === 'string') {
                    if (action.bracket === '@open') {
                        newAction.bracket = monarchCommon.MonarchBracket.Open;
                    }
                    else if (action.bracket === '@close') {
                        newAction.bracket = monarchCommon.MonarchBracket.Close;
                    }
                    else {
                        monarchCommon.throwError(lexer, 'a \'bracket\' attribute must be either \'@open\' or \'@close\', in rule: ' + ruleName);
                    }
                }
                if (action.next) {
                    if (typeof (action.next) !== 'string') {
                        monarchCommon.throwError(lexer, 'the next state must be a string value in rule: ' + ruleName);
                    }
                    else {
                        var next = action.next;
                        if (!/^(@pop|@push|@popall)$/.test(next)) {
                            if (next[0] === '@') {
                                next = next.substr(1); // peel off starting @ sign
                            }
                            if (next.indexOf('$') < 0) {
                                if (!monarchCommon.stateExists(lexer, monarchCommon.substituteMatches(lexer, next, '', [], ''))) {
                                    monarchCommon.throwError(lexer, 'the next state \'' + action.next + '\' is not defined in rule: ' + ruleName);
                                }
                            }
                        }
                        newAction.next = next;
                    }
                }
                if (typeof (action.goBack) === 'number') {
                    newAction.goBack = action.goBack;
                }
                if (typeof (action.switchTo) === 'string') {
                    newAction.switchTo = action.switchTo;
                }
                if (typeof (action.log) === 'string') {
                    newAction.log = action.log;
                }
                if (typeof (action.nextEmbedded) === 'string') {
                    newAction.nextEmbedded = action.nextEmbedded;
                    lexer.usesEmbedded = true;
                }
                return newAction;
            }
        }
        else if (Array.isArray(action)) {
            var results = [];
            var idx;
            for (idx in action) {
                if (action.hasOwnProperty(idx)) {
                    results[idx] = compileAction(lexer, ruleName, action[idx]);
                }
            }
            return { group: results };
        }
        else if (action.cases) {
            // build an array of test cases
            var cases = [];
            // for each case, push a test function and result value
            var tkey;
            for (tkey in action.cases) {
                if (action.cases.hasOwnProperty(tkey)) {
                    var val = compileAction(lexer, ruleName, action.cases[tkey]);
                    // what kind of case
                    if (tkey === '@default' || tkey === '@' || tkey === '') {
                        cases.push({ test: null, value: val, name: tkey });
                    }
                    else if (tkey === '@eos') {
                        cases.push({ test: function (id, matches, state, eos) { return eos; }, value: val, name: tkey });
                    }
                    else {
                        cases.push(createGuard(lexer, ruleName, tkey, val)); // call separate function to avoid local variable capture
                    }
                }
            }
            // create a matching function
            var def = lexer.defaultToken;
            return {
                test: function (id, matches, state, eos) {
                    var idx;
                    for (idx in cases) {
                        if (cases.hasOwnProperty(idx)) {
                            var didmatch = (!cases[idx].test || cases[idx].test(id, matches, state, eos));
                            if (didmatch) {
                                return cases[idx].value;
                            }
                        }
                    }
                    return def;
                }
            };
        }
        else {
            monarchCommon.throwError(lexer, 'an action must be a string, an object with a \'token\' or \'cases\' attribute, or an array of actions; in rule: ' + ruleName);
            return '';
        }
    }
    /**
     * Helper class for creating matching rules
     */
    var Rule = (function () {
        function Rule(name) {
            this.regex = new RegExp('');
            this.action = { token: '' };
            this.matchOnlyAtLineStart = false;
            this.name = '';
            this.name = name;
        }
        Rule.prototype.setRegex = function (lexer, re) {
            var sregex;
            if (typeof (re) === 'string') {
                sregex = re;
            }
            else if (re instanceof RegExp) {
                sregex = re.source;
            }
            else {
                monarchCommon.throwError(lexer, 'rules must start with a match string or regular expression: ' + this.name);
            }
            this.matchOnlyAtLineStart = (sregex.length > 0 && sregex[0] === '^');
            this.name = this.name + ': ' + sregex;
            this.regex = compileRegExp(lexer, '^(?:' + (this.matchOnlyAtLineStart ? sregex.substr(1) : sregex) + ')');
        };
        Rule.prototype.setAction = function (lexer, act) {
            this.action = compileAction(lexer, this.name, act);
        };
        return Rule;
    }());
    /**
     * Compiles a json description function into json where all regular expressions,
     * case matches etc, are compiled and all include rules are expanded.
     * We also compile the bracket definitions, supply defaults, and do many sanity checks.
     * If the 'jsonStrict' parameter is 'false', we allow at certain locations
     * regular expression objects and functions that get called during lexing.
     * (Currently we have no samples that need this so perhaps we should always have
     * jsonStrict to true).
     */
    function compile(languageId, json) {
        if (!json || typeof (json) !== 'object') {
            throw new Error('Monarch: expecting a language definition object');
        }
        // Create our lexer
        var lexer = {};
        lexer.languageId = languageId;
        lexer.noThrow = false; // raise exceptions during compilation
        lexer.maxStack = 100;
        // Set standard fields: be defensive about types
        lexer.start = string(json.start);
        lexer.ignoreCase = bool(json.ignoreCase, false);
        lexer.tokenPostfix = string(json.tokenPostfix, '.' + lexer.languageId);
        lexer.defaultToken = string(json.defaultToken, 'source', function () { monarchCommon.throwError(lexer, 'the \'defaultToken\' must be a string'); });
        lexer.usesEmbedded = false; // becomes true if we find a nextEmbedded action
        // For calling compileAction later on
        var lexerMin = json;
        lexerMin.languageId = languageId;
        lexerMin.ignoreCase = lexer.ignoreCase;
        lexerMin.noThrow = lexer.noThrow;
        lexerMin.usesEmbedded = lexer.usesEmbedded;
        lexerMin.stateNames = json.tokenizer;
        lexerMin.defaultToken = lexer.defaultToken;
        // Compile an array of rules into newrules where RegExp objects are created.
        function addRules(state, newrules, rules) {
            var idx;
            for (idx in rules) {
                if (rules.hasOwnProperty(idx)) {
                    var rule = rules[idx];
                    var include = rule.include;
                    if (include) {
                        if (typeof (include) !== 'string') {
                            monarchCommon.throwError(lexer, 'an \'include\' attribute must be a string at: ' + state);
                        }
                        if (include[0] === '@') {
                            include = include.substr(1); // peel off starting @
                        }
                        if (!json.tokenizer[include]) {
                            monarchCommon.throwError(lexer, 'include target \'' + include + '\' is not defined at: ' + state);
                        }
                        addRules(state + '.' + include, newrules, json.tokenizer[include]);
                    }
                    else {
                        var newrule = new Rule(state);
                        // Set up new rule attributes
                        if (Array.isArray(rule) && rule.length >= 1 && rule.length <= 3) {
                            newrule.setRegex(lexerMin, rule[0]);
                            if (rule.length >= 3) {
                                if (typeof (rule[1]) === 'string') {
                                    newrule.setAction(lexerMin, { token: rule[1], next: rule[2] });
                                }
                                else if (typeof (rule[1]) === 'object') {
                                    var rule1 = rule[1];
                                    rule1.next = rule[2];
                                    newrule.setAction(lexerMin, rule1);
                                }
                                else {
                                    monarchCommon.throwError(lexer, 'a next state as the last element of a rule can only be given if the action is either an object or a string, at: ' + state);
                                }
                            }
                            else {
                                newrule.setAction(lexerMin, rule[1]);
                            }
                        }
                        else {
                            if (!rule.regex) {
                                monarchCommon.throwError(lexer, 'a rule must either be an array, or an object with a \'regex\' or \'include\' field at: ' + state);
                            }
                            if (rule.name) {
                                newrule.name = string(rule.name);
                            }
                            if (rule.matchOnlyAtStart) {
                                newrule.matchOnlyAtLineStart = bool(rule.matchOnlyAtLineStart);
                            }
                            newrule.setRegex(lexerMin, rule.regex);
                            newrule.setAction(lexerMin, rule.action);
                        }
                        newrules.push(newrule);
                    }
                }
            }
        }
        // compile the tokenizer rules
        if (!json.tokenizer || typeof (json.tokenizer) !== 'object') {
            monarchCommon.throwError(lexer, 'a language definition must define the \'tokenizer\' attribute as an object');
        }
        lexer.tokenizer = [];
        var key;
        for (key in json.tokenizer) {
            if (json.tokenizer.hasOwnProperty(key)) {
                if (!lexer.start) {
                    lexer.start = key;
                }
                var rules = json.tokenizer[key];
                lexer.tokenizer[key] = new Array();
                addRules('tokenizer.' + key, lexer.tokenizer[key], rules);
            }
        }
        lexer.usesEmbedded = lexerMin.usesEmbedded; // can be set during compileAction
        // Set simple brackets
        if (json.brackets) {
            if (!(Array.isArray(json.brackets))) {
                monarchCommon.throwError(lexer, 'the \'brackets\' attribute must be defined as an array');
            }
        }
        else {
            json.brackets = [
                { open: '{', close: '}', token: 'delimiter.curly' },
                { open: '[', close: ']', token: 'delimiter.square' },
                { open: '(', close: ')', token: 'delimiter.parenthesis' },
                { open: '<', close: '>', token: 'delimiter.angle' }];
        }
        var brackets = [];
        for (var bracketIdx in json.brackets) {
            if (json.brackets.hasOwnProperty(bracketIdx)) {
                var desc = json.brackets[bracketIdx];
                if (desc && Array.isArray(desc) && desc.length === 3) {
                    desc = { token: desc[2], open: desc[0], close: desc[1] };
                }
                if (desc.open === desc.close) {
                    monarchCommon.throwError(lexer, 'open and close brackets in a \'brackets\' attribute must be different: ' + desc.open +
                        '\n hint: use the \'bracket\' attribute if matching on equal brackets is required.');
                }
                if (typeof (desc.open) === 'string' && typeof (desc.token) === 'string') {
                    brackets.push({
                        token: string(desc.token) + lexer.tokenPostfix,
                        open: monarchCommon.fixCase(lexer, string(desc.open)),
                        close: monarchCommon.fixCase(lexer, string(desc.close))
                    });
                }
                else {
                    monarchCommon.throwError(lexer, 'every element in the \'brackets\' array must be a \'{open,close,token}\' object or array');
                }
            }
        }
        lexer.brackets = brackets;
        // Disable throw so the syntax highlighter goes, no matter what
        lexer.noThrow = true;
        return lexer;
    }
    exports.compile = compile;
});

define(__m[121], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var NullState = (function () {
        function NullState(mode, stateData) {
            this.mode = mode;
            this.stateData = stateData;
        }
        NullState.prototype.clone = function () {
            var stateDataClone = (this.stateData ? this.stateData.clone() : null);
            return new NullState(this.mode, stateDataClone);
        };
        NullState.prototype.equals = function (other) {
            if (this.mode !== other.getMode()) {
                return false;
            }
            var otherStateData = other.getStateData();
            if (!this.stateData && !otherStateData) {
                return true;
            }
            if (this.stateData && otherStateData) {
                return this.stateData.equals(otherStateData);
            }
            return false;
        };
        NullState.prototype.getMode = function () {
            return this.mode;
        };
        NullState.prototype.tokenize = function (stream) {
            stream.advanceToEOS();
            return { type: '' };
        };
        NullState.prototype.getStateData = function () {
            return this.stateData;
        };
        NullState.prototype.setStateData = function (stateData) {
            this.stateData = stateData;
        };
        return NullState;
    }());
    exports.NullState = NullState;
    var NullMode = (function () {
        function NullMode() {
        }
        NullMode.prototype.getId = function () {
            return NullMode.ID;
        };
        NullMode.prototype.toSimplifiedMode = function () {
            return this;
        };
        NullMode.ID = 'vs.editor.modes.nullMode';
        return NullMode;
    }());
    exports.NullMode = NullMode;
    function nullTokenize(mode, buffer, state, deltaOffset, stopAtOffset) {
        if (deltaOffset === void 0) { deltaOffset = 0; }
        var tokens = [
            {
                startIndex: deltaOffset,
                type: ''
            }
        ];
        var modeTransitions = [
            {
                startIndex: deltaOffset,
                mode: mode
            }
        ];
        return {
            tokens: tokens,
            actualStopOffset: deltaOffset + buffer.length,
            endState: state,
            modeTransitions: modeTransitions
        };
    }
    exports.nullTokenize = nullTokenize;
});

define(__m[49], __M([0,1,10,31,88]), function (require, exports, strings, objects, modeTransition_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Token = (function () {
        function Token(startIndex, type) {
            this.startIndex = startIndex;
            this.type = type;
        }
        Token.prototype.toString = function () {
            return '(' + this.startIndex + ', ' + this.type + ')';
        };
        return Token;
    }());
    exports.Token = Token;
    var LineTokens = (function () {
        function LineTokens(tokens, modeTransitions, actualStopOffset, endState) {
            this.tokens = tokens;
            this.modeTransitions = modeTransitions;
            this.actualStopOffset = actualStopOffset;
            this.endState = endState;
            this.retokenize = null;
        }
        return LineTokens;
    }());
    exports.LineTokens = LineTokens;
    function handleEvent(context, offset, runner) {
        var modeTransitions = context.modeTransitions;
        if (modeTransitions.length === 1) {
            return runner(modeTransitions[0].modeId, context, offset);
        }
        var modeIndex = modeTransition_1.ModeTransition.findIndexInSegmentsArray(modeTransitions, offset);
        var nestedMode = modeTransitions[modeIndex].mode;
        var modeStartIndex = modeTransitions[modeIndex].startIndex;
        var firstTokenInModeIndex = context.findIndexOfOffset(modeStartIndex);
        var nextCharacterAfterModeIndex = -1;
        var nextTokenAfterMode = -1;
        if (modeIndex + 1 < modeTransitions.length) {
            nextTokenAfterMode = context.findIndexOfOffset(modeTransitions[modeIndex + 1].startIndex);
            nextCharacterAfterModeIndex = context.getTokenStartIndex(nextTokenAfterMode);
        }
        else {
            nextTokenAfterMode = context.getTokenCount();
            nextCharacterAfterModeIndex = context.getLineContent().length;
        }
        var firstTokenCharacterOffset = context.getTokenStartIndex(firstTokenInModeIndex);
        var newCtx = new FilteredLineContext(context, nestedMode, firstTokenInModeIndex, nextTokenAfterMode, firstTokenCharacterOffset, nextCharacterAfterModeIndex);
        return runner(nestedMode.getId(), newCtx, offset - firstTokenCharacterOffset);
    }
    exports.handleEvent = handleEvent;
    var FilteredLineContext = (function () {
        function FilteredLineContext(actual, mode, firstTokenInModeIndex, nextTokenAfterMode, firstTokenCharacterOffset, nextCharacterAfterModeIndex) {
            this.modeTransitions = [new modeTransition_1.ModeTransition(0, mode)];
            this._actual = actual;
            this._firstTokenInModeIndex = firstTokenInModeIndex;
            this._nextTokenAfterMode = nextTokenAfterMode;
            this._firstTokenCharacterOffset = firstTokenCharacterOffset;
            this._nextCharacterAfterModeIndex = nextCharacterAfterModeIndex;
        }
        FilteredLineContext.prototype.getLineContent = function () {
            var actualLineContent = this._actual.getLineContent();
            return actualLineContent.substring(this._firstTokenCharacterOffset, this._nextCharacterAfterModeIndex);
        };
        FilteredLineContext.prototype.getTokenCount = function () {
            return this._nextTokenAfterMode - this._firstTokenInModeIndex;
        };
        FilteredLineContext.prototype.findIndexOfOffset = function (offset) {
            return this._actual.findIndexOfOffset(offset + this._firstTokenCharacterOffset) - this._firstTokenInModeIndex;
        };
        FilteredLineContext.prototype.getTokenStartIndex = function (tokenIndex) {
            return this._actual.getTokenStartIndex(tokenIndex + this._firstTokenInModeIndex) - this._firstTokenCharacterOffset;
        };
        FilteredLineContext.prototype.getTokenEndIndex = function (tokenIndex) {
            return this._actual.getTokenEndIndex(tokenIndex + this._firstTokenInModeIndex) - this._firstTokenCharacterOffset;
        };
        FilteredLineContext.prototype.getTokenType = function (tokenIndex) {
            return this._actual.getTokenType(tokenIndex + this._firstTokenInModeIndex);
        };
        FilteredLineContext.prototype.getTokenText = function (tokenIndex) {
            return this._actual.getTokenText(tokenIndex + this._firstTokenInModeIndex);
        };
        return FilteredLineContext;
    }());
    exports.FilteredLineContext = FilteredLineContext;
    var IGNORE_IN_TOKENS = /\b(comment|string|regex)\b/;
    function ignoreBracketsInToken(tokenType) {
        return IGNORE_IN_TOKENS.test(tokenType);
    }
    exports.ignoreBracketsInToken = ignoreBracketsInToken;
    // TODO@Martin: find a better home for this code:
    // TODO@Martin: modify suggestSupport to return a boolean if snippets should be presented or not
    //       and turn this into a real registry
    var SnippetsRegistry = (function () {
        function SnippetsRegistry() {
        }
        SnippetsRegistry.registerDefaultSnippets = function (modeId, snippets) {
            this._defaultSnippets[modeId] = (this._defaultSnippets[modeId] || []).concat(snippets);
        };
        SnippetsRegistry.registerSnippets = function (modeId, path, snippets) {
            var snippetsByMode = this._snippets[modeId];
            if (!snippetsByMode) {
                this._snippets[modeId] = snippetsByMode = {};
            }
            snippetsByMode[path] = snippets;
        };
        // the previous
        SnippetsRegistry.getNonWhitespacePrefix = function (model, position) {
            var line = model.getLineContent(position.lineNumber);
            var match = line.match(/[^\s]+$/);
            if (match) {
                return match[0];
            }
            return '';
        };
        SnippetsRegistry.getSnippets = function (model, position) {
            var word = model.getWordAtPosition(position);
            var currentWord = word ? word.word.substring(0, position.column - word.startColumn).toLowerCase() : '';
            var currentFullWord = SnippetsRegistry.getNonWhitespacePrefix(model, position).toLowerCase();
            var result = {
                currentWord: currentWord,
                incomplete: currentWord.length === 0,
                suggestions: []
            };
            var modeId = model.getModeId();
            var snippets = [];
            var snipppetsByMode = this._snippets[modeId];
            if (snipppetsByMode) {
                for (var s in snipppetsByMode) {
                    snippets = snippets.concat(snipppetsByMode[s]);
                }
            }
            var defaultSnippets = this._defaultSnippets[modeId];
            if (defaultSnippets) {
                snippets = snippets.concat(defaultSnippets);
            }
            // to avoid that snippets are too prominent in the intellisense proposals:
            // enforce that current word is matched or the position is after a whitespace
            snippets.forEach(function (p) {
                if (currentWord.length === 0 && currentFullWord.length === 0) {
                }
                else {
                    var label = p.label.toLowerCase();
                    // force that the current word or full word matches with the snippet prefix
                    if (currentWord.length > 0 && strings.startsWith(label, currentWord)) {
                    }
                    else if (currentFullWord.length > currentWord.length && strings.startsWith(label, currentFullWord)) {
                        p = objects.clone(p);
                        p.overwriteBefore = currentFullWord.length;
                    }
                    else {
                        return;
                    }
                }
                result.suggestions.push(p);
            });
            // if (result.suggestions.length > 0) {
            // 	if (word) {
            // 		// Push also the current word as first suggestion, to avoid unexpected snippet acceptance on Enter.
            // 		result.suggestions = result.suggestions.slice(0);
            // 		result.suggestions.unshift({
            // 			codeSnippet: word.word,
            // 			label: word.word,
            // 			type: 'text'
            // 		});
            // 	}
            // 	result.incomplete = true;
            // }
            return result;
        };
        SnippetsRegistry._defaultSnippets = Object.create(null);
        SnippetsRegistry._snippets = Object.create(null);
        return SnippetsRegistry;
    }());
    exports.SnippetsRegistry = SnippetsRegistry;
});

define(__m[384], __M([0,1,49]), function (require, exports, supports_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CharacterPairSupport = (function () {
        function CharacterPairSupport(registry, modeId, config) {
            this._registry = registry;
            this._modeId = modeId;
            this._autoClosingPairs = config.autoClosingPairs;
            if (!this._autoClosingPairs) {
                this._autoClosingPairs = config.brackets ? config.brackets.map(function (b) { return ({ open: b[0], close: b[1] }); }) : [];
            }
            this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;
        }
        CharacterPairSupport.prototype.getAutoClosingPairs = function () {
            return this._autoClosingPairs;
        };
        CharacterPairSupport.prototype.shouldAutoClosePair = function (character, context, offset) {
            var _this = this;
            return supports_1.handleEvent(context, offset, function (nestedModeId, context, offset) {
                if (_this._modeId === nestedModeId) {
                    // Always complete on empty line
                    if (context.getTokenCount() === 0) {
                        return true;
                    }
                    var tokenIndex = context.findIndexOfOffset(offset - 1);
                    var tokenType = context.getTokenType(tokenIndex);
                    for (var i = 0; i < _this._autoClosingPairs.length; ++i) {
                        if (_this._autoClosingPairs[i].open === character) {
                            if (_this._autoClosingPairs[i].notIn) {
                                for (var notInIndex = 0; notInIndex < _this._autoClosingPairs[i].notIn.length; ++notInIndex) {
                                    if (tokenType.indexOf(_this._autoClosingPairs[i].notIn[notInIndex]) > -1) {
                                        return false;
                                    }
                                }
                            }
                            break;
                        }
                    }
                    return true;
                }
                var characterPairSupport = _this._registry.getCharacterPairSupport(nestedModeId);
                if (characterPairSupport) {
                    return characterPairSupport.shouldAutoClosePair(character, context, offset);
                }
                return null;
            });
        };
        CharacterPairSupport.prototype.getSurroundingPairs = function () {
            return this._surroundingPairs;
        };
        return CharacterPairSupport;
    }());
    exports.CharacterPairSupport = CharacterPairSupport;
});

define(__m[386], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var BasicInplaceReplace = (function () {
        function BasicInplaceReplace() {
            this._defaultValueSet = [
                ['true', 'false'],
                ['True', 'False'],
                ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],
                ['public', 'protected', 'private'],
            ];
        }
        BasicInplaceReplace.prototype.navigateValueSet = function (range1, text1, range2, text2, up) {
            if (range1 && text1) {
                var result = this.doNavigateValueSet(text1, up);
                if (result) {
                    return {
                        range: range1,
                        value: result
                    };
                }
            }
            if (range2 && text2) {
                var result = this.doNavigateValueSet(text2, up);
                if (result) {
                    return {
                        range: range2,
                        value: result
                    };
                }
            }
            return null;
        };
        BasicInplaceReplace.prototype.doNavigateValueSet = function (text, up) {
            var numberResult = this.numberReplace(text, up);
            if (numberResult !== null) {
                return numberResult;
            }
            return this.textReplace(text, up);
        };
        BasicInplaceReplace.prototype.numberReplace = function (value, up) {
            var precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1)), n1 = Number(value), n2 = parseFloat(value);
            if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
                if (n1 === 0 && !up) {
                    return null; // don't do negative
                }
                else {
                    n1 = Math.floor(n1 * precision);
                    n1 += up ? precision : -precision;
                    return String(n1 / precision);
                }
            }
            return null;
        };
        BasicInplaceReplace.prototype.textReplace = function (value, up) {
            return this.valueSetsReplace(this._defaultValueSet, value, up);
        };
        BasicInplaceReplace.prototype.valueSetsReplace = function (valueSets, value, up) {
            var result = null;
            for (var i = 0, len = valueSets.length; result === null && i < len; i++) {
                result = this.valueSetReplace(valueSets[i], value, up);
            }
            return result;
        };
        BasicInplaceReplace.prototype.valueSetReplace = function (valueSet, value, up) {
            var idx = valueSet.indexOf(value);
            if (idx >= 0) {
                idx += up ? +1 : -1;
                if (idx < 0) {
                    idx = valueSet.length - 1;
                }
                else {
                    idx %= valueSet.length;
                }
                return valueSet[idx];
            }
            return null;
        };
        BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();
        return BasicInplaceReplace;
    }());
    exports.BasicInplaceReplace = BasicInplaceReplace;
});

define(__m[83], __M([0,1,10,4]), function (require, exports, strings, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var RichEditBrackets = (function () {
        function RichEditBrackets(modeId, brackets) {
            var _this = this;
            this.brackets = brackets.map(function (b) {
                return {
                    modeId: modeId,
                    open: b[0],
                    close: b[1],
                    forwardRegex: getRegexForBracketPair({ open: b[0], close: b[1] }),
                    reversedRegex: getReversedRegexForBracketPair({ open: b[0], close: b[1] })
                };
            });
            this.forwardRegex = getRegexForBrackets(this.brackets);
            this.reversedRegex = getReversedRegexForBrackets(this.brackets);
            this.textIsBracket = {};
            this.textIsOpenBracket = {};
            this.maxBracketLength = 0;
            this.brackets.forEach(function (b) {
                _this.textIsBracket[b.open] = b;
                _this.textIsBracket[b.close] = b;
                _this.textIsOpenBracket[b.open] = true;
                _this.textIsOpenBracket[b.close] = false;
                _this.maxBracketLength = Math.max(_this.maxBracketLength, b.open.length);
                _this.maxBracketLength = Math.max(_this.maxBracketLength, b.close.length);
            });
        }
        return RichEditBrackets;
    }());
    exports.RichEditBrackets = RichEditBrackets;
    function once(keyFn, computeFn) {
        var cache = {};
        return function (input) {
            var key = keyFn(input);
            if (!cache.hasOwnProperty(key)) {
                cache[key] = computeFn(input);
            }
            return cache[key];
        };
    }
    var getRegexForBracketPair = once(function (input) { return (input.open + ";" + input.close); }, function (input) {
        return createOrRegex([input.open, input.close]);
    });
    var getReversedRegexForBracketPair = once(function (input) { return (input.open + ";" + input.close); }, function (input) {
        return createOrRegex([toReversedString(input.open), toReversedString(input.close)]);
    });
    var getRegexForBrackets = once(function (input) { return input.map(function (b) { return (b.open + ";" + b.close); }).join(';'); }, function (input) {
        var pieces = [];
        input.forEach(function (b) {
            pieces.push(b.open);
            pieces.push(b.close);
        });
        return createOrRegex(pieces);
    });
    var getReversedRegexForBrackets = once(function (input) { return input.map(function (b) { return (b.open + ";" + b.close); }).join(';'); }, function (input) {
        var pieces = [];
        input.forEach(function (b) {
            pieces.push(toReversedString(b.open));
            pieces.push(toReversedString(b.close));
        });
        return createOrRegex(pieces);
    });
    function createOrRegex(pieces) {
        var regexStr = "(" + pieces.map(strings.escapeRegExpCharacters).join(')|(') + ")";
        return strings.createRegExp(regexStr, true, false, false, false);
    }
    function toReversedString(str) {
        var reversedStr = '';
        for (var i = str.length - 1; i >= 0; i--) {
            reversedStr += str.charAt(i);
        }
        return reversedStr;
    }
    var BracketsUtils = (function () {
        function BracketsUtils() {
        }
        BracketsUtils._findPrevBracketInText = function (reversedBracketRegex, lineNumber, reversedText, offset) {
            var m = reversedText.match(reversedBracketRegex);
            if (!m) {
                return null;
            }
            var matchOffset = reversedText.length - m.index;
            var matchLength = m[0].length;
            var absoluteMatchOffset = offset + matchOffset;
            return new range_1.Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);
        };
        BracketsUtils.findPrevBracketInToken = function (reversedBracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd) {
            // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)
            var currentTokenReversedText = '';
            for (var index = currentTokenEnd - 1; index >= currentTokenStart; index--) {
                currentTokenReversedText += lineText.charAt(index);
            }
            return this._findPrevBracketInText(reversedBracketRegex, lineNumber, currentTokenReversedText, currentTokenStart);
        };
        BracketsUtils.findNextBracketInText = function (bracketRegex, lineNumber, text, offset) {
            var m = text.match(bracketRegex);
            if (!m) {
                return null;
            }
            var matchOffset = m.index;
            var matchLength = m[0].length;
            var absoluteMatchOffset = offset + matchOffset;
            return new range_1.Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);
        };
        BracketsUtils.findNextBracketInToken = function (bracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd) {
            var currentTokenText = lineText.substring(currentTokenStart, currentTokenEnd);
            return this.findNextBracketInText(bracketRegex, lineNumber, currentTokenText, currentTokenStart);
        };
        return BracketsUtils;
    }());
    exports.BracketsUtils = BracketsUtils;
});

define(__m[389], __M([0,1,10,49,83]), function (require, exports, strings, supports_1, richEditBrackets_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var BracketElectricCharacterSupport = (function () {
        function BracketElectricCharacterSupport(registry, modeId, brackets, contribution) {
            this._registry = registry;
            this._modeId = modeId;
            this.contribution = contribution || {};
            this.brackets = new Brackets(modeId, brackets, this.contribution.docComment);
        }
        BracketElectricCharacterSupport.prototype.getElectricCharacters = function () {
            if (Array.isArray(this.contribution.embeddedElectricCharacters)) {
                return this.contribution.embeddedElectricCharacters.concat(this.brackets.getElectricCharacters());
            }
            return this.brackets.getElectricCharacters();
        };
        BracketElectricCharacterSupport.prototype.onElectricCharacter = function (context, offset) {
            var _this = this;
            return supports_1.handleEvent(context, offset, function (nestedModeId, context, offset) {
                if (_this._modeId === nestedModeId) {
                    return _this.brackets.onElectricCharacter(context, offset);
                }
                var electricCharacterSupport = _this._registry.getElectricCharacterSupport(nestedModeId);
                if (electricCharacterSupport) {
                    return electricCharacterSupport.onElectricCharacter(context, offset);
                }
                return null;
            });
        };
        return BracketElectricCharacterSupport;
    }());
    exports.BracketElectricCharacterSupport = BracketElectricCharacterSupport;
    var Brackets = (function () {
        function Brackets(modeId, richEditBrackets, docComment) {
            if (docComment === void 0) { docComment = null; }
            this._modeId = modeId;
            this._richEditBrackets = richEditBrackets;
            this._docComment = docComment ? docComment : null;
        }
        Brackets.prototype.getElectricCharacters = function () {
            var result = [];
            if (this._richEditBrackets) {
                for (var i = 0, len = this._richEditBrackets.brackets.length; i < len; i++) {
                    var bracketPair = this._richEditBrackets.brackets[i];
                    var lastChar = bracketPair.close.charAt(bracketPair.close.length - 1);
                    result.push(lastChar);
                }
            }
            // Doc comments
            if (this._docComment) {
                result.push(this._docComment.open.charAt(this._docComment.open.length - 1));
            }
            // Filter duplicate entries
            result = result.filter(function (item, pos, array) {
                return array.indexOf(item) === pos;
            });
            return result;
        };
        Brackets.prototype.onElectricCharacter = function (context, offset) {
            if (context.getTokenCount() === 0) {
                return null;
            }
            return (this._onElectricCharacterDocComment(context, offset) ||
                this._onElectricCharacterStandardBrackets(context, offset));
        };
        Brackets.prototype.containsTokenTypes = function (fullTokenSpec, tokensToLookFor) {
            var array = tokensToLookFor.split('.');
            for (var i = 0; i < array.length; ++i) {
                if (fullTokenSpec.indexOf(array[i]) < 0) {
                    return false;
                }
            }
            return true;
        };
        Brackets.prototype._onElectricCharacterStandardBrackets = function (context, offset) {
            if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {
                return null;
            }
            var reversedBracketRegex = this._richEditBrackets.reversedRegex;
            var lineText = context.getLineContent();
            var tokenIndex = context.findIndexOfOffset(offset);
            var tokenStart = context.getTokenStartIndex(tokenIndex);
            var tokenEnd = offset + 1;
            var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(context.getLineContent());
            if (firstNonWhitespaceIndex !== -1 && firstNonWhitespaceIndex < tokenStart) {
                return null;
            }
            if (!supports_1.ignoreBracketsInToken(context.getTokenType(tokenIndex))) {
                var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(reversedBracketRegex, 1, lineText, tokenStart, tokenEnd);
                if (r) {
                    var text = lineText.substring(r.startColumn - 1, r.endColumn - 1);
                    var isOpen = this._richEditBrackets.textIsOpenBracket[text];
                    if (!isOpen) {
                        return {
                            matchOpenBracket: text
                        };
                    }
                }
            }
            return null;
        };
        Brackets.prototype._onElectricCharacterDocComment = function (context, offset) {
            // We only auto-close, so do nothing if there is no closing part.
            if (!this._docComment || !this._docComment.close) {
                return null;
            }
            var line = context.getLineContent();
            var char = line[offset];
            // See if the right electric character was pressed
            if (char !== this._docComment.open.charAt(this._docComment.open.length - 1)) {
                return null;
            }
            // If this line already contains the closing tag, do nothing.
            if (line.indexOf(this._docComment.close, offset) >= 0) {
                return null;
            }
            // If we're not in a documentation comment, do nothing.
            var lastTokenIndex = context.findIndexOfOffset(offset);
            if (!this.containsTokenTypes(context.getTokenType(lastTokenIndex), this._docComment.scope)) {
                return null;
            }
            if (line.substring(context.getTokenStartIndex(lastTokenIndex), offset + 1 /* include electric char*/) !== this._docComment.open) {
                return null;
            }
            return { appendText: this._docComment.close };
        };
        return Brackets;
    }());
    exports.Brackets = Brackets;
});

define(__m[138], __M([0,1,170,121,49]), function (require, exports, lineStream_1, nullMode_1, supports_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function isFunction(something) {
        return typeof something === 'function';
    }
    var TokenizationSupport = (function () {
        function TokenizationSupport(mode, customization, supportsNestedModes) {
            this._mode = mode;
            this.customization = customization;
            this.supportsNestedModes = supportsNestedModes;
            this._embeddedModesListeners = {};
            if (this.supportsNestedModes) {
                if (!this._mode.setTokenizationSupport) {
                    throw new Error('Cannot be a mode with nested modes unless I can emit a tokenizationSupport changed event!');
                }
            }
            this.defaults = {
                enterNestedMode: !isFunction(customization.enterNestedMode),
                getNestedMode: !isFunction(customization.getNestedMode),
                getNestedModeInitialState: !isFunction(customization.getNestedModeInitialState),
                getLeavingNestedModeData: !isFunction(customization.getLeavingNestedModeData),
                onReturningFromNestedMode: !isFunction(customization.onReturningFromNestedMode)
            };
        }
        TokenizationSupport.prototype.dispose = function () {
            for (var listener in this._embeddedModesListeners) {
                this._embeddedModesListeners[listener].dispose();
                delete this._embeddedModesListeners[listener];
            }
        };
        TokenizationSupport.prototype.getInitialState = function () {
            return this.customization.getInitialState();
        };
        TokenizationSupport.prototype.tokenize = function (line, state, deltaOffset, stopAtOffset) {
            if (deltaOffset === void 0) { deltaOffset = 0; }
            if (stopAtOffset === void 0) { stopAtOffset = deltaOffset + line.length; }
            if (state.getMode() !== this._mode) {
                return this._nestedTokenize(line, state, deltaOffset, stopAtOffset, [], []);
            }
            else {
                return this._myTokenize(line, state, deltaOffset, stopAtOffset, [], []);
            }
        };
        /**
         * Precondition is: nestedModeState.getMode() !== this
         * This means we are in a nested mode when parsing starts on this line.
         */
        TokenizationSupport.prototype._nestedTokenize = function (buffer, nestedModeState, deltaOffset, stopAtOffset, prependTokens, prependModeTransitions) {
            var myStateBeforeNestedMode = nestedModeState.getStateData();
            var leavingNestedModeData = this.getLeavingNestedModeData(buffer, myStateBeforeNestedMode);
            // Be sure to give every embedded mode the
            // opportunity to leave nested mode.
            // i.e. Don't go straight to the most nested mode
            var stepOnceNestedState = nestedModeState;
            while (stepOnceNestedState.getStateData() && stepOnceNestedState.getStateData().getMode() !== this._mode) {
                stepOnceNestedState = stepOnceNestedState.getStateData();
            }
            var nestedMode = stepOnceNestedState.getMode();
            if (!leavingNestedModeData) {
                // tokenization will not leave nested mode
                var result;
                if (nestedMode.tokenizationSupport) {
                    result = nestedMode.tokenizationSupport.tokenize(buffer, nestedModeState, deltaOffset, stopAtOffset);
                }
                else {
                    // The nested mode doesn't have tokenization support,
                    // unfortunatelly this means we have to fake it
                    result = nullMode_1.nullTokenize(nestedMode, buffer, nestedModeState, deltaOffset);
                }
                result.tokens = prependTokens.concat(result.tokens);
                result.modeTransitions = prependModeTransitions.concat(result.modeTransitions);
                return result;
            }
            var nestedModeBuffer = leavingNestedModeData.nestedModeBuffer;
            if (nestedModeBuffer.length > 0) {
                // Tokenize with the nested mode
                var nestedModeLineTokens;
                if (nestedMode.tokenizationSupport) {
                    nestedModeLineTokens = nestedMode.tokenizationSupport.tokenize(nestedModeBuffer, nestedModeState, deltaOffset, stopAtOffset);
                }
                else {
                    // The nested mode doesn't have tokenization support,
                    // unfortunatelly this means we have to fake it
                    nestedModeLineTokens = nullMode_1.nullTokenize(nestedMode, nestedModeBuffer, nestedModeState, deltaOffset);
                }
                // Save last state of nested mode
                nestedModeState = nestedModeLineTokens.endState;
                // Prepend nested mode's result to our result
                prependTokens = prependTokens.concat(nestedModeLineTokens.tokens);
                prependModeTransitions = prependModeTransitions.concat(nestedModeLineTokens.modeTransitions);
            }
            var bufferAfterNestedMode = leavingNestedModeData.bufferAfterNestedMode;
            var myStateAfterNestedMode = leavingNestedModeData.stateAfterNestedMode;
            myStateAfterNestedMode.setStateData(myStateBeforeNestedMode.getStateData());
            this.onReturningFromNestedMode(myStateAfterNestedMode, nestedModeState);
            return this._myTokenize(bufferAfterNestedMode, myStateAfterNestedMode, deltaOffset + nestedModeBuffer.length, stopAtOffset, prependTokens, prependModeTransitions);
        };
        /**
         * Precondition is: state.getMode() === this
         * This means we are in the current mode when parsing starts on this line.
         */
        TokenizationSupport.prototype._myTokenize = function (buffer, myState, deltaOffset, stopAtOffset, prependTokens, prependModeTransitions) {
            var _this = this;
            var lineStream = new lineStream_1.LineStream(buffer);
            var tokenResult, beforeTokenizeStreamPos;
            var previousType = null;
            var retokenize = null;
            myState = myState.clone();
            if (prependModeTransitions.length <= 0 || prependModeTransitions[prependModeTransitions.length - 1].mode !== this._mode) {
                // Avoid transitioning to the same mode (this can happen in case of empty embedded modes)
                prependModeTransitions.push({
                    startIndex: deltaOffset,
                    mode: this._mode
                });
            }
            var maxPos = Math.min(stopAtOffset - deltaOffset, buffer.length);
            while (lineStream.pos() < maxPos) {
                beforeTokenizeStreamPos = lineStream.pos();
                do {
                    tokenResult = myState.tokenize(lineStream);
                    if (tokenResult === null || tokenResult === undefined ||
                        ((tokenResult.type === undefined || tokenResult.type === null) &&
                            (tokenResult.nextState === undefined || tokenResult.nextState === null))) {
                        throw new Error('Tokenizer must return a valid state');
                    }
                    if (tokenResult.nextState) {
                        tokenResult.nextState.setStateData(myState.getStateData());
                        myState = tokenResult.nextState;
                    }
                    if (lineStream.pos() <= beforeTokenizeStreamPos) {
                        throw new Error('Stream did not advance while tokenizing. Mode id is ' + this._mode.getId() + ' (stuck at token type: "' + tokenResult.type + '", prepend tokens: "' + (prependTokens.map(function (t) { return t.type; }).join(',')) + '").');
                    }
                } while (!tokenResult.type && tokenResult.type !== '');
                if (previousType !== tokenResult.type || tokenResult.dontMergeWithPrev || previousType === null) {
                    prependTokens.push(new supports_1.Token(beforeTokenizeStreamPos + deltaOffset, tokenResult.type));
                }
                previousType = tokenResult.type;
                if (this.supportsNestedModes && this.enterNestedMode(myState)) {
                    var currentEmbeddedLevels = this._getEmbeddedLevel(myState);
                    if (currentEmbeddedLevels < TokenizationSupport.MAX_EMBEDDED_LEVELS) {
                        var nestedModeState = this.getNestedModeInitialState(myState);
                        // Re-emit tokenizationSupport change events from all modes that I ever embedded
                        var embeddedMode = nestedModeState.state.getMode();
                        if (typeof embeddedMode.addSupportChangedListener === 'function' && !this._embeddedModesListeners.hasOwnProperty(embeddedMode.getId())) {
                            var emitting = false;
                            this._embeddedModesListeners[embeddedMode.getId()] = embeddedMode.addSupportChangedListener(function (e) {
                                if (emitting) {
                                    return;
                                }
                                if (e.tokenizationSupport) {
                                    emitting = true;
                                    _this._mode.setTokenizationSupport(function (mode) {
                                        return mode.tokenizationSupport;
                                    });
                                    emitting = false;
                                }
                            });
                        }
                        if (!lineStream.eos()) {
                            // There is content from the embedded mode
                            var restOfBuffer = buffer.substr(lineStream.pos());
                            var result = this._nestedTokenize(restOfBuffer, nestedModeState.state, deltaOffset + lineStream.pos(), stopAtOffset, prependTokens, prependModeTransitions);
                            result.retokenize = result.retokenize || nestedModeState.missingModePromise;
                            return result;
                        }
                        else {
                            // Transition to the nested mode state
                            myState = nestedModeState.state;
                            retokenize = nestedModeState.missingModePromise;
                        }
                    }
                }
            }
            return {
                tokens: prependTokens,
                actualStopOffset: lineStream.pos() + deltaOffset,
                modeTransitions: prependModeTransitions,
                endState: myState,
                retokenize: retokenize
            };
        };
        TokenizationSupport.prototype._getEmbeddedLevel = function (state) {
            var result = -1;
            while (state) {
                result++;
                state = state.getStateData();
            }
            return result;
        };
        TokenizationSupport.prototype.enterNestedMode = function (state) {
            if (this.defaults.enterNestedMode) {
                return false;
            }
            return this.customization.enterNestedMode(state);
        };
        TokenizationSupport.prototype.getNestedMode = function (state) {
            if (this.defaults.getNestedMode) {
                return null;
            }
            return this.customization.getNestedMode(state);
        };
        TokenizationSupport._validatedNestedMode = function (input) {
            var mode = new nullMode_1.NullMode(), missingModePromise = null;
            if (input && input.mode) {
                mode = input.mode;
            }
            if (input && input.missingModePromise) {
                missingModePromise = input.missingModePromise;
            }
            return {
                mode: mode,
                missingModePromise: missingModePromise
            };
        };
        TokenizationSupport.prototype.getNestedModeInitialState = function (state) {
            if (this.defaults.getNestedModeInitialState) {
                var nestedMode = TokenizationSupport._validatedNestedMode(this.getNestedMode(state));
                var missingModePromise = nestedMode.missingModePromise;
                var nestedModeState;
                if (nestedMode.mode.tokenizationSupport) {
                    nestedModeState = nestedMode.mode.tokenizationSupport.getInitialState();
                }
                else {
                    nestedModeState = new nullMode_1.NullState(nestedMode.mode, null);
                }
                nestedModeState.setStateData(state);
                return {
                    state: nestedModeState,
                    missingModePromise: missingModePromise
                };
            }
            return this.customization.getNestedModeInitialState(state);
        };
        TokenizationSupport.prototype.getLeavingNestedModeData = function (line, state) {
            if (this.defaults.getLeavingNestedModeData) {
                return null;
            }
            return this.customization.getLeavingNestedModeData(line, state);
        };
        TokenizationSupport.prototype.onReturningFromNestedMode = function (myStateAfterNestedMode, lastNestedModeState) {
            if (this.defaults.onReturningFromNestedMode) {
                return null;
            }
            return this.customization.onReturningFromNestedMode(myStateAfterNestedMode, lastNestedModeState);
        };
        TokenizationSupport.MAX_EMBEDDED_LEVELS = 5;
        return TokenizationSupport;
    }());
    exports.TokenizationSupport = TokenizationSupport;
});






define(__m[140], __M([0,1,114,170,117,138]), function (require, exports, abstractState_1, lineStream_1, monarchCommon, tokenizationSupport_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The MonarchLexer class implements a monaco lexer that highlights source code.
     * It takes a compiled lexer to guide the tokenizer and maintains a stack of
     * lexer states.
     */
    var MonarchLexer = (function (_super) {
        __extends(MonarchLexer, _super);
        function MonarchLexer(mode, modeService, lexer, stack, embeddedMode) {
            _super.call(this, mode);
            this.id = MonarchLexer.ID++; // for debugging, assigns unique id to each instance
            this.modeService = modeService;
            this.lexer = lexer; // (compiled) lexer description
            this.stack = (stack ? stack : [lexer.start]); // stack of states
            this.embeddedMode = (embeddedMode ? embeddedMode : null); // are we scanning an embedded section?
            // did we encounter an embedded start on this line?
            // no need for cloning or equality since it is used only within a line
            this.embeddedEntered = false;
            // regular expression group matching
            // these never need cloning or equality since they are only used within a line match
            this.groupActions = null;
            this.groupMatches = null;
            this.groupMatched = null;
            this.groupRule = null;
        }
        MonarchLexer.prototype.makeClone = function () {
            return new MonarchLexer(this.getMode(), this.modeService, this.lexer, this.stack.slice(0), this.embeddedMode);
        };
        MonarchLexer.prototype.equals = function (other) {
            if (!_super.prototype.equals.call(this, other)) {
                return false;
            }
            if (!(other instanceof MonarchLexer)) {
                return false;
            }
            var otherm = other;
            if ((this.stack.length !== otherm.stack.length) || (this.lexer.languageId !== otherm.lexer.languageId) ||
                (this.embeddedMode !== otherm.embeddedMode)) {
                return false;
            }
            var idx;
            for (idx in this.stack) {
                if (this.stack.hasOwnProperty(idx)) {
                    if (this.stack[idx] !== otherm.stack[idx]) {
                        return false;
                    }
                }
            }
            return true;
        };
        /**
         * The main tokenizer: this function gets called by monaco to tokenize lines
         * Note: we don't want to raise exceptions here and always keep going..
         *
         * TODO: there are many optimizations possible here for the common cases
         * but for now I concentrated on functionality and correctness.
         */
        MonarchLexer.prototype.tokenize = function (stream, noConsumeIsOk) {
            var stackLen0 = this.stack.length; // these are saved to check progress
            var groupLen0 = 0;
            var state = this.stack[0]; // the current state
            this.embeddedEntered = false;
            var matches = null;
            var matched = null;
            var action = null;
            var next = null;
            var rule = null;
            // check if we need to process group matches first
            if (this.groupActions) {
                groupLen0 = this.groupActions.length;
                matches = this.groupMatches;
                matched = this.groupMatched.shift();
                action = this.groupActions.shift();
                rule = this.groupRule;
                // cleanup if necessary
                if (this.groupActions.length === 0) {
                    this.groupActions = null;
                    this.groupMatches = null;
                    this.groupMatched = null;
                    this.groupRule = null;
                }
            }
            else {
                // nothing to do
                if (stream.eos()) {
                    return { type: '' };
                }
                // get the entire line
                var line = stream.advanceToEOS();
                stream.goBack(line.length);
                // get the rules for this state
                var rules = this.lexer.tokenizer[state];
                if (!rules) {
                    rules = monarchCommon.findRules(this.lexer, state); // do parent matching
                }
                if (!rules) {
                    monarchCommon.throwError(this.lexer, 'tokenizer state is not defined: ' + state);
                }
                else {
                    // try each rule until we match
                    rule = null;
                    var pos = stream.pos();
                    var idx;
                    for (idx in rules) {
                        if (rules.hasOwnProperty(idx)) {
                            rule = rules[idx];
                            if (pos === 0 || !rule.matchOnlyAtLineStart) {
                                matches = line.match(rule.regex);
                                if (matches) {
                                    matched = matches[0];
                                    action = rule.action;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            // We matched 'rule' with 'matches' and 'action'
            if (!matches) {
                matches = [''];
                matched = '';
            }
            if (!action) {
                // bad: we didn't match anything, and there is no action to take
                // we need to advance the stream or we get progress trouble
                if (!stream.eos()) {
                    matches = [stream.peek()];
                    matched = matches[0];
                }
                action = this.lexer.defaultToken;
            }
            // advance stream
            stream.advance(matched.length);
            // maybe call action function (used for 'cases')
            while (action.test) {
                var callres = action.test(matched, matches, state, stream.eos());
                action = callres;
            }
            // set the result: either a string or an array of actions
            var result = null;
            if (typeof (action) === 'string' || Array.isArray(action)) {
                result = action;
            }
            else if (action.group) {
                result = action.group;
            }
            else if (action.token !== null && action.token !== undefined) {
                result = action.token;
                // do $n replacements?
                if (action.tokenSubst) {
                    result = monarchCommon.substituteMatches(this.lexer, result, matched, matches, state);
                }
                // enter embedded mode?
                if (action.nextEmbedded) {
                    if (action.nextEmbedded === '@pop') {
                        if (!this.embeddedMode) {
                            monarchCommon.throwError(this.lexer, 'cannot pop embedded mode if not inside one');
                        }
                        this.embeddedMode = null;
                    }
                    else if (this.embeddedMode) {
                        monarchCommon.throwError(this.lexer, 'cannot enter embedded mode from within an embedded mode');
                    }
                    else {
                        this.embeddedMode = monarchCommon.substituteMatches(this.lexer, action.nextEmbedded, matched, matches, state);
                        // substitute language alias to known modes to support syntax highlighting
                        var embeddedMode = this.modeService.getModeIdForLanguageName(this.embeddedMode);
                        if (this.embeddedMode && embeddedMode) {
                            this.embeddedMode = embeddedMode;
                        }
                        this.embeddedEntered = true;
                    }
                }
                // state transformations
                if (action.goBack) {
                    stream.goBack(action.goBack);
                }
                if (action.switchTo && typeof action.switchTo === 'string') {
                    var nextState = monarchCommon.substituteMatches(this.lexer, action.switchTo, matched, matches, state); // switch state without a push...
                    if (nextState[0] === '@') {
                        nextState = nextState.substr(1); // peel off starting '@'
                    }
                    if (!monarchCommon.findRules(this.lexer, nextState)) {
                        monarchCommon.throwError(this.lexer, 'trying to switch to a state \'' + nextState + '\' that is undefined in rule: ' + rule.name);
                    }
                    else {
                        this.stack[0] = nextState;
                    }
                    next = null;
                }
                else if (action.transform && typeof action.transform === 'function') {
                    this.stack = action.transform(this.stack); // if you need to do really funky stuff...
                    next = null;
                }
                else if (action.next) {
                    if (action.next === '@push') {
                        if (this.stack.length >= this.lexer.maxStack) {
                            monarchCommon.throwError(this.lexer, 'maximum tokenizer stack size reached: [' +
                                this.stack[0] + ',' + this.stack[1] + ',...,' +
                                this.stack[this.stack.length - 2] + ',' + this.stack[this.stack.length - 1] + ']');
                        }
                        else {
                            this.stack.unshift(state);
                        }
                    }
                    else if (action.next === '@pop') {
                        if (this.stack.length <= 1) {
                            monarchCommon.throwError(this.lexer, 'trying to pop an empty stack in rule: ' + rule.name);
                        }
                        else {
                            this.stack.shift();
                        }
                    }
                    else if (action.next === '@popall') {
                        if (this.stack.length > 1) {
                            this.stack = [this.stack[this.stack.length - 1]];
                        }
                    }
                    else {
                        var nextState = monarchCommon.substituteMatches(this.lexer, action.next, matched, matches, state);
                        if (nextState[0] === '@') {
                            nextState = nextState.substr(1); // peel off starting '@'
                        }
                        if (!monarchCommon.findRules(this.lexer, nextState)) {
                            monarchCommon.throwError(this.lexer, 'trying to set a next state \'' + nextState + '\' that is undefined in rule: ' + rule.name);
                        }
                        else {
                            this.stack.unshift(nextState);
                        }
                    }
                }
                if (action.log && typeof (action.log) === 'string') {
                    monarchCommon.log(this.lexer, this.lexer.languageId + ': ' + monarchCommon.substituteMatches(this.lexer, action.log, matched, matches, state));
                }
            }
            // check result
            if (result === null) {
                monarchCommon.throwError(this.lexer, 'lexer rule has no well-defined action in rule: ' + rule.name);
                result = this.lexer.defaultToken;
            }
            // is the result a group match?
            if (Array.isArray(result)) {
                if (this.groupActions && this.groupActions.length > 0) {
                    monarchCommon.throwError(this.lexer, 'groups cannot be nested: ' + rule.name);
                }
                if (matches.length !== result.length + 1) {
                    monarchCommon.throwError(this.lexer, 'matched number of groups does not match the number of actions in rule: ' + rule.name);
                }
                var totalLen = 0;
                for (var i = 1; i < matches.length; i++) {
                    totalLen += matches[i].length;
                }
                if (totalLen !== matched.length) {
                    monarchCommon.throwError(this.lexer, 'with groups, all characters should be matched in consecutive groups in rule: ' + rule.name);
                }
                this.groupMatches = matches;
                this.groupMatched = matches.slice(1);
                this.groupActions = result.slice(0);
                this.groupRule = rule;
                stream.goBack(matched.length);
                return this.tokenize(stream); // call recursively to initiate first result match
            }
            else {
                // check for '@rematch'
                if (result === '@rematch') {
                    stream.goBack(matched.length);
                    matched = ''; // better set the next state too..
                    matches = null;
                    result = '';
                }
                // check progress
                if (matched.length === 0) {
                    if (stackLen0 !== this.stack.length || state !== this.stack[0]
                        || (!this.groupActions ? 0 : this.groupActions.length) !== groupLen0) {
                        if (!noConsumeIsOk) {
                            return this.tokenize(stream); // tokenize again in the new state
                        }
                    }
                    else {
                        monarchCommon.throwError(this.lexer, 'no progress in tokenizer in rule: ' + rule.name);
                        stream.advanceToEOS(); // must make progress or editor loops
                    }
                }
                // return the result (and check for brace matching)
                // todo: for efficiency we could pre-sanitize tokenPostfix and substitutions
                if (result.indexOf('@brackets') === 0) {
                    var rest = result.substr('@brackets'.length);
                    var bracket = findBracket(this.lexer, matched);
                    if (!bracket) {
                        monarchCommon.throwError(this.lexer, '@brackets token returned but no bracket defined as: ' + matched);
                        bracket = { token: '', bracketType: monarchCommon.MonarchBracket.None };
                    }
                    return { type: monarchCommon.sanitize(bracket.token + rest) };
                }
                else {
                    var token = (result === '' ? '' : result + this.lexer.tokenPostfix);
                    return { type: monarchCommon.sanitize(token) };
                }
            }
        };
        MonarchLexer.ID = 0;
        return MonarchLexer;
    }(abstractState_1.AbstractState));
    exports.MonarchLexer = MonarchLexer;
    /**
     * Searches for a bracket in the 'brackets' attribute that matches the input.
     */
    function findBracket(lexer, matched) {
        if (!matched) {
            return null;
        }
        matched = monarchCommon.fixCase(lexer, matched);
        var brackets = lexer.brackets;
        for (var i = 0; i < brackets.length; i++) {
            var bracket = brackets[i];
            if (bracket.open === matched) {
                return { token: bracket.token, bracketType: monarchCommon.MonarchBracket.Open };
            }
            else if (bracket.close === matched) {
                return { token: bracket.token, bracketType: monarchCommon.MonarchBracket.Close };
            }
        }
        return null;
    }
    function createTokenizationSupport(modeService, mode, lexer) {
        return new tokenizationSupport_1.TokenizationSupport(mode, {
            getInitialState: function () {
                return new MonarchLexer(mode, modeService, lexer);
            },
            enterNestedMode: function (state) {
                if (state instanceof MonarchLexer) {
                    return state.embeddedEntered;
                }
                return false;
            },
            getNestedMode: function (rawState) {
                var mime = rawState.embeddedMode;
                if (!modeService.isRegisteredMode(mime)) {
                    // unknown mode
                    return {
                        mode: modeService.getMode('text/plain'),
                        missingModePromise: null
                    };
                }
                var mode = modeService.getMode(mime);
                if (mode) {
                    // mode is available
                    return {
                        mode: mode,
                        missingModePromise: null
                    };
                }
                // mode is not yet loaded
                return {
                    mode: modeService.getMode('text/plain'),
                    missingModePromise: modeService.getOrCreateMode(mime).then(function () { return null; })
                };
            },
            getLeavingNestedModeData: function (line, state) {
                // state = state.clone();
                var mstate = state.clone();
                var stream = new lineStream_1.LineStream(line);
                while (!stream.eos() && mstate.embeddedMode) {
                    mstate.tokenize(stream, true); // allow no consumption for @rematch
                }
                if (mstate.embeddedMode) {
                    return null; // don't leave yet
                }
                var end = stream.pos();
                return {
                    nestedModeBuffer: line.substring(0, end),
                    bufferAfterNestedMode: line.substring(end),
                    stateAfterNestedMode: mstate
                };
            }
        }, lexer.usesEmbedded);
    }
    exports.createTokenizationSupport = createTokenizationSupport;
});

define(__m[393], __M([0,1,10,121]), function (require, exports, strings, nullMode_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function tokenizeToHtmlContent(text, mode) {
        return _tokenizeToHtmlContent(text, _getSafeTokenizationSupport(mode));
    }
    exports.tokenizeToHtmlContent = tokenizeToHtmlContent;
    function tokenizeToString(text, mode, extraTokenClass) {
        return _tokenizeToString(text, _getSafeTokenizationSupport(mode), extraTokenClass);
    }
    exports.tokenizeToString = tokenizeToString;
    function _getSafeTokenizationSupport(mode) {
        if (mode && mode.tokenizationSupport) {
            return mode.tokenizationSupport;
        }
        return {
            getInitialState: function () { return new nullMode_1.NullState(null, null); },
            tokenize: function (buffer, state, deltaOffset, stopAtOffset) {
                if (deltaOffset === void 0) { deltaOffset = 0; }
                return nullMode_1.nullTokenize(null, buffer, state, deltaOffset, stopAtOffset);
            }
        };
    }
    function _tokenizeToHtmlContent(text, tokenizationSupport) {
        var result = {
            tagName: 'div',
            style: 'white-space: pre-wrap',
            children: []
        };
        var emitToken = function (className, tokenText) {
            result.children.push({
                tagName: 'span',
                className: className,
                text: tokenText
            });
        };
        var emitNewLine = function () {
            result.children.push({
                tagName: 'br'
            });
        };
        _tokenizeLines(text, tokenizationSupport, emitToken, emitNewLine);
        return result;
    }
    function _tokenizeToString(text, tokenizationSupport, extraTokenClass) {
        if (extraTokenClass === void 0) { extraTokenClass = ''; }
        if (extraTokenClass && extraTokenClass.length > 0) {
            extraTokenClass = ' ' + extraTokenClass;
        }
        var result = '';
        var emitToken = function (className, tokenText) {
            result += '<span class="' + className + extraTokenClass + '">' + strings.escape(tokenText) + '</span>';
        };
        var emitNewLine = function () {
            result += '<br/>';
        };
        result = '<div style="white-space: pre-wrap;">';
        _tokenizeLines(text, tokenizationSupport, emitToken, emitNewLine);
        result += '</div>';
        return result;
    }
    function _tokenizeLines(text, tokenizationSupport, emitToken, emitNewLine) {
        var lines = text.split(/\r\n|\r|\n/);
        var currentState = tokenizationSupport.getInitialState();
        for (var i = 0; i < lines.length; i++) {
            currentState = _tokenizeLine(lines[i], tokenizationSupport, emitToken, currentState);
            // Keep new lines
            if (i < lines.length - 1) {
                emitNewLine();
            }
        }
    }
    function _tokenizeLine(line, tokenizationSupport, emitToken, startState) {
        var tokenized = tokenizationSupport.tokenize(line, startState), endState = tokenized.endState, tokens = tokenized.tokens, offset = 0, tokenText;
        // For each token inject spans with proper class names based on token type
        for (var j = 0; j < tokens.length; j++) {
            var token = tokens[j];
            // Tokens only provide a startIndex from where they are valid from. As such, we need to
            // look ahead the value of the token by advancing until the next tokens start inex or the
            // end of the line.
            if (j < tokens.length - 1) {
                tokenText = line.substring(offset, tokens[j + 1].startIndex);
                offset = tokens[j + 1].startIndex;
            }
            else {
                tokenText = line.substr(offset);
            }
            var className = 'token';
            var safeType = token.type.replace(/[^a-z0-9\-]/gi, ' ');
            if (safeType.length > 0) {
                className += ' ' + safeType;
            }
            emitToken(className, tokenText);
        }
        return endState;
    }
});

define(__m[395], __M([0,1,7]), function (require, exports, editorCommon_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var OverviewZoneManager = (function () {
        function OverviewZoneManager(getVerticalOffsetForLine) {
            this._getVerticalOffsetForLine = getVerticalOffsetForLine;
            this._zones = [];
            this._colorZonesInvalid = false;
            this._lineHeight = 0;
            this._domWidth = 0;
            this._domHeight = 0;
            this._outerHeight = 0;
            this._maximumHeight = 0;
            this._minimumHeight = 0;
            this._useDarkColor = false;
            this._pixelRatio = 1;
            this._lastAssignedId = 0;
            this._color2Id = Object.create(null);
            this._id2Color = [];
        }
        OverviewZoneManager.prototype.getId2Color = function () {
            return this._id2Color;
        };
        OverviewZoneManager.prototype.setZones = function (newZones) {
            newZones.sort(function (a, b) { return a.compareTo(b); });
            var oldZones = this._zones;
            var oldIndex = 0;
            var oldLength = this._zones.length;
            var newIndex = 0;
            var newLength = newZones.length;
            var result = [];
            while (newIndex < newLength) {
                var newZone = newZones[newIndex];
                if (oldIndex >= oldLength) {
                    result.push(newZone);
                    newIndex++;
                }
                else {
                    var oldZone = oldZones[oldIndex];
                    var cmp = oldZone.compareTo(newZone);
                    if (cmp < 0) {
                        oldIndex++;
                    }
                    else if (cmp > 0) {
                        result.push(newZone);
                        newIndex++;
                    }
                    else {
                        // cmp === 0
                        result.push(oldZone);
                        oldIndex++;
                        newIndex++;
                    }
                }
            }
            this._zones = result;
        };
        OverviewZoneManager.prototype.setLineHeight = function (lineHeight) {
            if (this._lineHeight === lineHeight) {
                return false;
            }
            this._lineHeight = lineHeight;
            this._colorZonesInvalid = true;
            return true;
        };
        OverviewZoneManager.prototype.setPixelRatio = function (pixelRatio) {
            this._pixelRatio = pixelRatio;
            this._colorZonesInvalid = true;
        };
        OverviewZoneManager.prototype.getDOMWidth = function () {
            return this._domWidth;
        };
        OverviewZoneManager.prototype.getCanvasWidth = function () {
            return this._domWidth * this._pixelRatio;
        };
        OverviewZoneManager.prototype.setDOMWidth = function (width) {
            if (this._domWidth === width) {
                return false;
            }
            this._domWidth = width;
            this._colorZonesInvalid = true;
            return true;
        };
        OverviewZoneManager.prototype.getDOMHeight = function () {
            return this._domHeight;
        };
        OverviewZoneManager.prototype.getCanvasHeight = function () {
            return this._domHeight * this._pixelRatio;
        };
        OverviewZoneManager.prototype.setDOMHeight = function (height) {
            if (this._domHeight === height) {
                return false;
            }
            this._domHeight = height;
            this._colorZonesInvalid = true;
            return true;
        };
        OverviewZoneManager.prototype.getOuterHeight = function () {
            return this._outerHeight;
        };
        OverviewZoneManager.prototype.setOuterHeight = function (outerHeight) {
            if (this._outerHeight === outerHeight) {
                return false;
            }
            this._outerHeight = outerHeight;
            this._colorZonesInvalid = true;
            return true;
        };
        OverviewZoneManager.prototype.setMaximumHeight = function (maximumHeight) {
            if (this._maximumHeight === maximumHeight) {
                return false;
            }
            this._maximumHeight = maximumHeight;
            this._colorZonesInvalid = true;
            return true;
        };
        OverviewZoneManager.prototype.setMinimumHeight = function (minimumHeight) {
            if (this._minimumHeight === minimumHeight) {
                return false;
            }
            this._minimumHeight = minimumHeight;
            this._colorZonesInvalid = true;
            return true;
        };
        OverviewZoneManager.prototype.setUseDarkColor = function (useDarkColor) {
            if (this._useDarkColor === useDarkColor) {
                return false;
            }
            this._useDarkColor = useDarkColor;
            this._colorZonesInvalid = true;
            return true;
        };
        OverviewZoneManager.prototype.resolveColorZones = function () {
            var colorZonesInvalid = this._colorZonesInvalid;
            var lineHeight = Math.floor(this._lineHeight); // @perf
            var totalHeight = Math.floor(this.getCanvasHeight()); // @perf
            var maximumHeight = Math.floor(this._maximumHeight * this._pixelRatio); // @perf
            var minimumHeight = Math.floor(this._minimumHeight * this._pixelRatio); // @perf
            var useDarkColor = this._useDarkColor; // @perf
            var outerHeight = Math.floor(this._outerHeight); // @perf
            var heightRatio = totalHeight / outerHeight;
            var allColorZones = [];
            for (var i = 0, len = this._zones.length; i < len; i++) {
                var zone = this._zones[i];
                if (!colorZonesInvalid) {
                    var colorZones_1 = zone.getColorZones();
                    if (colorZones_1) {
                        for (var j = 0, lenJ = colorZones_1.length; j < lenJ; j++) {
                            allColorZones.push(colorZones_1[j]);
                        }
                        continue;
                    }
                }
                var colorZones = [];
                if (zone.forceHeight) {
                    var forcedHeight = Math.floor(zone.forceHeight * this._pixelRatio);
                    var y1 = Math.floor(this._getVerticalOffsetForLine(zone.startLineNumber));
                    y1 = Math.floor(y1 * heightRatio);
                    var y2 = y1 + forcedHeight;
                    colorZones.push(this.createZone(totalHeight, y1, y2, forcedHeight, forcedHeight, zone.getColor(useDarkColor), zone.position));
                }
                else {
                    var y1 = Math.floor(this._getVerticalOffsetForLine(zone.startLineNumber));
                    var y2 = Math.floor(this._getVerticalOffsetForLine(zone.endLineNumber)) + lineHeight;
                    y1 = Math.floor(y1 * heightRatio);
                    y2 = Math.floor(y2 * heightRatio);
                    // Figure out if we can render this in one continuous zone
                    var zoneLineNumbers = zone.endLineNumber - zone.startLineNumber + 1;
                    var zoneMaximumHeight = zoneLineNumbers * maximumHeight;
                    if (y2 - y1 > zoneMaximumHeight) {
                        // We need to draw one zone per line
                        for (var lineNumber = zone.startLineNumber; lineNumber <= zone.endLineNumber; lineNumber++) {
                            y1 = Math.floor(this._getVerticalOffsetForLine(lineNumber));
                            y2 = y1 + lineHeight;
                            y1 = Math.floor(y1 * heightRatio);
                            y2 = Math.floor(y2 * heightRatio);
                            colorZones.push(this.createZone(totalHeight, y1, y2, minimumHeight, maximumHeight, zone.getColor(useDarkColor), zone.position));
                        }
                    }
                    else {
                        colorZones.push(this.createZone(totalHeight, y1, y2, minimumHeight, zoneMaximumHeight, zone.getColor(useDarkColor), zone.position));
                    }
                }
                zone.setColorZones(colorZones);
                for (var j = 0, lenJ = colorZones.length; j < lenJ; j++) {
                    allColorZones.push(colorZones[j]);
                }
            }
            this._colorZonesInvalid = false;
            var sortFunc = function (a, b) {
                if (a.colorId === b.colorId) {
                    if (a.from === b.from) {
                        return a.to - b.to;
                    }
                    return a.from - b.from;
                }
                return a.colorId - b.colorId;
            };
            allColorZones.sort(sortFunc);
            return allColorZones;
        };
        OverviewZoneManager.prototype.createZone = function (totalHeight, y1, y2, minimumHeight, maximumHeight, color, position) {
            totalHeight = Math.floor(totalHeight); // @perf
            y1 = Math.floor(y1); // @perf
            y2 = Math.floor(y2); // @perf
            minimumHeight = Math.floor(minimumHeight); // @perf
            maximumHeight = Math.floor(maximumHeight); // @perf
            var ycenter = Math.floor((y1 + y2) / 2);
            var halfHeight = (y2 - ycenter);
            if (halfHeight > maximumHeight / 2) {
                halfHeight = maximumHeight / 2;
            }
            if (halfHeight < minimumHeight / 2) {
                halfHeight = minimumHeight / 2;
            }
            if (ycenter - halfHeight < 0) {
                ycenter = halfHeight;
            }
            if (ycenter + halfHeight > totalHeight) {
                ycenter = totalHeight - halfHeight;
            }
            var colorId = this._color2Id[color];
            if (!colorId) {
                colorId = (++this._lastAssignedId);
                this._color2Id[color] = colorId;
                this._id2Color[colorId] = color;
            }
            return new editorCommon_1.ColorZone(ycenter - halfHeight, ycenter + halfHeight, colorId, position);
        };
        return OverviewZoneManager;
    }());
    exports.OverviewZoneManager = OverviewZoneManager;
});

define(__m[102], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LineVisibleRanges = (function () {
        function LineVisibleRanges(lineNumber, ranges) {
            this.lineNumber = lineNumber;
            this.ranges = ranges;
        }
        return LineVisibleRanges;
    }());
    exports.LineVisibleRanges = LineVisibleRanges;
    var VisibleRange = (function () {
        function VisibleRange(top, left, width) {
            this.top = top | 0;
            this.left = left | 0;
            this.width = width | 0;
        }
        return VisibleRange;
    }());
    exports.VisibleRange = VisibleRange;
    var HorizontalRange = (function () {
        function HorizontalRange(left, width) {
            this.left = left | 0;
            this.width = width | 0;
        }
        return HorizontalRange;
    }());
    exports.HorizontalRange = HorizontalRange;
});

define(__m[397], __M([0,1,102]), function (require, exports, renderingContext_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var RangeUtil = (function () {
        function RangeUtil() {
        }
        RangeUtil._createRange = function () {
            if (!this._handyReadyRange) {
                this._handyReadyRange = document.createRange();
            }
            return this._handyReadyRange;
        };
        RangeUtil._detachRange = function (range, endNode) {
            // Move range out of the span node, IE doesn't like having many ranges in
            // the same spot and will act badly for lines containing dashes ('-')
            range.selectNodeContents(endNode);
        };
        RangeUtil._readClientRects = function (startElement, startOffset, endElement, endOffset, endNode) {
            var range = this._createRange();
            try {
                range.setStart(startElement, startOffset);
                range.setEnd(endElement, endOffset);
                return range.getClientRects();
            }
            catch (e) {
                // This is life ...
                return null;
            }
            finally {
                this._detachRange(range, endNode);
            }
        };
        RangeUtil._createHorizontalRangesFromClientRects = function (clientRects, clientRectDeltaLeft, scaleRatio) {
            if (!clientRects || clientRects.length === 0) {
                return null;
            }
            var result = [];
            var prevLeft = Math.max(0, clientRects[0].left * scaleRatio - clientRectDeltaLeft);
            var prevWidth = clientRects[0].width * scaleRatio;
            for (var i = 1, len = clientRects.length; i < len; i++) {
                var myLeft = Math.max(0, clientRects[i].left * scaleRatio - clientRectDeltaLeft);
                var myWidth = clientRects[i].width * scaleRatio;
                if (myLeft < prevLeft) {
                    console.error('Unexpected: RangeUtil._createHorizontalRangesFromClientRects: client rects are not sorted');
                }
                if (prevLeft + prevWidth + 0.9 /* account for browser's rounding errors*/ >= myLeft) {
                    prevWidth = Math.max(prevWidth, myLeft + myWidth - prevLeft);
                }
                else {
                    result.push(new renderingContext_1.HorizontalRange(prevLeft, prevWidth));
                    prevLeft = myLeft;
                    prevWidth = myWidth;
                }
            }
            result.push(new renderingContext_1.HorizontalRange(prevLeft, prevWidth));
            return result;
        };
        RangeUtil.readHorizontalRanges = function (domNode, startChildIndex, startOffset, endChildIndex, endOffset, clientRectDeltaLeft, scaleRatio, endNode) {
            // Panic check
            var min = 0;
            var max = domNode.children.length - 1;
            if (min > max) {
                return null;
            }
            startChildIndex = Math.min(max, Math.max(min, startChildIndex));
            endChildIndex = Math.min(max, Math.max(min, endChildIndex));
            // If crossing over to a span only to select offset 0, then use the previous span's maximum offset
            // Chrome is buggy and doesn't handle 0 offsets well sometimes.
            if (startChildIndex !== endChildIndex) {
                if (endChildIndex > 0 && endOffset === 0) {
                    endChildIndex--;
                    endOffset = Number.MAX_VALUE;
                }
            }
            var startElement = domNode.children[startChildIndex].firstChild;
            var endElement = domNode.children[endChildIndex].firstChild;
            if (!startElement || !endElement) {
                return null;
            }
            startOffset = Math.min(startElement.textContent.length, Math.max(0, startOffset));
            endOffset = Math.min(endElement.textContent.length, Math.max(0, endOffset));
            var clientRects = this._readClientRects(startElement, startOffset, endElement, endOffset, endNode);
            return this._createHorizontalRangesFromClientRects(clientRects, clientRectDeltaLeft, scaleRatio);
        };
        return RangeUtil;
    }());
    exports.RangeUtil = RangeUtil;
});

define(__m[399], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewContext = (function () {
        function ViewContext(configuration, model, privateViewEventBus, addEventHandler, removeEventHandler) {
            this.configuration = configuration;
            this.model = model;
            this.privateViewEventBus = privateViewEventBus;
            this.addEventHandler = addEventHandler;
            this.removeEventHandler = removeEventHandler;
        }
        return ViewContext;
    }());
    exports.ViewContext = ViewContext;
});

define(__m[403], __M([0,1,7]), function (require, exports, editorCommon_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditorLayoutProvider = (function () {
        function EditorLayoutProvider() {
        }
        EditorLayoutProvider.compute = function (_opts) {
            var outerWidth = _opts.outerWidth | 0;
            var outerHeight = _opts.outerHeight | 0;
            var showGlyphMargin = Boolean(_opts.showGlyphMargin);
            var lineHeight = _opts.lineHeight | 0;
            var showLineNumbers = Boolean(_opts.showLineNumbers);
            var lineNumbersMinChars = _opts.lineNumbersMinChars | 0;
            var lineDecorationsWidth = _opts.lineDecorationsWidth | 0;
            var maxDigitWidth = Number(_opts.maxDigitWidth);
            var lineCount = _opts.lineCount | 0;
            var verticalScrollbarWidth = _opts.verticalScrollbarWidth | 0;
            var verticalScrollbarHasArrows = Boolean(_opts.verticalScrollbarHasArrows);
            var scrollbarArrowSize = _opts.scrollbarArrowSize | 0;
            var horizontalScrollbarHeight = _opts.horizontalScrollbarHeight | 0;
            var lineNumbersWidth = 0;
            if (showLineNumbers) {
                var digitCount = Math.max(this.digitCount(lineCount), lineNumbersMinChars);
                lineNumbersWidth = Math.round(digitCount * maxDigitWidth);
            }
            var glyphMarginWidth = 0;
            if (showGlyphMargin) {
                glyphMarginWidth = lineHeight;
            }
            var contentWidth = outerWidth - glyphMarginWidth - lineNumbersWidth - lineDecorationsWidth;
            var glyphMarginLeft = 0;
            var lineNumbersLeft = glyphMarginLeft + glyphMarginWidth;
            var decorationsLeft = lineNumbersLeft + lineNumbersWidth;
            var contentLeft = decorationsLeft + lineDecorationsWidth;
            var verticalArrowSize = (verticalScrollbarHasArrows ? scrollbarArrowSize : 0);
            return new editorCommon_1.EditorLayoutInfo({
                width: outerWidth,
                height: outerHeight,
                glyphMarginLeft: glyphMarginLeft,
                glyphMarginWidth: glyphMarginWidth,
                glyphMarginHeight: outerHeight,
                lineNumbersLeft: lineNumbersLeft,
                lineNumbersWidth: lineNumbersWidth,
                lineNumbersHeight: outerHeight,
                decorationsLeft: decorationsLeft,
                decorationsWidth: lineDecorationsWidth,
                decorationsHeight: outerHeight,
                contentLeft: contentLeft,
                contentWidth: contentWidth,
                contentHeight: outerHeight,
                verticalScrollbarWidth: verticalScrollbarWidth,
                horizontalScrollbarHeight: horizontalScrollbarHeight,
                overviewRuler: new editorCommon_1.OverviewRulerPosition({
                    top: verticalArrowSize,
                    width: verticalScrollbarWidth,
                    height: (outerHeight - 2 * verticalArrowSize),
                    right: 0
                })
            });
        };
        EditorLayoutProvider.digitCount = function (n) {
            var r = 0;
            while (n) {
                n = Math.floor(n / 10);
                r++;
            }
            return r ? r : 1;
        };
        return EditorLayoutProvider;
    }());
    exports.EditorLayoutProvider = EditorLayoutProvider;
});

define(__m[103], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var RenderLineInput = (function () {
        function RenderLineInput(lineContent, tabSize, spaceWidth, stopRenderingLineAfter, renderWhitespace, parts) {
            this.lineContent = lineContent;
            this.tabSize = tabSize;
            this.spaceWidth = spaceWidth;
            this.stopRenderingLineAfter = stopRenderingLineAfter;
            this.renderWhitespace = renderWhitespace;
            this.parts = parts;
        }
        return RenderLineInput;
    }());
    exports.RenderLineInput = RenderLineInput;
    var RenderLineOutput = (function () {
        function RenderLineOutput(charOffsetInPart, lastRenderedPartIndex, output) {
            this.charOffsetInPart = charOffsetInPart;
            this.lastRenderedPartIndex = lastRenderedPartIndex;
            this.output = output;
        }
        return RenderLineOutput;
    }());
    exports.RenderLineOutput = RenderLineOutput;
    var _space = ' '.charCodeAt(0);
    var _tab = '\t'.charCodeAt(0);
    var _lowerThan = '<'.charCodeAt(0);
    var _greaterThan = '>'.charCodeAt(0);
    var _ampersand = '&'.charCodeAt(0);
    var _carriageReturn = '\r'.charCodeAt(0);
    var _lineSeparator = '\u2028'.charCodeAt(0); //http://www.fileformat.info/info/unicode/char/2028/index.htm
    var _bom = 65279;
    function renderLine(input) {
        var lineText = input.lineContent;
        var lineTextLength = lineText.length;
        var tabSize = input.tabSize;
        var spaceWidth = input.spaceWidth;
        var actualLineParts = input.parts;
        var renderWhitespace = input.renderWhitespace;
        var charBreakIndex = (input.stopRenderingLineAfter === -1 ? lineTextLength : input.stopRenderingLineAfter - 1);
        if (lineTextLength === 0) {
            return new RenderLineOutput([], 0, 
            // This is basically for IE's hit test to work
            '<span><span>&nbsp;</span></span>');
        }
        if (actualLineParts.length === 0) {
            throw new Error('Cannot render non empty line without line parts!');
        }
        return renderLineActual(lineText, lineTextLength, tabSize, spaceWidth, actualLineParts.slice(0), renderWhitespace, charBreakIndex);
    }
    exports.renderLine = renderLine;
    function isWhitespace(type) {
        return (type.indexOf('whitespace') >= 0);
    }
    function isIndentGuide(type) {
        return (type.indexOf('indent-guide') >= 0);
    }
    function renderLineActual(lineText, lineTextLength, tabSize, spaceWidth, actualLineParts, renderWhitespace, charBreakIndex) {
        lineTextLength = +lineTextLength;
        tabSize = +tabSize;
        charBreakIndex = +charBreakIndex;
        var charIndex = 0;
        var out = '';
        var charOffsetInPartArr = [];
        var charOffsetInPart = 0;
        var tabsCharDelta = 0;
        out += '<span>';
        for (var partIndex = 0, partIndexLen = actualLineParts.length; partIndex < partIndexLen; partIndex++) {
            var part = actualLineParts[partIndex];
            var parsRendersWhitespace = (renderWhitespace && isWhitespace(part.type));
            var partIsFixedWidth = parsRendersWhitespace || isIndentGuide(part.type);
            var toCharIndex = lineTextLength;
            if (partIndex + 1 < partIndexLen) {
                var nextPart = actualLineParts[partIndex + 1];
                toCharIndex = Math.min(lineTextLength, nextPart.startIndex);
            }
            charOffsetInPart = 0;
            if (partIsFixedWidth) {
                var partContentCnt = 0;
                var partContent = '';
                for (; charIndex < toCharIndex; charIndex++) {
                    charOffsetInPartArr[charIndex] = charOffsetInPart;
                    var charCode = lineText.charCodeAt(charIndex);
                    if (charCode === _tab) {
                        var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;
                        tabsCharDelta += insertSpacesCount - 1;
                        charOffsetInPart += insertSpacesCount - 1;
                        if (insertSpacesCount > 0) {
                            partContent += parsRendersWhitespace ? '&rarr;' : '&nbsp;';
                            partContentCnt++;
                            insertSpacesCount--;
                        }
                        while (insertSpacesCount > 0) {
                            partContent += '&nbsp;';
                            partContentCnt++;
                            insertSpacesCount--;
                        }
                    }
                    else {
                        // must be _space
                        partContent += parsRendersWhitespace ? '&middot;' : '&nbsp;';
                        partContentCnt++;
                    }
                    charOffsetInPart++;
                    if (charIndex >= charBreakIndex) {
                        out += '<span class="token ' + part.type + '" style="width:' + (spaceWidth * partContentCnt) + 'px">';
                        out += partContent;
                        out += '&hellip;</span></span>';
                        charOffsetInPartArr[charIndex] = charOffsetInPart;
                        return new RenderLineOutput(charOffsetInPartArr, partIndex, out);
                    }
                }
                out += '<span class="token ' + part.type + '" style="width:' + (spaceWidth * partContentCnt) + 'px">';
                out += partContent;
                out += '</span>';
            }
            else {
                out += '<span class="token ';
                out += part.type;
                out += '">';
                for (; charIndex < toCharIndex; charIndex++) {
                    charOffsetInPartArr[charIndex] = charOffsetInPart;
                    var charCode = lineText.charCodeAt(charIndex);
                    switch (charCode) {
                        case _tab:
                            var insertSpacesCount = tabSize - (charIndex + tabsCharDelta) % tabSize;
                            tabsCharDelta += insertSpacesCount - 1;
                            charOffsetInPart += insertSpacesCount - 1;
                            while (insertSpacesCount > 0) {
                                out += '&nbsp;';
                                insertSpacesCount--;
                            }
                            break;
                        case _space:
                            out += '&nbsp;';
                            break;
                        case _lowerThan:
                            out += '&lt;';
                            break;
                        case _greaterThan:
                            out += '&gt;';
                            break;
                        case _ampersand:
                            out += '&amp;';
                            break;
                        case 0:
                            out += '&#00;';
                            break;
                        case _bom:
                        case _lineSeparator:
                            out += '\ufffd';
                            break;
                        case _carriageReturn:
                            // zero width space, because carriage return would introduce a line break
                            out += '&#8203';
                            break;
                        default:
                            out += lineText.charAt(charIndex);
                    }
                    charOffsetInPart++;
                    if (charIndex >= charBreakIndex) {
                        out += '&hellip;</span></span>';
                        charOffsetInPartArr[charIndex] = charOffsetInPart;
                        return new RenderLineOutput(charOffsetInPartArr, partIndex, out);
                    }
                }
                out += '</span>';
            }
        }
        out += '</span>';
        // When getting client rects for the last character, we will position the
        // text range at the end of the span, insteaf of at the beginning of next span
        charOffsetInPartArr.push(charOffsetInPart);
        return new RenderLineOutput(charOffsetInPartArr, actualLineParts.length - 1, out);
    }
});

define(__m[406], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewLinesViewportData = (function () {
        function ViewLinesViewportData(partialData, visibleRange, decorationsData) {
            this.viewportTop = partialData.viewportTop | 0;
            this.viewportHeight = partialData.viewportHeight | 0;
            this.bigNumbersDelta = partialData.bigNumbersDelta | 0;
            this.visibleRangesDeltaTop = partialData.visibleRangesDeltaTop | 0;
            this.startLineNumber = partialData.startLineNumber | 0;
            this.endLineNumber = partialData.endLineNumber | 0;
            this.relativeVerticalOffset = partialData.relativeVerticalOffset;
            this.visibleRange = visibleRange;
            this._decorations = decorationsData.decorations;
            this._inlineDecorations = decorationsData.inlineDecorations;
        }
        ViewLinesViewportData.prototype.getDecorationsInViewport = function () {
            return this._decorations;
        };
        ViewLinesViewportData.prototype.getInlineDecorationsForLineInViewport = function (lineNumber) {
            lineNumber = lineNumber | 0;
            return this._inlineDecorations[lineNumber - this.startLineNumber];
        };
        return ViewLinesViewportData;
    }());
    exports.ViewLinesViewportData = ViewLinesViewportData;
});

define(__m[407], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Represent whitespaces in between lines and provide fast CRUD management methods.
     * The whitespaces are sorted ascending by `afterLineNumber`.
     */
    var WhitespaceComputer = (function () {
        function WhitespaceComputer() {
            this.heights = [];
            this.ids = [];
            this.afterLineNumbers = [];
            this.ordinals = [];
            this.prefixSum = [];
            this.prefixSumValidIndex = -1;
            this.whitespaceId2Index = {};
            this.lastWhitespaceId = 0;
        }
        /**
         * Find the insertion index for a new value inside a sorted array of values.
         * If the value is already present in the sorted array, the insertion index will be after the already existing value.
         */
        WhitespaceComputer.findInsertionIndex = function (sortedArray, value, ordinals, valueOrdinal) {
            var low = 0, high = sortedArray.length, mid;
            while (low < high) {
                mid = Math.floor((low + high) / 2);
                if (value === sortedArray[mid]) {
                    if (valueOrdinal < ordinals[mid]) {
                        high = mid;
                    }
                    else {
                        low = mid + 1;
                    }
                }
                else if (value < sortedArray[mid]) {
                    high = mid;
                }
                else {
                    low = mid + 1;
                }
            }
            return low;
        };
        /**
         * Insert a new whitespace of a certain height after a line number.
         * The whitespace has a "sticky" characteristic.
         * Irrespective of edits above or below `afterLineNumber`, the whitespace will follow the initial line.
         *
         * @param afterLineNumber The conceptual position of this whitespace. The whitespace will follow this line as best as possible even when deleting/inserting lines above/below.
         * @param heightInPx The height of the whitespace, in pixels.
         * @return An id that can be used later to mutate or delete the whitespace
         */
        WhitespaceComputer.prototype.insertWhitespace = function (afterLineNumber, ordinal, heightInPx) {
            afterLineNumber = afterLineNumber | 0;
            ordinal = ordinal | 0;
            heightInPx = heightInPx | 0;
            var id = (++this.lastWhitespaceId);
            var insertionIndex = WhitespaceComputer.findInsertionIndex(this.afterLineNumbers, afterLineNumber, this.ordinals, ordinal);
            this.insertWhitespaceAtIndex(id, insertionIndex, afterLineNumber, ordinal, heightInPx);
            return id;
        };
        WhitespaceComputer.prototype.insertWhitespaceAtIndex = function (id, insertIndex, afterLineNumber, ordinal, heightInPx) {
            id = id | 0;
            insertIndex = insertIndex | 0;
            afterLineNumber = afterLineNumber | 0;
            ordinal = ordinal | 0;
            heightInPx = heightInPx | 0;
            this.heights.splice(insertIndex, 0, heightInPx);
            this.ids.splice(insertIndex, 0, id);
            this.afterLineNumbers.splice(insertIndex, 0, afterLineNumber);
            this.ordinals.splice(insertIndex, 0, ordinal);
            this.prefixSum.splice(insertIndex, 0, 0);
            var keys = Object.keys(this.whitespaceId2Index);
            for (var i = 0, len = keys.length; i < len; i++) {
                var sid = keys[i];
                var oldIndex = this.whitespaceId2Index[sid];
                if (oldIndex >= insertIndex) {
                    this.whitespaceId2Index[sid] = oldIndex + 1;
                }
            }
            this.whitespaceId2Index[id.toString()] = insertIndex;
            this.prefixSumValidIndex = Math.min(this.prefixSumValidIndex, insertIndex - 1);
        };
        WhitespaceComputer.prototype.changeWhitespace = function (id, newAfterLineNumber, newHeight) {
            id = id | 0;
            newAfterLineNumber = newAfterLineNumber | 0;
            newHeight = newHeight | 0;
            var hasChanges = false;
            hasChanges = this.changeWhitespaceHeight(id, newHeight) || hasChanges;
            hasChanges = this.changeWhitespaceAfterLineNumber(id, newAfterLineNumber) || hasChanges;
            return hasChanges;
        };
        /**
         * Change the height of an existing whitespace
         *
         * @param id The whitespace to change
         * @param newHeightInPx The new height of the whitespace, in pixels
         * @return Returns true if the whitespace is found and if the new height is different than the old height
         */
        WhitespaceComputer.prototype.changeWhitespaceHeight = function (id, newHeightInPx) {
            id = id | 0;
            newHeightInPx = newHeightInPx | 0;
            var sid = id.toString();
            if (this.whitespaceId2Index.hasOwnProperty(sid)) {
                var index = this.whitespaceId2Index[sid];
                if (this.heights[index] !== newHeightInPx) {
                    this.heights[index] = newHeightInPx;
                    this.prefixSumValidIndex = Math.min(this.prefixSumValidIndex, index - 1);
                    return true;
                }
            }
            return false;
        };
        /**
         * Change the line number after which an existing whitespace flows.
         *
         * @param id The whitespace to change
         * @param newAfterLineNumber The new line number the whitespace will follow
         * @return Returns true if the whitespace is found and if the new line number is different than the old line number
         */
        WhitespaceComputer.prototype.changeWhitespaceAfterLineNumber = function (id, newAfterLineNumber) {
            id = id | 0;
            newAfterLineNumber = newAfterLineNumber | 0;
            var sid = id.toString();
            if (this.whitespaceId2Index.hasOwnProperty(sid)) {
                var index = this.whitespaceId2Index[sid];
                if (this.afterLineNumbers[index] !== newAfterLineNumber) {
                    // `afterLineNumber` changed for this whitespace
                    // Record old ordinal
                    var ordinal = this.ordinals[index];
                    // Record old height
                    var heightInPx = this.heights[index];
                    // Since changing `afterLineNumber` can trigger a reordering, we're gonna remove this whitespace
                    this.removeWhitespace(id);
                    // And add it again
                    var insertionIndex = WhitespaceComputer.findInsertionIndex(this.afterLineNumbers, newAfterLineNumber, this.ordinals, ordinal);
                    this.insertWhitespaceAtIndex(id, insertionIndex, newAfterLineNumber, ordinal, heightInPx);
                    return true;
                }
            }
            return false;
        };
        /**
         * Remove an existing whitespace.
         *
         * @param id The whitespace to remove
         * @return Returns true if the whitespace is found and it is removed.
         */
        WhitespaceComputer.prototype.removeWhitespace = function (id) {
            id = id | 0;
            var sid = id.toString();
            if (this.whitespaceId2Index.hasOwnProperty(sid)) {
                var index = this.whitespaceId2Index[sid];
                delete this.whitespaceId2Index[sid];
                this.removeWhitespaceAtIndex(index);
                return true;
            }
            return false;
        };
        WhitespaceComputer.prototype.removeWhitespaceAtIndex = function (removeIndex) {
            removeIndex = removeIndex | 0;
            this.heights.splice(removeIndex, 1);
            this.ids.splice(removeIndex, 1);
            this.afterLineNumbers.splice(removeIndex, 1);
            this.ordinals.splice(removeIndex, 1);
            this.prefixSum.splice(removeIndex, 1);
            this.prefixSumValidIndex = Math.min(this.prefixSumValidIndex, removeIndex - 1);
            var keys = Object.keys(this.whitespaceId2Index);
            for (var i = 0, len = keys.length; i < len; i++) {
                var sid = keys[i];
                var oldIndex = this.whitespaceId2Index[sid];
                if (oldIndex >= removeIndex) {
                    this.whitespaceId2Index[sid] = oldIndex - 1;
                }
            }
        };
        /**
         * Notify the computer that lines have been deleted (a continuous zone of lines).
         * This gives it a chance to update `afterLineNumber` for whitespaces, giving the "sticky" characteristic.
         *
         * @param fromLineNumber The line number at which the deletion started, inclusive
         * @param toLineNumber The line number at which the deletion ended, inclusive
         */
        WhitespaceComputer.prototype.onModelLinesDeleted = function (fromLineNumber, toLineNumber) {
            fromLineNumber = fromLineNumber | 0;
            toLineNumber = toLineNumber | 0;
            var afterLineNumber, i, len;
            for (i = 0, len = this.afterLineNumbers.length; i < len; i++) {
                afterLineNumber = this.afterLineNumbers[i];
                if (fromLineNumber <= afterLineNumber && afterLineNumber <= toLineNumber) {
                    // The line this whitespace was after has been deleted
                    //  => move whitespace to before first deleted line
                    this.afterLineNumbers[i] = fromLineNumber - 1;
                }
                else if (afterLineNumber > toLineNumber) {
                    // The line this whitespace was after has been moved up
                    //  => move whitespace up
                    this.afterLineNumbers[i] -= (toLineNumber - fromLineNumber + 1);
                }
            }
        };
        /**
         * Notify the computer that lines have been inserted (a continuous zone of lines).
         * This gives it a chance to update `afterLineNumber` for whitespaces, giving the "sticky" characteristic.
         *
         * @param fromLineNumber The line number at which the insertion started, inclusive
         * @param toLineNumber The line number at which the insertion ended, inclusive.
         */
        WhitespaceComputer.prototype.onModelLinesInserted = function (fromLineNumber, toLineNumber) {
            fromLineNumber = fromLineNumber | 0;
            toLineNumber = toLineNumber | 0;
            var afterLineNumber, i, len;
            for (i = 0, len = this.afterLineNumbers.length; i < len; i++) {
                afterLineNumber = this.afterLineNumbers[i];
                if (fromLineNumber <= afterLineNumber) {
                    this.afterLineNumbers[i] += (toLineNumber - fromLineNumber + 1);
                }
            }
        };
        /**
         * Get the sum of all the whitespaces.
         */
        WhitespaceComputer.prototype.getTotalHeight = function () {
            if (this.heights.length === 0) {
                return 0;
            }
            return this.getAccumulatedHeight(this.heights.length - 1);
        };
        /**
         * Return the sum of the heights of the whitespaces at [0..index].
         * This includes the whitespace at `index`.
         *
         * @param index The index of the whitespace.
         * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.
         */
        WhitespaceComputer.prototype.getAccumulatedHeight = function (index) {
            index = index | 0;
            var startIndex = Math.max(0, this.prefixSumValidIndex + 1);
            if (startIndex === 0) {
                this.prefixSum[0] = this.heights[0];
                startIndex++;
            }
            for (var i = startIndex; i <= index; i++) {
                this.prefixSum[i] = this.prefixSum[i - 1] + this.heights[i];
            }
            this.prefixSumValidIndex = Math.max(this.prefixSumValidIndex, index);
            return this.prefixSum[index];
        };
        /**
         * Find all whitespaces with `afterLineNumber` < `lineNumber` and return the sum of their heights.
         *
         * @param lineNumber The line number whitespaces should be before.
         * @return The sum of the heights of the whitespaces before `lineNumber`.
         */
        WhitespaceComputer.prototype.getAccumulatedHeightBeforeLineNumber = function (lineNumber) {
            lineNumber = lineNumber | 0;
            var lastWhitespaceBeforeLineNumber = this.findLastWhitespaceBeforeLineNumber(lineNumber);
            if (lastWhitespaceBeforeLineNumber === -1) {
                return 0;
            }
            return this.getAccumulatedHeight(lastWhitespaceBeforeLineNumber);
        };
        WhitespaceComputer.prototype.findLastWhitespaceBeforeLineNumber = function (lineNumber) {
            lineNumber = lineNumber | 0;
            // Find the whitespace before line number
            var afterLineNumbers = this.afterLineNumbers;
            var low = 0;
            var high = afterLineNumbers.length - 1;
            while (low <= high) {
                var delta = (high - low) | 0;
                var halfDelta = (delta / 2) | 0;
                var mid = (low + halfDelta) | 0;
                if (afterLineNumbers[mid] < lineNumber) {
                    if (mid + 1 >= afterLineNumbers.length || afterLineNumbers[mid + 1] >= lineNumber) {
                        return mid;
                    }
                    else {
                        low = (mid + 1) | 0;
                    }
                }
                else {
                    high = (mid - 1) | 0;
                }
            }
            return -1;
        };
        WhitespaceComputer.prototype.findFirstWhitespaceAfterLineNumber = function (lineNumber) {
            lineNumber = lineNumber | 0;
            var lastWhitespaceBeforeLineNumber = this.findLastWhitespaceBeforeLineNumber(lineNumber);
            var firstWhitespaceAfterLineNumber = lastWhitespaceBeforeLineNumber + 1;
            if (firstWhitespaceAfterLineNumber < this.heights.length) {
                return firstWhitespaceAfterLineNumber;
            }
            return -1;
        };
        /**
         * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.
         * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.
         */
        WhitespaceComputer.prototype.getFirstWhitespaceIndexAfterLineNumber = function (lineNumber) {
            lineNumber = lineNumber | 0;
            return this.findFirstWhitespaceAfterLineNumber(lineNumber);
        };
        /**
         * The number of whitespaces.
         */
        WhitespaceComputer.prototype.getCount = function () {
            return this.heights.length;
        };
        /**
         * Get the `afterLineNumber` for whitespace at index `index`.
         *
         * @param index The index of the whitespace.
         * @return `afterLineNumber` of whitespace at `index`.
         */
        WhitespaceComputer.prototype.getAfterLineNumberForWhitespaceIndex = function (index) {
            index = index | 0;
            return this.afterLineNumbers[index];
        };
        /**
         * Get the `id` for whitespace at index `index`.
         *
         * @param index The index of the whitespace.
         * @return `id` of whitespace at `index`.
         */
        WhitespaceComputer.prototype.getIdForWhitespaceIndex = function (index) {
            index = index | 0;
            return this.ids[index];
        };
        /**
         * Get the `height` for whitespace at index `index`.
         *
         * @param index The index of the whitespace.
         * @return `height` of whitespace at `index`.
         */
        WhitespaceComputer.prototype.getHeightForWhitespaceIndex = function (index) {
            index = index | 0;
            return this.heights[index];
        };
        WhitespaceComputer.prototype.getWhitespaces = function (deviceLineHeight) {
            deviceLineHeight = deviceLineHeight | 0;
            var result = [];
            for (var i = 0; i < this.heights.length; i++) {
                result.push({
                    id: this.ids[i],
                    afterLineNumber: this.afterLineNumbers[i],
                    heightInLines: this.heights[i] / deviceLineHeight
                });
            }
            return result;
        };
        return WhitespaceComputer;
    }());
    exports.WhitespaceComputer = WhitespaceComputer;
});

define(__m[408], __M([0,1,407]), function (require, exports, whitespaceComputer_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Layouting of objects that take vertical space (by having a height) and push down other objects.
     *
     * These objects are basically either text (lines) or spaces between those lines (whitespaces).
     * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).
     * This is written with no knowledge of an editor in mind.
     */
    var VerticalObjects = (function () {
        function VerticalObjects() {
            this.linesCount = 0;
            this.whitespaces = new whitespaceComputer_1.WhitespaceComputer();
        }
        /**
         * Set the number of lines.
         *
         * @param newLineCount New number of lines.
         */
        VerticalObjects.prototype.replaceLines = function (newLineCount) {
            this.linesCount = newLineCount;
        };
        /**
         * Insert a new whitespace of a certain height after a line number.
         * The whitespace has a "sticky" characteristic.
         * Irrespective of edits above or below `afterLineNumber`, the whitespace will follow the initial line.
         *
         * @param afterLineNumber The conceptual position of this whitespace. The whitespace will follow this line as best as possible even when deleting/inserting lines above/below.
         * @param heightInPx The height of the whitespace, in pixels.
         * @return An id that can be used later to mutate or delete the whitespace
         */
        VerticalObjects.prototype.insertWhitespace = function (afterLineNumber, ordinal, heightInPx) {
            return this.whitespaces.insertWhitespace(afterLineNumber, ordinal, heightInPx);
        };
        VerticalObjects.prototype.changeWhitespace = function (id, newAfterLineNumber, newHeight) {
            return this.whitespaces.changeWhitespace(id, newAfterLineNumber, newHeight);
        };
        /**
         * Remove an existing whitespace.
         *
         * @param id The whitespace to remove
         * @return Returns true if the whitespace is found and it is removed.
         */
        VerticalObjects.prototype.removeWhitespace = function (id) {
            return this.whitespaces.removeWhitespace(id);
        };
        /**
         * Notify the layouter that lines have been deleted (a continuous zone of lines).
         *
         * @param fromLineNumber The line number at which the deletion started, inclusive
         * @param toLineNumber The line number at which the deletion ended, inclusive
         */
        VerticalObjects.prototype.onModelLinesDeleted = function (fromLineNumber, toLineNumber) {
            this.linesCount -= (toLineNumber - fromLineNumber + 1);
            this.whitespaces.onModelLinesDeleted(fromLineNumber, toLineNumber);
        };
        /**
         * Notify the layouter that lines have been inserted (a continuous zone of lines).
         *
         * @param fromLineNumber The line number at which the insertion started, inclusive
         * @param toLineNumber The line number at which the insertion ended, inclusive.
         */
        VerticalObjects.prototype.onModelLinesInserted = function (fromLineNumber, toLineNumber) {
            this.linesCount += (toLineNumber - fromLineNumber + 1);
            this.whitespaces.onModelLinesInserted(fromLineNumber, toLineNumber);
        };
        /**
         * Get the sum of heights for all objects.
         *
         * @param deviceLineHeight The height, in pixels, for one rendered line.
         * @return The sum of heights for all objects.
         */
        VerticalObjects.prototype.getTotalHeight = function (deviceLineHeight) {
            deviceLineHeight = deviceLineHeight | 0;
            var linesHeight = deviceLineHeight * this.linesCount;
            var whitespacesHeight = this.whitespaces.getTotalHeight();
            return linesHeight + whitespacesHeight;
        };
        /**
         * Get the vertical offset (the sum of heights for all objects above) a certain line number.
         *
         * @param lineNumber The line number
         * @param deviceLineHeight The height, in pixels, for one rendered line.
         * @return The sum of heights for all objects above `lineNumber`.
         */
        VerticalObjects.prototype.getVerticalOffsetForLineNumber = function (lineNumber, deviceLineHeight) {
            lineNumber = lineNumber | 0;
            deviceLineHeight = deviceLineHeight | 0;
            var previousLinesHeight;
            if (lineNumber > 1) {
                previousLinesHeight = deviceLineHeight * (lineNumber - 1);
            }
            else {
                previousLinesHeight = 0;
            }
            var previousWhitespacesHeight = this.whitespaces.getAccumulatedHeightBeforeLineNumber(lineNumber);
            return previousLinesHeight + previousWhitespacesHeight;
        };
        /**
         * Returns the accumulated height of whitespaces before the given line number.
         *
         * @param lineNumber The line number
         */
        VerticalObjects.prototype.getWhitespaceAccumulatedHeightBeforeLineNumber = function (lineNumber) {
            return this.whitespaces.getAccumulatedHeightBeforeLineNumber(lineNumber);
        };
        /**
         * Returns if there is any whitespace in the document.
         */
        VerticalObjects.prototype.hasWhitespace = function () {
            return this.whitespaces.getCount() > 0;
        };
        VerticalObjects.prototype.isAfterLines = function (verticalOffset, deviceLineHeight) {
            var totalHeight = this.getTotalHeight(deviceLineHeight);
            return verticalOffset > totalHeight;
        };
        /**
         * Find the first line number that is at or after vertical offset `verticalOffset`.
         * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then
         * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.
         *
         * @param verticalOffset The vertical offset to search at.
         * @param deviceLineHeight The height, in piexels, for one rendered line.
         * @return The line number at or after vertical offset `verticalOffset`.
         */
        VerticalObjects.prototype.getLineNumberAtOrAfterVerticalOffset = function (verticalOffset, deviceLineHeight) {
            verticalOffset = verticalOffset | 0;
            deviceLineHeight = deviceLineHeight | 0;
            if (verticalOffset < 0) {
                return 1;
            }
            var minLineNumber = 1;
            var linesCount = this.linesCount | 0;
            var maxLineNumber = linesCount;
            while (minLineNumber < maxLineNumber) {
                var midLineNumber = ((minLineNumber + maxLineNumber) / 2) | 0;
                var midLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(midLineNumber, deviceLineHeight) | 0;
                if (verticalOffset >= midLineNumberVerticalOffset + deviceLineHeight) {
                    // vertical offset is after mid line number
                    minLineNumber = midLineNumber + 1;
                }
                else if (verticalOffset >= midLineNumberVerticalOffset) {
                    // Hit
                    return midLineNumber;
                }
                else {
                    // vertical offset is before mid line number, but mid line number could still be what we're searching for
                    maxLineNumber = midLineNumber;
                }
            }
            if (minLineNumber > linesCount) {
                return linesCount;
            }
            return minLineNumber;
        };
        /**
         * Get the line that appears visually in the center between `verticalOffset1` and `verticalOffset2`.
         *
         * @param verticalOffset1 The beginning of the viewport
         * @param verticalOffset2 The end of the viewport.
         * @param deviceLineHeight The height, in pixels, for one rendered line.
         * @return The line number that is closest to the center between `verticalOffset1` and `verticalOffset2`.
         */
        VerticalObjects.prototype.getCenteredLineInViewport = function (verticalOffset1, verticalOffset2, deviceLineHeight) {
            verticalOffset1 = verticalOffset1 | 0;
            verticalOffset2 = verticalOffset2 | 0;
            deviceLineHeight = deviceLineHeight | 0;
            var viewportData = this.getLinesViewportData(verticalOffset1, verticalOffset2, deviceLineHeight);
            var verticalCenter = (verticalOffset2 - verticalOffset1) / 2;
            var currentLineActualTop, currentLineActualBottom;
            for (var lineNumber = viewportData.startLineNumber; lineNumber <= viewportData.endLineNumber; lineNumber++) {
                currentLineActualTop = viewportData.visibleRangesDeltaTop + viewportData.relativeVerticalOffset[lineNumber - viewportData.startLineNumber];
                currentLineActualBottom = currentLineActualTop + deviceLineHeight;
                if ((currentLineActualTop <= verticalCenter && verticalCenter < currentLineActualBottom) || currentLineActualTop > verticalCenter) {
                    return lineNumber;
                }
            }
            return viewportData.endLineNumber;
        };
        /**
         * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.
         *
         * @param verticalOffset1 The beginning of the viewport.
         * @param verticalOffset2 The end of the viewport.
         * @param deviceLineHeight The height, in pixels, for one rendered line.
         * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.
         */
        VerticalObjects.prototype.getLinesViewportData = function (verticalOffset1, verticalOffset2, deviceLineHeight) {
            verticalOffset1 = verticalOffset1 | 0;
            verticalOffset2 = verticalOffset2 | 0;
            deviceLineHeight = deviceLineHeight | 0;
            // Find first line number
            // We don't live in a perfect world, so the line number might start before or after verticalOffset1
            var startLineNumber = this.getLineNumberAtOrAfterVerticalOffset(verticalOffset1, deviceLineHeight) | 0;
            var endLineNumber = this.linesCount | 0;
            var startLineNumberVerticalOffset = this.getVerticalOffsetForLineNumber(startLineNumber, deviceLineHeight) | 0;
            // Also keep track of what whitespace we've got
            var whitespaceIndex = this.whitespaces.getFirstWhitespaceIndexAfterLineNumber(startLineNumber) | 0;
            var whitespaceCount = this.whitespaces.getCount() | 0;
            var currentWhitespaceHeight;
            var currentWhitespaceAfterLineNumber;
            if (whitespaceIndex === -1) {
                whitespaceIndex = whitespaceCount;
                currentWhitespaceAfterLineNumber = endLineNumber + 1;
                currentWhitespaceHeight = 0;
            }
            else {
                currentWhitespaceAfterLineNumber = this.whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;
                currentWhitespaceHeight = this.whitespaces.getHeightForWhitespaceIndex(whitespaceIndex) | 0;
            }
            var currentVerticalOffset = startLineNumberVerticalOffset;
            var currentLineRelativeOffset = currentVerticalOffset;
            // IE (all versions) cannot handle units above about 1,533,908 px, so every 500k pixels bring numbers down
            var STEP_SIZE = 500000;
            var bigNumbersDelta = 0;
            if (startLineNumberVerticalOffset >= STEP_SIZE) {
                // Compute a delta that guarantees that lines are positioned at `lineHeight` increments
                bigNumbersDelta = Math.floor(startLineNumberVerticalOffset / STEP_SIZE) * STEP_SIZE;
                bigNumbersDelta = Math.floor(bigNumbersDelta / deviceLineHeight) * deviceLineHeight;
                currentLineRelativeOffset -= bigNumbersDelta;
            }
            var linesOffsets = [];
            // Figure out how far the lines go
            for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
                // Count current line height in the vertical offsets
                currentVerticalOffset += deviceLineHeight;
                linesOffsets.push(currentLineRelativeOffset);
                // Next line starts immediately after this one
                currentLineRelativeOffset += deviceLineHeight;
                while (currentWhitespaceAfterLineNumber === lineNumber) {
                    // Push down next line with the height of the current whitespace
                    currentLineRelativeOffset += currentWhitespaceHeight;
                    // Count current whitespace in the vertical offsets
                    currentVerticalOffset += currentWhitespaceHeight;
                    whitespaceIndex++;
                    if (whitespaceIndex >= whitespaceCount) {
                        currentWhitespaceAfterLineNumber = endLineNumber + 1;
                    }
                    else {
                        currentWhitespaceAfterLineNumber = this.whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex) | 0;
                        currentWhitespaceHeight = this.whitespaces.getHeightForWhitespaceIndex(whitespaceIndex) | 0;
                    }
                }
                if (currentVerticalOffset > verticalOffset2) {
                    // We have covered the entire viewport area, time to stop
                    endLineNumber = lineNumber;
                    break;
                }
            }
            return {
                viewportTop: verticalOffset1 - bigNumbersDelta,
                viewportHeight: verticalOffset2 - verticalOffset1,
                bigNumbersDelta: bigNumbersDelta,
                startLineNumber: startLineNumber,
                endLineNumber: endLineNumber,
                visibleRangesDeltaTop: -(verticalOffset1 - bigNumbersDelta),
                relativeVerticalOffset: linesOffsets
            };
        };
        VerticalObjects.prototype.getVerticalOffsetForWhitespaceIndex = function (whitespaceIndex, deviceLineHeight) {
            whitespaceIndex = whitespaceIndex | 0;
            deviceLineHeight = deviceLineHeight | 0;
            var afterLineNumber = this.whitespaces.getAfterLineNumberForWhitespaceIndex(whitespaceIndex);
            var previousLinesHeight;
            if (afterLineNumber >= 1) {
                previousLinesHeight = deviceLineHeight * afterLineNumber;
            }
            else {
                previousLinesHeight = 0;
            }
            var previousWhitespacesHeight;
            if (whitespaceIndex > 0) {
                previousWhitespacesHeight = this.whitespaces.getAccumulatedHeight(whitespaceIndex - 1);
            }
            else {
                previousWhitespacesHeight = 0;
            }
            return previousLinesHeight + previousWhitespacesHeight;
        };
        VerticalObjects.prototype.getWhitespaceIndexAtOrAfterVerticallOffset = function (verticalOffset, deviceLineHeight) {
            verticalOffset = verticalOffset | 0;
            deviceLineHeight = deviceLineHeight | 0;
            var midWhitespaceIndex, minWhitespaceIndex = 0, maxWhitespaceIndex = this.whitespaces.getCount() - 1, midWhitespaceVerticalOffset, midWhitespaceHeight;
            if (maxWhitespaceIndex < 0) {
                return -1;
            }
            // Special case: nothing to be found
            var maxWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(maxWhitespaceIndex, deviceLineHeight);
            var maxWhitespaceHeight = this.whitespaces.getHeightForWhitespaceIndex(maxWhitespaceIndex);
            if (verticalOffset >= maxWhitespaceVerticalOffset + maxWhitespaceHeight) {
                return -1;
            }
            while (minWhitespaceIndex < maxWhitespaceIndex) {
                midWhitespaceIndex = Math.floor((minWhitespaceIndex + maxWhitespaceIndex) / 2);
                midWhitespaceVerticalOffset = this.getVerticalOffsetForWhitespaceIndex(midWhitespaceIndex, deviceLineHeight);
                midWhitespaceHeight = this.whitespaces.getHeightForWhitespaceIndex(midWhitespaceIndex);
                if (verticalOffset >= midWhitespaceVerticalOffset + midWhitespaceHeight) {
                    // vertical offset is after whitespace
                    minWhitespaceIndex = midWhitespaceIndex + 1;
                }
                else if (verticalOffset >= midWhitespaceVerticalOffset) {
                    // Hit
                    return midWhitespaceIndex;
                }
                else {
                    // vertical offset is before whitespace, but midWhitespaceIndex might still be what we're searching for
                    maxWhitespaceIndex = midWhitespaceIndex;
                }
            }
            return minWhitespaceIndex;
        };
        /**
         * Get exactly the whitespace that is layouted at `verticalOffset`.
         *
         * @param verticalOffset The vertical offset.
         * @param deviceLineHeight The height, in pixels, for one rendered line.
         * @return Precisely the whitespace that is layouted at `verticaloffset` or null.
         */
        VerticalObjects.prototype.getWhitespaceAtVerticalOffset = function (verticalOffset, deviceLineHeight) {
            verticalOffset = verticalOffset | 0;
            deviceLineHeight = deviceLineHeight | 0;
            var candidateIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset, deviceLineHeight);
            if (candidateIndex < 0) {
                return null;
            }
            if (candidateIndex >= this.whitespaces.getCount()) {
                return null;
            }
            var candidateTop = this.getVerticalOffsetForWhitespaceIndex(candidateIndex, deviceLineHeight);
            if (candidateTop > verticalOffset) {
                return null;
            }
            var candidateHeight = this.whitespaces.getHeightForWhitespaceIndex(candidateIndex);
            var candidateId = this.whitespaces.getIdForWhitespaceIndex(candidateIndex);
            var candidateAfterLineNumber = this.whitespaces.getAfterLineNumberForWhitespaceIndex(candidateIndex);
            return {
                id: candidateId,
                afterLineNumber: candidateAfterLineNumber,
                verticalOffset: candidateTop,
                height: candidateHeight
            };
        };
        /**
         * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.
         *
         * @param verticalOffset1 The beginning of the viewport.
         * @param verticalOffset2 The end of the viewport.
         * @param deviceLineHeight The height, in pixels, for one rendered line.
         * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.
         */
        VerticalObjects.prototype.getWhitespaceViewportData = function (verticalOffset1, verticalOffset2, deviceLineHeight) {
            verticalOffset1 = verticalOffset1 | 0;
            verticalOffset2 = verticalOffset2 | 0;
            deviceLineHeight = deviceLineHeight | 0;
            var startIndex = this.getWhitespaceIndexAtOrAfterVerticallOffset(verticalOffset1, deviceLineHeight);
            var endIndex = this.whitespaces.getCount() - 1;
            if (startIndex < 0) {
                return [];
            }
            var result = [], i, top, height;
            for (i = startIndex; i <= endIndex; i++) {
                top = this.getVerticalOffsetForWhitespaceIndex(i, deviceLineHeight);
                height = this.whitespaces.getHeightForWhitespaceIndex(i);
                if (top >= verticalOffset2) {
                    break;
                }
                result.push({
                    id: this.whitespaces.getIdForWhitespaceIndex(i),
                    afterLineNumber: this.whitespaces.getAfterLineNumberForWhitespaceIndex(i),
                    verticalOffset: top,
                    height: height
                });
            }
            return result;
        };
        VerticalObjects.prototype.getWhitespaces = function (deviceLineHeight) {
            return this.whitespaces.getWhitespaces(deviceLineHeight);
        };
        return VerticalObjects;
    }());
    exports.VerticalObjects = VerticalObjects;
});

define(__m[409], __M([0,1,408,4,406]), function (require, exports, verticalObjects_1, range_1, viewLinesViewportData_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Layouting of objects that take vertical space (by having a height) and push down other objects.
     *
     * These objects are basically either text (lines) or spaces between those lines (whitespaces).
     * This provides commodity operations for working with lines that contain whitespace that pushes lines lower (vertically).
     * This is a thin wrapper around VerticalObjects.VerticalObjects, with knowledge of the editor.
     */
    var LinesLayout = (function () {
        function LinesLayout(configuration, model) {
            this.configuration = configuration;
            this._lineHeight = this.configuration.editor.lineHeight;
            this._scrollBeyondLastLine = this.configuration.editor.viewInfo.scrollBeyondLastLine;
            this.model = model;
            this.verticalObjects = new verticalObjects_1.VerticalObjects();
            this.verticalObjects.replaceLines(model.getLineCount());
        }
        LinesLayout.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this.configuration.editor.lineHeight;
            }
            if (e.viewInfo.scrollBeyondLastLine) {
                this._scrollBeyondLastLine = this.configuration.editor.viewInfo.scrollBeyondLastLine;
            }
        };
        /**
         * Insert a new whitespace of a certain height after a line number.
         * The whitespace has a "sticky" characteristic.
         * Irrespective of edits above or below `afterLineNumber`, the whitespace will follow the initial line.
         *
         * @param afterLineNumber The conceptual position of this whitespace. The whitespace will follow this line as best as possible even when deleting/inserting lines above/below.
         * @param heightInPx The height of the whitespace, in pixels.
         * @return An id that can be used later to mutate or delete the whitespace
         */
        LinesLayout.prototype.insertWhitespace = function (afterLineNumber, ordinal, height) {
            return this.verticalObjects.insertWhitespace(afterLineNumber, ordinal, height);
        };
        LinesLayout.prototype.changeWhitespace = function (id, newAfterLineNumber, newHeight) {
            return this.verticalObjects.changeWhitespace(id, newAfterLineNumber, newHeight);
        };
        /**
         * Remove an existing whitespace.
         *
         * @param id The whitespace to remove
         * @return Returns true if the whitespace is found and it is removed.
         */
        LinesLayout.prototype.removeWhitespace = function (id) {
            return this.verticalObjects.removeWhitespace(id);
        };
        /**
         * Event handler, call when the model associated to this view has been flushed.
         */
        LinesLayout.prototype.onModelFlushed = function () {
            this.verticalObjects.replaceLines(this.model.getLineCount());
        };
        /**
         * Event handler, call when the model has had lines deleted.
         */
        LinesLayout.prototype.onModelLinesDeleted = function (e) {
            this.verticalObjects.onModelLinesDeleted(e.fromLineNumber, e.toLineNumber);
        };
        /**
         * Event handler, call when the model has had lines inserted.
         */
        LinesLayout.prototype.onModelLinesInserted = function (e) {
            this.verticalObjects.onModelLinesInserted(e.fromLineNumber, e.toLineNumber);
        };
        /**
         * Get the vertical offset (the sum of heights for all objects above) a certain line number.
         *
         * @param lineNumber The line number
         * @return The sum of heights for all objects above `lineNumber`.
         */
        LinesLayout.prototype.getVerticalOffsetForLineNumber = function (lineNumber) {
            return this.verticalObjects.getVerticalOffsetForLineNumber(lineNumber, this._lineHeight);
        };
        LinesLayout.prototype.getLinesTotalHeight = function () {
            return this.verticalObjects.getTotalHeight(this._lineHeight);
        };
        /**
         * Get the sum of heights for all objects and compute basically the `scrollHeight` for the editor content.
         *
         * Take into account the `scrollBeyondLastLine` and `reserveHorizontalScrollbarHeight` and produce a scrollHeight that is at least as large as `viewport`.height.
         *
         * @param viewport The viewport.
         * @param reserveHorizontalScrollbarHeight The height of the horizontal scrollbar.
         * @return Basically, the `scrollHeight` for the editor content.
         */
        LinesLayout.prototype.getTotalHeight = function (viewport, reserveHorizontalScrollbarHeight) {
            var totalLinesHeight = this.getLinesTotalHeight();
            //		if (this.context.configuration.editor.autoSize) {
            //			return linesHeight;
            //		}
            if (this._scrollBeyondLastLine) {
                totalLinesHeight += viewport.height - this._lineHeight;
            }
            else {
                totalLinesHeight += reserveHorizontalScrollbarHeight;
            }
            return Math.max(viewport.height, totalLinesHeight);
        };
        LinesLayout.prototype.isAfterLines = function (verticalOffset) {
            return this.verticalObjects.isAfterLines(verticalOffset, this._lineHeight);
        };
        /**
         * Find the first line number that is at or after vertical offset `verticalOffset`.
         * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then
         * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.
         *
         * @param verticalOffset The vertical offset to search at.
         * @return The line number at or after vertical offset `verticalOffset`.
         */
        LinesLayout.prototype.getLineNumberAtOrAfterVerticalOffset = function (verticalOffset) {
            return this.verticalObjects.getLineNumberAtOrAfterVerticalOffset(verticalOffset, this._lineHeight);
        };
        /**
         * Get the height, in pixels, for line `lineNumber`.
         *
         * @param lineNumber The line number
         * @return The height, in pixels, for line `lineNumber`.
         */
        LinesLayout.prototype.getHeightForLineNumber = function (lineNumber) {
            return this._lineHeight;
        };
        /**
         * Get a list of whitespaces that are positioned inside `viewport`.
         *
         * @param viewport The viewport.
         * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.
         */
        LinesLayout.prototype.getWhitespaceViewportData = function (visibleBox) {
            return this.verticalObjects.getWhitespaceViewportData(visibleBox.top, visibleBox.top + visibleBox.height, this._lineHeight);
        };
        LinesLayout.prototype.getWhitespaces = function () {
            return this.verticalObjects.getWhitespaces(this._lineHeight);
        };
        /**
         * Get exactly the whitespace that is layouted at `verticalOffset`.
         *
         * @param verticalOffset The vertical offset.
         * @return Precisely the whitespace that is layouted at `verticaloffset` or null.
         */
        LinesLayout.prototype.getWhitespaceAtVerticalOffset = function (verticalOffset) {
            return this.verticalObjects.getWhitespaceAtVerticalOffset(verticalOffset, this._lineHeight);
        };
        /**
         * Get all the lines and their relative vertical offsets that are positioned inside `viewport`.
         *
         * @param viewport The viewport.
         * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.
         */
        LinesLayout.prototype.getLinesViewportData = function (visibleBox) {
            var partialData = this.verticalObjects.getLinesViewportData(visibleBox.top, visibleBox.top + visibleBox.height, this._lineHeight);
            var decorationsData = this.model.getDecorationsViewportData(partialData.startLineNumber, partialData.endLineNumber);
            var visibleRange = new range_1.Range(partialData.startLineNumber, 1, partialData.endLineNumber, this.model.getLineMaxColumn(partialData.endLineNumber));
            return new viewLinesViewportData_1.ViewLinesViewportData(partialData, visibleRange, decorationsData);
        };
        /**
         * Get the line that appears visually in the center of `viewport`.
         *
         * @param viewport The viewport.
         * @return The line number that is closest to the center of `viewport`.
         */
        LinesLayout.prototype.getCenteredLineInViewport = function (visibleBox) {
            return this.verticalObjects.getCenteredLineInViewport(visibleBox.top, visibleBox.top + visibleBox.height, this._lineHeight);
        };
        /**
         * Returns the accumulated height of whitespaces before the given line number.
         *
         * @param lineNumber The line number
         */
        LinesLayout.prototype.getWhitespaceAccumulatedHeightBeforeLineNumber = function (lineNumber) {
            return this.verticalObjects.getWhitespaceAccumulatedHeightBeforeLineNumber(lineNumber);
        };
        /**
         * Returns if there is any whitespace in the document.
         */
        LinesLayout.prototype.hasWhitespace = function () {
            return this.verticalObjects.hasWhitespace();
        };
        return LinesLayout;
    }());
    exports.LinesLayout = LinesLayout;
});

define(__m[410], __M([0,1,64]), function (require, exports, viewLineToken_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var FilteredLineTokens = (function () {
        function FilteredLineTokens() {
        }
        /**
         * [startOffset; endOffset) (i.e. do not include endOffset)
         */
        FilteredLineTokens.create = function (original, startOffset, endOffset, deltaStartIndex) {
            var inflatedTokens = original.sliceAndInflate(startOffset, endOffset, deltaStartIndex);
            return new viewLineToken_1.ViewLineTokens(inflatedTokens, deltaStartIndex, endOffset - startOffset + deltaStartIndex);
        };
        return FilteredLineTokens;
    }());
    exports.FilteredLineTokens = FilteredLineTokens;
    var IdentityFilteredLineTokens = (function () {
        function IdentityFilteredLineTokens() {
        }
        IdentityFilteredLineTokens.create = function (original, textLength) {
            var inflatedTokens = original.inflate();
            return new viewLineToken_1.ViewLineTokens(inflatedTokens, 0, textLength);
        };
        return IdentityFilteredLineTokens;
    }());
    exports.IdentityFilteredLineTokens = IdentityFilteredLineTokens;
});

define(__m[80], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var PrefixSumIndexOfResult = (function () {
        function PrefixSumIndexOfResult(index, remainder) {
            this.index = index;
            this.remainder = remainder;
        }
        return PrefixSumIndexOfResult;
    }());
    exports.PrefixSumIndexOfResult = PrefixSumIndexOfResult;
    var PrefixSumComputer = (function () {
        function PrefixSumComputer(values) {
            this.values = values;
            this.prefixSum = [];
            for (var i = 0, len = this.values.length; i < len; i++) {
                this.prefixSum[i] = 0;
            }
            this.prefixSumValidIndex = -1;
        }
        PrefixSumComputer.prototype.getCount = function () {
            return this.values.length;
        };
        PrefixSumComputer.prototype.insertValue = function (insertIndex, value) {
            insertIndex = Math.floor(insertIndex); //@perf
            value = Math.floor(value); //@perf
            this.values.splice(insertIndex, 0, value);
            this.prefixSum.splice(insertIndex, 0, 0);
            if (insertIndex - 1 < this.prefixSumValidIndex) {
                this.prefixSumValidIndex = insertIndex - 1;
            }
        };
        PrefixSumComputer.prototype.insertValues = function (insertIndex, values) {
            insertIndex = Math.floor(insertIndex); //@perf
            if (values.length === 0) {
                return;
            }
            this.values = this.values.slice(0, insertIndex).concat(values).concat(this.values.slice(insertIndex));
            this.prefixSum = this.prefixSum.slice(0, insertIndex).concat(PrefixSumComputer._zeroArray(values.length)).concat(this.prefixSum.slice(insertIndex));
            if (insertIndex - 1 < this.prefixSumValidIndex) {
                this.prefixSumValidIndex = insertIndex - 1;
            }
        };
        PrefixSumComputer._zeroArray = function (count) {
            count = Math.floor(count); //@perf
            var r = [];
            for (var i = 0; i < count; i++) {
                r[i] = 0;
            }
            return r;
        };
        PrefixSumComputer.prototype.changeValue = function (index, value) {
            index = Math.floor(index); //@perf
            value = Math.floor(value); //@perf
            if (this.values[index] === value) {
                return;
            }
            this.values[index] = value;
            if (index - 1 < this.prefixSumValidIndex) {
                this.prefixSumValidIndex = index - 1;
            }
        };
        PrefixSumComputer.prototype.removeValues = function (startIndex, cnt) {
            startIndex = Math.floor(startIndex); //@perf
            cnt = Math.floor(cnt); //@perf
            this.values.splice(startIndex, cnt);
            this.prefixSum.splice(startIndex, cnt);
            if (startIndex - 1 < this.prefixSumValidIndex) {
                this.prefixSumValidIndex = startIndex - 1;
            }
        };
        PrefixSumComputer.prototype.getTotalValue = function () {
            if (this.values.length === 0) {
                return 0;
            }
            return this.getAccumulatedValue(this.values.length - 1);
        };
        PrefixSumComputer.prototype.getAccumulatedValue = function (index) {
            index = Math.floor(index); //@perf
            if (index < 0) {
                return 0;
            }
            if (index <= this.prefixSumValidIndex) {
                return this.prefixSum[index];
            }
            var startIndex = this.prefixSumValidIndex + 1;
            if (startIndex === 0) {
                this.prefixSum[0] = this.values[0];
                startIndex++;
            }
            if (index >= this.values.length) {
                index = this.values.length - 1;
            }
            for (var i = startIndex; i <= index; i++) {
                this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
            }
            this.prefixSumValidIndex = Math.max(this.prefixSumValidIndex, index);
            return this.prefixSum[index];
        };
        PrefixSumComputer.prototype.getIndexOf = function (accumulatedValue) {
            accumulatedValue = Math.floor(accumulatedValue); //@perf
            var low = 0;
            var high = this.values.length - 1;
            var mid;
            var midStop;
            var midStart;
            while (low <= high) {
                mid = low + ((high - low) / 2) | 0;
                midStop = this.getAccumulatedValue(mid);
                midStart = midStop - this.values[mid];
                if (accumulatedValue < midStart) {
                    high = mid - 1;
                }
                else if (accumulatedValue >= midStop) {
                    low = mid + 1;
                }
                else {
                    break;
                }
            }
            return new PrefixSumIndexOfResult(mid, accumulatedValue - midStart);
        };
        return PrefixSumComputer;
    }());
    exports.PrefixSumComputer = PrefixSumComputer;
});

define(__m[419], __M([0,1,80]), function (require, exports, prefixSumComputer_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MirrorModel2 = (function () {
        function MirrorModel2(uri, lines, eol, versionId) {
            this._uri = uri;
            this._lines = lines;
            this._eol = eol;
            this._versionId = versionId;
        }
        MirrorModel2.prototype.dispose = function () {
            this._lines.length = 0;
        };
        Object.defineProperty(MirrorModel2.prototype, "version", {
            get: function () {
                return this._versionId;
            },
            enumerable: true,
            configurable: true
        });
        MirrorModel2.prototype.getText = function () {
            return this._lines.join(this._eol);
        };
        MirrorModel2.prototype.onEvents = function (events) {
            var newEOL = null;
            for (var i = 0, len = events.length; i < len; i++) {
                var e = events[i];
                if (e.eol) {
                    newEOL = e.eol;
                }
            }
            if (newEOL && newEOL !== this._eol) {
                this._eol = newEOL;
                this._lineStarts = null;
            }
            // Update my lines
            var lastVersionId = -1;
            for (var i = 0, len = events.length; i < len; i++) {
                var e = events[i];
                this._acceptDeleteRange(e.range);
                this._acceptInsertText({
                    lineNumber: e.range.startLineNumber,
                    column: e.range.startColumn
                }, e.text);
                lastVersionId = Math.max(lastVersionId, e.versionId);
            }
            if (lastVersionId !== -1) {
                this._versionId = lastVersionId;
            }
        };
        MirrorModel2.prototype._ensureLineStarts = function () {
            if (!this._lineStarts) {
                var lineStartValues = [];
                var eolLength = this._eol.length;
                for (var i = 0, len = this._lines.length; i < len; i++) {
                    lineStartValues.push(this._lines[i].length + eolLength);
                }
                this._lineStarts = new prefixSumComputer_1.PrefixSumComputer(lineStartValues);
            }
        };
        /**
         * All changes to a line's text go through this method
         */
        MirrorModel2.prototype._setLineText = function (lineIndex, newValue) {
            this._lines[lineIndex] = newValue;
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.changeValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
            }
        };
        MirrorModel2.prototype._acceptDeleteRange = function (range) {
            if (range.startLineNumber === range.endLineNumber) {
                if (range.startColumn === range.endColumn) {
                    // Nothing to delete
                    return;
                }
                // Delete text on the affected line
                this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
                    + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
                return;
            }
            // Take remaining text on last line and append it to remaining text on first line
            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
                + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
            // Delete middle lines
            this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
            }
        };
        MirrorModel2.prototype._acceptInsertText = function (position, insertText) {
            if (insertText.length === 0) {
                // Nothing to insert
                return;
            }
            var insertLines = insertText.split(/\r\n|\r|\n/);
            if (insertLines.length === 1) {
                // Inserting text on one line
                this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
                    + insertLines[0]
                    + this._lines[position.lineNumber - 1].substring(position.column - 1));
                return;
            }
            // Append overflowing text from first line to the end of text to insert
            insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
            // Delete overflowing text from first line and insert text on first line
            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
                + insertLines[0]);
            // Insert new lines & store lengths
            var newLengths = new Array(insertLines.length - 1);
            for (var i = 1; i < insertLines.length; i++) {
                this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
                newLengths[i - 1] = insertLines[i].length + this._eol.length;
            }
            if (this._lineStarts) {
                // update prefix sum
                this._lineStarts.insertValues(position.lineNumber, newLengths);
            }
        };
        return MirrorModel2;
    }());
    exports.MirrorModel2 = MirrorModel2;
});

define(__m[146], __M([0,1,21,4,7,410,80]), function (require, exports, position_1, range_1, editorCommon, filteredLineTokens_1, prefixSumComputer_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var OutputPosition = (function () {
        function OutputPosition(outputLineIndex, outputOffset) {
            this.outputLineIndex = outputLineIndex;
            this.outputOffset = outputOffset;
        }
        return OutputPosition;
    }());
    exports.OutputPosition = OutputPosition;
    var IdentitySplitLine = (function () {
        function IdentitySplitLine(isVisible) {
            this._isVisible = isVisible;
        }
        IdentitySplitLine.prototype.isVisible = function () {
            return this._isVisible;
        };
        IdentitySplitLine.prototype.setVisible = function (isVisible) {
            this._isVisible = isVisible;
        };
        IdentitySplitLine.prototype.getOutputLineCount = function () {
            if (!this._isVisible) {
                return 0;
            }
            return 1;
        };
        IdentitySplitLine.prototype.getOutputLineContent = function (model, myLineNumber, outputLineIndex) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            return model.getLineContent(myLineNumber);
        };
        IdentitySplitLine.prototype.getOutputLineMinColumn = function (model, myLineNumber, outputLineIndex) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            return model.getLineMinColumn(myLineNumber);
        };
        IdentitySplitLine.prototype.getOutputLineMaxColumn = function (model, myLineNumber, outputLineIndex) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            return model.getLineMaxColumn(myLineNumber);
        };
        IdentitySplitLine.prototype.getOutputLineTokens = function (model, myLineNumber, outputLineIndex) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            return filteredLineTokens_1.IdentityFilteredLineTokens.create(model.getLineTokens(myLineNumber, true), model.getLineMaxColumn(myLineNumber) - 1);
        };
        IdentitySplitLine.prototype.getInputColumnOfOutputPosition = function (outputLineIndex, outputColumn) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            return outputColumn;
        };
        IdentitySplitLine.prototype.getOutputPositionOfInputPosition = function (deltaLineNumber, inputColumn) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            return new position_1.Position(deltaLineNumber, inputColumn);
        };
        return IdentitySplitLine;
    }());
    var SplitLine = (function () {
        function SplitLine(positionMapper, isVisible) {
            this.positionMapper = positionMapper;
            this.wrappedIndent = this.positionMapper.getWrappedLinesIndent();
            this.wrappedIndentLength = this.wrappedIndent.length;
            this.outputLineCount = this.positionMapper.getOutputLineCount();
            this._isVisible = isVisible;
        }
        SplitLine.prototype.isVisible = function () {
            return this._isVisible;
        };
        SplitLine.prototype.setVisible = function (isVisible) {
            this._isVisible = isVisible;
        };
        SplitLine.prototype.getOutputLineCount = function () {
            if (!this._isVisible) {
                return 0;
            }
            return this.outputLineCount;
        };
        SplitLine.prototype.getInputStartOffsetOfOutputLineIndex = function (outputLineIndex) {
            return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex, 0);
        };
        SplitLine.prototype.getInputEndOffsetOfOutputLineIndex = function (model, myLineNumber, outputLineIndex) {
            if (outputLineIndex + 1 === this.outputLineCount) {
                return model.getLineMaxColumn(myLineNumber) - 1;
            }
            return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex + 1, 0);
        };
        SplitLine.prototype.getOutputLineContent = function (model, myLineNumber, outputLineIndex) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            var startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);
            var endOffset = this.getInputEndOffsetOfOutputLineIndex(model, myLineNumber, outputLineIndex);
            var r = model.getLineContent(myLineNumber).substring(startOffset, endOffset);
            if (outputLineIndex > 0) {
                r = this.wrappedIndent + r;
            }
            return r;
        };
        SplitLine.prototype.getOutputLineMinColumn = function (model, myLineNumber, outputLineIndex) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            if (outputLineIndex > 0) {
                return this.wrappedIndentLength + 1;
            }
            return 1;
        };
        SplitLine.prototype.getOutputLineMaxColumn = function (model, myLineNumber, outputLineIndex) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            return this.getOutputLineContent(model, myLineNumber, outputLineIndex).length + 1;
        };
        SplitLine.prototype.getOutputLineTokens = function (model, myLineNumber, outputLineIndex) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            var startOffset = this.getInputStartOffsetOfOutputLineIndex(outputLineIndex);
            var endOffset = this.getInputEndOffsetOfOutputLineIndex(model, myLineNumber, outputLineIndex);
            var deltaStartIndex = 0;
            if (outputLineIndex > 0) {
                deltaStartIndex = this.wrappedIndentLength;
            }
            return filteredLineTokens_1.FilteredLineTokens.create(model.getLineTokens(myLineNumber, true), startOffset, endOffset, deltaStartIndex);
        };
        SplitLine.prototype.getInputColumnOfOutputPosition = function (outputLineIndex, outputColumn) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            var adjustedColumn = outputColumn - 1;
            if (outputLineIndex > 0) {
                if (adjustedColumn < this.wrappedIndentLength) {
                    adjustedColumn = 0;
                }
                else {
                    adjustedColumn -= this.wrappedIndentLength;
                }
            }
            return this.positionMapper.getInputOffsetOfOutputPosition(outputLineIndex, adjustedColumn) + 1;
        };
        SplitLine.prototype.getOutputPositionOfInputPosition = function (deltaLineNumber, inputColumn) {
            if (!this._isVisible) {
                throw new Error('Not supported');
            }
            var r = this.positionMapper.getOutputPositionOfInputOffset(inputColumn - 1);
            var outputLineIndex = r.outputLineIndex;
            var outputColumn = r.outputOffset + 1;
            if (outputLineIndex > 0) {
                outputColumn += this.wrappedIndentLength;
            }
            //		console.log('in -> out ' + deltaLineNumber + ',' + inputColumn + ' ===> ' + (deltaLineNumber+outputLineIndex) + ',' + outputColumn);
            return new position_1.Position(deltaLineNumber + outputLineIndex, outputColumn);
        };
        return SplitLine;
    }());
    exports.SplitLine = SplitLine;
    function createSplitLine(linePositionMapperFactory, text, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent, isVisible) {
        var positionMapper = linePositionMapperFactory.createLineMapping(text, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent);
        if (positionMapper === null) {
            // No mapping needed
            return new IdentitySplitLine(isVisible);
        }
        else {
            return new SplitLine(positionMapper, isVisible);
        }
    }
    var SplitLinesCollection = (function () {
        function SplitLinesCollection(model, linePositionMapperFactory, tabSize, wrappingColumn, columnsForFullWidthChar, wrappingIndent) {
            this.model = model;
            this._validModelVersionId = -1;
            this.tabSize = tabSize;
            this.wrappingColumn = wrappingColumn;
            this.columnsForFullWidthChar = columnsForFullWidthChar;
            this.wrappingIndent = wrappingIndent;
            this.linePositionMapperFactory = linePositionMapperFactory;
            this._constructLines(true);
        }
        SplitLinesCollection.prototype.dispose = function () {
            this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, []);
        };
        SplitLinesCollection.prototype._ensureValidState = function () {
            var modelVersion = this.model.getVersionId();
            if (modelVersion !== this._validModelVersionId) {
                throw new Error('SplitLinesCollection: attempt to access a \'newer\' model');
            }
        };
        SplitLinesCollection.prototype._constructLines = function (resetHiddenAreas) {
            var _this = this;
            this.lines = [];
            if (resetHiddenAreas) {
                this.hiddenAreasIds = [];
            }
            var values = [];
            var linesContent = this.model.getLinesContent();
            var lineCount = linesContent.length;
            var hiddenAreas = this.hiddenAreasIds.map(function (areaId) { return _this.model.getDecorationRange(areaId); }).sort(range_1.Range.compareRangesUsingStarts);
            var hiddenAreaStart = 1, hiddenAreaEnd = 0;
            var hiddenAreaIdx = -1;
            var nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;
            for (var i = 0; i < lineCount; i++) {
                var lineNumber = i + 1;
                if (lineNumber === nextLineNumberToUpdateHiddenArea) {
                    hiddenAreaIdx++;
                    hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;
                    hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;
                    nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : lineCount + 2;
                }
                var isInHiddenArea = (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd);
                var line = createSplitLine(this.linePositionMapperFactory, linesContent[i], this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, !isInHiddenArea);
                values[i] = line.getOutputLineCount();
                this.lines[i] = line;
            }
            this._validModelVersionId = this.model.getVersionId();
            this.prefixSumComputer = new prefixSumComputer_1.PrefixSumComputer(values);
        };
        SplitLinesCollection.prototype.getHiddenAreas = function () {
            var _this = this;
            return this.hiddenAreasIds.map(function (decId) {
                return _this.model.getDecorationRange(decId);
            }).sort(range_1.Range.compareRangesUsingStarts);
        };
        SplitLinesCollection.prototype._reduceRanges = function (_ranges) {
            var _this = this;
            if (_ranges.length === 0) {
                return [];
            }
            var ranges = _ranges.map(function (r) { return _this.model.validateRange(r); }).sort(range_1.Range.compareRangesUsingStarts);
            var result = [];
            var currentRangeStart = ranges[0].startLineNumber;
            var currentRangeEnd = ranges[0].endLineNumber;
            for (var i = 1, len = ranges.length; i < len; i++) {
                var range = ranges[i];
                if (range.startLineNumber > currentRangeEnd + 1) {
                    result.push(new range_1.Range(currentRangeStart, 1, currentRangeEnd, 1));
                    currentRangeStart = range.startLineNumber;
                    currentRangeEnd = range.endLineNumber;
                }
                else if (range.endLineNumber > currentRangeEnd) {
                    currentRangeEnd = range.endLineNumber;
                }
            }
            result.push(new range_1.Range(currentRangeStart, 1, currentRangeEnd, 1));
            return result;
        };
        SplitLinesCollection.prototype.setHiddenAreas = function (_ranges, emit) {
            var _this = this;
            var newRanges = this._reduceRanges(_ranges);
            // BEGIN TODO@Martin: Please stop calling this method on each model change!
            var oldRanges = this.hiddenAreasIds.map(function (areaId) { return _this.model.getDecorationRange(areaId); }).sort(range_1.Range.compareRangesUsingStarts);
            if (newRanges.length === oldRanges.length) {
                var hasDifference = false;
                for (var i = 0; i < newRanges.length; i++) {
                    if (!newRanges[i].equalsRange(oldRanges[i])) {
                        hasDifference = true;
                        break;
                    }
                }
                if (!hasDifference) {
                    return false;
                }
            }
            // END TODO@Martin: Please stop calling this method on each model change!
            var newDecorations = [];
            for (var i = 0; i < newRanges.length; i++) {
                newDecorations.push({
                    range: newRanges[i],
                    options: {}
                });
            }
            this.hiddenAreasIds = this.model.deltaDecorations(this.hiddenAreasIds, newDecorations);
            var hiddenAreas = newRanges;
            var hiddenAreaStart = 1, hiddenAreaEnd = 0;
            var hiddenAreaIdx = -1;
            var nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;
            for (var i = 0; i < this.lines.length; i++) {
                var lineNumber = i + 1;
                if (lineNumber === nextLineNumberToUpdateHiddenArea) {
                    hiddenAreaIdx++;
                    hiddenAreaStart = hiddenAreas[hiddenAreaIdx].startLineNumber;
                    hiddenAreaEnd = hiddenAreas[hiddenAreaIdx].endLineNumber;
                    nextLineNumberToUpdateHiddenArea = (hiddenAreaIdx + 1 < hiddenAreas.length) ? hiddenAreaEnd + 1 : this.lines.length + 2;
                }
                var lineChanged = false;
                if (lineNumber >= hiddenAreaStart && lineNumber <= hiddenAreaEnd) {
                    // Line should be hidden
                    if (this.lines[i].isVisible()) {
                        this.lines[i].setVisible(false);
                        lineChanged = true;
                    }
                }
                else {
                    // Line should be visible
                    if (!this.lines[i].isVisible()) {
                        this.lines[i].setVisible(true);
                        lineChanged = true;
                    }
                }
                if (lineChanged) {
                    var newOutputLineCount = this.lines[i].getOutputLineCount();
                    this.prefixSumComputer.changeValue(i, newOutputLineCount);
                }
            }
            emit(editorCommon.ViewEventNames.ModelFlushedEvent, null);
            return true;
        };
        SplitLinesCollection.prototype.inputPositionIsVisible = function (inputLineNumber, inputColumn) {
            if (inputLineNumber < 1 || inputLineNumber > this.lines.length) {
                // invalid arguments
                return false;
            }
            return this.lines[inputLineNumber - 1].isVisible();
        };
        SplitLinesCollection.prototype.setTabSize = function (newTabSize, emit) {
            if (this.tabSize === newTabSize) {
                return false;
            }
            this.tabSize = newTabSize;
            this._constructLines(false);
            emit(editorCommon.ViewEventNames.ModelFlushedEvent, null);
            return true;
        };
        SplitLinesCollection.prototype.setWrappingIndent = function (newWrappingIndent, emit) {
            if (this.wrappingIndent === newWrappingIndent) {
                return false;
            }
            this.wrappingIndent = newWrappingIndent;
            this._constructLines(false);
            emit(editorCommon.ViewEventNames.ModelFlushedEvent, null);
            return true;
        };
        SplitLinesCollection.prototype.setWrappingColumn = function (newWrappingColumn, columnsForFullWidthChar, emit) {
            if (this.wrappingColumn === newWrappingColumn && this.columnsForFullWidthChar === columnsForFullWidthChar) {
                return false;
            }
            this.wrappingColumn = newWrappingColumn;
            this.columnsForFullWidthChar = columnsForFullWidthChar;
            this._constructLines(false);
            emit(editorCommon.ViewEventNames.ModelFlushedEvent, null);
            return true;
        };
        SplitLinesCollection.prototype.onModelFlushed = function (versionId, emit) {
            this._constructLines(true);
            emit(editorCommon.ViewEventNames.ModelFlushedEvent, null);
        };
        SplitLinesCollection.prototype.onModelLinesDeleted = function (versionId, fromLineNumber, toLineNumber, emit) {
            if (versionId <= this._validModelVersionId) {
                return;
            }
            this._validModelVersionId = versionId;
            var outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);
            var outputToLineNumber = this.prefixSumComputer.getAccumulatedValue(toLineNumber - 1);
            this.lines.splice(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);
            this.prefixSumComputer.removeValues(fromLineNumber - 1, toLineNumber - fromLineNumber + 1);
            var e = {
                fromLineNumber: outputFromLineNumber,
                toLineNumber: outputToLineNumber
            };
            emit(editorCommon.ViewEventNames.LinesDeletedEvent, e);
        };
        SplitLinesCollection.prototype.onModelLinesInserted = function (versionId, fromLineNumber, toLineNumber, text, emit) {
            if (versionId <= this._validModelVersionId) {
                return;
            }
            this._validModelVersionId = versionId;
            var hiddenAreas = this.getHiddenAreas();
            var isInHiddenArea = false;
            var testPosition = new position_1.Position(fromLineNumber, 1);
            for (var i = 0; i < hiddenAreas.length; i++) {
                if (hiddenAreas[i].containsPosition(testPosition)) {
                    isInHiddenArea = true;
                    break;
                }
            }
            var outputFromLineNumber = (fromLineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(fromLineNumber - 2) + 1);
            var totalOutputLineCount = 0;
            var insertLines = [];
            var insertPrefixSumValues = [];
            for (var i = 0, len = text.length; i < len; i++) {
                var line = createSplitLine(this.linePositionMapperFactory, text[i], this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, !isInHiddenArea);
                insertLines.push(line);
                var outputLineCount = line.getOutputLineCount();
                totalOutputLineCount += outputLineCount;
                insertPrefixSumValues.push(outputLineCount);
            }
            this.lines = this.lines.slice(0, fromLineNumber - 1).concat(insertLines).concat(this.lines.slice(fromLineNumber - 1));
            this.prefixSumComputer.insertValues(fromLineNumber - 1, insertPrefixSumValues);
            var e = {
                fromLineNumber: outputFromLineNumber,
                toLineNumber: outputFromLineNumber + totalOutputLineCount - 1
            };
            emit(editorCommon.ViewEventNames.LinesInsertedEvent, e);
        };
        SplitLinesCollection.prototype.onModelLineChanged = function (versionId, lineNumber, newText, emit) {
            if (versionId <= this._validModelVersionId) {
                return;
            }
            this._validModelVersionId = versionId;
            var lineIndex = lineNumber - 1;
            var oldOutputLineCount = this.lines[lineIndex].getOutputLineCount();
            var isVisible = this.lines[lineIndex].isVisible();
            var line = createSplitLine(this.linePositionMapperFactory, newText, this.tabSize, this.wrappingColumn, this.columnsForFullWidthChar, this.wrappingIndent, isVisible);
            this.lines[lineIndex] = line;
            var newOutputLineCount = this.lines[lineIndex].getOutputLineCount();
            var lineMappingChanged = false;
            var changeFrom = 0;
            var changeTo = -1;
            var insertFrom = 0;
            var insertTo = -1;
            var deleteFrom = 0;
            var deleteTo = -1;
            if (oldOutputLineCount > newOutputLineCount) {
                changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);
                changeTo = changeFrom + newOutputLineCount - 1;
                deleteFrom = changeTo + 1;
                deleteTo = deleteFrom + (oldOutputLineCount - newOutputLineCount) - 1;
                lineMappingChanged = true;
            }
            else if (oldOutputLineCount < newOutputLineCount) {
                changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);
                changeTo = changeFrom + oldOutputLineCount - 1;
                insertFrom = changeTo + 1;
                insertTo = insertFrom + (newOutputLineCount - oldOutputLineCount) - 1;
                lineMappingChanged = true;
            }
            else {
                changeFrom = (lineNumber === 1 ? 1 : this.prefixSumComputer.getAccumulatedValue(lineNumber - 2) + 1);
                changeTo = changeFrom + newOutputLineCount - 1;
            }
            this.prefixSumComputer.changeValue(lineIndex, newOutputLineCount);
            var e1;
            var e2;
            var e3;
            if (changeFrom <= changeTo) {
                for (var i = changeFrom; i <= changeTo; i++) {
                    e1 = {
                        lineNumber: i
                    };
                    emit(editorCommon.ViewEventNames.LineChangedEvent, e1);
                }
            }
            if (insertFrom <= insertTo) {
                e2 = {
                    fromLineNumber: insertFrom,
                    toLineNumber: insertTo
                };
                emit(editorCommon.ViewEventNames.LinesInsertedEvent, e2);
            }
            if (deleteFrom <= deleteTo) {
                e3 = {
                    fromLineNumber: deleteFrom,
                    toLineNumber: deleteTo
                };
                emit(editorCommon.ViewEventNames.LinesDeletedEvent, e3);
            }
            return lineMappingChanged;
        };
        SplitLinesCollection.prototype.getOutputLineCount = function () {
            this._ensureValidState();
            return this.prefixSumComputer.getTotalValue();
        };
        SplitLinesCollection.prototype._toValidOutputLineNumber = function (outputLineNumber) {
            if (outputLineNumber < 1) {
                return 1;
            }
            var outputLineCount = this.getOutputLineCount();
            if (outputLineNumber > outputLineCount) {
                return outputLineCount;
            }
            return outputLineNumber;
        };
        SplitLinesCollection.prototype.getOutputLineContent = function (outputLineNumber) {
            this._ensureValidState();
            outputLineNumber = this._toValidOutputLineNumber(outputLineNumber);
            var r = this.prefixSumComputer.getIndexOf(outputLineNumber - 1);
            var lineIndex = r.index;
            var remainder = r.remainder;
            return this.lines[lineIndex].getOutputLineContent(this.model, lineIndex + 1, remainder);
        };
        SplitLinesCollection.prototype.getOutputLineMinColumn = function (outputLineNumber) {
            this._ensureValidState();
            outputLineNumber = this._toValidOutputLineNumber(outputLineNumber);
            var r = this.prefixSumComputer.getIndexOf(outputLineNumber - 1);
            var lineIndex = r.index;
            var remainder = r.remainder;
            return this.lines[lineIndex].getOutputLineMinColumn(this.model, lineIndex + 1, remainder);
        };
        SplitLinesCollection.prototype.getOutputLineMaxColumn = function (outputLineNumber) {
            this._ensureValidState();
            outputLineNumber = this._toValidOutputLineNumber(outputLineNumber);
            var r = this.prefixSumComputer.getIndexOf(outputLineNumber - 1);
            var lineIndex = r.index;
            var remainder = r.remainder;
            return this.lines[lineIndex].getOutputLineMaxColumn(this.model, lineIndex + 1, remainder);
        };
        SplitLinesCollection.prototype.getOutputLineTokens = function (outputLineNumber) {
            this._ensureValidState();
            outputLineNumber = this._toValidOutputLineNumber(outputLineNumber);
            var r = this.prefixSumComputer.getIndexOf(outputLineNumber - 1);
            var lineIndex = r.index;
            var remainder = r.remainder;
            return this.lines[lineIndex].getOutputLineTokens(this.model, lineIndex + 1, remainder);
        };
        SplitLinesCollection.prototype.convertOutputPositionToInputPosition = function (viewLineNumber, viewColumn) {
            this._ensureValidState();
            viewLineNumber = this._toValidOutputLineNumber(viewLineNumber);
            var r = this.prefixSumComputer.getIndexOf(viewLineNumber - 1);
            var lineIndex = r.index;
            var remainder = r.remainder;
            var inputColumn = this.lines[lineIndex].getInputColumnOfOutputPosition(remainder, viewColumn);
            // console.log('out -> in ' + viewLineNumber + ',' + viewColumn + ' ===> ' + (lineIndex+1) + ',' + inputColumn);
            return this.model.validatePosition(new position_1.Position(lineIndex + 1, inputColumn));
        };
        SplitLinesCollection.prototype.convertInputPositionToOutputPosition = function (_inputLineNumber, _inputColumn) {
            this._ensureValidState();
            var validPosition = this.model.validatePosition(new position_1.Position(_inputLineNumber, _inputColumn));
            var inputLineNumber = validPosition.lineNumber;
            var inputColumn = validPosition.column;
            var lineIndex = inputLineNumber - 1, lineIndexChanged = false;
            while (lineIndex > 0 && !this.lines[lineIndex].isVisible()) {
                lineIndex--;
                lineIndexChanged = true;
            }
            if (lineIndex === 0 && !this.lines[lineIndex].isVisible()) {
                // Could not reach a real line
                // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + 1 + ',' + 1);
                return new position_1.Position(1, 1);
            }
            var deltaLineNumber = 1 + (lineIndex === 0 ? 0 : this.prefixSumComputer.getAccumulatedValue(lineIndex - 1));
            var r;
            if (lineIndexChanged) {
                r = this.lines[lineIndex].getOutputPositionOfInputPosition(deltaLineNumber, this.model.getLineMaxColumn(lineIndex + 1));
            }
            else {
                r = this.lines[inputLineNumber - 1].getOutputPositionOfInputPosition(deltaLineNumber, inputColumn);
            }
            // console.log('in -> out ' + inputLineNumber + ',' + inputColumn + ' ===> ' + r.lineNumber + ',' + r);
            return r;
        };
        return SplitLinesCollection;
    }());
    exports.SplitLinesCollection = SplitLinesCollection;
});

define(__m[421], __M([0,1,10,7,80,146]), function (require, exports, strings, editorCommon_1, prefixSumComputer_1, splitLinesCollection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CharacterClass;
    (function (CharacterClass) {
        CharacterClass[CharacterClass["NONE"] = 0] = "NONE";
        CharacterClass[CharacterClass["BREAK_BEFORE"] = 1] = "BREAK_BEFORE";
        CharacterClass[CharacterClass["BREAK_AFTER"] = 2] = "BREAK_AFTER";
        CharacterClass[CharacterClass["BREAK_OBTRUSIVE"] = 3] = "BREAK_OBTRUSIVE";
        CharacterClass[CharacterClass["BREAK_IDEOGRAPHIC"] = 4] = "BREAK_IDEOGRAPHIC"; // for Han and Kana.
    })(CharacterClass || (CharacterClass = {}));
    var CharacterClassifier = (function () {
        function CharacterClassifier(BREAK_BEFORE, BREAK_AFTER, BREAK_OBTRUSIVE) {
            this._asciiMap = [];
            for (var i = 0; i < 256; i++) {
                this._asciiMap[i] = CharacterClass.NONE;
            }
            this._map = [];
            for (var i = 0; i < BREAK_BEFORE.length; i++) {
                this._set(BREAK_BEFORE.charCodeAt(i), CharacterClass.BREAK_BEFORE);
            }
            for (var i = 0; i < BREAK_AFTER.length; i++) {
                this._set(BREAK_AFTER.charCodeAt(i), CharacterClass.BREAK_AFTER);
            }
            for (var i = 0; i < BREAK_OBTRUSIVE.length; i++) {
                this._set(BREAK_OBTRUSIVE.charCodeAt(i), CharacterClass.BREAK_OBTRUSIVE);
            }
        }
        CharacterClassifier.prototype._set = function (charCode, charClass) {
            if (charCode < 256) {
                this._asciiMap[charCode] = charClass;
            }
            this._map[charCode] = charClass;
        };
        CharacterClassifier.prototype.classify = function (charCode) {
            if (charCode < 256) {
                return this._asciiMap[charCode];
            }
            var charClass = this._map[charCode];
            if (charClass) {
                return charClass;
            }
            // Initialize CharacterClass.BREAK_IDEOGRAPHIC for these Unicode ranges:
            // 1. CJK Unified Ideographs (0x4E00 -- 0x9FFF)
            // 2. CJK Unified Ideographs Extension A (0x3400 -- 0x4DBF)
            // 3. Hiragana and Katakana (0x3040 -- 0x30FF)
            if ((charCode >= 0x3040 && charCode <= 0x30FF)
                || (charCode >= 0x3400 && charCode <= 0x4DBF)
                || (charCode >= 0x4E00 && charCode <= 0x9FFF)) {
                return CharacterClass.BREAK_IDEOGRAPHIC;
            }
            return CharacterClass.NONE;
        };
        return CharacterClassifier;
    }());
    var CharacterHardWrappingLineMapperFactory = (function () {
        function CharacterHardWrappingLineMapperFactory(breakBeforeChars, breakAfterChars, breakObtrusiveChars) {
            this.classifier = new CharacterClassifier(breakBeforeChars, breakAfterChars, breakObtrusiveChars);
        }
        // TODO@Alex -> duplicated in lineCommentCommand
        CharacterHardWrappingLineMapperFactory.nextVisibleColumn = function (currentVisibleColumn, tabSize, isTab, columnSize) {
            currentVisibleColumn = +currentVisibleColumn; //@perf
            tabSize = +tabSize; //@perf
            columnSize = +columnSize; //@perf
            if (isTab) {
                return currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));
            }
            return currentVisibleColumn + columnSize;
        };
        CharacterHardWrappingLineMapperFactory.prototype.createLineMapping = function (lineText, tabSize, breakingColumn, columnsForFullWidthChar, hardWrappingIndent) {
            if (breakingColumn === -1) {
                return null;
            }
            tabSize = +tabSize; //@perf
            breakingColumn = +breakingColumn; //@perf
            columnsForFullWidthChar = +columnsForFullWidthChar; //@perf
            hardWrappingIndent = +hardWrappingIndent; //@perf
            var wrappedTextIndentVisibleColumn = 0;
            var wrappedTextIndent = '';
            var TAB_CHAR_CODE = '\t'.charCodeAt(0);
            var firstNonWhitespaceIndex = -1;
            if (hardWrappingIndent !== editorCommon_1.WrappingIndent.None) {
                firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineText);
                if (firstNonWhitespaceIndex !== -1) {
                    wrappedTextIndent = lineText.substring(0, firstNonWhitespaceIndex);
                    for (var i = 0; i < firstNonWhitespaceIndex; i++) {
                        wrappedTextIndentVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(wrappedTextIndentVisibleColumn, tabSize, lineText.charCodeAt(i) === TAB_CHAR_CODE, 1);
                    }
                    if (hardWrappingIndent === editorCommon_1.WrappingIndent.Indent) {
                        wrappedTextIndent += '\t';
                        wrappedTextIndentVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(wrappedTextIndentVisibleColumn, tabSize, true, 1);
                    }
                    // Force sticking to beginning of line if indentColumn > 66% breakingColumn
                    if (wrappedTextIndentVisibleColumn > 1 / 2 * breakingColumn) {
                        wrappedTextIndent = '';
                        wrappedTextIndentVisibleColumn = 0;
                    }
                }
            }
            var classifier = this.classifier;
            var lastBreakingOffset = 0; // Last 0-based offset in the lineText at which a break happened
            var breakingLengths = []; // The length of each broken-up line text
            var breakingLengthsIndex = 0; // The count of breaks already done
            var visibleColumn = 0; // Visible column since the beginning of the current line
            var breakBeforeOffset; // 0-based offset in the lineText before which breaking
            var restoreVisibleColumnFrom;
            var niceBreakOffset = -1; // Last index of a character that indicates a break should happen before it (more desirable)
            var niceBreakVisibleColumn = 0; // visible column if a break were to be later introduced before `niceBreakOffset`
            var obtrusiveBreakOffset = -1; // Last index of a character that indicates a break should happen before it (less desirable)
            var obtrusiveBreakVisibleColumn = 0; // visible column if a break were to be later introduced before `obtrusiveBreakOffset`
            var len = lineText.length;
            for (var i = 0; i < len; i++) {
                // At this point, there is a certainty that the character before `i` fits on the current line,
                // but the character at `i` might not fit
                var charCode = lineText.charCodeAt(i);
                var charCodeIsTab = (charCode === TAB_CHAR_CODE);
                var charCodeClass = classifier.classify(charCode);
                if (charCodeClass === CharacterClass.BREAK_BEFORE) {
                    // This is a character that indicates that a break should happen before it
                    // Since we are certain the character before `i` fits, there's no extra checking needed,
                    // just mark it as a nice breaking opportunity
                    niceBreakOffset = i;
                    niceBreakVisibleColumn = 0;
                }
                // CJK breaking : before break
                if (charCodeClass === CharacterClass.BREAK_IDEOGRAPHIC && i > 0) {
                    var prevCode = lineText.charCodeAt(i - 1);
                    var prevClass = classifier.classify(prevCode);
                    if (prevClass !== CharacterClass.BREAK_BEFORE) {
                        niceBreakOffset = i;
                        niceBreakVisibleColumn = 0;
                    }
                }
                var charColumnSize = 1;
                if (strings.isFullWidthCharacter(charCode)) {
                    charColumnSize = columnsForFullWidthChar;
                }
                // Advance visibleColumn with character at `i`
                visibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(visibleColumn, tabSize, charCodeIsTab, charColumnSize);
                if (visibleColumn > breakingColumn && i !== 0) {
                    // We need to break at least before character at `i`:
                    //  - break before niceBreakLastOffset if it exists (and re-establish a correct visibleColumn by using niceBreakVisibleColumn + charAt(i))
                    //  - otherwise, break before obtrusiveBreakLastOffset if it exists (and re-establish a correct visibleColumn by using obtrusiveBreakVisibleColumn + charAt(i))
                    //  - otherwise, break before i (and re-establish a correct visibleColumn by charAt(i))
                    if (niceBreakOffset !== -1) {
                        // We will break before `niceBreakLastOffset`
                        breakBeforeOffset = niceBreakOffset;
                        restoreVisibleColumnFrom = niceBreakVisibleColumn;
                    }
                    else if (obtrusiveBreakOffset !== -1) {
                        // We will break before `obtrusiveBreakLastOffset`
                        breakBeforeOffset = obtrusiveBreakOffset;
                        restoreVisibleColumnFrom = obtrusiveBreakVisibleColumn;
                    }
                    else {
                        // We will break before `i`
                        breakBeforeOffset = i;
                        restoreVisibleColumnFrom = wrappedTextIndentVisibleColumn;
                    }
                    // Break before character at `breakBeforeOffset`
                    breakingLengths[breakingLengthsIndex++] = breakBeforeOffset - lastBreakingOffset;
                    lastBreakingOffset = breakBeforeOffset;
                    // Re-establish visibleColumn by taking character at `i` into account
                    visibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(restoreVisibleColumnFrom, tabSize, charCodeIsTab, charColumnSize);
                    // Reset markers
                    niceBreakOffset = -1;
                    niceBreakVisibleColumn = 0;
                    obtrusiveBreakOffset = -1;
                    obtrusiveBreakVisibleColumn = 0;
                }
                // At this point, there is a certainty that the character at `i` fits on the current line
                if (niceBreakOffset !== -1) {
                    // Advance niceBreakVisibleColumn
                    niceBreakVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(niceBreakVisibleColumn, tabSize, charCodeIsTab, charColumnSize);
                }
                if (obtrusiveBreakOffset !== -1) {
                    // Advance obtrusiveBreakVisibleColumn
                    obtrusiveBreakVisibleColumn = CharacterHardWrappingLineMapperFactory.nextVisibleColumn(obtrusiveBreakVisibleColumn, tabSize, charCodeIsTab, charColumnSize);
                }
                if (charCodeClass === CharacterClass.BREAK_AFTER && (hardWrappingIndent === editorCommon_1.WrappingIndent.None || i >= firstNonWhitespaceIndex)) {
                    // This is a character that indicates that a break should happen after it
                    niceBreakOffset = i + 1;
                    niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;
                }
                // CJK breaking : after break
                if (charCodeClass === CharacterClass.BREAK_IDEOGRAPHIC && i < len - 1) {
                    var nextCode = lineText.charCodeAt(i + 1);
                    var nextClass = classifier.classify(nextCode);
                    if (nextClass !== CharacterClass.BREAK_AFTER) {
                        niceBreakOffset = i + 1;
                        niceBreakVisibleColumn = wrappedTextIndentVisibleColumn;
                    }
                }
                if (charCodeClass === CharacterClass.BREAK_OBTRUSIVE) {
                    // This is an obtrusive character that indicates that a break should happen after it
                    obtrusiveBreakOffset = i + 1;
                    obtrusiveBreakVisibleColumn = wrappedTextIndentVisibleColumn;
                }
            }
            if (breakingLengthsIndex === 0) {
                return null;
            }
            // Add last segment
            breakingLengths[breakingLengthsIndex++] = len - lastBreakingOffset;
            return new CharacterHardWrappingLineMapping(new prefixSumComputer_1.PrefixSumComputer(breakingLengths), wrappedTextIndent);
        };
        return CharacterHardWrappingLineMapperFactory;
    }());
    exports.CharacterHardWrappingLineMapperFactory = CharacterHardWrappingLineMapperFactory;
    var CharacterHardWrappingLineMapping = (function () {
        function CharacterHardWrappingLineMapping(prefixSums, wrappedLinesIndent) {
            this._prefixSums = prefixSums;
            this._wrappedLinesIndent = wrappedLinesIndent;
        }
        CharacterHardWrappingLineMapping.prototype.getOutputLineCount = function () {
            return this._prefixSums.getCount();
        };
        CharacterHardWrappingLineMapping.prototype.getWrappedLinesIndent = function () {
            return this._wrappedLinesIndent;
        };
        CharacterHardWrappingLineMapping.prototype.getInputOffsetOfOutputPosition = function (outputLineIndex, outputOffset) {
            if (outputLineIndex === 0) {
                return outputOffset;
            }
            else {
                return this._prefixSums.getAccumulatedValue(outputLineIndex - 1) + outputOffset;
            }
        };
        CharacterHardWrappingLineMapping.prototype.getOutputPositionOfInputOffset = function (inputOffset) {
            var r = this._prefixSums.getIndexOf(inputOffset);
            return new splitLinesCollection_1.OutputPosition(r.index, r.remainder);
        };
        return CharacterHardWrappingLineMapping;
    }());
    exports.CharacterHardWrappingLineMapping = CharacterHardWrappingLineMapping;
});

define(__m[53], __M([0,1,7]), function (require, exports, editorCommon) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewEventHandler = (function () {
        function ViewEventHandler() {
            this._shouldRender = true;
        }
        ViewEventHandler.prototype.shouldRender = function () {
            return this._shouldRender;
        };
        ViewEventHandler.prototype.setShouldRender = function () {
            this._shouldRender = true;
        };
        ViewEventHandler.prototype.onDidRender = function () {
            this._shouldRender = false;
        };
        // --- begin event handlers
        ViewEventHandler.prototype.onLineMappingChanged = function () {
            return false;
        };
        ViewEventHandler.prototype.onModelFlushed = function () {
            return false;
        };
        ViewEventHandler.prototype.onModelDecorationsChanged = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onModelLinesDeleted = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onModelLineChanged = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onModelLinesInserted = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onModelTokensChanged = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onCursorPositionChanged = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onCursorSelectionChanged = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onCursorRevealRange = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onCursorScrollRequest = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onConfigurationChanged = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onLayoutChanged = function (layoutInfo) {
            return false;
        };
        ViewEventHandler.prototype.onScrollChanged = function (e) {
            return false;
        };
        ViewEventHandler.prototype.onZonesChanged = function () {
            return false;
        };
        ViewEventHandler.prototype.onViewFocusChanged = function (isFocused) {
            return false;
        };
        // --- end event handlers
        ViewEventHandler.prototype.handleEvents = function (events) {
            var shouldRender = false;
            for (var i = 0, len = events.length; i < len; i++) {
                var e = events[i];
                var data = e.getData();
                switch (e.getType()) {
                    case editorCommon.ViewEventNames.LineMappingChangedEvent:
                        if (this.onLineMappingChanged()) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.ModelFlushedEvent:
                        if (this.onModelFlushed()) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.LinesDeletedEvent:
                        if (this.onModelLinesDeleted(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.LinesInsertedEvent:
                        if (this.onModelLinesInserted(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.LineChangedEvent:
                        if (this.onModelLineChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.TokensChangedEvent:
                        if (this.onModelTokensChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.DecorationsChangedEvent:
                        if (this.onModelDecorationsChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.CursorPositionChangedEvent:
                        if (this.onCursorPositionChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.CursorSelectionChangedEvent:
                        if (this.onCursorSelectionChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.RevealRangeEvent:
                        if (this.onCursorRevealRange(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.ViewEventNames.ScrollRequestEvent:
                        if (this.onCursorScrollRequest(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.EventType.ConfigurationChanged:
                        if (this.onConfigurationChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.EventType.ViewLayoutChanged:
                        if (this.onLayoutChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.EventType.ViewScrollChanged:
                        if (this.onScrollChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.EventType.ViewZonesChanged:
                        if (this.onZonesChanged()) {
                            shouldRender = true;
                        }
                        break;
                    case editorCommon.EventType.ViewFocusChanged:
                        if (this.onViewFocusChanged(data)) {
                            shouldRender = true;
                        }
                        break;
                    default:
                        console.info('View received unknown event: ');
                        console.info(e);
                }
            }
            if (shouldRender) {
                this._shouldRender = true;
            }
        };
        return ViewEventHandler;
    }());
    exports.ViewEventHandler = ViewEventHandler;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[74], __M([0,1,53]), function (require, exports, viewEventHandler_1) {
    'use strict';
    var DynamicViewOverlay = (function (_super) {
        __extends(DynamicViewOverlay, _super);
        function DynamicViewOverlay() {
            _super.apply(this, arguments);
        }
        return DynamicViewOverlay;
    }(viewEventHandler_1.ViewEventHandler));
    exports.DynamicViewOverlay = DynamicViewOverlay;
});






define(__m[46], __M([0,1,53]), function (require, exports, viewEventHandler_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewPart = (function (_super) {
        __extends(ViewPart, _super);
        function ViewPart(context) {
            _super.call(this);
            this._context = context;
            this._context.addEventHandler(this);
        }
        ViewPart.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._context = null;
        };
        return ViewPart;
    }(viewEventHandler_1.ViewEventHandler));
    exports.ViewPart = ViewPart;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[430], __M([0,1,74,511]), function (require, exports, dynamicViewOverlay_1) {
    'use strict';
    var CurrentLineHighlightOverlay = (function (_super) {
        __extends(CurrentLineHighlightOverlay, _super);
        function CurrentLineHighlightOverlay(context, layoutProvider) {
            _super.call(this);
            this._context = context;
            this._lineHeight = this._context.configuration.editor.lineHeight;
            this._readOnly = this._context.configuration.editor.readOnly;
            this._layoutProvider = layoutProvider;
            this._selectionIsEmpty = true;
            this._primaryCursorIsInEditableRange = true;
            this._primaryCursorLineNumber = 1;
            this._scrollWidth = this._layoutProvider.getScrollWidth();
            this._context.addEventHandler(this);
        }
        CurrentLineHighlightOverlay.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._context = null;
        };
        // --- begin event handlers
        CurrentLineHighlightOverlay.prototype.onModelFlushed = function () {
            this._primaryCursorIsInEditableRange = true;
            this._selectionIsEmpty = true;
            this._primaryCursorLineNumber = 1;
            this._scrollWidth = this._layoutProvider.getScrollWidth();
            return true;
        };
        CurrentLineHighlightOverlay.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        CurrentLineHighlightOverlay.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        CurrentLineHighlightOverlay.prototype.onCursorPositionChanged = function (e) {
            var hasChanged = false;
            if (this._primaryCursorIsInEditableRange !== e.isInEditableRange) {
                this._primaryCursorIsInEditableRange = e.isInEditableRange;
                hasChanged = true;
            }
            if (this._primaryCursorLineNumber !== e.position.lineNumber) {
                this._primaryCursorLineNumber = e.position.lineNumber;
                hasChanged = true;
            }
            return hasChanged;
        };
        CurrentLineHighlightOverlay.prototype.onCursorSelectionChanged = function (e) {
            var isEmpty = e.selection.isEmpty();
            if (this._selectionIsEmpty !== isEmpty) {
                this._selectionIsEmpty = isEmpty;
                return true;
            }
            return false;
        };
        CurrentLineHighlightOverlay.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            if (e.readOnly) {
                this._readOnly = this._context.configuration.editor.readOnly;
            }
            return true;
        };
        CurrentLineHighlightOverlay.prototype.onLayoutChanged = function (layoutInfo) {
            return true;
        };
        CurrentLineHighlightOverlay.prototype.onScrollChanged = function (e) {
            this._scrollWidth = e.scrollWidth;
            return e.scrollWidthChanged;
        };
        CurrentLineHighlightOverlay.prototype.onZonesChanged = function () {
            return true;
        };
        // --- end event handlers
        CurrentLineHighlightOverlay.prototype.prepareRender = function (ctx) {
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
            this._scrollWidth = ctx.scrollWidth;
        };
        CurrentLineHighlightOverlay.prototype.render = function (startLineNumber, lineNumber) {
            if (lineNumber === this._primaryCursorLineNumber) {
                if (this._shouldShowCurrentLine()) {
                    return ('<div class="current-line" style="width:'
                        + String(this._scrollWidth)
                        + 'px; height:'
                        + String(this._lineHeight)
                        + 'px;"></div>');
                }
                else {
                    return '';
                }
            }
            return '';
        };
        CurrentLineHighlightOverlay.prototype._shouldShowCurrentLine = function () {
            return this._selectionIsEmpty && this._primaryCursorIsInEditableRange && !this._readOnly;
        };
        return CurrentLineHighlightOverlay;
    }(dynamicViewOverlay_1.DynamicViewOverlay));
    exports.CurrentLineHighlightOverlay = CurrentLineHighlightOverlay;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[437], __M([0,1,74,182]), function (require, exports, dynamicViewOverlay_1) {
    'use strict';
    var DecorationsOverlay = (function (_super) {
        __extends(DecorationsOverlay, _super);
        function DecorationsOverlay(context) {
            _super.call(this);
            this._context = context;
            this._lineHeight = this._context.configuration.editor.lineHeight;
            this._renderResult = null;
            this._context.addEventHandler(this);
        }
        DecorationsOverlay.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._context = null;
            this._renderResult = null;
        };
        // --- begin event handlers
        DecorationsOverlay.prototype.onModelFlushed = function () {
            return true;
        };
        DecorationsOverlay.prototype.onModelDecorationsChanged = function (e) {
            return true;
        };
        DecorationsOverlay.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        DecorationsOverlay.prototype.onModelLineChanged = function (e) {
            return true;
        };
        DecorationsOverlay.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        DecorationsOverlay.prototype.onCursorPositionChanged = function (e) {
            return false;
        };
        DecorationsOverlay.prototype.onCursorSelectionChanged = function (e) {
            return false;
        };
        DecorationsOverlay.prototype.onCursorRevealRange = function (e) {
            return false;
        };
        DecorationsOverlay.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            return true;
        };
        DecorationsOverlay.prototype.onLayoutChanged = function (layoutInfo) {
            return true;
        };
        DecorationsOverlay.prototype.onScrollChanged = function (e) {
            return e.scrollTopChanged || e.scrollWidthChanged;
        };
        DecorationsOverlay.prototype.onZonesChanged = function () {
            return true;
        };
        // --- end event handlers
        DecorationsOverlay.prototype.prepareRender = function (ctx) {
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
            var decorations = ctx.getDecorationsInViewport();
            // Keep only decorations with `className`
            decorations = decorations.filter(function (d) { return !!d.options.className; });
            // Sort decorations for consistent render output
            decorations = decorations.sort(function (a, b) {
                if (a.options.className < b.options.className) {
                    return -1;
                }
                if (a.options.className > b.options.className) {
                    return 1;
                }
                if (a.range.startLineNumber === b.range.startLineNumber) {
                    if (a.range.startColumn === b.range.startColumn) {
                        if (a.range.endLineNumber === b.range.endLineNumber) {
                            return a.range.endColumn - b.range.endColumn;
                        }
                        return a.range.endLineNumber - b.range.endLineNumber;
                    }
                    return a.range.startColumn - b.range.startColumn;
                }
                return a.range.startLineNumber - b.range.startLineNumber;
            });
            var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
            var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
            var output = [];
            for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
                var lineIndex = lineNumber - visibleStartLineNumber;
                output[lineIndex] = '';
            }
            // Render first whole line decorations and then regular decorations
            this._renderWholeLineDecorations(ctx, decorations, output);
            this._renderNormalDecorations(ctx, decorations, output);
            this._renderResult = output;
        };
        DecorationsOverlay.prototype._renderWholeLineDecorations = function (ctx, decorations, output) {
            var lineHeight = String(this._lineHeight);
            var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
            var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
            for (var i = 0, lenI = decorations.length; i < lenI; i++) {
                var d = decorations[i];
                if (!d.options.isWholeLine) {
                    continue;
                }
                var decorationOutput = ('<div class="cdr '
                    + d.options.className
                    + '" style="left:0;width:100%;height:'
                    + lineHeight
                    + 'px;"></div>');
                var startLineNumber = Math.max(d.range.startLineNumber, visibleStartLineNumber);
                var endLineNumber = Math.min(d.range.endLineNumber, visibleEndLineNumber);
                for (var j = startLineNumber; j <= endLineNumber; j++) {
                    var lineIndex = j - visibleStartLineNumber;
                    output[lineIndex] += decorationOutput;
                }
            }
        };
        DecorationsOverlay.prototype._renderNormalDecorations = function (ctx, decorations, output) {
            var lineHeight = String(this._lineHeight);
            var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
            for (var i = 0, lenI = decorations.length; i < lenI; i++) {
                var d = decorations[i];
                if (d.options.isWholeLine) {
                    continue;
                }
                var linesVisibleRanges = ctx.linesVisibleRangesForRange(d.range, false);
                if (!linesVisibleRanges) {
                    continue;
                }
                var className = d.options.className;
                for (var j = 0, lenJ = linesVisibleRanges.length; j < lenJ; j++) {
                    var lineVisibleRanges = linesVisibleRanges[j];
                    var lineIndex = lineVisibleRanges.lineNumber - visibleStartLineNumber;
                    for (var k = 0, lenK = lineVisibleRanges.ranges.length; k < lenK; k++) {
                        var visibleRange = lineVisibleRanges.ranges[k];
                        var decorationOutput = ('<div class="cdr '
                            + className
                            + '" style="left:'
                            + String(visibleRange.left)
                            + 'px;width:'
                            + String(visibleRange.width)
                            + 'px;height:'
                            + lineHeight
                            + 'px;"></div>');
                        output[lineIndex] += decorationOutput;
                    }
                }
            }
        };
        DecorationsOverlay.prototype.render = function (startLineNumber, lineNumber) {
            if (!this._renderResult) {
                return '';
            }
            var lineIndex = lineNumber - startLineNumber;
            if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
                throw new Error('Unexpected render request');
            }
            return this._renderResult[lineIndex];
        };
        return DecorationsOverlay;
    }(dynamicViewOverlay_1.DynamicViewOverlay));
    exports.DecorationsOverlay = DecorationsOverlay;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[152], __M([0,1,74,187]), function (require, exports, dynamicViewOverlay_1) {
    'use strict';
    var DecorationToRender = (function () {
        function DecorationToRender(startLineNumber, endLineNumber, className) {
            this.startLineNumber = +startLineNumber;
            this.endLineNumber = +endLineNumber;
            this.className = String(className);
        }
        return DecorationToRender;
    }());
    exports.DecorationToRender = DecorationToRender;
    var DedupOverlay = (function (_super) {
        __extends(DedupOverlay, _super);
        function DedupOverlay() {
            _super.apply(this, arguments);
        }
        DedupOverlay.prototype._render = function (visibleStartLineNumber, visibleEndLineNumber, decorations) {
            var output = [];
            for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
                var lineIndex = lineNumber - visibleStartLineNumber;
                output[lineIndex] = '';
            }
            if (decorations.length === 0) {
                return output;
            }
            decorations.sort(function (a, b) {
                if (a.className === b.className) {
                    if (a.startLineNumber === b.startLineNumber) {
                        return a.endLineNumber - b.endLineNumber;
                    }
                    return a.startLineNumber - b.startLineNumber;
                }
                return (a.className < b.className ? -1 : 1);
            });
            var prevClassName = null;
            var prevEndLineIndex = 0;
            for (var i = 0, len = decorations.length; i < len; i++) {
                var d = decorations[i];
                var className = d.className;
                var startLineIndex = Math.max(d.startLineNumber, visibleStartLineNumber) - visibleStartLineNumber;
                var endLineIndex = Math.min(d.endLineNumber, visibleEndLineNumber) - visibleStartLineNumber;
                if (prevClassName === className) {
                    startLineIndex = Math.max(prevEndLineIndex + 1, startLineIndex);
                    prevEndLineIndex = Math.max(prevEndLineIndex, endLineIndex);
                }
                else {
                    prevClassName = className;
                    prevEndLineIndex = endLineIndex;
                }
                for (var i_1 = startLineIndex; i_1 <= prevEndLineIndex; i_1++) {
                    output[i_1] += ' ' + prevClassName;
                }
            }
            return output;
        };
        return DedupOverlay;
    }(dynamicViewOverlay_1.DynamicViewOverlay));
    exports.DedupOverlay = DedupOverlay;
    var GlyphMarginOverlay = (function (_super) {
        __extends(GlyphMarginOverlay, _super);
        function GlyphMarginOverlay(context) {
            _super.call(this);
            this._context = context;
            this._lineHeight = this._context.configuration.editor.lineHeight;
            this._glyphMargin = this._context.configuration.editor.viewInfo.glyphMargin;
            this._glyphMarginLeft = 0;
            this._glyphMarginWidth = 0;
            this._renderResult = null;
            this._context.addEventHandler(this);
        }
        GlyphMarginOverlay.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._context = null;
            this._renderResult = null;
        };
        // --- begin event handlers
        GlyphMarginOverlay.prototype.onModelFlushed = function () {
            return true;
        };
        GlyphMarginOverlay.prototype.onModelDecorationsChanged = function (e) {
            return true;
        };
        GlyphMarginOverlay.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        GlyphMarginOverlay.prototype.onModelLineChanged = function (e) {
            return true;
        };
        GlyphMarginOverlay.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        GlyphMarginOverlay.prototype.onCursorPositionChanged = function (e) {
            return false;
        };
        GlyphMarginOverlay.prototype.onCursorSelectionChanged = function (e) {
            return false;
        };
        GlyphMarginOverlay.prototype.onCursorRevealRange = function (e) {
            return false;
        };
        GlyphMarginOverlay.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            if (e.viewInfo.glyphMargin) {
                this._glyphMargin = this._context.configuration.editor.viewInfo.glyphMargin;
            }
            return true;
        };
        GlyphMarginOverlay.prototype.onLayoutChanged = function (layoutInfo) {
            this._glyphMarginLeft = layoutInfo.glyphMarginLeft;
            this._glyphMarginWidth = layoutInfo.glyphMarginWidth;
            return true;
        };
        GlyphMarginOverlay.prototype.onScrollChanged = function (e) {
            return e.scrollTopChanged;
        };
        GlyphMarginOverlay.prototype.onZonesChanged = function () {
            return true;
        };
        // --- end event handlers
        GlyphMarginOverlay.prototype._getDecorations = function (ctx) {
            var decorations = ctx.getDecorationsInViewport();
            var r = [];
            for (var i = 0, len = decorations.length; i < len; i++) {
                var d = decorations[i];
                if (d.options.glyphMarginClassName) {
                    r.push(new DecorationToRender(d.range.startLineNumber, d.range.endLineNumber, d.options.glyphMarginClassName));
                }
            }
            return r;
        };
        GlyphMarginOverlay.prototype.prepareRender = function (ctx) {
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
            if (!this._glyphMargin) {
                this._renderResult = null;
                return;
            }
            var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
            var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
            var toRender = this._render(visibleStartLineNumber, visibleEndLineNumber, this._getDecorations(ctx));
            var lineHeight = this._lineHeight.toString();
            var left = this._glyphMarginLeft.toString();
            var width = this._glyphMarginWidth.toString();
            var common = '" style="left:' + left + 'px;width:' + width + 'px' + ';height:' + lineHeight + 'px;"></div>';
            var output = [];
            for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
                var lineIndex = lineNumber - visibleStartLineNumber;
                var classNames = toRender[lineIndex];
                if (classNames.length === 0) {
                    output[lineIndex] = '';
                }
                else {
                    output[lineIndex] = ('<div class="cgmr'
                        + classNames
                        + common);
                }
            }
            this._renderResult = output;
        };
        GlyphMarginOverlay.prototype.render = function (startLineNumber, lineNumber) {
            if (!this._renderResult) {
                return '';
            }
            var lineIndex = lineNumber - startLineNumber;
            if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
                throw new Error('Unexpected render request');
            }
            return this._renderResult[lineIndex];
        };
        return GlyphMarginOverlay;
    }(DedupOverlay));
    exports.GlyphMarginOverlay = GlyphMarginOverlay;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[439], __M([0,1,18,74,22,188]), function (require, exports, platform, dynamicViewOverlay_1, editorBrowser_1) {
    'use strict';
    var LineNumbersOverlay = (function (_super) {
        __extends(LineNumbersOverlay, _super);
        function LineNumbersOverlay(context) {
            _super.call(this);
            this._context = context;
            this._lineHeight = this._context.configuration.editor.lineHeight;
            this._lineNumbers = this._context.configuration.editor.viewInfo.lineNumbers;
            this._lineNumbersLeft = 0;
            this._lineNumbersWidth = 0;
            this._renderResult = null;
            this._context.addEventHandler(this);
        }
        LineNumbersOverlay.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._context = null;
            this._renderResult = null;
        };
        // --- begin event handlers
        LineNumbersOverlay.prototype.onModelFlushed = function () {
            return true;
        };
        LineNumbersOverlay.prototype.onModelDecorationsChanged = function (e) {
            return false;
        };
        LineNumbersOverlay.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        LineNumbersOverlay.prototype.onModelLineChanged = function (e) {
            return true;
        };
        LineNumbersOverlay.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        LineNumbersOverlay.prototype.onCursorPositionChanged = function (e) {
            return false;
        };
        LineNumbersOverlay.prototype.onCursorSelectionChanged = function (e) {
            return false;
        };
        LineNumbersOverlay.prototype.onCursorRevealRange = function (e) {
            return false;
        };
        LineNumbersOverlay.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            if (e.viewInfo.lineNumbers) {
                this._lineNumbers = this._context.configuration.editor.viewInfo.lineNumbers;
            }
            return true;
        };
        LineNumbersOverlay.prototype.onLayoutChanged = function (layoutInfo) {
            this._lineNumbersLeft = layoutInfo.lineNumbersLeft;
            this._lineNumbersWidth = layoutInfo.lineNumbersWidth;
            return true;
        };
        LineNumbersOverlay.prototype.onScrollChanged = function (e) {
            return e.scrollTopChanged;
        };
        LineNumbersOverlay.prototype.onZonesChanged = function () {
            return true;
        };
        // --- end event handlers
        LineNumbersOverlay.prototype.prepareRender = function (ctx) {
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
            if (!this._lineNumbers) {
                this._renderResult = null;
                return;
            }
            var lineHeightClassName = (platform.isLinux ? (this._lineHeight % 2 === 0 ? ' lh-even' : ' lh-odd') : '');
            var lineHeight = this._lineHeight.toString();
            var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
            var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
            var common = '<div class="' + editorBrowser_1.ClassNames.LINE_NUMBERS + lineHeightClassName + '" style="left:' + this._lineNumbersLeft.toString() + 'px;width:' + this._lineNumbersWidth.toString() + 'px;height:' + lineHeight + 'px;">';
            var output = [];
            for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
                var lineIndex = lineNumber - visibleStartLineNumber;
                var renderLineNumber = this._context.model.getLineRenderLineNumber(lineNumber);
                if (renderLineNumber) {
                    output[lineIndex] = (common
                        + renderLineNumber
                        + '</div>');
                }
                else {
                    output[lineIndex] = '';
                }
            }
            this._renderResult = output;
        };
        LineNumbersOverlay.prototype.render = function (startLineNumber, lineNumber) {
            if (!this._renderResult) {
                return '';
            }
            var lineIndex = lineNumber - startLineNumber;
            if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
                throw new Error('Unexpected render request');
            }
            return this._renderResult[lineIndex];
        };
        return LineNumbersOverlay;
    }(dynamicViewOverlay_1.DynamicViewOverlay));
    exports.LineNumbersOverlay = LineNumbersOverlay;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[440], __M([0,1,152,190]), function (require, exports, glyphMargin_1) {
    'use strict';
    var LinesDecorationsOverlay = (function (_super) {
        __extends(LinesDecorationsOverlay, _super);
        function LinesDecorationsOverlay(context) {
            _super.call(this);
            this._context = context;
            this._lineHeight = this._context.configuration.editor.lineHeight;
            this._decorationsLeft = 0;
            this._decorationsWidth = 0;
            this._renderResult = null;
            this._context.addEventHandler(this);
        }
        LinesDecorationsOverlay.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._context = null;
            this._renderResult = null;
        };
        // --- begin event handlers
        LinesDecorationsOverlay.prototype.onModelFlushed = function () {
            return true;
        };
        LinesDecorationsOverlay.prototype.onModelDecorationsChanged = function (e) {
            return true;
        };
        LinesDecorationsOverlay.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        LinesDecorationsOverlay.prototype.onModelLineChanged = function (e) {
            return true;
        };
        LinesDecorationsOverlay.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        LinesDecorationsOverlay.prototype.onCursorPositionChanged = function (e) {
            return false;
        };
        LinesDecorationsOverlay.prototype.onCursorSelectionChanged = function (e) {
            return false;
        };
        LinesDecorationsOverlay.prototype.onCursorRevealRange = function (e) {
            return false;
        };
        LinesDecorationsOverlay.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            return true;
        };
        LinesDecorationsOverlay.prototype.onLayoutChanged = function (layoutInfo) {
            this._decorationsLeft = layoutInfo.decorationsLeft;
            this._decorationsWidth = layoutInfo.decorationsWidth;
            return true;
        };
        LinesDecorationsOverlay.prototype.onScrollChanged = function (e) {
            return e.scrollTopChanged;
        };
        LinesDecorationsOverlay.prototype.onZonesChanged = function () {
            return true;
        };
        // --- end event handlers
        LinesDecorationsOverlay.prototype._getDecorations = function (ctx) {
            var decorations = ctx.getDecorationsInViewport();
            var r = [];
            for (var i = 0, len = decorations.length; i < len; i++) {
                var d = decorations[i];
                if (d.options.linesDecorationsClassName) {
                    r.push(new glyphMargin_1.DecorationToRender(d.range.startLineNumber, d.range.endLineNumber, d.options.linesDecorationsClassName));
                }
            }
            return r;
        };
        LinesDecorationsOverlay.prototype.prepareRender = function (ctx) {
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
            var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
            var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
            var toRender = this._render(visibleStartLineNumber, visibleEndLineNumber, this._getDecorations(ctx));
            var lineHeight = this._lineHeight.toString();
            var left = this._decorationsLeft.toString();
            var width = this._decorationsWidth.toString();
            var common = '" style="left:' + left + 'px;width:' + width + 'px' + ';height:' + lineHeight + 'px;"></div>';
            var output = [];
            for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
                var lineIndex = lineNumber - visibleStartLineNumber;
                var classNames = toRender[lineIndex];
                if (classNames.length === 0) {
                    output[lineIndex] = '';
                }
                else {
                    output[lineIndex] = ('<div class="cldr'
                        + classNames
                        + common);
                }
            }
            this._renderResult = output;
        };
        LinesDecorationsOverlay.prototype.render = function (startLineNumber, lineNumber) {
            if (!this._renderResult) {
                return '';
            }
            var lineIndex = lineNumber - startLineNumber;
            if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
                throw new Error('Unexpected render request');
            }
            return this._renderResult[lineIndex];
        };
        return LinesDecorationsOverlay;
    }(glyphMargin_1.DedupOverlay));
    exports.LinesDecorationsOverlay = LinesDecorationsOverlay;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[441], __M([0,1,74,194]), function (require, exports, dynamicViewOverlay_1) {
    'use strict';
    var CornerStyle;
    (function (CornerStyle) {
        CornerStyle[CornerStyle["EXTERN"] = 0] = "EXTERN";
        CornerStyle[CornerStyle["INTERN"] = 1] = "INTERN";
        CornerStyle[CornerStyle["FLAT"] = 2] = "FLAT";
    })(CornerStyle || (CornerStyle = {}));
    var HorizontalRangeWithStyle = (function () {
        function HorizontalRangeWithStyle(other) {
            this.left = other.left;
            this.width = other.width;
            this.startStyle = null;
            this.endStyle = null;
        }
        return HorizontalRangeWithStyle;
    }());
    var LineVisibleRangesWithStyle = (function () {
        function LineVisibleRangesWithStyle(lineNumber, ranges) {
            this.lineNumber = lineNumber;
            this.ranges = ranges;
        }
        return LineVisibleRangesWithStyle;
    }());
    function toStyledRange(item) {
        return new HorizontalRangeWithStyle(item);
    }
    function toStyled(item) {
        return new LineVisibleRangesWithStyle(item.lineNumber, item.ranges.map(toStyledRange));
    }
    // TODO@Alex: Remove this once IE11 fixes Bug #524217
    // The problem in IE11 is that it does some sort of auto-zooming to accomodate for displays with different pixel density.
    // Unfortunately, this auto-zooming is buggy around dealing with rounded borders
    var isIEWithZoomingIssuesNearRoundedBorders = ((navigator.userAgent.indexOf('Trident/7.0') >= 0)
        || (navigator.userAgent.indexOf('Edge/12') >= 0));
    var SelectionsOverlay = (function (_super) {
        __extends(SelectionsOverlay, _super);
        function SelectionsOverlay(context) {
            _super.call(this);
            this._previousFrameVisibleRangesWithStyle = [];
            this._context = context;
            this._lineHeight = this._context.configuration.editor.lineHeight;
            this._roundedSelection = this._context.configuration.editor.viewInfo.roundedSelection;
            this._selections = [];
            this._renderResult = null;
            this._context.addEventHandler(this);
        }
        SelectionsOverlay.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._context = null;
            this._selections = null;
            this._renderResult = null;
        };
        // --- begin event handlers
        SelectionsOverlay.prototype.onModelFlushed = function () {
            return true;
        };
        SelectionsOverlay.prototype.onModelDecorationsChanged = function (e) {
            // true for inline decorations that can end up relayouting text
            return e.inlineDecorationsChanged;
        };
        SelectionsOverlay.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        SelectionsOverlay.prototype.onModelLineChanged = function (e) {
            return true;
        };
        SelectionsOverlay.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        SelectionsOverlay.prototype.onCursorPositionChanged = function (e) {
            return false;
        };
        SelectionsOverlay.prototype.onCursorSelectionChanged = function (e) {
            this._selections = [e.selection];
            this._selections = this._selections.concat(e.secondarySelections);
            return true;
        };
        SelectionsOverlay.prototype.onCursorRevealRange = function (e) {
            return false;
        };
        SelectionsOverlay.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            if (e.viewInfo.roundedSelection) {
                this._roundedSelection = this._context.configuration.editor.viewInfo.roundedSelection;
            }
            return true;
        };
        SelectionsOverlay.prototype.onLayoutChanged = function (layoutInfo) {
            return true;
        };
        SelectionsOverlay.prototype.onScrollChanged = function (e) {
            return e.scrollTopChanged;
        };
        SelectionsOverlay.prototype.onZonesChanged = function () {
            return true;
        };
        // --- end event handlers
        SelectionsOverlay.prototype._visibleRangesHaveGaps = function (linesVisibleRanges) {
            var i, len, lineVisibleRanges;
            for (i = 0, len = linesVisibleRanges.length; i < len; i++) {
                lineVisibleRanges = linesVisibleRanges[i];
                if (lineVisibleRanges.ranges.length > 1) {
                    // There are two ranges on the same line
                    return true;
                }
            }
            return false;
        };
        SelectionsOverlay.prototype._enrichVisibleRangesWithStyle = function (linesVisibleRanges, previousFrame) {
            var curLineRange, curLeft, curRight, prevLeft, prevRight, nextLeft, nextRight, startStyle, endStyle, i, len;
            var previousFrameTop = null, previousFrameBottom = null;
            if (previousFrame && previousFrame.length > 0 && linesVisibleRanges.length > 0) {
                var topLineNumber = linesVisibleRanges[0].lineNumber;
                for (var i = 0; !previousFrameTop && i < previousFrame.length; i++) {
                    if (previousFrame[i].lineNumber === topLineNumber) {
                        previousFrameTop = previousFrame[i].ranges[0];
                    }
                }
                var bottomLineNumber = linesVisibleRanges[linesVisibleRanges.length - 1].lineNumber;
                for (var i = previousFrame.length - 1; !previousFrameBottom && i >= 0; i--) {
                    if (previousFrame[i].lineNumber === bottomLineNumber) {
                        previousFrameBottom = previousFrame[i].ranges[0];
                    }
                }
                if (previousFrameTop && !previousFrameTop.startStyle) {
                    previousFrameTop = null;
                }
                if (previousFrameBottom && !previousFrameBottom.startStyle) {
                    previousFrameBottom = null;
                }
            }
            for (i = 0, len = linesVisibleRanges.length; i < len; i++) {
                // We know for a fact that there is precisely one range on each line
                curLineRange = linesVisibleRanges[i].ranges[0];
                curLeft = curLineRange.left;
                curRight = curLineRange.left + curLineRange.width;
                startStyle = {
                    top: CornerStyle.EXTERN,
                    bottom: CornerStyle.EXTERN
                };
                endStyle = {
                    top: CornerStyle.EXTERN,
                    bottom: CornerStyle.EXTERN
                };
                if (i > 0) {
                    // Look above
                    prevLeft = linesVisibleRanges[i - 1].ranges[0].left;
                    prevRight = linesVisibleRanges[i - 1].ranges[0].left + linesVisibleRanges[i - 1].ranges[0].width;
                    if (curLeft === prevLeft) {
                        startStyle.top = CornerStyle.FLAT;
                    }
                    else if (curLeft > prevLeft) {
                        startStyle.top = CornerStyle.INTERN;
                    }
                    if (curRight === prevRight) {
                        endStyle.top = CornerStyle.FLAT;
                    }
                    else if (prevLeft < curRight && curRight < prevRight) {
                        endStyle.top = CornerStyle.INTERN;
                    }
                }
                else if (previousFrameTop) {
                    // Accept some hick-ups near the viewport edges to save on repaints
                    startStyle.top = previousFrameTop.startStyle.top;
                    endStyle.top = previousFrameTop.endStyle.top;
                }
                if (i + 1 < len) {
                    // Look below
                    nextLeft = linesVisibleRanges[i + 1].ranges[0].left;
                    nextRight = linesVisibleRanges[i + 1].ranges[0].left + linesVisibleRanges[i + 1].ranges[0].width;
                    if (curLeft === nextLeft) {
                        startStyle.bottom = CornerStyle.FLAT;
                    }
                    else if (nextLeft < curLeft && curLeft < nextRight) {
                        startStyle.bottom = CornerStyle.INTERN;
                    }
                    if (curRight === nextRight) {
                        endStyle.bottom = CornerStyle.FLAT;
                    }
                    else if (curRight < nextRight) {
                        endStyle.bottom = CornerStyle.INTERN;
                    }
                }
                else if (previousFrameBottom) {
                    // Accept some hick-ups near the viewport edges to save on repaints
                    startStyle.bottom = previousFrameBottom.startStyle.bottom;
                    endStyle.bottom = previousFrameBottom.endStyle.bottom;
                }
                curLineRange.startStyle = startStyle;
                curLineRange.endStyle = endStyle;
            }
        };
        SelectionsOverlay.prototype._getVisibleRangesWithStyle = function (selection, ctx, previousFrame) {
            var _linesVisibleRanges = ctx.linesVisibleRangesForRange(selection, true) || [];
            var linesVisibleRanges = _linesVisibleRanges.map(toStyled);
            var visibleRangesHaveGaps = this._visibleRangesHaveGaps(linesVisibleRanges);
            if (!isIEWithZoomingIssuesNearRoundedBorders && !visibleRangesHaveGaps && this._roundedSelection) {
                this._enrichVisibleRangesWithStyle(linesVisibleRanges, previousFrame);
            }
            // The visible ranges are sorted TOP-BOTTOM and LEFT-RIGHT
            return linesVisibleRanges;
        };
        SelectionsOverlay.prototype._createSelectionPiece = function (top, height, className, left, width) {
            return ('<div class="cslr '
                + className
                + '" style="top:'
                + top.toString()
                + 'px;left:'
                + left.toString()
                + 'px;width:'
                + width.toString()
                + 'px;height:'
                + height
                + 'px;"></div>');
        };
        SelectionsOverlay.prototype._actualRenderOneSelection = function (output2, visibleStartLineNumber, hasMultipleSelections, visibleRanges) {
            var visibleRangesHaveStyle = (visibleRanges.length > 0 && visibleRanges[0].ranges[0].startStyle);
            var fullLineHeight = (this._lineHeight).toString();
            var reducedLineHeight = (this._lineHeight - 1).toString();
            var firstLineNumber = (visibleRanges.length > 0 ? visibleRanges[0].lineNumber : 0);
            var lastLineNumber = (visibleRanges.length > 0 ? visibleRanges[visibleRanges.length - 1].lineNumber : 0);
            for (var i = 0, len = visibleRanges.length; i < len; i++) {
                var lineVisibleRanges = visibleRanges[i];
                var lineNumber = lineVisibleRanges.lineNumber;
                var lineIndex = lineNumber - visibleStartLineNumber;
                var lineHeight = hasMultipleSelections ? (lineNumber === lastLineNumber || lineNumber === firstLineNumber ? reducedLineHeight : fullLineHeight) : fullLineHeight;
                var top_1 = hasMultipleSelections ? (lineNumber === firstLineNumber ? 1 : 0) : 0;
                var lineOutput = '';
                for (var j = 0, lenJ = lineVisibleRanges.ranges.length; j < lenJ; j++) {
                    var visibleRange = lineVisibleRanges.ranges[j];
                    if (visibleRangesHaveStyle) {
                        if (visibleRange.startStyle.top === CornerStyle.INTERN || visibleRange.startStyle.bottom === CornerStyle.INTERN) {
                            // Reverse rounded corner to the left
                            // First comes the selection (blue layer)
                            lineOutput += this._createSelectionPiece(top_1, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
                            // Second comes the background (white layer) with inverse border radius
                            var className_1 = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;
                            if (visibleRange.startStyle.top === CornerStyle.INTERN) {
                                className_1 += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;
                            }
                            if (visibleRange.startStyle.bottom === CornerStyle.INTERN) {
                                className_1 += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;
                            }
                            lineOutput += this._createSelectionPiece(top_1, lineHeight, className_1, visibleRange.left - SelectionsOverlay.ROUNDED_PIECE_WIDTH, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
                        }
                        if (visibleRange.endStyle.top === CornerStyle.INTERN || visibleRange.endStyle.bottom === CornerStyle.INTERN) {
                            // Reverse rounded corner to the right
                            // First comes the selection (blue layer)
                            lineOutput += this._createSelectionPiece(top_1, lineHeight, SelectionsOverlay.SELECTION_CLASS_NAME, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
                            // Second comes the background (white layer) with inverse border radius
                            var className_2 = SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME;
                            if (visibleRange.endStyle.top === CornerStyle.INTERN) {
                                className_2 += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;
                            }
                            if (visibleRange.endStyle.bottom === CornerStyle.INTERN) {
                                className_2 += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;
                            }
                            lineOutput += this._createSelectionPiece(top_1, lineHeight, className_2, visibleRange.left + visibleRange.width, SelectionsOverlay.ROUNDED_PIECE_WIDTH);
                        }
                    }
                    var className = SelectionsOverlay.SELECTION_CLASS_NAME;
                    if (visibleRangesHaveStyle) {
                        if (visibleRange.startStyle.top === CornerStyle.EXTERN) {
                            className += ' ' + SelectionsOverlay.SELECTION_TOP_LEFT;
                        }
                        if (visibleRange.startStyle.bottom === CornerStyle.EXTERN) {
                            className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_LEFT;
                        }
                        if (visibleRange.endStyle.top === CornerStyle.EXTERN) {
                            className += ' ' + SelectionsOverlay.SELECTION_TOP_RIGHT;
                        }
                        if (visibleRange.endStyle.bottom === CornerStyle.EXTERN) {
                            className += ' ' + SelectionsOverlay.SELECTION_BOTTOM_RIGHT;
                        }
                    }
                    lineOutput += this._createSelectionPiece(top_1, lineHeight, className, visibleRange.left, visibleRange.width);
                }
                output2[lineIndex] += lineOutput;
            }
        };
        SelectionsOverlay.prototype.prepareRender = function (ctx) {
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
            var output = [];
            var visibleStartLineNumber = ctx.visibleRange.startLineNumber;
            var visibleEndLineNumber = ctx.visibleRange.endLineNumber;
            for (var lineNumber = visibleStartLineNumber; lineNumber <= visibleEndLineNumber; lineNumber++) {
                var lineIndex = lineNumber - visibleStartLineNumber;
                output[lineIndex] = '';
            }
            var thisFrameVisibleRangesWithStyle = [];
            for (var i = 0, len = this._selections.length; i < len; i++) {
                var selection = this._selections[i];
                if (selection.isEmpty()) {
                    thisFrameVisibleRangesWithStyle.push(null);
                    continue;
                }
                var visibleRangesWithStyle = this._getVisibleRangesWithStyle(selection, ctx, this._previousFrameVisibleRangesWithStyle[i]);
                thisFrameVisibleRangesWithStyle.push(visibleRangesWithStyle);
                this._actualRenderOneSelection(output, visibleStartLineNumber, this._selections.length > 1, visibleRangesWithStyle);
            }
            this._previousFrameVisibleRangesWithStyle = thisFrameVisibleRangesWithStyle;
            this._renderResult = output;
        };
        SelectionsOverlay.prototype.render = function (startLineNumber, lineNumber) {
            if (!this._renderResult) {
                return '';
            }
            var lineIndex = lineNumber - startLineNumber;
            if (lineIndex < 0 || lineIndex >= this._renderResult.length) {
                throw new Error('Unexpected render request');
            }
            return this._renderResult[lineIndex];
        };
        SelectionsOverlay.SELECTION_CLASS_NAME = 'selected-text';
        SelectionsOverlay.SELECTION_TOP_LEFT = 'top-left-radius';
        SelectionsOverlay.SELECTION_BOTTOM_LEFT = 'bottom-left-radius';
        SelectionsOverlay.SELECTION_TOP_RIGHT = 'top-right-radius';
        SelectionsOverlay.SELECTION_BOTTOM_RIGHT = 'bottom-right-radius';
        SelectionsOverlay.EDITOR_BACKGROUND_CLASS_NAME = 'monaco-editor-background';
        SelectionsOverlay.ROUNDED_PIECE_WIDTH = 10;
        return SelectionsOverlay;
    }(dynamicViewOverlay_1.DynamicViewOverlay));
    exports.SelectionsOverlay = SelectionsOverlay;
});

define(__m[116], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var InlineDecoration = (function () {
        function InlineDecoration(range, inlineClassName) {
            this.range = range;
            this.inlineClassName = inlineClassName;
        }
        return InlineDecoration;
    }());
    exports.InlineDecoration = InlineDecoration;
});

define(__m[172], __M([0,1,10,89,4,64,116]), function (require, exports, strings, arrays_1, range_1, viewLineToken_1, viewModel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function cmpLineDecorations(a, b) {
        return range_1.Range.compareRangesUsingStarts(a.range, b.range);
    }
    function createLineParts(lineNumber, minLineColumn, lineContent, tabSize, lineTokens, rawLineDecorations, renderWhitespace, indentGuides) {
        if (indentGuides || renderWhitespace) {
            var oldLength = rawLineDecorations.length;
            rawLineDecorations = insertCustomLineDecorations(indentGuides, renderWhitespace, lineNumber, lineContent, tabSize, lineTokens.getFauxIndentLength(), rawLineDecorations);
            if (rawLineDecorations.length !== oldLength) {
                rawLineDecorations.sort(cmpLineDecorations);
            }
        }
        if (rawLineDecorations.length > 0) {
            return createViewLineParts(lineNumber, minLineColumn, lineTokens, lineContent, rawLineDecorations);
        }
        else {
            return createFastViewLineParts(lineTokens, lineContent);
        }
    }
    exports.createLineParts = createLineParts;
    function getColumnOfLinePartOffset(stopRenderingLineAfter, lineParts, lineMaxColumn, charOffsetInPart, partIndex, partLength, offset) {
        if (partIndex >= lineParts.length) {
            return stopRenderingLineAfter;
        }
        if (offset === 0) {
            return lineParts[partIndex].startIndex + 1;
        }
        if (offset === partLength) {
            return (partIndex + 1 < lineParts.length ? lineParts[partIndex + 1].startIndex + 1 : lineMaxColumn);
        }
        var originalMin = lineParts[partIndex].startIndex;
        var originalMax = (partIndex + 1 < lineParts.length ? lineParts[partIndex + 1].startIndex : lineMaxColumn - 1);
        var min = originalMin;
        var max = originalMax;
        // invariant: offsetOf(min) <= offset <= offsetOf(max)
        while (min + 1 < max) {
            var mid = Math.floor((min + max) / 2);
            var midOffset = charOffsetInPart[mid];
            if (midOffset === offset) {
                return mid + 1;
            }
            else if (midOffset > offset) {
                max = mid;
            }
            else {
                min = mid;
            }
        }
        if (min === max) {
            return min + 1;
        }
        var minOffset = charOffsetInPart[min];
        var maxOffset = (max < originalMax ? charOffsetInPart[max] : partLength);
        var distanceToMin = offset - minOffset;
        var distanceToMax = maxOffset - offset;
        if (distanceToMin <= distanceToMax) {
            return min + 1;
        }
        else {
            return max + 1;
        }
    }
    exports.getColumnOfLinePartOffset = getColumnOfLinePartOffset;
    function trimEmptyTrailingPart(parts, lineContent) {
        if (parts.length <= 1) {
            return parts;
        }
        var lastPartStartIndex = parts[parts.length - 1].startIndex;
        if (lastPartStartIndex < lineContent.length) {
            // All is good
            return parts;
        }
        // Remove last line part
        return parts.slice(0, parts.length - 1);
    }
    var _tab = '\t'.charCodeAt(0);
    var _space = ' '.charCodeAt(0);
    function insertOneCustomLineDecoration(dest, lineNumber, startColumn, endColumn, className) {
        dest.push(new viewModel_1.InlineDecoration(new range_1.Range(lineNumber, startColumn, lineNumber, endColumn), className));
    }
    function insertCustomLineDecorations(indentGuides, renderWhitespace, lineNumber, lineContent, tabSize, fauxIndentLength, rawLineDecorations) {
        if (!indentGuides && !renderWhitespace) {
            return rawLineDecorations;
        }
        var lineLength = lineContent.length;
        if (lineLength === fauxIndentLength) {
            return rawLineDecorations;
        }
        var firstChar = indentGuides ? lineContent.charCodeAt(0) : lineContent.charCodeAt(fauxIndentLength);
        var lastChar = lineContent.charCodeAt(lineLength - 1);
        if (firstChar !== _tab && firstChar !== _space && lastChar !== _tab && lastChar !== _space) {
            // This line contains no leading nor trailing whitespace => fast path
            return rawLineDecorations;
        }
        var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);
        var lastNonWhitespaceIndex;
        if (firstNonWhitespaceIndex === -1) {
            // The entire line is whitespace
            firstNonWhitespaceIndex = lineLength;
            lastNonWhitespaceIndex = lineLength;
        }
        else {
            lastNonWhitespaceIndex = strings.lastNonWhitespaceIndex(lineContent);
        }
        var sm_endIndex = [];
        var sm_decoration = [];
        if (fauxIndentLength > 0) {
            // add faux indent state
            sm_endIndex.push(fauxIndentLength - 1);
            sm_decoration.push(indentGuides ? 'indent-guide' : null);
        }
        if (firstNonWhitespaceIndex > fauxIndentLength) {
            // add leading whitespace state
            sm_endIndex.push(firstNonWhitespaceIndex - 1);
            var leadingClassName = null;
            if (fauxIndentLength > 0) {
                leadingClassName = (renderWhitespace ? 'leading whitespace' : null);
            }
            else {
                if (indentGuides && renderWhitespace) {
                    leadingClassName = 'leading whitespace indent-guide';
                }
                else if (indentGuides) {
                    leadingClassName = 'indent-guide';
                }
                else {
                    leadingClassName = 'leading whitespace';
                }
            }
            sm_decoration.push(leadingClassName);
        }
        // add content state
        sm_endIndex.push(lastNonWhitespaceIndex);
        sm_decoration.push(null);
        // add trailing whitespace state
        sm_endIndex.push(lineLength - 1);
        sm_decoration.push(renderWhitespace ? 'trailing whitespace' : null);
        // add dummy state to avoid array length checks
        sm_endIndex.push(lineLength);
        sm_decoration.push(null);
        return insertCustomLineDecorationsWithStateMachine(lineNumber, lineContent, tabSize, rawLineDecorations, sm_endIndex, sm_decoration);
    }
    function insertCustomLineDecorationsWithStateMachine(lineNumber, lineContent, tabSize, rawLineDecorations, sm_endIndex, sm_decoration) {
        var lineLength = lineContent.length;
        var currentStateIndex = 0;
        var stateEndIndex = sm_endIndex[currentStateIndex];
        var stateDecoration = sm_decoration[currentStateIndex];
        var result = rawLineDecorations.slice(0);
        var tmpIndent = 0;
        var whitespaceStartColumn = 1;
        for (var index = 0; index < lineLength; index++) {
            var chCode = lineContent.charCodeAt(index);
            if (chCode === _tab) {
                tmpIndent = tabSize;
            }
            else {
                tmpIndent++;
            }
            if (index === stateEndIndex) {
                if (stateDecoration !== null) {
                    insertOneCustomLineDecoration(result, lineNumber, whitespaceStartColumn, index + 2, stateDecoration);
                }
                whitespaceStartColumn = index + 2;
                tmpIndent = tmpIndent % tabSize;
                currentStateIndex++;
                stateEndIndex = sm_endIndex[currentStateIndex];
                stateDecoration = sm_decoration[currentStateIndex];
            }
            else {
                if (stateDecoration !== null && tmpIndent >= tabSize) {
                    insertOneCustomLineDecoration(result, lineNumber, whitespaceStartColumn, index + 2, stateDecoration);
                    whitespaceStartColumn = index + 2;
                    tmpIndent = tmpIndent % tabSize;
                }
            }
        }
        return result;
    }
    var LineParts = (function () {
        function LineParts(parts) {
            this._parts = parts;
        }
        LineParts.prototype.getParts = function () {
            return this._parts;
        };
        LineParts.prototype.equals = function (other) {
            return viewLineToken_1.ViewLineToken.equalsArray(this._parts, other._parts);
        };
        LineParts.prototype.findIndexOfOffset = function (offset) {
            return arrays_1.Arrays.findIndexInSegmentsArray(this._parts, offset);
        };
        return LineParts;
    }());
    exports.LineParts = LineParts;
    function createFastViewLineParts(lineTokens, lineContent) {
        var parts = lineTokens.getTokens();
        parts = trimEmptyTrailingPart(parts, lineContent);
        return new LineParts(parts);
    }
    function createViewLineParts(lineNumber, minLineColumn, lineTokens, lineContent, rawLineDecorations) {
        // lineDecorations might overlap on top of each other, so they need to be normalized
        var lineDecorations = LineDecorationsNormalizer.normalize(lineNumber, minLineColumn, rawLineDecorations), lineDecorationsIndex = 0, lineDecorationsLength = lineDecorations.length;
        var actualLineTokens = lineTokens.getTokens(), nextStartOffset, currentTokenEndOffset, currentTokenClassName;
        var parts = [];
        for (var i = 0, len = actualLineTokens.length; i < len; i++) {
            nextStartOffset = actualLineTokens[i].startIndex;
            currentTokenEndOffset = (i + 1 < len ? actualLineTokens[i + 1].startIndex : lineTokens.getTextLength());
            currentTokenClassName = actualLineTokens[i].type;
            while (lineDecorationsIndex < lineDecorationsLength && lineDecorations[lineDecorationsIndex].startOffset < currentTokenEndOffset) {
                if (lineDecorations[lineDecorationsIndex].startOffset > nextStartOffset) {
                    // the first decorations starts after the token
                    parts.push(new viewLineToken_1.ViewLineToken(nextStartOffset, currentTokenClassName));
                    nextStartOffset = lineDecorations[lineDecorationsIndex].startOffset;
                }
                parts.push(new viewLineToken_1.ViewLineToken(nextStartOffset, currentTokenClassName + ' ' + lineDecorations[lineDecorationsIndex].className));
                if (lineDecorations[lineDecorationsIndex].endOffset >= currentTokenEndOffset) {
                    // this decoration goes on to the next token
                    nextStartOffset = currentTokenEndOffset;
                    break;
                }
                else {
                    // this decorations stops inside this token
                    nextStartOffset = lineDecorations[lineDecorationsIndex].endOffset + 1;
                    lineDecorationsIndex++;
                }
            }
            if (nextStartOffset < currentTokenEndOffset) {
                parts.push(new viewLineToken_1.ViewLineToken(nextStartOffset, currentTokenClassName));
            }
        }
        return new LineParts(parts);
    }
    var DecorationSegment = (function () {
        function DecorationSegment(startOffset, endOffset, className) {
            this.startOffset = startOffset;
            this.endOffset = endOffset;
            this.className = className;
        }
        return DecorationSegment;
    }());
    exports.DecorationSegment = DecorationSegment;
    var Stack = (function () {
        function Stack() {
            this.stopOffsets = [];
            this.classNames = [];
            this.count = 0;
        }
        Stack.prototype.consumeLowerThan = function (maxStopOffset, nextStartOffset, result) {
            while (this.count > 0 && this.stopOffsets[0] < maxStopOffset) {
                var i = 0;
                // Take all equal stopping offsets
                while (i + 1 < this.count && this.stopOffsets[i] === this.stopOffsets[i + 1]) {
                    i++;
                }
                // Basically we are consuming the first i + 1 elements of the stack
                result.push(new DecorationSegment(nextStartOffset, this.stopOffsets[i], this.classNames.join(' ')));
                nextStartOffset = this.stopOffsets[i] + 1;
                // Consume them
                this.stopOffsets.splice(0, i + 1);
                this.classNames.splice(0, i + 1);
                this.count -= (i + 1);
            }
            if (this.count > 0 && nextStartOffset < maxStopOffset) {
                result.push(new DecorationSegment(nextStartOffset, maxStopOffset - 1, this.classNames.join(' ')));
                nextStartOffset = maxStopOffset;
            }
            return nextStartOffset;
        };
        Stack.prototype.insert = function (stopOffset, className) {
            if (this.count === 0 || this.stopOffsets[this.count - 1] <= stopOffset) {
                // Insert at the end
                this.stopOffsets.push(stopOffset);
                this.classNames.push(className);
            }
            else {
                // Find the insertion position for `stopOffset`
                for (var i = 0; i < this.count; i++) {
                    if (this.stopOffsets[i] >= stopOffset) {
                        this.stopOffsets.splice(i, 0, stopOffset);
                        this.classNames.splice(i, 0, className);
                        break;
                    }
                }
            }
            this.count++;
            return;
        };
        return Stack;
    }());
    var LineDecorationsNormalizer = (function () {
        function LineDecorationsNormalizer() {
        }
        /**
         * Normalize line decorations. Overlapping decorations will generate multiple segments
         */
        LineDecorationsNormalizer.normalize = function (lineNumber, minLineColumn, lineDecorations) {
            var result = [];
            if (lineDecorations.length === 0) {
                return result;
            }
            var stack = new Stack(), nextStartOffset = 0, d, currentStartOffset, currentEndOffset, i, len;
            for (i = 0, len = lineDecorations.length; i < len; i++) {
                d = lineDecorations[i];
                if (d.range.endLineNumber < lineNumber || d.range.startLineNumber > lineNumber) {
                    // Ignore decorations that sit outside this line
                    continue;
                }
                if (d.range.startLineNumber === d.range.endLineNumber && d.range.startColumn === d.range.endColumn) {
                    // Ignore empty range decorations
                    continue;
                }
                currentStartOffset = (d.range.startLineNumber === lineNumber ? d.range.startColumn - 1 : minLineColumn - 1);
                currentEndOffset = (d.range.endLineNumber === lineNumber ? d.range.endColumn - 2 : LineDecorationsNormalizer.MAX_LINE_LENGTH - 1);
                if (currentEndOffset < 0) {
                    // An empty decoration (endColumn === 1)
                    continue;
                }
                nextStartOffset = stack.consumeLowerThan(currentStartOffset, nextStartOffset, result);
                if (stack.count === 0) {
                    nextStartOffset = currentStartOffset;
                }
                stack.insert(currentEndOffset, d.inlineClassName);
            }
            stack.consumeLowerThan(LineDecorationsNormalizer.MAX_LINE_LENGTH, nextStartOffset, result);
            return result;
        };
        /**
         * A number that is guaranteed to be larger than the maximum line column
         */
        LineDecorationsNormalizer.MAX_LINE_LENGTH = 10000000;
        return LineDecorationsNormalizer;
    }());
    exports.LineDecorationsNormalizer = LineDecorationsNormalizer;
});

define(__m[464], __M([0,1,4,24,7]), function (require, exports, range_1, selection_1, editorCommon) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewModelCursors = (function () {
        function ViewModelCursors(configuration, converter) {
            this.configuration = configuration;
            this.converter = converter;
            this.lastCursorPositionChangedEvent = null;
            this.lastCursorSelectionChangedEvent = null;
        }
        ViewModelCursors.prototype.getSelections = function () {
            if (this.lastCursorSelectionChangedEvent) {
                var selections = [];
                selections.push(this.converter.convertModelSelectionToViewSelection(this.lastCursorSelectionChangedEvent.selection));
                for (var i = 0, len = this.lastCursorSelectionChangedEvent.secondarySelections.length; i < len; i++) {
                    selections.push(this.converter.convertModelSelectionToViewSelection(this.lastCursorSelectionChangedEvent.secondarySelections[i]));
                }
                return selections;
            }
            else {
                return [new selection_1.Selection(1, 1, 1, 1)];
            }
        };
        ViewModelCursors.prototype.onCursorPositionChanged = function (e, emit) {
            this.lastCursorPositionChangedEvent = e;
            var position = this.converter.validateViewPosition(e.viewPosition.lineNumber, e.viewPosition.column, e.position), stopRenderingLineAfter = this.configuration.editor.viewInfo.stopRenderingLineAfter;
            // Limit position to be somewhere where it can actually be rendered
            if (stopRenderingLineAfter !== -1 && position.column > stopRenderingLineAfter) {
                position = position.clone();
                position.column = stopRenderingLineAfter;
            }
            var secondaryPositions = [];
            for (var i = 0, len = e.secondaryPositions.length; i < len; i++) {
                secondaryPositions[i] = this.converter.validateViewPosition(e.secondaryViewPositions[i].lineNumber, e.secondaryViewPositions[i].column, e.secondaryPositions[i]);
                // Limit position to be somewhere where it can actually be rendered
                if (stopRenderingLineAfter !== -1 && secondaryPositions[i].column > stopRenderingLineAfter) {
                    secondaryPositions[i] = secondaryPositions[i].clone();
                    secondaryPositions[i].column = stopRenderingLineAfter;
                }
            }
            var newEvent = {
                position: position,
                secondaryPositions: secondaryPositions,
                isInEditableRange: e.isInEditableRange
            };
            emit(editorCommon.ViewEventNames.CursorPositionChangedEvent, newEvent);
        };
        ViewModelCursors.prototype.onCursorSelectionChanged = function (e, emit) {
            this.lastCursorSelectionChangedEvent = e;
            var selection = this.converter.validateViewSelection(e.viewSelection, e.selection);
            var secondarySelections = [];
            for (var i = 0, len = e.secondarySelections.length; i < len; i++) {
                secondarySelections[i] = this.converter.validateViewSelection(e.secondaryViewSelections[i], e.secondarySelections[i]);
            }
            var newEvent = {
                selection: selection,
                secondarySelections: secondarySelections
            };
            emit(editorCommon.ViewEventNames.CursorSelectionChangedEvent, newEvent);
        };
        ViewModelCursors.prototype.onCursorRevealRange = function (e, emit) {
            var viewRange = null;
            if (e.viewRange) {
                var viewStartRange = this.converter.validateViewPosition(e.viewRange.startLineNumber, e.viewRange.startColumn, e.range.getStartPosition());
                var viewEndRange = this.converter.validateViewPosition(e.viewRange.endLineNumber, e.viewRange.endColumn, e.range.getEndPosition());
                viewRange = new range_1.Range(viewStartRange.lineNumber, viewStartRange.column, viewEndRange.lineNumber, viewEndRange.column);
            }
            else {
                viewRange = this.converter.convertModelRangeToViewRange(e.range);
            }
            var newEvent = {
                range: viewRange,
                verticalType: e.verticalType,
                revealHorizontal: e.revealHorizontal
            };
            emit(editorCommon.ViewEventNames.RevealRangeEvent, newEvent);
        };
        ViewModelCursors.prototype.onCursorScrollRequest = function (e, emit) {
            var newEvent = {
                deltaLines: e.deltaLines
            };
            emit(editorCommon.ViewEventNames.ScrollRequestEvent, newEvent);
        };
        ViewModelCursors.prototype.onLineMappingChanged = function (emit) {
            if (this.lastCursorPositionChangedEvent) {
                this.onCursorPositionChanged(this.lastCursorPositionChangedEvent, emit);
            }
            if (this.lastCursorSelectionChangedEvent) {
                this.onCursorSelectionChanged(this.lastCursorSelectionChangedEvent, emit);
            }
        };
        return ViewModelCursors;
    }());
    exports.ViewModelCursors = ViewModelCursors;
});

define(__m[467], __M([0,1,4,7,116]), function (require, exports, range_1, editorCommon, viewModel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewModelDecoration = (function () {
        function ViewModelDecoration(source, range) {
            this.id = source.id;
            this.options = source.options;
            this.ownerId = source.ownerId;
            this.modelRange = source.range;
            this.range = range;
        }
        return ViewModelDecoration;
    }());
    var ViewModelDecorations = (function () {
        function ViewModelDecorations(editorId, configuration, converter) {
            this.editorId = editorId;
            this.configuration = configuration;
            this.converter = converter;
            this.decorations = [];
            this._clearCachedModelDecorationsResolver();
        }
        ViewModelDecorations.prototype._clearCachedModelDecorationsResolver = function () {
            this._cachedModelDecorationsResolver = null;
            this._cachedModelDecorationsResolverStartLineNumber = 0;
            this._cachedModelDecorationsResolverEndLineNumber = 0;
        };
        ViewModelDecorations.prototype.dispose = function () {
            this.converter = null;
            this.decorations = null;
            this._clearCachedModelDecorationsResolver();
        };
        ViewModelDecorations.compareDecorations = function (a, b) {
            return range_1.Range.compareRangesUsingStarts(a.range, b.range);
        };
        ViewModelDecorations.prototype.reset = function (model) {
            var decorations = model.getAllDecorations(this.editorId, this.configuration.editor.readOnly), i, len, theirDecoration, myDecoration;
            this.decorations = [];
            for (i = 0, len = decorations.length; i < len; i++) {
                theirDecoration = decorations[i];
                myDecoration = new ViewModelDecoration(theirDecoration, this.converter.convertModelRangeToViewRange(theirDecoration.range, theirDecoration.options.isWholeLine));
                this.decorations[i] = myDecoration;
            }
            this._clearCachedModelDecorationsResolver();
            this.decorations.sort(ViewModelDecorations.compareDecorations);
        };
        ViewModelDecorations.prototype.onModelDecorationsChanged = function (e, emit) {
            var somethingChanged = false, inlineDecorationsChanged = false;
            // -----------------------------------
            // Interpret addedOrChangedDecorations
            var removedMap = {}, addedOrChangedMap = {}, theirDecoration, i, skipValidation = this.configuration.editor.readOnly, len;
            for (i = 0, len = e.addedOrChangedDecorations.length; i < len; i++) {
                theirDecoration = e.addedOrChangedDecorations[i];
                if (skipValidation && theirDecoration.isForValidation) {
                    continue;
                }
                if (theirDecoration.ownerId && theirDecoration.ownerId !== this.editorId) {
                    continue;
                }
                addedOrChangedMap[theirDecoration.id] = theirDecoration;
            }
            for (i = 0, len = e.removedDecorations.length; i < len; i++) {
                removedMap[e.removedDecorations[i]] = true;
            }
            // Interpret changed decorations
            var usedMap = {}, myDecoration;
            for (i = 0, len = this.decorations.length; i < len; i++) {
                myDecoration = this.decorations[i];
                if (addedOrChangedMap.hasOwnProperty(myDecoration.id)) {
                    usedMap[myDecoration.id] = true;
                    theirDecoration = addedOrChangedMap[myDecoration.id];
                    myDecoration.options = theirDecoration.options;
                    myDecoration.modelRange = theirDecoration.range;
                    myDecoration.range = this.converter.convertModelRangeToViewRange(theirDecoration.range, theirDecoration.options.isWholeLine);
                    //				console.log(theirDecoration.range.toString() + '--->' + myDecoration.range.toString());
                    inlineDecorationsChanged = inlineDecorationsChanged || hasInlineChanges(myDecoration);
                    somethingChanged = true;
                }
                if (removedMap.hasOwnProperty(myDecoration.id)) {
                    inlineDecorationsChanged = inlineDecorationsChanged || hasInlineChanges(this.decorations[i]);
                    this.decorations.splice(i, 1);
                    len--;
                    i--;
                    somethingChanged = true;
                }
            }
            // Interpret new decorations
            var keys = Object.keys(addedOrChangedMap);
            for (var i_1 = 0, len_1 = keys.length; i_1 < len_1; i_1++) {
                var id = keys[i_1];
                if (!usedMap.hasOwnProperty(id)) {
                    theirDecoration = addedOrChangedMap[id];
                    myDecoration = new ViewModelDecoration(theirDecoration, this.converter.convertModelRangeToViewRange(theirDecoration.range, theirDecoration.options.isWholeLine));
                    //				console.log(theirDecoration.range.toString() + '--->' + myDecoration.range.toString());
                    this.decorations.push(myDecoration);
                    inlineDecorationsChanged = inlineDecorationsChanged || hasInlineChanges(myDecoration);
                    somethingChanged = true;
                }
            }
            if (somethingChanged) {
                this._clearCachedModelDecorationsResolver();
                this.decorations.sort(ViewModelDecorations.compareDecorations);
                var newEvent = {
                    inlineDecorationsChanged: inlineDecorationsChanged
                };
                emit(editorCommon.ViewEventNames.DecorationsChangedEvent, newEvent);
            }
        };
        ViewModelDecorations.prototype.onLineMappingChanged = function (emit) {
            var decorations = this.decorations, d, i, newRange, somethingChanged = false, inlineDecorationsChanged = false, len;
            for (i = 0, len = decorations.length; i < len; i++) {
                d = decorations[i];
                newRange = this.converter.convertModelRangeToViewRange(d.modelRange, d.options.isWholeLine);
                if (!inlineDecorationsChanged && hasInlineChanges(d) && !range_1.Range.equalsRange(newRange, d.range)) {
                    inlineDecorationsChanged = true;
                }
                if (!somethingChanged && !range_1.Range.equalsRange(newRange, d.range)) {
                    somethingChanged = true;
                }
                d.range = newRange;
            }
            if (somethingChanged) {
                this._clearCachedModelDecorationsResolver();
                this.decorations.sort(ViewModelDecorations.compareDecorations);
                var newEvent = {
                    inlineDecorationsChanged: inlineDecorationsChanged
                };
                emit(editorCommon.ViewEventNames.DecorationsChangedEvent, newEvent);
            }
        };
        ViewModelDecorations.prototype.getAllDecorations = function () {
            return this.decorations;
        };
        ViewModelDecorations.prototype.getDecorationsViewportData = function (startLineNumber, endLineNumber) {
            var cacheIsValid = true;
            cacheIsValid = cacheIsValid && (this._cachedModelDecorationsResolver !== null);
            cacheIsValid = cacheIsValid && (this._cachedModelDecorationsResolverStartLineNumber === startLineNumber);
            cacheIsValid = cacheIsValid && (this._cachedModelDecorationsResolverEndLineNumber === endLineNumber);
            if (!cacheIsValid) {
                this._cachedModelDecorationsResolver = this._getDecorationsViewportData(startLineNumber, endLineNumber);
                this._cachedModelDecorationsResolverStartLineNumber = startLineNumber;
                this._cachedModelDecorationsResolverEndLineNumber = endLineNumber;
            }
            return this._cachedModelDecorationsResolver;
        };
        ViewModelDecorations.prototype._getDecorationsViewportData = function (startLineNumber, endLineNumber) {
            var decorationsInViewport = [], inlineDecorations = [], j, intersectedStartLineNumber, intersectedEndLineNumber, decorations = this.decorations, d, r, i, len;
            for (j = startLineNumber; j <= endLineNumber; j++) {
                inlineDecorations[j - startLineNumber] = [];
            }
            for (i = 0, len = decorations.length; i < len; i++) {
                d = decorations[i];
                r = d.range;
                if (r.startLineNumber > endLineNumber) {
                    // Decorations are sorted ascending by line number, it is safe to stop now
                    break;
                }
                if (r.endLineNumber < startLineNumber) {
                    continue;
                }
                decorationsInViewport.push(d);
                if (d.options.inlineClassName) {
                    var inlineDecoration = new viewModel_1.InlineDecoration(d.range, d.options.inlineClassName);
                    intersectedStartLineNumber = Math.max(startLineNumber, r.startLineNumber);
                    intersectedEndLineNumber = Math.min(endLineNumber, r.endLineNumber);
                    for (j = intersectedStartLineNumber; j <= intersectedEndLineNumber; j++) {
                        inlineDecorations[j - startLineNumber].push(inlineDecoration);
                    }
                }
                if (d.options.beforeContentClassName && r.startLineNumber >= startLineNumber) {
                    // TODO: What happens if the startLineNumber and startColumn is at the end of a line?
                    var inlineDecoration = new viewModel_1.InlineDecoration(new range_1.Range(r.startLineNumber, r.startColumn, r.startLineNumber, r.startColumn + 1), d.options.beforeContentClassName);
                    inlineDecorations[r.startLineNumber - startLineNumber].push(inlineDecoration);
                }
                if (d.options.afterContentClassName && r.endLineNumber <= endLineNumber) {
                    if (r.endColumn > 1) {
                        var inlineDecoration = new viewModel_1.InlineDecoration(new range_1.Range(r.endLineNumber, r.endColumn - 1, r.endLineNumber, r.endColumn), d.options.afterContentClassName);
                        inlineDecorations[r.endLineNumber - startLineNumber].push(inlineDecoration);
                    }
                }
            }
            return {
                decorations: decorationsInViewport,
                inlineDecorations: inlineDecorations
            };
        };
        return ViewModelDecorations;
    }());
    exports.ViewModelDecorations = ViewModelDecorations;
    function hasInlineChanges(decoration) {
        var options = decoration.options;
        return !!(options.inlineClassName || options.beforeContentClassName || options.afterContentClassName);
    }
});

define(__m[473], __M([0,1,4]), function (require, exports, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MoveCarretCommand = (function () {
        function MoveCarretCommand(selection, isMovingLeft) {
            this._selection = selection;
            this._isMovingLeft = isMovingLeft;
        }
        MoveCarretCommand.prototype.getEditOperations = function (model, builder) {
            var s = this._selection;
            this._selectionId = builder.trackSelection(s);
            if (s.startLineNumber !== s.endLineNumber) {
                return;
            }
            if (this._isMovingLeft && s.startColumn === 0) {
                return;
            }
            else if (!this._isMovingLeft && s.endColumn === model.getLineMaxColumn(s.startLineNumber)) {
                return;
            }
            var lineNumber = s.selectionStartLineNumber;
            var lineContent = model.getLineContent(lineNumber);
            var left;
            var middle;
            var right;
            if (this._isMovingLeft) {
                left = lineContent.substring(0, s.startColumn - 2);
                middle = lineContent.substring(s.startColumn - 1, s.endColumn - 1);
                right = lineContent.substring(s.startColumn - 2, s.startColumn - 1) + lineContent.substring(s.endColumn - 1);
            }
            else {
                left = lineContent.substring(0, s.startColumn - 1) + lineContent.substring(s.endColumn - 1, s.endColumn);
                middle = lineContent.substring(s.startColumn - 1, s.endColumn - 1);
                right = lineContent.substring(s.endColumn);
            }
            var newLineContent = left + middle + right;
            builder.addEditOperation(new range_1.Range(lineNumber, 1, lineNumber, model.getLineMaxColumn(lineNumber)), null);
            builder.addEditOperation(new range_1.Range(lineNumber, 1, lineNumber, 1), newLineContent);
            this._cutStartIndex = s.startColumn + (this._isMovingLeft ? -1 : 1);
            this._cutEndIndex = this._cutStartIndex + s.endColumn - s.startColumn;
            this._moved = true;
        };
        MoveCarretCommand.prototype.computeCursorState = function (model, helper) {
            var result = helper.getTrackedSelection(this._selectionId);
            if (this._moved) {
                result = result.setStartPosition(result.startLineNumber, this._cutStartIndex);
                result = result.setEndPosition(result.startLineNumber, this._cutEndIndex);
            }
            return result;
        };
        return MoveCarretCommand;
    }());
    exports.MoveCarretCommand = MoveCarretCommand;
});

define(__m[482], __M([0,1,7]), function (require, exports, editorCommon) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var FindDecorations = (function () {
        function FindDecorations(editor) {
            this._editor = editor;
            this._decorations = [];
            this._findScopeDecorationId = null;
            this._highlightedDecorationId = null;
            this._startPosition = this._editor.getPosition();
        }
        FindDecorations.prototype.dispose = function () {
            this._editor.deltaDecorations(this._allDecorations(), []);
            this._editor = null;
            this._decorations = [];
            this._findScopeDecorationId = null;
            this._highlightedDecorationId = null;
            this._startPosition = null;
        };
        FindDecorations.prototype.reset = function () {
            this._decorations = [];
            this._findScopeDecorationId = null;
            this._highlightedDecorationId = null;
        };
        FindDecorations.prototype.getCount = function () {
            return this._decorations.length;
        };
        FindDecorations.prototype.getFindScope = function () {
            if (this._findScopeDecorationId) {
                return this._editor.getModel().getDecorationRange(this._findScopeDecorationId);
            }
            return null;
        };
        FindDecorations.prototype.getStartPosition = function () {
            return this._startPosition;
        };
        FindDecorations.prototype.setStartPosition = function (newStartPosition) {
            this._startPosition = newStartPosition;
            this.setCurrentFindMatch(null);
        };
        FindDecorations.prototype.getCurrentMatchesPosition = function (desiredRange) {
            for (var i = 0, len = this._decorations.length; i < len; i++) {
                var range = this._editor.getModel().getDecorationRange(this._decorations[i]);
                if (desiredRange.equalsRange(range)) {
                    return (i + 1);
                }
            }
            return 1;
        };
        FindDecorations.prototype.setCurrentFindMatch = function (nextMatch) {
            var _this = this;
            var newCurrentDecorationId = null;
            var matchPosition = 0;
            if (nextMatch) {
                for (var i = 0, len = this._decorations.length; i < len; i++) {
                    var range = this._editor.getModel().getDecorationRange(this._decorations[i]);
                    if (nextMatch.equalsRange(range)) {
                        newCurrentDecorationId = this._decorations[i];
                        matchPosition = (i + 1);
                        break;
                    }
                }
            }
            if (this._highlightedDecorationId !== null || newCurrentDecorationId !== null) {
                this._editor.changeDecorations(function (changeAccessor) {
                    if (_this._highlightedDecorationId !== null) {
                        changeAccessor.changeDecorationOptions(_this._highlightedDecorationId, FindDecorations.createFindMatchDecorationOptions(false));
                        _this._highlightedDecorationId = null;
                    }
                    if (newCurrentDecorationId !== null) {
                        _this._highlightedDecorationId = newCurrentDecorationId;
                        changeAccessor.changeDecorationOptions(_this._highlightedDecorationId, FindDecorations.createFindMatchDecorationOptions(true));
                    }
                });
            }
            return matchPosition;
        };
        FindDecorations.prototype.set = function (matches, findScope) {
            var newDecorations = matches.map(function (match) {
                return {
                    range: match,
                    options: FindDecorations.createFindMatchDecorationOptions(false)
                };
            });
            if (findScope) {
                newDecorations.unshift({
                    range: findScope,
                    options: FindDecorations.createFindScopeDecorationOptions()
                });
            }
            var tmpDecorations = this._editor.deltaDecorations(this._allDecorations(), newDecorations);
            if (findScope) {
                this._findScopeDecorationId = tmpDecorations.shift();
            }
            else {
                this._findScopeDecorationId = null;
            }
            this._decorations = tmpDecorations;
            this._highlightedDecorationId = null;
        };
        FindDecorations.prototype._allDecorations = function () {
            var result = [];
            result = result.concat(this._decorations);
            if (this._findScopeDecorationId) {
                result.push(this._findScopeDecorationId);
            }
            return result;
        };
        FindDecorations.createFindMatchDecorationOptions = function (isCurrent) {
            return {
                stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                className: isCurrent ? 'currentFindMatch' : 'findMatch',
                overviewRuler: {
                    color: 'rgba(246, 185, 77, 0.7)',
                    darkColor: 'rgba(246, 185, 77, 0.7)',
                    position: editorCommon.OverviewRulerLane.Center
                }
            };
        };
        FindDecorations.createFindScopeDecorationOptions = function () {
            return {
                className: 'findScope',
                isWholeLine: true
            };
        };
        return FindDecorations;
    }());
    exports.FindDecorations = FindDecorations;
});

define(__m[484], __M([0,1,4]), function (require, exports, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ReplaceAllCommand = (function () {
        function ReplaceAllCommand(editorSelection, ranges, replaceStrings) {
            this._editorSelection = editorSelection;
            this._ranges = ranges;
            this._replaceStrings = replaceStrings;
        }
        ReplaceAllCommand.prototype.getEditOperations = function (model, builder) {
            if (this._ranges.length > 0) {
                // Collect all edit operations
                var ops = [];
                for (var i = 0; i < this._ranges.length; i++) {
                    ops.push({
                        range: this._ranges[i],
                        text: this._replaceStrings[i]
                    });
                }
                // Sort them in ascending order by range starts
                ops.sort(function (o1, o2) {
                    return range_1.Range.compareRangesUsingStarts(o1.range, o2.range);
                });
                // Merge operations that touch each other
                var resultOps = [];
                var previousOp = ops[0];
                for (var i = 1; i < ops.length; i++) {
                    if (previousOp.range.endLineNumber === ops[i].range.startLineNumber && previousOp.range.endColumn === ops[i].range.startColumn) {
                        // These operations are one after another and can be merged
                        previousOp.range = previousOp.range.plusRange(ops[i].range);
                        previousOp.text = previousOp.text + ops[i].text;
                    }
                    else {
                        resultOps.push(previousOp);
                        previousOp = ops[i];
                    }
                }
                resultOps.push(previousOp);
                for (var i = 0; i < resultOps.length; i++) {
                    builder.addEditOperation(resultOps[i].range, resultOps[i].text);
                }
            }
            this._trackedEditorSelectionId = builder.trackSelection(this._editorSelection);
        };
        ReplaceAllCommand.prototype.computeCursorState = function (model, helper) {
            return helper.getTrackedSelection(this._trackedEditorSelectionId);
        };
        return ReplaceAllCommand;
    }());
    exports.ReplaceAllCommand = ReplaceAllCommand;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[488], __M([0,1]), function (require, exports) {
    'use strict';
    function computeRanges(model, tabSize, minimumRangeSize) {
        if (minimumRangeSize === void 0) { minimumRangeSize = 1; }
        var result = [];
        var previousRegions = [];
        previousRegions.push({ indent: -1, line: model.getLineCount() + 1 }); // sentinel, to make sure there's at least one entry
        for (var line = model.getLineCount(); line > 0; line--) {
            var indent = computeIndentLevel(model.getLineContent(line), tabSize);
            if (indent === -1) {
                continue; // only whitespace
            }
            var previous = previousRegions[previousRegions.length - 1];
            if (previous.indent > indent) {
                // discard all regions with larger indent
                do {
                    previousRegions.pop();
                    previous = previousRegions[previousRegions.length - 1];
                } while (previous.indent > indent);
                // new folding range
                var endLineNumber = previous.line - 1;
                if (endLineNumber - line >= minimumRangeSize) {
                    result.push({ startLineNumber: line, endLineNumber: endLineNumber, indent: indent });
                }
            }
            if (previous.indent === indent) {
                previous.line = line;
            }
            else {
                // new region with a bigger indent
                previousRegions.push({ indent: indent, line: line });
            }
        }
        return result.reverse();
    }
    exports.computeRanges = computeRanges;
    function computeIndentLevel(line, tabSize) {
        var i = 0;
        var indent = 0;
        while (i < line.length) {
            var ch = line.charAt(i);
            if (ch === ' ') {
                indent++;
            }
            else if (ch === '\t') {
                indent = indent - indent % tabSize + tabSize;
            }
            else {
                break;
            }
            i++;
        }
        if (i === line.length) {
            return -1; // line only consists of whitespace
        }
        return indent;
    }
    exports.computeIndentLevel = computeIndentLevel;
    /**
     * Limits the number of folding ranges by removing ranges with larger indent levels
     */
    function limitByIndent(ranges, maxEntries) {
        if (ranges.length <= maxEntries) {
            return ranges;
        }
        var indentOccurrences = [];
        ranges.forEach(function (r) {
            if (r.indent < 1000) {
                indentOccurrences[r.indent] = (indentOccurrences[r.indent] || 0) + 1;
            }
        });
        var maxIndent = indentOccurrences.length;
        for (var i = 0; i < indentOccurrences.length; i++) {
            if (indentOccurrences[i]) {
                maxEntries -= indentOccurrences[i];
                if (maxEntries < 0) {
                    maxIndent = i;
                    break;
                }
            }
        }
        return ranges.filter(function (r) { return r.indent < maxIndent; });
    }
    exports.limitByIndent = limitByIndent;
});

define(__m[494], __M([0,1,10,4]), function (require, exports, strings, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditOperationsCommand = (function () {
        function EditOperationsCommand(edits, initialSelection) {
            this._edits = edits;
            this._initialSelection = initialSelection;
        }
        EditOperationsCommand.prototype.getEditOperations = function (model, builder) {
            this._edits
                .map(function (edit) { return EditOperationsCommand.trimEdit(edit, model); })
                .filter(function (edit) { return edit !== null; }) // produced above in case the edit.text is identical to the existing text
                .forEach(function (edit) { return builder.addEditOperation(range_1.Range.lift(edit.range), edit.text); });
            var selectionIsSet = false;
            if (Array.isArray(this._edits) && this._edits.length === 1 && this._initialSelection.isEmpty()) {
                if (this._edits[0].range.startColumn === this._initialSelection.endColumn &&
                    this._edits[0].range.startLineNumber === this._initialSelection.endLineNumber) {
                    selectionIsSet = true;
                    this._selectionId = builder.trackSelection(this._initialSelection, true);
                }
                else if (this._edits[0].range.endColumn === this._initialSelection.startColumn &&
                    this._edits[0].range.endLineNumber === this._initialSelection.startLineNumber) {
                    selectionIsSet = true;
                    this._selectionId = builder.trackSelection(this._initialSelection, false);
                }
            }
            if (!selectionIsSet) {
                this._selectionId = builder.trackSelection(this._initialSelection);
            }
        };
        EditOperationsCommand.prototype.computeCursorState = function (model, helper) {
            return helper.getTrackedSelection(this._selectionId);
        };
        EditOperationsCommand.fixLineTerminators = function (edit, model) {
            edit.text = edit.text.replace(/\r\n|\r|\n/g, model.getEOL());
        };
        /**
         * This is used to minimize the edits by removing changes that appear on the edges of the range which are identical
         * to the current text.
         *
         * The reason this was introduced is to allow better selection tracking of the current cursor and solve
         * bug #15108. There the cursor was jumping since the tracked selection was in the middle of the range edit
         * and was lost.
         */
        EditOperationsCommand.trimEdit = function (edit, model) {
            this.fixLineTerminators(edit, model);
            return this._trimEdit(model.validateRange(edit.range), edit.text, edit.forceMoveMarkers, model);
        };
        EditOperationsCommand._trimEdit = function (editRange, editText, editForceMoveMarkers, model) {
            var currentText = model.getValueInRange(editRange);
            // Find the equal characters in the front
            var commonPrefixLength = strings.commonPrefixLength(editText, currentText);
            // If the two strings are identical, return no edit (no-op)
            if (commonPrefixLength === currentText.length && commonPrefixLength === editText.length) {
                return null;
            }
            if (commonPrefixLength > 0) {
                // Apply front trimming
                var newStartPosition = model.modifyPosition(editRange.getStartPosition(), commonPrefixLength);
                editRange = new range_1.Range(newStartPosition.lineNumber, newStartPosition.column, editRange.endLineNumber, editRange.endColumn);
                editText = editText.substring(commonPrefixLength);
                currentText = currentText.substr(commonPrefixLength);
            }
            // Find the equal characters in the rear
            var commonSuffixLength = strings.commonSuffixLength(editText, currentText);
            if (commonSuffixLength > 0) {
                // Apply rear trimming
                var newEndPosition = model.modifyPosition(editRange.getEndPosition(), -commonSuffixLength);
                editRange = new range_1.Range(editRange.startLineNumber, editRange.startColumn, newEndPosition.lineNumber, newEndPosition.column);
                editText = editText.substring(0, editText.length - commonSuffixLength);
                currentText = currentText.substring(0, currentText.length - commonSuffixLength);
            }
            return {
                text: editText,
                range: editRange,
                forceMoveMarkers: editForceMoveMarkers
            };
        };
        return EditOperationsCommand;
    }());
    exports.EditOperationsCommand = EditOperationsCommand;
});

define(__m[498], __M([0,1,24]), function (require, exports, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var InPlaceReplaceCommand = (function () {
        function InPlaceReplaceCommand(editRange, originalSelection, text) {
            this._editRange = editRange;
            this._originalSelection = originalSelection;
            this._text = text;
        }
        InPlaceReplaceCommand.prototype.getEditOperations = function (model, builder) {
            builder.addEditOperation(this._editRange, this._text);
        };
        InPlaceReplaceCommand.prototype.computeCursorState = function (model, helper) {
            var inverseEditOperations = helper.getInverseEditOperations();
            var srcRange = inverseEditOperations[0].range;
            if (!this._originalSelection.isEmpty()) {
                // Preserve selection and extends to typed text
                return new selection_1.Selection(srcRange.endLineNumber, srcRange.endColumn - this._text.length, srcRange.endLineNumber, srcRange.endColumn);
            }
            return new selection_1.Selection(srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn), srcRange.endLineNumber, Math.min(this._originalSelection.positionColumn, srcRange.endColumn));
        };
        return InPlaceReplaceCommand;
    }());
    exports.InPlaceReplaceCommand = InPlaceReplaceCommand;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[499], __M([0,1,4]), function (require, exports, range_1) {
    "use strict";
    function getIndentationEditOperations(model, builder, tabSize, tabsToSpaces) {
        if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
            // Model is empty
            return;
        }
        var spaces = '';
        for (var i = 0; i < tabSize; i++) {
            spaces += ' ';
        }
        var content = model.getLinesContent();
        for (var i = 0; i < content.length; i++) {
            var lastIndentationColumn = model.getLineFirstNonWhitespaceColumn(i + 1);
            if (lastIndentationColumn === 0) {
                lastIndentationColumn = model.getLineMaxColumn(i + 1);
            }
            var text = (tabsToSpaces ? content[i].substr(0, lastIndentationColumn).replace(/\t/ig, spaces) :
                content[i].substr(0, lastIndentationColumn).replace(new RegExp(spaces, 'gi'), '\t')) +
                content[i].substr(lastIndentationColumn);
            builder.addEditOperation(new range_1.Range(i + 1, 1, i + 1, model.getLineMaxColumn(i + 1)), text);
        }
    }
    var IndentationToSpacesCommand = (function () {
        function IndentationToSpacesCommand(selection, tabSize) {
            this.selection = selection;
            this.tabSize = tabSize;
        }
        IndentationToSpacesCommand.prototype.getEditOperations = function (model, builder) {
            this.selectionId = builder.trackSelection(this.selection);
            getIndentationEditOperations(model, builder, this.tabSize, true);
        };
        IndentationToSpacesCommand.prototype.computeCursorState = function (model, helper) {
            return helper.getTrackedSelection(this.selectionId);
        };
        return IndentationToSpacesCommand;
    }());
    exports.IndentationToSpacesCommand = IndentationToSpacesCommand;
    var IndentationToTabsCommand = (function () {
        function IndentationToTabsCommand(selection, tabSize) {
            this.selection = selection;
            this.tabSize = tabSize;
        }
        IndentationToTabsCommand.prototype.getEditOperations = function (model, builder) {
            this.selectionId = builder.trackSelection(this.selection);
            getIndentationEditOperations(model, builder, this.tabSize, false);
        };
        IndentationToTabsCommand.prototype.computeCursorState = function (model, helper) {
            return helper.getTrackedSelection(this.selectionId);
        };
        return IndentationToTabsCommand;
    }());
    exports.IndentationToTabsCommand = IndentationToTabsCommand;
});

define(__m[500], __M([0,1,4,24]), function (require, exports, range_1, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CopyLinesCommand = (function () {
        function CopyLinesCommand(selection, isCopyingDown) {
            this._selection = selection;
            this._isCopyingDown = isCopyingDown;
        }
        CopyLinesCommand.prototype.getEditOperations = function (model, builder) {
            var s = this._selection;
            this._startLineNumberDelta = 0;
            this._endLineNumberDelta = 0;
            if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
                this._endLineNumberDelta = 1;
                s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
            }
            var sourceLines = [];
            for (var i = s.startLineNumber; i <= s.endLineNumber; i++) {
                sourceLines.push(model.getLineContent(i));
            }
            var sourceText = sourceLines.join('\n');
            if (sourceText === '') {
                // Duplicating empty line
                if (this._isCopyingDown) {
                    this._startLineNumberDelta++;
                    this._endLineNumberDelta++;
                }
            }
            if (!this._isCopyingDown) {
                builder.addEditOperation(new range_1.Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\n' + sourceText);
            }
            else {
                builder.addEditOperation(new range_1.Range(s.startLineNumber, 1, s.startLineNumber, 1), sourceText + '\n');
            }
            this._selectionId = builder.trackSelection(s);
            this._selectionDirection = this._selection.getDirection();
        };
        CopyLinesCommand.prototype.computeCursorState = function (model, helper) {
            var result = helper.getTrackedSelection(this._selectionId);
            if (this._startLineNumberDelta !== 0 || this._endLineNumberDelta !== 0) {
                var startLineNumber = result.startLineNumber, startColumn = result.startColumn, endLineNumber = result.endLineNumber, endColumn = result.endColumn;
                if (this._startLineNumberDelta !== 0) {
                    startLineNumber = startLineNumber + this._startLineNumberDelta;
                    startColumn = 1;
                }
                if (this._endLineNumberDelta !== 0) {
                    endLineNumber = endLineNumber + this._endLineNumberDelta;
                    endColumn = 1;
                }
                result = selection_1.Selection.createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, this._selectionDirection);
            }
            return result;
        };
        return CopyLinesCommand;
    }());
    exports.CopyLinesCommand = CopyLinesCommand;
});

define(__m[501], __M([0,1,4,24]), function (require, exports, range_1, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var DeleteLinesCommand = (function () {
        function DeleteLinesCommand(startLineNumber, endLineNumber, restoreCursorToColumn) {
            this.startLineNumber = startLineNumber;
            this.endLineNumber = endLineNumber;
            this.restoreCursorToColumn = restoreCursorToColumn;
        }
        DeleteLinesCommand.createFromSelection = function (selection) {
            var endLineNumber = selection.endLineNumber;
            if (selection.startLineNumber < selection.endLineNumber && selection.endColumn === 1) {
                endLineNumber -= 1;
            }
            return new DeleteLinesCommand(selection.startLineNumber, endLineNumber, selection.positionColumn);
        };
        DeleteLinesCommand.prototype.getEditOperations = function (model, builder) {
            if (model.getLineCount() === 1 && model.getLineMaxColumn(1) === 1) {
                // Model is empty
                return;
            }
            var startLineNumber = this.startLineNumber;
            var endLineNumber = this.endLineNumber;
            var startColumn = 1;
            var endColumn = model.getLineMaxColumn(endLineNumber);
            if (endLineNumber < model.getLineCount()) {
                endLineNumber += 1;
                endColumn = 1;
            }
            else if (startLineNumber > 1) {
                startLineNumber -= 1;
                startColumn = model.getLineMaxColumn(startLineNumber);
            }
            builder.addEditOperation(new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn), null);
        };
        DeleteLinesCommand.prototype.computeCursorState = function (model, helper) {
            var inverseEditOperations = helper.getInverseEditOperations();
            var srcRange = inverseEditOperations[0].range;
            return new selection_1.Selection(srcRange.endLineNumber, this.restoreCursorToColumn, srcRange.endLineNumber, this.restoreCursorToColumn);
        };
        return DeleteLinesCommand;
    }());
    exports.DeleteLinesCommand = DeleteLinesCommand;
});

define(__m[502], __M([0,1,4,24]), function (require, exports, range_1, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MoveLinesCommand = (function () {
        function MoveLinesCommand(selection, isMovingDown) {
            this._selection = selection;
            this._isMovingDown = isMovingDown;
        }
        MoveLinesCommand.prototype.getEditOperations = function (model, builder) {
            var modelLineCount = model.getLineCount();
            if (this._isMovingDown && this._selection.endLineNumber === modelLineCount) {
                return;
            }
            if (!this._isMovingDown && this._selection.startLineNumber === 1) {
                return;
            }
            this._moveEndPositionDown = false;
            var s = this._selection;
            if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
                this._moveEndPositionDown = true;
                s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
            }
            if (s.startLineNumber === s.endLineNumber && model.getLineMaxColumn(s.startLineNumber) === 1) {
                // Current line is empty
                var lineNumber = s.startLineNumber;
                var otherLineNumber = (this._isMovingDown ? lineNumber + 1 : lineNumber - 1);
                if (model.getLineMaxColumn(otherLineNumber) === 1) {
                    // Other line number is empty too, so no editing is needed
                    // Add a no-op to force running by the model
                    builder.addEditOperation(new range_1.Range(1, 1, 1, 1), null);
                }
                else {
                    // Type content from other line number on line number
                    builder.addEditOperation(new range_1.Range(lineNumber, 1, lineNumber, 1), model.getLineContent(otherLineNumber));
                    // Remove content from other line number
                    builder.addEditOperation(new range_1.Range(otherLineNumber, 1, otherLineNumber, model.getLineMaxColumn(otherLineNumber)), null);
                }
                // Track selection at the other line number
                s = new selection_1.Selection(otherLineNumber, 1, otherLineNumber, 1);
            }
            else {
                var movingLineNumber, movingLineText;
                if (this._isMovingDown) {
                    movingLineNumber = s.endLineNumber + 1;
                    movingLineText = model.getLineContent(movingLineNumber);
                    // Delete line that needs to be moved
                    builder.addEditOperation(new range_1.Range(movingLineNumber - 1, model.getLineMaxColumn(movingLineNumber - 1), movingLineNumber, model.getLineMaxColumn(movingLineNumber)), null);
                    // Insert line that needs to be moved before
                    builder.addEditOperation(new range_1.Range(s.startLineNumber, 1, s.startLineNumber, 1), movingLineText + '\n');
                }
                else {
                    movingLineNumber = s.startLineNumber - 1;
                    movingLineText = model.getLineContent(movingLineNumber);
                    // Delete line that needs to be moved
                    builder.addEditOperation(new range_1.Range(movingLineNumber, 1, movingLineNumber + 1, 1), null);
                    // Insert line that needs to be moved after
                    builder.addEditOperation(new range_1.Range(s.endLineNumber, model.getLineMaxColumn(s.endLineNumber), s.endLineNumber, model.getLineMaxColumn(s.endLineNumber)), '\n' + movingLineText);
                }
            }
            this._selectionId = builder.trackSelection(s);
        };
        MoveLinesCommand.prototype.computeCursorState = function (model, helper) {
            var result = helper.getTrackedSelection(this._selectionId);
            if (this._moveEndPositionDown) {
                result = result.setEndPosition(result.endLineNumber + 1, 1);
            }
            return result;
        };
        return MoveLinesCommand;
    }());
    exports.MoveLinesCommand = MoveLinesCommand;
});

define(__m[505], __M([0,1,62,4]), function (require, exports, editOperation_1, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var SortLinesCommand = (function () {
        function SortLinesCommand(selection, descending) {
            this.selection = selection;
            this.descending = descending;
        }
        SortLinesCommand.prototype.getEditOperations = function (model, builder) {
            var op = sortLines(model, this.selection, this.descending);
            if (op) {
                builder.addEditOperation(op.range, op.text);
            }
            this.selectionId = builder.trackSelection(this.selection);
        };
        SortLinesCommand.prototype.computeCursorState = function (model, helper) {
            return helper.getTrackedSelection(this.selectionId);
        };
        return SortLinesCommand;
    }());
    exports.SortLinesCommand = SortLinesCommand;
    /**
     * Generate commands for sorting lines on a model.
     */
    function sortLines(model, selection, descending) {
        var startLineNumber = selection.startLineNumber;
        var endLineNumber = selection.endLineNumber;
        if (selection.endColumn === 1) {
            endLineNumber--;
        }
        // Nothing to sort if user didn't select anything.
        if (startLineNumber >= endLineNumber) {
            return null;
        }
        var linesToSort = [];
        // Get the contents of the selection to be sorted.
        for (var lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
            linesToSort.push(model.getLineContent(lineNumber));
        }
        var sorted = linesToSort.sort(function (a, b) {
            return a.toLowerCase().localeCompare(b.toLowerCase());
        });
        // If descending, reverse the order.
        if (descending === true) {
            sorted = sorted.reverse();
        }
        return editOperation_1.EditOperation.replace(new range_1.Range(startLineNumber, 1, endLineNumber, model.getLineMaxColumn(endLineNumber)), sorted.join('\n'));
    }
    exports.sortLines = sortLines;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[506], __M([0,1,240]), function (require, exports) {
    'use strict';
});

define(__m[510], __M([5,6]), function(nls, data) { return nls.create("vs/base/browser/ui/actionbar/actionbar", data); });
define(__m[183], __M([5,6]), function(nls, data) { return nls.create("vs/base/browser/ui/aria/aria", data); });
define(__m[184], __M([5,6]), function(nls, data) { return nls.create("vs/base/browser/ui/findinput/findInput", data); });
define(__m[185], __M([5,6]), function(nls, data) { return nls.create("vs/base/browser/ui/inputbox/inputBox", data); });
define(__m[186], __M([5,6]), function(nls, data) { return nls.create("vs/base/common/errors", data); });
define(__m[8], __M([0,1,186,31,18,26,37,10]), function (require, exports, nls, objects, platform, types, arrays, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // Avoid circular dependency on EventEmitter by implementing a subset of the interface.
    var ErrorHandler = (function () {
        function ErrorHandler() {
            this.listeners = [];
            this.unexpectedErrorHandler = function (e) {
                platform.setTimeout(function () {
                    if (e.stack) {
                        throw new Error(e.message + '\n\n' + e.stack);
                    }
                    throw e;
                }, 0);
            };
        }
        ErrorHandler.prototype.addListener = function (listener) {
            var _this = this;
            this.listeners.push(listener);
            return function () {
                _this._removeListener(listener);
            };
        };
        ErrorHandler.prototype.emit = function (e) {
            this.listeners.forEach(function (listener) {
                listener(e);
            });
        };
        ErrorHandler.prototype._removeListener = function (listener) {
            this.listeners.splice(this.listeners.indexOf(listener), 1);
        };
        ErrorHandler.prototype.setUnexpectedErrorHandler = function (newUnexpectedErrorHandler) {
            this.unexpectedErrorHandler = newUnexpectedErrorHandler;
        };
        ErrorHandler.prototype.getUnexpectedErrorHandler = function () {
            return this.unexpectedErrorHandler;
        };
        ErrorHandler.prototype.onUnexpectedError = function (e) {
            this.unexpectedErrorHandler(e);
            this.emit(e);
        };
        return ErrorHandler;
    }());
    exports.ErrorHandler = ErrorHandler;
    exports.errorHandler = new ErrorHandler();
    function setUnexpectedErrorHandler(newUnexpectedErrorHandler) {
        exports.errorHandler.setUnexpectedErrorHandler(newUnexpectedErrorHandler);
    }
    exports.setUnexpectedErrorHandler = setUnexpectedErrorHandler;
    function onUnexpectedError(e) {
        // ignore errors from cancelled promises
        if (!isPromiseCanceledError(e)) {
            exports.errorHandler.onUnexpectedError(e);
        }
    }
    exports.onUnexpectedError = onUnexpectedError;
    function onUnexpectedPromiseError(promise) {
        return promise.then(null, onUnexpectedError);
    }
    exports.onUnexpectedPromiseError = onUnexpectedPromiseError;
    function transformErrorForSerialization(error) {
        if (error instanceof Error) {
            var name_1 = error.name, message = error.message;
            var stack = error.stacktrace || error.stack;
            return {
                $isError: true,
                name: name_1,
                message: message,
                stack: stack
            };
        }
        // return as is
        return error;
    }
    exports.transformErrorForSerialization = transformErrorForSerialization;
    /**
     * The base class for all connection errors originating from XHR requests.
     */
    var ConnectionError = (function () {
        function ConnectionError(arg) {
            this.status = arg.status;
            this.statusText = arg.statusText;
            this.name = 'ConnectionError';
            try {
                this.responseText = arg.responseText;
            }
            catch (e) {
                this.responseText = '';
            }
            this.errorMessage = null;
            this.errorCode = null;
            this.errorObject = null;
            if (this.responseText) {
                try {
                    var errorObj = JSON.parse(this.responseText);
                    this.errorMessage = errorObj.message;
                    this.errorCode = errorObj.code;
                    this.errorObject = errorObj;
                }
                catch (error) {
                }
            }
        }
        Object.defineProperty(ConnectionError.prototype, "message", {
            get: function () {
                return this.connectionErrorToMessage(this, false);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ConnectionError.prototype, "verboseMessage", {
            get: function () {
                return this.connectionErrorToMessage(this, true);
            },
            enumerable: true,
            configurable: true
        });
        ConnectionError.prototype.connectionErrorDetailsToMessage = function (error, verbose) {
            var errorCode = error.errorCode;
            var errorMessage = error.errorMessage;
            if (errorCode !== null && errorMessage !== null) {
                return nls.localize(0, null, strings.rtrim(errorMessage, '.'), errorCode);






            }
            if (errorMessage !== null) {
                return errorMessage;
            }
            if (verbose && error.responseText !== null) {
                return error.responseText;
            }
            return null;
        };
        ConnectionError.prototype.connectionErrorToMessage = function (error, verbose) {
            var details = this.connectionErrorDetailsToMessage(error, verbose);
            // Status Code based Error
            if (error.status === 401) {
                if (details !== null) {
                    return nls.localize(1, null, details);





                }
                return nls.localize(2, null);
            }
            // Return error details if present
            if (details) {
                return details;
            }
            // Fallback to HTTP Status and Code
            if (error.status > 0 && error.statusText !== null) {
                if (verbose && error.responseText !== null && error.responseText.length > 0) {
                    return nls.localize(3, null, error.statusText, error.status, error.responseText);
                }
                return nls.localize(4, null, error.statusText, error.status);
            }
            // Finally its an Unknown Connection Error
            if (verbose && error.responseText !== null && error.responseText.length > 0) {
                return nls.localize(5, null, error.responseText);
            }
            return nls.localize(6, null);
        };
        return ConnectionError;
    }());
    exports.ConnectionError = ConnectionError;
    // Bug: Can not subclass a JS Type. Do it manually (as done in WinJS.Class.derive)
    objects.derive(Error, ConnectionError);
    function xhrToErrorMessage(xhr, verbose) {
        var ce = new ConnectionError(xhr);
        if (verbose) {
            return ce.verboseMessage;
        }
        else {
            return ce.message;
        }
    }
    function exceptionToErrorMessage(exception, verbose) {
        if (exception.message) {
            if (verbose && (exception.stack || exception.stacktrace)) {
                return nls.localize(7, null, detectSystemErrorMessage(exception), exception.stack || exception.stacktrace);
            }
            return detectSystemErrorMessage(exception);
        }
        return nls.localize(8, null);
    }
    function detectSystemErrorMessage(exception) {
        // See https://nodejs.org/api/errors.html#errors_class_system_error
        if (typeof exception.code === 'string' && typeof exception.errno === 'number' && typeof exception.syscall === 'string') {
            return nls.localize(9, null, exception.message);
        }
        return exception.message;
    }
    /**
     * Tries to generate a human readable error message out of the error. If the verbose parameter
     * is set to true, the error message will include stacktrace details if provided.
     * @returns A string containing the error message.
     */
    function toErrorMessage(error, verbose) {
        if (error === void 0) { error = null; }
        if (verbose === void 0) { verbose = false; }
        if (!error) {
            return nls.localize(10, null);
        }
        if (Array.isArray(error)) {
            var errors = arrays.coalesce(error);
            var msg = toErrorMessage(errors[0], verbose);
            if (errors.length > 1) {
                return nls.localize(11, null, msg, errors.length);
            }
            return msg;
        }
        if (types.isString(error)) {
            return error;
        }
        if (!types.isUndefinedOrNull(error.status)) {
            return xhrToErrorMessage(error, verbose);
        }
        if (error.detail) {
            var detail = error.detail;
            if (detail.error) {
                if (detail.error && !types.isUndefinedOrNull(detail.error.status)) {
                    return xhrToErrorMessage(detail.error, verbose);
                }
                if (types.isArray(detail.error)) {
                    for (var i = 0; i < detail.error.length; i++) {
                        if (detail.error[i] && !types.isUndefinedOrNull(detail.error[i].status)) {
                            return xhrToErrorMessage(detail.error[i], verbose);
                        }
                    }
                }
                else {
                    return exceptionToErrorMessage(detail.error, verbose);
                }
            }
            if (detail.exception) {
                if (!types.isUndefinedOrNull(detail.exception.status)) {
                    return xhrToErrorMessage(detail.exception, verbose);
                }
                return exceptionToErrorMessage(detail.exception, verbose);
            }
        }
        if (error.stack) {
            return exceptionToErrorMessage(error, verbose);
        }
        if (error.message) {
            return error.message;
        }
        return nls.localize(12, null);
    }
    exports.toErrorMessage = toErrorMessage;
    var canceledName = 'Canceled';
    /**
     * Checks if the given error is a promise in canceled state
     */
    function isPromiseCanceledError(error) {
        return error instanceof Error && error.name === canceledName && error.message === canceledName;
    }
    exports.isPromiseCanceledError = isPromiseCanceledError;
    /**
     * Returns an error that signals cancellation.
     */
    function canceled() {
        var error = new Error(canceledName);
        error.name = error.message;
        return error;
    }
    exports.canceled = canceled;
    /**
     * Returns an error that signals something is not implemented.
     */
    function notImplemented() {
        return new Error(nls.localize(13, null));
    }
    exports.notImplemented = notImplemented;
    function illegalArgument(name) {
        if (name) {
            return new Error(nls.localize(14, null, name));
        }
        else {
            return new Error(nls.localize(15, null));
        }
    }
    exports.illegalArgument = illegalArgument;
    function illegalState(name) {
        if (name) {
            return new Error(nls.localize(16, null, name));
        }
        else {
            return new Error(nls.localize(17, null));
        }
    }
    exports.illegalState = illegalState;
    function readonly(name) {
        return name
            ? new Error("readonly property '" + name + " cannot be changed'")
            : new Error('readonly property cannot be changed');
    }
    exports.readonly = readonly;
    function loaderError(err) {
        if (platform.isWeb) {
            return new Error(nls.localize(18, null));
        }
        return new Error(nls.localize(19, null, JSON.stringify(err)));
    }
    exports.loaderError = loaderError;
    function create(message, options) {
        if (options === void 0) { options = {}; }
        var result = new Error(message);
        if (types.isNumber(options.severity)) {
            result.severity = options.severity;
        }
        if (options.actions) {
            result.actions = options.actions;
        }
        return result;
    }
    exports.create = create;
});

define(__m[134], __M([0,1,8]), function (require, exports, errors_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CallbackList = (function () {
        function CallbackList() {
        }
        CallbackList.prototype.add = function (callback, context, bucket) {
            var _this = this;
            if (context === void 0) { context = null; }
            if (!this._callbacks) {
                this._callbacks = [];
                this._contexts = [];
            }
            this._callbacks.push(callback);
            this._contexts.push(context);
            if (Array.isArray(bucket)) {
                bucket.push({ dispose: function () { return _this.remove(callback, context); } });
            }
        };
        CallbackList.prototype.remove = function (callback, context) {
            if (context === void 0) { context = null; }
            if (!this._callbacks) {
                return;
            }
            var foundCallbackWithDifferentContext = false;
            for (var i = 0, len = this._callbacks.length; i < len; i++) {
                if (this._callbacks[i] === callback) {
                    if (this._contexts[i] === context) {
                        // callback & context match => remove it
                        this._callbacks.splice(i, 1);
                        this._contexts.splice(i, 1);
                        return;
                    }
                    else {
                        foundCallbackWithDifferentContext = true;
                    }
                }
            }
            if (foundCallbackWithDifferentContext) {
                throw new Error('When adding a listener with a context, you should remove it with the same context');
            }
        };
        CallbackList.prototype.invoke = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            if (!this._callbacks) {
                return;
            }
            var ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
            for (var i = 0, len = callbacks.length; i < len; i++) {
                try {
                    ret.push(callbacks[i].apply(contexts[i], args));
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                }
            }
            return ret;
        };
        CallbackList.prototype.isEmpty = function () {
            return !this._callbacks || this._callbacks.length === 0;
        };
        CallbackList.prototype.dispose = function () {
            this._callbacks = undefined;
            this._contexts = undefined;
        };
        return CallbackList;
    }());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = CallbackList;
});

define(__m[16], __M([0,1,134]), function (require, exports, callbackList_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Event;
    (function (Event) {
        var _disposable = { dispose: function () { } };
        Event.None = function () { return _disposable; };
    })(Event || (Event = {}));
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Event;
    /**
     * The Emitter can be used to expose an Event to the public
     * to fire it from the insides.
     * Sample:
        class Document {
    
            private _onDidChange = new Emitter<(value:string)=>any>();
    
            public onDidChange = this._onDidChange.event;
    
            // getter-style
            // get onDidChange(): Event<(value:string)=>any> {
            // 	return this._onDidChange.event;
            // }
    
            private _doIt() {
                //...
                this._onDidChange.fire(value);
            }
        }
     */
    var Emitter = (function () {
        function Emitter(_options) {
            this._options = _options;
        }
        Object.defineProperty(Emitter.prototype, "event", {
            /**
             * For the public to allow to subscribe
             * to events from this Emitter
             */
            get: function () {
                var _this = this;
                if (!this._event) {
                    this._event = function (listener, thisArgs, disposables) {
                        if (!_this._callbacks) {
                            _this._callbacks = new callbackList_1.default();
                        }
                        if (_this._options && _this._options.onFirstListenerAdd && _this._callbacks.isEmpty()) {
                            _this._options.onFirstListenerAdd(_this);
                        }
                        _this._callbacks.add(listener, thisArgs);
                        var result;
                        result = {
                            dispose: function () {
                                result.dispose = Emitter._noop;
                                if (!_this._disposed) {
                                    _this._callbacks.remove(listener, thisArgs);
                                    if (_this._options && _this._options.onLastListenerRemove && _this._callbacks.isEmpty()) {
                                        _this._options.onLastListenerRemove(_this);
                                    }
                                }
                            }
                        };
                        if (Array.isArray(disposables)) {
                            disposables.push(result);
                        }
                        return result;
                    };
                }
                return this._event;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * To be kept private to fire an event to
         * subscribers
         */
        Emitter.prototype.fire = function (event) {
            if (this._callbacks) {
                this._callbacks.invoke.call(this._callbacks, event);
            }
        };
        Emitter.prototype.dispose = function () {
            if (this._callbacks) {
                this._callbacks.dispose();
                this._callbacks = undefined;
                this._disposed = true;
            }
        };
        Emitter._noop = function () { };
        return Emitter;
    }());
    exports.Emitter = Emitter;
    /**
     * Creates an Event which is backed-up by the event emitter. This allows
     * to use the existing eventing pattern and is likely using less memory.
     * Sample:
     *
     * 	class Document {
     *
     *		private _eventbus = new EventEmitter();
     *
     *		public onDidChange = fromEventEmitter(this._eventbus, 'changed');
     *
     *		// getter-style
     *		// get onDidChange(): Event<(value:string)=>any> {
     *		// 	cache fromEventEmitter result and return
     *		// }
     *
     *		private _doIt() {
     *			// ...
     *			this._eventbus.emit('changed', value)
     *		}
     *	}
     */
    function fromEventEmitter(emitter, eventType) {
        return function (listener, thisArgs, disposables) {
            var result = emitter.addListener2(eventType, function () {
                listener.apply(thisArgs, arguments);
            });
            if (Array.isArray(disposables)) {
                disposables.push(result);
            }
            return result;
        };
    }
    exports.fromEventEmitter = fromEventEmitter;
    function mapEvent(event, map) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (i) { return listener.call(thisArgs, map(i)); }, null, disposables);
        };
    }
    exports.mapEvent = mapEvent;
    function filterEvent(event, filter) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (e) { return filter(e) && listener.call(thisArgs, e); }, null, disposables);
        };
    }
    exports.filterEvent = filterEvent;
    function debounceEvent(event, merger, delay) {
        if (delay === void 0) { delay = 100; }
        var subscription;
        var output;
        var handle;
        var emitter = new Emitter({
            onFirstListenerAdd: function () {
                subscription = event(function (cur) {
                    output = merger(output, cur);
                    clearTimeout(handle);
                    handle = setTimeout(function () {
                        emitter.fire(output);
                        output = undefined;
                    }, delay);
                });
            },
            onLastListenerRemove: function () {
                subscription.dispose();
            }
        });
        return emitter.event;
    }
    exports.debounceEvent = debounceEvent;
    var EventDelayerState;
    (function (EventDelayerState) {
        EventDelayerState[EventDelayerState["Idle"] = 0] = "Idle";
        EventDelayerState[EventDelayerState["Running"] = 1] = "Running";
    })(EventDelayerState || (EventDelayerState = {}));
    /**
     * The EventDelayer is useful in situations in which you want
     * to delay firing your events during some code.
     * You can wrap that code and be sure that the event will not
     * be fired during that wrap.
     *
     * ```
     * const emitter: Emitter;
     * const delayer = new EventDelayer();
     * const delayedEvent = delayer.delay(emitter.event);
     *
     * delayedEvent(console.log);
     *
     * delayer.wrap(() => {
     *   emitter.fire(); // event will not be fired yet
     * });
     *
     * // event will only be fired at this point
     * ```
     */
    var EventBufferer = (function () {
        function EventBufferer() {
            this.buffers = [];
        }
        EventBufferer.prototype.wrapEvent = function (event) {
            var _this = this;
            return function (listener, thisArgs, disposables) {
                return event(function (i) {
                    var buffer = _this.buffers[_this.buffers.length - 1];
                    if (buffer) {
                        buffer.push(function () { return listener.call(thisArgs, i); });
                    }
                    else {
                        listener.call(thisArgs, i);
                    }
                }, void 0, disposables);
            };
        };
        EventBufferer.prototype.bufferEvents = function (fn) {
            var buffer = [];
            this.buffers.push(buffer);
            fn();
            this.buffers.pop();
            buffer.forEach(function (flush) { return flush(); });
        };
        return EventBufferer;
    }());
    exports.EventBufferer = EventBufferer;
});

define(__m[28], __M([0,1,26,18,16]), function (require, exports, types, Platform, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ZoomManager = (function () {
        function ZoomManager() {
            this._zoomLevel = 0;
            this._pixelRatioCache = 0;
            this._pixelRatioComputed = false;
            this._onDidChangeZoomLevel = new event_1.Emitter();
            this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;
        }
        ZoomManager.prototype.getZoomLevel = function () {
            return this._zoomLevel;
        };
        ZoomManager.prototype.setZoomLevel = function (zoomLevel) {
            if (this._zoomLevel === zoomLevel) {
                return;
            }
            this._zoomLevel = zoomLevel;
            this._pixelRatioComputed = false;
            this._onDidChangeZoomLevel.fire(this._zoomLevel);
        };
        ZoomManager.prototype.getPixelRatio = function () {
            if (!this._pixelRatioComputed) {
                this._pixelRatioCache = this._computePixelRatio();
                this._pixelRatioComputed = true;
            }
            return this._pixelRatioCache;
        };
        ZoomManager.prototype._computePixelRatio = function () {
            var ctx = document.createElement('canvas').getContext('2d');
            var dpr = window.devicePixelRatio || 1;
            var bsr = ctx.webkitBackingStorePixelRatio ||
                ctx.mozBackingStorePixelRatio ||
                ctx.msBackingStorePixelRatio ||
                ctx.oBackingStorePixelRatio ||
                ctx.backingStorePixelRatio || 1;
            return dpr / bsr;
        };
        ZoomManager.INSTANCE = new ZoomManager();
        return ZoomManager;
    }());
    function getZoomLevel() {
        return ZoomManager.INSTANCE.getZoomLevel();
    }
    exports.getZoomLevel = getZoomLevel;
    function getPixelRatio() {
        return ZoomManager.INSTANCE.getPixelRatio();
    }
    exports.getPixelRatio = getPixelRatio;
    function setZoomLevel(zoomLevel) {
        ZoomManager.INSTANCE.setZoomLevel(zoomLevel);
    }
    exports.setZoomLevel = setZoomLevel;
    function onDidChangeZoomLevel(callback) {
        return ZoomManager.INSTANCE.onDidChangeZoomLevel(callback);
    }
    exports.onDidChangeZoomLevel = onDidChangeZoomLevel;
    var userAgent = navigator.userAgent;
    // DOCUMENTED FOR FUTURE REFERENCE:
    // When running IE11 in IE10 document mode, the code below will identify the browser as being IE10,
    // which is correct because IE11 in IE10 document mode will reimplement all the bugs of IE10
    exports.isIE11 = (userAgent.indexOf('Trident') >= 0 && userAgent.indexOf('MSIE') < 0);
    exports.isIE10 = (userAgent.indexOf('MSIE 10') >= 0);
    exports.isIE9 = (userAgent.indexOf('MSIE 9') >= 0);
    exports.isIE11orEarlier = exports.isIE11 || exports.isIE10 || exports.isIE9;
    exports.isIE10orEarlier = exports.isIE10 || exports.isIE9;
    exports.isIE10orLater = exports.isIE11 || exports.isIE10;
    exports.isOpera = (userAgent.indexOf('Opera') >= 0);
    exports.isFirefox = (userAgent.indexOf('Firefox') >= 0);
    exports.isWebKit = (userAgent.indexOf('AppleWebKit') >= 0);
    exports.isChrome = (userAgent.indexOf('Chrome') >= 0);
    exports.isSafari = (userAgent.indexOf('Chrome') === -1) && (userAgent.indexOf('Safari') >= 0);
    exports.isIPad = (userAgent.indexOf('iPad') >= 0);
    exports.canUseTranslate3d = !exports.isIE9 && !exports.isFirefox;
    exports.enableEmptySelectionClipboard = exports.isWebKit;
    /**
     * Returns if the browser supports CSS 3 animations.
     */
    function hasCSSAnimationSupport() {
        if (this._hasCSSAnimationSupport === true || this._hasCSSAnimationSupport === false) {
            return this._hasCSSAnimationSupport;
        }
        var supported = false;
        var element = document.createElement('div');
        var properties = ['animationName', 'webkitAnimationName', 'msAnimationName', 'MozAnimationName', 'OAnimationName'];
        for (var i = 0; i < properties.length; i++) {
            var property = properties[i];
            if (!types.isUndefinedOrNull(element.style[property]) || element.style.hasOwnProperty(property)) {
                supported = true;
                break;
            }
        }
        if (supported) {
            this._hasCSSAnimationSupport = true;
        }
        else {
            this._hasCSSAnimationSupport = false;
        }
        return this._hasCSSAnimationSupport;
    }
    exports.hasCSSAnimationSupport = hasCSSAnimationSupport;
    function supportsExecCommand(command) {
        return ((exports.isIE11orEarlier || Platform.isNative)
            && document.queryCommandSupported(command));
    }
    exports.supportsExecCommand = supportsExecCommand;
});

define(__m[137], __M([0,1,16]), function (require, exports, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.domEvent = function (element, type, useCapture) {
        var fn = function (e) { return emitter.fire(e); };
        var emitter = new event_1.Emitter({
            onFirstListenerAdd: function () {
                element.addEventListener(type, fn);
            },
            onLastListenerRemove: function () {
                element.removeEventListener(type, fn);
            }
        });
        return emitter.event;
    };
});






define(__m[39], __M([0,1,18,28,149]), function (require, exports, platform, browser, iframe_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var StandardMouseEvent = (function () {
        function StandardMouseEvent(e) {
            this.timestamp = Date.now();
            this.browserEvent = e;
            this.leftButton = e.button === 0;
            this.middleButton = e.button === 1;
            this.rightButton = e.button === 2;
            this.target = e.target;
            this.detail = e.detail || 1;
            if (e.type === 'dblclick') {
                this.detail = 2;
            }
            this.ctrlKey = e.ctrlKey;
            this.shiftKey = e.shiftKey;
            this.altKey = e.altKey;
            this.metaKey = e.metaKey;
            if (typeof e.pageX === 'number') {
                this.posx = e.pageX;
                this.posy = e.pageY;
            }
            else {
                // Probably hit by MSGestureEvent
                this.posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
                this.posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;
            }
            // Find the position of the iframe this code is executing in relative to the iframe where the event was captured.
            var iframeOffsets = iframe_1.IframeUtils.getPositionOfChildWindowRelativeToAncestorWindow(self, e.view);
            this.posx -= iframeOffsets.left;
            this.posy -= iframeOffsets.top;
        }
        StandardMouseEvent.prototype.preventDefault = function () {
            if (this.browserEvent.preventDefault) {
                this.browserEvent.preventDefault();
            }
        };
        StandardMouseEvent.prototype.stopPropagation = function () {
            if (this.browserEvent.stopPropagation) {
                this.browserEvent.stopPropagation();
            }
        };
        return StandardMouseEvent;
    }());
    exports.StandardMouseEvent = StandardMouseEvent;
    var DragMouseEvent = (function (_super) {
        __extends(DragMouseEvent, _super);
        function DragMouseEvent(e) {
            _super.call(this, e);
            this.dataTransfer = e.dataTransfer;
        }
        return DragMouseEvent;
    }(StandardMouseEvent));
    exports.DragMouseEvent = DragMouseEvent;
    var DropMouseEvent = (function (_super) {
        __extends(DropMouseEvent, _super);
        function DropMouseEvent(e) {
            _super.call(this, e);
        }
        return DropMouseEvent;
    }(DragMouseEvent));
    exports.DropMouseEvent = DropMouseEvent;
    var StandardMouseWheelEvent = (function () {
        function StandardMouseWheelEvent(e, deltaX, deltaY) {
            if (deltaX === void 0) { deltaX = 0; }
            if (deltaY === void 0) { deltaY = 0; }
            this.browserEvent = e || null;
            this.target = e ? (e.target || e.targetNode || e.srcElement) : null;
            this.deltaY = deltaY;
            this.deltaX = deltaX;
            if (e) {
                var e1 = e;
                var e2 = e;
                // vertical delta scroll
                if (typeof e1.wheelDeltaY !== 'undefined') {
                    this.deltaY = e1.wheelDeltaY / 120;
                }
                else if (typeof e2.VERTICAL_AXIS !== 'undefined' && e2.axis === e2.VERTICAL_AXIS) {
                    this.deltaY = -e2.detail / 3;
                }
                // horizontal delta scroll
                if (typeof e1.wheelDeltaX !== 'undefined') {
                    if (browser.isSafari && platform.isWindows) {
                        this.deltaX = -(e1.wheelDeltaX / 120);
                    }
                    else {
                        this.deltaX = e1.wheelDeltaX / 120;
                    }
                }
                else if (typeof e2.HORIZONTAL_AXIS !== 'undefined' && e2.axis === e2.HORIZONTAL_AXIS) {
                    this.deltaX = -e.detail / 3;
                }
                // Assume a vertical scroll if nothing else worked
                if (this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta) {
                    this.deltaY = e.wheelDelta / 120;
                }
            }
        }
        StandardMouseWheelEvent.prototype.preventDefault = function () {
            if (this.browserEvent) {
                if (this.browserEvent.preventDefault) {
                    this.browserEvent.preventDefault();
                }
            }
        };
        StandardMouseWheelEvent.prototype.stopPropagation = function () {
            if (this.browserEvent) {
                if (this.browserEvent.stopPropagation) {
                    this.browserEvent.stopPropagation();
                }
            }
        };
        return StandardMouseWheelEvent;
    }());
    exports.StandardMouseWheelEvent = StandardMouseWheelEvent;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[104], __M([0,1,16]), function (require, exports, event_1) {
    'use strict';
    var CancellationToken;
    (function (CancellationToken) {
        CancellationToken.None = Object.freeze({
            isCancellationRequested: false,
            onCancellationRequested: event_1.default.None
        });
        CancellationToken.Cancelled = Object.freeze({
            isCancellationRequested: true,
            onCancellationRequested: event_1.default.None
        });
    })(CancellationToken = exports.CancellationToken || (exports.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function (callback, context) {
        var handle = setTimeout(callback.bind(context), 0);
        return { dispose: function () { clearTimeout(handle); } };
    });
    var MutableToken = (function () {
        function MutableToken() {
            this._isCancelled = false;
        }
        MutableToken.prototype.cancel = function () {
            if (!this._isCancelled) {
                this._isCancelled = true;
                if (this._emitter) {
                    this._emitter.fire(undefined);
                    this._emitter = undefined;
                }
            }
        };
        Object.defineProperty(MutableToken.prototype, "isCancellationRequested", {
            get: function () {
                return this._isCancelled;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MutableToken.prototype, "onCancellationRequested", {
            get: function () {
                if (this._isCancelled) {
                    return shortcutEvent;
                }
                if (!this._emitter) {
                    this._emitter = new event_1.Emitter();
                }
                return this._emitter.event;
            },
            enumerable: true,
            configurable: true
        });
        return MutableToken;
    }());
    var CancellationTokenSource = (function () {
        function CancellationTokenSource() {
        }
        Object.defineProperty(CancellationTokenSource.prototype, "token", {
            get: function () {
                if (!this._token) {
                    // be lazy and create the token only when
                    // actually needed
                    this._token = new MutableToken();
                }
                return this._token;
            },
            enumerable: true,
            configurable: true
        });
        CancellationTokenSource.prototype.cancel = function () {
            if (!this._token) {
                // save an object by returning the default
                // cancelled token when cancellation happens
                // before someone asks for the token
                this._token = CancellationToken.Cancelled;
            }
            else {
                this._token.cancel();
            }
        };
        CancellationTokenSource.prototype.dispose = function () {
            this.cancel();
        };
        return CancellationTokenSource;
    }());
    exports.CancellationTokenSource = CancellationTokenSource;
});






define(__m[23], __M([0,1,8]), function (require, exports, Errors) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EmitterEvent = (function () {
        function EmitterEvent(eventType, data) {
            if (eventType === void 0) { eventType = null; }
            if (data === void 0) { data = null; }
            this._type = eventType;
            this._data = data;
        }
        EmitterEvent.prototype.getType = function () {
            return this._type;
        };
        EmitterEvent.prototype.getData = function () {
            return this._data;
        };
        return EmitterEvent;
    }());
    exports.EmitterEvent = EmitterEvent;
    var EventEmitter = (function () {
        function EventEmitter(allowedEventTypes) {
            if (allowedEventTypes === void 0) { allowedEventTypes = null; }
            this._listeners = {};
            this._bulkListeners = [];
            this._collectedEvents = [];
            this._deferredCnt = 0;
            if (allowedEventTypes) {
                this._allowedEventTypes = {};
                for (var i = 0; i < allowedEventTypes.length; i++) {
                    this._allowedEventTypes[allowedEventTypes[i]] = true;
                }
            }
            else {
                this._allowedEventTypes = null;
            }
        }
        EventEmitter.prototype.dispose = function () {
            this._listeners = {};
            this._bulkListeners = [];
            this._collectedEvents = [];
            this._deferredCnt = 0;
            this._allowedEventTypes = null;
        };
        EventEmitter.prototype.addListener = function (eventType, listener) {
            if (eventType === '*') {
                throw new Error('Use addBulkListener(listener) to register your listener!');
            }
            if (this._allowedEventTypes && !this._allowedEventTypes.hasOwnProperty(eventType)) {
                throw new Error('This object will never emit this event type!');
            }
            if (this._listeners.hasOwnProperty(eventType)) {
                this._listeners[eventType].push(listener);
            }
            else {
                this._listeners[eventType] = [listener];
            }
            var bound = this;
            return {
                dispose: function () {
                    if (!bound) {
                        // Already called
                        return;
                    }
                    bound._removeListener(eventType, listener);
                    // Prevent leakers from holding on to the event emitter
                    bound = null;
                    listener = null;
                }
            };
        };
        EventEmitter.prototype.addListener2 = function (eventType, listener) {
            return this.addListener(eventType, listener);
        };
        EventEmitter.prototype.addOneTimeDisposableListener = function (eventType, listener) {
            var disposable = this.addListener(eventType, function (value) {
                disposable.dispose();
                listener(value);
            });
            return disposable;
        };
        EventEmitter.prototype.addBulkListener = function (listener) {
            var _this = this;
            this._bulkListeners.push(listener);
            return {
                dispose: function () {
                    _this._removeBulkListener(listener);
                }
            };
        };
        EventEmitter.prototype.addBulkListener2 = function (listener) {
            return this.addBulkListener(listener);
        };
        EventEmitter.prototype.addEmitter = function (eventEmitter) {
            var _this = this;
            return eventEmitter.addBulkListener2(function (events) {
                var newEvents = events;
                if (_this._deferredCnt === 0) {
                    _this._emitEvents(newEvents);
                }
                else {
                    // Collect for later
                    _this._collectedEvents.push.apply(_this._collectedEvents, newEvents);
                }
            });
        };
        EventEmitter.prototype.addEmitter2 = function (eventEmitter) {
            return this.addEmitter(eventEmitter);
        };
        EventEmitter.prototype._removeListener = function (eventType, listener) {
            if (this._listeners.hasOwnProperty(eventType)) {
                var listeners = this._listeners[eventType];
                for (var i = 0, len = listeners.length; i < len; i++) {
                    if (listeners[i] === listener) {
                        listeners.splice(i, 1);
                        break;
                    }
                }
            }
        };
        EventEmitter.prototype._removeBulkListener = function (listener) {
            for (var i = 0, len = this._bulkListeners.length; i < len; i++) {
                if (this._bulkListeners[i] === listener) {
                    this._bulkListeners.splice(i, 1);
                    break;
                }
            }
        };
        EventEmitter.prototype._emitToSpecificTypeListeners = function (eventType, data) {
            if (this._listeners.hasOwnProperty(eventType)) {
                var listeners = this._listeners[eventType].slice(0);
                for (var i = 0, len = listeners.length; i < len; i++) {
                    safeInvoke1Arg(listeners[i], data);
                }
            }
        };
        EventEmitter.prototype._emitToBulkListeners = function (events) {
            var bulkListeners = this._bulkListeners.slice(0);
            for (var i = 0, len = bulkListeners.length; i < len; i++) {
                safeInvoke1Arg(bulkListeners[i], events);
            }
        };
        EventEmitter.prototype._emitEvents = function (events) {
            if (this._bulkListeners.length > 0) {
                this._emitToBulkListeners(events);
            }
            for (var i = 0, len = events.length; i < len; i++) {
                var e = events[i];
                this._emitToSpecificTypeListeners(e.getType(), e.getData());
            }
        };
        EventEmitter.prototype.emit = function (eventType, data) {
            if (data === void 0) { data = {}; }
            if (this._allowedEventTypes && !this._allowedEventTypes.hasOwnProperty(eventType)) {
                throw new Error('Cannot emit this event type because it wasn\'t white-listed!');
            }
            // Early return if no listeners would get this
            if (!this._listeners.hasOwnProperty(eventType) && this._bulkListeners.length === 0) {
                return;
            }
            var emitterEvent = new EmitterEvent(eventType, data);
            if (this._deferredCnt === 0) {
                this._emitEvents([emitterEvent]);
            }
            else {
                // Collect for later
                this._collectedEvents.push(emitterEvent);
            }
        };
        EventEmitter.prototype.deferredEmit = function (callback) {
            this._deferredCnt = this._deferredCnt + 1;
            var result = safeInvokeNoArg(callback);
            this._deferredCnt = this._deferredCnt - 1;
            if (this._deferredCnt === 0) {
                this._emitCollected();
            }
            return result;
        };
        EventEmitter.prototype._emitCollected = function () {
            // Flush collected events
            var events = this._collectedEvents;
            this._collectedEvents = [];
            if (events.length > 0) {
                this._emitEvents(events);
            }
        };
        return EventEmitter;
    }());
    exports.EventEmitter = EventEmitter;
    var EmitQueueElement = (function () {
        function EmitQueueElement(target, arg) {
            this.target = target;
            this.arg = arg;
        }
        return EmitQueueElement;
    }());
    /**
     * Same as EventEmitter, but guarantees events are delivered in order to each listener
     */
    var OrderGuaranteeEventEmitter = (function (_super) {
        __extends(OrderGuaranteeEventEmitter, _super);
        function OrderGuaranteeEventEmitter(allowedEventTypes) {
            if (allowedEventTypes === void 0) { allowedEventTypes = null; }
            _super.call(this, allowedEventTypes);
            this._emitQueue = [];
        }
        OrderGuaranteeEventEmitter.prototype._emitToSpecificTypeListeners = function (eventType, data) {
            if (this._listeners.hasOwnProperty(eventType)) {
                var listeners = this._listeners[eventType];
                for (var i = 0, len = listeners.length; i < len; i++) {
                    this._emitQueue.push(new EmitQueueElement(listeners[i], data));
                }
            }
        };
        OrderGuaranteeEventEmitter.prototype._emitToBulkListeners = function (events) {
            var bulkListeners = this._bulkListeners;
            for (var i = 0, len = bulkListeners.length; i < len; i++) {
                this._emitQueue.push(new EmitQueueElement(bulkListeners[i], events));
            }
        };
        OrderGuaranteeEventEmitter.prototype._emitEvents = function (events) {
            _super.prototype._emitEvents.call(this, events);
            while (this._emitQueue.length > 0) {
                var queueElement = this._emitQueue.shift();
                safeInvoke1Arg(queueElement.target, queueElement.arg);
            }
        };
        return OrderGuaranteeEventEmitter;
    }(EventEmitter));
    exports.OrderGuaranteeEventEmitter = OrderGuaranteeEventEmitter;
    function safeInvokeNoArg(func) {
        try {
            return func();
        }
        catch (e) {
            Errors.onUnexpectedError(e);
        }
    }
    function safeInvoke1Arg(func, arg1) {
        try {
            return func(arg1);
        }
        catch (e) {
            Errors.onUnexpectedError(e);
        }
    }
});






define(__m[195], __M([0,1,3,16]), function (require, exports, lifecycle_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Scrollable = (function (_super) {
        __extends(Scrollable, _super);
        function Scrollable() {
            _super.call(this);
            this._onScroll = this._register(new event_1.Emitter());
            this.onScroll = this._onScroll.event;
            this._width = 0;
            this._scrollWidth = 0;
            this._scrollLeft = 0;
            this._height = 0;
            this._scrollHeight = 0;
            this._scrollTop = 0;
        }
        Scrollable.prototype.getWidth = function () {
            return this._width;
        };
        Scrollable.prototype.getScrollWidth = function () {
            return this._scrollWidth;
        };
        Scrollable.prototype.getScrollLeft = function () {
            return this._scrollLeft;
        };
        Scrollable.prototype.getHeight = function () {
            return this._height;
        };
        Scrollable.prototype.getScrollHeight = function () {
            return this._scrollHeight;
        };
        Scrollable.prototype.getScrollTop = function () {
            return this._scrollTop;
        };
        Scrollable.prototype.updateState = function (newState) {
            var width = (typeof newState.width !== 'undefined' ? newState.width | 0 : this._width);
            var scrollWidth = (typeof newState.scrollWidth !== 'undefined' ? newState.scrollWidth | 0 : this._scrollWidth);
            var scrollLeft = (typeof newState.scrollLeft !== 'undefined' ? newState.scrollLeft | 0 : this._scrollLeft);
            var height = (typeof newState.height !== 'undefined' ? newState.height | 0 : this._height);
            var scrollHeight = (typeof newState.scrollHeight !== 'undefined' ? newState.scrollHeight | 0 : this._scrollHeight);
            var scrollTop = (typeof newState.scrollTop !== 'undefined' ? newState.scrollTop | 0 : this._scrollTop);
            if (width < 0) {
                width = 0;
            }
            if (scrollLeft + width > scrollWidth) {
                scrollLeft = scrollWidth - width;
            }
            if (scrollLeft < 0) {
                scrollLeft = 0;
            }
            if (height < 0) {
                height = 0;
            }
            if (scrollTop + height > scrollHeight) {
                scrollTop = scrollHeight - height;
            }
            if (scrollTop < 0) {
                scrollTop = 0;
            }
            var widthChanged = (this._width !== width);
            var scrollWidthChanged = (this._scrollWidth !== scrollWidth);
            var scrollLeftChanged = (this._scrollLeft !== scrollLeft);
            var heightChanged = (this._height !== height);
            var scrollHeightChanged = (this._scrollHeight !== scrollHeight);
            var scrollTopChanged = (this._scrollTop !== scrollTop);
            if (!widthChanged && !scrollWidthChanged && !scrollLeftChanged && !heightChanged && !scrollHeightChanged && !scrollTopChanged) {
                return;
            }
            this._width = width;
            this._scrollWidth = scrollWidth;
            this._scrollLeft = scrollLeft;
            this._height = height;
            this._scrollHeight = scrollHeight;
            this._scrollTop = scrollTop;
            this._onScroll.fire({
                width: this._width,
                scrollWidth: this._scrollWidth,
                scrollLeft: this._scrollLeft,
                height: this._height,
                scrollHeight: this._scrollHeight,
                scrollTop: this._scrollTop,
                widthChanged: widthChanged,
                scrollWidthChanged: scrollWidthChanged,
                scrollLeftChanged: scrollLeftChanged,
                heightChanged: heightChanged,
                scrollHeightChanged: scrollHeightChanged,
                scrollTopChanged: scrollTopChanged,
            });
        };
        return Scrollable;
    }(lifecycle_1.Disposable));
    exports.Scrollable = Scrollable;
});

define(__m[59], __M([0,1,18,8,143]), function (require, exports, Platform, errors, precision) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ENABLE_TIMER = false;
    var msWriteProfilerMark = Platform.globals['msWriteProfilerMark'];
    (function (Topic) {
        Topic[Topic["EDITOR"] = 0] = "EDITOR";
        Topic[Topic["LANGUAGES"] = 1] = "LANGUAGES";
        Topic[Topic["WORKER"] = 2] = "WORKER";
        Topic[Topic["WORKBENCH"] = 3] = "WORKBENCH";
        Topic[Topic["STARTUP"] = 4] = "STARTUP";
    })(exports.Topic || (exports.Topic = {}));
    var Topic = exports.Topic;
    var NullTimerEvent = (function () {
        function NullTimerEvent() {
        }
        NullTimerEvent.prototype.stop = function () {
            return;
        };
        NullTimerEvent.prototype.timeTaken = function () {
            return -1;
        };
        return NullTimerEvent;
    }());
    var TimerEvent = (function () {
        function TimerEvent(timeKeeper, name, topic, startTime, description) {
            this.timeKeeper = timeKeeper;
            this.name = name;
            this.description = description;
            this.topic = topic;
            this.stopTime = null;
            if (startTime) {
                this.startTime = startTime;
                return;
            }
            this.startTime = new Date();
            this.sw = precision.StopWatch.create();
            if (msWriteProfilerMark) {
                var profilerName = ['Monaco', this.topic, this.name, 'start'];
                msWriteProfilerMark(profilerName.join('|'));
            }
        }
        TimerEvent.prototype.stop = function (stopTime) {
            // already stopped
            if (this.stopTime !== null) {
                return;
            }
            if (stopTime) {
                this.stopTime = stopTime;
                this.sw = null;
                this.timeKeeper._onEventStopped(this);
                return;
            }
            this.stopTime = new Date();
            if (this.sw) {
                this.sw.stop();
            }
            this.timeKeeper._onEventStopped(this);
            if (msWriteProfilerMark) {
                var profilerName = ['Monaco', this.topic, this.name, 'stop'];
                msWriteProfilerMark(profilerName.join('|'));
            }
        };
        TimerEvent.prototype.timeTaken = function () {
            if (this.sw) {
                return this.sw.elapsed();
            }
            if (this.stopTime) {
                return this.stopTime.getTime() - this.startTime.getTime();
            }
            return -1;
        };
        return TimerEvent;
    }());
    var TimeKeeper = (function () {
        function TimeKeeper() {
            this.cleaningIntervalId = -1;
            this.collectedEvents = [];
            this.listeners = [];
        }
        TimeKeeper.prototype.isEnabled = function () {
            return exports.ENABLE_TIMER;
        };
        TimeKeeper.prototype.start = function (topic, name, start, description) {
            if (!this.isEnabled()) {
                return exports.nullEvent;
            }
            var strTopic;
            if (typeof topic === 'string') {
                strTopic = topic;
            }
            else if (topic === Topic.EDITOR) {
                strTopic = 'Editor';
            }
            else if (topic === Topic.LANGUAGES) {
                strTopic = 'Languages';
            }
            else if (topic === Topic.WORKER) {
                strTopic = 'Worker';
            }
            else if (topic === Topic.WORKBENCH) {
                strTopic = 'Workbench';
            }
            else if (topic === Topic.STARTUP) {
                strTopic = 'Startup';
            }
            this.initAutoCleaning();
            var event = new TimerEvent(this, name, strTopic, start, description);
            this.addEvent(event);
            return event;
        };
        TimeKeeper.prototype.dispose = function () {
            if (this.cleaningIntervalId !== -1) {
                Platform.clearInterval(this.cleaningIntervalId);
                this.cleaningIntervalId = -1;
            }
        };
        TimeKeeper.prototype.addListener = function (listener) {
            var _this = this;
            this.listeners.push(listener);
            return {
                dispose: function () {
                    for (var i = 0; i < _this.listeners.length; i++) {
                        if (_this.listeners[i] === listener) {
                            _this.listeners.splice(i, 1);
                            return;
                        }
                    }
                }
            };
        };
        TimeKeeper.prototype.addEvent = function (event) {
            event.id = TimeKeeper.EVENT_ID;
            TimeKeeper.EVENT_ID++;
            this.collectedEvents.push(event);
            // expire items from the front of the cache
            if (this.collectedEvents.length > TimeKeeper._EVENT_CACHE_LIMIT) {
                this.collectedEvents.shift();
            }
        };
        TimeKeeper.prototype.initAutoCleaning = function () {
            var _this = this;
            if (this.cleaningIntervalId === -1) {
                this.cleaningIntervalId = Platform.setInterval(function () {
                    var now = Date.now();
                    _this.collectedEvents.forEach(function (event) {
                        if (!event.stopTime && (now - event.startTime.getTime()) >= TimeKeeper._MAX_TIMER_LENGTH) {
                            event.stop();
                        }
                    });
                }, TimeKeeper._CLEAN_UP_INTERVAL);
            }
        };
        TimeKeeper.prototype.getCollectedEvents = function () {
            return this.collectedEvents.slice(0);
        };
        TimeKeeper.prototype.clearCollectedEvents = function () {
            this.collectedEvents = [];
        };
        TimeKeeper.prototype._onEventStopped = function (event) {
            var emitEvents = [event];
            var listeners = this.listeners.slice(0);
            for (var i = 0; i < listeners.length; i++) {
                try {
                    listeners[i](emitEvents);
                }
                catch (e) {
                    errors.onUnexpectedError(e);
                }
            }
        };
        TimeKeeper.prototype.setInitialCollectedEvents = function (events, startTime) {
            var _this = this;
            if (!this.isEnabled()) {
                return;
            }
            if (startTime) {
                TimeKeeper.PARSE_TIME = startTime;
            }
            events.forEach(function (event) {
                var e = new TimerEvent(_this, event.name, event.topic, event.startTime, event.description);
                e.stop(event.stopTime);
                _this.addEvent(e);
            });
        };
        /**
         * After being started for 1 minute, all timers are automatically stopped.
         */
        TimeKeeper._MAX_TIMER_LENGTH = 60000; // 1 minute
        /**
         * Every 2 minutes, a sweep of current started timers is done.
         */
        TimeKeeper._CLEAN_UP_INTERVAL = 120000; // 2 minutes
        /**
         * Collect at most 1000 events.
         */
        TimeKeeper._EVENT_CACHE_LIMIT = 1000;
        TimeKeeper.EVENT_ID = 1;
        TimeKeeper.PARSE_TIME = new Date();
        return TimeKeeper;
    }());
    exports.TimeKeeper = TimeKeeper;
    var timeKeeper = new TimeKeeper();
    exports.nullEvent = new NullTimerEvent();
    function start(topic, name, start, description) {
        return timeKeeper.start(topic, name, start, description);
    }
    exports.start = start;
    function getTimeKeeper() {
        return timeKeeper;
    }
    exports.getTimeKeeper = getTimeKeeper;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

define(__m[2], __M([515,8]), function (winjs, __Errors__) {
	'use strict';

	var outstandingPromiseErrors = {};
	function promiseErrorHandler(e) {

		//
		// e.detail looks like: { exception, error, promise, handler, id, parent }
		//
		var details = e.detail;
		var id = details.id;

		// If the error has a parent promise then this is not the origination of the
		//  error so we check if it has a handler, and if so we mark that the error
		//  was handled by removing it from outstandingPromiseErrors
		//
		if (details.parent) {
			if (details.handler && outstandingPromiseErrors) {
				delete outstandingPromiseErrors[id];
			}
			return;
		}

		// Indicate that this error was originated and needs to be handled
		outstandingPromiseErrors[id] = details;

		// The first time the queue fills up this iteration, schedule a timeout to
		// check if any errors are still unhandled.
		if (Object.keys(outstandingPromiseErrors).length === 1) {
			setTimeout(function () {
				var errors = outstandingPromiseErrors;
				outstandingPromiseErrors = {};
				Object.keys(errors).forEach(function (errorId) {
					var error = errors[errorId];
					if(error.exception) {
						__Errors__.onUnexpectedError(error.exception);
					} else if(error.error) {
						__Errors__.onUnexpectedError(error.error);
					}
					console.log("WARNING: Promise with no error callback:" + error.id);
					console.log(error);
					if(error.exception) {
						console.log(error.exception.stack);
					}
				});
			}, 0);
		}
	}

	winjs.Promise.addEventListener("error", promiseErrorHandler);

	return {
		Promise: winjs.Promise,
		TPromise: winjs.Promise,
		PPromise: winjs.Promise
	};
});





define(__m[50], __M([0,1,2,23,60]), function (require, exports, winjs_base_1, eventEmitter_1, Events) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Checks if the provided object is compatible
     * with the IAction interface.
     * @param thing an object
     */
    function isAction(thing) {
        if (!thing) {
            return false;
        }
        else if (thing instanceof Action) {
            return true;
        }
        else if (typeof thing.id !== 'string') {
            return false;
        }
        else if (typeof thing.label !== 'string') {
            return false;
        }
        else if (typeof thing.class !== 'string') {
            return false;
        }
        else if (typeof thing.enabled !== 'boolean') {
            return false;
        }
        else if (typeof thing.checked !== 'boolean') {
            return false;
        }
        else if (typeof thing.run !== 'function') {
            return false;
        }
        else {
            return true;
        }
    }
    exports.isAction = isAction;
    var Action = (function (_super) {
        __extends(Action, _super);
        function Action(id, label, cssClass, enabled, actionCallback) {
            if (label === void 0) { label = ''; }
            if (cssClass === void 0) { cssClass = ''; }
            if (enabled === void 0) { enabled = true; }
            if (actionCallback === void 0) { actionCallback = null; }
            _super.call(this);
            this._id = id;
            this._label = label;
            this._cssClass = cssClass;
            this._enabled = enabled;
            this._actionCallback = actionCallback;
        }
        Object.defineProperty(Action.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "label", {
            get: function () {
                return this._label;
            },
            set: function (value) {
                this._setLabel(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setLabel = function (value) {
            if (this._label !== value) {
                this._label = value;
                this.emit(Action.LABEL, { source: this });
            }
        };
        Object.defineProperty(Action.prototype, "tooltip", {
            get: function () {
                return this._tooltip;
            },
            set: function (value) {
                this._setTooltip(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setTooltip = function (value) {
            if (this._tooltip !== value) {
                this._tooltip = value;
                this.emit(Action.TOOLTIP, { source: this });
            }
        };
        Object.defineProperty(Action.prototype, "class", {
            get: function () {
                return this._cssClass;
            },
            set: function (value) {
                this._setClass(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setClass = function (value) {
            if (this._cssClass !== value) {
                this._cssClass = value;
                this.emit(Action.CLASS, { source: this });
            }
        };
        Object.defineProperty(Action.prototype, "enabled", {
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                this._setEnabled(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setEnabled = function (value) {
            if (this._enabled !== value) {
                this._enabled = value;
                this.emit(Action.ENABLED, { source: this });
            }
        };
        Object.defineProperty(Action.prototype, "checked", {
            get: function () {
                return this._checked;
            },
            set: function (value) {
                this._setChecked(value);
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype._setChecked = function (value) {
            if (this._checked !== value) {
                this._checked = value;
                this.emit(Action.CHECKED, { source: this });
            }
        };
        Object.defineProperty(Action.prototype, "order", {
            get: function () {
                return this._order;
            },
            set: function (value) {
                this._order = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Action.prototype, "actionCallback", {
            get: function () {
                return this._actionCallback;
            },
            set: function (value) {
                this._actionCallback = value;
            },
            enumerable: true,
            configurable: true
        });
        Action.prototype.run = function (event) {
            if (this._actionCallback !== null) {
                return this._actionCallback(event);
            }
            else {
                return winjs_base_1.TPromise.as(true);
            }
        };
        Action.LABEL = 'label';
        Action.TOOLTIP = 'tooltip';
        Action.CLASS = 'class';
        Action.ENABLED = 'enabled';
        Action.CHECKED = 'checked';
        return Action;
    }(eventEmitter_1.EventEmitter));
    exports.Action = Action;
    var ActionRunner = (function (_super) {
        __extends(ActionRunner, _super);
        function ActionRunner() {
            _super.apply(this, arguments);
        }
        ActionRunner.prototype.run = function (action, context) {
            var _this = this;
            if (!action.enabled) {
                return winjs_base_1.TPromise.as(null);
            }
            this.emit(Events.EventType.BEFORE_RUN, { action: action });
            return winjs_base_1.TPromise.as(action.run(context)).then(function (result) {
                _this.emit(Events.EventType.RUN, { action: action, result: result });
            }, function (error) {
                _this.emit(Events.EventType.RUN, { action: action, error: error });
            });
        };
        return ActionRunner;
    }(eventEmitter_1.EventEmitter));
    exports.ActionRunner = ActionRunner;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[14], __M([0,1,8,18,2,104,3]), function (require, exports, errors, platform, winjs_base_1, cancellation_1, lifecycle_1) {
    'use strict';
    function isThenable(obj) {
        return obj && typeof obj.then === 'function';
    }
    function toThenable(arg) {
        if (isThenable(arg)) {
            return arg;
        }
        else {
            return winjs_base_1.TPromise.as(arg);
        }
    }
    exports.toThenable = toThenable;
    function asWinJsPromise(callback) {
        var source = new cancellation_1.CancellationTokenSource();
        return new winjs_base_1.TPromise(function (resolve, reject) {
            var item = callback(source.token);
            if (isThenable(item)) {
                item.then(resolve, reject);
            }
            else {
                resolve(item);
            }
        }, function () {
            source.cancel();
        });
    }
    exports.asWinJsPromise = asWinJsPromise;
    /**
     * Hook a cancellation token to a WinJS Promise
     */
    function wireCancellationToken(token, promise) {
        token.onCancellationRequested(function () { return promise.cancel(); });
        return promise;
    }
    exports.wireCancellationToken = wireCancellationToken;
    /**
     * A helper to prevent accumulation of sequential async tasks.
     *
     * Imagine a mail man with the sole task of delivering letters. As soon as
     * a letter submitted for delivery, he drives to the destination, delivers it
     * and returns to his base. Imagine that during the trip, N more letters were submitted.
     * When the mail man returns, he picks those N letters and delivers them all in a
     * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.
     *
     * The throttler implements this via the queue() method, by providing it a task
     * factory. Following the example:
     *
     * 		var throttler = new Throttler();
     * 		var letters = [];
     *
     * 		function deliver() {
     * 			const lettersToDeliver = letters;
     * 			letters = [];
     * 			return makeTheTrip(lettersToDeliver);
     * 		}
     *
     * 		function onLetterReceived(l) {
     * 			letters.push(l);
     * 			throttler.queue(deliver);
     * 		}
     */
    var Throttler = (function () {
        function Throttler() {
            this.activePromise = null;
            this.queuedPromise = null;
            this.queuedPromiseFactory = null;
        }
        Throttler.prototype.queue = function (promiseFactory) {
            var _this = this;
            if (this.activePromise) {
                this.queuedPromiseFactory = promiseFactory;
                if (!this.queuedPromise) {
                    var onComplete_1 = function () {
                        _this.queuedPromise = null;
                        var result = _this.queue(_this.queuedPromiseFactory);
                        _this.queuedPromiseFactory = null;
                        return result;
                    };
                    this.queuedPromise = new winjs_base_1.Promise(function (c, e, p) {
                        _this.activePromise.then(onComplete_1, onComplete_1, p).done(c);
                    }, function () {
                        _this.activePromise.cancel();
                    });
                }
                return new winjs_base_1.Promise(function (c, e, p) {
                    _this.queuedPromise.then(c, e, p);
                }, function () {
                    // no-op
                });
            }
            this.activePromise = promiseFactory();
            return new winjs_base_1.Promise(function (c, e, p) {
                _this.activePromise.done(function (result) {
                    _this.activePromise = null;
                    c(result);
                }, function (err) {
                    _this.activePromise = null;
                    e(err);
                }, p);
            }, function () {
                _this.activePromise.cancel();
            });
        };
        return Throttler;
    }());
    exports.Throttler = Throttler;
    // TODO@Joao: can the previous throttler be replaced with this?
    var SimpleThrottler = (function () {
        function SimpleThrottler() {
            this.current = winjs_base_1.TPromise.as(null);
        }
        SimpleThrottler.prototype.queue = function (promiseTask) {
            return this.current = this.current.then(function () { return promiseTask(); });
        };
        return SimpleThrottler;
    }());
    exports.SimpleThrottler = SimpleThrottler;
    /**
     * A helper to delay execution of a task that is being requested often.
     *
     * Following the throttler, now imagine the mail man wants to optimize the number of
     * trips proactively. The trip itself can be long, so the he decides not to make the trip
     * as soon as a letter is submitted. Instead he waits a while, in case more
     * letters are submitted. After said waiting period, if no letters were submitted, he
     * decides to make the trip. Imagine that N more letters were submitted after the first
     * one, all within a short period of time between each other. Even though N+1
     * submissions occurred, only 1 delivery was made.
     *
     * The delayer offers this behavior via the trigger() method, into which both the task
     * to be executed and the waiting period (delay) must be passed in as arguments. Following
     * the example:
     *
     * 		var delayer = new Delayer(WAITING_PERIOD);
     * 		var letters = [];
     *
     * 		function letterReceived(l) {
     * 			letters.push(l);
     * 			delayer.trigger(() => { return makeTheTrip(); });
     * 		}
     */
    var Delayer = (function () {
        function Delayer(defaultDelay) {
            this.defaultDelay = defaultDelay;
            this.timeout = null;
            this.completionPromise = null;
            this.onSuccess = null;
            this.task = null;
        }
        Delayer.prototype.trigger = function (task, delay) {
            var _this = this;
            if (delay === void 0) { delay = this.defaultDelay; }
            this.task = task;
            this.cancelTimeout();
            if (!this.completionPromise) {
                this.completionPromise = new winjs_base_1.Promise(function (c) {
                    _this.onSuccess = c;
                }, function () {
                    // no-op
                }).then(function () {
                    _this.completionPromise = null;
                    _this.onSuccess = null;
                    var task = _this.task;
                    _this.task = null;
                    return task();
                });
            }
            this.timeout = setTimeout(function () {
                _this.timeout = null;
                _this.onSuccess(null);
            }, delay);
            return this.completionPromise;
        };
        Delayer.prototype.isTriggered = function () {
            return this.timeout !== null;
        };
        Delayer.prototype.cancel = function () {
            this.cancelTimeout();
            if (this.completionPromise) {
                this.completionPromise.cancel();
                this.completionPromise = null;
            }
        };
        Delayer.prototype.cancelTimeout = function () {
            if (this.timeout !== null) {
                clearTimeout(this.timeout);
                this.timeout = null;
            }
        };
        return Delayer;
    }());
    exports.Delayer = Delayer;
    /**
     * A helper to delay execution of a task that is being requested often, while
     * preventing accumulation of consecutive executions, while the task runs.
     *
     * Simply combine the two mail man strategies from the Throttler and Delayer
     * helpers, for an analogy.
     */
    var ThrottledDelayer = (function (_super) {
        __extends(ThrottledDelayer, _super);
        function ThrottledDelayer(defaultDelay) {
            _super.call(this, defaultDelay);
            this.throttler = new Throttler();
        }
        ThrottledDelayer.prototype.trigger = function (promiseFactory, delay) {
            var _this = this;
            return _super.prototype.trigger.call(this, function () { return _this.throttler.queue(promiseFactory); }, delay);
        };
        return ThrottledDelayer;
    }(Delayer));
    exports.ThrottledDelayer = ThrottledDelayer;
    /**
     * Similar to the ThrottledDelayer, except it also guarantees that the promise
     * factory doesn't get called more often than every `minimumPeriod` milliseconds.
     */
    var PeriodThrottledDelayer = (function (_super) {
        __extends(PeriodThrottledDelayer, _super);
        function PeriodThrottledDelayer(defaultDelay, minimumPeriod) {
            if (minimumPeriod === void 0) { minimumPeriod = 0; }
            _super.call(this, defaultDelay);
            this.minimumPeriod = minimumPeriod;
            this.periodThrottler = new Throttler();
        }
        PeriodThrottledDelayer.prototype.trigger = function (promiseFactory, delay) {
            var _this = this;
            return _super.prototype.trigger.call(this, function () {
                return _this.periodThrottler.queue(function () {
                    return winjs_base_1.Promise.join([
                        winjs_base_1.TPromise.timeout(_this.minimumPeriod),
                        promiseFactory()
                    ]).then(function (r) { return r[1]; });
                });
            }, delay);
        };
        return PeriodThrottledDelayer;
    }(ThrottledDelayer));
    exports.PeriodThrottledDelayer = PeriodThrottledDelayer;
    var PromiseSource = (function () {
        function PromiseSource() {
            var _this = this;
            this._value = new winjs_base_1.TPromise(function (c, e) {
                _this._completeCallback = c;
                _this._errorCallback = e;
            });
        }
        Object.defineProperty(PromiseSource.prototype, "value", {
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        PromiseSource.prototype.complete = function (value) {
            this._completeCallback(value);
        };
        PromiseSource.prototype.error = function (err) {
            this._errorCallback(err);
        };
        return PromiseSource;
    }());
    exports.PromiseSource = PromiseSource;
    var ShallowCancelThenPromise = (function (_super) {
        __extends(ShallowCancelThenPromise, _super);
        function ShallowCancelThenPromise(outer) {
            var completeCallback, errorCallback, progressCallback;
            _super.call(this, function (c, e, p) {
                completeCallback = c;
                errorCallback = e;
                progressCallback = p;
            }, function () {
                // cancel this promise but not the
                // outer promise
                errorCallback(errors.canceled());
            });
            outer.then(completeCallback, errorCallback, progressCallback);
        }
        return ShallowCancelThenPromise;
    }(winjs_base_1.TPromise));
    exports.ShallowCancelThenPromise = ShallowCancelThenPromise;
    /**
     * Returns a new promise that joins the provided promise. Upon completion of
     * the provided promise the provided function will always be called. This
     * method is comparable to a try-finally code block.
     * @param promise a promise
     * @param f a function that will be call in the success and error case.
     */
    function always(promise, f) {
        return new winjs_base_1.TPromise(function (c, e, p) {
            promise.done(function (result) {
                try {
                    f(result);
                }
                catch (e1) {
                    errors.onUnexpectedError(e1);
                }
                c(result);
            }, function (err) {
                try {
                    f(err);
                }
                catch (e1) {
                    errors.onUnexpectedError(e1);
                }
                e(err);
            }, function (progress) {
                p(progress);
            });
        }, function () {
            promise.cancel();
        });
    }
    exports.always = always;
    /**
     * Runs the provided list of promise factories in sequential order. The returned
     * promise will complete to an array of results from each promise.
     */
    function sequence(promiseFactory) {
        var results = [];
        // reverse since we start with last element using pop()
        promiseFactory = promiseFactory.reverse();
        function next() {
            if (promiseFactory.length) {
                return promiseFactory.pop()();
            }
            return null;
        }
        function thenHandler(result) {
            if (result) {
                results.push(result);
            }
            var n = next();
            if (n) {
                return n.then(thenHandler);
            }
            return winjs_base_1.TPromise.as(results);
        }
        return winjs_base_1.TPromise.as(null).then(thenHandler);
    }
    exports.sequence = sequence;
    function once(fn) {
        var _this = this;
        var didCall = false;
        var result;
        return function () {
            if (didCall) {
                return result;
            }
            didCall = true;
            result = fn.apply(_this, arguments);
            return result;
        };
    }
    exports.once = once;
    /**
     * A helper to queue N promises and run them all with a max degree of parallelism. The helper
     * ensures that at any time no more than M promises are running at the same time.
     */
    var Limiter = (function () {
        function Limiter(maxDegreeOfParalellism) {
            this.maxDegreeOfParalellism = maxDegreeOfParalellism;
            this.outstandingPromises = [];
            this.runningPromises = 0;
        }
        Limiter.prototype.queue = function (promiseFactory) {
            var _this = this;
            return new winjs_base_1.TPromise(function (c, e, p) {
                _this.outstandingPromises.push({
                    factory: promiseFactory,
                    c: c,
                    e: e,
                    p: p
                });
                _this.consume();
            });
        };
        Limiter.prototype.consume = function () {
            var _this = this;
            while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {
                var iLimitedTask = this.outstandingPromises.shift();
                this.runningPromises++;
                var promise = iLimitedTask.factory();
                promise.done(iLimitedTask.c, iLimitedTask.e, iLimitedTask.p);
                promise.done(function () { return _this.consumed(); }, function () { return _this.consumed(); });
            }
        };
        Limiter.prototype.consumed = function () {
            this.runningPromises--;
            this.consume();
        };
        return Limiter;
    }());
    exports.Limiter = Limiter;
    var TimeoutTimer = (function (_super) {
        __extends(TimeoutTimer, _super);
        function TimeoutTimer() {
            _super.call(this);
            this._token = -1;
        }
        TimeoutTimer.prototype.dispose = function () {
            this.cancel();
            _super.prototype.dispose.call(this);
        };
        TimeoutTimer.prototype.cancel = function () {
            if (this._token !== -1) {
                platform.clearTimeout(this._token);
                this._token = -1;
            }
        };
        TimeoutTimer.prototype.cancelAndSet = function (runner, timeout) {
            var _this = this;
            this.cancel();
            this._token = platform.setTimeout(function () {
                _this._token = -1;
                runner();
            }, timeout);
        };
        TimeoutTimer.prototype.setIfNotSet = function (runner, timeout) {
            var _this = this;
            if (this._token !== -1) {
                // timer is already set
                return;
            }
            this._token = platform.setTimeout(function () {
                _this._token = -1;
                runner();
            }, timeout);
        };
        return TimeoutTimer;
    }(lifecycle_1.Disposable));
    exports.TimeoutTimer = TimeoutTimer;
    var IntervalTimer = (function (_super) {
        __extends(IntervalTimer, _super);
        function IntervalTimer() {
            _super.call(this);
            this._token = -1;
        }
        IntervalTimer.prototype.dispose = function () {
            this.cancel();
            _super.prototype.dispose.call(this);
        };
        IntervalTimer.prototype.cancel = function () {
            if (this._token !== -1) {
                platform.clearInterval(this._token);
                this._token = -1;
            }
        };
        IntervalTimer.prototype.cancelAndSet = function (runner, interval) {
            this.cancel();
            this._token = platform.setInterval(function () {
                runner();
            }, interval);
        };
        return IntervalTimer;
    }(lifecycle_1.Disposable));
    exports.IntervalTimer = IntervalTimer;
    var RunOnceScheduler = (function () {
        function RunOnceScheduler(runner, timeout) {
            this.timeoutToken = -1;
            this.runner = runner;
            this.timeout = timeout;
            this.timeoutHandler = this.onTimeout.bind(this);
        }
        /**
         * Dispose RunOnceScheduler
         */
        RunOnceScheduler.prototype.dispose = function () {
            this.cancel();
            this.runner = null;
        };
        /**
         * Cancel current scheduled runner (if any).
         */
        RunOnceScheduler.prototype.cancel = function () {
            if (this.isScheduled()) {
                platform.clearTimeout(this.timeoutToken);
                this.timeoutToken = -1;
            }
        };
        /**
         * Replace runner. If there is a runner already scheduled, the new runner will be called.
         */
        RunOnceScheduler.prototype.setRunner = function (runner) {
            this.runner = runner;
        };
        /**
         * Cancel previous runner (if any) & schedule a new runner.
         */
        RunOnceScheduler.prototype.schedule = function (delay) {
            if (delay === void 0) { delay = this.timeout; }
            this.cancel();
            this.timeoutToken = platform.setTimeout(this.timeoutHandler, delay);
        };
        /**
         * Returns true if scheduled.
         */
        RunOnceScheduler.prototype.isScheduled = function () {
            return this.timeoutToken !== -1;
        };
        RunOnceScheduler.prototype.onTimeout = function () {
            this.timeoutToken = -1;
            if (this.runner) {
                this.runner();
            }
        };
        return RunOnceScheduler;
    }());
    exports.RunOnceScheduler = RunOnceScheduler;
    function nfcall(fn) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return new winjs_base_1.Promise(function (c, e) { return fn.apply(void 0, args.concat([function (err, result) { return err ? e(err) : c(result); }])); });
    }
    exports.nfcall = nfcall;
    function ninvoke(thisArg, fn) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        return new winjs_base_1.Promise(function (c, e) { return fn.call.apply(fn, [thisArg].concat(args, [function (err, result) { return err ? e(err) : c(result); }])); });
    }
    exports.ninvoke = ninvoke;
});






define(__m[201], __M([0,1,3,14,41]), function (require, exports, lifecycle_1, async_1, scrollableElementOptions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ScrollbarVisibilityController = (function (_super) {
        __extends(ScrollbarVisibilityController, _super);
        function ScrollbarVisibilityController(visibility, visibleClassName, invisibleClassName) {
            _super.call(this);
            this._visibility = visibility;
            this._visibleClassName = visibleClassName;
            this._invisibleClassName = invisibleClassName;
            this._domNode = null;
            this._isVisible = false;
            this._isNeeded = false;
            this._shouldBeVisible = false;
            this._revealTimer = this._register(new async_1.TimeoutTimer());
        }
        // ----------------- Hide / Reveal
        ScrollbarVisibilityController.prototype.applyVisibilitySetting = function (shouldBeVisible) {
            if (this._visibility === scrollableElementOptions_1.ScrollbarVisibility.Hidden) {
                return false;
            }
            if (this._visibility === scrollableElementOptions_1.ScrollbarVisibility.Visible) {
                return true;
            }
            return shouldBeVisible;
        };
        ScrollbarVisibilityController.prototype.setShouldBeVisible = function (rawShouldBeVisible) {
            var shouldBeVisible = this.applyVisibilitySetting(rawShouldBeVisible);
            if (this._shouldBeVisible !== shouldBeVisible) {
                this._shouldBeVisible = shouldBeVisible;
                this.ensureVisibility();
            }
        };
        ScrollbarVisibilityController.prototype.setIsNeeded = function (isNeeded) {
            if (this._isNeeded !== isNeeded) {
                this._isNeeded = isNeeded;
                this.ensureVisibility();
            }
        };
        ScrollbarVisibilityController.prototype.setDomNode = function (domNode) {
            this._domNode = domNode;
            this._domNode.setClassName(this._invisibleClassName);
            // Now that the flags & the dom node are in a consistent state, ensure the Hidden/Visible configuration
            this.setShouldBeVisible(false);
        };
        ScrollbarVisibilityController.prototype.ensureVisibility = function () {
            if (!this._isNeeded) {
                // Nothing to be rendered
                this._hide(false);
                return;
            }
            if (this._shouldBeVisible) {
                this._reveal();
            }
            else {
                this._hide(true);
            }
        };
        ScrollbarVisibilityController.prototype._reveal = function () {
            var _this = this;
            if (this._isVisible) {
                return;
            }
            this._isVisible = true;
            // The CSS animation doesn't play otherwise
            this._revealTimer.setIfNotSet(function () {
                _this._domNode.setClassName(_this._visibleClassName);
            }, 0);
        };
        ScrollbarVisibilityController.prototype._hide = function (withFadeAway) {
            this._revealTimer.cancel();
            if (!this._isVisible) {
                return;
            }
            this._isVisible = false;
            this._domNode.setClassName(this._invisibleClassName + (withFadeAway ? ' fade' : ''));
        };
        return ScrollbarVisibilityController;
    }(lifecycle_1.Disposable));
    exports.ScrollbarVisibilityController = ScrollbarVisibilityController;
});

define(__m[78], __M([0,1,2]), function (require, exports, winjs_base_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Schemas;
    (function (Schemas) {
        /**
         * A schema that is used for models that exist in memory
         * only and that have no correspondence on a server or such.
         */
        Schemas.inMemory = 'inmemory';
        /**
         * A schema that is used for setting files
         */
        Schemas.vscode = 'vscode';
        /**
         * A schema that is used for internal private files
         */
        Schemas.internal = 'private';
        Schemas.http = 'http';
        Schemas.https = 'https';
        Schemas.file = 'file';
    })(Schemas = exports.Schemas || (exports.Schemas = {}));
    function xhr(options) {
        var req = null;
        var canceled = false;
        return new winjs_base_1.TPromise(function (c, e, p) {
            req = new XMLHttpRequest();
            req.onreadystatechange = function () {
                if (canceled) {
                    return;
                }
                if (req.readyState === 4) {
                    // Handle 1223: http://bugs.jquery.com/ticket/1450
                    if ((req.status >= 200 && req.status < 300) || req.status === 1223) {
                        c(req);
                    }
                    else {
                        e(req);
                    }
                    req.onreadystatechange = function () { };
                }
                else {
                    p(req);
                }
            };
            req.open(options.type || 'GET', options.url, 
            // Promise based XHR does not support sync.
            //
            true, options.user, options.password);
            req.responseType = options.responseType || '';
            Object.keys(options.headers || {}).forEach(function (k) {
                req.setRequestHeader(k, options.headers[k]);
            });
            if (options.customRequestInitializer) {
                options.customRequestInitializer(req);
            }
            req.send(options.data);
        }, function () {
            canceled = true;
            req.abort();
        });
    }
    exports.xhr = xhr;
});






define(__m[203], __M([0,1,8,3,2,14]), function (require, exports, errors_1, lifecycle_1, winjs_base_1, async_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var INITIALIZE = '$initialize';
    var SimpleWorkerProtocol = (function () {
        function SimpleWorkerProtocol(handler) {
            this._workerId = -1;
            this._handler = handler;
            this._lastSentReq = 0;
            this._pendingReplies = Object.create(null);
        }
        SimpleWorkerProtocol.prototype.setWorkerId = function (workerId) {
            this._workerId = workerId;
        };
        SimpleWorkerProtocol.prototype.sendMessage = function (method, args) {
            var req = String(++this._lastSentReq);
            var reply = {
                c: null,
                e: null
            };
            var result = new winjs_base_1.TPromise(function (c, e, p) {
                reply.c = c;
                reply.e = e;
            }, function () {
                // Cancel not supported
            });
            this._pendingReplies[req] = reply;
            this._send({
                vsWorker: this._workerId,
                req: req,
                method: method,
                args: args
            });
            return result;
        };
        SimpleWorkerProtocol.prototype.handleMessage = function (serializedMessage) {
            var message;
            try {
                message = JSON.parse(serializedMessage);
            }
            catch (e) {
            }
            if (!message.vsWorker) {
                return;
            }
            if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
                return;
            }
            this._handleMessage(message);
        };
        SimpleWorkerProtocol.prototype._handleMessage = function (msg) {
            var _this = this;
            if (msg.seq) {
                var replyMessage = msg;
                if (!this._pendingReplies[replyMessage.seq]) {
                    console.warn('Got reply to unknown seq');
                    return;
                }
                var reply = this._pendingReplies[replyMessage.seq];
                delete this._pendingReplies[replyMessage.seq];
                if (replyMessage.err) {
                    var err = replyMessage.err;
                    if (replyMessage.err.$isError) {
                        err = new Error();
                        err.name = replyMessage.err.name;
                        err.message = replyMessage.err.message;
                        err.stack = replyMessage.err.stack;
                    }
                    reply.e(err);
                    return;
                }
                reply.c(replyMessage.res);
                return;
            }
            var requestMessage = msg;
            var req = requestMessage.req;
            var result = this._handler.handleMessage(requestMessage.method, requestMessage.args);
            result.then(function (r) {
                _this._send({
                    vsWorker: _this._workerId,
                    seq: req,
                    res: r,
                    err: undefined
                });
            }, function (e) {
                _this._send({
                    vsWorker: _this._workerId,
                    seq: req,
                    res: undefined,
                    err: errors_1.transformErrorForSerialization(e)
                });
            });
        };
        SimpleWorkerProtocol.prototype._send = function (msg) {
            var strMsg = JSON.stringify(msg);
            // console.log('SENDING: ' + strMsg);
            this._handler.sendMessage(strMsg);
        };
        return SimpleWorkerProtocol;
    }());
    /**
     * Main thread side
     */
    var SimpleWorkerClient = (function (_super) {
        __extends(SimpleWorkerClient, _super);
        function SimpleWorkerClient(workerFactory, moduleId) {
            var _this = this;
            _super.call(this);
            this._lastRequestTimestamp = -1;
            var lazyProxyFulfill = null;
            var lazyProxyReject = null;
            this._worker = this._register(workerFactory.create('vs/base/common/worker/simpleWorker', function (msg) {
                _this._protocol.handleMessage(msg);
            }, function (err) {
                // in Firefox, web workers fail lazily :(
                // we will reject the proxy
                lazyProxyReject(err);
            }));
            this._protocol = new SimpleWorkerProtocol({
                sendMessage: function (msg) {
                    _this._worker.postMessage(msg);
                },
                handleMessage: function (method, args) {
                    // Intentionally not supporting worker -> main requests
                    return winjs_base_1.TPromise.as(null);
                }
            });
            this._protocol.setWorkerId(this._worker.getId());
            // Gather loader configuration
            var loaderConfiguration = null;
            var globalRequire = window.require;
            if (typeof globalRequire.getConfig === 'function') {
                // Get the configuration from the Monaco AMD Loader
                loaderConfiguration = globalRequire.getConfig();
            }
            else if (typeof window.requirejs !== 'undefined') {
                // Get the configuration from requirejs
                loaderConfiguration = window.requirejs.s.contexts._.config;
            }
            this._lazyProxy = new winjs_base_1.TPromise(function (c, e, p) {
                lazyProxyFulfill = c;
                lazyProxyReject = e;
            }, function () { });
            // Send initialize message
            this._onModuleLoaded = this._protocol.sendMessage(INITIALIZE, [
                this._worker.getId(),
                moduleId,
                loaderConfiguration
            ]);
            this._onModuleLoaded.then(function (availableMethods) {
                var proxy = {};
                for (var i = 0; i < availableMethods.length; i++) {
                    proxy[availableMethods[i]] = createProxyMethod(availableMethods[i], proxyMethodRequest);
                }
                lazyProxyFulfill(proxy);
            }, function (e) {
                lazyProxyReject(e);
                _this._onError('Worker failed to load ' + moduleId, e);
            });
            // Create proxy to loaded code
            var proxyMethodRequest = function (method, args) {
                return _this._request(method, args);
            };
            var createProxyMethod = function (method, proxyMethodRequest) {
                return function () {
                    var args = Array.prototype.slice.call(arguments, 0);
                    return proxyMethodRequest(method, args);
                };
            };
        }
        SimpleWorkerClient.prototype.getProxyObject = function () {
            // Do not allow chaining promises to cancel the proxy creation
            return new async_1.ShallowCancelThenPromise(this._lazyProxy);
        };
        SimpleWorkerClient.prototype.getLastRequestTimestamp = function () {
            return this._lastRequestTimestamp;
        };
        SimpleWorkerClient.prototype._request = function (method, args) {
            var _this = this;
            return new winjs_base_1.TPromise(function (c, e, p) {
                _this._onModuleLoaded.then(function () {
                    _this._lastRequestTimestamp = Date.now();
                    _this._protocol.sendMessage(method, args).then(c, e);
                }, e);
            }, function () {
                // Cancel intentionally not supported
            });
        };
        SimpleWorkerClient.prototype._onError = function (message, error) {
            console.error(message);
            console.info(error);
        };
        return SimpleWorkerClient;
    }(lifecycle_1.Disposable));
    exports.SimpleWorkerClient = SimpleWorkerClient;
    /**
     * Worker side
     */
    var SimpleWorkerServer = (function () {
        function SimpleWorkerServer(postSerializedMessage) {
            var _this = this;
            this._protocol = new SimpleWorkerProtocol({
                sendMessage: function (msg) {
                    postSerializedMessage(msg);
                },
                handleMessage: function (method, args) { return _this._handleMessage(method, args); }
            });
        }
        SimpleWorkerServer.prototype.onmessage = function (msg) {
            this._protocol.handleMessage(msg);
        };
        SimpleWorkerServer.prototype._handleMessage = function (method, args) {
            if (method === INITIALIZE) {
                return this.initialize(args[0], args[1], args[2]);
            }
            if (!this._requestHandler || typeof this._requestHandler[method] !== 'function') {
                return winjs_base_1.TPromise.wrapError(new Error('Missing requestHandler or method: ' + method));
            }
            try {
                return winjs_base_1.TPromise.as(this._requestHandler[method].apply(this._requestHandler, args));
            }
            catch (e) {
                return winjs_base_1.TPromise.wrapError(e);
            }
        };
        SimpleWorkerServer.prototype.initialize = function (workerId, moduleId, loaderConfig) {
            var _this = this;
            this._protocol.setWorkerId(workerId);
            // TODO@Alex: share this code with workerServer
            if (loaderConfig) {
                // Remove 'baseUrl', handling it is beyond scope for now
                if (typeof loaderConfig.baseUrl !== 'undefined') {
                    delete loaderConfig['baseUrl'];
                }
                if (typeof loaderConfig.paths !== 'undefined') {
                    if (typeof loaderConfig.paths.vs !== 'undefined') {
                        delete loaderConfig.paths['vs'];
                    }
                }
                var nlsConfig_1 = loaderConfig['vs/nls'];
                // We need to have pseudo translation
                if (nlsConfig_1 && nlsConfig_1.pseudo) {
                    require(['vs/nls'], function (nlsPlugin) {
                        nlsPlugin.setPseudoTranslation(nlsConfig_1.pseudo);
                    });
                }
                // Since this is in a web worker, enable catching errors
                loaderConfig.catchError = true;
                self.require.config(loaderConfig);
            }
            var cc;
            var ee;
            var r = new winjs_base_1.TPromise(function (c, e, p) {
                cc = c;
                ee = e;
            });
            // Use the global require to be sure to get the global config
            self.require([moduleId], function () {
                var result = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    result[_i - 0] = arguments[_i];
                }
                var handlerModule = result[0];
                _this._requestHandler = handlerModule.create();
                var methods = [];
                for (var prop in _this._requestHandler) {
                    if (typeof _this._requestHandler[prop] === 'function') {
                        methods.push(prop);
                    }
                }
                cc(methods);
            }, ee);
            return r;
        };
        return SimpleWorkerServer;
    }());
    exports.SimpleWorkerServer = SimpleWorkerServer;
    /**
     * Called on the worker side
     */
    function create(postMessage) {
        return new SimpleWorkerServer(postMessage);
    }
    exports.create = create;
});

define(__m[118], __M([0,1,8,268,2,279]), function (require, exports, errors_1, marshalling_1, winjs_base_1, workerProtocol) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var webWorkerWarningLogged = false;
    function logOnceWebWorkerWarning(err) {
        if (!webWorkerWarningLogged) {
            webWorkerWarningLogged = true;
            console.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/Microsoft/monaco-editor#faq');
        }
        console.warn(err.message);
    }
    exports.logOnceWebWorkerWarning = logOnceWebWorkerWarning;
    var WorkerClient = (function () {
        function WorkerClient(workerFactory, moduleId) {
            var _this = this;
            this._lastMessageId = 0;
            this._promises = {};
            this._messagesQueue = [];
            this._processQueueTimeout = -1;
            this._waitingForWorkerReply = false;
            this._worker = workerFactory.create('vs/base/common/worker/workerServer', function (msg) { return _this._onSerializedMessage(msg); }, function (err) {
                // reject the onModuleLoaded promise, this signals that things are bad
                var promiseEntry = _this._promises[1];
                delete _this._promises[1];
                promiseEntry.error(err);
            });
            var loaderConfiguration = null;
            var globalRequire = window.require;
            if (typeof globalRequire.getConfig === 'function') {
                // Get the configuration from the Monaco AMD Loader
                loaderConfiguration = globalRequire.getConfig();
            }
            else if (typeof window.requirejs !== 'undefined') {
                // Get the configuration from requirejs
                loaderConfiguration = window.requirejs.s.contexts._.config;
            }
            this.onModuleLoaded = this._sendMessage(workerProtocol.MessageType.INITIALIZE, {
                id: this._worker.getId(),
                moduleId: moduleId,
                loaderConfiguration: loaderConfiguration
            });
        }
        WorkerClient.prototype.request = function (requestName, payload) {
            var _this = this;
            if (requestName.charAt(0) === '$') {
                throw new Error('Illegal requestName: ' + requestName);
            }
            var shouldCancelPromise = false, messagePromise;
            return new winjs_base_1.TPromise(function (c, e, p) {
                // hide the initialize promise inside this
                // promise so that it won't be canceled by accident
                _this.onModuleLoaded.then(function () {
                    if (!shouldCancelPromise) {
                        messagePromise = _this._sendMessage(requestName, payload).then(c, e, p);
                    }
                }, e, p);
            }, function () {
                // forward cancel to the proper promise
                if (messagePromise) {
                    messagePromise.cancel();
                }
                else {
                    shouldCancelPromise = true;
                }
            });
        };
        WorkerClient.prototype.dispose = function () {
            var promises = Object.keys(this._promises);
            if (promises.length > 0) {
                console.warn('Terminating a worker with ' + promises.length + ' pending promises:');
                console.warn(this._promises);
                for (var id in this._promises) {
                    if (promises.hasOwnProperty(id)) {
                        this._promises[id].error('Worker forcefully terminated');
                    }
                }
            }
            this._worker.dispose();
        };
        WorkerClient.prototype._sendMessage = function (type, payload) {
            var _this = this;
            var msg = {
                id: ++this._lastMessageId,
                type: type,
                timestamp: Date.now(),
                payload: payload
            };
            var pc, pe, pp;
            var promise = new winjs_base_1.TPromise(function (c, e, p) {
                pc = c;
                pe = e;
                pp = p;
            }, function () {
                _this._removeMessage(msg.id);
            });
            this._promises[msg.id] = {
                complete: pc,
                error: pe,
                progress: pp,
                type: type,
                payload: payload
            };
            this._enqueueMessage(msg);
            return promise;
        };
        WorkerClient.prototype._enqueueMessage = function (msg) {
            var lastIndexSmallerOrEqual = -1, i;
            // Find the right index to insert at - keep the queue ordered by timestamp
            for (i = this._messagesQueue.length - 1; i >= 0; i--) {
                if (this._messagesQueue[i].timestamp <= msg.timestamp) {
                    lastIndexSmallerOrEqual = i;
                    break;
                }
            }
            this._messagesQueue.splice(lastIndexSmallerOrEqual + 1, 0, msg);
            this._processMessagesQueue();
        };
        WorkerClient.prototype._removeMessage = function (msgId) {
            for (var i = 0, len = this._messagesQueue.length; i < len; i++) {
                if (this._messagesQueue[i].id === msgId) {
                    if (this._promises.hasOwnProperty(String(msgId))) {
                        delete this._promises[String(msgId)];
                    }
                    this._messagesQueue.splice(i, 1);
                    this._processMessagesQueue();
                    return;
                }
            }
        };
        WorkerClient.prototype._processMessagesQueue = function () {
            var _this = this;
            if (this._processQueueTimeout !== -1) {
                clearTimeout(this._processQueueTimeout);
                this._processQueueTimeout = -1;
            }
            if (this._messagesQueue.length === 0) {
                return;
            }
            if (this._waitingForWorkerReply) {
                return;
            }
            var delayUntilNextMessage = this._messagesQueue[0].timestamp - (new Date()).getTime();
            delayUntilNextMessage = Math.max(0, delayUntilNextMessage);
            this._processQueueTimeout = setTimeout(function () {
                _this._processQueueTimeout = -1;
                if (_this._messagesQueue.length === 0) {
                    return;
                }
                _this._waitingForWorkerReply = true;
                var msg = _this._messagesQueue.shift();
                _this._postMessage(msg);
            }, delayUntilNextMessage);
        };
        WorkerClient.prototype._postMessage = function (msg) {
            this._worker.postMessage(marshalling_1.stringify(msg));
        };
        WorkerClient.prototype._onSerializedMessage = function (msg) {
            var message = null;
            try {
                message = marshalling_1.parse(msg);
            }
            catch (e) {
            }
            if (message) {
                this._onmessage(message);
            }
        };
        WorkerClient.prototype._onmessage = function (msg) {
            if (!msg.monacoWorker) {
                return;
            }
            if (msg.from && msg.from !== this._worker.getId()) {
                return;
            }
            switch (msg.type) {
                case workerProtocol.MessageType.REPLY:
                    var serverReplyMessage = msg;
                    this._waitingForWorkerReply = false;
                    if (!this._promises.hasOwnProperty(String(serverReplyMessage.id))) {
                        this._onError('Received unexpected message from Worker:', msg);
                        return;
                    }
                    switch (serverReplyMessage.action) {
                        case workerProtocol.ReplyType.COMPLETE:
                            this._promises[serverReplyMessage.id].complete(serverReplyMessage.payload);
                            delete this._promises[serverReplyMessage.id];
                            break;
                        case workerProtocol.ReplyType.ERROR:
                            this._onError('Main Thread sent to worker the following message:', {
                                type: this._promises[serverReplyMessage.id].type,
                                payload: this._promises[serverReplyMessage.id].payload
                            });
                            this._onError('And the worker replied with an error:', serverReplyMessage.payload);
                            errors_1.onUnexpectedError(serverReplyMessage.payload);
                            this._promises[serverReplyMessage.id].error(serverReplyMessage.payload);
                            delete this._promises[serverReplyMessage.id];
                            break;
                        case workerProtocol.ReplyType.PROGRESS:
                            this._promises[serverReplyMessage.id].progress(serverReplyMessage.payload);
                            break;
                    }
                    break;
                case workerProtocol.MessageType.PRINT:
                    var serverPrintMessage = msg;
                    this._consoleLog(serverPrintMessage.level, serverPrintMessage.payload);
                    break;
                default:
                    this._onError('Received unexpected message from worker:', msg);
            }
            this._processMessagesQueue();
        };
        WorkerClient.prototype._consoleLog = function (level, payload) {
            switch (level) {
                case workerProtocol.PrintType.LOG:
                    console.log(payload);
                    break;
                case workerProtocol.PrintType.DEBUG:
                    console.info(payload);
                    break;
                case workerProtocol.PrintType.INFO:
                    console.info(payload);
                    break;
                case workerProtocol.PrintType.WARN:
                    console.warn(payload);
                    break;
                case workerProtocol.PrintType.ERROR:
                    console.error(payload);
                    break;
                default:
                    this._onError('Received unexpected message from Worker:', payload);
            }
        };
        WorkerClient.prototype._onError = function (message, error) {
            console.error(message);
            console.info(error);
        };
        return WorkerClient;
    }());
    exports.WorkerClient = WorkerClient;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[205], __M([0,1,2,26]), function (require, exports, winjs_base_1, types_1) {
    "use strict";
    var DataSource = (function () {
        function DataSource(arg) {
            this.modelProvider = types_1.isFunction(arg.getModel) ? arg : { getModel: function () { return arg; } };
        }
        DataSource.prototype.getId = function (tree, element) {
            if (!element) {
                return null;
            }
            var model = this.modelProvider.getModel();
            return model === element ? '__root__' : model.dataSource.getId(element);
        };
        DataSource.prototype.hasChildren = function (tree, element) {
            var model = this.modelProvider.getModel();
            return model && model === element && model.entries.length > 0;
        };
        DataSource.prototype.getChildren = function (tree, element) {
            var model = this.modelProvider.getModel();
            return winjs_base_1.TPromise.as(model === element ? model.entries : []);
        };
        DataSource.prototype.getParent = function (tree, element) {
            return winjs_base_1.TPromise.as(null);
        };
        return DataSource;
    }());
    exports.DataSource = DataSource;
    var AccessibilityProvider = (function () {
        function AccessibilityProvider(modelProvider) {
            this.modelProvider = modelProvider;
        }
        AccessibilityProvider.prototype.getAriaLabel = function (tree, element) {
            var model = this.modelProvider.getModel();
            return model.accessibilityProvider && model.accessibilityProvider.getAriaLabel(element);
        };
        return AccessibilityProvider;
    }());
    exports.AccessibilityProvider = AccessibilityProvider;
    var Filter = (function () {
        function Filter(modelProvider) {
            this.modelProvider = modelProvider;
        }
        Filter.prototype.isVisible = function (tree, element) {
            var model = this.modelProvider.getModel();
            if (!model.filter) {
                return true;
            }
            return model.filter.isVisible(element);
        };
        return Filter;
    }());
    exports.Filter = Filter;
    var Renderer = (function () {
        function Renderer(modelProvider) {
            this.modelProvider = modelProvider;
        }
        Renderer.prototype.getHeight = function (tree, element) {
            var model = this.modelProvider.getModel();
            return model.renderer.getHeight(element);
        };
        Renderer.prototype.getTemplateId = function (tree, element) {
            var model = this.modelProvider.getModel();
            return model.renderer.getTemplateId(element);
        };
        Renderer.prototype.renderTemplate = function (tree, templateId, container) {
            var model = this.modelProvider.getModel();
            return model.renderer.renderTemplate(templateId, container);
        };
        Renderer.prototype.renderElement = function (tree, element, templateId, templateData) {
            var model = this.modelProvider.getModel();
            model.renderer.renderElement(element, templateId, templateData);
        };
        Renderer.prototype.disposeTemplate = function (tree, templateId, templateData) {
            var model = this.modelProvider.getModel();
            model.renderer.disposeTemplate(templateId, templateData);
        };
        return Renderer;
    }());
    exports.Renderer = Renderer;
});






define(__m[206], __M([0,1,47,8,3,37,23,2]), function (require, exports, Assert, errors_1, lifecycle_1, arrays, Events, WinJS) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LockData = (function (_super) {
        __extends(LockData, _super);
        function LockData(item) {
            _super.call(this);
            this._item = item;
        }
        Object.defineProperty(LockData.prototype, "item", {
            get: function () {
                return this._item;
            },
            enumerable: true,
            configurable: true
        });
        LockData.prototype.dispose = function () {
            this.emit('unlock');
            _super.prototype.dispose.call(this);
        };
        return LockData;
    }(Events.EventEmitter));
    exports.LockData = LockData;
    var Lock = (function () {
        function Lock() {
            this.locks = Object.create({});
        }
        Lock.prototype.isLocked = function (item) {
            return !!this.locks[item.id];
        };
        Lock.prototype.run = function (item, fn) {
            var _this = this;
            var lock = this.getLock(item);
            if (lock) {
                var unbindListener;
                return new WinJS.Promise(function (c, e) {
                    unbindListener = lock.addOneTimeDisposableListener('unlock', function () {
                        return _this.run(item, fn).then(c, e);
                    });
                }, function () { unbindListener.dispose(); });
            }
            var result;
            return new WinJS.Promise(function (c, e) {
                if (item.isDisposed()) {
                    return e(new Error('Item is disposed.'));
                }
                var lock = _this.locks[item.id] = new LockData(item);
                result = fn().then(function (r) {
                    delete _this.locks[item.id];
                    lock.dispose();
                    return r;
                }).then(c, e);
                return result;
            }, function () { return result.cancel(); });
        };
        Lock.prototype.getLock = function (item) {
            var key;
            for (key in this.locks) {
                var lock = this.locks[key];
                if (item.intersects(lock.item)) {
                    return lock;
                }
            }
            return null;
        };
        return Lock;
    }());
    exports.Lock = Lock;
    var ItemRegistry = (function (_super) {
        __extends(ItemRegistry, _super);
        function ItemRegistry() {
            _super.call(this);
            this.items = {};
        }
        ItemRegistry.prototype.register = function (item) {
            Assert.ok(!this.isRegistered(item.id), 'item already registered: ' + item.id);
            this.items[item.id] = { item: item, disposable: this.addEmitter2(item) };
        };
        ItemRegistry.prototype.deregister = function (item) {
            Assert.ok(this.isRegistered(item.id), 'item not registered: ' + item.id);
            this.items[item.id].disposable.dispose();
            delete this.items[item.id];
        };
        ItemRegistry.prototype.isRegistered = function (id) {
            return this.items.hasOwnProperty(id);
        };
        ItemRegistry.prototype.getItem = function (id) {
            var result = this.items[id];
            return result ? result.item : null;
        };
        ItemRegistry.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.items = null;
        };
        return ItemRegistry;
    }(Events.EventEmitter));
    exports.ItemRegistry = ItemRegistry;
    var Item = (function (_super) {
        __extends(Item, _super);
        function Item(id, registry, context, lock, element) {
            _super.call(this);
            this.registry = registry;
            this.context = context;
            this.lock = lock;
            this.element = element;
            this.id = id;
            this.registry.register(this);
            this.doesHaveChildren = this.context.dataSource.hasChildren(this.context.tree, this.element);
            this.needsChildrenRefresh = true;
            this.parent = null;
            this.previous = null;
            this.next = null;
            this.firstChild = null;
            this.lastChild = null;
            this.userContent = null;
            this.traits = {};
            this.depth = 0;
            this.expanded = false;
            this.emit('item:create', { item: this });
            this.visible = this._isVisible();
            this.height = this._getHeight();
            this._isDisposed = false;
        }
        Item.prototype.getElement = function () {
            return this.element;
        };
        Item.prototype.hasChildren = function () {
            return this.doesHaveChildren;
        };
        Item.prototype.getDepth = function () {
            return this.depth;
        };
        Item.prototype.isVisible = function () {
            return this.visible;
        };
        Item.prototype.setVisible = function (value) {
            this.visible = value;
        };
        Item.prototype.isExpanded = function () {
            return this.expanded;
        };
        /* protected */ Item.prototype._setExpanded = function (value) {
            this.expanded = value;
        };
        Item.prototype.reveal = function (relativeTop) {
            if (relativeTop === void 0) { relativeTop = null; }
            var eventData = { item: this, relativeTop: relativeTop };
            this.emit('item:reveal', eventData);
        };
        Item.prototype.expand = function () {
            var _this = this;
            if (this.isExpanded() || !this.doesHaveChildren || this.lock.isLocked(this)) {
                return WinJS.TPromise.as(false);
            }
            var result = this.lock.run(this, function () {
                var eventData = { item: _this };
                var result;
                _this.emit('item:expanding', eventData);
                if (_this.needsChildrenRefresh) {
                    result = _this.refreshChildren(false, true, true);
                }
                else {
                    result = WinJS.TPromise.as(null);
                }
                return result.then(function () {
                    _this._setExpanded(true);
                    _this.emit('item:expanded', eventData);
                    return true;
                });
            });
            return result.then(function (r) {
                if (_this.isDisposed()) {
                    return false;
                }
                // Auto expand single child folders
                if (_this.context.options.autoExpandSingleChildren && r && _this.firstChild !== null && _this.firstChild === _this.lastChild && _this.firstChild.isVisible()) {
                    return _this.firstChild.expand().then(function () { return true; });
                }
                return r;
            });
        };
        Item.prototype.collapse = function (recursive) {
            var _this = this;
            if (recursive === void 0) { recursive = false; }
            if (recursive) {
                var collapseChildrenPromise = WinJS.TPromise.as(null);
                this.forEachChild(function (child) {
                    collapseChildrenPromise = collapseChildrenPromise.then(function () { return child.collapse(true); });
                });
                return collapseChildrenPromise.then(function () {
                    return _this.collapse(false);
                });
            }
            else {
                if (!this.isExpanded() || this.lock.isLocked(this)) {
                    return WinJS.TPromise.as(false);
                }
                return this.lock.run(this, function () {
                    var eventData = { item: _this };
                    _this.emit('item:collapsing', eventData);
                    _this._setExpanded(false);
                    _this.emit('item:collapsed', eventData);
                    return WinJS.TPromise.as(true);
                });
            }
        };
        Item.prototype.addTrait = function (trait) {
            var eventData = { item: this, trait: trait };
            this.traits[trait] = true;
            this.emit('item:addTrait', eventData);
        };
        Item.prototype.removeTrait = function (trait) {
            var eventData = { item: this, trait: trait };
            delete this.traits[trait];
            this.emit('item:removeTrait', eventData);
        };
        Item.prototype.hasTrait = function (trait) {
            return this.traits[trait] || false;
        };
        Item.prototype.getAllTraits = function () {
            var result = [];
            var trait;
            for (trait in this.traits) {
                if (this.traits.hasOwnProperty(trait) && this.traits[trait]) {
                    result.push(trait);
                }
            }
            return result;
        };
        Item.prototype.getHeight = function () {
            return this.height;
        };
        Item.prototype.refreshChildren = function (recursive, safe, force) {
            var _this = this;
            if (safe === void 0) { safe = false; }
            if (force === void 0) { force = false; }
            if (!force && !this.isExpanded()) {
                this.needsChildrenRefresh = true;
                return WinJS.TPromise.as(this);
            }
            this.needsChildrenRefresh = false;
            var doRefresh = function () {
                var eventData = { item: _this, isNested: safe };
                _this.emit('item:childrenRefreshing', eventData);
                var childrenPromise;
                if (_this.doesHaveChildren) {
                    childrenPromise = _this.context.dataSource.getChildren(_this.context.tree, _this.element);
                }
                else {
                    childrenPromise = WinJS.TPromise.as([]);
                }
                var result = childrenPromise.then(function (elements) {
                    if (_this.isDisposed()) {
                        return WinJS.TPromise.as(null);
                    }
                    elements = !elements ? [] : elements.slice(0);
                    elements = _this.sort(elements);
                    var staleItems = {};
                    while (_this.firstChild !== null) {
                        staleItems[_this.firstChild.id] = _this.firstChild;
                        _this.removeChild(_this.firstChild);
                    }
                    for (var i = 0, len = elements.length; i < len; i++) {
                        var element = elements[i];
                        var id = _this.context.dataSource.getId(_this.context.tree, element);
                        var item = staleItems[id] || new Item(id, _this.registry, _this.context, _this.lock, element);
                        item.element = element;
                        if (recursive) {
                            item.needsChildrenRefresh = recursive;
                        }
                        delete staleItems[id];
                        _this.addChild(item);
                    }
                    for (var staleItemId in staleItems) {
                        if (staleItems.hasOwnProperty(staleItemId)) {
                            staleItems[staleItemId].dispose();
                        }
                    }
                    if (recursive) {
                        return WinJS.Promise.join(_this.mapEachChild(function (child) {
                            return child.doRefresh(recursive, true);
                        }));
                    }
                    else {
                        return WinJS.TPromise.as(null);
                    }
                });
                return result
                    .then(null, errors_1.onUnexpectedError)
                    .then(function () { return _this.emit('item:childrenRefreshed', eventData); });
            };
            return safe ? doRefresh() : this.lock.run(this, doRefresh);
        };
        Item.prototype.doRefresh = function (recursive, safe) {
            if (safe === void 0) { safe = false; }
            var eventData = { item: this };
            this.doesHaveChildren = this.context.dataSource.hasChildren(this.context.tree, this.element);
            this.height = this._getHeight();
            this.setVisible(this._isVisible());
            this.emit('item:refresh', eventData);
            return this.refreshChildren(recursive, safe);
        };
        Item.prototype.refresh = function (recursive) {
            return this.doRefresh(recursive);
        };
        Item.prototype.getNavigator = function () {
            return new TreeNavigator(this);
        };
        Item.prototype.intersects = function (other) {
            return this.isAncestorOf(other) || other.isAncestorOf(this);
        };
        Item.prototype.getHierarchy = function () {
            var result = [];
            var node = this;
            do {
                result.push(node);
                node = node.parent;
            } while (node);
            result.reverse();
            return result;
        };
        Item.prototype.isAncestorOf = function (item) {
            while (item) {
                if (item.id === this.id) {
                    return true;
                }
                item = item.parent;
            }
            return false;
        };
        Item.prototype.addChild = function (item, afterItem) {
            if (afterItem === void 0) { afterItem = this.lastChild; }
            var isEmpty = this.firstChild === null;
            var atHead = afterItem === null;
            var atTail = afterItem === this.lastChild;
            if (isEmpty) {
                this.firstChild = this.lastChild = item;
                item.next = item.previous = null;
            }
            else if (atHead) {
                this.firstChild.previous = item;
                item.next = this.firstChild;
                item.previous = null;
                this.firstChild = item;
            }
            else if (atTail) {
                this.lastChild.next = item;
                item.next = null;
                item.previous = this.lastChild;
                this.lastChild = item;
            }
            else {
                item.previous = afterItem;
                item.next = afterItem.next;
                afterItem.next.previous = item;
                afterItem.next = item;
            }
            item.parent = this;
            item.depth = this.depth + 1;
        };
        Item.prototype.removeChild = function (item) {
            var isFirstChild = this.firstChild === item;
            var isLastChild = this.lastChild === item;
            if (isFirstChild && isLastChild) {
                this.firstChild = this.lastChild = null;
            }
            else if (isFirstChild) {
                item.next.previous = null;
                this.firstChild = item.next;
            }
            else if (isLastChild) {
                item.previous.next = null;
                this.lastChild = item.previous;
            }
            else {
                item.next.previous = item.previous;
                item.previous.next = item.next;
            }
            item.parent = null;
            item.depth = null;
        };
        Item.prototype.forEachChild = function (fn) {
            var child = this.firstChild, next;
            while (child) {
                next = child.next;
                fn(child);
                child = next;
            }
        };
        Item.prototype.mapEachChild = function (fn) {
            var result = [];
            this.forEachChild(function (child) {
                result.push(fn(child));
            });
            return result;
        };
        Item.prototype.sort = function (elements) {
            var _this = this;
            if (this.context.sorter) {
                return elements.sort(function (element, otherElement) {
                    return _this.context.sorter.compare(_this.context.tree, element, otherElement);
                });
            }
            return elements;
        };
        /* protected */ Item.prototype._getHeight = function () {
            return this.context.renderer.getHeight(this.context.tree, this.element);
        };
        /* protected */ Item.prototype._isVisible = function () {
            return this.context.filter.isVisible(this.context.tree, this.element);
        };
        Item.prototype.isDisposed = function () {
            return this._isDisposed;
        };
        Item.prototype.dispose = function () {
            this.forEachChild(function (child) { return child.dispose(); });
            this.parent = null;
            this.previous = null;
            this.next = null;
            this.firstChild = null;
            this.lastChild = null;
            var eventData = { item: this };
            this.emit('item:dispose', eventData);
            this.registry.deregister(this);
            _super.prototype.dispose.call(this);
            this._isDisposed = true;
        };
        return Item;
    }(Events.EventEmitter));
    exports.Item = Item;
    var RootItem = (function (_super) {
        __extends(RootItem, _super);
        function RootItem(id, registry, context, lock, element) {
            _super.call(this, id, registry, context, lock, element);
        }
        RootItem.prototype.isVisible = function () {
            return false;
        };
        RootItem.prototype.setVisible = function (value) {
            // no-op
        };
        RootItem.prototype.isExpanded = function () {
            return true;
        };
        /* protected */ RootItem.prototype._setExpanded = function (value) {
            // no-op
        };
        RootItem.prototype.render = function () {
            // no-op
        };
        /* protected */ RootItem.prototype._getHeight = function () {
            return 0;
        };
        /* protected */ RootItem.prototype._isVisible = function () {
            return false;
        };
        return RootItem;
    }(Item));
    var TreeNavigator = (function () {
        function TreeNavigator(item, subTreeOnly) {
            if (subTreeOnly === void 0) { subTreeOnly = true; }
            this.item = item;
            this.start = subTreeOnly ? item : null;
        }
        TreeNavigator.lastDescendantOf = function (item) {
            if (!item) {
                return null;
            }
            else {
                if (!item.isVisible() || !item.isExpanded() || item.lastChild === null) {
                    return item;
                }
                else {
                    return TreeNavigator.lastDescendantOf(item.lastChild);
                }
            }
        };
        TreeNavigator.prototype.current = function () {
            return this.item || null;
        };
        TreeNavigator.prototype.next = function () {
            if (this.item) {
                do {
                    if ((this.item instanceof RootItem || (this.item.isVisible() && this.item.isExpanded())) && this.item.firstChild) {
                        this.item = this.item.firstChild;
                    }
                    else if (this.item === this.start) {
                        this.item = null;
                    }
                    else {
                        // select next brother, next uncle, next great-uncle, etc...
                        while (this.item && this.item !== this.start && !this.item.next) {
                            this.item = this.item.parent;
                        }
                        if (this.item === this.start) {
                            this.item = null;
                        }
                        this.item = !this.item ? null : this.item.next;
                    }
                } while (this.item && !this.item.isVisible());
            }
            return this.item || null;
        };
        TreeNavigator.prototype.previous = function () {
            if (this.item) {
                do {
                    var previous = TreeNavigator.lastDescendantOf(this.item.previous);
                    if (previous) {
                        this.item = previous;
                    }
                    else if (this.item.parent && this.item.parent !== this.start && this.item.parent.isVisible()) {
                        this.item = this.item.parent;
                    }
                    else {
                        this.item = null;
                    }
                } while (this.item && !this.item.isVisible());
            }
            return this.item || null;
        };
        TreeNavigator.prototype.parent = function () {
            if (this.item) {
                var parent = this.item.parent;
                if (parent && parent !== this.start && parent.isVisible()) {
                    this.item = parent;
                }
                else {
                    this.item = null;
                }
            }
            return this.item || null;
        };
        TreeNavigator.prototype.first = function () {
            this.item = this.start;
            this.next();
            return this.item || null;
        };
        TreeNavigator.prototype.last = function () {
            if (this.start && this.start.isExpanded()) {
                this.item = this.start.lastChild;
                if (this.item && !this.item.isVisible()) {
                    this.previous();
                }
            }
            return this.item || null;
        };
        return TreeNavigator;
    }());
    exports.TreeNavigator = TreeNavigator;
    function getRange(one, other) {
        var oneHierarchy = one.getHierarchy();
        var otherHierarchy = other.getHierarchy();
        var length = arrays.commonPrefixLength(oneHierarchy, otherHierarchy);
        var item = oneHierarchy[length - 1];
        var nav = item.getNavigator();
        var oneIndex = null;
        var otherIndex = null;
        var index = 0;
        var result = [];
        while (item && (oneIndex === null || otherIndex === null)) {
            result.push(item);
            if (item === one) {
                oneIndex = index;
            }
            if (item === other) {
                otherIndex = index;
            }
            index++;
            item = nav.next();
        }
        if (oneIndex === null || otherIndex === null) {
            return [];
        }
        var min = Math.min(oneIndex, otherIndex);
        var max = Math.max(oneIndex, otherIndex);
        return result.slice(min, max + 1);
    }
    var TreeModel = (function (_super) {
        __extends(TreeModel, _super);
        function TreeModel(context) {
            _super.call(this);
            this.context = context;
            this.input = null;
            this.traitsToItems = {};
        }
        TreeModel.prototype.setInput = function (element) {
            var _this = this;
            var eventData = { item: this.input };
            this.emit('clearingInput', eventData);
            this.setSelection([]);
            this.setFocus();
            this.setHighlight();
            this.lock = new Lock();
            if (this.input) {
                this.input.dispose();
            }
            if (this.registry) {
                this.registry.dispose();
                this.registryDisposable.dispose();
            }
            this.registry = new ItemRegistry();
            this.registryDisposable = lifecycle_1.combinedDisposable([
                this.addEmitter2(this.registry),
                this.registry.addListener2('item:dispose', function (event) {
                    event.item.getAllTraits()
                        .forEach(function (trait) { return delete _this.traitsToItems[trait][event.item.id]; });
                })
            ]);
            var id = this.context.dataSource.getId(this.context.tree, element);
            this.input = new RootItem(id, this.registry, this.context, this.lock, element);
            eventData = { item: this.input };
            this.emit('setInput', eventData);
            return this.refresh(this.input);
        };
        TreeModel.prototype.getInput = function () {
            return this.input ? this.input.getElement() : null;
        };
        TreeModel.prototype.refresh = function (element, recursive) {
            var _this = this;
            if (element === void 0) { element = null; }
            if (recursive === void 0) { recursive = true; }
            var item = this.getItem(element);
            if (!item) {
                return WinJS.TPromise.as(null);
            }
            var eventData = { item: item, recursive: recursive };
            this.emit('refreshing', eventData);
            return item.refresh(recursive).then(function () {
                _this.emit('refreshed', eventData);
            });
        };
        TreeModel.prototype.refreshAll = function (elements, recursive) {
            var _this = this;
            if (recursive === void 0) { recursive = true; }
            var promises = [];
            this.deferredEmit(function () {
                for (var i = 0, len = elements.length; i < len; i++) {
                    promises.push(_this.refresh(elements[i], recursive));
                }
            });
            return WinJS.Promise.join(promises);
        };
        TreeModel.prototype.expand = function (element) {
            var item = this.getItem(element);
            if (!item) {
                return WinJS.TPromise.as(false);
            }
            return item.expand();
        };
        TreeModel.prototype.expandAll = function (elements) {
            if (!elements) {
                elements = [];
                var item;
                var nav = this.getNavigator();
                while (item = nav.next()) {
                    elements.push(item);
                }
            }
            var promises = [];
            for (var i = 0, len = elements.length; i < len; i++) {
                promises.push(this.expand(elements[i]));
            }
            return WinJS.Promise.join(promises);
        };
        TreeModel.prototype.collapse = function (element, recursive) {
            if (recursive === void 0) { recursive = false; }
            var item = this.getItem(element);
            if (!item) {
                return WinJS.TPromise.as(false);
            }
            return item.collapse(recursive);
        };
        TreeModel.prototype.collapseAll = function (elements, recursive) {
            if (elements === void 0) { elements = null; }
            if (recursive === void 0) { recursive = false; }
            if (!elements) {
                elements = [this.input];
                recursive = true;
            }
            var promises = [];
            for (var i = 0, len = elements.length; i < len; i++) {
                promises.push(this.collapse(elements[i], recursive));
            }
            return WinJS.Promise.join(promises);
        };
        TreeModel.prototype.toggleExpansion = function (element) {
            return this.isExpanded(element) ? this.collapse(element) : this.expand(element);
        };
        TreeModel.prototype.toggleExpansionAll = function (elements) {
            var promises = [];
            for (var i = 0, len = elements.length; i < len; i++) {
                promises.push(this.toggleExpansion(elements[i]));
            }
            return WinJS.Promise.join(promises);
        };
        TreeModel.prototype.isExpanded = function (element) {
            var item = this.getItem(element);
            if (!item) {
                return false;
            }
            return item.isExpanded();
        };
        TreeModel.prototype.getExpandedElements = function () {
            var result = [];
            var item;
            var nav = this.getNavigator();
            while (item = nav.next()) {
                if (item.isExpanded()) {
                    result.push(item.getElement());
                }
            }
            return result;
        };
        TreeModel.prototype.reveal = function (element, relativeTop) {
            var _this = this;
            if (relativeTop === void 0) { relativeTop = null; }
            return this.resolveUnknownParentChain(element).then(function (chain) {
                var result = WinJS.TPromise.as(null);
                chain.forEach(function (e) {
                    result = result.then(function () { return _this.expand(e); });
                });
                return result;
            }).then(function () {
                var item = _this.getItem(element);
                if (item) {
                    return item.reveal(relativeTop);
                }
            });
        };
        TreeModel.prototype.resolveUnknownParentChain = function (element) {
            var _this = this;
            return this.context.dataSource.getParent(this.context.tree, element).then(function (parent) {
                if (!parent) {
                    return WinJS.TPromise.as([]);
                }
                return _this.resolveUnknownParentChain(parent).then(function (result) {
                    result.push(parent);
                    return result;
                });
            });
        };
        TreeModel.prototype.setHighlight = function (element, eventPayload) {
            this.setTraits('highlighted', element ? [element] : []);
            var eventData = { highlight: this.getHighlight(), payload: eventPayload };
            this.emit('highlight', eventData);
        };
        TreeModel.prototype.getHighlight = function (includeHidden) {
            var result = this.getElementsWithTrait('highlighted', includeHidden);
            return result.length === 0 ? null : result[0];
        };
        TreeModel.prototype.isHighlighted = function (element) {
            var item = this.getItem(element);
            if (!item) {
                return false;
            }
            return item.hasTrait('highlighted');
        };
        TreeModel.prototype.select = function (element, eventPayload) {
            this.selectAll([element], eventPayload);
        };
        TreeModel.prototype.selectRange = function (fromElement, toElement, eventPayload) {
            var fromItem = this.getItem(fromElement);
            var toItem = this.getItem(toElement);
            if (!fromItem || !toItem) {
                return;
            }
            this.selectAll(getRange(fromItem, toItem), eventPayload);
        };
        TreeModel.prototype.deselectRange = function (fromElement, toElement, eventPayload) {
            var fromItem = this.getItem(fromElement);
            var toItem = this.getItem(toElement);
            if (!fromItem || !toItem) {
                return;
            }
            this.deselectAll(getRange(fromItem, toItem), eventPayload);
        };
        TreeModel.prototype.selectAll = function (elements, eventPayload) {
            this.addTraits('selected', elements);
            var eventData = { selection: this.getSelection(), payload: eventPayload };
            this.emit('selection', eventData);
        };
        TreeModel.prototype.deselect = function (element, eventPayload) {
            this.deselectAll([element], eventPayload);
        };
        TreeModel.prototype.deselectAll = function (elements, eventPayload) {
            this.removeTraits('selected', elements);
            var eventData = { selection: this.getSelection(), payload: eventPayload };
            this.emit('selection', eventData);
        };
        TreeModel.prototype.setSelection = function (elements, eventPayload) {
            this.setTraits('selected', elements);
            var eventData = { selection: this.getSelection(), payload: eventPayload };
            this.emit('selection', eventData);
        };
        TreeModel.prototype.toggleSelection = function (element, eventPayload) {
            this.toggleTrait('selected', element);
            var eventData = { selection: this.getSelection(), payload: eventPayload };
            this.emit('selection', eventData);
        };
        TreeModel.prototype.isSelected = function (element) {
            var item = this.getItem(element);
            if (!item) {
                return false;
            }
            return item.hasTrait('selected');
        };
        TreeModel.prototype.getSelection = function (includeHidden) {
            return this.getElementsWithTrait('selected', includeHidden);
        };
        TreeModel.prototype.selectNext = function (count, clearSelection, eventPayload) {
            if (count === void 0) { count = 1; }
            if (clearSelection === void 0) { clearSelection = true; }
            var selection = this.getSelection();
            var item = selection.length > 0 ? selection[0] : this.input;
            var nextItem;
            var nav = this.getNavigator(item, false);
            for (var i = 0; i < count; i++) {
                nextItem = nav.next();
                if (!nextItem) {
                    break;
                }
                item = nextItem;
            }
            if (clearSelection) {
                this.setSelection([item], eventPayload);
            }
            else {
                this.select(item, eventPayload);
            }
        };
        TreeModel.prototype.selectPrevious = function (count, clearSelection, eventPayload) {
            if (count === void 0) { count = 1; }
            if (clearSelection === void 0) { clearSelection = true; }
            var selection = this.getSelection(), item = null, previousItem = null;
            if (selection.length === 0) {
                var nav = this.getNavigator(this.input);
                while (item = nav.next()) {
                    previousItem = item;
                }
                item = previousItem;
            }
            else {
                item = selection[0];
                var nav = this.getNavigator(item, false);
                for (var i = 0; i < count; i++) {
                    previousItem = nav.previous();
                    if (!previousItem) {
                        break;
                    }
                    item = previousItem;
                }
            }
            if (clearSelection) {
                this.setSelection([item], eventPayload);
            }
            else {
                this.select(item, eventPayload);
            }
        };
        TreeModel.prototype.selectParent = function (eventPayload, clearSelection) {
            if (clearSelection === void 0) { clearSelection = true; }
            var selection = this.getSelection();
            var item = selection.length > 0 ? selection[0] : this.input;
            var nav = this.getNavigator(item, false);
            var parent = nav.parent();
            if (parent) {
                if (clearSelection) {
                    this.setSelection([parent], eventPayload);
                }
                else {
                    this.select(parent, eventPayload);
                }
            }
        };
        TreeModel.prototype.setFocus = function (element, eventPayload) {
            this.setTraits('focused', element ? [element] : []);
            var eventData = { focus: this.getFocus(), payload: eventPayload };
            this.emit('focus', eventData);
        };
        TreeModel.prototype.isFocused = function (element) {
            var item = this.getItem(element);
            if (!item) {
                return false;
            }
            return item.hasTrait('focused');
        };
        TreeModel.prototype.getFocus = function (includeHidden) {
            var result = this.getElementsWithTrait('focused', includeHidden);
            return result.length === 0 ? null : result[0];
        };
        TreeModel.prototype.focusNext = function (count, eventPayload) {
            if (count === void 0) { count = 1; }
            var item = this.getFocus() || this.input;
            var nextItem;
            var nav = this.getNavigator(item, false);
            for (var i = 0; i < count; i++) {
                nextItem = nav.next();
                if (!nextItem) {
                    break;
                }
                item = nextItem;
            }
            this.setFocus(item, eventPayload);
        };
        TreeModel.prototype.focusPrevious = function (count, eventPayload) {
            if (count === void 0) { count = 1; }
            var item = this.getFocus() || this.input;
            var previousItem;
            var nav = this.getNavigator(item, false);
            for (var i = 0; i < count; i++) {
                previousItem = nav.previous();
                if (!previousItem) {
                    break;
                }
                item = previousItem;
            }
            this.setFocus(item, eventPayload);
        };
        TreeModel.prototype.focusParent = function (eventPayload) {
            var item = this.getFocus() || this.input;
            var nav = this.getNavigator(item, false);
            var parent = nav.parent();
            if (parent) {
                this.setFocus(parent, eventPayload);
            }
        };
        TreeModel.prototype.focusFirst = function (eventPayload) {
            this.focusNth(0, eventPayload);
        };
        TreeModel.prototype.focusNth = function (index, eventPayload) {
            var nav = this.getNavigator(this.input);
            var item = nav.first();
            for (var i = 0; i < index; i++) {
                item = nav.next();
            }
            if (item) {
                this.setFocus(item, eventPayload);
            }
        };
        TreeModel.prototype.focusLast = function (eventPayload) {
            var nav = this.getNavigator(this.input);
            var item = nav.last();
            if (item) {
                this.setFocus(item, eventPayload);
            }
        };
        TreeModel.prototype.getNavigator = function (element, subTreeOnly) {
            if (element === void 0) { element = null; }
            if (subTreeOnly === void 0) { subTreeOnly = true; }
            return new TreeNavigator(this.getItem(element), subTreeOnly);
        };
        TreeModel.prototype.getItem = function (element) {
            if (element === void 0) { element = null; }
            if (element === null) {
                return this.input;
            }
            else if (element instanceof Item) {
                return element;
            }
            else if (typeof element === 'string') {
                return this.registry.getItem(element);
            }
            else {
                return this.registry.getItem(this.context.dataSource.getId(this.context.tree, element));
            }
        };
        TreeModel.prototype.addTraits = function (trait, elements) {
            var items = this.traitsToItems[trait] || {};
            var item;
            for (var i = 0, len = elements.length; i < len; i++) {
                item = this.getItem(elements[i]);
                if (item) {
                    item.addTrait(trait);
                    items[item.id] = item;
                }
            }
            this.traitsToItems[trait] = items;
        };
        TreeModel.prototype.removeTraits = function (trait, elements) {
            var items = this.traitsToItems[trait] || {};
            var item;
            var id;
            if (elements.length === 0) {
                for (id in items) {
                    if (items.hasOwnProperty(id)) {
                        item = items[id];
                        item.removeTrait(trait);
                    }
                }
                delete this.traitsToItems[trait];
            }
            else {
                for (var i = 0, len = elements.length; i < len; i++) {
                    item = this.getItem(elements[i]);
                    if (item) {
                        item.removeTrait(trait);
                        delete items[item.id];
                    }
                }
            }
        };
        TreeModel.prototype.hasTrait = function (trait, element) {
            var item = this.getItem(element);
            return item && item.hasTrait(trait);
        };
        TreeModel.prototype.toggleTrait = function (trait, element) {
            var item = this.getItem(element);
            if (!item) {
                return;
            }
            if (item.hasTrait(trait)) {
                this.removeTraits(trait, [element]);
            }
            else {
                this.addTraits(trait, [element]);
            }
        };
        TreeModel.prototype.setTraits = function (trait, elements) {
            if (elements.length === 0) {
                this.removeTraits(trait, elements);
            }
            else {
                var items = {};
                var item;
                for (var i = 0, len = elements.length; i < len; i++) {
                    item = this.getItem(elements[i]);
                    if (item) {
                        items[item.id] = item;
                    }
                }
                var traitItems = this.traitsToItems[trait] || {};
                var itemsToRemoveTrait = [];
                var id;
                for (id in traitItems) {
                    if (traitItems.hasOwnProperty(id)) {
                        if (items.hasOwnProperty(id)) {
                            delete items[id];
                        }
                        else {
                            itemsToRemoveTrait.push(traitItems[id]);
                        }
                    }
                }
                for (var i = 0, len = itemsToRemoveTrait.length; i < len; i++) {
                    item = itemsToRemoveTrait[i];
                    item.removeTrait(trait);
                    delete traitItems[item.id];
                }
                for (id in items) {
                    if (items.hasOwnProperty(id)) {
                        item = items[id];
                        item.addTrait(trait);
                        traitItems[id] = item;
                    }
                }
                this.traitsToItems[trait] = traitItems;
            }
        };
        TreeModel.prototype.getElementsWithTrait = function (trait, includeHidden) {
            var elements = [];
            var items = this.traitsToItems[trait] || {};
            var id;
            for (id in items) {
                if (items.hasOwnProperty(id) && (items[id].isVisible() || includeHidden)) {
                    elements.push(items[id].getElement());
                }
            }
            return elements;
        };
        TreeModel.prototype.dispose = function () {
            if (this.registry) {
                this.registry.dispose();
                this.registry = null;
            }
            _super.prototype.dispose.call(this);
        };
        return TreeModel;
    }(Events.EventEmitter));
    exports.TreeModel = TreeModel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[207], __M([0,1,23,109]), function (require, exports, eventEmitter_1, iterator_1) {
    "use strict";
    var HeightMap = (function (_super) {
        __extends(HeightMap, _super);
        function HeightMap() {
            _super.call(this);
            this.heightMap = [];
            this.indexes = {};
        }
        HeightMap.prototype.getTotalHeight = function () {
            var last = this.heightMap[this.heightMap.length - 1];
            return !last ? 0 : last.top + last.height;
        };
        HeightMap.prototype.onInsertItems = function (iterator, afterItemId) {
            if (afterItemId === void 0) { afterItemId = null; }
            var item;
            var viewItem;
            var i, j;
            var totalSize;
            var sizeDiff = 0;
            if (afterItemId === null) {
                i = 0;
                totalSize = 0;
            }
            else {
                i = this.indexes[afterItemId] + 1;
                viewItem = this.heightMap[i - 1];
                if (!viewItem) {
                    throw new Error('Tree error, onInsertItems: viewItem doesn\'t exist.');
                }
                totalSize = viewItem.top + viewItem.height;
            }
            var boundSplice = this.heightMap.splice.bind(this.heightMap, i, 0);
            var itemsToInsert = [];
            while (item = iterator.next()) {
                viewItem = this.createViewItem(item);
                viewItem.top = totalSize + sizeDiff;
                this.emit('viewItem:create', { item: viewItem.model });
                this.indexes[item.id] = i++;
                itemsToInsert.push(viewItem);
                sizeDiff += viewItem.height;
            }
            boundSplice.apply(this.heightMap, itemsToInsert);
            for (j = i; j < this.heightMap.length; j++) {
                viewItem = this.heightMap[j];
                viewItem.top += sizeDiff;
                this.indexes[viewItem.model.id] = j;
            }
            for (j = itemsToInsert.length - 1; j >= 0; j--) {
                this.onInsertItem(itemsToInsert[j]);
            }
            for (j = this.heightMap.length - 1; j >= i; j--) {
                this.onRefreshItem(this.heightMap[j]);
            }
            return sizeDiff;
        };
        HeightMap.prototype.onInsertItem = function (item) {
            // noop
        };
        // Contiguous items
        HeightMap.prototype.onRemoveItems = function (iterator) {
            var itemId;
            var viewItem;
            var startIndex = null;
            var i;
            var sizeDiff = 0;
            while (itemId = iterator.next()) {
                i = this.indexes[itemId];
                viewItem = this.heightMap[i];
                if (!viewItem) {
                    throw new Error('Tree error, onRemoveItems: viewItem doesn\'t exist.');
                }
                sizeDiff -= viewItem.height;
                delete this.indexes[itemId];
                this.onRemoveItem(viewItem);
                if (startIndex === null) {
                    startIndex = i;
                }
            }
            if (sizeDiff === 0) {
                return;
            }
            this.heightMap.splice(startIndex, i - startIndex + 1);
            for (i = startIndex; i < this.heightMap.length; i++) {
                viewItem = this.heightMap[i];
                viewItem.top += sizeDiff;
                this.indexes[viewItem.model.id] = i;
                this.onRefreshItem(viewItem);
            }
        };
        HeightMap.prototype.onRemoveItem = function (item) {
            // noop
        };
        HeightMap.prototype.onRefreshItemSet = function (items) {
            var _this = this;
            var sortedItems = items.sort(function (a, b) { return _this.indexes[a.id] - _this.indexes[b.id]; });
            this.onRefreshItems(new iterator_1.ArrayIterator(sortedItems));
        };
        // Ordered, but not necessarily contiguous items
        HeightMap.prototype.onRefreshItems = function (iterator) {
            var item;
            var viewItem;
            var newHeight;
            var i, j = null;
            var cummDiff = 0;
            while (item = iterator.next()) {
                i = this.indexes[item.id];
                for (; cummDiff !== 0 && j !== null && j < i; j++) {
                    viewItem = this.heightMap[j];
                    viewItem.top += cummDiff;
                    this.onRefreshItem(viewItem);
                }
                viewItem = this.heightMap[i];
                newHeight = item.getHeight();
                viewItem.top += cummDiff;
                cummDiff += newHeight - viewItem.height;
                viewItem.height = newHeight;
                this.onRefreshItem(viewItem, true);
                j = i + 1;
            }
            if (cummDiff !== 0 && j !== null) {
                for (; j < this.heightMap.length; j++) {
                    viewItem = this.heightMap[j];
                    viewItem.top += cummDiff;
                    this.onRefreshItem(viewItem);
                }
            }
        };
        HeightMap.prototype.onRefreshItem = function (item, needsRender) {
            if (needsRender === void 0) { needsRender = false; }
            // noop
        };
        HeightMap.prototype.itemsCount = function () {
            return this.heightMap.length;
        };
        HeightMap.prototype.itemAt = function (position) {
            return this.heightMap[this.indexAt(position)].model.id;
        };
        HeightMap.prototype.withItemsInRange = function (start, end, fn) {
            start = this.indexAt(start);
            end = this.indexAt(end);
            for (var i = start; i <= end; i++) {
                fn(this.heightMap[i].model.id);
            }
        };
        HeightMap.prototype.indexAt = function (position) {
            var left = 0;
            var right = this.heightMap.length;
            var center;
            var item;
            // Binary search
            while (left < right) {
                center = Math.floor((left + right) / 2);
                item = this.heightMap[center];
                if (position < item.top) {
                    right = center;
                }
                else if (position >= item.top + item.height) {
                    if (left === center) {
                        break;
                    }
                    left = center;
                }
                else {
                    return center;
                }
            }
            return this.heightMap.length;
        };
        HeightMap.prototype.indexAfter = function (position) {
            return Math.min(this.indexAt(position) + 1, this.heightMap.length);
        };
        HeightMap.prototype.itemAtIndex = function (index) {
            return this.heightMap[index];
        };
        HeightMap.prototype.itemAfter = function (item) {
            return this.heightMap[this.indexes[item.model.id] + 1] || null;
        };
        HeightMap.prototype.createViewItem = function (item) {
            throw new Error('not implemented');
        };
        HeightMap.prototype.dispose = function () {
            this.heightMap = null;
            this.indexes = null;
        };
        return HeightMap;
    }(eventEmitter_1.EventEmitter));
    exports.HeightMap = HeightMap;
});

define(__m[151], __M([0,1,14,2,103,64]), function (require, exports, async_1, winjs_base_1, viewLineRenderer_1, viewLineToken_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Colorizer = (function () {
        function Colorizer() {
        }
        Colorizer.colorizeElement = function (modeService, domNode, options) {
            options = options || {};
            var theme = options.theme || 'vs';
            var mimeType = options.mimeType || domNode.getAttribute('lang') || domNode.getAttribute('data-lang');
            if (!mimeType) {
                console.error('Mode not detected');
                return;
            }
            var text = domNode.firstChild.nodeValue;
            domNode.className += 'monaco-editor ' + theme;
            var render = function (str) {
                domNode.innerHTML = str;
            };
            return this.colorize(modeService, text, mimeType, options).then(render, function (err) { return console.error(err); }, render);
        };
        Colorizer.colorize = function (modeService, text, mimeType, options) {
            options = options || {};
            if (typeof options.tabSize === 'undefined') {
                options.tabSize = 4;
            }
            var lines = text.split('\n'), c, e, p, isCancelled = false, mode;
            var result = new winjs_base_1.TPromise(function (_c, _e, _p) {
                c = _c;
                e = _e;
                p = _p;
            }, function () {
                isCancelled = true;
            });
            var colorize = new async_1.RunOnceScheduler(function () {
                if (isCancelled) {
                    return;
                }
                var r = actualColorize(lines, mode, options.tabSize);
                if (r.retokenize.length > 0) {
                    // There are retokenization requests
                    r.retokenize.forEach(function (p) { return p.then(scheduleColorize); });
                    p(r.result);
                }
                else {
                    // There are no (more) retokenization requests
                    c(r.result);
                }
            }, 0);
            var scheduleColorize = function () { return colorize.schedule(); };
            modeService.getOrCreateMode(mimeType).then(function (_mode) {
                if (!_mode) {
                    e('Mode not found: "' + mimeType + '".');
                    return;
                }
                if (!_mode.tokenizationSupport) {
                    e('Mode found ("' + _mode.getId() + '"), but does not support tokenization.');
                    return;
                }
                mode = _mode;
                scheduleColorize();
            });
            return result;
        };
        Colorizer.colorizeLine = function (line, tokens, tabSize) {
            if (tabSize === void 0) { tabSize = 4; }
            var renderResult = viewLineRenderer_1.renderLine(new viewLineRenderer_1.RenderLineInput(line, tabSize, 0, -1, false, tokens));
            return renderResult.output;
        };
        Colorizer.colorizeModelLine = function (model, lineNumber, tabSize) {
            if (tabSize === void 0) { tabSize = 4; }
            var content = model.getLineContent(lineNumber);
            var tokens = model.getLineTokens(lineNumber, false);
            var inflatedTokens = tokens.inflate();
            return this.colorizeLine(content, inflatedTokens, tabSize);
        };
        return Colorizer;
    }());
    exports.Colorizer = Colorizer;
    function actualColorize(lines, mode, tabSize) {
        var tokenization = mode.tokenizationSupport, html = [], state = tokenization.getInitialState(), i, length, line, tokenizeResult, renderResult, retokenize = [];
        for (i = 0, length = lines.length; i < length; i++) {
            line = lines[i];
            tokenizeResult = tokenization.tokenize(line, state);
            if (tokenizeResult.retokenize) {
                retokenize.push(tokenizeResult.retokenize);
            }
            renderResult = viewLineRenderer_1.renderLine(new viewLineRenderer_1.RenderLineInput(line, tabSize, 0, -1, false, tokenizeResult.tokens.map(function (t) { return new viewLineToken_1.ViewLineToken(t.startIndex, t.type); })));
            html = html.concat(renderResult.output);
            html.push('<br/>');
            state = tokenizeResult.endState;
        }
        return {
            result: html.join(''),
            retokenize: retokenize
        };
    }
});

define(__m[209], __M([0,1,23]), function (require, exports, eventEmitter_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewEventDispatcher = (function () {
        function ViewEventDispatcher(eventHandlerGateKeeper) {
            this._eventHandlerGateKeeper = eventHandlerGateKeeper;
            this._eventHandlers = [];
            this._eventQueue = null;
            this._isConsumingQueue = false;
        }
        ViewEventDispatcher.prototype.addEventHandler = function (eventHandler) {
            for (var i = 0, len = this._eventHandlers.length; i < len; i++) {
                if (this._eventHandlers[i] === eventHandler) {
                    console.warn('Detected duplicate listener in ViewEventDispatcher', eventHandler);
                }
            }
            this._eventHandlers.push(eventHandler);
        };
        ViewEventDispatcher.prototype.removeEventHandler = function (eventHandler) {
            for (var i = 0; i < this._eventHandlers.length; i++) {
                if (this._eventHandlers[i] === eventHandler) {
                    this._eventHandlers.splice(i, 1);
                    break;
                }
            }
        };
        ViewEventDispatcher.prototype.emit = function (eventType, data) {
            var event = new eventEmitter_1.EmitterEvent(eventType, data);
            if (this._eventQueue) {
                this._eventQueue.push(event);
            }
            else {
                this._eventQueue = [event];
            }
            if (!this._isConsumingQueue) {
                this.consumeQueue();
            }
        };
        ViewEventDispatcher.prototype.emitMany = function (events) {
            if (this._eventQueue) {
                this._eventQueue = this._eventQueue.concat(events);
            }
            else {
                this._eventQueue = events;
            }
            if (!this._isConsumingQueue) {
                this.consumeQueue();
            }
        };
        ViewEventDispatcher.prototype.consumeQueue = function () {
            var _this = this;
            this._eventHandlerGateKeeper(function () {
                try {
                    _this._isConsumingQueue = true;
                    _this._doConsumeQueue();
                }
                finally {
                    _this._isConsumingQueue = false;
                }
            });
        };
        ViewEventDispatcher.prototype._doConsumeQueue = function () {
            while (this._eventQueue) {
                // Empty event queue, as events might come in while sending these off
                var events = this._eventQueue;
                this._eventQueue = null;
                // Use a clone of the event handlers list, as they might remove themselves
                var eventHandlers = this._eventHandlers.slice(0);
                for (var i = 0, len = eventHandlers.length; i < len; i++) {
                    eventHandlers[i].handleEvents(events);
                }
            }
        };
        return ViewEventDispatcher;
    }());
    exports.ViewEventDispatcher = ViewEventDispatcher;
});






define(__m[20], __M([0,1,50,10,2,25]), function (require, exports, actions_1, strings, winjs_base_1, editorActionEnablement_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var defaultBehaviour = editorActionEnablement_1.Behaviour.TextFocus | editorActionEnablement_1.Behaviour.Writeable | editorActionEnablement_1.Behaviour.UpdateOnModelChange;
    var EditorAction = (function (_super) {
        __extends(EditorAction, _super);
        function EditorAction(descriptor, editor, condition) {
            if (condition === void 0) { condition = defaultBehaviour; }
            _super.call(this, descriptor.id);
            this.editor = editor;
            this._descriptor = descriptor;
            this.label = descriptor.label || '';
            this._enablementState = editorActionEnablement_1.createActionEnablement(editor, condition, this);
            this._shouldShowInContextMenu = !!(condition & editorActionEnablement_1.Behaviour.ShowInContextMenu);
            this._supportsReadonly = !(condition & editorActionEnablement_1.Behaviour.Writeable);
        }
        EditorAction.prototype.getId = function () {
            return this.id;
        };
        EditorAction.prototype.dispose = function () {
            this._enablementState.dispose();
            _super.prototype.dispose.call(this);
        };
        /**
         * A helper to be able to group and sort actions when they are presented visually.
         */
        EditorAction.prototype.getGroupId = function () {
            return this.id;
        };
        EditorAction.prototype.shouldShowInContextMenu = function () {
            return this._shouldShowInContextMenu;
        };
        EditorAction.prototype.getDescriptor = function () {
            return this._descriptor;
        };
        Object.defineProperty(EditorAction.prototype, "enabled", {
            // ---- enablement state mangament --------------------------------------------------------
            get: function () {
                return this._enablementState.value();
            },
            set: function (value) {
                // call reset?
                var e = new Error();
                console.log('setting EditorAction.enabled is UNCOOL. Use resetEnablementState and getEnablementState');
                console.log(e.stack);
            },
            enumerable: true,
            configurable: true
        });
        EditorAction.prototype.resetEnablementState = function () {
            this._enablementState.reset();
        };
        /**
         * Returns {{true}} in case this action works
         * with the current mode. To be overwritten
         * in subclasses.
         */
        EditorAction.prototype.isSupported = function () {
            if (!this._supportsReadonly) {
                if (this.editor.getConfiguration().readOnly) {
                    return false; // action requires a writeable model
                }
                var model = this.editor.getModel();
                if (model && model.hasEditableRange()) {
                    return false; // editable ranges are an indicator for mostly readonly models
                }
            }
            return true;
        };
        /**
         * Returns the enablement state of this action. This
         * method is being called in the process of {{updateEnablementState}}
         * and overwriters should call super (this method).
         */
        EditorAction.prototype.getEnablementState = function () {
            return true;
        };
        EditorAction.prototype.getAlias = function () {
            return this._descriptor.alias;
        };
        return EditorAction;
    }(actions_1.Action));
    exports.EditorAction = EditorAction;
    var HandlerEditorAction = (function (_super) {
        __extends(HandlerEditorAction, _super);
        function HandlerEditorAction(descriptor, editor, handlerId) {
            _super.call(this, descriptor, editor);
            this._handlerId = handlerId;
        }
        HandlerEditorAction.prototype.run = function () {
            this.editor.trigger(this.getId(), this._handlerId, null);
            return winjs_base_1.TPromise.as(true);
        };
        return HandlerEditorAction;
    }(EditorAction));
    exports.HandlerEditorAction = HandlerEditorAction;
    var DynamicEditorAction = (function (_super) {
        __extends(DynamicEditorAction, _super);
        function DynamicEditorAction(descriptor, editor) {
            var enablement = descriptor.enablement || {};
            _super.call(this, {
                id: descriptor.id,
                label: descriptor.label
            }, editor, DynamicEditorAction._transformBehaviour(enablement, descriptor.contextMenuGroupId));
            this._contextMenuGroupId = descriptor.contextMenuGroupId;
            this._run = descriptor.run;
            this._tokensAtPosition = enablement.tokensAtPosition;
            this._wordAtPosition = enablement.wordAtPosition;
        }
        DynamicEditorAction._transformBehaviour = function (behaviour, contextMenuGroupId) {
            var r = 0;
            if (contextMenuGroupId) {
                r |= editorActionEnablement_1.Behaviour.ShowInContextMenu;
            }
            else if (behaviour.textFocus) {
                // Allowed to set text focus only if not appearing in the context menu
                r |= editorActionEnablement_1.Behaviour.TextFocus;
            }
            if (behaviour.widgetFocus) {
                r |= editorActionEnablement_1.Behaviour.WidgetFocus;
            }
            if (behaviour.writeableEditor) {
                r |= editorActionEnablement_1.Behaviour.Writeable;
            }
            if (typeof behaviour.tokensAtPosition !== 'undefined') {
                r |= editorActionEnablement_1.Behaviour.UpdateOnCursorPositionChange;
            }
            if (typeof behaviour.wordAtPosition !== 'undefined') {
                r |= editorActionEnablement_1.Behaviour.UpdateOnCursorPositionChange;
            }
            return r;
        };
        DynamicEditorAction.prototype.getGroupId = function () {
            return this._contextMenuGroupId;
        };
        DynamicEditorAction.prototype.run = function () {
            return winjs_base_1.TPromise.as(this._run(this.editor));
        };
        DynamicEditorAction.prototype.getEnablementState = function () {
            return this._getEnablementOnTokens() && this._getEnablementOnWord();
        };
        DynamicEditorAction.prototype._getEnablementOnTokens = function () {
            if (!this._tokensAtPosition) {
                return true;
            }
            var model = this.editor.getModel(), position = this.editor.getSelection().getStartPosition(), lineContext = model.getLineContext(position.lineNumber), offset = position.column - 1;
            return isToken(lineContext, offset, this._tokensAtPosition);
        };
        DynamicEditorAction.prototype._getEnablementOnWord = function () {
            if (!this._wordAtPosition) {
                return true;
            }
            var model = this.editor.getModel(), position = this.editor.getSelection().getStartPosition(), wordAtPosition = model.getWordAtPosition(position);
            return (!!wordAtPosition);
        };
        return DynamicEditorAction;
    }(EditorAction));
    exports.DynamicEditorAction = DynamicEditorAction;
    function isToken(context, offset, types) {
        if (context.getLineContent().length <= offset) {
            return false;
        }
        var tokenIdx = context.findIndexOfOffset(offset);
        var type = context.getTokenType(tokenIdx);
        for (var i = 0, len = types.length; i < len; i++) {
            if (types[i] === '') {
                if (type === '') {
                    return true;
                }
            }
            else {
                if (strings.startsWith(type, types[i])) {
                    return true;
                }
            }
        }
        return false;
    }
});

define(__m[211], __M([0,1,8]), function (require, exports, errors_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditStack = (function () {
        function EditStack(model) {
            this.model = model;
            this.currentOpenStackElement = null;
            this.past = [];
            this.future = [];
        }
        EditStack.prototype.pushStackElement = function () {
            if (this.currentOpenStackElement !== null) {
                this.past.push(this.currentOpenStackElement);
                this.currentOpenStackElement = null;
            }
        };
        EditStack.prototype.clear = function () {
            this.currentOpenStackElement = null;
            this.past = [];
            this.future = [];
        };
        EditStack.prototype.pushEditOperation = function (beforeCursorState, editOperations, cursorStateComputer) {
            // No support for parallel universes :(
            this.future = [];
            if (!this.currentOpenStackElement) {
                this.currentOpenStackElement = {
                    beforeVersionId: this.model.getAlternativeVersionId(),
                    beforeCursorState: beforeCursorState,
                    editOperations: [],
                    afterCursorState: null,
                    afterVersionId: -1
                };
            }
            var inverseEditOperation = {
                operations: this.model.applyEdits(editOperations)
            };
            this.currentOpenStackElement.editOperations.push(inverseEditOperation);
            try {
                this.currentOpenStackElement.afterCursorState = cursorStateComputer ? cursorStateComputer(inverseEditOperation.operations) : null;
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
                this.currentOpenStackElement.afterCursorState = null;
            }
            this.currentOpenStackElement.afterVersionId = this.model.getVersionId();
            return this.currentOpenStackElement.afterCursorState;
        };
        EditStack.prototype.undo = function () {
            this.pushStackElement();
            if (this.past.length > 0) {
                var pastStackElement = this.past.pop();
                try {
                    // Apply all operations in reverse order
                    for (var i = pastStackElement.editOperations.length - 1; i >= 0; i--) {
                        pastStackElement.editOperations[i] = {
                            operations: this.model.applyEdits(pastStackElement.editOperations[i].operations)
                        };
                    }
                }
                catch (e) {
                    this.clear();
                    return null;
                }
                this.future.push(pastStackElement);
                return {
                    selections: pastStackElement.beforeCursorState,
                    recordedVersionId: pastStackElement.beforeVersionId
                };
            }
            return null;
        };
        EditStack.prototype.redo = function () {
            if (this.future.length > 0) {
                if (this.currentOpenStackElement) {
                    throw new Error('How is this possible?');
                }
                var futureStackElement = this.future.pop();
                try {
                    // Apply all operations
                    for (var i = 0; i < futureStackElement.editOperations.length; i++) {
                        futureStackElement.editOperations[i] = {
                            operations: this.model.applyEdits(futureStackElement.editOperations[i].operations)
                        };
                    }
                }
                catch (e) {
                    this.clear();
                    return null;
                }
                this.past.push(futureStackElement);
                return {
                    selections: futureStackElement.afterCursorState,
                    recordedVersionId: futureStackElement.afterVersionId
                };
            }
            return null;
        };
        return EditStack;
    }());
    exports.EditStack = EditStack;
});

define(__m[154], __M([0,1,8,10,64]), function (require, exports, errors_1, strings, viewLineToken_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var START_INDEX_MASK = 0xffffffff;
    var TYPE_MASK = 0xffff;
    var START_INDEX_OFFSET = 1;
    var TYPE_OFFSET = Math.pow(2, 32);
    var DEFAULT_VIEW_TOKEN = new viewLineToken_1.ViewLineToken(0, '');
    var INFLATED_TOKENS_EMPTY_TEXT = [];
    var DEFLATED_TOKENS_EMPTY_TEXT = [];
    var INFLATED_TOKENS_NON_EMPTY_TEXT = [DEFAULT_VIEW_TOKEN];
    var DEFLATED_TOKENS_NON_EMPTY_TEXT = [0];
    var TokensInflatorMap = (function () {
        function TokensInflatorMap() {
            this._inflate = [''];
            this._deflate = { '': 0 };
        }
        return TokensInflatorMap;
    }());
    exports.TokensInflatorMap = TokensInflatorMap;
    var TokensBinaryEncoding = (function () {
        function TokensBinaryEncoding() {
        }
        TokensBinaryEncoding.deflateArr = function (map, tokens) {
            if (tokens.length === 0) {
                return DEFLATED_TOKENS_EMPTY_TEXT;
            }
            if (tokens.length === 1 && tokens[0].startIndex === 0 && !tokens[0].type) {
                return DEFLATED_TOKENS_NON_EMPTY_TEXT;
            }
            var i, len, deflatedToken, deflated, token, inflateMap = map._inflate, deflateMap = map._deflate, prevStartIndex = -1, result = new Array(tokens.length);
            for (i = 0, len = tokens.length; i < len; i++) {
                token = tokens[i];
                if (token.startIndex <= prevStartIndex) {
                    token.startIndex = prevStartIndex + 1;
                    errors_1.onUnexpectedError({
                        message: 'Invalid tokens detected',
                        tokens: tokens
                    });
                }
                if (deflateMap.hasOwnProperty(token.type)) {
                    deflatedToken = deflateMap[token.type];
                }
                else {
                    deflatedToken = inflateMap.length;
                    deflateMap[token.type] = deflatedToken;
                    inflateMap.push(token.type);
                }
                // http://stackoverflow.com/a/2803010
                // All numbers in JavaScript are actually IEEE-754 compliant floating-point doubles.
                // These have a 53-bit mantissa which should mean that any integer value with a magnitude
                // of approximately 9 quadrillion or less -- more specifically, 9,007,199,254,740,991 --
                // will be represented accurately.
                // http://stackoverflow.com/a/6729252
                // Bitwise operations cast numbers to 32bit representation in JS
                // 32 bits for startIndex => up to 2^32 = 4,294,967,296
                // 16 bits for token => up to 2^16 = 65,536
                // [token][startIndex]
                deflated = deflatedToken * TYPE_OFFSET + token.startIndex * START_INDEX_OFFSET;
                result[i] = deflated;
                prevStartIndex = token.startIndex;
            }
            return result;
        };
        TokensBinaryEncoding.getStartIndex = function (binaryEncodedToken) {
            return (binaryEncodedToken / START_INDEX_OFFSET) & START_INDEX_MASK;
        };
        TokensBinaryEncoding.getType = function (map, binaryEncodedToken) {
            var deflatedType = (binaryEncodedToken / TYPE_OFFSET) & TYPE_MASK;
            if (deflatedType === 0) {
                return strings.empty;
            }
            return map._inflate[deflatedType];
        };
        TokensBinaryEncoding.inflateArr = function (map, binaryEncodedTokens) {
            if (binaryEncodedTokens.length === 0) {
                return INFLATED_TOKENS_EMPTY_TEXT;
            }
            if (binaryEncodedTokens.length === 1 && binaryEncodedTokens[0] === 0) {
                return INFLATED_TOKENS_NON_EMPTY_TEXT;
            }
            var result = [];
            var inflateMap = map._inflate;
            for (var i = 0, len = binaryEncodedTokens.length; i < len; i++) {
                var deflated = binaryEncodedTokens[i];
                var startIndex = (deflated / START_INDEX_OFFSET) & START_INDEX_MASK;
                var deflatedType = (deflated / TYPE_OFFSET) & TYPE_MASK;
                result.push(new viewLineToken_1.ViewLineToken(startIndex, inflateMap[deflatedType]));
            }
            return result;
        };
        TokensBinaryEncoding.findIndexOfOffset = function (binaryEncodedTokens, offset) {
            return this.findIndexInSegmentsArray(binaryEncodedTokens, offset);
        };
        TokensBinaryEncoding.sliceAndInflate = function (map, binaryEncodedTokens, startOffset, endOffset, deltaStartIndex) {
            if (binaryEncodedTokens.length === 0) {
                return INFLATED_TOKENS_EMPTY_TEXT;
            }
            if (binaryEncodedTokens.length === 1 && binaryEncodedTokens[0] === 0) {
                return INFLATED_TOKENS_NON_EMPTY_TEXT;
            }
            var startIndex = this.findIndexInSegmentsArray(binaryEncodedTokens, startOffset);
            var result = [];
            var inflateMap = map._inflate;
            var originalToken = binaryEncodedTokens[startIndex];
            var deflatedType = (originalToken / TYPE_OFFSET) & TYPE_MASK;
            var newStartIndex = 0;
            result.push(new viewLineToken_1.ViewLineToken(newStartIndex, inflateMap[deflatedType]));
            for (var i = startIndex + 1, len = binaryEncodedTokens.length; i < len; i++) {
                originalToken = binaryEncodedTokens[i];
                var originalStartIndex = (originalToken / START_INDEX_OFFSET) & START_INDEX_MASK;
                if (originalStartIndex >= endOffset) {
                    break;
                }
                deflatedType = (originalToken / TYPE_OFFSET) & TYPE_MASK;
                newStartIndex = originalStartIndex - startOffset + deltaStartIndex;
                result.push(new viewLineToken_1.ViewLineToken(newStartIndex, inflateMap[deflatedType]));
            }
            return result;
        };
        TokensBinaryEncoding.findIndexInSegmentsArray = function (arr, desiredIndex) {
            var low = 0, high = arr.length - 1, mid, value;
            while (low < high) {
                mid = low + Math.ceil((high - low) / 2);
                value = arr[mid] & 0xffffffff;
                if (value > desiredIndex) {
                    high = mid - 1;
                }
                else {
                    low = mid;
                }
            }
            return low;
        };
        TokensBinaryEncoding.START_INDEX_MASK = START_INDEX_MASK;
        TokensBinaryEncoding.TYPE_MASK = TYPE_MASK;
        TokensBinaryEncoding.START_INDEX_OFFSET = START_INDEX_OFFSET;
        TokensBinaryEncoding.TYPE_OFFSET = TYPE_OFFSET;
        return TokensBinaryEncoding;
    }());
    exports.TokensBinaryEncoding = TokensBinaryEncoding;
});

define(__m[165], __M([0,1,10,154,88,64]), function (require, exports, strings, tokensBinaryEncoding_1, modeTransition_1, viewLineToken_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var START_INDEX_MASK = tokensBinaryEncoding_1.TokensBinaryEncoding.START_INDEX_MASK;
    var TYPE_MASK = tokensBinaryEncoding_1.TokensBinaryEncoding.TYPE_MASK;
    var START_INDEX_OFFSET = tokensBinaryEncoding_1.TokensBinaryEncoding.START_INDEX_OFFSET;
    var TYPE_OFFSET = tokensBinaryEncoding_1.TokensBinaryEncoding.TYPE_OFFSET;
    var NO_OP_TOKENS_ADJUSTER = {
        adjust: function () { },
        finish: function () { }
    };
    var NO_OP_MARKERS_ADJUSTER = {
        adjustDelta: function () { },
        adjustSet: function () { },
        finish: function () { }
    };
    var MarkerMoveSemantics;
    (function (MarkerMoveSemantics) {
        MarkerMoveSemantics[MarkerMoveSemantics["MarkerDefined"] = 0] = "MarkerDefined";
        MarkerMoveSemantics[MarkerMoveSemantics["ForceMove"] = 1] = "ForceMove";
        MarkerMoveSemantics[MarkerMoveSemantics["ForceStay"] = 2] = "ForceStay";
    })(MarkerMoveSemantics || (MarkerMoveSemantics = {}));
    var ModelLine = (function () {
        function ModelLine(lineNumber, text) {
            this._lineNumber = lineNumber | 0;
            this._text = text;
            this._isInvalid = false;
            this._state = null;
            this._modeTransitions = null;
            this._lineTokens = null;
            this._markers = null;
        }
        Object.defineProperty(ModelLine.prototype, "lineNumber", {
            get: function () { return this._lineNumber; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModelLine.prototype, "text", {
            get: function () { return this._text; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModelLine.prototype, "isInvalid", {
            get: function () { return this._isInvalid; },
            set: function (value) { this._isInvalid = value; },
            enumerable: true,
            configurable: true
        });
        // --- BEGIN STATE
        ModelLine.prototype.setState = function (state) {
            this._state = state;
        };
        ModelLine.prototype.getState = function () {
            return this._state || null;
        };
        // --- END STATE
        // --- BEGIN MODE TRANSITIONS
        ModelLine.prototype.getModeTransitions = function (topLevelMode) {
            if (this._modeTransitions) {
                return this._modeTransitions;
            }
            else {
                return [new modeTransition_1.ModeTransition(0, topLevelMode)];
            }
        };
        // --- END MODE TRANSITIONS
        // --- BEGIN TOKENS
        ModelLine.prototype.setTokens = function (map, tokens, topLevelMode, modeTransitions) {
            this._lineTokens = toLineTokensFromInflated(map, tokens, this._text.length);
            this._modeTransitions = toModeTransitions(topLevelMode, modeTransitions);
        };
        ModelLine.prototype._setLineTokensFromDeflated = function (map, tokens) {
            this._lineTokens = toLineTokensFromDeflated(map, tokens, this._text.length);
        };
        ModelLine.prototype.getTokens = function () {
            if (this._lineTokens) {
                return this._lineTokens;
            }
            if (this._text.length === 0) {
                return EmptyLineTokens.INSTANCE;
            }
            return DefaultLineTokens.INSTANCE;
        };
        // --- END TOKENS
        ModelLine.prototype._createTokensAdjuster = function () {
            if (!this._lineTokens) {
                // This line does not have real tokens, so there is nothing to adjust
                return NO_OP_TOKENS_ADJUSTER;
            }
            var lineTokens = this._lineTokens;
            var tokens = lineTokens.getBinaryEncodedTokens();
            var tokensLength = tokens.length;
            var tokensIndex = 0;
            var currentTokenStartIndex = 0;
            var adjust = function (toColumn, delta, minimumAllowedColumn) {
                // console.log('before call: tokensIndex: ' + tokensIndex + ': ' + String(this.getTokens()));
                // console.log('adjustTokens: ' + toColumn + ' with delta: ' + delta + ' and [' + minimumAllowedColumn + ']');
                // console.log('currentTokenStartIndex: ' + currentTokenStartIndex);
                var minimumAllowedIndex = minimumAllowedColumn - 1;
                while (currentTokenStartIndex < toColumn && tokensIndex < tokensLength) {
                    if (currentTokenStartIndex > 0 && delta !== 0) {
                        // adjust token's `startIndex` by `delta`
                        var deflatedType = (tokens[tokensIndex] / TYPE_OFFSET) & TYPE_MASK;
                        var newStartIndex = Math.max(minimumAllowedIndex, currentTokenStartIndex + delta);
                        var newToken = deflatedType * TYPE_OFFSET + newStartIndex * START_INDEX_OFFSET;
                        if (delta < 0) {
                            // pop all previous tokens that have become `collapsed`
                            while (tokensIndex > 0) {
                                var prevTokenStartIndex = (tokens[tokensIndex - 1] / START_INDEX_OFFSET) & START_INDEX_MASK;
                                if (prevTokenStartIndex >= newStartIndex) {
                                    // Token at `tokensIndex` - 1 is now `collapsed` => pop it
                                    tokens.splice(tokensIndex - 1, 1);
                                    tokensLength--;
                                    tokensIndex--;
                                }
                                else {
                                    break;
                                }
                            }
                        }
                        tokens[tokensIndex] = newToken;
                    }
                    tokensIndex++;
                    if (tokensIndex < tokensLength) {
                        currentTokenStartIndex = (tokens[tokensIndex] / START_INDEX_OFFSET) & START_INDEX_MASK;
                    }
                }
                // console.log('after call: tokensIndex: ' + tokensIndex + ': ' + String(this.getTokens()));
            };
            var finish = function (delta, lineTextLength) {
                adjust(Number.MAX_VALUE, delta, 1);
            };
            return {
                adjust: adjust,
                finish: finish
            };
        };
        ModelLine.prototype._setText = function (text) {
            this._text = text;
            if (this._lineTokens) {
                var map = this._lineTokens.getBinaryEncodedTokensMap(), tokens = this._lineTokens.getBinaryEncodedTokens(), lineTextLength = this._text.length;
                // Remove overflowing tokens
                while (tokens.length > 0) {
                    var lastTokenStartIndex = (tokens[tokens.length - 1] / START_INDEX_OFFSET) & START_INDEX_MASK;
                    if (lastTokenStartIndex < lineTextLength) {
                        // Valid token
                        break;
                    }
                    // This token now overflows the text => remove it
                    tokens.pop();
                }
                this._setLineTokensFromDeflated(map, tokens);
            }
        };
        // private _printMarkers(): string {
        // 	if (!this._markers) {
        // 		return '[]';
        // 	}
        // 	if (this._markers.length === 0) {
        // 		return '[]';
        // 	}
        // 	var markers = this._markers;
        // 	var printMarker = (m:ILineMarker) => {
        // 		if (m.stickToPreviousCharacter) {
        // 			return '|' + m.column;
        // 		}
        // 		return m.column + '|';
        // 	};
        // 	return '[' + markers.map(printMarker).join(', ') + ']';
        // }
        ModelLine.prototype._createMarkersAdjuster = function (changedMarkers) {
            var _this = this;
            if (!this._markers) {
                return NO_OP_MARKERS_ADJUSTER;
            }
            if (this._markers.length === 0) {
                return NO_OP_MARKERS_ADJUSTER;
            }
            this._markers.sort(ModelLine._compareMarkers);
            var markers = this._markers;
            var markersLength = markers.length;
            var markersIndex = 0;
            var marker = markers[markersIndex];
            // console.log('------------- INITIAL MARKERS: ' + this._printMarkers());
            var adjustMarkerBeforeColumn = function (toColumn, moveSemantics) {
                if (marker.column < toColumn) {
                    return true;
                }
                if (marker.column > toColumn) {
                    return false;
                }
                if (moveSemantics === MarkerMoveSemantics.ForceMove) {
                    return false;
                }
                if (moveSemantics === MarkerMoveSemantics.ForceStay) {
                    return true;
                }
                return marker.stickToPreviousCharacter;
            };
            var adjustDelta = function (toColumn, delta, minimumAllowedColumn, moveSemantics) {
                // console.log('------------------------------');
                // console.log('adjustDelta called: toColumn: ' + toColumn + ', delta: ' + delta + ', minimumAllowedColumn: ' + minimumAllowedColumn + ', moveSemantics: ' + MarkerMoveSemantics[moveSemantics]);
                // console.log('BEFORE::: markersIndex: ' + markersIndex + ' : ' + this._printMarkers());
                while (markersIndex < markersLength && adjustMarkerBeforeColumn(toColumn, moveSemantics)) {
                    if (delta !== 0) {
                        var newColumn = Math.max(minimumAllowedColumn, marker.column + delta);
                        if (marker.column !== newColumn) {
                            changedMarkers[marker.id] = true;
                            marker.oldLineNumber = marker.oldLineNumber || _this._lineNumber;
                            marker.oldColumn = marker.oldColumn || marker.column;
                            marker.column = newColumn;
                        }
                    }
                    markersIndex++;
                    if (markersIndex < markersLength) {
                        marker = markers[markersIndex];
                    }
                }
                // console.log('AFTER::: markersIndex: ' + markersIndex + ' : ' + this._printMarkers());
            };
            var adjustSet = function (toColumn, newColumn, moveSemantics) {
                // console.log('------------------------------');
                // console.log('adjustSet called: toColumn: ' + toColumn + ', newColumn: ' + newColumn + ', moveSemantics: ' + MarkerMoveSemantics[moveSemantics]);
                // console.log('BEFORE::: markersIndex: ' + markersIndex + ' : ' + this._printMarkers());
                while (markersIndex < markersLength && adjustMarkerBeforeColumn(toColumn, moveSemantics)) {
                    if (marker.column !== newColumn) {
                        changedMarkers[marker.id] = true;
                        marker.oldLineNumber = marker.oldLineNumber || _this._lineNumber;
                        marker.oldColumn = marker.oldColumn || marker.column;
                        marker.column = newColumn;
                    }
                    markersIndex++;
                    if (markersIndex < markersLength) {
                        marker = markers[markersIndex];
                    }
                }
                // console.log('AFTER::: markersIndex: ' + markersIndex + ' : ' + this._printMarkers());
            };
            var finish = function (delta, lineTextLength) {
                adjustDelta(Number.MAX_VALUE, delta, 1, MarkerMoveSemantics.MarkerDefined);
                // console.log('------------- FINAL MARKERS: ' + this._printMarkers());
            };
            return {
                adjustDelta: adjustDelta,
                adjustSet: adjustSet,
                finish: finish
            };
        };
        ModelLine.prototype.applyEdits = function (changedMarkers, edits) {
            var deltaColumn = 0;
            var resultText = this._text;
            var tokensAdjuster = this._createTokensAdjuster();
            var markersAdjuster = this._createMarkersAdjuster(changedMarkers);
            for (var i = 0, len = edits.length; i < len; i++) {
                var edit = edits[i];
                // console.log();
                // console.log('=============================');
                // console.log('EDIT #' + i + ' [ ' + edit.startColumn + ' -> ' + edit.endColumn + ' ] : <<<' + edit.text + '>>>, forceMoveMarkers: ' + edit.forceMoveMarkers);
                // console.log('deltaColumn: ' + deltaColumn);
                var startColumn = deltaColumn + edit.startColumn;
                var endColumn = deltaColumn + edit.endColumn;
                var deletingCnt = endColumn - startColumn;
                var insertingCnt = edit.text.length;
                // Adjust tokens & markers before this edit
                // console.log('Adjust tokens & markers before this edit');
                tokensAdjuster.adjust(edit.startColumn - 1, deltaColumn, 1);
                markersAdjuster.adjustDelta(edit.startColumn, deltaColumn, 1, edit.forceMoveMarkers ? MarkerMoveSemantics.ForceMove : (deletingCnt > 0 ? MarkerMoveSemantics.ForceStay : MarkerMoveSemantics.MarkerDefined));
                // Adjust tokens & markers for the common part of this edit
                var commonLength = Math.min(deletingCnt, insertingCnt);
                if (commonLength > 0) {
                    // console.log('Adjust tokens & markers for the common part of this edit');
                    tokensAdjuster.adjust(edit.startColumn - 1 + commonLength, deltaColumn, startColumn);
                    if (!edit.forceMoveMarkers) {
                        markersAdjuster.adjustDelta(edit.startColumn + commonLength, deltaColumn, startColumn, edit.forceMoveMarkers ? MarkerMoveSemantics.ForceMove : (deletingCnt > insertingCnt ? MarkerMoveSemantics.ForceStay : MarkerMoveSemantics.MarkerDefined));
                    }
                }
                // Perform the edit & update `deltaColumn`
                resultText = resultText.substring(0, startColumn - 1) + edit.text + resultText.substring(endColumn - 1);
                deltaColumn += insertingCnt - deletingCnt;
                // Adjust tokens & markers inside this edit
                // console.log('Adjust tokens & markers inside this edit');
                tokensAdjuster.adjust(edit.endColumn, deltaColumn, startColumn);
                markersAdjuster.adjustSet(edit.endColumn, startColumn + insertingCnt, edit.forceMoveMarkers ? MarkerMoveSemantics.ForceMove : MarkerMoveSemantics.MarkerDefined);
            }
            // Wrap up tokens & markers; adjust remaining if needed
            tokensAdjuster.finish(deltaColumn, resultText.length);
            markersAdjuster.finish(deltaColumn, resultText.length);
            // Save the resulting text
            this._setText(resultText);
            return deltaColumn;
        };
        ModelLine.prototype.split = function (changedMarkers, splitColumn, forceMoveMarkers) {
            // console.log('--> split @ ' + splitColumn + '::: ' + this._printMarkers());
            var myText = this._text.substring(0, splitColumn - 1);
            var otherText = this._text.substring(splitColumn - 1);
            var otherMarkers = null;
            if (this._markers) {
                this._markers.sort(ModelLine._compareMarkers);
                for (var i = 0, len = this._markers.length; i < len; i++) {
                    var marker = this._markers[i];
                    if (marker.column > splitColumn
                        || (marker.column === splitColumn
                            && (forceMoveMarkers
                                || !marker.stickToPreviousCharacter))) {
                        var myMarkers = this._markers.slice(0, i);
                        otherMarkers = this._markers.slice(i);
                        this._markers = myMarkers;
                        break;
                    }
                }
                if (otherMarkers) {
                    for (var i = 0, len = otherMarkers.length; i < len; i++) {
                        var marker = otherMarkers[i];
                        changedMarkers[marker.id] = true;
                        marker.oldLineNumber = marker.oldLineNumber || this._lineNumber;
                        marker.oldColumn = marker.oldColumn || marker.column;
                        marker.column -= splitColumn - 1;
                    }
                }
            }
            this._setText(myText);
            var otherLine = new ModelLine(this._lineNumber + 1, otherText);
            if (otherMarkers) {
                otherLine.addMarkers(otherMarkers);
            }
            return otherLine;
        };
        ModelLine.prototype.append = function (changedMarkers, other) {
            // console.log('--> append: THIS :: ' + this._printMarkers());
            // console.log('--> append: OTHER :: ' + this._printMarkers());
            var thisTextLength = this._text.length;
            this._setText(this._text + other._text);
            var otherLineTokens = other._lineTokens;
            if (otherLineTokens) {
                // Other has real tokens
                var otherTokens = otherLineTokens.getBinaryEncodedTokens();
                // Adjust other tokens
                if (thisTextLength > 0) {
                    for (var i = 0, len = otherTokens.length; i < len; i++) {
                        var token = otherTokens[i];
                        var deflatedStartIndex = (token / START_INDEX_OFFSET) & START_INDEX_MASK;
                        var deflatedType = (token / TYPE_OFFSET) & TYPE_MASK;
                        var newStartIndex = deflatedStartIndex + thisTextLength;
                        var newToken = deflatedType * TYPE_OFFSET + newStartIndex * START_INDEX_OFFSET;
                        otherTokens[i] = newToken;
                    }
                }
                // Append other tokens
                var myLineTokens = this._lineTokens;
                if (myLineTokens) {
                    // I have real tokens
                    this._setLineTokensFromDeflated(myLineTokens.getBinaryEncodedTokensMap(), myLineTokens.getBinaryEncodedTokens().concat(otherTokens));
                }
                else {
                    // I don't have real tokens
                    this._setLineTokensFromDeflated(otherLineTokens.getBinaryEncodedTokensMap(), otherTokens);
                }
            }
            if (other._markers) {
                // Other has markers
                var otherMarkers = other._markers;
                // Adjust other markers
                for (var i = 0, len = otherMarkers.length; i < len; i++) {
                    var marker = otherMarkers[i];
                    changedMarkers[marker.id] = true;
                    marker.oldLineNumber = marker.oldLineNumber || other.lineNumber;
                    marker.oldColumn = marker.oldColumn || marker.column;
                    marker.column += thisTextLength;
                }
                this.addMarkers(otherMarkers);
            }
        };
        ModelLine.prototype.addMarker = function (marker) {
            marker.line = this;
            if (!this._markers) {
                this._markers = [marker];
            }
            else {
                this._markers.push(marker);
            }
        };
        ModelLine.prototype.addMarkers = function (markers) {
            if (markers.length === 0) {
                return;
            }
            var i, len;
            for (i = 0, len = markers.length; i < len; i++) {
                markers[i].line = this;
            }
            if (!this._markers) {
                this._markers = markers.slice(0);
            }
            else {
                this._markers = this._markers.concat(markers);
            }
        };
        ModelLine._compareMarkers = function (a, b) {
            if (a.column === b.column) {
                return (a.stickToPreviousCharacter ? 0 : 1) - (b.stickToPreviousCharacter ? 0 : 1);
            }
            return a.column - b.column;
        };
        ModelLine.prototype.removeMarker = function (marker) {
            if (!this._markers) {
                return;
            }
            var index = this._indexOfMarkerId(marker.id);
            if (index >= 0) {
                marker.line = null;
                this._markers.splice(index, 1);
            }
            if (this._markers.length === 0) {
                this._markers = null;
            }
        };
        ModelLine.prototype.removeMarkers = function (deleteMarkers) {
            if (!this._markers) {
                return;
            }
            for (var i = 0, len = this._markers.length; i < len; i++) {
                var marker = this._markers[i];
                if (deleteMarkers[marker.id]) {
                    marker.line = null;
                    this._markers.splice(i, 1);
                    len--;
                    i--;
                }
            }
            if (this._markers.length === 0) {
                this._markers = null;
            }
        };
        ModelLine.prototype.getMarkers = function () {
            if (!this._markers) {
                return [];
            }
            return this._markers.slice(0);
        };
        ModelLine.prototype.updateLineNumber = function (changedMarkers, newLineNumber) {
            if (this._markers) {
                var markers = this._markers, i, len, marker;
                for (i = 0, len = markers.length; i < len; i++) {
                    marker = markers[i];
                    changedMarkers[marker.id] = true;
                    marker.oldLineNumber = marker.oldLineNumber || this._lineNumber;
                }
            }
            this._lineNumber = newLineNumber;
        };
        ModelLine.prototype.deleteLine = function (changedMarkers, setMarkersColumn, setMarkersOldLineNumber) {
            // console.log('--> deleteLine: ');
            if (this._markers) {
                var markers = this._markers, i, len, marker;
                // Mark all these markers as changed
                for (i = 0, len = markers.length; i < len; i++) {
                    marker = markers[i];
                    changedMarkers[marker.id] = true;
                    marker.oldColumn = marker.oldColumn || marker.column;
                    marker.oldLineNumber = marker.oldLineNumber || setMarkersOldLineNumber;
                    marker.column = setMarkersColumn;
                }
                return markers;
            }
            return [];
        };
        ModelLine.prototype._indexOfMarkerId = function (markerId) {
            var markers = this._markers;
            for (var i = 0, len = markers.length; i < len; i++) {
                if (markers[i].id === markerId) {
                    return i;
                }
            }
        };
        return ModelLine;
    }());
    exports.ModelLine = ModelLine;
    function toLineTokensFromInflated(map, tokens, textLength) {
        if (textLength === 0) {
            return null;
        }
        if (!tokens || tokens.length === 0) {
            return null;
        }
        if (tokens.length === 1) {
            if (tokens[0].startIndex === 0 && tokens[0].type === '') {
                return null;
            }
        }
        var deflated = tokensBinaryEncoding_1.TokensBinaryEncoding.deflateArr(map, tokens);
        return new LineTokens(map, deflated);
    }
    function toLineTokensFromDeflated(map, tokens, textLength) {
        if (textLength === 0) {
            return null;
        }
        if (!tokens || tokens.length === 0) {
            return null;
        }
        if (tokens.length === 1) {
            if (tokens[0] === 0) {
                return null;
            }
        }
        return new LineTokens(map, tokens);
    }
    var LineTokens = (function () {
        function LineTokens(map, tokens) {
            this.map = map;
            this._tokens = tokens;
        }
        LineTokens.prototype.getBinaryEncodedTokensMap = function () {
            return this.map;
        };
        LineTokens.prototype.getBinaryEncodedTokens = function () {
            return this._tokens;
        };
        LineTokens.prototype.getTokenCount = function () {
            return this._tokens.length;
        };
        LineTokens.prototype.getTokenStartIndex = function (tokenIndex) {
            return tokensBinaryEncoding_1.TokensBinaryEncoding.getStartIndex(this._tokens[tokenIndex]);
        };
        LineTokens.prototype.getTokenType = function (tokenIndex) {
            return tokensBinaryEncoding_1.TokensBinaryEncoding.getType(this.map, this._tokens[tokenIndex]);
        };
        LineTokens.prototype.getTokenEndIndex = function (tokenIndex, textLength) {
            if (tokenIndex + 1 < this._tokens.length) {
                return tokensBinaryEncoding_1.TokensBinaryEncoding.getStartIndex(this._tokens[tokenIndex + 1]);
            }
            return textLength;
        };
        LineTokens.prototype.equals = function (other) {
            if (other instanceof LineTokens) {
                if (this.map !== other.map) {
                    return false;
                }
                if (this._tokens.length !== other._tokens.length) {
                    return false;
                }
                for (var i = 0, len = this._tokens.length; i < len; i++) {
                    if (this._tokens[i] !== other._tokens[i]) {
                        return false;
                    }
                }
                return true;
            }
            if (!(other instanceof LineTokens)) {
                return false;
            }
        };
        LineTokens.prototype.findIndexOfOffset = function (offset) {
            return tokensBinaryEncoding_1.TokensBinaryEncoding.findIndexOfOffset(this._tokens, offset);
        };
        LineTokens.prototype.inflate = function () {
            return tokensBinaryEncoding_1.TokensBinaryEncoding.inflateArr(this.map, this._tokens);
        };
        LineTokens.prototype.sliceAndInflate = function (startOffset, endOffset, deltaStartIndex) {
            return tokensBinaryEncoding_1.TokensBinaryEncoding.sliceAndInflate(this.map, this._tokens, startOffset, endOffset, deltaStartIndex);
        };
        return LineTokens;
    }());
    exports.LineTokens = LineTokens;
    var EmptyLineTokens = (function () {
        function EmptyLineTokens() {
        }
        EmptyLineTokens.prototype.getTokenCount = function () {
            return 0;
        };
        EmptyLineTokens.prototype.getTokenStartIndex = function (tokenIndex) {
            return 0;
        };
        EmptyLineTokens.prototype.getTokenType = function (tokenIndex) {
            return strings.empty;
        };
        EmptyLineTokens.prototype.getTokenEndIndex = function (tokenIndex, textLength) {
            return 0;
        };
        EmptyLineTokens.prototype.equals = function (other) {
            return other === this;
        };
        EmptyLineTokens.prototype.findIndexOfOffset = function (offset) {
            return 0;
        };
        EmptyLineTokens.prototype.inflate = function () {
            return [];
        };
        EmptyLineTokens.prototype.sliceAndInflate = function (startOffset, endOffset, deltaStartIndex) {
            return [];
        };
        EmptyLineTokens.INSTANCE = new EmptyLineTokens();
        return EmptyLineTokens;
    }());
    var DefaultLineTokens = (function () {
        function DefaultLineTokens() {
        }
        DefaultLineTokens.prototype.getTokenCount = function () {
            return 1;
        };
        DefaultLineTokens.prototype.getTokenStartIndex = function (tokenIndex) {
            return 0;
        };
        DefaultLineTokens.prototype.getTokenType = function (tokenIndex) {
            return strings.empty;
        };
        DefaultLineTokens.prototype.getTokenEndIndex = function (tokenIndex, textLength) {
            return textLength;
        };
        DefaultLineTokens.prototype.equals = function (other) {
            return this === other;
        };
        DefaultLineTokens.prototype.findIndexOfOffset = function (offset) {
            return 0;
        };
        DefaultLineTokens.prototype.inflate = function () {
            return [new viewLineToken_1.ViewLineToken(0, '')];
        };
        DefaultLineTokens.prototype.sliceAndInflate = function (startOffset, endOffset, deltaStartIndex) {
            return [new viewLineToken_1.ViewLineToken(0, '')];
        };
        DefaultLineTokens.INSTANCE = new DefaultLineTokens();
        return DefaultLineTokens;
    }());
    exports.DefaultLineTokens = DefaultLineTokens;
    function toModeTransitions(topLevelMode, modeTransitions) {
        if (!modeTransitions || modeTransitions.length === 0) {
            return null;
        }
        else if (modeTransitions.length === 1 && modeTransitions[0].startIndex === 0 && modeTransitions[0].mode === topLevelMode) {
            return null;
        }
        return modeTransitions;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[214], __M([0,1,16,375]), function (require, exports, event_1, languageSelector_1) {
    'use strict';
    var LanguageFeatureRegistry = (function () {
        function LanguageFeatureRegistry() {
            this._clock = 0;
            this._entries = [];
            this._onDidChange = new event_1.Emitter();
        }
        Object.defineProperty(LanguageFeatureRegistry.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        LanguageFeatureRegistry.prototype.register = function (selector, provider, isBuiltin) {
            var _this = this;
            if (isBuiltin === void 0) { isBuiltin = false; }
            var entry = {
                selector: selector,
                provider: provider,
                isBuiltin: isBuiltin,
                _score: -1,
                _time: this._clock++
            };
            this._entries.push(entry);
            this._lastCandidate = undefined;
            this._onDidChange.fire(this._entries.length);
            return {
                dispose: function () {
                    if (entry) {
                        var idx = _this._entries.indexOf(entry);
                        if (idx >= 0) {
                            _this._entries.splice(idx, 1);
                            _this._lastCandidate = undefined;
                            _this._onDidChange.fire(_this._entries.length);
                            entry = undefined;
                        }
                    }
                }
            };
        };
        LanguageFeatureRegistry.prototype.has = function (model) {
            return this.all(model).length > 0;
        };
        LanguageFeatureRegistry.prototype.all = function (model) {
            if (!model || model.isTooLargeForHavingAMode()) {
                return [];
            }
            this._updateScores(model);
            var result = [];
            // from registry
            for (var _i = 0, _a = this._entries; _i < _a.length; _i++) {
                var entry = _a[_i];
                if (entry._score > 0) {
                    result.push(entry.provider);
                }
            }
            return result;
        };
        LanguageFeatureRegistry.prototype.ordered = function (model) {
            var result = [];
            this._orderedForEach(model, function (entry) { return result.push(entry.provider); });
            return result;
        };
        LanguageFeatureRegistry.prototype.orderedGroups = function (model) {
            var result = [];
            var lastBucket;
            var lastBucketScore;
            this._orderedForEach(model, function (entry) {
                if (lastBucket && lastBucketScore === entry._score) {
                    lastBucket.push(entry.provider);
                }
                else {
                    lastBucketScore = entry._score;
                    lastBucket = [entry.provider];
                    result.push(lastBucket);
                }
            });
            return result;
        };
        LanguageFeatureRegistry.prototype._orderedForEach = function (model, callback) {
            if (!model || model.isTooLargeForHavingAMode()) {
                return;
            }
            this._updateScores(model);
            for (var from = 0; from < this._entries.length; from++) {
                var entry = this._entries[from];
                if (entry._score > 0) {
                    callback(entry);
                }
            }
        };
        LanguageFeatureRegistry.prototype._updateScores = function (model) {
            var candidate = {
                uri: model.uri.toString(),
                language: model.getModeId()
            };
            if (this._lastCandidate
                && this._lastCandidate.language === candidate.language
                && this._lastCandidate.uri === candidate.uri) {
                // nothing has changed
                return;
            }
            this._lastCandidate = candidate;
            for (var _i = 0, _a = this._entries; _i < _a.length; _i++) {
                var entry = _a[_i];
                entry._score = languageSelector_1.score(entry.selector, model.uri, model.getModeId());
                if (entry.isBuiltin && entry._score > 0) {
                    entry._score = .5;
                    entry._time = -1;
                }
            }
            // needs sorting
            this._entries.sort(LanguageFeatureRegistry._compareByScoreAndTime);
        };
        LanguageFeatureRegistry._compareByScoreAndTime = function (a, b) {
            if (a._score < b._score) {
                return 1;
            }
            else if (a._score > b._score) {
                return -1;
            }
            else if (a._time < b._time) {
                return 1;
            }
            else if (a._time > b._time) {
                return -1;
            }
            else {
                return 0;
            }
        };
        return LanguageFeatureRegistry;
    }());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = LanguageFeatureRegistry;
});

define(__m[17], __M([0,1,214]), function (require, exports, languageFeatureRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * A document highlight kind.
     */
    (function (DocumentHighlightKind) {
        /**
         * A textual occurrence.
         */
        DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
        /**
         * Read-access of a symbol, like reading a variable.
         */
        DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
        /**
         * Write-access of a symbol, like writing to a variable.
         */
        DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
    })(exports.DocumentHighlightKind || (exports.DocumentHighlightKind = {}));
    var DocumentHighlightKind = exports.DocumentHighlightKind;
    /**
     * A symbol kind.
     */
    (function (SymbolKind) {
        SymbolKind[SymbolKind["File"] = 0] = "File";
        SymbolKind[SymbolKind["Module"] = 1] = "Module";
        SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
        SymbolKind[SymbolKind["Package"] = 3] = "Package";
        SymbolKind[SymbolKind["Class"] = 4] = "Class";
        SymbolKind[SymbolKind["Method"] = 5] = "Method";
        SymbolKind[SymbolKind["Property"] = 6] = "Property";
        SymbolKind[SymbolKind["Field"] = 7] = "Field";
        SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
        SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
        SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
        SymbolKind[SymbolKind["Function"] = 11] = "Function";
        SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
        SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
        SymbolKind[SymbolKind["String"] = 14] = "String";
        SymbolKind[SymbolKind["Number"] = 15] = "Number";
        SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
        SymbolKind[SymbolKind["Array"] = 17] = "Array";
        SymbolKind[SymbolKind["Object"] = 18] = "Object";
        SymbolKind[SymbolKind["Key"] = 19] = "Key";
        SymbolKind[SymbolKind["Null"] = 20] = "Null";
    })(exports.SymbolKind || (exports.SymbolKind = {}));
    var SymbolKind = exports.SymbolKind;
    /**
     * @internal
     */
    var SymbolKind;
    (function (SymbolKind) {
        /**
         * @internal
         */
        function from(kind) {
            switch (kind) {
                case SymbolKind.Method:
                    return 'method';
                case SymbolKind.Function:
                    return 'function';
                case SymbolKind.Constructor:
                    return 'constructor';
                case SymbolKind.Variable:
                    return 'variable';
                case SymbolKind.Class:
                    return 'class';
                case SymbolKind.Interface:
                    return 'interface';
                case SymbolKind.Namespace:
                    return 'namespace';
                case SymbolKind.Package:
                    return 'package';
                case SymbolKind.Module:
                    return 'module';
                case SymbolKind.Property:
                    return 'property';
                case SymbolKind.Enum:
                    return 'enum';
                case SymbolKind.String:
                    return 'string';
                case SymbolKind.File:
                    return 'file';
                case SymbolKind.Array:
                    return 'array';
                case SymbolKind.Number:
                    return 'number';
                case SymbolKind.Boolean:
                    return 'boolean';
                case SymbolKind.Object:
                    return 'object';
                case SymbolKind.Key:
                    return 'key';
                case SymbolKind.Null:
                    return 'null';
            }
            return 'property';
        }
        SymbolKind.from = from;
        /**
         * @internal
         */
        function to(type) {
            switch (type) {
                case 'method':
                    return SymbolKind.Method;
                case 'function':
                    return SymbolKind.Function;
                case 'constructor':
                    return SymbolKind.Constructor;
                case 'variable':
                    return SymbolKind.Variable;
                case 'class':
                    return SymbolKind.Class;
                case 'interface':
                    return SymbolKind.Interface;
                case 'namespace':
                    return SymbolKind.Namespace;
                case 'package':
                    return SymbolKind.Package;
                case 'module':
                    return SymbolKind.Module;
                case 'property':
                    return SymbolKind.Property;
                case 'enum':
                    return SymbolKind.Enum;
                case 'string':
                    return SymbolKind.String;
                case 'file':
                    return SymbolKind.File;
                case 'array':
                    return SymbolKind.Array;
                case 'number':
                    return SymbolKind.Number;
                case 'boolean':
                    return SymbolKind.Boolean;
                case 'object':
                    return SymbolKind.Object;
                case 'key':
                    return SymbolKind.Key;
                case 'null':
                    return SymbolKind.Null;
            }
            return SymbolKind.Property;
        }
        SymbolKind.to = to;
    })(SymbolKind = exports.SymbolKind || (exports.SymbolKind = {}));
    /**
     * Describes what to do with the indentation when pressing Enter.
     */
    (function (IndentAction) {
        /**
         * Insert new line and copy the previous line's indentation.
         */
        IndentAction[IndentAction["None"] = 0] = "None";
        /**
         * Insert new line and indent once (relative to the previous line's indentation).
         */
        IndentAction[IndentAction["Indent"] = 1] = "Indent";
        /**
         * Insert two new lines:
         *  - the first one indented which will hold the cursor
         *  - the second one at the same indentation level
         */
        IndentAction[IndentAction["IndentOutdent"] = 2] = "IndentOutdent";
        /**
         * Insert new line and outdent once (relative to the previous line's indentation).
         */
        IndentAction[IndentAction["Outdent"] = 3] = "Outdent";
    })(exports.IndentAction || (exports.IndentAction = {}));
    var IndentAction = exports.IndentAction;
    // --- feature registries ------
    /**
     * @internal
     */
    exports.ReferenceProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.RenameProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.SuggestRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.SignatureHelpProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.HoverProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DocumentSymbolProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DocumentHighlightProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DefinitionProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.CodeLensProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.CodeActionProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DocumentFormattingEditProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.DocumentRangeFormattingEditProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.OnTypeFormattingEditProviderRegistry = new languageFeatureRegistry_1.default();
    /**
     * @internal
     */
    exports.LinkProviderRegistry = new languageFeatureRegistry_1.default();
});

define(__m[216], __M([0,1,8,10,17,49]), function (require, exports, errors_1, strings, modes_1, supports_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var OnEnterSupport = (function () {
        function OnEnterSupport(registry, modeId, opts) {
            this._registry = registry;
            opts = opts || {};
            opts.brackets = opts.brackets || [
                ['(', ')'],
                ['{', '}'],
                ['[', ']']
            ];
            this._modeId = modeId;
            this._brackets = opts.brackets.map(function (bracket) {
                return {
                    open: bracket[0],
                    openRegExp: OnEnterSupport._createOpenBracketRegExp(bracket[0]),
                    close: bracket[1],
                    closeRegExp: OnEnterSupport._createCloseBracketRegExp(bracket[1]),
                };
            });
            this._regExpRules = opts.regExpRules || [];
            this._indentationRules = opts.indentationRules;
        }
        OnEnterSupport.prototype.onEnter = function (model, position) {
            var _this = this;
            var context = model.getLineContext(position.lineNumber);
            return supports_1.handleEvent(context, position.column - 1, function (nestedModeId, context, offset) {
                if (_this._modeId === nestedModeId) {
                    return _this._onEnter(model, position);
                }
                var onEnterSupport = _this._registry.getOnEnterSupport(nestedModeId);
                if (onEnterSupport) {
                    return onEnterSupport.onEnter(model, position);
                }
                return null;
            });
        };
        OnEnterSupport.prototype._onEnter = function (model, position) {
            var lineText = model.getLineContent(position.lineNumber);
            var beforeEnterText = lineText.substr(0, position.column - 1);
            var afterEnterText = lineText.substr(position.column - 1);
            var oneLineAboveText = position.lineNumber === 1 ? '' : model.getLineContent(position.lineNumber - 1);
            return this._actualOnEnter(oneLineAboveText, beforeEnterText, afterEnterText);
        };
        OnEnterSupport.prototype._actualOnEnter = function (oneLineAboveText, beforeEnterText, afterEnterText) {
            // (1): `regExpRules`
            for (var i = 0, len = this._regExpRules.length; i < len; i++) {
                var rule = this._regExpRules[i];
                if (rule.beforeText.test(beforeEnterText)) {
                    if (rule.afterText) {
                        if (rule.afterText.test(afterEnterText)) {
                            return rule.action;
                        }
                    }
                    else {
                        return rule.action;
                    }
                }
            }
            // (2): Special indent-outdent
            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {
                for (var i = 0, len = this._brackets.length; i < len; i++) {
                    var bracket = this._brackets[i];
                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {
                        return OnEnterSupport._INDENT_OUTDENT;
                    }
                }
            }
            // (3): Indentation Support
            if (this._indentationRules) {
                if (this._indentationRules.increaseIndentPattern && this._indentationRules.increaseIndentPattern.test(beforeEnterText)) {
                    return OnEnterSupport._INDENT;
                }
                if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(beforeEnterText)) {
                    return OnEnterSupport._INDENT;
                }
                if (/^\s/.test(beforeEnterText)) {
                    // No reason to run regular expressions if there is nothing to outdent from
                    if (this._indentationRules.decreaseIndentPattern && this._indentationRules.decreaseIndentPattern.test(afterEnterText)) {
                        return OnEnterSupport._OUTDENT;
                    }
                    if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(oneLineAboveText)) {
                        return OnEnterSupport._OUTDENT;
                    }
                }
            }
            // (4): Open bracket based logic
            if (beforeEnterText.length > 0) {
                for (var i = 0, len = this._brackets.length; i < len; i++) {
                    var bracket = this._brackets[i];
                    if (bracket.openRegExp.test(beforeEnterText)) {
                        return OnEnterSupport._INDENT;
                    }
                }
            }
            return null;
        };
        OnEnterSupport._createOpenBracketRegExp = function (bracket) {
            var str = strings.escapeRegExpCharacters(bracket);
            if (!/\B/.test(str.charAt(0))) {
                str = '\\b' + str;
            }
            str += '\\s*$';
            return OnEnterSupport._safeRegExp(str);
        };
        OnEnterSupport._createCloseBracketRegExp = function (bracket) {
            var str = strings.escapeRegExpCharacters(bracket);
            if (!/\B/.test(str.charAt(str.length - 1))) {
                str = str + '\\b';
            }
            str = '^\\s*' + str;
            return OnEnterSupport._safeRegExp(str);
        };
        OnEnterSupport._safeRegExp = function (def) {
            try {
                return new RegExp(def);
            }
            catch (err) {
                errors_1.onUnexpectedError(err);
                return null;
            }
        };
        OnEnterSupport._INDENT = { indentAction: modes_1.IndentAction.Indent };
        OnEnterSupport._INDENT_OUTDENT = { indentAction: modes_1.IndentAction.IndentOutdent };
        OnEnterSupport._OUTDENT = { indentAction: modes_1.IndentAction.Outdent };
        return OnEnterSupport;
    }());
    exports.OnEnterSupport = OnEnterSupport;
});

define(__m[40], __M([0,1,17,384,389,216,83,16,8,21,10,76]), function (require, exports, modes_1, characterPair_1, electricCharacter_1, onEnter_1, richEditBrackets_1, event_1, errors_1, position_1, strings, wordHelper_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var RichEditSupport = (function () {
        function RichEditSupport(modeId, previous, rawConf) {
            var prev = null;
            if (previous) {
                prev = previous._conf;
            }
            this._conf = RichEditSupport._mergeConf(prev, rawConf);
            if (this._conf.brackets) {
                this.brackets = new richEditBrackets_1.RichEditBrackets(modeId, this._conf.brackets);
            }
            this._handleOnEnter(modeId, this._conf);
            this._handleComments(modeId, this._conf);
            if (this._conf.autoClosingPairs) {
                this.characterPair = new characterPair_1.CharacterPairSupport(exports.LanguageConfigurationRegistry, modeId, this._conf);
            }
            if (this._conf.__electricCharacterSupport || this._conf.brackets) {
                this.electricCharacter = new electricCharacter_1.BracketElectricCharacterSupport(exports.LanguageConfigurationRegistry, modeId, this.brackets, this._conf.__electricCharacterSupport);
            }
            this.wordDefinition = this._conf.wordPattern || wordHelper_1.DEFAULT_WORD_REGEXP;
        }
        RichEditSupport._mergeConf = function (prev, current) {
            return {
                comments: (prev ? current.comments || prev.comments : current.comments),
                brackets: (prev ? current.brackets || prev.brackets : current.brackets),
                wordPattern: (prev ? current.wordPattern || prev.wordPattern : current.wordPattern),
                indentationRules: (prev ? current.indentationRules || prev.indentationRules : current.indentationRules),
                onEnterRules: (prev ? current.onEnterRules || prev.onEnterRules : current.onEnterRules),
                autoClosingPairs: (prev ? current.autoClosingPairs || prev.autoClosingPairs : current.autoClosingPairs),
                surroundingPairs: (prev ? current.surroundingPairs || prev.surroundingPairs : current.surroundingPairs),
                __electricCharacterSupport: (prev ? current.__electricCharacterSupport || prev.__electricCharacterSupport : current.__electricCharacterSupport),
            };
        };
        RichEditSupport.prototype._handleOnEnter = function (modeId, conf) {
            // on enter
            var onEnter = {};
            var empty = true;
            if (conf.brackets) {
                empty = false;
                onEnter.brackets = conf.brackets;
            }
            if (conf.indentationRules) {
                empty = false;
                onEnter.indentationRules = conf.indentationRules;
            }
            if (conf.onEnterRules) {
                empty = false;
                onEnter.regExpRules = conf.onEnterRules;
            }
            if (!empty) {
                this.onEnter = new onEnter_1.OnEnterSupport(exports.LanguageConfigurationRegistry, modeId, onEnter);
            }
        };
        RichEditSupport.prototype._handleComments = function (modeId, conf) {
            var commentRule = conf.comments;
            // comment configuration
            if (commentRule) {
                this.comments = {};
                if (commentRule.lineComment) {
                    this.comments.lineCommentToken = commentRule.lineComment;
                }
                if (commentRule.blockComment) {
                    var _a = commentRule.blockComment, blockStart = _a[0], blockEnd = _a[1];
                    this.comments.blockCommentStartToken = blockStart;
                    this.comments.blockCommentEndToken = blockEnd;
                }
            }
        };
        return RichEditSupport;
    }());
    exports.RichEditSupport = RichEditSupport;
    var LanguageConfigurationRegistryImpl = (function () {
        function LanguageConfigurationRegistryImpl() {
            this._onDidChange = new event_1.Emitter();
            this.onDidChange = this._onDidChange.event;
            this._entries = Object.create(null);
        }
        LanguageConfigurationRegistryImpl.prototype.register = function (languageId, configuration) {
            var previous = this._entries[languageId] || null;
            this._entries[languageId] = new RichEditSupport(languageId, previous, configuration);
            this._onDidChange.fire(void 0);
            return {
                dispose: function () { }
            };
        };
        LanguageConfigurationRegistryImpl.prototype._getRichEditSupport = function (modeId) {
            return this._entries[modeId];
        };
        LanguageConfigurationRegistryImpl.prototype.getElectricCharacterSupport = function (modeId) {
            var value = this._getRichEditSupport(modeId);
            if (!value) {
                return null;
            }
            return value.electricCharacter || null;
        };
        LanguageConfigurationRegistryImpl.prototype.getComments = function (modeId) {
            var value = this._getRichEditSupport(modeId);
            if (!value) {
                return null;
            }
            return value.comments || null;
        };
        LanguageConfigurationRegistryImpl.prototype.getCharacterPairSupport = function (modeId) {
            var value = this._getRichEditSupport(modeId);
            if (!value) {
                return null;
            }
            return value.characterPair || null;
        };
        LanguageConfigurationRegistryImpl.prototype.getWordDefinition = function (modeId) {
            var value = this._getRichEditSupport(modeId);
            if (!value) {
                return null;
            }
            return value.wordDefinition || null;
        };
        LanguageConfigurationRegistryImpl.prototype.getOnEnterSupport = function (modeId) {
            var value = this._getRichEditSupport(modeId);
            if (!value) {
                return null;
            }
            return value.onEnter || null;
        };
        LanguageConfigurationRegistryImpl.prototype.getRawEnterActionAtPosition = function (model, lineNumber, column) {
            var result;
            var onEnterSupport = this.getOnEnterSupport(model.getMode().getId());
            if (onEnterSupport) {
                try {
                    result = onEnterSupport.onEnter(model, new position_1.Position(lineNumber, column));
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                }
            }
            return result;
        };
        LanguageConfigurationRegistryImpl.prototype.getEnterActionAtPosition = function (model, lineNumber, column) {
            var lineText = model.getLineContent(lineNumber);
            var indentation = strings.getLeadingWhitespace(lineText);
            if (indentation.length > column - 1) {
                indentation = indentation.substring(0, column - 1);
            }
            var enterAction = this.getRawEnterActionAtPosition(model, lineNumber, column);
            if (!enterAction) {
                enterAction = {
                    indentAction: modes_1.IndentAction.None,
                    appendText: '',
                };
            }
            else {
                if (!enterAction.appendText) {
                    if ((enterAction.indentAction === modes_1.IndentAction.Indent) ||
                        (enterAction.indentAction === modes_1.IndentAction.IndentOutdent)) {
                        enterAction.appendText = '\t';
                    }
                    else {
                        enterAction.appendText = '';
                    }
                }
            }
            if (enterAction.removeText) {
                indentation = indentation.substring(0, indentation.length - 1);
            }
            return {
                enterAction: enterAction,
                indentation: indentation
            };
        };
        LanguageConfigurationRegistryImpl.prototype.getBracketsSupport = function (modeId) {
            var value = this._getRichEditSupport(modeId);
            if (!value) {
                return null;
            }
            return value.brackets || null;
        };
        return LanguageConfigurationRegistryImpl;
    }());
    exports.LanguageConfigurationRegistryImpl = LanguageConfigurationRegistryImpl;
    exports.LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();
});

define(__m[218], __M([0,1,10,97,4,24,40]), function (require, exports, strings, cursorMoveHelper_1, range_1, selection_1, languageConfigurationRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ShiftCommand = (function () {
        function ShiftCommand(range, opts) {
            this._opts = opts;
            this._selection = range;
            this._useLastEditRangeForCursorEndPosition = false;
        }
        ShiftCommand.unshiftIndentCount = function (line, column, tabSize) {
            // Determine the visible column where the content starts
            var contentStartVisibleColumn = cursorMoveHelper_1.CursorMoveHelper.visibleColumnFromColumn2(line, column, tabSize);
            var desiredTabStop = cursorMoveHelper_1.CursorMoveHelper.prevTabColumn(contentStartVisibleColumn, tabSize);
            // The `desiredTabStop` is a multiple of `tabSize` => determine the number of indents
            return desiredTabStop / tabSize;
        };
        ShiftCommand.shiftIndentCount = function (line, column, tabSize) {
            // Determine the visible column where the content starts
            var contentStartVisibleColumn = cursorMoveHelper_1.CursorMoveHelper.visibleColumnFromColumn2(line, column, tabSize);
            var desiredTabStop = cursorMoveHelper_1.CursorMoveHelper.nextTabColumn(contentStartVisibleColumn, tabSize);
            // The `desiredTabStop` is a multiple of `tabSize` => determine the number of indents
            return desiredTabStop / tabSize;
        };
        ShiftCommand.prototype.getEditOperations = function (model, builder) {
            var startLine = this._selection.startLineNumber, endLine = this._selection.endLineNumber, _SPACE = ' '.charCodeAt(0);
            if (this._selection.endColumn === 1 && startLine !== endLine) {
                endLine = endLine - 1;
            }
            var lineNumber, tabSize = this._opts.tabSize, oneIndent = this._opts.oneIndent, shouldIndentEmptyLines = (startLine === endLine);
            // indents[i] represents i * oneIndent
            var indents = ['', oneIndent];
            // if indenting or outdenting on a whitespace only line
            if (this._selection.isEmpty()) {
                if (/^\s*$/.test(model.getLineContent(startLine))) {
                    this._useLastEditRangeForCursorEndPosition = true;
                }
            }
            // keep track of previous line's "miss-alignment"
            var previousLineExtraSpaces = 0, extraSpaces = 0;
            for (lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {
                extraSpaces = 0;
                var lineText = model.getLineContent(lineNumber);
                var indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);
                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {
                    // empty line or line with no leading whitespace => nothing to do
                    continue;
                }
                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {
                    // do not indent empty lines => nothing to do
                    continue;
                }
                if (indentationEndIndex === -1) {
                    // the entire line is whitespace
                    indentationEndIndex = lineText.length;
                }
                if (lineNumber > 1) {
                    var contentStartVisibleColumn = cursorMoveHelper_1.CursorMoveHelper.visibleColumnFromColumn2(lineText, indentationEndIndex + 1, tabSize);
                    if (contentStartVisibleColumn % tabSize !== 0) {
                        // The current line is "miss-aligned", so let's see if this is expected...
                        // This can only happen when it has trailing commas in the indent
                        var enterAction = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getRawEnterActionAtPosition(model, lineNumber - 1, model.getLineMaxColumn(lineNumber - 1));
                        if (enterAction) {
                            extraSpaces = previousLineExtraSpaces;
                            if (enterAction.appendText) {
                                for (var j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < tabSize; j++) {
                                    if (enterAction.appendText.charCodeAt(j) === _SPACE) {
                                        extraSpaces++;
                                    }
                                    else {
                                        break;
                                    }
                                }
                            }
                            if (enterAction.removeText) {
                                extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);
                            }
                            // Act as if `prefixSpaces` is not part of the indentation
                            for (var j = 0; j < extraSpaces; j++) {
                                if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== _SPACE) {
                                    break;
                                }
                                indentationEndIndex--;
                            }
                        }
                    }
                }
                if (this._opts.isUnshift && indentationEndIndex === 0) {
                    // line with no leading whitespace => nothing to do
                    continue;
                }
                var desiredIndentCount = void 0;
                if (this._opts.isUnshift) {
                    desiredIndentCount = ShiftCommand.unshiftIndentCount(lineText, indentationEndIndex + 1, tabSize);
                }
                else {
                    desiredIndentCount = ShiftCommand.shiftIndentCount(lineText, indentationEndIndex + 1, tabSize);
                }
                // Fill `indents`, as needed
                for (var j = indents.length; j <= desiredIndentCount; j++) {
                    indents[j] = indents[j - 1] + oneIndent;
                }
                builder.addEditOperation(new range_1.Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), indents[desiredIndentCount]);
            }
            this._selectionId = builder.trackSelection(this._selection);
        };
        ShiftCommand.prototype.computeCursorState = function (model, helper) {
            if (this._useLastEditRangeForCursorEndPosition) {
                var lastOp = helper.getInverseEditOperations()[0];
                return new selection_1.Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);
            }
            return helper.getTrackedSelection(this._selectionId);
        };
        return ShiftCommand;
    }());
    exports.ShiftCommand = ShiftCommand;
});

define(__m[173], __M([0,1,8,10,110,218,270,97,21,4,24,7,17,40]), function (require, exports, errors_1, strings, replaceCommand_1, shiftCommand_1, surroundSelectionCommand_1, cursorMoveHelper_1, position_1, range_1, selection_1, editorCommon, modes_1, languageConfigurationRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    (function (WordType) {
        WordType[WordType["None"] = 0] = "None";
        WordType[WordType["Regular"] = 1] = "Regular";
        WordType[WordType["Separator"] = 2] = "Separator";
    })(exports.WordType || (exports.WordType = {}));
    var WordType = exports.WordType;
    ;
    var CharacterClass;
    (function (CharacterClass) {
        CharacterClass[CharacterClass["Regular"] = 0] = "Regular";
        CharacterClass[CharacterClass["Whitespace"] = 1] = "Whitespace";
        CharacterClass[CharacterClass["WordSeparator"] = 2] = "WordSeparator";
    })(CharacterClass || (CharacterClass = {}));
    ;
    (function (WordNavigationType) {
        WordNavigationType[WordNavigationType["WordStart"] = 0] = "WordStart";
        WordNavigationType[WordNavigationType["WordEnd"] = 1] = "WordEnd";
    })(exports.WordNavigationType || (exports.WordNavigationType = {}));
    var WordNavigationType = exports.WordNavigationType;
    var CH_REGULAR = CharacterClass.Regular;
    var CH_WHITESPACE = CharacterClass.Whitespace;
    var CH_WORD_SEPARATOR = CharacterClass.WordSeparator;
    var W_NONE = WordType.None;
    var W_REGULAR = WordType.Regular;
    var W_SEPARATOR = WordType.Separator;
    var OneCursor = (function () {
        function OneCursor(editorId, model, configuration, modeConfiguration, viewModelHelper) {
            this.editorId = editorId;
            this.model = model;
            this.configuration = configuration;
            this.modeConfiguration = modeConfiguration;
            this.viewModelHelper = viewModelHelper;
            this.helper = new CursorHelper(this.model, this.configuration);
            this.bracketDecorations = [];
            this._set(new range_1.Range(1, 1, 1, 1), 0, new position_1.Position(1, 1), 0, new range_1.Range(1, 1, 1, 1), new position_1.Position(1, 1));
        }
        OneCursor.prototype._set = function (selectionStart, selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns, viewSelectionStart, viewPosition) {
            this.selectionStart = selectionStart;
            this.selectionStartLeftoverVisibleColumns = selectionStartLeftoverVisibleColumns;
            this.position = position;
            this.leftoverVisibleColumns = leftoverVisibleColumns;
            this.viewSelectionStart = viewSelectionStart;
            this.viewPosition = viewPosition;
            this._cachedSelection = OneCursor.computeSelection(this.selectionStart, this.position);
            this._cachedViewSelection = OneCursor.computeSelection(this.viewSelectionStart, this.viewPosition);
            this._selStartMarker = this._ensureMarker(this._selStartMarker, this._cachedSelection.startLineNumber, this._cachedSelection.startColumn, true);
            this._selEndMarker = this._ensureMarker(this._selEndMarker, this._cachedSelection.endLineNumber, this._cachedSelection.endColumn, false);
            this._selDirection = this._cachedSelection.getDirection();
        };
        OneCursor.prototype._ensureMarker = function (markerId, lineNumber, column, stickToPreviousCharacter) {
            if (!markerId) {
                return this.model._addMarker(lineNumber, column, stickToPreviousCharacter);
            }
            else {
                this.model._changeMarker(markerId, lineNumber, column);
                this.model._changeMarkerStickiness(markerId, stickToPreviousCharacter);
                return markerId;
            }
        };
        OneCursor.prototype.saveState = function () {
            return {
                selectionStart: this.selectionStart,
                viewSelectionStart: this.viewSelectionStart,
                position: this.position,
                viewPosition: this.viewPosition,
                leftoverVisibleColumns: this.leftoverVisibleColumns,
                selectionStartLeftoverVisibleColumns: this.selectionStartLeftoverVisibleColumns
            };
        };
        OneCursor.prototype.restoreState = function (state) {
            var position = this.model.validatePosition(state.position);
            var selectionStart;
            if (state.selectionStart) {
                selectionStart = this.model.validateRange(state.selectionStart);
            }
            else {
                selectionStart = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
            }
            var viewPosition = this.viewModelHelper.validateViewPosition(state.viewPosition.lineNumber, state.viewPosition.column, position);
            var viewSelectionStart;
            if (state.viewSelectionStart) {
                viewSelectionStart = this.viewModelHelper.validateViewRange(state.viewSelectionStart.startLineNumber, state.viewSelectionStart.startColumn, state.viewSelectionStart.endLineNumber, state.viewSelectionStart.endColumn, selectionStart);
            }
            else {
                viewSelectionStart = this.viewModelHelper.convertModelRangeToViewRange(selectionStart);
            }
            this._set(selectionStart, state.selectionStartLeftoverVisibleColumns, position, state.leftoverVisibleColumns, viewSelectionStart, viewPosition);
        };
        OneCursor.prototype.updateModeConfiguration = function (modeConfiguration) {
            this.modeConfiguration = modeConfiguration;
        };
        OneCursor.prototype.duplicate = function () {
            var result = new OneCursor(this.editorId, this.model, this.configuration, this.modeConfiguration, this.viewModelHelper);
            result._set(this.selectionStart, this.selectionStartLeftoverVisibleColumns, this.position, this.leftoverVisibleColumns, this.viewSelectionStart, this.viewPosition);
            return result;
        };
        OneCursor.prototype.dispose = function () {
            this.model._removeMarker(this._selStartMarker);
            this.model._removeMarker(this._selEndMarker);
            this.bracketDecorations = this.model.deltaDecorations(this.bracketDecorations, [], this.editorId);
        };
        OneCursor.prototype.adjustBracketDecorations = function () {
            var bracketMatch = null;
            var selection = this.getSelection();
            if (selection.isEmpty()) {
                bracketMatch = this.model.matchBracket(this.position);
            }
            var newDecorations = [];
            if (bracketMatch) {
                var options = {
                    stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                    className: 'bracket-match'
                };
                newDecorations.push({ range: bracketMatch[0], options: options });
                newDecorations.push({ range: bracketMatch[1], options: options });
            }
            this.bracketDecorations = this.model.deltaDecorations(this.bracketDecorations, newDecorations, this.editorId);
        };
        OneCursor.computeSelection = function (selectionStart, position) {
            var startLineNumber, startColumn, endLineNumber, endColumn;
            if (selectionStart.isEmpty()) {
                startLineNumber = selectionStart.startLineNumber;
                startColumn = selectionStart.startColumn;
                endLineNumber = position.lineNumber;
                endColumn = position.column;
            }
            else {
                if (position.isBeforeOrEqual(selectionStart.getStartPosition())) {
                    startLineNumber = selectionStart.endLineNumber;
                    startColumn = selectionStart.endColumn;
                    endLineNumber = position.lineNumber;
                    endColumn = position.column;
                }
                else {
                    startLineNumber = selectionStart.startLineNumber;
                    startColumn = selectionStart.startColumn;
                    endLineNumber = position.lineNumber;
                    endColumn = position.column;
                }
            }
            return new selection_1.Selection(startLineNumber, startColumn, endLineNumber, endColumn);
        };
        OneCursor.prototype.setSelection = function (desiredSelection) {
            var position = this.model.validatePosition({
                lineNumber: desiredSelection.positionLineNumber,
                column: desiredSelection.positionColumn
            });
            var selectionStartPosition = this.model.validatePosition({
                lineNumber: desiredSelection.selectionStartLineNumber,
                column: desiredSelection.selectionStartColumn
            });
            var selectionStart = new range_1.Range(selectionStartPosition.lineNumber, selectionStartPosition.column, selectionStartPosition.lineNumber, selectionStartPosition.column);
            var viewPosition = this.viewModelHelper.convertModelPositionToViewPosition(position.lineNumber, position.column);
            var viewSelectionStart = this.viewModelHelper.convertModelRangeToViewRange(selectionStart);
            this._set(selectionStart, 0, position, 0, viewSelectionStart, viewPosition);
        };
        OneCursor.prototype.setViewSelection = function (desiredViewSel) {
            var viewSelectionStart = this.viewModelHelper.validateViewRange(desiredViewSel.selectionStartLineNumber, desiredViewSel.selectionStartColumn, desiredViewSel.selectionStartLineNumber, desiredViewSel.selectionStartColumn, this.selectionStart);
            var viewPosition = this.viewModelHelper.validateViewPosition(desiredViewSel.positionLineNumber, desiredViewSel.positionColumn, this.position);
            this._set(this.selectionStart, 0, this.position, 0, viewSelectionStart, viewPosition);
        };
        // -------------------- START modifications
        OneCursor.prototype.setSelectionStart = function (rng, viewRng) {
            this._set(rng, this.selectionStartLeftoverVisibleColumns, this.position, this.leftoverVisibleColumns, viewRng, this.viewPosition);
        };
        OneCursor.prototype.collapseSelection = function () {
            var selectionStart = new range_1.Range(this.position.lineNumber, this.position.column, this.position.lineNumber, this.position.column);
            var viewSelectionStart = new range_1.Range(this.viewPosition.lineNumber, this.viewPosition.column, this.viewPosition.lineNumber, this.viewPosition.column);
            this._set(selectionStart, 0, this.position, this.leftoverVisibleColumns, viewSelectionStart, this.viewPosition);
        };
        OneCursor.prototype.moveModelPosition = function (inSelectionMode, lineNumber, column, leftoverVisibleColumns, ensureInEditableRange) {
            var viewPosition = this.viewModelHelper.convertModelPositionToViewPosition(lineNumber, column);
            this._move(inSelectionMode, lineNumber, column, viewPosition.lineNumber, viewPosition.column, leftoverVisibleColumns, ensureInEditableRange);
        };
        OneCursor.prototype.moveViewPosition = function (inSelectionMode, viewLineNumber, viewColumn, leftoverVisibleColumns, ensureInEditableRange) {
            var modelPosition = this.viewModelHelper.convertViewToModelPosition(viewLineNumber, viewColumn);
            this._move(inSelectionMode, modelPosition.lineNumber, modelPosition.column, viewLineNumber, viewColumn, leftoverVisibleColumns, ensureInEditableRange);
        };
        OneCursor.prototype._move = function (inSelectionMode, lineNumber, column, viewLineNumber, viewColumn, leftoverVisibleColumns, ensureInEditableRange) {
            if (ensureInEditableRange) {
                var editableRange = this.model.getEditableRange();
                if (lineNumber < editableRange.startLineNumber || (lineNumber === editableRange.startLineNumber && column < editableRange.startColumn)) {
                    lineNumber = editableRange.startLineNumber;
                    column = editableRange.startColumn;
                    var viewPosition = this.viewModelHelper.convertModelPositionToViewPosition(lineNumber, column);
                    viewLineNumber = viewPosition.lineNumber;
                    viewColumn = viewPosition.column;
                }
                else if (lineNumber > editableRange.endLineNumber || (lineNumber === editableRange.endLineNumber && column > editableRange.endColumn)) {
                    lineNumber = editableRange.endLineNumber;
                    column = editableRange.endColumn;
                    var viewPosition = this.viewModelHelper.convertModelPositionToViewPosition(lineNumber, column);
                    viewLineNumber = viewPosition.lineNumber;
                    viewColumn = viewPosition.column;
                }
            }
            this._actualMove(inSelectionMode, new position_1.Position(lineNumber, column), new position_1.Position(viewLineNumber, viewColumn), leftoverVisibleColumns);
        };
        OneCursor.prototype._actualMove = function (inSelectionMode, position, viewPosition, leftoverVisibleColumns) {
            if (inSelectionMode) {
                // move just position
                this._set(this.selectionStart, this.selectionStartLeftoverVisibleColumns, position, leftoverVisibleColumns, this.viewSelectionStart, viewPosition);
            }
            else {
                // move everything
                var selectionStart = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
                var viewSelectionStart = new range_1.Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);
                this._set(selectionStart, leftoverVisibleColumns, position, leftoverVisibleColumns, viewSelectionStart, viewPosition);
            }
        };
        OneCursor.prototype._recoverSelectionFromMarkers = function () {
            var start = this.model._getMarker(this._selStartMarker);
            var end = this.model._getMarker(this._selEndMarker);
            if (this._selDirection === selection_1.SelectionDirection.LTR) {
                return new selection_1.Selection(start.lineNumber, start.column, end.lineNumber, end.column);
            }
            return new selection_1.Selection(end.lineNumber, end.column, start.lineNumber, start.column);
        };
        OneCursor.prototype.recoverSelectionFromMarkers = function (ctx) {
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.RecoverFromMarkers;
            ctx.shouldPushStackElementBefore = true;
            ctx.shouldPushStackElementAfter = true;
            ctx.shouldReveal = false;
            ctx.shouldRevealHorizontal = false;
            var recoveredSelection = this._recoverSelectionFromMarkers();
            var selectionStart = new range_1.Range(recoveredSelection.selectionStartLineNumber, recoveredSelection.selectionStartColumn, recoveredSelection.selectionStartLineNumber, recoveredSelection.selectionStartColumn);
            var position = new position_1.Position(recoveredSelection.positionLineNumber, recoveredSelection.positionColumn);
            var viewSelectionStart = this.viewModelHelper.convertModelRangeToViewRange(selectionStart);
            var viewPosition = this.viewModelHelper.convertViewToModelPosition(position.lineNumber, position.column);
            this._set(selectionStart, 0, position, 0, viewSelectionStart, viewPosition);
            return true;
        };
        // -------------------- END modifications
        // -------------------- START reading API
        OneCursor.prototype.getPageSize = function () {
            var c = this.configuration.editor;
            return Math.floor(c.layoutInfo.height / c.fontInfo.lineHeight) - 2;
        };
        OneCursor.prototype.getSelectionStart = function () {
            return this.selectionStart;
        };
        OneCursor.prototype.getPosition = function () {
            return this.position;
        };
        OneCursor.prototype.getSelection = function () {
            return this._cachedSelection;
        };
        OneCursor.prototype.getViewPosition = function () {
            return this.viewPosition;
        };
        OneCursor.prototype.getViewSelection = function () {
            return this._cachedViewSelection;
        };
        OneCursor.prototype.getValidViewPosition = function () {
            return this.viewModelHelper.validateViewPosition(this.viewPosition.lineNumber, this.viewPosition.column, this.position);
        };
        OneCursor.prototype.hasSelection = function () {
            return (!this.getSelection().isEmpty() || !this.selectionStart.isEmpty());
        };
        OneCursor.prototype.getBracketsDecorations = function () {
            return this.bracketDecorations;
        };
        OneCursor.prototype.getLeftoverVisibleColumns = function () {
            return this.leftoverVisibleColumns;
        };
        OneCursor.prototype.getSelectionStartLeftoverVisibleColumns = function () {
            return this.selectionStartLeftoverVisibleColumns;
        };
        OneCursor.prototype.setSelectionStartLeftoverVisibleColumns = function (value) {
            this.selectionStartLeftoverVisibleColumns = value;
        };
        // -- utils
        OneCursor.prototype.validatePosition = function (position) {
            return this.model.validatePosition(position);
        };
        OneCursor.prototype.validateViewPosition = function (viewLineNumber, viewColumn, modelPosition) {
            return this.viewModelHelper.validateViewPosition(viewLineNumber, viewColumn, modelPosition);
        };
        OneCursor.prototype.convertViewToModelPosition = function (lineNumber, column) {
            return this.viewModelHelper.convertViewToModelPosition(lineNumber, column);
        };
        OneCursor.prototype.convertViewSelectionToModelSelection = function (viewSelection) {
            return this.viewModelHelper.convertViewSelectionToModelSelection(viewSelection);
        };
        OneCursor.prototype.convertModelPositionToViewPosition = function (lineNumber, column) {
            return this.viewModelHelper.convertModelPositionToViewPosition(lineNumber, column);
        };
        // -- model
        OneCursor.prototype.getLineContent = function (lineNumber) {
            return this.model.getLineContent(lineNumber);
        };
        OneCursor.prototype.findPreviousWordOnLine = function (position) {
            return this.helper.findPreviousWordOnLine(position);
        };
        OneCursor.prototype.findNextWordOnLine = function (position) {
            return this.helper.findNextWordOnLine(position);
        };
        OneCursor.prototype.getLeftOfPosition = function (lineNumber, column) {
            return this.helper.getLeftOfPosition(this.model, lineNumber, column);
        };
        OneCursor.prototype.getRightOfPosition = function (lineNumber, column) {
            return this.helper.getRightOfPosition(this.model, lineNumber, column);
        };
        OneCursor.prototype.getPositionUp = function (lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {
            return this.helper.getPositionUp(this.model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine);
        };
        OneCursor.prototype.getPositionDown = function (lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {
            return this.helper.getPositionDown(this.model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine);
        };
        OneCursor.prototype.getColumnAtBeginningOfLine = function (lineNumber, column) {
            return this.helper.getColumnAtBeginningOfLine(this.model, lineNumber, column);
        };
        OneCursor.prototype.getColumnAtEndOfLine = function (lineNumber, column) {
            return this.helper.getColumnAtEndOfLine(this.model, lineNumber, column);
        };
        OneCursor.prototype.getVisibleColumnFromColumn = function (lineNumber, column) {
            return this.helper.visibleColumnFromColumn(this.model, lineNumber, column);
        };
        OneCursor.prototype.getColumnFromVisibleColumn = function (lineNumber, column) {
            return this.helper.columnFromVisibleColumn(this.model, lineNumber, column);
        };
        OneCursor.prototype.getViewVisibleColumnFromColumn = function (viewLineNumber, viewColumn) {
            return this.helper.visibleColumnFromColumn(this.viewModelHelper.viewModel, viewLineNumber, viewColumn);
        };
        // -- view
        OneCursor.prototype.getViewLineCount = function () {
            return this.viewModelHelper.viewModel.getLineCount();
        };
        OneCursor.prototype.getViewLineMaxColumn = function (lineNumber) {
            return this.viewModelHelper.viewModel.getLineMaxColumn(lineNumber);
        };
        OneCursor.prototype.getLeftOfViewPosition = function (lineNumber, column) {
            return this.helper.getLeftOfPosition(this.viewModelHelper.viewModel, lineNumber, column);
        };
        OneCursor.prototype.getRightOfViewPosition = function (lineNumber, column) {
            return this.helper.getRightOfPosition(this.viewModelHelper.viewModel, lineNumber, column);
        };
        OneCursor.prototype.getViewPositionUp = function (lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {
            return this.helper.getPositionUp(this.viewModelHelper.viewModel, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine);
        };
        OneCursor.prototype.getViewPositionDown = function (lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {
            return this.helper.getPositionDown(this.viewModelHelper.viewModel, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine);
        };
        OneCursor.prototype.getColumnAtBeginningOfViewLine = function (lineNumber, column) {
            return this.helper.getColumnAtBeginningOfLine(this.viewModelHelper.viewModel, lineNumber, column);
        };
        OneCursor.prototype.getColumnAtEndOfViewLine = function (lineNumber, column) {
            return this.helper.getColumnAtEndOfLine(this.viewModelHelper.viewModel, lineNumber, column);
        };
        OneCursor.prototype.columnSelect = function (fromViewLineNumber, fromViewVisibleColumn, toViewLineNumber, toViewVisibleColumn) {
            var _this = this;
            var r = this.helper.columnSelect(this.viewModelHelper.viewModel, fromViewLineNumber, fromViewVisibleColumn, toViewLineNumber, toViewVisibleColumn);
            return {
                reversed: r.reversed,
                viewSelections: r.viewSelections,
                selections: r.viewSelections.map(function (sel) { return _this.convertViewSelectionToModelSelection(sel); }),
                toLineNumber: toViewLineNumber,
                toVisualColumn: toViewVisibleColumn
            };
        };
        return OneCursor;
    }());
    exports.OneCursor = OneCursor;
    var OneCursorOp = (function () {
        function OneCursorOp() {
        }
        // -------------------- START handlers that simply change cursor state
        OneCursorOp.jumpToBracket = function (cursor, ctx) {
            var bracketDecorations = cursor.getBracketsDecorations();
            if (bracketDecorations.length !== 2) {
                return false;
            }
            var firstBracket = cursor.model.getDecorationRange(bracketDecorations[0]);
            var secondBracket = cursor.model.getDecorationRange(bracketDecorations[1]);
            var position = cursor.getPosition();
            if (Utils.isPositionAtRangeEdges(position, firstBracket) || Utils.isPositionInsideRange(position, firstBracket)) {
                cursor.moveModelPosition(false, secondBracket.endLineNumber, secondBracket.endColumn, 0, false);
                return true;
            }
            if (Utils.isPositionAtRangeEdges(position, secondBracket) || Utils.isPositionInsideRange(position, secondBracket)) {
                cursor.moveModelPosition(false, firstBracket.endLineNumber, firstBracket.endColumn, 0, false);
                return true;
            }
            return false;
        };
        OneCursorOp.moveTo = function (cursor, inSelectionMode, position, viewPosition, eventSource, ctx) {
            var validatedPosition = cursor.model.validatePosition(position);
            var validatedViewPosition;
            if (viewPosition) {
                validatedViewPosition = cursor.validateViewPosition(viewPosition.lineNumber, viewPosition.column, validatedPosition);
            }
            else {
                validatedViewPosition = cursor.convertModelPositionToViewPosition(validatedPosition.lineNumber, validatedPosition.column);
            }
            var reason = (eventSource === 'mouse' ? editorCommon.CursorChangeReason.Explicit : editorCommon.CursorChangeReason.NotSet);
            if (eventSource === 'api') {
                ctx.shouldRevealVerticalInCenter = true;
            }
            if (reason) {
                ctx.cursorPositionChangeReason = reason;
            }
            cursor.moveViewPosition(inSelectionMode, validatedViewPosition.lineNumber, validatedViewPosition.column, 0, false);
            return true;
        };
        OneCursorOp._columnSelectOp = function (cursor, toViewLineNumber, toViewVisualColumn) {
            var viewStartSelection = cursor.getViewSelection();
            var fromVisibleColumn = cursor.getVisibleColumnFromColumn(viewStartSelection.selectionStartLineNumber, viewStartSelection.selectionStartColumn);
            return cursor.columnSelect(viewStartSelection.selectionStartLineNumber, fromVisibleColumn, toViewLineNumber, toViewVisualColumn);
        };
        OneCursorOp.columnSelectMouse = function (cursor, position, viewPosition, toViewVisualColumn) {
            var validatedPosition = cursor.model.validatePosition(position);
            var validatedViewPosition;
            if (viewPosition) {
                validatedViewPosition = cursor.validateViewPosition(viewPosition.lineNumber, viewPosition.column, validatedPosition);
            }
            else {
                validatedViewPosition = cursor.convertModelPositionToViewPosition(validatedPosition.lineNumber, validatedPosition.column);
            }
            return this._columnSelectOp(cursor, validatedViewPosition.lineNumber, toViewVisualColumn);
        };
        OneCursorOp.columnSelectLeft = function (cursor, toViewLineNumber, toViewVisualColumn) {
            if (toViewVisualColumn > 1) {
                toViewVisualColumn--;
            }
            return this._columnSelectOp(cursor, toViewLineNumber, toViewVisualColumn);
        };
        OneCursorOp.columnSelectRight = function (cursor, toViewLineNumber, toViewVisualColumn) {
            var maxVisualViewColumn = 0;
            var minViewLineNumber = Math.min(cursor.getViewPosition().lineNumber, toViewLineNumber);
            var maxViewLineNumber = Math.max(cursor.getViewPosition().lineNumber, toViewLineNumber);
            for (var lineNumber = minViewLineNumber; lineNumber <= maxViewLineNumber; lineNumber++) {
                var lineMaxViewColumn = cursor.getViewLineMaxColumn(lineNumber);
                var lineMaxVisualViewColumn = cursor.getViewVisibleColumnFromColumn(lineNumber, lineMaxViewColumn);
                maxVisualViewColumn = Math.max(maxVisualViewColumn, lineMaxVisualViewColumn);
            }
            if (toViewVisualColumn < maxVisualViewColumn) {
                toViewVisualColumn++;
            }
            return this._columnSelectOp(cursor, toViewLineNumber, toViewVisualColumn);
        };
        OneCursorOp.columnSelectUp = function (isPaged, cursor, toViewLineNumber, toViewVisualColumn) {
            var linesCount = isPaged ? cursor.getPageSize() : 1;
            toViewLineNumber -= linesCount;
            if (toViewLineNumber < 1) {
                toViewLineNumber = 1;
            }
            return this._columnSelectOp(cursor, toViewLineNumber, toViewVisualColumn);
        };
        OneCursorOp.columnSelectDown = function (isPaged, cursor, toViewLineNumber, toViewVisualColumn) {
            var linesCount = isPaged ? cursor.getPageSize() : 1;
            toViewLineNumber += linesCount;
            if (toViewLineNumber > cursor.getViewLineCount()) {
                toViewLineNumber = cursor.getViewLineCount();
            }
            return this._columnSelectOp(cursor, toViewLineNumber, toViewVisualColumn);
        };
        OneCursorOp.moveLeft = function (cursor, inSelectionMode, ctx) {
            var viewLineNumber, viewColumn;
            if (cursor.hasSelection() && !inSelectionMode) {
                // If we are in selection mode, move left without selection cancels selection and puts cursor at the beginning of the selection
                var viewSelection = cursor.getViewSelection();
                var viewSelectionStart = cursor.validateViewPosition(viewSelection.startLineNumber, viewSelection.startColumn, cursor.getSelection().getStartPosition());
                viewLineNumber = viewSelectionStart.lineNumber;
                viewColumn = viewSelectionStart.column;
            }
            else {
                var validatedViewPosition = cursor.getValidViewPosition();
                var r = cursor.getLeftOfViewPosition(validatedViewPosition.lineNumber, validatedViewPosition.column);
                viewLineNumber = r.lineNumber;
                viewColumn = r.column;
            }
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            cursor.moveViewPosition(inSelectionMode, viewLineNumber, viewColumn, 0, true);
            return true;
        };
        OneCursorOp.moveWordLeft = function (cursor, inSelectionMode, wordNavigationType, ctx) {
            var position = cursor.getPosition();
            var lineNumber = position.lineNumber;
            var column = position.column;
            if (column === 1) {
                if (lineNumber > 1) {
                    lineNumber = lineNumber - 1;
                    column = cursor.model.getLineMaxColumn(lineNumber);
                }
            }
            var prevWordOnLine = cursor.findPreviousWordOnLine(new position_1.Position(lineNumber, column));
            if (wordNavigationType === WordNavigationType.WordStart) {
                if (prevWordOnLine) {
                    column = prevWordOnLine.start + 1;
                }
                else {
                    column = 1;
                }
            }
            else {
                if (prevWordOnLine && column <= prevWordOnLine.end + 1) {
                    prevWordOnLine = cursor.findPreviousWordOnLine(new position_1.Position(lineNumber, prevWordOnLine.start + 1));
                }
                if (prevWordOnLine) {
                    column = prevWordOnLine.end + 1;
                }
                else {
                    column = 1;
                }
            }
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            cursor.moveModelPosition(inSelectionMode, lineNumber, column, 0, true);
            return true;
        };
        OneCursorOp.moveRight = function (cursor, inSelectionMode, ctx) {
            var viewLineNumber, viewColumn;
            if (cursor.hasSelection() && !inSelectionMode) {
                // If we are in selection mode, move right without selection cancels selection and puts cursor at the end of the selection
                var viewSelection = cursor.getViewSelection();
                var viewSelectionEnd = cursor.validateViewPosition(viewSelection.endLineNumber, viewSelection.endColumn, cursor.getSelection().getEndPosition());
                viewLineNumber = viewSelectionEnd.lineNumber;
                viewColumn = viewSelectionEnd.column;
            }
            else {
                var validatedViewPosition = cursor.getValidViewPosition();
                var r = cursor.getRightOfViewPosition(validatedViewPosition.lineNumber, validatedViewPosition.column);
                viewLineNumber = r.lineNumber;
                viewColumn = r.column;
            }
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            cursor.moveViewPosition(inSelectionMode, viewLineNumber, viewColumn, 0, true);
            return true;
        };
        OneCursorOp.moveWordRight = function (cursor, inSelectionMode, wordNavigationType, ctx) {
            var position = cursor.getPosition();
            var lineNumber = position.lineNumber;
            var column = position.column;
            if (column === cursor.model.getLineMaxColumn(lineNumber)) {
                if (lineNumber < cursor.model.getLineCount()) {
                    lineNumber = lineNumber + 1;
                    column = 1;
                }
            }
            var nextWordOnLine = cursor.findNextWordOnLine(new position_1.Position(lineNumber, column));
            if (wordNavigationType === WordNavigationType.WordEnd) {
                if (nextWordOnLine) {
                    column = nextWordOnLine.end + 1;
                }
                else {
                    column = cursor.model.getLineMaxColumn(lineNumber);
                }
            }
            else {
                if (nextWordOnLine && column >= nextWordOnLine.start + 1) {
                    nextWordOnLine = cursor.findNextWordOnLine(new position_1.Position(lineNumber, nextWordOnLine.end + 1));
                }
                if (nextWordOnLine) {
                    column = nextWordOnLine.start + 1;
                }
                else {
                    column = cursor.model.getLineMaxColumn(lineNumber);
                }
            }
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            cursor.moveModelPosition(inSelectionMode, lineNumber, column, 0, true);
            return true;
        };
        OneCursorOp.moveDown = function (cursor, inSelectionMode, isPaged, usePageSize, ctx) {
            var linesCount = isPaged ? (usePageSize || cursor.getPageSize()) : 1;
            var viewLineNumber, viewColumn;
            if (cursor.hasSelection() && !inSelectionMode) {
                // If we are in selection mode, move down acts relative to the end of selection
                var viewSelection = cursor.getViewSelection();
                var viewSelectionEnd = cursor.validateViewPosition(viewSelection.endLineNumber, viewSelection.endColumn, cursor.getSelection().getEndPosition());
                viewLineNumber = viewSelectionEnd.lineNumber;
                viewColumn = viewSelectionEnd.column;
            }
            else {
                var validatedViewPosition = cursor.getValidViewPosition();
                viewLineNumber = validatedViewPosition.lineNumber;
                viewColumn = validatedViewPosition.column;
            }
            var r = cursor.getViewPositionDown(viewLineNumber, viewColumn, cursor.getLeftoverVisibleColumns(), linesCount, true);
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            cursor.moveViewPosition(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns, true);
            return true;
        };
        OneCursorOp.translateDown = function (cursor, ctx) {
            var selection = cursor.getViewSelection();
            var selectionStart = cursor.getViewPositionDown(selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.getSelectionStartLeftoverVisibleColumns(), 1, false);
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            cursor.moveViewPosition(false, selectionStart.lineNumber, selectionStart.column, cursor.getLeftoverVisibleColumns(), true);
            var position = cursor.getViewPositionDown(selection.positionLineNumber, selection.positionColumn, cursor.getLeftoverVisibleColumns(), 1, false);
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            cursor.moveViewPosition(true, position.lineNumber, position.column, position.leftoverVisibleColumns, true);
            cursor.setSelectionStartLeftoverVisibleColumns(selectionStart.leftoverVisibleColumns);
            return true;
        };
        OneCursorOp.moveUp = function (cursor, inSelectionMode, isPaged, usePageSize, ctx) {
            var linesCount = isPaged ? (usePageSize || cursor.getPageSize()) : 1;
            var viewLineNumber, viewColumn;
            if (cursor.hasSelection() && !inSelectionMode) {
                // If we are in selection mode, move up acts relative to the beginning of selection
                var viewSelection = cursor.getViewSelection();
                var viewSelectionStart = cursor.validateViewPosition(viewSelection.startLineNumber, viewSelection.startColumn, cursor.getSelection().getStartPosition());
                viewLineNumber = viewSelectionStart.lineNumber;
                viewColumn = viewSelectionStart.column;
            }
            else {
                var validatedViewPosition = cursor.getValidViewPosition();
                viewLineNumber = validatedViewPosition.lineNumber;
                viewColumn = validatedViewPosition.column;
            }
            var r = cursor.getViewPositionUp(viewLineNumber, viewColumn, cursor.getLeftoverVisibleColumns(), linesCount, true);
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            cursor.moveViewPosition(inSelectionMode, r.lineNumber, r.column, r.leftoverVisibleColumns, true);
            return true;
        };
        OneCursorOp.translateUp = function (cursor, ctx) {
            var selection = cursor.getViewSelection();
            var selectionStart = cursor.getViewPositionUp(selection.selectionStartLineNumber, selection.selectionStartColumn, cursor.getSelectionStartLeftoverVisibleColumns(), 1, false);
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            cursor.moveViewPosition(false, selectionStart.lineNumber, selectionStart.column, cursor.getLeftoverVisibleColumns(), true);
            var position = cursor.getViewPositionUp(selection.positionLineNumber, selection.positionColumn, cursor.getLeftoverVisibleColumns(), 1, false);
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            cursor.moveViewPosition(true, position.lineNumber, position.column, position.leftoverVisibleColumns, true);
            cursor.setSelectionStartLeftoverVisibleColumns(selectionStart.leftoverVisibleColumns);
            return true;
        };
        OneCursorOp.moveToBeginningOfLine = function (cursor, inSelectionMode, ctx) {
            var validatedViewPosition = cursor.getValidViewPosition();
            var viewLineNumber = validatedViewPosition.lineNumber;
            var viewColumn = validatedViewPosition.column;
            viewColumn = cursor.getColumnAtBeginningOfViewLine(viewLineNumber, viewColumn);
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            cursor.moveViewPosition(inSelectionMode, viewLineNumber, viewColumn, 0, true);
            return true;
        };
        OneCursorOp.moveToEndOfLine = function (cursor, inSelectionMode, ctx) {
            var validatedViewPosition = cursor.getValidViewPosition();
            var viewLineNumber = validatedViewPosition.lineNumber;
            var viewColumn = validatedViewPosition.column;
            viewColumn = cursor.getColumnAtEndOfViewLine(viewLineNumber, viewColumn);
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            cursor.moveViewPosition(inSelectionMode, viewLineNumber, viewColumn, 0, true);
            return true;
        };
        OneCursorOp.expandLineSelection = function (cursor, ctx) {
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            var viewSel = cursor.getViewSelection();
            var viewStartLineNumber = viewSel.startLineNumber;
            var viewStartColumn = viewSel.startColumn;
            var viewEndLineNumber = viewSel.endLineNumber;
            var viewEndColumn = viewSel.endColumn;
            var viewEndMaxColumn = cursor.getViewLineMaxColumn(viewEndLineNumber);
            if (viewStartColumn !== 1 || viewEndColumn !== viewEndMaxColumn) {
                viewStartColumn = 1;
                viewEndColumn = viewEndMaxColumn;
            }
            else {
                // Expand selection with one more line down
                var moveResult = cursor.getViewPositionDown(viewEndLineNumber, viewEndColumn, 0, 1, true);
                viewEndLineNumber = moveResult.lineNumber;
                viewEndColumn = cursor.getViewLineMaxColumn(viewEndLineNumber);
            }
            cursor.moveViewPosition(false, viewStartLineNumber, viewStartColumn, 0, true);
            cursor.moveViewPosition(true, viewEndLineNumber, viewEndColumn, 0, true);
            return true;
        };
        OneCursorOp.moveToBeginningOfBuffer = function (cursor, inSelectionMode, ctx) {
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            cursor.moveModelPosition(inSelectionMode, 1, 1, 0, true);
            return true;
        };
        OneCursorOp.moveToEndOfBuffer = function (cursor, inSelectionMode, ctx) {
            var lastLineNumber = cursor.model.getLineCount();
            var lastColumn = cursor.model.getLineMaxColumn(lastLineNumber);
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            cursor.moveModelPosition(inSelectionMode, lastLineNumber, lastColumn, 0, true);
            return true;
        };
        OneCursorOp.selectAll = function (cursor, ctx) {
            var selectEntireBuffer = true;
            var newSelectionStartLineNumber, newSelectionStartColumn, newPositionLineNumber, newPositionColumn;
            if (cursor.model.hasEditableRange()) {
                // Toggle between selecting editable range and selecting the entire buffer
                var editableRange = cursor.model.getEditableRange();
                var selection = cursor.getSelection();
                if (!selection.equalsRange(editableRange)) {
                    // Selection is not editable range => select editable range
                    selectEntireBuffer = false;
                    newSelectionStartLineNumber = editableRange.startLineNumber;
                    newSelectionStartColumn = editableRange.startColumn;
                    newPositionLineNumber = editableRange.endLineNumber;
                    newPositionColumn = editableRange.endColumn;
                }
            }
            if (selectEntireBuffer) {
                newSelectionStartLineNumber = 1;
                newSelectionStartColumn = 1;
                newPositionLineNumber = cursor.model.getLineCount();
                newPositionColumn = cursor.model.getLineMaxColumn(newPositionLineNumber);
            }
            cursor.moveModelPosition(false, newSelectionStartLineNumber, newSelectionStartColumn, 0, false);
            cursor.moveModelPosition(true, newPositionLineNumber, newPositionColumn, 0, false);
            ctx.shouldReveal = false;
            ctx.shouldRevealHorizontal = false;
            return true;
        };
        OneCursorOp.line = function (cursor, inSelectionMode, _position, _viewPosition, ctx) {
            // TODO@Alex -> select in editable range
            var position = cursor.validatePosition(_position);
            var viewPosition = (_viewPosition ?
                cursor.validateViewPosition(_viewPosition.lineNumber, _viewPosition.column, position)
                : cursor.convertModelPositionToViewPosition(position.lineNumber, position.column));
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            ctx.shouldRevealHorizontal = false;
            if (!inSelectionMode || !cursor.hasSelection()) {
                // Entering line selection for the first time
                var selectToLineNumber = position.lineNumber + 1;
                var selectToColumn = 1;
                if (selectToLineNumber > cursor.model.getLineCount()) {
                    selectToLineNumber = cursor.model.getLineCount();
                    selectToColumn = cursor.model.getLineMaxColumn(selectToLineNumber);
                }
                var selectionStartRange = new range_1.Range(position.lineNumber, 1, selectToLineNumber, selectToColumn);
                var r1 = cursor.convertModelPositionToViewPosition(position.lineNumber, 1);
                var r2 = cursor.convertModelPositionToViewPosition(selectToLineNumber, selectToColumn);
                cursor.setSelectionStart(selectionStartRange, new range_1.Range(r1.lineNumber, r1.column, r2.lineNumber, r2.column));
                cursor.moveModelPosition(cursor.hasSelection(), selectionStartRange.endLineNumber, selectionStartRange.endColumn, 0, false);
                return true;
            }
            else {
                // Continuing line selection
                var enteringLineNumber = cursor.getSelectionStart().getStartPosition().lineNumber;
                if (position.lineNumber < enteringLineNumber) {
                    cursor.moveViewPosition(cursor.hasSelection(), viewPosition.lineNumber, 1, 0, false);
                }
                else if (position.lineNumber > enteringLineNumber) {
                    var selectToViewLineNumber = viewPosition.lineNumber + 1;
                    var selectToViewColumn = 1;
                    if (selectToViewLineNumber > cursor.getViewLineCount()) {
                        selectToViewLineNumber = cursor.getViewLineCount();
                        selectToViewColumn = cursor.getViewLineMaxColumn(selectToViewLineNumber);
                    }
                    cursor.moveViewPosition(cursor.hasSelection(), selectToViewLineNumber, selectToViewColumn, 0, false);
                }
                else {
                    var endPositionOfSelectionStart = cursor.getSelectionStart().getEndPosition();
                    cursor.moveModelPosition(cursor.hasSelection(), endPositionOfSelectionStart.lineNumber, endPositionOfSelectionStart.column, 0, false);
                }
                return true;
            }
        };
        OneCursorOp.word = function (cursor, inSelectionMode, position, ctx) {
            // TODO@Alex -> select in editable range
            var validatedPosition = cursor.validatePosition(position);
            var prevWord = cursor.findPreviousWordOnLine(validatedPosition);
            var isInPrevWord = (prevWord && prevWord.wordType === WordType.Regular && prevWord.start < validatedPosition.column - 1 && validatedPosition.column - 1 <= prevWord.end);
            var nextWord = cursor.findNextWordOnLine(validatedPosition);
            var isInNextWord = (nextWord && nextWord.wordType === WordType.Regular && nextWord.start < validatedPosition.column - 1 && validatedPosition.column - 1 <= nextWord.end);
            var lineNumber;
            var column;
            if (!inSelectionMode || !cursor.hasSelection()) {
                var startColumn = void 0;
                var endColumn = void 0;
                if (isInPrevWord) {
                    startColumn = prevWord.start + 1;
                    endColumn = prevWord.end + 1;
                }
                else if (isInNextWord) {
                    startColumn = nextWord.start + 1;
                    endColumn = nextWord.end + 1;
                }
                else {
                    if (prevWord) {
                        startColumn = prevWord.end + 1;
                    }
                    else {
                        startColumn = 1;
                    }
                    if (nextWord) {
                        endColumn = nextWord.start + 1;
                    }
                    else {
                        endColumn = cursor.model.getLineMaxColumn(validatedPosition.lineNumber);
                    }
                }
                var selectionStartRange = new range_1.Range(validatedPosition.lineNumber, startColumn, validatedPosition.lineNumber, endColumn);
                var r1 = cursor.convertModelPositionToViewPosition(validatedPosition.lineNumber, startColumn);
                var r2 = cursor.convertModelPositionToViewPosition(validatedPosition.lineNumber, endColumn);
                cursor.setSelectionStart(selectionStartRange, new range_1.Range(r1.lineNumber, r1.column, r2.lineNumber, r2.column));
                lineNumber = selectionStartRange.endLineNumber;
                column = selectionStartRange.endColumn;
            }
            else {
                var startColumn = void 0;
                var endColumn = void 0;
                if (isInPrevWord) {
                    startColumn = prevWord.start + 1;
                    endColumn = prevWord.end + 1;
                }
                else if (isInNextWord) {
                    startColumn = nextWord.start + 1;
                    endColumn = nextWord.end + 1;
                }
                else {
                    startColumn = validatedPosition.column;
                    endColumn = validatedPosition.column;
                }
                lineNumber = validatedPosition.lineNumber;
                if (validatedPosition.isBeforeOrEqual(cursor.getSelectionStart().getStartPosition())) {
                    column = startColumn;
                    var possiblePosition = new position_1.Position(lineNumber, column);
                    if (cursor.getSelectionStart().containsPosition(possiblePosition)) {
                        column = cursor.getSelectionStart().endColumn;
                    }
                }
                else {
                    column = endColumn;
                    var possiblePosition = new position_1.Position(lineNumber, column);
                    if (cursor.getSelectionStart().containsPosition(possiblePosition)) {
                        column = cursor.getSelectionStart().startColumn;
                    }
                }
            }
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Explicit;
            cursor.moveModelPosition(cursor.hasSelection(), lineNumber, column, 0, false);
            return true;
        };
        OneCursorOp.cancelSelection = function (cursor, ctx) {
            if (!cursor.hasSelection()) {
                return false;
            }
            cursor.collapseSelection();
            return true;
        };
        // -------------------- STOP handlers that simply change cursor state
        // -------------------- START type interceptors & co.
        OneCursorOp._typeInterceptorEnter = function (cursor, ch, ctx) {
            if (ch !== '\n') {
                return false;
            }
            return this._enter(cursor, false, ctx);
        };
        OneCursorOp.lineInsertBefore = function (cursor, ctx) {
            var lineNumber = cursor.getPosition().lineNumber;
            if (lineNumber === 1) {
                ctx.executeCommand = new replaceCommand_1.ReplaceCommandWithoutChangingPosition(new range_1.Range(1, 1, 1, 1), '\n');
                return true;
            }
            lineNumber--;
            var column = cursor.model.getLineMaxColumn(lineNumber);
            return this._enter(cursor, false, ctx, new position_1.Position(lineNumber, column), new range_1.Range(lineNumber, column, lineNumber, column));
        };
        OneCursorOp.lineInsertAfter = function (cursor, ctx) {
            var position = cursor.getPosition();
            var column = cursor.model.getLineMaxColumn(position.lineNumber);
            return this._enter(cursor, false, ctx, new position_1.Position(position.lineNumber, column), new range_1.Range(position.lineNumber, column, position.lineNumber, column));
        };
        OneCursorOp.lineBreakInsert = function (cursor, ctx) {
            return this._enter(cursor, true, ctx);
        };
        OneCursorOp._enter = function (cursor, keepPosition, ctx, position, range) {
            if (typeof position === 'undefined') {
                position = cursor.getPosition();
            }
            if (typeof range === 'undefined') {
                range = cursor.getSelection();
            }
            ctx.shouldPushStackElementBefore = true;
            var r = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getEnterActionAtPosition(cursor.model, position.lineNumber, position.column);
            var enterAction = r.enterAction;
            var indentation = r.indentation;
            ctx.isAutoWhitespaceCommand = true;
            if (enterAction.indentAction === modes_1.IndentAction.None) {
                // Nothing special
                this.actualType(cursor, '\n' + cursor.model.normalizeIndentation(indentation + enterAction.appendText), keepPosition, ctx, range);
            }
            else if (enterAction.indentAction === modes_1.IndentAction.Indent) {
                // Indent once
                this.actualType(cursor, '\n' + cursor.model.normalizeIndentation(indentation + enterAction.appendText), keepPosition, ctx, range);
            }
            else if (enterAction.indentAction === modes_1.IndentAction.IndentOutdent) {
                // Ultra special
                var normalIndent = cursor.model.normalizeIndentation(indentation);
                var increasedIndent = cursor.model.normalizeIndentation(indentation + enterAction.appendText);
                var typeText = '\n' + increasedIndent + '\n' + normalIndent;
                if (keepPosition) {
                    ctx.executeCommand = new replaceCommand_1.ReplaceCommandWithoutChangingPosition(range, typeText);
                }
                else {
                    ctx.executeCommand = new replaceCommand_1.ReplaceCommandWithOffsetCursorState(range, typeText, -1, increasedIndent.length - normalIndent.length);
                }
            }
            else if (enterAction.indentAction === modes_1.IndentAction.Outdent) {
                var desiredIndentCount = shiftCommand_1.ShiftCommand.unshiftIndentCount(indentation, indentation.length + 1, cursor.model.getOptions().tabSize);
                var actualIndentation = '';
                for (var i = 0; i < desiredIndentCount; i++) {
                    actualIndentation += '\t';
                }
                this.actualType(cursor, '\n' + cursor.model.normalizeIndentation(actualIndentation + enterAction.appendText), keepPosition, ctx, range);
            }
            return true;
        };
        OneCursorOp._typeInterceptorAutoClosingCloseChar = function (cursor, ch, ctx) {
            if (!cursor.configuration.editor.autoClosingBrackets) {
                return false;
            }
            var selection = cursor.getSelection();
            if (!selection.isEmpty() || !cursor.modeConfiguration.autoClosingPairsClose.hasOwnProperty(ch)) {
                return false;
            }
            var position = cursor.getPosition();
            var lineText = cursor.model.getLineContent(position.lineNumber);
            var beforeCharacter = lineText[position.column - 1];
            if (beforeCharacter !== ch) {
                return false;
            }
            var typeSelection = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column + 1);
            ctx.executeCommand = new replaceCommand_1.ReplaceCommand(typeSelection, ch);
            return true;
        };
        OneCursorOp._typeInterceptorAutoClosingOpenChar = function (cursor, ch, ctx) {
            if (!cursor.configuration.editor.autoClosingBrackets) {
                return false;
            }
            var selection = cursor.getSelection();
            if (!selection.isEmpty() || !cursor.modeConfiguration.autoClosingPairsOpen.hasOwnProperty(ch)) {
                return false;
            }
            var characterPairSupport = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getCharacterPairSupport(cursor.model.getMode().getId());
            if (!characterPairSupport) {
                return false;
            }
            var position = cursor.getPosition();
            var lineText = cursor.model.getLineContent(position.lineNumber);
            var beforeCharacter = lineText[position.column - 1];
            // Only consider auto closing the pair if a space follows or if another autoclosed pair follows
            if (beforeCharacter) {
                var isBeforeCloseBrace = false;
                for (var closeBrace in cursor.modeConfiguration.autoClosingPairsClose) {
                    if (beforeCharacter === closeBrace) {
                        isBeforeCloseBrace = true;
                        break;
                    }
                }
                if (!isBeforeCloseBrace && !/\s/.test(beforeCharacter)) {
                    return false;
                }
            }
            var lineContext = cursor.model.getLineContext(position.lineNumber);
            var shouldAutoClosePair = false;
            try {
                shouldAutoClosePair = characterPairSupport.shouldAutoClosePair(ch, lineContext, position.column - 1);
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
            }
            if (!shouldAutoClosePair) {
                return false;
            }
            ctx.shouldPushStackElementBefore = true;
            var closeCharacter = cursor.modeConfiguration.autoClosingPairsOpen[ch];
            ctx.executeCommand = new replaceCommand_1.ReplaceCommandWithOffsetCursorState(selection, ch + closeCharacter, 0, -closeCharacter.length);
            return true;
        };
        OneCursorOp._typeInterceptorSurroundSelection = function (cursor, ch, ctx) {
            if (!cursor.configuration.editor.autoClosingBrackets) {
                return false;
            }
            var selection = cursor.getSelection();
            if (selection.isEmpty() || !cursor.modeConfiguration.surroundingPairs.hasOwnProperty(ch)) {
                return false;
            }
            var selectionContainsOnlyWhitespace = true, lineNumber, startIndex, endIndex, charIndex, charCode, lineText, _tab = '\t'.charCodeAt(0), _space = ' '.charCodeAt(0);
            for (lineNumber = selection.startLineNumber; lineNumber <= selection.endLineNumber; lineNumber++) {
                lineText = cursor.model.getLineContent(lineNumber);
                startIndex = (lineNumber === selection.startLineNumber ? selection.startColumn - 1 : 0);
                endIndex = (lineNumber === selection.endLineNumber ? selection.endColumn - 1 : lineText.length);
                for (charIndex = startIndex; charIndex < endIndex; charIndex++) {
                    charCode = lineText.charCodeAt(charIndex);
                    if (charCode !== _tab && charCode !== _space) {
                        selectionContainsOnlyWhitespace = false;
                        // Break outer loop
                        lineNumber = selection.endLineNumber + 1;
                        // Break inner loop
                        charIndex = endIndex;
                    }
                }
            }
            if (selectionContainsOnlyWhitespace) {
                return false;
            }
            var closeCharacter = cursor.modeConfiguration.surroundingPairs[ch];
            ctx.shouldPushStackElementBefore = true;
            ctx.shouldPushStackElementAfter = true;
            ctx.executeCommand = new surroundSelectionCommand_1.SurroundSelectionCommand(selection, ch, closeCharacter);
            return true;
        };
        OneCursorOp._typeInterceptorElectricChar = function (cursor, ch, ctx) {
            var _this = this;
            if (!cursor.modeConfiguration.electricChars.hasOwnProperty(ch)) {
                return false;
            }
            ctx.postOperationRunnable = function (postOperationCtx) { return _this._typeInterceptorElectricCharRunnable(cursor, postOperationCtx); };
            return this.actualType(cursor, ch, false, ctx);
        };
        OneCursorOp._typeInterceptorElectricCharRunnable = function (cursor, ctx) {
            var position = cursor.getPosition();
            var lineText = cursor.model.getLineContent(position.lineNumber);
            var lineContext = cursor.model.getLineContext(position.lineNumber);
            var electricAction;
            var electricCharSupport = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getElectricCharacterSupport(cursor.model.getMode().getId());
            if (electricCharSupport) {
                try {
                    electricAction = electricCharSupport.onElectricCharacter(lineContext, position.column - 2);
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                }
            }
            if (electricAction) {
                var matchOpenBracket = electricAction.matchOpenBracket;
                var appendText = electricAction.appendText;
                if (matchOpenBracket) {
                    var match = cursor.model.findMatchingBracketUp(matchOpenBracket, {
                        lineNumber: position.lineNumber,
                        column: position.column - matchOpenBracket.length
                    });
                    if (match) {
                        var matchLineNumber = match.startLineNumber;
                        var matchLine = cursor.model.getLineContent(matchLineNumber);
                        var matchLineIndentation = strings.getLeadingWhitespace(matchLine);
                        var newIndentation = cursor.model.normalizeIndentation(matchLineIndentation);
                        var lineFirstNonBlankColumn = cursor.model.getLineFirstNonWhitespaceColumn(position.lineNumber) || position.column;
                        var oldIndentation = lineText.substring(0, lineFirstNonBlankColumn - 1);
                        if (oldIndentation !== newIndentation) {
                            var prefix = lineText.substring(lineFirstNonBlankColumn - 1, position.column - 1);
                            var typeText = newIndentation + prefix;
                            var typeSelection = new range_1.Range(position.lineNumber, 1, position.lineNumber, position.column);
                            ctx.shouldPushStackElementAfter = true;
                            ctx.executeCommand = new replaceCommand_1.ReplaceCommand(typeSelection, typeText);
                        }
                    }
                }
                else if (appendText) {
                    var columnDeltaOffset = -appendText.length;
                    if (electricAction.advanceCount) {
                        columnDeltaOffset += electricAction.advanceCount;
                    }
                    ctx.shouldPushStackElementAfter = true;
                    ctx.executeCommand = new replaceCommand_1.ReplaceCommandWithOffsetCursorState(cursor.getSelection(), appendText, 0, columnDeltaOffset);
                }
            }
        };
        OneCursorOp.actualType = function (cursor, text, keepPosition, ctx, range) {
            if (typeof range === 'undefined') {
                range = cursor.getSelection();
            }
            if (keepPosition) {
                ctx.executeCommand = new replaceCommand_1.ReplaceCommandWithoutChangingPosition(range, text);
            }
            else {
                ctx.executeCommand = new replaceCommand_1.ReplaceCommand(range, text);
            }
            return true;
        };
        OneCursorOp.type = function (cursor, ch, ctx) {
            if (this._typeInterceptorEnter(cursor, ch, ctx)) {
                return true;
            }
            if (this._typeInterceptorAutoClosingCloseChar(cursor, ch, ctx)) {
                return true;
            }
            if (this._typeInterceptorAutoClosingOpenChar(cursor, ch, ctx)) {
                return true;
            }
            if (this._typeInterceptorSurroundSelection(cursor, ch, ctx)) {
                return true;
            }
            if (this._typeInterceptorElectricChar(cursor, ch, ctx)) {
                return true;
            }
            return this.actualType(cursor, ch, false, ctx);
        };
        OneCursorOp.replacePreviousChar = function (cursor, txt, replaceCharCnt, ctx) {
            var pos = cursor.getPosition();
            var range;
            var startColumn = Math.max(1, pos.column - replaceCharCnt);
            range = new range_1.Range(pos.lineNumber, startColumn, pos.lineNumber, pos.column);
            ctx.executeCommand = new replaceCommand_1.ReplaceCommand(range, txt);
            return true;
        };
        OneCursorOp._goodIndentForLine = function (cursor, lineNumber) {
            var lastLineNumber = lineNumber - 1;
            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {
                var lineText = cursor.model.getLineContent(lastLineNumber);
                var nonWhitespaceIdx = strings.lastNonWhitespaceIndex(lineText);
                if (nonWhitespaceIdx >= 0) {
                    break;
                }
            }
            if (lastLineNumber < 1) {
                // No previous line with content found
                return '\t';
            }
            var r = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getEnterActionAtPosition(cursor.model, lastLineNumber, cursor.model.getLineMaxColumn(lastLineNumber));
            var indentation;
            if (r.enterAction.indentAction === modes_1.IndentAction.Outdent) {
                var modelOpts = cursor.model.getOptions();
                var desiredIndentCount = shiftCommand_1.ShiftCommand.unshiftIndentCount(r.indentation, r.indentation.length, modelOpts.tabSize);
                indentation = '';
                for (var i = 0; i < desiredIndentCount; i++) {
                    indentation += '\t';
                }
                indentation = cursor.model.normalizeIndentation(indentation);
            }
            else {
                indentation = r.indentation;
            }
            var result = indentation + r.enterAction.appendText;
            if (result.length === 0) {
                // good position is at column 1, but we gotta do something...
                return '\t';
            }
            return result;
        };
        OneCursorOp.tab = function (cursor, ctx) {
            var selection = cursor.getSelection();
            if (selection.isEmpty()) {
                ctx.isAutoWhitespaceCommand = true;
                var typeText = '';
                if (cursor.model.getLineMaxColumn(selection.startLineNumber) === 1) {
                    // Line is empty => indent straight to the right place
                    typeText = cursor.model.normalizeIndentation(this._goodIndentForLine(cursor, selection.startLineNumber));
                }
                else {
                    var position = cursor.getPosition();
                    var modelOpts = cursor.model.getOptions();
                    if (modelOpts.insertSpaces) {
                        var visibleColumnFromColumn = cursor.getVisibleColumnFromColumn(position.lineNumber, position.column);
                        var tabSize = modelOpts.tabSize;
                        var spacesCnt = tabSize - (visibleColumnFromColumn % tabSize);
                        for (var i = 0; i < spacesCnt; i++) {
                            typeText += ' ';
                        }
                    }
                    else {
                        typeText = '\t';
                    }
                }
                ctx.executeCommand = new replaceCommand_1.ReplaceCommand(selection, typeText);
                return true;
            }
            else {
                if (selection.startLineNumber === selection.endLineNumber) {
                    var lineMaxColumn = cursor.model.getLineMaxColumn(selection.startLineNumber);
                    if (selection.startColumn !== 1 || selection.endColumn !== lineMaxColumn) {
                        // This is a single line selection that is not the entire line
                        ctx.executeCommand = new replaceCommand_1.ReplaceCommand(selection, '\t');
                        return true;
                    }
                }
                return this.indent(cursor, ctx);
            }
        };
        OneCursorOp.indent = function (cursor, ctx) {
            var selection = cursor.getSelection();
            ctx.shouldPushStackElementBefore = true;
            ctx.shouldPushStackElementAfter = true;
            ctx.executeCommand = new shiftCommand_1.ShiftCommand(selection, {
                isUnshift: false,
                tabSize: cursor.model.getOptions().tabSize,
                oneIndent: cursor.model.getOneIndent()
            });
            ctx.shouldRevealHorizontal = false;
            return true;
        };
        OneCursorOp.outdent = function (cursor, ctx) {
            var selection = cursor.getSelection();
            ctx.shouldPushStackElementBefore = true;
            ctx.shouldPushStackElementAfter = true;
            ctx.executeCommand = new shiftCommand_1.ShiftCommand(selection, {
                isUnshift: true,
                tabSize: cursor.model.getOptions().tabSize,
                oneIndent: cursor.model.getOneIndent()
            });
            ctx.shouldRevealHorizontal = false;
            return true;
        };
        OneCursorOp.paste = function (cursor, text, pasteOnNewLine, ctx) {
            var position = cursor.getPosition();
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Paste;
            if (pasteOnNewLine && text.charAt(text.length - 1) === '\n') {
                if (text.indexOf('\n') === text.length - 1) {
                    // Paste entire line at the beginning of line
                    var typeSelection = new range_1.Range(position.lineNumber, 1, position.lineNumber, 1);
                    ctx.executeCommand = new replaceCommand_1.ReplaceCommand(typeSelection, text);
                    return true;
                }
            }
            ctx.executeCommand = new replaceCommand_1.ReplaceCommand(cursor.getSelection(), text);
            return true;
        };
        // -------------------- END type interceptors & co.
        // -------------------- START delete handlers & co.
        OneCursorOp._autoClosingPairDelete = function (cursor, ctx) {
            // Returns true if delete was handled.
            if (!cursor.configuration.editor.autoClosingBrackets) {
                return false;
            }
            if (!cursor.getSelection().isEmpty()) {
                return false;
            }
            var position = cursor.getPosition();
            var lineText = cursor.model.getLineContent(position.lineNumber);
            var character = lineText[position.column - 2];
            if (!cursor.modeConfiguration.autoClosingPairsOpen.hasOwnProperty(character)) {
                return false;
            }
            var afterCharacter = lineText[position.column - 1];
            var closeCharacter = cursor.modeConfiguration.autoClosingPairsOpen[character];
            if (afterCharacter !== closeCharacter) {
                return false;
            }
            var deleteSelection = new range_1.Range(position.lineNumber, position.column - 1, position.lineNumber, position.column + 1);
            ctx.executeCommand = new replaceCommand_1.ReplaceCommand(deleteSelection, '');
            return true;
        };
        OneCursorOp.deleteLeft = function (cursor, ctx) {
            if (this._autoClosingPairDelete(cursor, ctx)) {
                // This was a case for an auto-closing pair delete
                return true;
            }
            var deleteSelection = cursor.getSelection();
            if (deleteSelection.isEmpty()) {
                var position = cursor.getPosition();
                if (cursor.configuration.editor.useTabStops && position.column > 1) {
                    var lineContent = cursor.getLineContent(position.lineNumber);
                    var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);
                    var lastIndentationColumn = (firstNonWhitespaceIndex === -1
                        ? lineContent.length + 1
                        : firstNonWhitespaceIndex + 1);
                    if (position.column <= lastIndentationColumn) {
                        var fromVisibleColumn = cursor.getVisibleColumnFromColumn(position.lineNumber, position.column);
                        var toVisibleColumn = cursorMoveHelper_1.CursorMoveHelper.prevTabColumn(fromVisibleColumn, cursor.model.getOptions().tabSize);
                        var toColumn = cursor.getColumnFromVisibleColumn(position.lineNumber, toVisibleColumn);
                        deleteSelection = new range_1.Range(position.lineNumber, toColumn, position.lineNumber, position.column);
                    }
                    else {
                        deleteSelection = new range_1.Range(position.lineNumber, position.column - 1, position.lineNumber, position.column);
                    }
                }
                else {
                    var leftOfPosition = cursor.getLeftOfPosition(position.lineNumber, position.column);
                    deleteSelection = new range_1.Range(leftOfPosition.lineNumber, leftOfPosition.column, position.lineNumber, position.column);
                }
            }
            if (deleteSelection.isEmpty()) {
                // Probably at beginning of file => ignore
                return true;
            }
            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {
                ctx.shouldPushStackElementBefore = true;
            }
            ctx.executeCommand = new replaceCommand_1.ReplaceCommand(deleteSelection, '');
            return true;
        };
        OneCursorOp.deleteWordLeftWhitespace = function (cursor, ctx) {
            var position = cursor.getPosition();
            var lineContent = cursor.getLineContent(position.lineNumber);
            var startIndex = position.column - 2;
            var lastNonWhitespace = strings.lastNonWhitespaceIndex(lineContent, startIndex);
            if (lastNonWhitespace + 1 < startIndex) {
                // bingo
                ctx.executeCommand = new replaceCommand_1.ReplaceCommand(new range_1.Range(position.lineNumber, lastNonWhitespace + 2, position.lineNumber, position.column), '');
                return true;
            }
            return false;
        };
        OneCursorOp.deleteWordLeft = function (cursor, whitespaceHeuristics, wordNavigationType, ctx) {
            if (this._autoClosingPairDelete(cursor, ctx)) {
                // This was a case for an auto-closing pair delete
                return true;
            }
            var selection = cursor.getSelection();
            if (selection.isEmpty()) {
                var position = cursor.getPosition();
                var lineNumber = position.lineNumber;
                var column = position.column;
                if (lineNumber === 1 && column === 1) {
                    // Ignore deleting at beginning of file
                    return true;
                }
                if (whitespaceHeuristics && this.deleteWordLeftWhitespace(cursor, ctx)) {
                    return true;
                }
                var prevWordOnLine = cursor.findPreviousWordOnLine(position);
                if (wordNavigationType === WordNavigationType.WordStart) {
                    if (prevWordOnLine) {
                        column = prevWordOnLine.start + 1;
                    }
                    else {
                        column = 1;
                    }
                }
                else {
                    if (prevWordOnLine && column <= prevWordOnLine.end + 1) {
                        prevWordOnLine = cursor.findPreviousWordOnLine(new position_1.Position(lineNumber, prevWordOnLine.start + 1));
                    }
                    if (prevWordOnLine) {
                        column = prevWordOnLine.end + 1;
                    }
                    else {
                        column = 1;
                    }
                }
                var deleteSelection = new range_1.Range(lineNumber, column, lineNumber, position.column);
                if (!deleteSelection.isEmpty()) {
                    ctx.executeCommand = new replaceCommand_1.ReplaceCommand(deleteSelection, '');
                    return true;
                }
            }
            return this.deleteLeft(cursor, ctx);
        };
        OneCursorOp.deleteRight = function (cursor, ctx) {
            var deleteSelection = cursor.getSelection();
            if (deleteSelection.isEmpty()) {
                var position = cursor.getPosition();
                var rightOfPosition = cursor.getRightOfPosition(position.lineNumber, position.column);
                deleteSelection = new range_1.Range(rightOfPosition.lineNumber, rightOfPosition.column, position.lineNumber, position.column);
            }
            if (deleteSelection.isEmpty()) {
                // Probably at end of file => ignore
                return true;
            }
            if (deleteSelection.startLineNumber !== deleteSelection.endLineNumber) {
                ctx.shouldPushStackElementBefore = true;
            }
            ctx.executeCommand = new replaceCommand_1.ReplaceCommand(deleteSelection, '');
            return true;
        };
        OneCursorOp._findFirstNonWhitespaceChar = function (str, startIndex) {
            var len = str.length;
            for (var chIndex = startIndex; chIndex < len; chIndex++) {
                var ch = str.charAt(chIndex);
                if (ch !== ' ' && ch !== '\t') {
                    return chIndex;
                }
            }
            return len;
        };
        OneCursorOp.deleteWordRightWhitespace = function (cursor, ctx) {
            var position = cursor.getPosition();
            var lineContent = cursor.getLineContent(position.lineNumber);
            var startIndex = position.column - 1;
            var firstNonWhitespace = this._findFirstNonWhitespaceChar(lineContent, startIndex);
            if (startIndex + 1 < firstNonWhitespace) {
                // bingo
                ctx.executeCommand = new replaceCommand_1.ReplaceCommand(new range_1.Range(position.lineNumber, position.column, position.lineNumber, firstNonWhitespace + 1), '');
                return true;
            }
            return false;
        };
        OneCursorOp.deleteWordRight = function (cursor, whitespaceHeuristics, wordNavigationType, ctx) {
            var selection = cursor.getSelection();
            if (selection.isEmpty()) {
                var position = cursor.getPosition();
                var lineNumber = position.lineNumber;
                var column = position.column;
                var lineCount = cursor.model.getLineCount();
                var maxColumn = cursor.model.getLineMaxColumn(lineNumber);
                if (lineNumber === lineCount && column === maxColumn) {
                    // Ignore deleting at end of file
                    return true;
                }
                if (whitespaceHeuristics && this.deleteWordRightWhitespace(cursor, ctx)) {
                    return true;
                }
                var nextWordOnLine = cursor.findNextWordOnLine(position);
                if (wordNavigationType === WordNavigationType.WordEnd) {
                    if (nextWordOnLine) {
                        column = nextWordOnLine.end + 1;
                    }
                    else {
                        if (column < maxColumn || lineNumber === lineCount) {
                            column = maxColumn;
                        }
                        else {
                            lineNumber++;
                            nextWordOnLine = cursor.findNextWordOnLine(new position_1.Position(lineNumber, 1));
                            if (nextWordOnLine) {
                                column = nextWordOnLine.start + 1;
                            }
                            else {
                                column = cursor.model.getLineMaxColumn(lineNumber);
                            }
                        }
                    }
                }
                else {
                    if (nextWordOnLine && column >= nextWordOnLine.start + 1) {
                        nextWordOnLine = cursor.findNextWordOnLine(new position_1.Position(lineNumber, nextWordOnLine.end + 1));
                    }
                    if (nextWordOnLine) {
                        column = nextWordOnLine.start + 1;
                    }
                    else {
                        if (column < maxColumn || lineNumber === lineCount) {
                            column = maxColumn;
                        }
                        else {
                            lineNumber++;
                            nextWordOnLine = cursor.findNextWordOnLine(new position_1.Position(lineNumber, 1));
                            if (nextWordOnLine) {
                                column = nextWordOnLine.start + 1;
                            }
                            else {
                                column = cursor.model.getLineMaxColumn(lineNumber);
                            }
                        }
                    }
                }
                var deleteSelection = new range_1.Range(lineNumber, column, position.lineNumber, position.column);
                if (!deleteSelection.isEmpty()) {
                    ctx.executeCommand = new replaceCommand_1.ReplaceCommand(deleteSelection, '');
                    return true;
                }
            }
            // fall back to normal deleteRight behavior
            return this.deleteRight(cursor, ctx);
        };
        OneCursorOp.deleteAllLeft = function (cursor, ctx) {
            if (this._autoClosingPairDelete(cursor, ctx)) {
                // This was a case for an auto-closing pair delete
                return true;
            }
            var selection = cursor.getSelection();
            if (selection.isEmpty()) {
                var position = cursor.getPosition();
                var lineNumber = position.lineNumber;
                var column = position.column;
                if (column === 1) {
                    // Ignore deleting at beginning of line
                    return true;
                }
                var deleteSelection = new range_1.Range(lineNumber, 1, lineNumber, column);
                if (!deleteSelection.isEmpty()) {
                    ctx.executeCommand = new replaceCommand_1.ReplaceCommand(deleteSelection, '');
                    return true;
                }
            }
            return this.deleteLeft(cursor, ctx);
        };
        OneCursorOp.deleteAllRight = function (cursor, ctx) {
            var selection = cursor.getSelection();
            if (selection.isEmpty()) {
                var position = cursor.getPosition();
                var lineNumber = position.lineNumber;
                var column = position.column;
                var maxColumn = cursor.model.getLineMaxColumn(lineNumber);
                if (column === maxColumn) {
                    // Ignore deleting at end of file
                    return true;
                }
                var deleteSelection = new range_1.Range(lineNumber, column, lineNumber, maxColumn);
                if (!deleteSelection.isEmpty()) {
                    ctx.executeCommand = new replaceCommand_1.ReplaceCommand(deleteSelection, '');
                    return true;
                }
            }
            return this.deleteRight(cursor, ctx);
        };
        OneCursorOp.cut = function (cursor, enableEmptySelectionClipboard, ctx) {
            var selection = cursor.getSelection();
            if (selection.isEmpty()) {
                if (enableEmptySelectionClipboard) {
                    // This is a full line cut
                    var position = cursor.getPosition();
                    var startLineNumber = void 0, startColumn = void 0, endLineNumber = void 0, endColumn = void 0;
                    if (position.lineNumber < cursor.model.getLineCount()) {
                        // Cutting a line in the middle of the model
                        startLineNumber = position.lineNumber;
                        startColumn = 1;
                        endLineNumber = position.lineNumber + 1;
                        endColumn = 1;
                    }
                    else if (position.lineNumber > 1) {
                        // Cutting the last line & there are more than 1 lines in the model
                        startLineNumber = position.lineNumber - 1;
                        startColumn = cursor.model.getLineMaxColumn(position.lineNumber - 1);
                        endLineNumber = position.lineNumber;
                        endColumn = cursor.model.getLineMaxColumn(position.lineNumber);
                    }
                    else {
                        // Cutting the single line that the model contains
                        startLineNumber = position.lineNumber;
                        startColumn = 1;
                        endLineNumber = position.lineNumber;
                        endColumn = cursor.model.getLineMaxColumn(position.lineNumber);
                    }
                    var deleteSelection = new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn);
                    if (!deleteSelection.isEmpty()) {
                        ctx.executeCommand = new replaceCommand_1.ReplaceCommand(deleteSelection, '');
                    }
                }
                else {
                    // Cannot cut empty selection
                    return false;
                }
            }
            else {
                // Delete left or right, they will both result in the selection being deleted
                this.deleteRight(cursor, ctx);
            }
            return true;
        };
        return OneCursorOp;
    }());
    exports.OneCursorOp = OneCursorOp;
    var CursorHelper = (function () {
        function CursorHelper(model, configuration) {
            var _this = this;
            this.model = model;
            this.configuration = configuration;
            this.moveHelper = new cursorMoveHelper_1.CursorMoveHelper({
                getIndentationOptions: function () {
                    return _this.model.getOptions();
                }
            });
        }
        CursorHelper.prototype.getLeftOfPosition = function (model, lineNumber, column) {
            return this.moveHelper.getLeftOfPosition(model, lineNumber, column);
        };
        CursorHelper.prototype.getRightOfPosition = function (model, lineNumber, column) {
            return this.moveHelper.getRightOfPosition(model, lineNumber, column);
        };
        CursorHelper.prototype.getPositionUp = function (model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine) {
            return this.moveHelper.getPositionUp(model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnFirstLine);
        };
        CursorHelper.prototype.getPositionDown = function (model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine) {
            return this.moveHelper.getPositionDown(model, lineNumber, column, leftoverVisibleColumns, count, allowMoveOnLastLine);
        };
        CursorHelper.prototype.getColumnAtBeginningOfLine = function (model, lineNumber, column) {
            return this.moveHelper.getColumnAtBeginningOfLine(model, lineNumber, column);
        };
        CursorHelper.prototype.getColumnAtEndOfLine = function (model, lineNumber, column) {
            return this.moveHelper.getColumnAtEndOfLine(model, lineNumber, column);
        };
        CursorHelper.prototype.columnSelect = function (model, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn) {
            return this.moveHelper.columnSelect(model, fromLineNumber, fromVisibleColumn, toLineNumber, toVisibleColumn);
        };
        CursorHelper.prototype.visibleColumnFromColumn = function (model, lineNumber, column) {
            return this.moveHelper.visibleColumnFromColumn(model, lineNumber, column);
        };
        CursorHelper.prototype.columnFromVisibleColumn = function (model, lineNumber, column) {
            return this.moveHelper.columnFromVisibleColumn(model, lineNumber, column);
        };
        CursorHelper.prototype._createWord = function (lineContent, wordType, start, end) {
            // console.log('WORD ==> ' + start + ' => ' + end + ':::: <<<' + lineContent.substring(start, end) + '>>>');
            return { start: start, end: end, wordType: wordType };
        };
        CursorHelper.prototype.findPreviousWordOnLine = function (_position) {
            var position = this.model.validatePosition(_position);
            var wordSeparators = getMapForWordSeparators(this.configuration.editor.wordSeparators);
            var lineContent = this.model.getLineContent(position.lineNumber);
            var wordType = W_NONE;
            for (var chIndex = position.column - 2; chIndex >= 0; chIndex--) {
                var chCode = lineContent.charCodeAt(chIndex);
                var chClass = (wordSeparators[chCode] || CharacterClass.Regular);
                if (chClass === CH_REGULAR) {
                    if (wordType === W_SEPARATOR) {
                        return this._createWord(lineContent, wordType, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));
                    }
                    wordType = W_REGULAR;
                }
                else if (chClass === CH_WORD_SEPARATOR) {
                    if (wordType === W_REGULAR) {
                        return this._createWord(lineContent, wordType, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));
                    }
                    wordType = W_SEPARATOR;
                }
                else if (chClass === CH_WHITESPACE) {
                    if (wordType !== W_NONE) {
                        return this._createWord(lineContent, wordType, chIndex + 1, this._findEndOfWord(lineContent, wordSeparators, wordType, chIndex + 1));
                    }
                }
            }
            if (wordType !== W_NONE) {
                return this._createWord(lineContent, wordType, 0, this._findEndOfWord(lineContent, wordSeparators, wordType, 0));
            }
            return null;
        };
        CursorHelper.prototype._findEndOfWord = function (lineContent, wordSeparators, wordType, startIndex) {
            var len = lineContent.length;
            for (var chIndex = startIndex; chIndex < len; chIndex++) {
                var chCode = lineContent.charCodeAt(chIndex);
                var chClass = (wordSeparators[chCode] || CharacterClass.Regular);
                if (chClass === CH_WHITESPACE) {
                    return chIndex;
                }
                if (wordType === W_REGULAR && chClass === CH_WORD_SEPARATOR) {
                    return chIndex;
                }
                if (wordType === W_SEPARATOR && chClass === CH_REGULAR) {
                    return chIndex;
                }
            }
            return len;
        };
        CursorHelper.prototype.findNextWordOnLine = function (_position) {
            var position = this.model.validatePosition(_position);
            var wordSeparators = getMapForWordSeparators(this.configuration.editor.wordSeparators);
            var lineContent = this.model.getLineContent(position.lineNumber);
            var wordType = W_NONE;
            var len = lineContent.length;
            for (var chIndex = position.column - 1; chIndex < len; chIndex++) {
                var chCode = lineContent.charCodeAt(chIndex);
                var chClass = (wordSeparators[chCode] || CharacterClass.Regular);
                if (chClass === CH_REGULAR) {
                    if (wordType === W_SEPARATOR) {
                        return this._createWord(lineContent, wordType, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);
                    }
                    wordType = W_REGULAR;
                }
                else if (chClass === CH_WORD_SEPARATOR) {
                    if (wordType === W_REGULAR) {
                        return this._createWord(lineContent, wordType, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);
                    }
                    wordType = W_SEPARATOR;
                }
                else if (chClass === CH_WHITESPACE) {
                    if (wordType !== W_NONE) {
                        return this._createWord(lineContent, wordType, this._findStartOfWord(lineContent, wordSeparators, wordType, chIndex - 1), chIndex);
                    }
                }
            }
            if (wordType !== W_NONE) {
                return this._createWord(lineContent, wordType, this._findStartOfWord(lineContent, wordSeparators, wordType, len - 1), len);
            }
            return null;
        };
        CursorHelper.prototype._findStartOfWord = function (lineContent, wordSeparators, wordType, startIndex) {
            for (var chIndex = startIndex; chIndex >= 0; chIndex--) {
                var chCode = lineContent.charCodeAt(chIndex);
                var chClass = (wordSeparators[chCode] || CharacterClass.Regular);
                if (chClass === CH_WHITESPACE) {
                    return chIndex + 1;
                }
                if (wordType === W_REGULAR && chClass === CH_WORD_SEPARATOR) {
                    return chIndex + 1;
                }
                if (wordType === W_SEPARATOR && chClass === CH_REGULAR) {
                    return chIndex + 1;
                }
            }
            return 0;
        };
        return CursorHelper;
    }());
    function once(keyFn, computeFn) {
        var cache = {};
        return function (input) {
            var key = keyFn(input);
            if (!cache.hasOwnProperty(key)) {
                cache[key] = computeFn(input);
            }
            return cache[key];
        };
    }
    var getMapForWordSeparators = once(function (input) { return input; }, function (input) {
        var r = [];
        // Make array fast for ASCII text
        for (var chCode = 0; chCode < 256; chCode++) {
            r[chCode] = CharacterClass.Regular;
        }
        for (var i = 0, len = input.length; i < len; i++) {
            r[input.charCodeAt(i)] = CharacterClass.WordSeparator;
        }
        r[' '.charCodeAt(0)] = CharacterClass.Whitespace;
        r['\t'.charCodeAt(0)] = CharacterClass.Whitespace;
        return r;
    });
    var Utils = (function () {
        function Utils() {
        }
        /**
         * Range contains position (including edges)?
         */
        Utils.rangeContainsPosition = function (range, position) {
            if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
                return false;
            }
            if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
                return false;
            }
            if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
                return false;
            }
            return true;
        };
        /**
         * Tests if position is contained inside range.
         * If position is either the starting or ending of a range, false is returned.
         */
        Utils.isPositionInsideRange = function (position, range) {
            if (position.lineNumber < range.startLineNumber) {
                return false;
            }
            if (position.lineNumber > range.endLineNumber) {
                return false;
            }
            if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
                return false;
            }
            if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
                return false;
            }
            return true;
        };
        Utils.isPositionAtRangeEdges = function (position, range) {
            if (position.lineNumber === range.startLineNumber && position.column === range.startColumn) {
                return true;
            }
            if (position.lineNumber === range.endLineNumber && position.column === range.endColumn) {
                return true;
            }
            return false;
        };
        return Utils;
    }());
});

define(__m[220], __M([0,1,8,173,24,40]), function (require, exports, errors_1, oneCursor_1, selection_1, languageConfigurationRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CursorCollection = (function () {
        function CursorCollection(editorId, model, configuration, viewModelHelper) {
            this.editorId = editorId;
            this.model = model;
            this.configuration = configuration;
            this.viewModelHelper = viewModelHelper;
            this.modeConfiguration = this.getModeConfiguration();
            this.primaryCursor = new oneCursor_1.OneCursor(this.editorId, this.model, this.configuration, this.modeConfiguration, this.viewModelHelper);
            this.secondaryCursors = [];
            this.lastAddedCursorIndex = 0;
        }
        CursorCollection.prototype.dispose = function () {
            this.primaryCursor.dispose();
            this.killSecondaryCursors();
        };
        CursorCollection.prototype.saveState = function () {
            return {
                primary: this.primaryCursor.saveState(),
                secondary: this.secondaryCursors.map(function (c) { return c.saveState(); })
            };
        };
        CursorCollection.prototype.restoreState = function (state) {
            this.primaryCursor.restoreState(state.primary);
            this.killSecondaryCursors();
            for (var i = 0; i < state.secondary.length; i++) {
                this.addSecondaryCursor(null);
                this.secondaryCursors[i].restoreState(state.secondary[i]);
            }
        };
        CursorCollection.prototype.updateMode = function () {
            var _this = this;
            this.modeConfiguration = this.getModeConfiguration();
            this.getAll().forEach(function (cursor) {
                cursor.updateModeConfiguration(_this.modeConfiguration);
            });
        };
        CursorCollection.prototype.getAll = function () {
            var result = [];
            result.push(this.primaryCursor);
            result = result.concat(this.secondaryCursors);
            return result;
        };
        CursorCollection.prototype.getPosition = function (index) {
            if (index === 0) {
                return this.primaryCursor.getPosition();
            }
            else {
                return this.secondaryCursors[index - 1].getPosition();
            }
        };
        CursorCollection.prototype.getViewPosition = function (index) {
            if (index === 0) {
                return this.primaryCursor.getViewPosition();
            }
            else {
                return this.secondaryCursors[index - 1].getViewPosition();
            }
        };
        CursorCollection.prototype.getPositions = function () {
            var result = [];
            result.push(this.primaryCursor.getPosition());
            for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
                result.push(this.secondaryCursors[i].getPosition());
            }
            return result;
        };
        CursorCollection.prototype.getViewPositions = function () {
            var result = [];
            result.push(this.primaryCursor.getViewPosition());
            for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
                result.push(this.secondaryCursors[i].getViewPosition());
            }
            return result;
        };
        CursorCollection.prototype.getSelection = function (index) {
            if (index === 0) {
                return this.primaryCursor.getSelection();
            }
            else {
                return this.secondaryCursors[index - 1].getSelection();
            }
        };
        CursorCollection.prototype.getSelections = function () {
            var result = [];
            result.push(this.primaryCursor.getSelection());
            for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
                result.push(this.secondaryCursors[i].getSelection());
            }
            return result;
        };
        CursorCollection.prototype.getViewSelections = function () {
            var result = [];
            result.push(this.primaryCursor.getViewSelection());
            for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
                result.push(this.secondaryCursors[i].getViewSelection());
            }
            return result;
        };
        CursorCollection.prototype.setSelections = function (selections, viewSelections) {
            this.primaryCursor.setSelection(selections[0]);
            this._setSecondarySelections(selections.slice(1));
            if (viewSelections) {
                this.primaryCursor.setViewSelection(viewSelections[0]);
                for (var i = 0; i < this.secondaryCursors.length; i++) {
                    this.secondaryCursors[i].setViewSelection(viewSelections[i + 1]);
                }
            }
        };
        CursorCollection.prototype.killSecondaryCursors = function () {
            return (this._setSecondarySelections([]) > 0);
        };
        CursorCollection.prototype.normalize = function () {
            this._mergeCursorsIfNecessary();
            this.primaryCursor.adjustBracketDecorations();
            for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
                this.secondaryCursors[i].adjustBracketDecorations();
            }
        };
        CursorCollection.prototype.addSecondaryCursor = function (selection) {
            var newCursor = new oneCursor_1.OneCursor(this.editorId, this.model, this.configuration, this.modeConfiguration, this.viewModelHelper);
            if (selection) {
                newCursor.setSelection(selection);
            }
            this.secondaryCursors.push(newCursor);
            this.lastAddedCursorIndex = this.secondaryCursors.length;
        };
        CursorCollection.prototype.duplicateCursors = function () {
            var newCursors = [];
            newCursors.push(this.primaryCursor.duplicate());
            for (var i = 0, len = this.secondaryCursors.length; i < len; i++) {
                newCursors.push(this.secondaryCursors[i].duplicate());
            }
            this.secondaryCursors = this.secondaryCursors.concat(newCursors);
            this.lastAddedCursorIndex = this.secondaryCursors.length;
        };
        CursorCollection.prototype.getLastAddedCursor = function () {
            if (this.secondaryCursors.length === 0 || this.lastAddedCursorIndex === 0) {
                return this.primaryCursor;
            }
            return this.secondaryCursors[this.lastAddedCursorIndex - 1];
        };
        /**
         * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.
         * Return value:
         * 		- a positive number indicates the number of secondary cursors added
         * 		- a negative number indicates the number of secondary cursors removed
         * 		- 0 indicates that no changes have been done to the secondary cursors list
         */
        CursorCollection.prototype._setSecondarySelections = function (secondarySelections) {
            var secondaryCursorsLength = this.secondaryCursors.length;
            var secondarySelectionsLength = secondarySelections.length;
            var returnValue = secondarySelectionsLength - secondaryCursorsLength;
            if (secondaryCursorsLength < secondarySelectionsLength) {
                var createCnt = secondarySelectionsLength - secondaryCursorsLength;
                for (var i = 0; i < createCnt; i++) {
                    this.addSecondaryCursor(null);
                }
            }
            else if (secondaryCursorsLength > secondarySelectionsLength) {
                var removeCnt = secondaryCursorsLength - secondarySelectionsLength;
                for (var i = 0; i < removeCnt; i++) {
                    this._removeSecondaryCursor(this.secondaryCursors.length - 1);
                }
            }
            for (var i = 0; i < secondarySelectionsLength; i++) {
                if (secondarySelections[i]) {
                    this.secondaryCursors[i].setSelection(secondarySelections[i]);
                }
            }
            return returnValue;
        };
        CursorCollection.prototype._removeSecondaryCursor = function (removeIndex) {
            if (this.lastAddedCursorIndex >= removeIndex + 1) {
                this.lastAddedCursorIndex--;
            }
            this.secondaryCursors[removeIndex].dispose();
            this.secondaryCursors.splice(removeIndex, 1);
        };
        CursorCollection.prototype._mergeCursorsIfNecessary = function () {
            if (this.secondaryCursors.length === 0) {
                return;
            }
            var cursors = this.getAll();
            var sortedCursors = [];
            for (var i = 0; i < cursors.length; i++) {
                sortedCursors.push({
                    index: i,
                    selection: cursors[i].getSelection(),
                    viewSelection: cursors[i].getViewSelection()
                });
            }
            sortedCursors.sort(function (a, b) {
                if (a.viewSelection.startLineNumber === b.viewSelection.startLineNumber) {
                    return a.viewSelection.startColumn - b.viewSelection.startColumn;
                }
                return a.viewSelection.startLineNumber - b.viewSelection.startLineNumber;
            });
            for (var sortedCursorIndex = 0; sortedCursorIndex < sortedCursors.length - 1; sortedCursorIndex++) {
                var current = sortedCursors[sortedCursorIndex];
                var next = sortedCursors[sortedCursorIndex + 1];
                var currentViewSelection = current.viewSelection;
                var nextViewSelection = next.viewSelection;
                if (nextViewSelection.getStartPosition().isBeforeOrEqual(currentViewSelection.getEndPosition())) {
                    var winnerSortedCursorIndex = current.index < next.index ? sortedCursorIndex : sortedCursorIndex + 1;
                    var looserSortedCursorIndex = current.index < next.index ? sortedCursorIndex + 1 : sortedCursorIndex;
                    var looserIndex = sortedCursors[looserSortedCursorIndex].index;
                    var winnerIndex = sortedCursors[winnerSortedCursorIndex].index;
                    var looserSelection = sortedCursors[looserSortedCursorIndex].selection;
                    var winnerSelection = sortedCursors[winnerSortedCursorIndex].selection;
                    if (!looserSelection.equalsSelection(winnerSelection)) {
                        var resultingRange = looserSelection.plusRange(winnerSelection);
                        var looserSelectionIsLTR = (looserSelection.selectionStartLineNumber === looserSelection.startLineNumber && looserSelection.selectionStartColumn === looserSelection.startColumn);
                        var winnerSelectionIsLTR = (winnerSelection.selectionStartLineNumber === winnerSelection.startLineNumber && winnerSelection.selectionStartColumn === winnerSelection.startColumn);
                        // Give more importance to the last added cursor (think Ctrl-dragging + hitting another cursor)
                        var resultingSelectionIsLTR;
                        if (looserIndex === this.lastAddedCursorIndex) {
                            resultingSelectionIsLTR = looserSelectionIsLTR;
                            this.lastAddedCursorIndex = winnerIndex;
                        }
                        else {
                            // Winner takes it all
                            resultingSelectionIsLTR = winnerSelectionIsLTR;
                        }
                        var resultingSelection;
                        if (resultingSelectionIsLTR) {
                            resultingSelection = new selection_1.Selection(resultingRange.startLineNumber, resultingRange.startColumn, resultingRange.endLineNumber, resultingRange.endColumn);
                        }
                        else {
                            resultingSelection = new selection_1.Selection(resultingRange.endLineNumber, resultingRange.endColumn, resultingRange.startLineNumber, resultingRange.startColumn);
                        }
                        sortedCursors[winnerSortedCursorIndex].selection = resultingSelection;
                        cursors[winnerIndex].setSelection(resultingSelection);
                    }
                    for (var j = 0; j < sortedCursors.length; j++) {
                        if (sortedCursors[j].index > looserIndex) {
                            sortedCursors[j].index--;
                        }
                    }
                    cursors.splice(looserIndex, 1);
                    sortedCursors.splice(looserSortedCursorIndex, 1);
                    this._removeSecondaryCursor(looserIndex - 1);
                    sortedCursorIndex--;
                }
            }
        };
        CursorCollection.prototype.getModeConfiguration = function () {
            var i;
            var result = {
                electricChars: {},
                autoClosingPairsOpen: {},
                autoClosingPairsClose: {},
                surroundingPairs: {}
            };
            var electricCharSupport = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getElectricCharacterSupport(this.model.getMode().getId());
            if (electricCharSupport) {
                var electricChars = null;
                try {
                    electricChars = electricCharSupport.getElectricCharacters();
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                    electricChars = null;
                }
                if (electricChars) {
                    for (i = 0; i < electricChars.length; i++) {
                        result.electricChars[electricChars[i]] = true;
                    }
                }
            }
            var characterPairSupport = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getCharacterPairSupport(this.model.getMode().getId());
            if (characterPairSupport) {
                var autoClosingPairs = void 0;
                try {
                    autoClosingPairs = characterPairSupport.getAutoClosingPairs();
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                    autoClosingPairs = null;
                }
                if (autoClosingPairs) {
                    for (i = 0; i < autoClosingPairs.length; i++) {
                        result.autoClosingPairsOpen[autoClosingPairs[i].open] = autoClosingPairs[i].close;
                        result.autoClosingPairsClose[autoClosingPairs[i].close] = autoClosingPairs[i].open;
                    }
                }
                var surroundingPairs = void 0;
                try {
                    surroundingPairs = characterPairSupport.getSurroundingPairs();
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                    surroundingPairs = null;
                }
                if (surroundingPairs) {
                    for (i = 0; i < surroundingPairs.length; i++) {
                        result.surroundingPairs[surroundingPairs[i].open] = surroundingPairs[i].close;
                    }
                }
            }
            return result;
        };
        return CursorCollection;
    }());
    exports.CursorCollection = CursorCollection;
});

define(__m[176], __M([0,1,88,40,76]), function (require, exports, modeTransition_1, languageConfigurationRegistry_1, wordHelper_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var WordHelper = (function () {
        function WordHelper() {
        }
        WordHelper._safeGetWordDefinition = function (mode) {
            return languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(mode.getId());
        };
        WordHelper.massageWordDefinitionOf = function (mode) {
            return wordHelper_1.ensureValidWordDefinition(WordHelper._safeGetWordDefinition(mode));
        };
        WordHelper._getWordAtColumn = function (txt, column, modeIndex, modeTransitions) {
            var modeStartIndex = modeTransitions[modeIndex].startIndex, modeEndIndex = (modeIndex + 1 < modeTransitions.length ? modeTransitions[modeIndex + 1].startIndex : txt.length), mode = modeTransitions[modeIndex].mode;
            return wordHelper_1.getWordAtText(column, WordHelper.massageWordDefinitionOf(mode), txt.substring(modeStartIndex, modeEndIndex), modeStartIndex);
        };
        WordHelper.getWordAtPosition = function (textSource, position) {
            if (!textSource._lineIsTokenized(position.lineNumber)) {
                return wordHelper_1.getWordAtText(position.column, WordHelper.massageWordDefinitionOf(textSource.getMode()), textSource.getLineContent(position.lineNumber), 0);
            }
            var result = null;
            var txt = textSource.getLineContent(position.lineNumber), modeTransitions = textSource._getLineModeTransitions(position.lineNumber), columnIndex = position.column - 1, modeIndex = modeTransition_1.ModeTransition.findIndexInSegmentsArray(modeTransitions, columnIndex);
            result = WordHelper._getWordAtColumn(txt, position.column, modeIndex, modeTransitions);
            if (!result && modeIndex > 0 && modeTransitions[modeIndex].startIndex === columnIndex) {
                // The position is right at the beginning of `modeIndex`, so try looking at `modeIndex` - 1 too
                result = WordHelper._getWordAtColumn(txt, position.column, modeIndex - 1, modeTransitions);
            }
            return result;
        };
        return WordHelper;
    }());
    exports.WordHelper = WordHelper;
});






define(__m[222], __M([0,1,23,3,10,21,4,24,7,464,467]), function (require, exports, eventEmitter_1, lifecycle_1, strings, position_1, range_1, selection_1, editorCommon, viewModelCursors_1, viewModelDecorations_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewModel = (function (_super) {
        __extends(ViewModel, _super);
        function ViewModel(lines, editorId, configuration, model, getCurrentCenteredModelRange) {
            var _this = this;
            _super.call(this);
            this.lines = lines;
            this.editorId = editorId;
            this.configuration = configuration;
            this.model = model;
            this.getCurrentCenteredModelRange = getCurrentCenteredModelRange;
            this.decorations = new viewModelDecorations_1.ViewModelDecorations(this.editorId, this.configuration, {
                convertModelRangeToViewRange: function (modelRange, isWholeLine) {
                    if (isWholeLine) {
                        return _this.convertWholeLineModelRangeToViewRange(modelRange);
                    }
                    return _this.convertModelRangeToViewRange(modelRange);
                }
            });
            this.decorations.reset(this.model);
            this.cursors = new viewModelCursors_1.ViewModelCursors(this.configuration, this);
            this.listenersToRemove = [];
            this._toDispose = [];
            this.listenersToRemove.push(this.model.addBulkListener(function (events) { return _this.onEvents(events); }));
            this._toDispose.push(this.configuration.onDidChange(function (e) {
                _this.onEvents([new eventEmitter_1.EmitterEvent(editorCommon.EventType.ConfigurationChanged, e)]);
            }));
        }
        ViewModel.prototype.setHiddenAreas = function (ranges) {
            var _this = this;
            this.deferredEmit(function () {
                var lineMappingChanged = _this.lines.setHiddenAreas(ranges, function (eventType, payload) { return _this.emit(eventType, payload); });
                if (lineMappingChanged) {
                    _this.emit(editorCommon.ViewEventNames.LineMappingChangedEvent);
                    _this.decorations.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
                    _this.cursors.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
                }
            });
        };
        ViewModel.prototype.dispose = function () {
            this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);
            this._toDispose = lifecycle_1.dispose(this._toDispose);
            this.decorations.dispose();
            this.decorations = null;
            this.lines.dispose();
            this.lines = null;
            this.configuration = null;
            this.model = null;
        };
        ViewModel.prototype._onTabSizeChange = function (newTabSize) {
            var _this = this;
            var lineMappingChanged = this.lines.setTabSize(newTabSize, function (eventType, payload) { return _this.emit(eventType, payload); });
            if (lineMappingChanged) {
                this.emit(editorCommon.ViewEventNames.LineMappingChangedEvent);
                this.decorations.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
                this.cursors.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
            }
            return lineMappingChanged;
        };
        ViewModel.prototype._onWrappingIndentChange = function (newWrappingIndent) {
            var _this = this;
            var lineMappingChanged = this.lines.setWrappingIndent(newWrappingIndent, function (eventType, payload) { return _this.emit(eventType, payload); });
            if (lineMappingChanged) {
                this.emit(editorCommon.ViewEventNames.LineMappingChangedEvent);
                this.decorations.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
                this.cursors.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
            }
            return lineMappingChanged;
        };
        ViewModel.prototype._restoreCenteredModelRange = function (range) {
            // modelLine -> viewLine
            var newCenteredViewRange = this.convertModelRangeToViewRange(range);
            // Send a reveal event to restore the centered content
            var restoreRevealEvent = {
                range: newCenteredViewRange,
                verticalType: editorCommon.VerticalRevealType.Center,
                revealHorizontal: false
            };
            this.emit(editorCommon.ViewEventNames.RevealRangeEvent, restoreRevealEvent);
        };
        ViewModel.prototype._onWrappingColumnChange = function (newWrappingColumn, columnsForFullWidthChar) {
            var _this = this;
            var lineMappingChanged = this.lines.setWrappingColumn(newWrappingColumn, columnsForFullWidthChar, function (eventType, payload) { return _this.emit(eventType, payload); });
            if (lineMappingChanged) {
                this.emit(editorCommon.ViewEventNames.LineMappingChangedEvent);
                this.decorations.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
                this.cursors.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
            }
            return lineMappingChanged;
        };
        ViewModel.prototype.addEventSource = function (eventSource) {
            var _this = this;
            this.listenersToRemove.push(eventSource.addBulkListener2(function (events) { return _this.onEvents(events); }));
        };
        ViewModel.prototype.onEvents = function (events) {
            var _this = this;
            this.deferredEmit(function () {
                var hasContentChange = events.some(function (e) { return e.getType() === editorCommon.EventType.ModelRawContentChanged; }), previousCenteredModelRange;
                if (!hasContentChange) {
                    // We can only convert the current centered view range to the current centered model range if the model has no changes.
                    previousCenteredModelRange = _this.getCurrentCenteredModelRange();
                }
                var i, len, e, data, modelContentChangedEvent, hadOtherModelChange = false, hadModelLineChangeThatChangedLineMapping = false, revealPreviousCenteredModelRange = false;
                for (i = 0, len = events.length; i < len; i++) {
                    e = events[i];
                    data = e.getData();
                    switch (e.getType()) {
                        case editorCommon.EventType.ModelRawContentChanged:
                            modelContentChangedEvent = data;
                            switch (modelContentChangedEvent.changeType) {
                                case editorCommon.EventType.ModelRawContentChangedFlush:
                                    _this.onModelFlushed(modelContentChangedEvent);
                                    hadOtherModelChange = true;
                                    break;
                                case editorCommon.EventType.ModelRawContentChangedLinesDeleted:
                                    _this.onModelLinesDeleted(modelContentChangedEvent);
                                    hadOtherModelChange = true;
                                    break;
                                case editorCommon.EventType.ModelRawContentChangedLinesInserted:
                                    _this.onModelLinesInserted(modelContentChangedEvent);
                                    hadOtherModelChange = true;
                                    break;
                                case editorCommon.EventType.ModelRawContentChangedLineChanged:
                                    hadModelLineChangeThatChangedLineMapping = _this.onModelLineChanged(modelContentChangedEvent);
                                    break;
                                default:
                                    console.info('ViewModel received unknown event: ');
                                    console.info(e);
                            }
                            break;
                        case editorCommon.EventType.ModelTokensChanged:
                            _this.onModelTokensChanged(data);
                            break;
                        case editorCommon.EventType.ModelModeChanged:
                            // That's ok, a model tokens changed event will follow shortly
                            break;
                        case editorCommon.EventType.ModelModeSupportChanged:
                            // That's ok, no work to do
                            break;
                        case editorCommon.EventType.ModelContentChanged2:
                            // Ignore
                            break;
                        case editorCommon.EventType.ModelOptionsChanged:
                            // A tab size change causes a line mapping changed event => all view parts will repaint OK, no further event needed here
                            var prevLineCount = _this.lines.getOutputLineCount();
                            var tabSizeChanged = _this._onTabSizeChange(_this.model.getOptions().tabSize);
                            var newLineCount = _this.lines.getOutputLineCount();
                            if (tabSizeChanged && prevLineCount !== newLineCount) {
                                revealPreviousCenteredModelRange = true;
                            }
                            break;
                        case editorCommon.EventType.ModelDecorationsChanged:
                            _this.onModelDecorationsChanged(data);
                            break;
                        case editorCommon.EventType.ModelDispose:
                            // Ignore, since the editor will take care of this and destroy the view shortly
                            break;
                        case editorCommon.EventType.CursorPositionChanged:
                            _this.onCursorPositionChanged(data);
                            break;
                        case editorCommon.EventType.CursorSelectionChanged:
                            _this.onCursorSelectionChanged(data);
                            break;
                        case editorCommon.EventType.CursorRevealRange:
                            _this.onCursorRevealRange(data);
                            break;
                        case editorCommon.EventType.CursorScrollRequest:
                            _this.onCursorScrollRequest(data);
                            break;
                        case editorCommon.EventType.ConfigurationChanged:
                            revealPreviousCenteredModelRange = _this._onWrappingIndentChange(_this.configuration.editor.wrappingInfo.wrappingIndent) || revealPreviousCenteredModelRange;
                            revealPreviousCenteredModelRange = _this._onWrappingColumnChange(_this.configuration.editor.wrappingInfo.wrappingColumn, _this.configuration.editor.fontInfo.typicalFullwidthCharacterWidth / _this.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth) || revealPreviousCenteredModelRange;
                            if (data.readOnly) {
                                // Must read again all decorations due to readOnly filtering
                                _this.decorations.reset(_this.model);
                                var decorationsChangedEvent = {
                                    inlineDecorationsChanged: false
                                };
                                _this.emit(editorCommon.ViewEventNames.DecorationsChangedEvent, decorationsChangedEvent);
                            }
                            _this.emit(e.getType(), data);
                            break;
                        default:
                            console.info('View received unknown event: ');
                            console.info(e);
                    }
                }
                if (!hadOtherModelChange && hadModelLineChangeThatChangedLineMapping) {
                    _this.emit(editorCommon.ViewEventNames.LineMappingChangedEvent);
                    _this.decorations.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
                    _this.cursors.onLineMappingChanged(function (eventType, payload) { return _this.emit(eventType, payload); });
                }
                if (revealPreviousCenteredModelRange && previousCenteredModelRange) {
                    _this._restoreCenteredModelRange(previousCenteredModelRange);
                }
            });
        };
        // --- begin inbound event conversion
        ViewModel.prototype.onModelFlushed = function (e) {
            var _this = this;
            this.lines.onModelFlushed(e.versionId, function (eventType, payload) { return _this.emit(eventType, payload); });
            this.decorations.reset(this.model);
        };
        ViewModel.prototype.onModelDecorationsChanged = function (e) {
            var _this = this;
            this.decorations.onModelDecorationsChanged(e, function (eventType, payload) { return _this.emit(eventType, payload); });
        };
        ViewModel.prototype.onModelLinesDeleted = function (e) {
            var _this = this;
            this.lines.onModelLinesDeleted(e.versionId, e.fromLineNumber, e.toLineNumber, function (eventType, payload) { return _this.emit(eventType, payload); });
        };
        ViewModel.prototype.onModelTokensChanged = function (e) {
            var viewStartLineNumber = this.convertModelPositionToViewPosition(e.fromLineNumber, 1).lineNumber;
            var viewEndLineNumber = this.convertModelPositionToViewPosition(e.toLineNumber, this.model.getLineMaxColumn(e.toLineNumber)).lineNumber;
            var e = {
                fromLineNumber: viewStartLineNumber,
                toLineNumber: viewEndLineNumber
            };
            this.emit(editorCommon.ViewEventNames.TokensChangedEvent, e);
        };
        ViewModel.prototype.onModelLineChanged = function (e) {
            var _this = this;
            var lineMappingChanged = this.lines.onModelLineChanged(e.versionId, e.lineNumber, e.detail, function (eventType, payload) { return _this.emit(eventType, payload); });
            return lineMappingChanged;
        };
        ViewModel.prototype.onModelLinesInserted = function (e) {
            var _this = this;
            this.lines.onModelLinesInserted(e.versionId, e.fromLineNumber, e.toLineNumber, e.detail.split('\n'), function (eventType, payload) { return _this.emit(eventType, payload); });
        };
        ViewModel.prototype.validateViewRange = function (viewStartLineNumber, viewStartColumn, viewEndLineNumber, viewEndColumn, modelRange) {
            var validViewStart = this.validateViewPosition(viewStartColumn, viewStartColumn, modelRange.getStartPosition());
            var validViewEnd = this.validateViewPosition(viewEndLineNumber, viewEndColumn, modelRange.getEndPosition());
            return new range_1.Range(validViewStart.lineNumber, validViewStart.column, validViewEnd.lineNumber, validViewEnd.column);
        };
        ViewModel.prototype.validateViewPosition = function (viewLineNumber, viewColumn, modelPosition) {
            if (viewLineNumber < 1) {
                viewLineNumber = 1;
            }
            var lineCount = this.getLineCount();
            if (viewLineNumber > lineCount) {
                viewLineNumber = lineCount;
            }
            var viewMinColumn = this.getLineMinColumn(viewLineNumber);
            var viewMaxColumn = this.getLineMaxColumn(viewLineNumber);
            if (viewColumn < viewMinColumn) {
                viewColumn = viewMinColumn;
            }
            if (viewColumn > viewMaxColumn) {
                viewColumn = viewMaxColumn;
            }
            var computedModelPosition = this.convertViewPositionToModelPosition(viewLineNumber, viewColumn);
            if (computedModelPosition.equals(modelPosition)) {
                return new position_1.Position(viewLineNumber, viewColumn);
            }
            return this.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);
        };
        ViewModel.prototype.validateViewSelection = function (viewSelection, modelSelection) {
            var modelSelectionStart = new position_1.Position(modelSelection.selectionStartLineNumber, modelSelection.selectionStartColumn);
            var modelPosition = new position_1.Position(modelSelection.positionLineNumber, modelSelection.positionColumn);
            var viewSelectionStart = this.validateViewPosition(viewSelection.selectionStartLineNumber, viewSelection.selectionStartColumn, modelSelectionStart);
            var viewPosition = this.validateViewPosition(viewSelection.positionLineNumber, viewSelection.positionColumn, modelPosition);
            return new selection_1.Selection(viewSelectionStart.lineNumber, viewSelectionStart.column, viewPosition.lineNumber, viewPosition.column);
        };
        ViewModel.prototype.onCursorPositionChanged = function (e) {
            var _this = this;
            this.cursors.onCursorPositionChanged(e, function (eventType, payload) { return _this.emit(eventType, payload); });
        };
        ViewModel.prototype.onCursorSelectionChanged = function (e) {
            var _this = this;
            this.cursors.onCursorSelectionChanged(e, function (eventType, payload) { return _this.emit(eventType, payload); });
        };
        ViewModel.prototype.onCursorRevealRange = function (e) {
            var _this = this;
            this.cursors.onCursorRevealRange(e, function (eventType, payload) { return _this.emit(eventType, payload); });
        };
        ViewModel.prototype.onCursorScrollRequest = function (e) {
            var _this = this;
            this.cursors.onCursorScrollRequest(e, function (eventType, payload) { return _this.emit(eventType, payload); });
        };
        // --- end inbound event conversion
        ViewModel.prototype.getTabSize = function () {
            return this.model.getOptions().tabSize;
        };
        ViewModel.prototype.getLineCount = function () {
            return this.lines.getOutputLineCount();
        };
        ViewModel.prototype.getLineContent = function (lineNumber) {
            return this.lines.getOutputLineContent(lineNumber);
        };
        ViewModel.prototype.getLineMinColumn = function (lineNumber) {
            return this.lines.getOutputLineMinColumn(lineNumber);
        };
        ViewModel.prototype.getLineMaxColumn = function (lineNumber) {
            return this.lines.getOutputLineMaxColumn(lineNumber);
        };
        ViewModel.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {
            var result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));
            if (result === -1) {
                return 0;
            }
            return result + 1;
        };
        ViewModel.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {
            var result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));
            if (result === -1) {
                return 0;
            }
            return result + 2;
        };
        ViewModel.prototype.getLineTokens = function (lineNumber) {
            return this.lines.getOutputLineTokens(lineNumber);
        };
        ViewModel.prototype.getLineRenderLineNumber = function (viewLineNumber) {
            var modelPosition = this.convertViewPositionToModelPosition(viewLineNumber, 1);
            if (modelPosition.column !== 1) {
                return '';
            }
            var modelLineNumber = modelPosition.lineNumber;
            if (typeof this.configuration.editor.viewInfo.lineNumbers === 'function') {
                return this.configuration.editor.viewInfo.lineNumbers(modelLineNumber);
            }
            return modelLineNumber.toString();
        };
        ViewModel.prototype.getDecorationsViewportData = function (startLineNumber, endLineNumber) {
            return this.decorations.getDecorationsViewportData(startLineNumber, endLineNumber);
        };
        ViewModel.prototype.getAllDecorations = function () {
            return this.decorations.getAllDecorations();
        };
        ViewModel.prototype.getEOL = function () {
            return this.model.getEOL();
        };
        ViewModel.prototype.getValueInRange = function (range, eol) {
            var modelRange = this.convertViewRangeToModelRange(range);
            return this.model.getValueInRange(modelRange, eol);
        };
        ViewModel.prototype.getSelections = function () {
            return this.cursors.getSelections();
        };
        // View -> Model conversion and related methods
        ViewModel.prototype.convertViewPositionToModelPosition = function (viewLineNumber, viewColumn) {
            return this.lines.convertOutputPositionToInputPosition(viewLineNumber, viewColumn);
        };
        ViewModel.prototype.convertViewRangeToModelRange = function (viewRange) {
            var start = this.convertViewPositionToModelPosition(viewRange.startLineNumber, viewRange.startColumn);
            var end = this.convertViewPositionToModelPosition(viewRange.endLineNumber, viewRange.endColumn);
            return new range_1.Range(start.lineNumber, start.column, end.lineNumber, end.column);
        };
        ViewModel.prototype.convertViewSelectionToModelSelection = function (viewSelection) {
            var selectionStart = this.convertViewPositionToModelPosition(viewSelection.selectionStartLineNumber, viewSelection.selectionStartColumn);
            var position = this.convertViewPositionToModelPosition(viewSelection.positionLineNumber, viewSelection.positionColumn);
            return new selection_1.Selection(selectionStart.lineNumber, selectionStart.column, position.lineNumber, position.column);
        };
        // Model -> View conversion and related methods
        ViewModel.prototype.getModelLineContent = function (modelLineNumber) {
            return this.model.getLineContent(modelLineNumber);
        };
        ViewModel.prototype.getModelLineMaxColumn = function (modelLineNumber) {
            return this.model.getLineMaxColumn(modelLineNumber);
        };
        ViewModel.prototype.validateModelPosition = function (position) {
            return this.model.validatePosition(position);
        };
        ViewModel.prototype.convertModelPositionToViewPosition = function (modelLineNumber, modelColumn) {
            return this.lines.convertInputPositionToOutputPosition(modelLineNumber, modelColumn);
        };
        ViewModel.prototype.convertModelRangeToViewRange = function (modelRange) {
            var start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, modelRange.startColumn);
            var end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, modelRange.endColumn);
            return new range_1.Range(start.lineNumber, start.column, end.lineNumber, end.column);
        };
        ViewModel.prototype.convertWholeLineModelRangeToViewRange = function (modelRange) {
            var start = this.convertModelPositionToViewPosition(modelRange.startLineNumber, 1);
            var end = this.convertModelPositionToViewPosition(modelRange.endLineNumber, this.model.getLineMaxColumn(modelRange.endLineNumber));
            return new range_1.Range(start.lineNumber, start.column, end.lineNumber, end.column);
        };
        ViewModel.prototype.convertModelSelectionToViewSelection = function (modelSelection) {
            var selectionStart = this.convertModelPositionToViewPosition(modelSelection.selectionStartLineNumber, modelSelection.selectionStartColumn);
            var position = this.convertModelPositionToViewPosition(modelSelection.positionLineNumber, modelSelection.positionColumn);
            return new selection_1.Selection(selectionStart.lineNumber, selectionStart.column, position.lineNumber, position.column);
        };
        ViewModel.prototype.modelPositionIsVisible = function (position) {
            return this.lines.inputPositionIsVisible(position.lineNumber, position.column);
        };
        return ViewModel;
    }(eventEmitter_1.EventEmitter));
    exports.ViewModel = ViewModel;
});

define(__m[126], __M([0,1,62,21,4,24,40]), function (require, exports, editOperation_1, position_1, range_1, selection_1, languageConfigurationRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var BlockCommentCommand = (function () {
        function BlockCommentCommand(selection) {
            this._selection = selection;
            this._usedEndToken = null;
        }
        BlockCommentCommand._haystackHasNeedleAtOffset = function (haystack, needle, offset) {
            if (offset < 0) {
                return false;
            }
            var needleLength = needle.length;
            var haystackLength = haystack.length;
            if (offset + needleLength > haystackLength) {
                return false;
            }
            for (var i = 0; i < needleLength; i++) {
                if (haystack.charCodeAt(offset + i) !== needle.charCodeAt(i)) {
                    return false;
                }
            }
            return true;
        };
        BlockCommentCommand.prototype._createOperationsForBlockComment = function (selection, config, model, builder) {
            var startLineNumber = selection.startLineNumber;
            var startColumn = selection.startColumn;
            var endLineNumber = selection.endLineNumber;
            var endColumn = selection.endColumn;
            var startToken = config.blockCommentStartToken;
            var endToken = config.blockCommentEndToken;
            var startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startColumn - 1 + startToken.length);
            var endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, endColumn - 1 - endToken.length);
            var ops;
            if (startTokenIndex !== -1 && endTokenIndex !== -1) {
                ops = BlockCommentCommand._createRemoveBlockCommentOperations({
                    startLineNumber: startLineNumber,
                    startColumn: startTokenIndex + 1 + startToken.length,
                    endLineNumber: endLineNumber,
                    endColumn: endTokenIndex + 1
                }, startToken, endToken);
            }
            else {
                ops = BlockCommentCommand._createAddBlockCommentOperations(selection, startToken, endToken);
                this._usedEndToken = ops.length === 1 ? endToken : null;
            }
            for (var i = 0; i < ops.length; i++) {
                builder.addEditOperation(ops[i].range, ops[i].text);
            }
        };
        BlockCommentCommand._createRemoveBlockCommentOperations = function (r, startToken, endToken) {
            var res = [];
            if (!range_1.Range.isEmpty(r)) {
                // Remove block comment start
                res.push(editOperation_1.EditOperation.delete(new range_1.Range(r.startLineNumber, r.startColumn - startToken.length, r.startLineNumber, r.startColumn)));
                // Remove block comment end
                res.push(editOperation_1.EditOperation.delete(new range_1.Range(r.endLineNumber, r.endColumn, r.endLineNumber, r.endColumn + endToken.length)));
            }
            else {
                // Remove both continuously
                res.push(editOperation_1.EditOperation.delete(new range_1.Range(r.startLineNumber, r.startColumn - startToken.length, r.endLineNumber, r.endColumn + endToken.length)));
            }
            return res;
        };
        BlockCommentCommand._createAddBlockCommentOperations = function (r, startToken, endToken) {
            var res = [];
            if (!range_1.Range.isEmpty(r)) {
                // Insert block comment start
                res.push(editOperation_1.EditOperation.insert(new position_1.Position(r.startLineNumber, r.startColumn), startToken));
                // Insert block comment end
                res.push(editOperation_1.EditOperation.insert(new position_1.Position(r.endLineNumber, r.endColumn), endToken));
            }
            else {
                // Insert both continuously
                res.push(editOperation_1.EditOperation.replace(new range_1.Range(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn), startToken + endToken));
            }
            return res;
        };
        BlockCommentCommand.prototype.getEditOperations = function (model, builder) {
            var startLineNumber = this._selection.startLineNumber;
            var startColumn = this._selection.startColumn;
            var endLineNumber = this._selection.endLineNumber;
            var endColumn = this._selection.endColumn;
            var modeId = model.getModeIdAtPosition(startLineNumber, startColumn);
            var config = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getComments(modeId);
            if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
                // Mode does not support block comments
                return;
            }
            this._createOperationsForBlockComment({
                startLineNumber: startLineNumber,
                startColumn: startColumn,
                endLineNumber: endLineNumber,
                endColumn: endColumn
            }, config, model, builder);
        };
        BlockCommentCommand.prototype.computeCursorState = function (model, helper) {
            var inverseEditOperations = helper.getInverseEditOperations();
            if (inverseEditOperations.length === 2) {
                var startTokenEditOperation = inverseEditOperations[0];
                var endTokenEditOperation = inverseEditOperations[1];
                return new selection_1.Selection(startTokenEditOperation.range.endLineNumber, startTokenEditOperation.range.endColumn, endTokenEditOperation.range.startLineNumber, endTokenEditOperation.range.startColumn);
            }
            else {
                var srcRange = inverseEditOperations[0].range;
                var deltaColumn = this._usedEndToken ? -this._usedEndToken.length : 0;
                return new selection_1.Selection(srcRange.endLineNumber, srcRange.endColumn + deltaColumn, srcRange.endLineNumber, srcRange.endColumn + deltaColumn);
            }
        };
        return BlockCommentCommand;
    }());
    exports.BlockCommentCommand = BlockCommentCommand;
});

define(__m[224], __M([0,1,10,62,21,4,24,126,40]), function (require, exports, strings, editOperation_1, position_1, range_1, selection_1, blockCommentCommand_1, languageConfigurationRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    (function (Type) {
        Type[Type["Toggle"] = 0] = "Toggle";
        Type[Type["ForceAdd"] = 1] = "ForceAdd";
        Type[Type["ForceRemove"] = 2] = "ForceRemove";
    })(exports.Type || (exports.Type = {}));
    var Type = exports.Type;
    var LineCommentCommand = (function () {
        function LineCommentCommand(selection, tabSize, type) {
            this._selection = selection;
            this._tabSize = tabSize;
            this._type = type;
            this._deltaColumn = 0;
        }
        /**
         * Do an initial pass over the lines and gather info about the line comment string.
         * Returns null if any of the lines doesn't support a line comment string.
         */
        LineCommentCommand._gatherPreflightCommentStrings = function (model, startLineNumber, endLineNumber) {
            var lines = [], config, commentStr, seenModes = Object.create(null), i, lineCount, lineNumber, modeId;
            for (i = 0, lineCount = endLineNumber - startLineNumber + 1; i < lineCount; i++) {
                lineNumber = startLineNumber + i;
                modeId = model.getModeIdAtPosition(lineNumber, 1);
                // Find the commentStr for this line, if none is found then bail out: we cannot do line comments
                if (seenModes[modeId]) {
                    commentStr = seenModes[modeId];
                }
                else {
                    config = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getComments(modeId);
                    commentStr = (config ? config.lineCommentToken : null);
                    if (!commentStr) {
                        // Mode does not support line comments
                        return null;
                    }
                    seenModes[modeId] = commentStr;
                }
                lines.push({
                    ignore: false,
                    commentStr: commentStr,
                    commentStrOffset: 0,
                    commentStrLength: commentStr.length
                });
            }
            return lines;
        };
        /**
         * Analyze lines and decide which lines are relevant and what the toggle should do.
         * Also, build up several offsets and lengths useful in the generation of editor operations.
         */
        LineCommentCommand._analyzeLines = function (type, model, lines, startLineNumber) {
            var lineData, lineContentStartOffset, commentStrEndOffset, i, lineCount, lineNumber, shouldRemoveComments, lineContent, _space = ' '.charCodeAt(0), onlyWhitespaceLines = true;
            if (type === Type.Toggle) {
                shouldRemoveComments = true;
            }
            else if (type === Type.ForceAdd) {
                shouldRemoveComments = false;
            }
            else {
                shouldRemoveComments = true;
            }
            for (i = 0, lineCount = lines.length; i < lineCount; i++) {
                lineData = lines[i];
                lineNumber = startLineNumber + i;
                lineContent = model.getLineContent(lineNumber);
                lineContentStartOffset = strings.firstNonWhitespaceIndex(lineContent);
                if (lineContentStartOffset === -1) {
                    // Empty or whitespace only line
                    if (type === Type.Toggle) {
                        lineData.ignore = true;
                    }
                    else if (type === Type.ForceAdd) {
                        lineData.ignore = true;
                    }
                    else {
                        lineData.ignore = true;
                    }
                    lineData.commentStrOffset = lineContent.length;
                    continue;
                }
                onlyWhitespaceLines = false;
                lineData.ignore = false;
                lineData.commentStrOffset = lineContentStartOffset;
                if (shouldRemoveComments && !blockCommentCommand_1.BlockCommentCommand._haystackHasNeedleAtOffset(lineContent, lineData.commentStr, lineContentStartOffset)) {
                    if (type === Type.Toggle) {
                        // Every line so far has been a line comment, but this one is not
                        shouldRemoveComments = false;
                    }
                    else if (type === Type.ForceAdd) {
                    }
                    else {
                        lineData.ignore = true;
                    }
                }
                if (shouldRemoveComments) {
                    commentStrEndOffset = lineContentStartOffset + lineData.commentStrLength;
                    if (commentStrEndOffset < lineContent.length && lineContent.charCodeAt(commentStrEndOffset) === _space) {
                        lineData.commentStrLength += 1;
                    }
                }
            }
            if (type === Type.Toggle && onlyWhitespaceLines) {
                // For only whitespace lines, we insert comments
                shouldRemoveComments = false;
                // Also, no longer ignore them
                for (i = 0, lineCount = lines.length; i < lineCount; i++) {
                    lines[i].ignore = false;
                }
            }
            return {
                supported: true,
                shouldRemoveComments: shouldRemoveComments,
                lines: lines
            };
        };
        /**
         * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments
         */
        LineCommentCommand._gatherPreflightData = function (type, model, startLineNumber, endLineNumber) {
            var lines = LineCommentCommand._gatherPreflightCommentStrings(model, startLineNumber, endLineNumber);
            if (lines === null) {
                return {
                    supported: false,
                    shouldRemoveComments: false,
                    lines: null
                };
            }
            return LineCommentCommand._analyzeLines(type, model, lines, startLineNumber);
        };
        /**
         * Given a successful analysis, execute either insert line comments, either remove line comments
         */
        LineCommentCommand.prototype._executeLineComments = function (model, builder, data, s) {
            var ops;
            if (data.shouldRemoveComments) {
                ops = LineCommentCommand._createRemoveLineCommentsOperations(data.lines, s.startLineNumber);
            }
            else {
                LineCommentCommand._normalizeInsertionPoint(model, data.lines, s.startLineNumber, this._tabSize);
                ops = LineCommentCommand._createAddLineCommentsOperations(data.lines, s.startLineNumber);
            }
            var cursorPosition = new position_1.Position(s.positionLineNumber, s.positionColumn);
            for (var i = 0, len = ops.length; i < len; i++) {
                builder.addEditOperation(ops[i].range, ops[i].text);
                if (ops[i].range.isEmpty() && ops[i].range.getStartPosition().equals(cursorPosition)) {
                    this._deltaColumn = ops[i].text.length;
                }
            }
            this._selectionId = builder.trackSelection(s);
        };
        LineCommentCommand.prototype._attemptRemoveBlockComment = function (model, s, startToken, endToken) {
            var startLineNumber = s.startLineNumber;
            var endLineNumber = s.endLineNumber;
            var startTokenAllowedBeforeColumn = endToken.length + Math.max(model.getLineFirstNonWhitespaceColumn(s.startLineNumber), s.startColumn);
            var startTokenIndex = model.getLineContent(startLineNumber).lastIndexOf(startToken, startTokenAllowedBeforeColumn - 1);
            var endTokenIndex = model.getLineContent(endLineNumber).indexOf(endToken, s.endColumn - 1 - startToken.length);
            if (startTokenIndex !== -1 && endTokenIndex === -1) {
                endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
                endLineNumber = startLineNumber;
            }
            if (startTokenIndex === -1 && endTokenIndex !== -1) {
                startTokenIndex = model.getLineContent(endLineNumber).lastIndexOf(startToken, endTokenIndex);
                startLineNumber = endLineNumber;
            }
            if (s.isEmpty() && (startTokenIndex === -1 || endTokenIndex === -1)) {
                startTokenIndex = model.getLineContent(startLineNumber).indexOf(startToken);
                if (startTokenIndex !== -1) {
                    endTokenIndex = model.getLineContent(startLineNumber).indexOf(endToken, startTokenIndex + startToken.length);
                }
            }
            if (startTokenIndex !== -1 && endTokenIndex !== -1) {
                return blockCommentCommand_1.BlockCommentCommand._createRemoveBlockCommentOperations({
                    startLineNumber: startLineNumber,
                    startColumn: startTokenIndex + startToken.length + 1,
                    endLineNumber: endLineNumber,
                    endColumn: endTokenIndex + 1
                }, startToken, endToken);
            }
            return null;
        };
        /**
         * Given an unsuccessful analysis, delegate to the block comment command
         */
        LineCommentCommand.prototype._executeBlockComment = function (model, builder, s) {
            var modeId = model.getModeIdAtPosition(s.startLineNumber, s.startColumn);
            var config = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getComments(modeId);
            if (!config || !config.blockCommentStartToken || !config.blockCommentEndToken) {
                // Mode does not support block comments
                return;
            }
            var startToken = config.blockCommentStartToken;
            var endToken = config.blockCommentEndToken;
            var ops = this._attemptRemoveBlockComment(model, s, startToken, endToken);
            if (!ops) {
                if (s.isEmpty()) {
                    var lineContent = model.getLineContent(s.startLineNumber);
                    var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(lineContent);
                    if (firstNonWhitespaceIndex === -1) {
                        // Line is empty or contains only whitespace
                        firstNonWhitespaceIndex = lineContent.length;
                    }
                    ops = blockCommentCommand_1.BlockCommentCommand._createAddBlockCommentOperations({
                        startLineNumber: s.startLineNumber,
                        startColumn: firstNonWhitespaceIndex + 1,
                        endLineNumber: s.startLineNumber,
                        endColumn: lineContent.length + 1
                    }, startToken, endToken);
                }
                else {
                    ops = blockCommentCommand_1.BlockCommentCommand._createAddBlockCommentOperations({
                        startLineNumber: s.startLineNumber,
                        startColumn: model.getLineFirstNonWhitespaceColumn(s.startLineNumber),
                        endLineNumber: s.endLineNumber,
                        endColumn: model.getLineMaxColumn(s.endLineNumber)
                    }, startToken, endToken);
                }
                if (ops.length === 1) {
                    this._deltaColumn = startToken.length;
                }
            }
            this._selectionId = builder.trackSelection(s);
            for (var i = 0; i < ops.length; i++) {
                builder.addEditOperation(ops[i].range, ops[i].text);
            }
        };
        LineCommentCommand.prototype.getEditOperations = function (model, builder) {
            var s = this._selection;
            this._moveEndPositionDown = false;
            if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
                this._moveEndPositionDown = true;
                s = s.setEndPosition(s.endLineNumber - 1, model.getLineMaxColumn(s.endLineNumber - 1));
            }
            var data = LineCommentCommand._gatherPreflightData(this._type, model, s.startLineNumber, s.endLineNumber);
            if (data.supported) {
                return this._executeLineComments(model, builder, data, s);
            }
            return this._executeBlockComment(model, builder, s);
        };
        LineCommentCommand.prototype.computeCursorState = function (model, helper) {
            var result = helper.getTrackedSelection(this._selectionId);
            if (this._moveEndPositionDown) {
                result = result.setEndPosition(result.endLineNumber + 1, 1);
            }
            return new selection_1.Selection(result.startLineNumber, result.startColumn + this._deltaColumn, result.endLineNumber, result.endColumn + this._deltaColumn);
        };
        /**
         * Generate edit operations in the remove line comment case
         */
        LineCommentCommand._createRemoveLineCommentsOperations = function (lines, startLineNumber) {
            var i, len, lineData, res = [];
            for (i = 0, len = lines.length; i < len; i++) {
                lineData = lines[i];
                if (lineData.ignore) {
                    continue;
                }
                res.push(editOperation_1.EditOperation.delete(new range_1.Range(startLineNumber + i, lineData.commentStrOffset + 1, startLineNumber + i, lineData.commentStrOffset + lineData.commentStrLength + 1)));
            }
            return res;
        };
        /**
         * Generate edit operations in the add line comment case
         */
        LineCommentCommand._createAddLineCommentsOperations = function (lines, startLineNumber) {
            var i, len, lineData, res = [];
            for (i = 0, len = lines.length; i < len; i++) {
                lineData = lines[i];
                if (lineData.ignore) {
                    continue;
                }
                res.push(editOperation_1.EditOperation.insert(new position_1.Position(startLineNumber + i, lineData.commentStrOffset + 1), lineData.commentStr + ' '));
            }
            return res;
        };
        // TODO@Alex -> duplicated in characterHardWrappingLineMapper
        LineCommentCommand.nextVisibleColumn = function (currentVisibleColumn, tabSize, isTab, columnSize) {
            if (isTab) {
                return currentVisibleColumn + (tabSize - (currentVisibleColumn % tabSize));
            }
            return currentVisibleColumn + columnSize;
        };
        /**
         * Adjust insertion points to have them vertically aligned in the add line comment case
         */
        LineCommentCommand._normalizeInsertionPoint = function (model, lines, startLineNumber, tabSize) {
            var minVisibleColumn = Number.MAX_VALUE, i, len, lineContent, j, lenJ, currentVisibleColumn, _tab = '\t'.charCodeAt(0);
            for (i = 0, len = lines.length; i < len; i++) {
                if (lines[i].ignore) {
                    continue;
                }
                lineContent = model.getLineContent(startLineNumber + i);
                currentVisibleColumn = 0;
                for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {
                    currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === _tab, 1);
                }
                if (currentVisibleColumn < minVisibleColumn) {
                    minVisibleColumn = currentVisibleColumn;
                }
            }
            minVisibleColumn = Math.floor(minVisibleColumn / tabSize) * tabSize;
            for (i = 0, len = lines.length; i < len; i++) {
                if (lines[i].ignore) {
                    continue;
                }
                lineContent = model.getLineContent(startLineNumber + i);
                currentVisibleColumn = 0;
                for (j = 0, lenJ = lines[i].commentStrOffset; currentVisibleColumn < minVisibleColumn && j < lenJ; j++) {
                    currentVisibleColumn = LineCommentCommand.nextVisibleColumn(currentVisibleColumn, tabSize, lineContent.charCodeAt(j) === _tab, 1);
                }
                if (currentVisibleColumn > minVisibleColumn) {
                    lines[i].commentStrOffset = j - 1;
                }
                else {
                    lines[i].commentStrOffset = j;
                }
            }
        };
        return LineCommentCommand;
    }());
    exports.LineCommentCommand = LineCommentCommand;
});






define(__m[127], __M([0,1,47,23,31,4,3]), function (require, exports, assert, eventEmitter_1, objects, range_1, lifecycle_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var defaultOptions = {
        followsCaret: true,
        ignoreCharChanges: true,
        alwaysRevealFirst: true
    };
    /**
     * Create a new diff navigator for the provided diff editor.
     */
    var DiffNavigator = (function (_super) {
        __extends(DiffNavigator, _super);
        function DiffNavigator(editor, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            _super.call(this, [
                DiffNavigator.Events.UPDATED
            ]);
            this.editor = editor;
            this.options = objects.mixin(options, defaultOptions, false);
            this.disposed = false;
            this.toUnbind = [];
            this.nextIdx = -1;
            this.ranges = [];
            this.ignoreSelectionChange = false;
            this.revealFirst = this.options.alwaysRevealFirst;
            // hook up to diff editor for diff, disposal, and caret move
            this.toUnbind.push(this.editor.onDidDispose(function () { return _this.dispose(); }));
            this.toUnbind.push(this.editor.onDidUpdateDiff(function () { return _this.onDiffUpdated(); }));
            if (this.options.followsCaret) {
                this.toUnbind.push(this.editor.getModifiedEditor().onDidChangeCursorPosition(function (e) {
                    if (_this.ignoreSelectionChange) {
                        return;
                    }
                    _this.nextIdx = -1;
                }));
            }
            if (this.options.alwaysRevealFirst) {
                this.toUnbind.push(this.editor.getModifiedEditor().onDidChangeModel(function (e) {
                    _this.revealFirst = true;
                }));
            }
            // init things
            this.init();
        }
        DiffNavigator.prototype.init = function () {
            var changes = this.editor.getLineChanges();
            if (!changes) {
                return;
            }
        };
        DiffNavigator.prototype.onDiffUpdated = function () {
            this.init();
            this.compute(this.editor.getLineChanges());
            if (this.revealFirst) {
                // Only reveal first on first non-null changes
                if (this.editor.getLineChanges() !== null) {
                    this.revealFirst = false;
                    this.nextIdx = -1;
                    this.next();
                }
            }
        };
        DiffNavigator.prototype.compute = function (lineChanges) {
            var _this = this;
            // new ranges
            this.ranges = [];
            if (lineChanges) {
                // create ranges from changes
                lineChanges.forEach(function (lineChange) {
                    if (!_this.options.ignoreCharChanges && lineChange.charChanges) {
                        lineChange.charChanges.forEach(function (charChange) {
                            _this.ranges.push({
                                rhs: true,
                                range: new range_1.Range(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn)
                            });
                        });
                    }
                    else {
                        _this.ranges.push({
                            rhs: true,
                            range: new range_1.Range(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedStartLineNumber, 1)
                        });
                    }
                });
            }
            // sort
            this.ranges.sort(function (left, right) {
                if (left.range.getStartPosition().isBeforeOrEqual(right.range.getStartPosition())) {
                    return -1;
                }
                else if (right.range.getStartPosition().isBeforeOrEqual(left.range.getStartPosition())) {
                    return 1;
                }
                else {
                    return 0;
                }
            });
            this.emit(DiffNavigator.Events.UPDATED, {});
        };
        DiffNavigator.prototype.initIdx = function (fwd) {
            var found = false;
            var position = this.editor.getPosition();
            for (var i = 0, len = this.ranges.length; i < len && !found; i++) {
                var range = this.ranges[i].range;
                if (position.isBeforeOrEqual(range.getStartPosition())) {
                    this.nextIdx = i + (fwd ? 0 : -1);
                    found = true;
                }
            }
            if (!found) {
                // after the last change
                this.nextIdx = fwd ? 0 : this.ranges.length - 1;
            }
            if (this.nextIdx < 0) {
                this.nextIdx = this.ranges.length - 1;
            }
        };
        DiffNavigator.prototype.move = function (fwd) {
            assert.ok(!this.disposed, 'Illegal State - diff navigator has been disposed');
            if (!this.canNavigate()) {
                return;
            }
            if (this.nextIdx === -1) {
                this.initIdx(fwd);
            }
            else if (fwd) {
                this.nextIdx += 1;
                if (this.nextIdx >= this.ranges.length) {
                    this.nextIdx = 0;
                }
            }
            else {
                this.nextIdx -= 1;
                if (this.nextIdx < 0) {
                    this.nextIdx = this.ranges.length - 1;
                }
            }
            var info = this.ranges[this.nextIdx];
            this.ignoreSelectionChange = true;
            try {
                var pos = info.range.getStartPosition();
                this.editor.setPosition(pos);
                this.editor.revealPositionInCenter(pos);
            }
            finally {
                this.ignoreSelectionChange = false;
            }
        };
        DiffNavigator.prototype.canNavigate = function () {
            return this.ranges && this.ranges.length > 0;
        };
        DiffNavigator.prototype.next = function () {
            this.move(true);
        };
        DiffNavigator.prototype.previous = function () {
            this.move(false);
        };
        DiffNavigator.prototype.dispose = function () {
            this.toUnbind = lifecycle_1.dispose(this.toUnbind);
            this.ranges = null;
            this.disposed = true;
            _super.prototype.dispose.call(this);
        };
        DiffNavigator.Events = {
            UPDATED: 'navigation.updated'
        };
        return DiffNavigator;
    }(eventEmitter_1.EventEmitter));
    exports.DiffNavigator = DiffNavigator;
});

define(__m[128], __M([0,1,14,3,10,110,21,4,7,482,484,24]), function (require, exports, async_1, lifecycle_1, strings, replaceCommand_1, position_1, range_1, editorCommon, findDecorations_1, replaceAllCommand_1, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.FIND_IDS = {
        StartFindAction: 'actions.find',
        NextMatchFindAction: 'editor.action.nextMatchFindAction',
        PreviousMatchFindAction: 'editor.action.previousMatchFindAction',
        NextSelectionMatchFindAction: 'editor.action.nextSelectionMatchFindAction',
        PreviousSelectionMatchFindAction: 'editor.action.previousSelectionMatchFindAction',
        AddSelectionToNextFindMatchAction: 'editor.action.addSelectionToNextFindMatch',
        MoveSelectionToNextFindMatchAction: 'editor.action.moveSelectionToNextFindMatch',
        StartFindReplaceAction: 'editor.action.startFindReplaceAction',
        CloseFindWidgetCommand: 'closeFindWidget',
        ToggleCaseSensitiveCommand: 'toggleFindCaseSensitive',
        ToggleWholeWordCommand: 'toggleFindWholeWord',
        ToggleRegexCommand: 'toggleFindRegex',
        ReplaceOneAction: 'editor.action.replaceOne',
        ReplaceAllAction: 'editor.action.replaceAll',
        SelectAllMatchesAction: 'editor.action.selectAllMatches'
    };
    exports.MATCHES_LIMIT = 999;
    var FindModelBoundToEditorModel = (function () {
        function FindModelBoundToEditorModel(editor, state) {
            var _this = this;
            this._editor = editor;
            this._state = state;
            this._toDispose = [];
            this._decorations = new findDecorations_1.FindDecorations(editor);
            this._toDispose.push(this._decorations);
            this._updateDecorationsScheduler = new async_1.RunOnceScheduler(function () { return _this.research(false); }, 100);
            this._toDispose.push(this._updateDecorationsScheduler);
            this._toDispose.push(this._editor.onDidChangeCursorPosition(function (e) {
                if (e.reason === editorCommon.CursorChangeReason.Explicit
                    || e.reason === editorCommon.CursorChangeReason.Undo
                    || e.reason === editorCommon.CursorChangeReason.Redo) {
                    _this._decorations.setStartPosition(_this._editor.getPosition());
                }
            }));
            this._ignoreModelContentChanged = false;
            this._toDispose.push(this._editor.onDidChangeModelRawContent(function (e) {
                if (_this._ignoreModelContentChanged) {
                    return;
                }
                if (e.changeType === editorCommon.EventType.ModelRawContentChangedFlush) {
                    // a model.setValue() was called
                    _this._decorations.reset();
                }
                _this._decorations.setStartPosition(_this._editor.getPosition());
                _this._updateDecorationsScheduler.schedule();
            }));
            this._toDispose.push(this._state.addChangeListener(function (e) { return _this._onStateChanged(e); }));
            this.research(false, this._state.searchScope);
        }
        FindModelBoundToEditorModel.prototype.dispose = function () {
            this._toDispose = lifecycle_1.dispose(this._toDispose);
        };
        FindModelBoundToEditorModel.prototype._onStateChanged = function (e) {
            if (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) {
                if (e.searchScope) {
                    this.research(e.moveCursor, this._state.searchScope);
                }
                else {
                    this.research(e.moveCursor);
                }
            }
        };
        FindModelBoundToEditorModel._getSearchRange = function (model, searchOnlyEditableRange, findScope) {
            var searchRange;
            if (searchOnlyEditableRange) {
                searchRange = model.getEditableRange();
            }
            else {
                searchRange = model.getFullModelRange();
            }
            // If we have set now or before a find scope, use it for computing the search range
            if (findScope) {
                searchRange = searchRange.intersectRanges(findScope);
            }
            return searchRange;
        };
        FindModelBoundToEditorModel.prototype.research = function (moveCursor, newFindScope) {
            var findScope = null;
            if (typeof newFindScope !== 'undefined') {
                findScope = newFindScope;
            }
            else {
                findScope = this._decorations.getFindScope();
            }
            if (findScope !== null) {
                findScope = new range_1.Range(findScope.startLineNumber, 1, findScope.endLineNumber, this._editor.getModel().getLineMaxColumn(findScope.endLineNumber));
            }
            var findMatches = this._findMatches(findScope, exports.MATCHES_LIMIT);
            this._decorations.set(findMatches, findScope);
            this._state.changeMatchInfo(this._decorations.getCurrentMatchesPosition(this._editor.getSelection()), this._decorations.getCount());
            if (moveCursor) {
                this._moveToNextMatch(this._decorations.getStartPosition());
            }
        };
        FindModelBoundToEditorModel.prototype._hasMatches = function () {
            return (this._state.matchesCount > 0);
        };
        FindModelBoundToEditorModel.prototype._cannotFind = function () {
            if (!this._hasMatches()) {
                var findScope = this._decorations.getFindScope();
                if (findScope) {
                    // Reveal the selection so user is reminded that 'selection find' is on.
                    this._editor.revealRangeInCenterIfOutsideViewport(findScope);
                }
                return true;
            }
            return false;
        };
        FindModelBoundToEditorModel.prototype._moveToPrevMatch = function (before, isRecursed) {
            if (isRecursed === void 0) { isRecursed = false; }
            if (this._cannotFind()) {
                return;
            }
            var findScope = this._decorations.getFindScope();
            var searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), this._state.isReplaceRevealed, findScope);
            // ...(----)...|...
            if (searchRange.getEndPosition().isBefore(before)) {
                before = searchRange.getEndPosition();
            }
            // ...|...(----)...
            if (before.isBefore(searchRange.getStartPosition())) {
                before = searchRange.getEndPosition();
            }
            var lineNumber = before.lineNumber, column = before.column;
            var model = this._editor.getModel();
            if (this._state.isRegex) {
                // Force advancing to the previous line if searching for $
                if (this._state.searchString === '$') {
                    if (lineNumber === 1) {
                        lineNumber = model.getLineCount();
                    }
                    else {
                        lineNumber--;
                    }
                    column = model.getLineMaxColumn(lineNumber);
                }
                // Force advancing to the previous line if searching for ^ or ^$ and cursor is at the beginning
                if (this._state.searchString === '^' || this._state.searchString === '^$') {
                    if (column === 1) {
                        if (lineNumber === 1) {
                            lineNumber = model.getLineCount();
                        }
                        else {
                            lineNumber--;
                        }
                        column = model.getLineMaxColumn(lineNumber);
                    }
                }
            }
            var position = new position_1.Position(lineNumber, column);
            var prevMatch = model.findPreviousMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord);
            if (!prevMatch) {
                // there is precisely one match and selection is on top of it
                return;
            }
            if (!isRecursed && !searchRange.containsRange(prevMatch)) {
                return this._moveToPrevMatch(prevMatch.getStartPosition(), true);
            }
            var matchesPosition = this._decorations.setCurrentFindMatch(prevMatch);
            this._state.changeMatchInfo(matchesPosition, this._decorations.getCount());
            this._editor.setSelection(prevMatch);
            this._editor.revealRangeInCenterIfOutsideViewport(prevMatch);
        };
        FindModelBoundToEditorModel.prototype.moveToPrevMatch = function () {
            this._moveToPrevMatch(this._editor.getSelection().getStartPosition());
        };
        FindModelBoundToEditorModel.prototype._moveToNextMatch = function (after, isRecursed) {
            if (isRecursed === void 0) { isRecursed = false; }
            if (this._cannotFind()) {
                return;
            }
            var findScope = this._decorations.getFindScope();
            var searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), this._state.isReplaceRevealed, findScope);
            // ...(----)...|...
            if (searchRange.getEndPosition().isBefore(after)) {
                after = searchRange.getStartPosition();
            }
            // ...|...(----)...
            if (after.isBefore(searchRange.getStartPosition())) {
                after = searchRange.getStartPosition();
            }
            var lineNumber = after.lineNumber, column = after.column;
            var model = this._editor.getModel();
            if (this._state.isRegex) {
                // Force advancing to the next line if searching for ^ or ^$
                if (this._state.searchString === '^' || this._state.searchString === '^$') {
                    if (lineNumber === model.getLineCount()) {
                        lineNumber = 1;
                    }
                    else {
                        lineNumber++;
                    }
                    column = 1;
                }
                // Force advancing to the next line if searching for $ and at the end of the line
                if (this._state.searchString === '$') {
                    if (column === model.getLineMaxColumn(lineNumber)) {
                        if (lineNumber === model.getLineCount()) {
                            lineNumber = 1;
                        }
                        else {
                            lineNumber++;
                        }
                        column = 1;
                    }
                }
            }
            var position = new position_1.Position(lineNumber, column);
            var nextMatch = model.findNextMatch(this._state.searchString, position, this._state.isRegex, this._state.matchCase, this._state.wholeWord);
            if (!nextMatch) {
                // there is precisely one match and selection is on top of it
                return;
            }
            if (!isRecursed && !searchRange.containsRange(nextMatch)) {
                return this._moveToNextMatch(nextMatch.getEndPosition(), true);
            }
            var matchesPosition = this._decorations.setCurrentFindMatch(nextMatch);
            this._state.changeMatchInfo(matchesPosition, this._decorations.getCount());
            this._editor.setSelection(nextMatch);
            this._editor.revealRangeInCenterIfOutsideViewport(nextMatch);
        };
        FindModelBoundToEditorModel.prototype.moveToNextMatch = function () {
            this._moveToNextMatch(this._editor.getSelection().getEndPosition());
        };
        FindModelBoundToEditorModel.prototype.getReplaceString = function (matchedString) {
            if (!this._state.isRegex) {
                return this._state.replaceString;
            }
            var regexp = strings.createRegExp(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord, true);
            // Parse the replace string to support that \t or \n mean the right thing
            var parsedReplaceString = parseReplaceString(this._state.replaceString);
            return matchedString.replace(regexp, parsedReplaceString);
        };
        FindModelBoundToEditorModel.prototype._rangeIsMatch = function (range) {
            var selection = this._editor.getSelection();
            var selectionText = this._editor.getModel().getValueInRange(selection);
            var regexp = strings.createSafeRegExp(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord);
            var m = selectionText.match(regexp);
            return (m && m[0].length === selectionText.length);
        };
        FindModelBoundToEditorModel.prototype.replace = function () {
            if (!this._hasMatches()) {
                return;
            }
            var selection = this._editor.getSelection();
            var selectionText = this._editor.getModel().getValueInRange(selection);
            if (this._rangeIsMatch(selection)) {
                // selection sits on a find match => replace it!
                var replaceString = this.getReplaceString(selectionText);
                var command = new replaceCommand_1.ReplaceCommand(selection, replaceString);
                this._executeEditorCommand('replace', command);
                this._decorations.setStartPosition(new position_1.Position(selection.startLineNumber, selection.startColumn + replaceString.length));
                this.research(true);
            }
            else {
                this._decorations.setStartPosition(this._editor.getPosition());
                this.moveToNextMatch();
            }
        };
        FindModelBoundToEditorModel.prototype._findMatches = function (findScope, limitResultCount) {
            var searchRange = FindModelBoundToEditorModel._getSearchRange(this._editor.getModel(), this._state.isReplaceRevealed, findScope);
            return this._editor.getModel().findMatches(this._state.searchString, searchRange, this._state.isRegex, this._state.matchCase, this._state.wholeWord, limitResultCount);
        };
        FindModelBoundToEditorModel.prototype.replaceAll = function () {
            if (!this._hasMatches()) {
                return;
            }
            var model = this._editor.getModel();
            var findScope = this._decorations.getFindScope();
            // Get all the ranges (even more than the highlighted ones)
            var ranges = this._findMatches(findScope, Number.MAX_VALUE);
            var replaceStrings = [];
            for (var i = 0, len = ranges.length; i < len; i++) {
                replaceStrings.push(this.getReplaceString(model.getValueInRange(ranges[i])));
            }
            var command = new replaceAllCommand_1.ReplaceAllCommand(this._editor.getSelection(), ranges, replaceStrings);
            this._executeEditorCommand('replaceAll', command);
            this.research(false);
        };
        FindModelBoundToEditorModel.prototype.selectAllMatches = function () {
            if (!this._hasMatches()) {
                return;
            }
            var findScope = this._decorations.getFindScope();
            // Get all the ranges (even more than the highlighted ones)
            var ranges = this._findMatches(findScope, Number.MAX_VALUE);
            this._editor.setSelections(ranges.map(function (r) { return new selection_1.Selection(r.startLineNumber, r.startColumn, r.endLineNumber, r.endColumn); }));
        };
        FindModelBoundToEditorModel.prototype._executeEditorCommand = function (source, command) {
            try {
                this._ignoreModelContentChanged = true;
                this._editor.executeCommand(source, command);
            }
            finally {
                this._ignoreModelContentChanged = false;
            }
        };
        return FindModelBoundToEditorModel;
    }());
    exports.FindModelBoundToEditorModel = FindModelBoundToEditorModel;
    var BACKSLASH_CHAR_CODE = '\\'.charCodeAt(0);
    var DOLLAR_CHAR_CODE = '$'.charCodeAt(0);
    var ZERO_CHAR_CODE = '0'.charCodeAt(0);
    var n_CHAR_CODE = 'n'.charCodeAt(0);
    var t_CHAR_CODE = 't'.charCodeAt(0);
    /**
     * \n => LF
     * \t => TAB
     * \\ => \
     * $0 => $& (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#Specifying_a_string_as_a_parameter)
     * everything else stays untouched
     */
    function parseReplaceString(input) {
        if (!input || input.length === 0) {
            return input;
        }
        var substrFrom = 0, result = '';
        for (var i = 0, len = input.length; i < len; i++) {
            var chCode = input.charCodeAt(i);
            if (chCode === BACKSLASH_CHAR_CODE) {
                // move to next char
                i++;
                if (i >= len) {
                    // string ends with a \
                    break;
                }
                var nextChCode = input.charCodeAt(i);
                var replaceWithCharacter = null;
                switch (nextChCode) {
                    case BACKSLASH_CHAR_CODE:
                        // \\ => \
                        replaceWithCharacter = '\\';
                        break;
                    case n_CHAR_CODE:
                        // \n => LF
                        replaceWithCharacter = '\n';
                        break;
                    case t_CHAR_CODE:
                        // \t => TAB
                        replaceWithCharacter = '\t';
                        break;
                }
                if (replaceWithCharacter) {
                    result += input.substring(substrFrom, i - 1) + replaceWithCharacter;
                    substrFrom = i + 1;
                }
            }
            if (chCode === DOLLAR_CHAR_CODE) {
                // move to next char
                i++;
                if (i >= len) {
                    // string ends with a $
                    break;
                }
                var nextChCode = input.charCodeAt(i);
                var replaceWithCharacter = null;
                switch (nextChCode) {
                    case ZERO_CHAR_CODE:
                        // $0 => $&
                        replaceWithCharacter = '$&';
                        break;
                }
                if (replaceWithCharacter) {
                    result += input.substring(substrFrom, i - 1) + replaceWithCharacter;
                    substrFrom = i + 1;
                }
            }
        }
        if (substrFrom === 0) {
            // no replacement occured
            return input;
        }
        return result + input.substring(substrFrom);
    }
    exports.parseReplaceString = parseReplaceString;
});

define(__m[227], __M([0,1,23,4]), function (require, exports, eventEmitter_1, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var FindReplaceState = (function () {
        function FindReplaceState() {
            this._searchString = '';
            this._replaceString = '';
            this._isRevealed = false;
            this._isReplaceRevealed = false;
            this._isRegex = false;
            this._wholeWord = false;
            this._matchCase = false;
            this._searchScope = null;
            this._matchesPosition = 0;
            this._matchesCount = 0;
            this._eventEmitter = new eventEmitter_1.EventEmitter();
        }
        Object.defineProperty(FindReplaceState.prototype, "searchString", {
            get: function () { return this._searchString; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "replaceString", {
            get: function () { return this._replaceString; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "isRevealed", {
            get: function () { return this._isRevealed; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "isReplaceRevealed", {
            get: function () { return this._isReplaceRevealed; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "isRegex", {
            get: function () { return this._isRegex; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "wholeWord", {
            get: function () { return this._wholeWord; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "matchCase", {
            get: function () { return this._matchCase; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "searchScope", {
            get: function () { return this._searchScope; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "matchesPosition", {
            get: function () { return this._matchesPosition; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FindReplaceState.prototype, "matchesCount", {
            get: function () { return this._matchesCount; },
            enumerable: true,
            configurable: true
        });
        FindReplaceState.prototype.dispose = function () {
            this._eventEmitter.dispose();
        };
        FindReplaceState.prototype.addChangeListener = function (listener) {
            return this._eventEmitter.addListener2(FindReplaceState._CHANGED_EVENT, listener);
        };
        FindReplaceState.prototype.changeMatchInfo = function (matchesPosition, matchesCount) {
            var changeEvent = {
                moveCursor: false,
                searchString: false,
                replaceString: false,
                isRevealed: false,
                isReplaceRevealed: false,
                isRegex: false,
                wholeWord: false,
                matchCase: false,
                searchScope: false,
                matchesPosition: false,
                matchesCount: false
            };
            var somethingChanged = false;
            if (matchesCount === 0) {
                matchesPosition = 0;
            }
            if (matchesPosition > matchesCount) {
                matchesPosition = matchesCount;
            }
            if (this._matchesPosition !== matchesPosition) {
                this._matchesPosition = matchesPosition;
                changeEvent.matchesPosition = true;
                somethingChanged = true;
            }
            if (this._matchesCount !== matchesCount) {
                this._matchesCount = matchesCount;
                changeEvent.matchesCount = true;
                somethingChanged = true;
            }
            if (somethingChanged) {
                this._eventEmitter.emit(FindReplaceState._CHANGED_EVENT, changeEvent);
            }
        };
        FindReplaceState.prototype.change = function (newState, moveCursor) {
            var changeEvent = {
                moveCursor: moveCursor,
                searchString: false,
                replaceString: false,
                isRevealed: false,
                isReplaceRevealed: false,
                isRegex: false,
                wholeWord: false,
                matchCase: false,
                searchScope: false,
                matchesPosition: false,
                matchesCount: false
            };
            var somethingChanged = false;
            if (typeof newState.searchString !== 'undefined') {
                if (this._searchString !== newState.searchString) {
                    this._searchString = newState.searchString;
                    changeEvent.searchString = true;
                    somethingChanged = true;
                }
            }
            if (typeof newState.replaceString !== 'undefined') {
                if (this._replaceString !== newState.replaceString) {
                    this._replaceString = newState.replaceString;
                    changeEvent.replaceString = true;
                    somethingChanged = true;
                }
            }
            if (typeof newState.isRevealed !== 'undefined') {
                if (this._isRevealed !== newState.isRevealed) {
                    this._isRevealed = newState.isRevealed;
                    changeEvent.isRevealed = true;
                    somethingChanged = true;
                }
            }
            if (typeof newState.isReplaceRevealed !== 'undefined') {
                if (this._isReplaceRevealed !== newState.isReplaceRevealed) {
                    this._isReplaceRevealed = newState.isReplaceRevealed;
                    changeEvent.isReplaceRevealed = true;
                    somethingChanged = true;
                }
            }
            if (typeof newState.isRegex !== 'undefined') {
                if (this._isRegex !== newState.isRegex) {
                    this._isRegex = newState.isRegex;
                    changeEvent.isRegex = true;
                    somethingChanged = true;
                }
            }
            if (typeof newState.wholeWord !== 'undefined') {
                if (this._wholeWord !== newState.wholeWord) {
                    this._wholeWord = newState.wholeWord;
                    changeEvent.wholeWord = true;
                    somethingChanged = true;
                }
            }
            if (typeof newState.matchCase !== 'undefined') {
                if (this._matchCase !== newState.matchCase) {
                    this._matchCase = newState.matchCase;
                    changeEvent.matchCase = true;
                    somethingChanged = true;
                }
            }
            if (typeof newState.searchScope !== 'undefined') {
                if (!range_1.Range.equalsRange(this._searchScope, newState.searchScope)) {
                    this._searchScope = newState.searchScope;
                    changeEvent.searchScope = true;
                    somethingChanged = true;
                }
            }
            if (somethingChanged) {
                this._eventEmitter.emit(FindReplaceState._CHANGED_EVENT, changeEvent);
            }
        };
        FindReplaceState._CHANGED_EVENT = 'changed';
        return FindReplaceState;
    }());
    exports.FindReplaceState = FindReplaceState;
});

define(__m[129], __M([0,1,14,8]), function (require, exports, async_1, errors_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ComputeHoverOperationState;
    (function (ComputeHoverOperationState) {
        ComputeHoverOperationState[ComputeHoverOperationState["IDLE"] = 0] = "IDLE";
        ComputeHoverOperationState[ComputeHoverOperationState["FIRST_WAIT"] = 1] = "FIRST_WAIT";
        ComputeHoverOperationState[ComputeHoverOperationState["SECOND_WAIT"] = 2] = "SECOND_WAIT";
        ComputeHoverOperationState[ComputeHoverOperationState["WAITING_FOR_ASYNC_COMPUTATION"] = 3] = "WAITING_FOR_ASYNC_COMPUTATION";
    })(ComputeHoverOperationState || (ComputeHoverOperationState = {}));
    var HoverOperation = (function () {
        function HoverOperation(computer, success, error, progress) {
            var _this = this;
            this._computer = computer;
            this._state = ComputeHoverOperationState.IDLE;
            this._firstWaitScheduler = new async_1.RunOnceScheduler(function () { return _this._triggerAsyncComputation(); }, this._getHoverTimeMillis() / 2);
            this._secondWaitScheduler = new async_1.RunOnceScheduler(function () { return _this._triggerSyncComputation(); }, this._getHoverTimeMillis() / 2);
            this._loadingMessageScheduler = new async_1.RunOnceScheduler(function () { return _this._showLoadingMessage(); }, 3 * this._getHoverTimeMillis());
            this._asyncComputationPromise = null;
            this._asyncComputationPromiseDone = false;
            this._completeCallback = success;
            this._errorCallback = error;
            this._progressCallback = progress;
        }
        HoverOperation.prototype.getComputer = function () {
            return this._computer;
        };
        HoverOperation.prototype._getHoverTimeMillis = function () {
            if (this._computer.getHoverTimeMillis) {
                return this._computer.getHoverTimeMillis();
            }
            return HoverOperation.HOVER_TIME;
        };
        HoverOperation.prototype._triggerAsyncComputation = function () {
            var _this = this;
            this._state = ComputeHoverOperationState.SECOND_WAIT;
            this._secondWaitScheduler.schedule();
            if (this._computer.computeAsync) {
                this._asyncComputationPromiseDone = false;
                this._asyncComputationPromise = this._computer.computeAsync().then(function (asyncResult) {
                    _this._asyncComputationPromiseDone = true;
                    _this._withAsyncResult(asyncResult);
                }, function () { return _this._onError; });
            }
            else {
                this._asyncComputationPromiseDone = true;
            }
        };
        HoverOperation.prototype._triggerSyncComputation = function () {
            if (this._computer.computeSync) {
                this._computer.onResult(this._computer.computeSync(), true);
            }
            if (this._asyncComputationPromiseDone) {
                this._state = ComputeHoverOperationState.IDLE;
                this._onComplete(this._computer.getResult());
            }
            else {
                this._state = ComputeHoverOperationState.WAITING_FOR_ASYNC_COMPUTATION;
                this._onProgress(this._computer.getResult());
            }
        };
        HoverOperation.prototype._showLoadingMessage = function () {
            if (this._state === ComputeHoverOperationState.WAITING_FOR_ASYNC_COMPUTATION) {
                this._onProgress(this._computer.getResultWithLoadingMessage());
            }
        };
        HoverOperation.prototype._withAsyncResult = function (asyncResult) {
            if (asyncResult) {
                this._computer.onResult(asyncResult, false);
            }
            if (this._state === ComputeHoverOperationState.WAITING_FOR_ASYNC_COMPUTATION) {
                this._state = ComputeHoverOperationState.IDLE;
                this._onComplete(this._computer.getResult());
            }
        };
        HoverOperation.prototype._onComplete = function (value) {
            if (this._completeCallback) {
                this._completeCallback(value);
            }
        };
        HoverOperation.prototype._onError = function (error) {
            if (this._errorCallback) {
                this._errorCallback(error);
            }
            else {
                errors_1.onUnexpectedError(error);
            }
        };
        HoverOperation.prototype._onProgress = function (value) {
            if (this._progressCallback) {
                this._progressCallback(value);
            }
        };
        HoverOperation.prototype.start = function () {
            if (this._state === ComputeHoverOperationState.IDLE) {
                this._state = ComputeHoverOperationState.FIRST_WAIT;
                this._firstWaitScheduler.schedule();
                this._loadingMessageScheduler.schedule();
            }
        };
        HoverOperation.prototype.cancel = function () {
            this._loadingMessageScheduler.cancel();
            if (this._state === ComputeHoverOperationState.FIRST_WAIT) {
                this._firstWaitScheduler.cancel();
            }
            if (this._state === ComputeHoverOperationState.SECOND_WAIT) {
                this._secondWaitScheduler.cancel();
                if (this._asyncComputationPromise) {
                    this._asyncComputationPromise.cancel();
                    this._asyncComputationPromise = null;
                }
            }
            if (this._state === ComputeHoverOperationState.WAITING_FOR_ASYNC_COMPUTATION) {
                if (this._asyncComputationPromise) {
                    this._asyncComputationPromise.cancel();
                    this._asyncComputationPromise = null;
                }
            }
            this._state = ComputeHoverOperationState.IDLE;
        };
        HoverOperation.HOVER_TIME = 300;
        return HoverOperation;
    }());
    exports.HoverOperation = HoverOperation;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[229], __M([0,1,8,2,17,14]), function (require, exports, errors_1, winjs_base_1, modes_1, async_1) {
    'use strict';
    function getLinks(model) {
        var promises = modes_1.LinkProviderRegistry.ordered(model).map(function (support) {
            return async_1.asWinJsPromise(function (token) {
                return support.provideLinks(model, token);
            }).then(function (result) {
                if (Array.isArray(result)) {
                    return result;
                }
            }, function (err) {
                errors_1.onUnexpectedError(err);
            });
        });
        return winjs_base_1.TPromise.join(promises).then(function (manyLinks) {
            var result = [];
            for (var _i = 0, manyLinks_1 = manyLinks; _i < manyLinks_1.length; _i++) {
                var links = manyLinks_1[_i];
                if (links) {
                    result = result.concat(links);
                }
            }
            return result;
        });
    }
    exports.getLinks = getLinks;
});

define(__m[96], __M([0,1,23,16,38,10,63,2,4]), function (require, exports, eventEmitter_1, event_1, paths_1, strings, idGenerator_1, winjs_base_1, range_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var OneReference = (function () {
        function OneReference(_parent, _range, _eventBus) {
            this._parent = _parent;
            this._range = _range;
            this._eventBus = _eventBus;
            this._id = idGenerator_1.defaultGenerator.nextId();
        }
        Object.defineProperty(OneReference.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OneReference.prototype, "model", {
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OneReference.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OneReference.prototype, "uri", {
            get: function () {
                return this._parent.uri;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OneReference.prototype, "name", {
            get: function () {
                return this._parent.name;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OneReference.prototype, "directory", {
            get: function () {
                return this._parent.directory;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(OneReference.prototype, "range", {
            get: function () {
                return this._range;
            },
            set: function (value) {
                this._range = value;
                this._eventBus.emit('ref/changed', this);
            },
            enumerable: true,
            configurable: true
        });
        return OneReference;
    }());
    exports.OneReference = OneReference;
    var FilePreview = (function () {
        function FilePreview(_value) {
            this._value = _value;
        }
        FilePreview.prototype.preview = function (range, n) {
            if (n === void 0) { n = 8; }
            var startLineNumber = range.startLineNumber, startColumn = range.startColumn, endColumn = range.endColumn;
            var word = this._value.getWordUntilPosition({ lineNumber: startLineNumber, column: startColumn - n });
            var beforeRange = new range_1.Range(startLineNumber, word.startColumn, startLineNumber, startColumn);
            var afterRange = new range_1.Range(startLineNumber, endColumn, startLineNumber, Number.MAX_VALUE);
            var ret = {
                before: this._value.getValueInRange(beforeRange).replace(/^\s+/, strings.empty),
                inside: this._value.getValueInRange(range),
                after: this._value.getValueInRange(afterRange).replace(/\s+$/, strings.empty)
            };
            return ret;
        };
        return FilePreview;
    }());
    exports.FilePreview = FilePreview;
    var FileReferences = (function () {
        function FileReferences(_parent, _uri) {
            this._parent = _parent;
            this._uri = _uri;
            this._children = [];
        }
        Object.defineProperty(FileReferences.prototype, "id", {
            get: function () {
                return this._uri.toString();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileReferences.prototype, "parent", {
            get: function () {
                return this._parent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileReferences.prototype, "children", {
            get: function () {
                return this._children;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileReferences.prototype, "uri", {
            get: function () {
                return this._uri;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileReferences.prototype, "name", {
            get: function () {
                return paths_1.basename(this.uri.fsPath);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileReferences.prototype, "directory", {
            get: function () {
                return paths_1.dirname(this.uri.fsPath);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileReferences.prototype, "preview", {
            get: function () {
                return this._preview;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FileReferences.prototype, "failure", {
            get: function () {
                return this._loadFailure;
            },
            enumerable: true,
            configurable: true
        });
        FileReferences.prototype.resolve = function (editorService) {
            var _this = this;
            if (this._resolved) {
                return winjs_base_1.TPromise.as(this);
            }
            return editorService.resolveEditorModel({ resource: this._uri }).then(function (model) {
                if (!model) {
                    throw new Error();
                }
                _this._preview = new FilePreview(model.textEditorModel);
                _this._resolved = true;
                return _this;
            }, function (err) {
                // something wrong here
                _this._children = [];
                _this._resolved = true;
                _this._loadFailure = err;
                return _this;
            });
        };
        return FileReferences;
    }());
    exports.FileReferences = FileReferences;
    var ReferencesModel = (function () {
        function ReferencesModel(references) {
            this._groups = [];
            this._references = [];
            this._eventBus = new eventEmitter_1.EventEmitter();
            this.onDidChangeReferenceRange = event_1.fromEventEmitter(this._eventBus, 'ref/changed');
            // grouping and sorting
            references.sort(ReferencesModel._compareReferences);
            var current;
            for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {
                var ref = references_1[_i];
                if (!current || current.uri.toString() !== ref.uri.toString()) {
                    // new group
                    current = new FileReferences(this, ref.uri);
                    this.groups.push(current);
                }
                // append, check for equality first!
                if (current.children.length === 0
                    || !range_1.Range.equalsRange(ref.range, current.children[current.children.length - 1].range)) {
                    var oneRef = new OneReference(current, ref.range, this._eventBus);
                    this._references.push(oneRef);
                    current.children.push(oneRef);
                }
            }
        }
        Object.defineProperty(ReferencesModel.prototype, "empty", {
            get: function () {
                return this._groups.length === 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReferencesModel.prototype, "references", {
            get: function () {
                return this._references;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ReferencesModel.prototype, "groups", {
            get: function () {
                return this._groups;
            },
            enumerable: true,
            configurable: true
        });
        ReferencesModel.prototype.nextReference = function (reference) {
            var idx = reference.parent.children.indexOf(reference), len = reference.parent.children.length, totalLength = reference.parent.parent.groups.length;
            if (idx + 1 < len || totalLength === 1) {
                return reference.parent.children[(idx + 1) % len];
            }
            idx = reference.parent.parent.groups.indexOf(reference.parent);
            idx = (idx + 1) % totalLength;
            return reference.parent.parent.groups[idx].children[0];
        };
        ReferencesModel.prototype.nearestReference = function (resource, position) {
            var nearest = this._references.map(function (ref, idx) {
                return {
                    idx: idx,
                    prefixLen: strings.commonPrefixLength(ref.uri.toString(), resource.toString()),
                    offsetDist: Math.abs(ref.range.startLineNumber - position.lineNumber) * 100 + Math.abs(ref.range.startColumn - position.column)
                };
            }).sort(function (a, b) {
                if (a.prefixLen > b.prefixLen) {
                    return -1;
                }
                else if (a.prefixLen < b.prefixLen) {
                    return 1;
                }
                else if (a.offsetDist < b.offsetDist) {
                    return -1;
                }
                else if (a.offsetDist > b.offsetDist) {
                    return 1;
                }
                else {
                    return 0;
                }
            })[0];
            if (nearest) {
                return this._references[nearest.idx];
            }
        };
        ReferencesModel._compareReferences = function (a, b) {
            if (a.uri.toString() < b.uri.toString()) {
                return -1;
            }
            else if (a.uri.toString() > b.uri.toString()) {
                return 1;
            }
            else {
                return range_1.Range.compareRangesUsingStarts(a.range, b.range);
            }
        };
        return ReferencesModel;
    }());
    exports.ReferencesModel = ReferencesModel;
});






define(__m[231], __M([0,1,4,49,83,40]), function (require, exports, range_1, supports_1, richEditBrackets_1, languageConfigurationRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    (function (TokenTreeBracket) {
        TokenTreeBracket[TokenTreeBracket["None"] = 0] = "None";
        TokenTreeBracket[TokenTreeBracket["Open"] = 1] = "Open";
        TokenTreeBracket[TokenTreeBracket["Close"] = -1] = "Close";
    })(exports.TokenTreeBracket || (exports.TokenTreeBracket = {}));
    var TokenTreeBracket = exports.TokenTreeBracket;
    var Node = (function () {
        function Node() {
        }
        Object.defineProperty(Node.prototype, "range", {
            get: function () {
                return new range_1.Range(this.start.lineNumber, this.start.column, this.end.lineNumber, this.end.column);
            },
            enumerable: true,
            configurable: true
        });
        return Node;
    }());
    exports.Node = Node;
    var NodeList = (function (_super) {
        __extends(NodeList, _super);
        function NodeList() {
            _super.apply(this, arguments);
        }
        Object.defineProperty(NodeList.prototype, "start", {
            get: function () {
                return this.hasChildren
                    ? this.children[0].start
                    : this.parent.start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NodeList.prototype, "end", {
            get: function () {
                return this.hasChildren
                    ? this.children[this.children.length - 1].end
                    : this.parent.end;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(NodeList.prototype, "hasChildren", {
            get: function () {
                return this.children && this.children.length > 0;
            },
            enumerable: true,
            configurable: true
        });
        NodeList.prototype.append = function (node) {
            if (!node) {
                return false;
            }
            node.parent = this;
            if (!this.children) {
                this.children = [];
            }
            if (node instanceof NodeList) {
                if (node.children) {
                    this.children.push.apply(this.children, node.children);
                }
            }
            else {
                this.children.push(node);
            }
            return true;
        };
        return NodeList;
    }(Node));
    exports.NodeList = NodeList;
    var Block = (function (_super) {
        __extends(Block, _super);
        function Block() {
            _super.call(this);
            this.elements = new NodeList();
            this.elements.parent = this;
        }
        Object.defineProperty(Block.prototype, "start", {
            get: function () {
                return this.open.start;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Block.prototype, "end", {
            get: function () {
                return this.close.end;
            },
            enumerable: true,
            configurable: true
        });
        return Block;
    }(Node));
    exports.Block = Block;
    function newNode(token) {
        var node = new Node();
        node.start = token.range.getStartPosition();
        node.end = token.range.getEndPosition();
        return node;
    }
    var TokenScanner = (function () {
        function TokenScanner(model) {
            this._model = model;
            this._versionId = model.getVersionId();
            this._currentLineNumber = 1;
        }
        TokenScanner.prototype.next = function () {
            if (this._versionId !== this._model.getVersionId()) {
                // model has been modified
                return null;
            }
            if (this._currentLineNumber >= this._model.getLineCount() + 1) {
                // all line visisted
                return null;
            }
            if (!this._currentLineTokens) {
                // no tokens for this line
                this._currentLineTokens = this._model.getLineTokens(this._currentLineNumber);
                this._currentLineText = this._model.getLineContent(this._currentLineNumber);
                this._currentLineModeTransitions = this._model._getLineModeTransitions(this._currentLineNumber);
                this._currentTokenIndex = 0;
                this._currentTokenStart = 0;
                this._currentModeIndex = -1;
                this._nextModeStart = 0;
            }
            if (this._currentTokenIndex >= this._currentLineTokens.getTokenCount()) {
                // last token of line visited
                this._currentLineNumber += 1;
                this._currentLineTokens = null;
                return this.next();
            }
            if (this._currentTokenStart >= this._nextModeStart) {
                this._currentModeIndex++;
                this._nextModeStart = (this._currentModeIndex + 1 < this._currentLineModeTransitions.length ? this._currentLineModeTransitions[this._currentModeIndex + 1].startIndex : this._currentLineText.length + 1);
                var mode = (this._currentModeIndex < this._currentLineModeTransitions.length ? this._currentLineModeTransitions[this._currentModeIndex] : null);
                this._currentModeBrackets = (mode ? languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(mode.modeId) : null);
            }
            var tokenType = this._currentLineTokens.getTokenType(this._currentTokenIndex);
            var tokenEndIndex = this._currentLineTokens.getTokenEndIndex(this._currentTokenIndex, this._currentLineText.length);
            var tmpTokenEndIndex = tokenEndIndex;
            var nextBracket = null;
            if (this._currentModeBrackets && !supports_1.ignoreBracketsInToken(tokenType)) {
                nextBracket = richEditBrackets_1.BracketsUtils.findNextBracketInToken(this._currentModeBrackets.forwardRegex, this._currentLineNumber, this._currentLineText, this._currentTokenStart, tokenEndIndex);
            }
            if (nextBracket && this._currentTokenStart < nextBracket.startColumn - 1) {
                // found a bracket, but it is not at the beginning of the token
                tmpTokenEndIndex = nextBracket.startColumn - 1;
                nextBracket = null;
            }
            var bracketData = null;
            var bracketIsOpen = false;
            if (nextBracket) {
                var bracketText = this._currentLineText.substring(nextBracket.startColumn - 1, nextBracket.endColumn - 1);
                bracketData = this._currentModeBrackets.textIsBracket[bracketText];
                bracketIsOpen = this._currentModeBrackets.textIsOpenBracket[bracketText];
            }
            if (!bracketData) {
                var token_1 = {
                    type: tokenType,
                    bracket: TokenTreeBracket.None,
                    range: new range_1.Range(this._currentLineNumber, 1 + this._currentTokenStart, this._currentLineNumber, 1 + tmpTokenEndIndex)
                };
                // console.log('TOKEN: <<' + this._currentLineText.substring(this._currentTokenStart, tmpTokenEndIndex) + '>>');
                if (tmpTokenEndIndex < tokenEndIndex) {
                    // there is a bracket somewhere in this token...
                    this._currentTokenStart = tmpTokenEndIndex;
                }
                else {
                    this._currentTokenIndex += 1;
                    this._currentTokenStart = (this._currentTokenIndex < this._currentLineTokens.getTokenCount() ? this._currentLineTokens.getTokenStartIndex(this._currentTokenIndex) : 0);
                }
                return token_1;
            }
            var type = bracketData.modeId + ";" + bracketData.open + ";" + bracketData.close;
            var token = {
                type: type,
                bracket: bracketIsOpen ? TokenTreeBracket.Open : TokenTreeBracket.Close,
                range: new range_1.Range(this._currentLineNumber, 1 + this._currentTokenStart, this._currentLineNumber, nextBracket.endColumn)
            };
            // console.log('BRACKET: <<' + this._currentLineText.substring(this._currentTokenStart, nextBracket.endColumn - 1) + '>>');
            if (nextBracket.endColumn - 1 < tokenEndIndex) {
                // found a bracket, but it is not at the end of the token
                this._currentTokenStart = nextBracket.endColumn - 1;
            }
            else {
                this._currentTokenIndex += 1;
                this._currentTokenStart = (this._currentTokenIndex < this._currentLineTokens.getTokenCount() ? this._currentLineTokens.getTokenStartIndex(this._currentTokenIndex) : 0);
            }
            return token;
        };
        return TokenScanner;
    }());
    var TokenTreeBuilder = (function () {
        function TokenTreeBuilder(model) {
            this._stack = [];
            this._scanner = new TokenScanner(model);
        }
        TokenTreeBuilder.prototype.build = function () {
            var node = new NodeList();
            while (node.append(this._line() || this._any())) {
            }
            return node;
        };
        TokenTreeBuilder.prototype._accept = function (condt) {
            var token = this._stack.pop() || this._scanner.next();
            if (!token) {
                return false;
            }
            var accepted = condt(token);
            if (!accepted) {
                this._stack.push(token);
                this._currentToken = null;
            }
            else {
                this._currentToken = token;
            }
            return accepted;
        };
        TokenTreeBuilder.prototype._peek = function (condt) {
            var ret = false;
            this._accept(function (info) {
                ret = condt(info);
                return false;
            });
            return ret;
        };
        TokenTreeBuilder.prototype._line = function () {
            var node = new NodeList(), lineNumber;
            // capture current linenumber
            this._peek(function (info) {
                lineNumber = info.range.startLineNumber;
                return false;
            });
            while (this._peek(function (info) { return info.range.startLineNumber === lineNumber; })
                && node.append(this._token() || this._block())) {
            }
            if (!node.children || node.children.length === 0) {
                return null;
            }
            else if (node.children.length === 1) {
                return node.children[0];
            }
            else {
                return node;
            }
        };
        TokenTreeBuilder.prototype._token = function () {
            if (!this._accept(function (token) { return token.bracket === TokenTreeBracket.None; })) {
                return null;
            }
            return newNode(this._currentToken);
        };
        TokenTreeBuilder.prototype._block = function () {
            var bracketType, accepted;
            accepted = this._accept(function (token) {
                bracketType = token.type;
                return token.bracket === TokenTreeBracket.Open;
            });
            if (!accepted) {
                return null;
            }
            var bracket = new Block();
            bracket.open = newNode(this._currentToken);
            while (bracket.elements.append(this._line())) {
            }
            if (!this._accept(function (token) { return token.bracket === TokenTreeBracket.Close && token.type === bracketType; })) {
                // missing closing bracket -> return just a node list
                var nodelist = new NodeList();
                nodelist.append(bracket.open);
                nodelist.append(bracket.elements);
                return nodelist;
            }
            bracket.close = newNode(this._currentToken);
            return bracket;
        };
        TokenTreeBuilder.prototype._any = function () {
            if (!this._accept(function (_) { return true; })) {
                return null;
            }
            return newNode(this._currentToken);
        };
        return TokenTreeBuilder;
    }());
    /**
     * Parses this grammar:
     *	grammer = { line }
     *	line = { block | "token" }
     *	block = "open_bracket" { line } "close_bracket"
     */
    function build(model) {
        var node = new TokenTreeBuilder(model).build();
        return node;
    }
    exports.build = build;
    function find(node, position) {
        if (!range_1.Range.containsPosition(node.range, position)) {
            return null;
        }
        var result;
        if (node instanceof NodeList) {
            for (var i = 0, len = node.children.length; i < len && !result; i++) {
                result = find(node.children[i], position);
            }
        }
        else if (node instanceof Block) {
            result = find(node.open, position) || find(node.elements, position) || find(node.close, position);
        }
        return result || node;
    }
    exports.find = find;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[232], __M([0,1,37,31,2,65,14]), function (require, exports, arrays_1, objects_1, winjs_base_1, filters_1, async_1) {
    'use strict';
    var CompletionItem = (function () {
        function CompletionItem(suggestion, container) {
            this._support = container.support;
            this.suggestion = suggestion;
            this.container = container;
            this.filter = container.support && container.support.filter || filters_1.fuzzyContiguousFilter;
        }
        CompletionItem.prototype.resolveDetails = function (model, position) {
            var _this = this;
            if (!this._support || typeof this._support.resolveCompletionItem !== 'function') {
                return winjs_base_1.TPromise.as(this.suggestion);
            }
            return async_1.asWinJsPromise(function (token) {
                return _this._support.resolveCompletionItem(model, position, _this.suggestion, token);
            });
        };
        CompletionItem.prototype.updateDetails = function (value) {
            this.suggestion = objects_1.assign(this.suggestion, value);
        };
        CompletionItem.compare = function (item, otherItem) {
            var suggestion = item.suggestion;
            var otherSuggestion = otherItem.suggestion;
            if (typeof suggestion.sortText === 'string' && typeof otherSuggestion.sortText === 'string') {
                var one = suggestion.sortText.toLowerCase();
                var other = otherSuggestion.sortText.toLowerCase();
                if (one < other) {
                    return -1;
                }
                else if (one > other) {
                    return 1;
                }
            }
            return suggestion.label.toLowerCase() < otherSuggestion.label.toLowerCase() ? -1 : 1;
        };
        return CompletionItem;
    }());
    exports.CompletionItem = CompletionItem;
    var LineContext = (function () {
        function LineContext() {
        }
        return LineContext;
    }());
    exports.LineContext = LineContext;
    var CompletionModel = (function () {
        function CompletionModel(raw, leadingLineContent) {
            this.raw = raw;
            this._items = [];
            this._filteredItems = undefined;
            this._lineContext = { leadingLineContent: leadingLineContent, characterCountDelta: 0 };
            for (var _i = 0, raw_1 = raw; _i < raw_1.length; _i++) {
                var container = raw_1[_i];
                for (var _a = 0, _b = container.suggestions; _a < _b.length; _a++) {
                    var suggestion = _b[_a];
                    this._items.push(new CompletionItem(suggestion, container));
                }
            }
            this._items.sort(CompletionItem.compare);
        }
        Object.defineProperty(CompletionModel.prototype, "lineContext", {
            get: function () {
                return this._lineContext;
            },
            set: function (value) {
                if (this._lineContext !== value) {
                    this._filteredItems = undefined;
                    this._lineContext = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CompletionModel.prototype, "items", {
            get: function () {
                if (!this._filteredItems) {
                    this._filter();
                }
                return this._filteredItems;
            },
            enumerable: true,
            configurable: true
        });
        CompletionModel.prototype._filter = function () {
            this._filteredItems = [];
            var _a = this._lineContext, leadingLineContent = _a.leadingLineContent, characterCountDelta = _a.characterCountDelta;
            for (var _i = 0, _b = this._items; _i < _b.length; _i++) {
                var item = _b[_i];
                var overwriteBefore = item.suggestion.overwriteBefore;
                if (typeof overwriteBefore !== 'number') {
                    overwriteBefore = item.container.currentWord.length;
                }
                var start = leadingLineContent.length - (overwriteBefore + characterCountDelta);
                var word = leadingLineContent.substr(start);
                var filter = item.filter, suggestion = item.suggestion;
                var match = false;
                // compute highlights based on 'label'
                item.highlights = filter(word, suggestion.label);
                match = item.highlights !== null;
                // no match on label -> check on codeSnippet
                if (!match && suggestion.codeSnippet !== suggestion.label) {
                    match = !arrays_1.isFalsyOrEmpty((filter(word, suggestion.codeSnippet.replace(/{{.+?}}/g, '')))); // filters {{text}}-snippet syntax
                }
                // no match on label nor codeSnippet -> check on filterText
                if (!match && typeof suggestion.filterText === 'string') {
                    match = !arrays_1.isFalsyOrEmpty(filter(word, suggestion.filterText));
                }
                if (match) {
                    this._filteredItems.push(item);
                }
            }
        };
        return CompletionModel;
    }());
    exports.CompletionModel = CompletionModel;
});

define(__m[233], __M([5,6]), function(nls, data) { return nls.create("vs/base/common/json", data); });
define(__m[124], __M([0,1,233]), function (require, exports, nls_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    (function (ScanError) {
        ScanError[ScanError["None"] = 0] = "None";
        ScanError[ScanError["UnexpectedEndOfComment"] = 1] = "UnexpectedEndOfComment";
        ScanError[ScanError["UnexpectedEndOfString"] = 2] = "UnexpectedEndOfString";
        ScanError[ScanError["UnexpectedEndOfNumber"] = 3] = "UnexpectedEndOfNumber";
        ScanError[ScanError["InvalidUnicode"] = 4] = "InvalidUnicode";
        ScanError[ScanError["InvalidEscapeCharacter"] = 5] = "InvalidEscapeCharacter";
    })(exports.ScanError || (exports.ScanError = {}));
    var ScanError = exports.ScanError;
    (function (SyntaxKind) {
        SyntaxKind[SyntaxKind["Unknown"] = 0] = "Unknown";
        SyntaxKind[SyntaxKind["OpenBraceToken"] = 1] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 2] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 3] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 4] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 5] = "CommaToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 6] = "ColonToken";
        SyntaxKind[SyntaxKind["NullKeyword"] = 7] = "NullKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 8] = "TrueKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 9] = "FalseKeyword";
        SyntaxKind[SyntaxKind["StringLiteral"] = 10] = "StringLiteral";
        SyntaxKind[SyntaxKind["NumericLiteral"] = 11] = "NumericLiteral";
        SyntaxKind[SyntaxKind["LineCommentTrivia"] = 12] = "LineCommentTrivia";
        SyntaxKind[SyntaxKind["BlockCommentTrivia"] = 13] = "BlockCommentTrivia";
        SyntaxKind[SyntaxKind["LineBreakTrivia"] = 14] = "LineBreakTrivia";
        SyntaxKind[SyntaxKind["Trivia"] = 15] = "Trivia";
        SyntaxKind[SyntaxKind["EOF"] = 16] = "EOF";
    })(exports.SyntaxKind || (exports.SyntaxKind = {}));
    var SyntaxKind = exports.SyntaxKind;
    /**
     * Creates a JSON scanner on the given text.
     * If ignoreTrivia is set, whitespaces or comments are ignored.
     */
    function createScanner(text, ignoreTrivia) {
        if (ignoreTrivia === void 0) { ignoreTrivia = false; }
        var pos = 0, len = text.length, value = '', tokenOffset = 0, token = SyntaxKind.Unknown, scanError = ScanError.None;
        function scanHexDigits(count, exact) {
            var digits = 0;
            var value = 0;
            while (digits < count || !exact) {
                var ch = text.charCodeAt(pos);
                if (ch >= CharacterCodes._0 && ch <= CharacterCodes._9) {
                    value = value * 16 + ch - CharacterCodes._0;
                }
                else if (ch >= CharacterCodes.A && ch <= CharacterCodes.F) {
                    value = value * 16 + ch - CharacterCodes.A + 10;
                }
                else if (ch >= CharacterCodes.a && ch <= CharacterCodes.f) {
                    value = value * 16 + ch - CharacterCodes.a + 10;
                }
                else {
                    break;
                }
                pos++;
                digits++;
            }
            if (digits < count) {
                value = -1;
            }
            return value;
        }
        function setPosition(newPosition) {
            pos = newPosition;
            value = '';
            tokenOffset = 0;
            token = SyntaxKind.Unknown;
            scanError = ScanError.None;
        }
        function scanNumber() {
            var start = pos;
            if (text.charCodeAt(pos) === CharacterCodes._0) {
                pos++;
            }
            else {
                pos++;
                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                }
            }
            if (pos < text.length && text.charCodeAt(pos) === CharacterCodes.dot) {
                pos++;
                if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                        pos++;
                    }
                }
                else {
                    scanError = ScanError.UnexpectedEndOfNumber;
                    return text.substring(start, pos);
                }
            }
            var end = pos;
            if (pos < text.length && (text.charCodeAt(pos) === CharacterCodes.E || text.charCodeAt(pos) === CharacterCodes.e)) {
                pos++;
                if (pos < text.length && text.charCodeAt(pos) === CharacterCodes.plus || text.charCodeAt(pos) === CharacterCodes.minus) {
                    pos++;
                }
                if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                    while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                        pos++;
                    }
                    end = pos;
                }
                else {
                    scanError = ScanError.UnexpectedEndOfNumber;
                }
            }
            return text.substring(start, end);
        }
        function scanString() {
            var result = '', start = pos;
            while (true) {
                if (pos >= len) {
                    result += text.substring(start, pos);
                    scanError = ScanError.UnexpectedEndOfString;
                    break;
                }
                var ch = text.charCodeAt(pos);
                if (ch === CharacterCodes.doubleQuote) {
                    result += text.substring(start, pos);
                    pos++;
                    break;
                }
                if (ch === CharacterCodes.backslash) {
                    result += text.substring(start, pos);
                    pos++;
                    if (pos >= len) {
                        scanError = ScanError.UnexpectedEndOfString;
                        break;
                    }
                    ch = text.charCodeAt(pos++);
                    switch (ch) {
                        case CharacterCodes.doubleQuote:
                            result += '\"';
                            break;
                        case CharacterCodes.backslash:
                            result += '\\';
                            break;
                        case CharacterCodes.slash:
                            result += '/';
                            break;
                        case CharacterCodes.b:
                            result += '\b';
                            break;
                        case CharacterCodes.f:
                            result += '\f';
                            break;
                        case CharacterCodes.n:
                            result += '\n';
                            break;
                        case CharacterCodes.r:
                            result += '\r';
                            break;
                        case CharacterCodes.t:
                            result += '\t';
                            break;
                        case CharacterCodes.u:
                            var ch_1 = scanHexDigits(4, true);
                            if (ch_1 >= 0) {
                                result += String.fromCharCode(ch_1);
                            }
                            else {
                                scanError = ScanError.InvalidUnicode;
                            }
                            break;
                        default:
                            scanError = ScanError.InvalidEscapeCharacter;
                    }
                    start = pos;
                    continue;
                }
                if (isLineBreak(ch)) {
                    result += text.substring(start, pos);
                    scanError = ScanError.UnexpectedEndOfString;
                    break;
                }
                pos++;
            }
            return result;
        }
        function scanNext() {
            value = '';
            scanError = ScanError.None;
            tokenOffset = pos;
            if (pos >= len) {
                // at the end
                tokenOffset = len;
                return token = SyntaxKind.EOF;
            }
            var code = text.charCodeAt(pos);
            // trivia: whitespace
            if (isWhiteSpace(code)) {
                do {
                    pos++;
                    value += String.fromCharCode(code);
                    code = text.charCodeAt(pos);
                } while (isWhiteSpace(code));
                return token = SyntaxKind.Trivia;
            }
            // trivia: newlines
            if (isLineBreak(code)) {
                pos++;
                value += String.fromCharCode(code);
                if (code === CharacterCodes.carriageReturn && text.charCodeAt(pos) === CharacterCodes.lineFeed) {
                    pos++;
                    value += '\n';
                }
                return token = SyntaxKind.LineBreakTrivia;
            }
            switch (code) {
                // tokens: []{}:,
                case CharacterCodes.openBrace:
                    pos++;
                    return token = SyntaxKind.OpenBraceToken;
                case CharacterCodes.closeBrace:
                    pos++;
                    return token = SyntaxKind.CloseBraceToken;
                case CharacterCodes.openBracket:
                    pos++;
                    return token = SyntaxKind.OpenBracketToken;
                case CharacterCodes.closeBracket:
                    pos++;
                    return token = SyntaxKind.CloseBracketToken;
                case CharacterCodes.colon:
                    pos++;
                    return token = SyntaxKind.ColonToken;
                case CharacterCodes.comma:
                    pos++;
                    return token = SyntaxKind.CommaToken;
                // strings
                case CharacterCodes.doubleQuote:
                    pos++;
                    value = scanString();
                    return token = SyntaxKind.StringLiteral;
                // comments
                case CharacterCodes.slash:
                    var start = pos - 1;
                    // Single-line comment
                    if (text.charCodeAt(pos + 1) === CharacterCodes.slash) {
                        pos += 2;
                        while (pos < len) {
                            if (isLineBreak(text.charCodeAt(pos))) {
                                break;
                            }
                            pos++;
                        }
                        value = text.substring(start, pos);
                        return token = SyntaxKind.LineCommentTrivia;
                    }
                    // Multi-line comment
                    if (text.charCodeAt(pos + 1) === CharacterCodes.asterisk) {
                        pos += 2;
                        var safeLength = len - 1; // For lookahead.
                        var commentClosed = false;
                        while (pos < safeLength) {
                            var ch = text.charCodeAt(pos);
                            if (ch === CharacterCodes.asterisk && text.charCodeAt(pos + 1) === CharacterCodes.slash) {
                                pos += 2;
                                commentClosed = true;
                                break;
                            }
                            pos++;
                        }
                        if (!commentClosed) {
                            pos++;
                            scanError = ScanError.UnexpectedEndOfComment;
                        }
                        value = text.substring(start, pos);
                        return token = SyntaxKind.BlockCommentTrivia;
                    }
                    // just a single slash
                    value += String.fromCharCode(code);
                    pos++;
                    return token = SyntaxKind.Unknown;
                // numbers
                case CharacterCodes.minus:
                    value += String.fromCharCode(code);
                    pos++;
                    if (pos === len || !isDigit(text.charCodeAt(pos))) {
                        return token = SyntaxKind.Unknown;
                    }
                // found a minus, followed by a number so
                // we fall through to proceed with scanning
                // numbers
                case CharacterCodes._0:
                case CharacterCodes._1:
                case CharacterCodes._2:
                case CharacterCodes._3:
                case CharacterCodes._4:
                case CharacterCodes._5:
                case CharacterCodes._6:
                case CharacterCodes._7:
                case CharacterCodes._8:
                case CharacterCodes._9:
                    value += scanNumber();
                    return token = SyntaxKind.NumericLiteral;
                // literals and unknown symbols
                default:
                    // is a literal? Read the full word.
                    while (pos < len && isUnknownContentCharacter(code)) {
                        pos++;
                        code = text.charCodeAt(pos);
                    }
                    if (tokenOffset !== pos) {
                        value = text.substring(tokenOffset, pos);
                        // keywords: true, false, null
                        switch (value) {
                            case 'true': return token = SyntaxKind.TrueKeyword;
                            case 'false': return token = SyntaxKind.FalseKeyword;
                            case 'null': return token = SyntaxKind.NullKeyword;
                        }
                        return token = SyntaxKind.Unknown;
                    }
                    // some
                    value += String.fromCharCode(code);
                    pos++;
                    return token = SyntaxKind.Unknown;
            }
        }
        function isUnknownContentCharacter(code) {
            if (isWhiteSpace(code) || isLineBreak(code)) {
                return false;
            }
            switch (code) {
                case CharacterCodes.closeBrace:
                case CharacterCodes.closeBracket:
                case CharacterCodes.openBrace:
                case CharacterCodes.openBracket:
                case CharacterCodes.doubleQuote:
                case CharacterCodes.colon:
                case CharacterCodes.comma:
                    return false;
            }
            return true;
        }
        function scanNextNonTrivia() {
            var result;
            do {
                result = scanNext();
            } while (result >= SyntaxKind.LineCommentTrivia && result <= SyntaxKind.Trivia);
            return result;
        }
        return {
            setPosition: setPosition,
            getPosition: function () { return pos; },
            scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
            getToken: function () { return token; },
            getTokenValue: function () { return value; },
            getTokenOffset: function () { return tokenOffset; },
            getTokenLength: function () { return pos - tokenOffset; },
            getTokenError: function () { return scanError; }
        };
    }
    exports.createScanner = createScanner;
    function isWhiteSpace(ch) {
        return ch === CharacterCodes.space || ch === CharacterCodes.tab || ch === CharacterCodes.verticalTab || ch === CharacterCodes.formFeed ||
            ch === CharacterCodes.nonBreakingSpace || ch === CharacterCodes.ogham || ch >= CharacterCodes.enQuad && ch <= CharacterCodes.zeroWidthSpace ||
            ch === CharacterCodes.narrowNoBreakSpace || ch === CharacterCodes.mathematicalSpace || ch === CharacterCodes.ideographicSpace || ch === CharacterCodes.byteOrderMark;
    }
    function isLineBreak(ch) {
        return ch === CharacterCodes.lineFeed || ch === CharacterCodes.carriageReturn || ch === CharacterCodes.lineSeparator || ch === CharacterCodes.paragraphSeparator;
    }
    function isDigit(ch) {
        return ch >= CharacterCodes._0 && ch <= CharacterCodes._9;
    }
    var CharacterCodes;
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["nullCharacter"] = 0] = "nullCharacter";
        CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";
        CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
        CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
        CharacterCodes[CharacterCodes["lineSeparator"] = 8232] = "lineSeparator";
        CharacterCodes[CharacterCodes["paragraphSeparator"] = 8233] = "paragraphSeparator";
        // REVIEW: do we need to support this?  The scanner doesn't, but our IText does.  This seems
        // like an odd disparity?  (Or maybe it's completely fine for them to be different).
        CharacterCodes[CharacterCodes["nextLine"] = 133] = "nextLine";
        // Unicode 3.0 space characters
        CharacterCodes[CharacterCodes["space"] = 32] = "space";
        CharacterCodes[CharacterCodes["nonBreakingSpace"] = 160] = "nonBreakingSpace";
        CharacterCodes[CharacterCodes["enQuad"] = 8192] = "enQuad";
        CharacterCodes[CharacterCodes["emQuad"] = 8193] = "emQuad";
        CharacterCodes[CharacterCodes["enSpace"] = 8194] = "enSpace";
        CharacterCodes[CharacterCodes["emSpace"] = 8195] = "emSpace";
        CharacterCodes[CharacterCodes["threePerEmSpace"] = 8196] = "threePerEmSpace";
        CharacterCodes[CharacterCodes["fourPerEmSpace"] = 8197] = "fourPerEmSpace";
        CharacterCodes[CharacterCodes["sixPerEmSpace"] = 8198] = "sixPerEmSpace";
        CharacterCodes[CharacterCodes["figureSpace"] = 8199] = "figureSpace";
        CharacterCodes[CharacterCodes["punctuationSpace"] = 8200] = "punctuationSpace";
        CharacterCodes[CharacterCodes["thinSpace"] = 8201] = "thinSpace";
        CharacterCodes[CharacterCodes["hairSpace"] = 8202] = "hairSpace";
        CharacterCodes[CharacterCodes["zeroWidthSpace"] = 8203] = "zeroWidthSpace";
        CharacterCodes[CharacterCodes["narrowNoBreakSpace"] = 8239] = "narrowNoBreakSpace";
        CharacterCodes[CharacterCodes["ideographicSpace"] = 12288] = "ideographicSpace";
        CharacterCodes[CharacterCodes["mathematicalSpace"] = 8287] = "mathematicalSpace";
        CharacterCodes[CharacterCodes["ogham"] = 5760] = "ogham";
        CharacterCodes[CharacterCodes["_"] = 95] = "_";
        CharacterCodes[CharacterCodes["$"] = 36] = "$";
        CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
        CharacterCodes[CharacterCodes["_1"] = 49] = "_1";
        CharacterCodes[CharacterCodes["_2"] = 50] = "_2";
        CharacterCodes[CharacterCodes["_3"] = 51] = "_3";
        CharacterCodes[CharacterCodes["_4"] = 52] = "_4";
        CharacterCodes[CharacterCodes["_5"] = 53] = "_5";
        CharacterCodes[CharacterCodes["_6"] = 54] = "_6";
        CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
        CharacterCodes[CharacterCodes["_8"] = 56] = "_8";
        CharacterCodes[CharacterCodes["_9"] = 57] = "_9";
        CharacterCodes[CharacterCodes["a"] = 97] = "a";
        CharacterCodes[CharacterCodes["b"] = 98] = "b";
        CharacterCodes[CharacterCodes["c"] = 99] = "c";
        CharacterCodes[CharacterCodes["d"] = 100] = "d";
        CharacterCodes[CharacterCodes["e"] = 101] = "e";
        CharacterCodes[CharacterCodes["f"] = 102] = "f";
        CharacterCodes[CharacterCodes["g"] = 103] = "g";
        CharacterCodes[CharacterCodes["h"] = 104] = "h";
        CharacterCodes[CharacterCodes["i"] = 105] = "i";
        CharacterCodes[CharacterCodes["j"] = 106] = "j";
        CharacterCodes[CharacterCodes["k"] = 107] = "k";
        CharacterCodes[CharacterCodes["l"] = 108] = "l";
        CharacterCodes[CharacterCodes["m"] = 109] = "m";
        CharacterCodes[CharacterCodes["n"] = 110] = "n";
        CharacterCodes[CharacterCodes["o"] = 111] = "o";
        CharacterCodes[CharacterCodes["p"] = 112] = "p";
        CharacterCodes[CharacterCodes["q"] = 113] = "q";
        CharacterCodes[CharacterCodes["r"] = 114] = "r";
        CharacterCodes[CharacterCodes["s"] = 115] = "s";
        CharacterCodes[CharacterCodes["t"] = 116] = "t";
        CharacterCodes[CharacterCodes["u"] = 117] = "u";
        CharacterCodes[CharacterCodes["v"] = 118] = "v";
        CharacterCodes[CharacterCodes["w"] = 119] = "w";
        CharacterCodes[CharacterCodes["x"] = 120] = "x";
        CharacterCodes[CharacterCodes["y"] = 121] = "y";
        CharacterCodes[CharacterCodes["z"] = 122] = "z";
        CharacterCodes[CharacterCodes["A"] = 65] = "A";
        CharacterCodes[CharacterCodes["B"] = 66] = "B";
        CharacterCodes[CharacterCodes["C"] = 67] = "C";
        CharacterCodes[CharacterCodes["D"] = 68] = "D";
        CharacterCodes[CharacterCodes["E"] = 69] = "E";
        CharacterCodes[CharacterCodes["F"] = 70] = "F";
        CharacterCodes[CharacterCodes["G"] = 71] = "G";
        CharacterCodes[CharacterCodes["H"] = 72] = "H";
        CharacterCodes[CharacterCodes["I"] = 73] = "I";
        CharacterCodes[CharacterCodes["J"] = 74] = "J";
        CharacterCodes[CharacterCodes["K"] = 75] = "K";
        CharacterCodes[CharacterCodes["L"] = 76] = "L";
        CharacterCodes[CharacterCodes["M"] = 77] = "M";
        CharacterCodes[CharacterCodes["N"] = 78] = "N";
        CharacterCodes[CharacterCodes["O"] = 79] = "O";
        CharacterCodes[CharacterCodes["P"] = 80] = "P";
        CharacterCodes[CharacterCodes["Q"] = 81] = "Q";
        CharacterCodes[CharacterCodes["R"] = 82] = "R";
        CharacterCodes[CharacterCodes["S"] = 83] = "S";
        CharacterCodes[CharacterCodes["T"] = 84] = "T";
        CharacterCodes[CharacterCodes["U"] = 85] = "U";
        CharacterCodes[CharacterCodes["V"] = 86] = "V";
        CharacterCodes[CharacterCodes["W"] = 87] = "W";
        CharacterCodes[CharacterCodes["X"] = 88] = "X";
        CharacterCodes[CharacterCodes["Y"] = 89] = "Y";
        CharacterCodes[CharacterCodes["Z"] = 90] = "Z";
        CharacterCodes[CharacterCodes["ampersand"] = 38] = "ampersand";
        CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
        CharacterCodes[CharacterCodes["at"] = 64] = "at";
        CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
        CharacterCodes[CharacterCodes["bar"] = 124] = "bar";
        CharacterCodes[CharacterCodes["caret"] = 94] = "caret";
        CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
        CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
        CharacterCodes[CharacterCodes["closeParen"] = 41] = "closeParen";
        CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
        CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
        CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
        CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
        CharacterCodes[CharacterCodes["equals"] = 61] = "equals";
        CharacterCodes[CharacterCodes["exclamation"] = 33] = "exclamation";
        CharacterCodes[CharacterCodes["greaterThan"] = 62] = "greaterThan";
        CharacterCodes[CharacterCodes["lessThan"] = 60] = "lessThan";
        CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
        CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
        CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
        CharacterCodes[CharacterCodes["openParen"] = 40] = "openParen";
        CharacterCodes[CharacterCodes["percent"] = 37] = "percent";
        CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
        CharacterCodes[CharacterCodes["question"] = 63] = "question";
        CharacterCodes[CharacterCodes["semicolon"] = 59] = "semicolon";
        CharacterCodes[CharacterCodes["singleQuote"] = 39] = "singleQuote";
        CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
        CharacterCodes[CharacterCodes["tilde"] = 126] = "tilde";
        CharacterCodes[CharacterCodes["backspace"] = 8] = "backspace";
        CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
        CharacterCodes[CharacterCodes["byteOrderMark"] = 65279] = "byteOrderMark";
        CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
        CharacterCodes[CharacterCodes["verticalTab"] = 11] = "verticalTab";
    })(CharacterCodes || (CharacterCodes = {}));
    /**
     * Takes JSON with JavaScript-style comments and remove
     * them. Optionally replaces every none-newline character
     * of comments with a replaceCharacter
     */
    function stripComments(text, replaceCh) {
        var _scanner = createScanner(text), parts = [], kind, offset = 0, pos;
        do {
            pos = _scanner.getPosition();
            kind = _scanner.scan();
            switch (kind) {
                case SyntaxKind.LineCommentTrivia:
                case SyntaxKind.BlockCommentTrivia:
                case SyntaxKind.EOF:
                    if (offset !== pos) {
                        parts.push(text.substring(offset, pos));
                    }
                    if (replaceCh !== void 0) {
                        parts.push(_scanner.getTokenValue().replace(/[^\r\n]/g, replaceCh));
                    }
                    offset = _scanner.getPosition();
                    break;
            }
        } while (kind !== SyntaxKind.EOF);
        return parts.join('');
    }
    exports.stripComments = stripComments;
    (function (ParseErrorCode) {
        ParseErrorCode[ParseErrorCode["InvalidSymbol"] = 0] = "InvalidSymbol";
        ParseErrorCode[ParseErrorCode["InvalidNumberFormat"] = 1] = "InvalidNumberFormat";
        ParseErrorCode[ParseErrorCode["PropertyNameExpected"] = 2] = "PropertyNameExpected";
        ParseErrorCode[ParseErrorCode["ValueExpected"] = 3] = "ValueExpected";
        ParseErrorCode[ParseErrorCode["ColonExpected"] = 4] = "ColonExpected";
        ParseErrorCode[ParseErrorCode["CommaExpected"] = 5] = "CommaExpected";
        ParseErrorCode[ParseErrorCode["CloseBraceExpected"] = 6] = "CloseBraceExpected";
        ParseErrorCode[ParseErrorCode["CloseBracketExpected"] = 7] = "CloseBracketExpected";
        ParseErrorCode[ParseErrorCode["EndOfFileExpected"] = 8] = "EndOfFileExpected";
    })(exports.ParseErrorCode || (exports.ParseErrorCode = {}));
    var ParseErrorCode = exports.ParseErrorCode;
    function getParseErrorMessage(errorCode) {
        switch (errorCode) {
            case ParseErrorCode.InvalidSymbol: return nls_1.localize(0, null);
            case ParseErrorCode.InvalidNumberFormat: return nls_1.localize(1, null);
            case ParseErrorCode.PropertyNameExpected: return nls_1.localize(2, null);
            case ParseErrorCode.ValueExpected: return nls_1.localize(3, null);
            case ParseErrorCode.ColonExpected: return nls_1.localize(4, null);
            case ParseErrorCode.CommaExpected: return nls_1.localize(5, null);
            case ParseErrorCode.CloseBraceExpected: return nls_1.localize(6, null);
            case ParseErrorCode.CloseBracketExpected: return nls_1.localize(7, null);
            case ParseErrorCode.EndOfFileExpected: return nls_1.localize(8, null);
            default:
                return '';
        }
    }
    exports.getParseErrorMessage = getParseErrorMessage;
    function getLiteralNodeType(value) {
        switch (typeof value) {
            case 'boolean': return 'boolean';
            case 'number': return 'number';
            case 'string': return 'string';
            default: return 'null';
        }
    }
    /**
     * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
     */
    function getLocation(text, position) {
        var segments = []; // strings or numbers
        var earlyReturnException = new Object();
        var previousNode = void 0;
        var previousNodeInst = {
            value: void 0,
            offset: void 0,
            length: void 0,
            type: void 0
        };
        var isAtPropertyKey = false;
        function setPreviousNode(value, offset, length, type) {
            previousNodeInst.value = value;
            previousNodeInst.offset = offset;
            previousNodeInst.length = length;
            previousNodeInst.type = type;
            previousNodeInst.columnOffset = void 0;
            previousNode = previousNodeInst;
        }
        try {
            visit(text, {
                onObjectBegin: function (offset, length) {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    previousNode = void 0;
                    isAtPropertyKey = position > offset;
                    segments.push(''); // push a placeholder (will be replaced or removed)
                },
                onObjectProperty: function (name, offset, length) {
                    if (position < offset) {
                        throw earlyReturnException;
                    }
                    setPreviousNode(name, offset, length, 'property');
                    segments[segments.length - 1] = name;
                    if (position <= offset + length) {
                        throw earlyReturnException;
                    }
                },
                onObjectEnd: function (offset, length) {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    previousNode = void 0;
                    segments.pop();
                },
                onArrayBegin: function (offset, length) {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    previousNode = void 0;
                    segments.push(0);
                },
                onArrayEnd: function (offset, length) {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    previousNode = void 0;
                    segments.pop();
                },
                onLiteralValue: function (value, offset, length) {
                    if (position < offset) {
                        throw earlyReturnException;
                    }
                    setPreviousNode(value, offset, length, getLiteralNodeType(value));
                    if (position <= offset + length) {
                        throw earlyReturnException;
                    }
                },
                onSeparator: function (sep, offset, length) {
                    if (position <= offset) {
                        throw earlyReturnException;
                    }
                    if (sep === ':' && previousNode.type === 'property') {
                        previousNode.columnOffset = offset;
                        isAtPropertyKey = false;
                        previousNode = void 0;
                    }
                    else if (sep === ',') {
                        var last = segments[segments.length - 1];
                        if (typeof last === 'number') {
                            segments[segments.length - 1] = last + 1;
                        }
                        else {
                            isAtPropertyKey = true;
                            segments[segments.length - 1] = '';
                        }
                        previousNode = void 0;
                    }
                }
            });
        }
        catch (e) {
            if (e !== earlyReturnException) {
                throw e;
            }
        }
        if (segments[segments.length - 1] === '') {
            segments.pop();
        }
        return {
            path: segments,
            previousNode: previousNode,
            isAtPropertyKey: isAtPropertyKey,
            matches: function (pattern) {
                var k = 0;
                for (var i = 0; k < pattern.length && i < segments.length; i++) {
                    if (pattern[k] === segments[i] || pattern[k] === '*') {
                        k++;
                    }
                    else if (pattern[k] !== '**') {
                        return false;
                    }
                }
                return k === pattern.length;
            }
        };
    }
    exports.getLocation = getLocation;
    /**
     * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
     * Therefore always check the errors list to find out if the input was valid.
     */
    function parse(text, errors, options) {
        if (errors === void 0) { errors = []; }
        var currentProperty = null;
        var currentParent = [];
        var previousParents = [];
        function onValue(value) {
            if (Array.isArray(currentParent)) {
                currentParent.push(value);
            }
            else if (currentProperty) {
                currentParent[currentProperty] = value;
            }
        }
        var visitor = {
            onObjectBegin: function () {
                var object = {};
                onValue(object);
                previousParents.push(currentParent);
                currentParent = object;
                currentProperty = null;
            },
            onObjectProperty: function (name) {
                currentProperty = name;
            },
            onObjectEnd: function () {
                currentParent = previousParents.pop();
            },
            onArrayBegin: function () {
                var array = [];
                onValue(array);
                previousParents.push(currentParent);
                currentParent = array;
                currentProperty = null;
            },
            onArrayEnd: function () {
                currentParent = previousParents.pop();
            },
            onLiteralValue: onValue,
            onError: function (error) {
                errors.push({ error: error });
            }
        };
        visit(text, visitor, options);
        return currentParent[0];
    }
    exports.parse = parse;
    /**
     * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
     */
    function parseTree(text, errors, options) {
        if (errors === void 0) { errors = []; }
        var currentParent = { type: 'array', offset: -1, length: -1, children: [] }; // artificial root
        function ensurePropertyComplete(endOffset) {
            if (currentParent.type === 'property') {
                currentParent.length = endOffset - currentParent.offset;
                currentParent = currentParent.parent;
            }
        }
        function onValue(valueNode) {
            currentParent.children.push(valueNode);
            ensurePropertyComplete(valueNode.offset + valueNode.length);
            return valueNode;
        }
        var visitor = {
            onObjectBegin: function (offset) {
                currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });
            },
            onObjectProperty: function (name, offset, length) {
                currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });
                currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });
            },
            onObjectEnd: function (offset, length) {
                ensurePropertyComplete(offset);
                currentParent.length = offset + length - currentParent.offset;
                currentParent = currentParent.parent;
            },
            onArrayBegin: function (offset, length) {
                currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });
            },
            onArrayEnd: function (offset, length) {
                currentParent.length = offset + length - currentParent.offset;
                currentParent = currentParent.parent;
            },
            onLiteralValue: function (value, offset, length) {
                onValue({ type: getLiteralNodeType(value), offset: offset, length: length, parent: currentParent, value: value });
            },
            onSeparator: function (sep, offset, length) {
                if (currentParent.type === 'property') {
                    if (sep === ':') {
                        currentParent.columnOffset = offset;
                    }
                    else if (sep === ',') {
                        ensurePropertyComplete(offset);
                    }
                }
            },
            onError: function (error) {
                errors.push({ error: error });
            }
        };
        visit(text, visitor, options);
        var result = currentParent.children[0];
        if (result) {
            delete result.parent;
        }
        return result;
    }
    exports.parseTree = parseTree;
    function findNodeAtLocation(root, path) {
        if (!root) {
            return void 0;
        }
        var node = root;
        for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {
            var segment = path_1[_i];
            if (typeof segment === 'string') {
                if (node.type !== 'object') {
                    return void 0;
                }
                var found = false;
                for (var _a = 0, _b = node.children; _a < _b.length; _a++) {
                    var propertyNode = _b[_a];
                    if (propertyNode.children[0].value === segment) {
                        node = propertyNode.children[1];
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    return void 0;
                }
            }
            else {
                var index = segment;
                if (node.type !== 'array' || index < 0 || index >= node.children.length) {
                    return void 0;
                }
                node = node.children[index];
            }
        }
        return node;
    }
    exports.findNodeAtLocation = findNodeAtLocation;
    function getNodeValue(node) {
        if (node.type === 'array') {
            return node.children.map(getNodeValue);
        }
        else if (node.type === 'object') {
            var obj = {};
            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                var prop = _a[_i];
                obj[prop.children[0].value] = getNodeValue(prop.children[1]);
            }
            return obj;
        }
        return node.value;
    }
    exports.getNodeValue = getNodeValue;
    /**
     * Parses the given text and invokes the visitor functions for each object, array and literal reached.
     */
    function visit(text, visitor, options) {
        var _scanner = createScanner(text, false);
        function toNoArgVisit(visitFunction) {
            return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };
        }
        function toOneArgVisit(visitFunction) {
            return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };
        }
        var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onError = toOneArgVisit(visitor.onError);
        var disallowComments = options && options.disallowComments;
        function scanNext() {
            while (true) {
                var token = _scanner.scan();
                switch (token) {
                    case SyntaxKind.LineCommentTrivia:
                    case SyntaxKind.BlockCommentTrivia:
                        if (disallowComments) {
                            handleError(ParseErrorCode.InvalidSymbol);
                        }
                        break;
                    case SyntaxKind.Unknown:
                        handleError(ParseErrorCode.InvalidSymbol);
                        break;
                    case SyntaxKind.Trivia:
                    case SyntaxKind.LineBreakTrivia:
                        break;
                    default:
                        return token;
                }
            }
        }
        function handleError(error, skipUntilAfter, skipUntil) {
            if (skipUntilAfter === void 0) { skipUntilAfter = []; }
            if (skipUntil === void 0) { skipUntil = []; }
            onError(error);
            if (skipUntilAfter.length + skipUntil.length > 0) {
                var token = _scanner.getToken();
                while (token !== SyntaxKind.EOF) {
                    if (skipUntilAfter.indexOf(token) !== -1) {
                        scanNext();
                        break;
                    }
                    else if (skipUntil.indexOf(token) !== -1) {
                        break;
                    }
                    token = scanNext();
                }
            }
        }
        function parseString(isValue) {
            if (_scanner.getToken() !== SyntaxKind.StringLiteral) {
                return false;
            }
            var value = _scanner.getTokenValue();
            if (isValue) {
                onLiteralValue(value);
            }
            else {
                onObjectProperty(value);
            }
            scanNext();
            return true;
        }
        function parseLiteral() {
            switch (_scanner.getToken()) {
                case SyntaxKind.NumericLiteral:
                    var value = 0;
                    try {
                        value = JSON.parse(_scanner.getTokenValue());
                        if (typeof value !== 'number') {
                            handleError(ParseErrorCode.InvalidNumberFormat);
                            value = 0;
                        }
                    }
                    catch (e) {
                        handleError(ParseErrorCode.InvalidNumberFormat);
                    }
                    onLiteralValue(value);
                    break;
                case SyntaxKind.NullKeyword:
                    onLiteralValue(null);
                    break;
                case SyntaxKind.TrueKeyword:
                    onLiteralValue(true);
                    break;
                case SyntaxKind.FalseKeyword:
                    onLiteralValue(false);
                    break;
                default:
                    return false;
            }
            scanNext();
            return true;
        }
        function parseProperty() {
            if (!parseString(false)) {
                handleError(ParseErrorCode.PropertyNameExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
                return false;
            }
            if (_scanner.getToken() === SyntaxKind.ColonToken) {
                onSeparator(':');
                scanNext(); // consume colon
                if (!parseValue()) {
                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
                }
            }
            else {
                handleError(ParseErrorCode.ColonExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
            }
            return true;
        }
        function parseObject() {
            if (_scanner.getToken() !== SyntaxKind.OpenBraceToken) {
                return false;
            }
            onObjectBegin();
            scanNext(); // consume open brace
            var needsComma = false;
            while (_scanner.getToken() !== SyntaxKind.CloseBraceToken && _scanner.getToken() !== SyntaxKind.EOF) {
                if (_scanner.getToken() === SyntaxKind.CommaToken) {
                    if (!needsComma) {
                        handleError(ParseErrorCode.ValueExpected, [], []);
                    }
                    onSeparator(',');
                    scanNext(); // consume comma
                }
                else if (needsComma) {
                    handleError(ParseErrorCode.CommaExpected, [], []);
                }
                if (!parseProperty()) {
                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBraceToken, SyntaxKind.CommaToken]);
                }
                needsComma = true;
            }
            onObjectEnd();
            if (_scanner.getToken() !== SyntaxKind.CloseBraceToken) {
                handleError(ParseErrorCode.CloseBraceExpected, [SyntaxKind.CloseBraceToken], []);
            }
            else {
                scanNext(); // consume close brace
            }
            return true;
        }
        function parseArray() {
            if (_scanner.getToken() !== SyntaxKind.OpenBracketToken) {
                return false;
            }
            onArrayBegin();
            scanNext(); // consume open bracket
            var needsComma = false;
            while (_scanner.getToken() !== SyntaxKind.CloseBracketToken && _scanner.getToken() !== SyntaxKind.EOF) {
                if (_scanner.getToken() === SyntaxKind.CommaToken) {
                    if (!needsComma) {
                        handleError(ParseErrorCode.ValueExpected, [], []);
                    }
                    onSeparator(',');
                    scanNext(); // consume comma
                }
                else if (needsComma) {
                    handleError(ParseErrorCode.CommaExpected, [], []);
                }
                if (!parseValue()) {
                    handleError(ParseErrorCode.ValueExpected, [], [SyntaxKind.CloseBracketToken, SyntaxKind.CommaToken]);
                }
                needsComma = true;
            }
            onArrayEnd();
            if (_scanner.getToken() !== SyntaxKind.CloseBracketToken) {
                handleError(ParseErrorCode.CloseBracketExpected, [SyntaxKind.CloseBracketToken], []);
            }
            else {
                scanNext(); // consume close bracket
            }
            return true;
        }
        function parseValue() {
            return parseArray() || parseObject() || parseString(true) || parseLiteral();
        }
        scanNext();
        if (_scanner.getToken() === SyntaxKind.EOF) {
            return true;
        }
        if (!parseValue()) {
            handleError(ParseErrorCode.ValueExpected, [], []);
            return false;
        }
        if (_scanner.getToken() !== SyntaxKind.EOF) {
            handleError(ParseErrorCode.EndOfFileExpected, [], []);
        }
        return true;
    }
    exports.visit = visit;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[235], __M([0,1,124,21,4]), function (require, exports, json_1, position_1, range_1) {
    'use strict';
    var SmartSnippetInserter = (function () {
        function SmartSnippetInserter() {
        }
        SmartSnippetInserter.hasOpenBrace = function (scanner) {
            while (scanner.scan() !== json_1.SyntaxKind.EOF) {
                var kind = scanner.getToken();
                if (kind === json_1.SyntaxKind.OpenBraceToken) {
                    return true;
                }
            }
            return false;
        };
        SmartSnippetInserter.offsetToPosition = function (model, offset) {
            var offsetBeforeLine = 0;
            var eolLength = model.getEOL().length;
            var lineCount = model.getLineCount();
            for (var lineNumber = 1; lineNumber <= lineCount; lineNumber++) {
                var lineTotalLength = model.getLineContent(lineNumber).length + eolLength;
                var offsetAfterLine = offsetBeforeLine + lineTotalLength;
                if (offsetAfterLine > offset) {
                    return new position_1.Position(lineNumber, offset - offsetBeforeLine + 1);
                }
                offsetBeforeLine = offsetAfterLine;
            }
            return new position_1.Position(lineCount, model.getLineMaxColumn(lineCount));
        };
        SmartSnippetInserter.insertSnippet = function (model, _position) {
            var desiredPosition = model.getValueLengthInRange(new range_1.Range(1, 1, _position.lineNumber, _position.column));
            // <INVALID> [ <BEFORE_OBJECT> { <INVALID> } <AFTER_OBJECT>, <BEFORE_OBJECT> { <INVALID> } <AFTER_OBJECT> ] <INVALID>
            var State;
            (function (State) {
                State[State["INVALID"] = 0] = "INVALID";
                State[State["AFTER_OBJECT"] = 1] = "AFTER_OBJECT";
                State[State["BEFORE_OBJECT"] = 2] = "BEFORE_OBJECT";
            })(State || (State = {}));
            var currentState = State.INVALID;
            var lastValidPos = -1;
            var lastValidState = State.INVALID;
            var scanner = json_1.createScanner(model.getValue());
            var arrayLevel = 0;
            var objLevel = 0;
            var checkRangeStatus = function (pos, state) {
                if (state !== State.INVALID && arrayLevel === 1 && objLevel === 0) {
                    currentState = state;
                    lastValidPos = pos;
                    lastValidState = state;
                }
                else {
                    if (currentState !== State.INVALID) {
                        currentState = State.INVALID;
                        lastValidPos = scanner.getTokenOffset();
                    }
                }
            };
            while (scanner.scan() !== json_1.SyntaxKind.EOF) {
                var currentPos = scanner.getPosition();
                var kind = scanner.getToken();
                var goodKind = false;
                switch (kind) {
                    case json_1.SyntaxKind.OpenBracketToken:
                        goodKind = true;
                        arrayLevel++;
                        checkRangeStatus(currentPos, State.BEFORE_OBJECT);
                        break;
                    case json_1.SyntaxKind.CloseBracketToken:
                        goodKind = true;
                        arrayLevel--;
                        checkRangeStatus(currentPos, State.INVALID);
                        break;
                    case json_1.SyntaxKind.CommaToken:
                        goodKind = true;
                        checkRangeStatus(currentPos, State.BEFORE_OBJECT);
                        break;
                    case json_1.SyntaxKind.OpenBraceToken:
                        goodKind = true;
                        objLevel++;
                        checkRangeStatus(currentPos, State.INVALID);
                        break;
                    case json_1.SyntaxKind.CloseBraceToken:
                        goodKind = true;
                        objLevel--;
                        checkRangeStatus(currentPos, State.AFTER_OBJECT);
                        break;
                    case json_1.SyntaxKind.Trivia:
                    case json_1.SyntaxKind.LineBreakTrivia:
                        goodKind = true;
                }
                if (currentPos >= desiredPosition && (currentState !== State.INVALID || lastValidPos !== -1)) {
                    var acceptPosition = void 0;
                    var acceptState = void 0;
                    if (currentState !== State.INVALID) {
                        acceptPosition = (goodKind ? currentPos : scanner.getTokenOffset());
                        acceptState = currentState;
                    }
                    else {
                        acceptPosition = lastValidPos;
                        acceptState = lastValidState;
                    }
                    if (acceptState === State.AFTER_OBJECT) {
                        return {
                            position: this.offsetToPosition(model, acceptPosition),
                            prepend: ',',
                            append: ''
                        };
                    }
                    else {
                        scanner.setPosition(acceptPosition);
                        return {
                            position: this.offsetToPosition(model, acceptPosition),
                            prepend: '',
                            append: this.hasOpenBrace(scanner) ? ',' : ''
                        };
                    }
                }
            }
            // no valid position found!
            var modelLineCount = model.getLineCount();
            return {
                position: new position_1.Position(modelLineCount, model.getLineMaxColumn(modelLineCount)),
                prepend: '\n[',
                append: ']'
            };
        };
        return SmartSnippetInserter;
    }());
    exports.SmartSnippetInserter = SmartSnippetInserter;
});

define(__m[236], __M([5,6]), function(nls, data) { return nls.create("vs/base/common/keyCodes", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[12], __M([0,1,236,18]), function (require, exports, nls, defaultPlatform) {
    'use strict';
    /**
     * Virtual Key Codes, the value does not hold any inherent meaning.
     * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
     * But these are "more general", as they should work across browsers & OS`s.
     */
    (function (KeyCode) {
        /**
         * Placed first to cover the 0 value of the enum.
         */
        KeyCode[KeyCode["Unknown"] = 0] = "Unknown";
        KeyCode[KeyCode["Backspace"] = 1] = "Backspace";
        KeyCode[KeyCode["Tab"] = 2] = "Tab";
        KeyCode[KeyCode["Enter"] = 3] = "Enter";
        KeyCode[KeyCode["Shift"] = 4] = "Shift";
        KeyCode[KeyCode["Ctrl"] = 5] = "Ctrl";
        KeyCode[KeyCode["Alt"] = 6] = "Alt";
        KeyCode[KeyCode["PauseBreak"] = 7] = "PauseBreak";
        KeyCode[KeyCode["CapsLock"] = 8] = "CapsLock";
        KeyCode[KeyCode["Escape"] = 9] = "Escape";
        KeyCode[KeyCode["Space"] = 10] = "Space";
        KeyCode[KeyCode["PageUp"] = 11] = "PageUp";
        KeyCode[KeyCode["PageDown"] = 12] = "PageDown";
        KeyCode[KeyCode["End"] = 13] = "End";
        KeyCode[KeyCode["Home"] = 14] = "Home";
        KeyCode[KeyCode["LeftArrow"] = 15] = "LeftArrow";
        KeyCode[KeyCode["UpArrow"] = 16] = "UpArrow";
        KeyCode[KeyCode["RightArrow"] = 17] = "RightArrow";
        KeyCode[KeyCode["DownArrow"] = 18] = "DownArrow";
        KeyCode[KeyCode["Insert"] = 19] = "Insert";
        KeyCode[KeyCode["Delete"] = 20] = "Delete";
        KeyCode[KeyCode["KEY_0"] = 21] = "KEY_0";
        KeyCode[KeyCode["KEY_1"] = 22] = "KEY_1";
        KeyCode[KeyCode["KEY_2"] = 23] = "KEY_2";
        KeyCode[KeyCode["KEY_3"] = 24] = "KEY_3";
        KeyCode[KeyCode["KEY_4"] = 25] = "KEY_4";
        KeyCode[KeyCode["KEY_5"] = 26] = "KEY_5";
        KeyCode[KeyCode["KEY_6"] = 27] = "KEY_6";
        KeyCode[KeyCode["KEY_7"] = 28] = "KEY_7";
        KeyCode[KeyCode["KEY_8"] = 29] = "KEY_8";
        KeyCode[KeyCode["KEY_9"] = 30] = "KEY_9";
        KeyCode[KeyCode["KEY_A"] = 31] = "KEY_A";
        KeyCode[KeyCode["KEY_B"] = 32] = "KEY_B";
        KeyCode[KeyCode["KEY_C"] = 33] = "KEY_C";
        KeyCode[KeyCode["KEY_D"] = 34] = "KEY_D";
        KeyCode[KeyCode["KEY_E"] = 35] = "KEY_E";
        KeyCode[KeyCode["KEY_F"] = 36] = "KEY_F";
        KeyCode[KeyCode["KEY_G"] = 37] = "KEY_G";
        KeyCode[KeyCode["KEY_H"] = 38] = "KEY_H";
        KeyCode[KeyCode["KEY_I"] = 39] = "KEY_I";
        KeyCode[KeyCode["KEY_J"] = 40] = "KEY_J";
        KeyCode[KeyCode["KEY_K"] = 41] = "KEY_K";
        KeyCode[KeyCode["KEY_L"] = 42] = "KEY_L";
        KeyCode[KeyCode["KEY_M"] = 43] = "KEY_M";
        KeyCode[KeyCode["KEY_N"] = 44] = "KEY_N";
        KeyCode[KeyCode["KEY_O"] = 45] = "KEY_O";
        KeyCode[KeyCode["KEY_P"] = 46] = "KEY_P";
        KeyCode[KeyCode["KEY_Q"] = 47] = "KEY_Q";
        KeyCode[KeyCode["KEY_R"] = 48] = "KEY_R";
        KeyCode[KeyCode["KEY_S"] = 49] = "KEY_S";
        KeyCode[KeyCode["KEY_T"] = 50] = "KEY_T";
        KeyCode[KeyCode["KEY_U"] = 51] = "KEY_U";
        KeyCode[KeyCode["KEY_V"] = 52] = "KEY_V";
        KeyCode[KeyCode["KEY_W"] = 53] = "KEY_W";
        KeyCode[KeyCode["KEY_X"] = 54] = "KEY_X";
        KeyCode[KeyCode["KEY_Y"] = 55] = "KEY_Y";
        KeyCode[KeyCode["KEY_Z"] = 56] = "KEY_Z";
        KeyCode[KeyCode["Meta"] = 57] = "Meta";
        KeyCode[KeyCode["ContextMenu"] = 58] = "ContextMenu";
        KeyCode[KeyCode["F1"] = 59] = "F1";
        KeyCode[KeyCode["F2"] = 60] = "F2";
        KeyCode[KeyCode["F3"] = 61] = "F3";
        KeyCode[KeyCode["F4"] = 62] = "F4";
        KeyCode[KeyCode["F5"] = 63] = "F5";
        KeyCode[KeyCode["F6"] = 64] = "F6";
        KeyCode[KeyCode["F7"] = 65] = "F7";
        KeyCode[KeyCode["F8"] = 66] = "F8";
        KeyCode[KeyCode["F9"] = 67] = "F9";
        KeyCode[KeyCode["F10"] = 68] = "F10";
        KeyCode[KeyCode["F11"] = 69] = "F11";
        KeyCode[KeyCode["F12"] = 70] = "F12";
        KeyCode[KeyCode["F13"] = 71] = "F13";
        KeyCode[KeyCode["F14"] = 72] = "F14";
        KeyCode[KeyCode["F15"] = 73] = "F15";
        KeyCode[KeyCode["F16"] = 74] = "F16";
        KeyCode[KeyCode["F17"] = 75] = "F17";
        KeyCode[KeyCode["F18"] = 76] = "F18";
        KeyCode[KeyCode["F19"] = 77] = "F19";
        KeyCode[KeyCode["NumLock"] = 78] = "NumLock";
        KeyCode[KeyCode["ScrollLock"] = 79] = "ScrollLock";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ';:' key
         */
        KeyCode[KeyCode["US_SEMICOLON"] = 80] = "US_SEMICOLON";
        /**
         * For any country/region, the '+' key
         * For the US standard keyboard, the '=+' key
         */
        KeyCode[KeyCode["US_EQUAL"] = 81] = "US_EQUAL";
        /**
         * For any country/region, the ',' key
         * For the US standard keyboard, the ',<' key
         */
        KeyCode[KeyCode["US_COMMA"] = 82] = "US_COMMA";
        /**
         * For any country/region, the '-' key
         * For the US standard keyboard, the '-_' key
         */
        KeyCode[KeyCode["US_MINUS"] = 83] = "US_MINUS";
        /**
         * For any country/region, the '.' key
         * For the US standard keyboard, the '.>' key
         */
        KeyCode[KeyCode["US_DOT"] = 84] = "US_DOT";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '/?' key
         */
        KeyCode[KeyCode["US_SLASH"] = 85] = "US_SLASH";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '`~' key
         */
        KeyCode[KeyCode["US_BACKTICK"] = 86] = "US_BACKTICK";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '[{' key
         */
        KeyCode[KeyCode["US_OPEN_SQUARE_BRACKET"] = 87] = "US_OPEN_SQUARE_BRACKET";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '\|' key
         */
        KeyCode[KeyCode["US_BACKSLASH"] = 88] = "US_BACKSLASH";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ']}' key
         */
        KeyCode[KeyCode["US_CLOSE_SQUARE_BRACKET"] = 89] = "US_CLOSE_SQUARE_BRACKET";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ''"' key
         */
        KeyCode[KeyCode["US_QUOTE"] = 90] = "US_QUOTE";
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         */
        KeyCode[KeyCode["OEM_8"] = 91] = "OEM_8";
        /**
         * Either the angle bracket key or the backslash key on the RT 102-key keyboard.
         */
        KeyCode[KeyCode["OEM_102"] = 92] = "OEM_102";
        KeyCode[KeyCode["NUMPAD_0"] = 93] = "NUMPAD_0";
        KeyCode[KeyCode["NUMPAD_1"] = 94] = "NUMPAD_1";
        KeyCode[KeyCode["NUMPAD_2"] = 95] = "NUMPAD_2";
        KeyCode[KeyCode["NUMPAD_3"] = 96] = "NUMPAD_3";
        KeyCode[KeyCode["NUMPAD_4"] = 97] = "NUMPAD_4";
        KeyCode[KeyCode["NUMPAD_5"] = 98] = "NUMPAD_5";
        KeyCode[KeyCode["NUMPAD_6"] = 99] = "NUMPAD_6";
        KeyCode[KeyCode["NUMPAD_7"] = 100] = "NUMPAD_7";
        KeyCode[KeyCode["NUMPAD_8"] = 101] = "NUMPAD_8";
        KeyCode[KeyCode["NUMPAD_9"] = 102] = "NUMPAD_9";
        KeyCode[KeyCode["NUMPAD_MULTIPLY"] = 103] = "NUMPAD_MULTIPLY";
        KeyCode[KeyCode["NUMPAD_ADD"] = 104] = "NUMPAD_ADD";
        KeyCode[KeyCode["NUMPAD_SEPARATOR"] = 105] = "NUMPAD_SEPARATOR";
        KeyCode[KeyCode["NUMPAD_SUBTRACT"] = 106] = "NUMPAD_SUBTRACT";
        KeyCode[KeyCode["NUMPAD_DECIMAL"] = 107] = "NUMPAD_DECIMAL";
        KeyCode[KeyCode["NUMPAD_DIVIDE"] = 108] = "NUMPAD_DIVIDE";
        /**
         * Placed last to cover the length of the enum.
         */
        KeyCode[KeyCode["MAX_VALUE"] = 109] = "MAX_VALUE";
    })(exports.KeyCode || (exports.KeyCode = {}));
    var KeyCode = exports.KeyCode;
    var Mapping = (function () {
        function Mapping(fromKeyCode, toKeyCode) {
            this._fromKeyCode = fromKeyCode;
            this._toKeyCode = toKeyCode;
        }
        Mapping.prototype.fromKeyCode = function (keyCode) {
            return this._fromKeyCode[keyCode];
        };
        Mapping.prototype.toKeyCode = function (str) {
            if (this._toKeyCode.hasOwnProperty(str)) {
                return this._toKeyCode[str];
            }
            return KeyCode.Unknown;
        };
        return Mapping;
    }());
    function createMapping(fill1, fill2) {
        var MAP = [];
        fill1(MAP);
        var REVERSE_MAP = {};
        for (var i = 0, len = MAP.length; i < len; i++) {
            if (!MAP[i]) {
                continue;
            }
            REVERSE_MAP[MAP[i]] = i;
        }
        fill2(REVERSE_MAP);
        var FINAL_REVERSE_MAP = {};
        for (var entry in REVERSE_MAP) {
            if (REVERSE_MAP.hasOwnProperty(entry)) {
                FINAL_REVERSE_MAP[entry] = REVERSE_MAP[entry];
                FINAL_REVERSE_MAP[entry.toLowerCase()] = REVERSE_MAP[entry];
            }
        }
        return new Mapping(MAP, FINAL_REVERSE_MAP);
    }
    var STRING = createMapping(function (TO_STRING_MAP) {
        TO_STRING_MAP[KeyCode.Unknown] = 'unknown';
        TO_STRING_MAP[KeyCode.Backspace] = 'Backspace';
        TO_STRING_MAP[KeyCode.Tab] = 'Tab';
        TO_STRING_MAP[KeyCode.Enter] = 'Enter';
        TO_STRING_MAP[KeyCode.Shift] = 'Shift';
        TO_STRING_MAP[KeyCode.Ctrl] = 'Ctrl';
        TO_STRING_MAP[KeyCode.Alt] = 'Alt';
        TO_STRING_MAP[KeyCode.PauseBreak] = 'PauseBreak';
        TO_STRING_MAP[KeyCode.CapsLock] = 'CapsLock';
        TO_STRING_MAP[KeyCode.Escape] = 'Escape';
        TO_STRING_MAP[KeyCode.Space] = 'Space';
        TO_STRING_MAP[KeyCode.PageUp] = 'PageUp';
        TO_STRING_MAP[KeyCode.PageDown] = 'PageDown';
        TO_STRING_MAP[KeyCode.End] = 'End';
        TO_STRING_MAP[KeyCode.Home] = 'Home';
        TO_STRING_MAP[KeyCode.LeftArrow] = 'LeftArrow';
        TO_STRING_MAP[KeyCode.UpArrow] = 'UpArrow';
        TO_STRING_MAP[KeyCode.RightArrow] = 'RightArrow';
        TO_STRING_MAP[KeyCode.DownArrow] = 'DownArrow';
        TO_STRING_MAP[KeyCode.Insert] = 'Insert';
        TO_STRING_MAP[KeyCode.Delete] = 'Delete';
        TO_STRING_MAP[KeyCode.KEY_0] = '0';
        TO_STRING_MAP[KeyCode.KEY_1] = '1';
        TO_STRING_MAP[KeyCode.KEY_2] = '2';
        TO_STRING_MAP[KeyCode.KEY_3] = '3';
        TO_STRING_MAP[KeyCode.KEY_4] = '4';
        TO_STRING_MAP[KeyCode.KEY_5] = '5';
        TO_STRING_MAP[KeyCode.KEY_6] = '6';
        TO_STRING_MAP[KeyCode.KEY_7] = '7';
        TO_STRING_MAP[KeyCode.KEY_8] = '8';
        TO_STRING_MAP[KeyCode.KEY_9] = '9';
        TO_STRING_MAP[KeyCode.KEY_A] = 'A';
        TO_STRING_MAP[KeyCode.KEY_B] = 'B';
        TO_STRING_MAP[KeyCode.KEY_C] = 'C';
        TO_STRING_MAP[KeyCode.KEY_D] = 'D';
        TO_STRING_MAP[KeyCode.KEY_E] = 'E';
        TO_STRING_MAP[KeyCode.KEY_F] = 'F';
        TO_STRING_MAP[KeyCode.KEY_G] = 'G';
        TO_STRING_MAP[KeyCode.KEY_H] = 'H';
        TO_STRING_MAP[KeyCode.KEY_I] = 'I';
        TO_STRING_MAP[KeyCode.KEY_J] = 'J';
        TO_STRING_MAP[KeyCode.KEY_K] = 'K';
        TO_STRING_MAP[KeyCode.KEY_L] = 'L';
        TO_STRING_MAP[KeyCode.KEY_M] = 'M';
        TO_STRING_MAP[KeyCode.KEY_N] = 'N';
        TO_STRING_MAP[KeyCode.KEY_O] = 'O';
        TO_STRING_MAP[KeyCode.KEY_P] = 'P';
        TO_STRING_MAP[KeyCode.KEY_Q] = 'Q';
        TO_STRING_MAP[KeyCode.KEY_R] = 'R';
        TO_STRING_MAP[KeyCode.KEY_S] = 'S';
        TO_STRING_MAP[KeyCode.KEY_T] = 'T';
        TO_STRING_MAP[KeyCode.KEY_U] = 'U';
        TO_STRING_MAP[KeyCode.KEY_V] = 'V';
        TO_STRING_MAP[KeyCode.KEY_W] = 'W';
        TO_STRING_MAP[KeyCode.KEY_X] = 'X';
        TO_STRING_MAP[KeyCode.KEY_Y] = 'Y';
        TO_STRING_MAP[KeyCode.KEY_Z] = 'Z';
        TO_STRING_MAP[KeyCode.ContextMenu] = 'ContextMenu';
        TO_STRING_MAP[KeyCode.F1] = 'F1';
        TO_STRING_MAP[KeyCode.F2] = 'F2';
        TO_STRING_MAP[KeyCode.F3] = 'F3';
        TO_STRING_MAP[KeyCode.F4] = 'F4';
        TO_STRING_MAP[KeyCode.F5] = 'F5';
        TO_STRING_MAP[KeyCode.F6] = 'F6';
        TO_STRING_MAP[KeyCode.F7] = 'F7';
        TO_STRING_MAP[KeyCode.F8] = 'F8';
        TO_STRING_MAP[KeyCode.F9] = 'F9';
        TO_STRING_MAP[KeyCode.F10] = 'F10';
        TO_STRING_MAP[KeyCode.F11] = 'F11';
        TO_STRING_MAP[KeyCode.F12] = 'F12';
        TO_STRING_MAP[KeyCode.F13] = 'F13';
        TO_STRING_MAP[KeyCode.F14] = 'F14';
        TO_STRING_MAP[KeyCode.F15] = 'F15';
        TO_STRING_MAP[KeyCode.F16] = 'F16';
        TO_STRING_MAP[KeyCode.F17] = 'F17';
        TO_STRING_MAP[KeyCode.F18] = 'F18';
        TO_STRING_MAP[KeyCode.F19] = 'F19';
        TO_STRING_MAP[KeyCode.NumLock] = 'NumLock';
        TO_STRING_MAP[KeyCode.ScrollLock] = 'ScrollLock';
        TO_STRING_MAP[KeyCode.US_SEMICOLON] = ';';
        TO_STRING_MAP[KeyCode.US_EQUAL] = '=';
        TO_STRING_MAP[KeyCode.US_COMMA] = ',';
        TO_STRING_MAP[KeyCode.US_MINUS] = '-';
        TO_STRING_MAP[KeyCode.US_DOT] = '.';
        TO_STRING_MAP[KeyCode.US_SLASH] = '/';
        TO_STRING_MAP[KeyCode.US_BACKTICK] = '`';
        TO_STRING_MAP[KeyCode.US_OPEN_SQUARE_BRACKET] = '[';
        TO_STRING_MAP[KeyCode.US_BACKSLASH] = '\\';
        TO_STRING_MAP[KeyCode.US_CLOSE_SQUARE_BRACKET] = ']';
        TO_STRING_MAP[KeyCode.US_QUOTE] = '\'';
        TO_STRING_MAP[KeyCode.OEM_8] = 'OEM_8';
        TO_STRING_MAP[KeyCode.OEM_102] = 'OEM_102';
        TO_STRING_MAP[KeyCode.NUMPAD_0] = 'NumPad0';
        TO_STRING_MAP[KeyCode.NUMPAD_1] = 'NumPad1';
        TO_STRING_MAP[KeyCode.NUMPAD_2] = 'NumPad2';
        TO_STRING_MAP[KeyCode.NUMPAD_3] = 'NumPad3';
        TO_STRING_MAP[KeyCode.NUMPAD_4] = 'NumPad4';
        TO_STRING_MAP[KeyCode.NUMPAD_5] = 'NumPad5';
        TO_STRING_MAP[KeyCode.NUMPAD_6] = 'NumPad6';
        TO_STRING_MAP[KeyCode.NUMPAD_7] = 'NumPad7';
        TO_STRING_MAP[KeyCode.NUMPAD_8] = 'NumPad8';
        TO_STRING_MAP[KeyCode.NUMPAD_9] = 'NumPad9';
        TO_STRING_MAP[KeyCode.NUMPAD_MULTIPLY] = 'NumPad_Multiply';
        TO_STRING_MAP[KeyCode.NUMPAD_ADD] = 'NumPad_Add';
        TO_STRING_MAP[KeyCode.NUMPAD_SEPARATOR] = 'NumPad_Separator';
        TO_STRING_MAP[KeyCode.NUMPAD_SUBTRACT] = 'NumPad_Subtract';
        TO_STRING_MAP[KeyCode.NUMPAD_DECIMAL] = 'NumPad_Decimal';
        TO_STRING_MAP[KeyCode.NUMPAD_DIVIDE] = 'NumPad_Divide';
        // for (let i = 0; i < KeyCode.MAX_VALUE; i++) {
        // 	if (!TO_STRING_MAP[i]) {
        // 		console.warn('Missing string representation for ' + KeyCode[i]);
        // 	}
        // }
    }, function (FROM_STRING_MAP) {
        FROM_STRING_MAP['\r'] = KeyCode.Enter;
    });
    var USER_SETTINGS = createMapping(function (TO_USER_SETTINGS_MAP) {
        for (var i = 0, len = STRING._fromKeyCode.length; i < len; i++) {
            TO_USER_SETTINGS_MAP[i] = STRING._fromKeyCode[i];
        }
        TO_USER_SETTINGS_MAP[KeyCode.LeftArrow] = 'Left';
        TO_USER_SETTINGS_MAP[KeyCode.UpArrow] = 'Up';
        TO_USER_SETTINGS_MAP[KeyCode.RightArrow] = 'Right';
        TO_USER_SETTINGS_MAP[KeyCode.DownArrow] = 'Down';
    }, function (FROM_USER_SETTINGS_MAP) {
        FROM_USER_SETTINGS_MAP['OEM_1'] = KeyCode.US_SEMICOLON;
        FROM_USER_SETTINGS_MAP['OEM_PLUS'] = KeyCode.US_EQUAL;
        FROM_USER_SETTINGS_MAP['OEM_COMMA'] = KeyCode.US_COMMA;
        FROM_USER_SETTINGS_MAP['OEM_MINUS'] = KeyCode.US_MINUS;
        FROM_USER_SETTINGS_MAP['OEM_PERIOD'] = KeyCode.US_DOT;
        FROM_USER_SETTINGS_MAP['OEM_2'] = KeyCode.US_SLASH;
        FROM_USER_SETTINGS_MAP['OEM_3'] = KeyCode.US_BACKTICK;
        FROM_USER_SETTINGS_MAP['OEM_4'] = KeyCode.US_OPEN_SQUARE_BRACKET;
        FROM_USER_SETTINGS_MAP['OEM_5'] = KeyCode.US_BACKSLASH;
        FROM_USER_SETTINGS_MAP['OEM_6'] = KeyCode.US_CLOSE_SQUARE_BRACKET;
        FROM_USER_SETTINGS_MAP['OEM_7'] = KeyCode.US_QUOTE;
        FROM_USER_SETTINGS_MAP['OEM_8'] = KeyCode.OEM_8;
        FROM_USER_SETTINGS_MAP['OEM_102'] = KeyCode.OEM_102;
    });
    var KeyCode;
    (function (KeyCode) {
        function toString(key) {
            return STRING.fromKeyCode(key);
        }
        KeyCode.toString = toString;
        function fromString(key) {
            return STRING.toKeyCode(key);
        }
        KeyCode.fromString = fromString;
    })(KeyCode = exports.KeyCode || (exports.KeyCode = {}));
    // Binary encoding strategy:
    // 15:  1 bit for ctrlCmd
    // 14:  1 bit for shift
    // 13:  1 bit for alt
    // 12:  1 bit for winCtrl
    //  0: 12 bits for keyCode (up to a maximum keyCode of 4096. Given we have 83 at this point thats good enough)
    var BIN_CTRLCMD_MASK = 1 << 15;
    var BIN_SHIFT_MASK = 1 << 14;
    var BIN_ALT_MASK = 1 << 13;
    var BIN_WINCTRL_MASK = 1 << 12;
    var BIN_KEYCODE_MASK = 0x00000fff;
    var BinaryKeybindings = (function () {
        function BinaryKeybindings() {
        }
        BinaryKeybindings.extractFirstPart = function (keybinding) {
            return keybinding & 0x0000ffff;
        };
        BinaryKeybindings.extractChordPart = function (keybinding) {
            return (keybinding >> 16) & 0x0000ffff;
        };
        BinaryKeybindings.hasChord = function (keybinding) {
            return (this.extractChordPart(keybinding) !== 0);
        };
        BinaryKeybindings.hasCtrlCmd = function (keybinding) {
            return (keybinding & BIN_CTRLCMD_MASK ? true : false);
        };
        BinaryKeybindings.hasShift = function (keybinding) {
            return (keybinding & BIN_SHIFT_MASK ? true : false);
        };
        BinaryKeybindings.hasAlt = function (keybinding) {
            return (keybinding & BIN_ALT_MASK ? true : false);
        };
        BinaryKeybindings.hasWinCtrl = function (keybinding) {
            return (keybinding & BIN_WINCTRL_MASK ? true : false);
        };
        BinaryKeybindings.extractKeyCode = function (keybinding) {
            return (keybinding & BIN_KEYCODE_MASK);
        };
        return BinaryKeybindings;
    }());
    exports.BinaryKeybindings = BinaryKeybindings;
    var KeyMod = (function () {
        function KeyMod() {
        }
        KeyMod.chord = function (firstPart, secondPart) {
            return firstPart | ((secondPart & 0x0000ffff) << 16);
        };
        KeyMod.CtrlCmd = BIN_CTRLCMD_MASK;
        KeyMod.Shift = BIN_SHIFT_MASK;
        KeyMod.Alt = BIN_ALT_MASK;
        KeyMod.WinCtrl = BIN_WINCTRL_MASK;
        return KeyMod;
    }());
    exports.KeyMod = KeyMod;
    /**
     * A set of usual keybindings that can be reused in code
     */
    var CommonKeybindings = (function () {
        function CommonKeybindings() {
        }
        CommonKeybindings.ENTER = KeyCode.Enter;
        CommonKeybindings.SHIFT_ENTER = KeyMod.Shift | KeyCode.Enter;
        CommonKeybindings.CTRLCMD_ENTER = KeyMod.CtrlCmd | KeyCode.Enter;
        CommonKeybindings.WINCTRL_ENTER = KeyMod.WinCtrl | KeyCode.Enter;
        CommonKeybindings.TAB = KeyCode.Tab;
        CommonKeybindings.SHIFT_TAB = KeyMod.Shift | KeyCode.Tab;
        CommonKeybindings.ESCAPE = KeyCode.Escape;
        CommonKeybindings.SPACE = KeyCode.Space;
        CommonKeybindings.DELETE = KeyCode.Delete;
        CommonKeybindings.SHIFT_DELETE = KeyMod.Shift | KeyCode.Delete;
        CommonKeybindings.CTRLCMD_BACKSPACE = KeyMod.CtrlCmd | KeyCode.Backspace;
        CommonKeybindings.UP_ARROW = KeyCode.UpArrow;
        CommonKeybindings.SHIFT_UP_ARROW = KeyMod.Shift | KeyCode.UpArrow;
        CommonKeybindings.CTRLCMD_UP_ARROW = KeyMod.CtrlCmd | KeyCode.UpArrow;
        CommonKeybindings.DOWN_ARROW = KeyCode.DownArrow;
        CommonKeybindings.SHIFT_DOWN_ARROW = KeyMod.Shift | KeyCode.DownArrow;
        CommonKeybindings.CTRLCMD_DOWN_ARROW = KeyMod.CtrlCmd | KeyCode.DownArrow;
        CommonKeybindings.LEFT_ARROW = KeyCode.LeftArrow;
        CommonKeybindings.RIGHT_ARROW = KeyCode.RightArrow;
        CommonKeybindings.HOME = KeyCode.Home;
        CommonKeybindings.END = KeyCode.End;
        CommonKeybindings.PAGE_UP = KeyCode.PageUp;
        CommonKeybindings.SHIFT_PAGE_UP = KeyMod.Shift | KeyCode.PageUp;
        CommonKeybindings.PAGE_DOWN = KeyCode.PageDown;
        CommonKeybindings.SHIFT_PAGE_DOWN = KeyMod.Shift | KeyCode.PageDown;
        CommonKeybindings.F2 = KeyCode.F2;
        CommonKeybindings.CTRLCMD_S = KeyMod.CtrlCmd | KeyCode.KEY_S;
        CommonKeybindings.CTRLCMD_C = KeyMod.CtrlCmd | KeyCode.KEY_C;
        CommonKeybindings.CTRLCMD_V = KeyMod.CtrlCmd | KeyCode.KEY_V;
        return CommonKeybindings;
    }());
    exports.CommonKeybindings = CommonKeybindings;
    var Keybinding = (function () {
        function Keybinding(keybinding) {
            this.value = keybinding;
        }
        /**
         * Format the binding to a format appropiate for rendering in the UI
         */
        Keybinding._toUSLabel = function (value, Platform) {
            return _asString(value, (Platform.isMacintosh ? MacUIKeyLabelProvider.INSTANCE : ClassicUIKeyLabelProvider.INSTANCE), Platform);
        };
        /**
         * Format the binding to a format appropiate for placing in an aria-label.
         */
        Keybinding._toUSAriaLabel = function (value, Platform) {
            return _asString(value, AriaKeyLabelProvider.INSTANCE, Platform);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         */
        Keybinding._toUSHTMLLabel = function (value, Platform) {
            return _asHTML(value, (Platform.isMacintosh ? MacUIKeyLabelProvider.INSTANCE : ClassicUIKeyLabelProvider.INSTANCE), Platform);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         */
        Keybinding._toCustomLabel = function (value, labelProvider, Platform) {
            return _asString(value, labelProvider, Platform);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         */
        Keybinding._toCustomHTMLLabel = function (value, labelProvider, Platform) {
            return _asHTML(value, labelProvider, Platform);
        };
        /**
         * This prints the binding in a format suitable for electron's accelerators.
         * See https://github.com/electron/electron/blob/master/docs/api/accelerator.md
         */
        Keybinding._toElectronAccelerator = function (value, Platform) {
            if (BinaryKeybindings.hasChord(value)) {
                // Electron cannot handle chords
                return null;
            }
            return _asString(value, ElectronAcceleratorLabelProvider.INSTANCE, Platform);
        };
        Keybinding.getUserSettingsKeybindingRegex = function () {
            if (!this._cachedKeybindingRegex) {
                var numpadKey = 'numpad(0|1|2|3|4|5|6|7|8|9|_multiply|_add|_subtract|_decimal|_divide|_separator)';
                var oemKey = '`|\\-|=|\\[|\\]|\\\\\\\\|;|\'|,|\\.|\\/|oem_8|oem_102';
                var specialKey = 'left|up|right|down|pageup|pagedown|end|home|tab|enter|escape|space|backspace|delete|pausebreak|capslock|insert|contextmenu|numlock|scrolllock';
                var casualKey = '[a-z]|[0-9]|f(1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19)';
                var key = '((' + [numpadKey, oemKey, specialKey, casualKey].join(')|(') + '))';
                var mod = '((ctrl|shift|alt|cmd|win|meta)\\+)*';
                var keybinding = '(' + mod + key + ')';
                this._cachedKeybindingRegex = '"\\s*(' + keybinding + '(\\s+' + keybinding + ')?' + ')\\s*"';
            }
            return this._cachedKeybindingRegex;
        };
        /**
         * Format the binding to a format appropiate for the user settings file.
         */
        Keybinding.toUserSettingsLabel = function (value, Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            var result = _asString(value, UserSettingsKeyLabelProvider.INSTANCE, Platform);
            result = result.toLowerCase();
            if (Platform.isMacintosh) {
                result = result.replace(/meta/g, 'cmd');
            }
            else if (Platform.isWindows) {
                result = result.replace(/meta/g, 'win');
            }
            return result;
        };
        Keybinding.fromUserSettingsLabel = function (input, Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            if (!input) {
                return null;
            }
            input = input.toLowerCase().trim();
            var ctrlCmd = false, shift = false, alt = false, winCtrl = false, key = '';
            while (/^(ctrl|shift|alt|meta|win|cmd)(\+|\-)/.test(input)) {
                if (/^ctrl(\+|\-)/.test(input)) {
                    if (Platform.isMacintosh) {
                        winCtrl = true;
                    }
                    else {
                        ctrlCmd = true;
                    }
                    input = input.substr('ctrl-'.length);
                }
                if (/^shift(\+|\-)/.test(input)) {
                    shift = true;
                    input = input.substr('shift-'.length);
                }
                if (/^alt(\+|\-)/.test(input)) {
                    alt = true;
                    input = input.substr('alt-'.length);
                }
                if (/^meta(\+|\-)/.test(input)) {
                    if (Platform.isMacintosh) {
                        ctrlCmd = true;
                    }
                    else {
                        winCtrl = true;
                    }
                    input = input.substr('meta-'.length);
                }
                if (/^win(\+|\-)/.test(input)) {
                    if (Platform.isMacintosh) {
                        ctrlCmd = true;
                    }
                    else {
                        winCtrl = true;
                    }
                    input = input.substr('win-'.length);
                }
                if (/^cmd(\+|\-)/.test(input)) {
                    if (Platform.isMacintosh) {
                        ctrlCmd = true;
                    }
                    else {
                        winCtrl = true;
                    }
                    input = input.substr('cmd-'.length);
                }
            }
            var chord = 0;
            var firstSpaceIdx = input.indexOf(' ');
            if (firstSpaceIdx > 0) {
                key = input.substring(0, firstSpaceIdx);
                chord = Keybinding.fromUserSettingsLabel(input.substring(firstSpaceIdx), Platform);
            }
            else {
                key = input;
            }
            var keyCode = USER_SETTINGS.toKeyCode(key);
            var result = 0;
            if (ctrlCmd) {
                result |= KeyMod.CtrlCmd;
            }
            if (shift) {
                result |= KeyMod.Shift;
            }
            if (alt) {
                result |= KeyMod.Alt;
            }
            if (winCtrl) {
                result |= KeyMod.WinCtrl;
            }
            result |= keyCode;
            return KeyMod.chord(result, chord);
        };
        Keybinding.prototype.hasCtrlCmd = function () {
            return BinaryKeybindings.hasCtrlCmd(this.value);
        };
        Keybinding.prototype.hasShift = function () {
            return BinaryKeybindings.hasShift(this.value);
        };
        Keybinding.prototype.hasAlt = function () {
            return BinaryKeybindings.hasAlt(this.value);
        };
        Keybinding.prototype.hasWinCtrl = function () {
            return BinaryKeybindings.hasWinCtrl(this.value);
        };
        Keybinding.prototype.extractKeyCode = function () {
            return BinaryKeybindings.extractKeyCode(this.value);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         */
        Keybinding.prototype._toUSLabel = function (Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return Keybinding._toUSLabel(this.value, Platform);
        };
        /**
         * Format the binding to a format appropiate for placing in an aria-label.
         */
        Keybinding.prototype._toUSAriaLabel = function (Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return Keybinding._toUSAriaLabel(this.value, Platform);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         */
        Keybinding.prototype._toUSHTMLLabel = function (Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return Keybinding._toUSHTMLLabel(this.value, Platform);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         */
        Keybinding.prototype.toCustomLabel = function (labelProvider, Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return Keybinding._toCustomLabel(this.value, labelProvider, Platform);
        };
        /**
         * Format the binding to a format appropiate for rendering in the UI
         */
        Keybinding.prototype.toCustomHTMLLabel = function (labelProvider, Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return Keybinding._toCustomHTMLLabel(this.value, labelProvider, Platform);
        };
        /**
         * This prints the binding in a format suitable for electron's accelerators.
         * See https://github.com/electron/electron/blob/master/docs/api/accelerator.md
         */
        Keybinding.prototype._toElectronAccelerator = function (Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return Keybinding._toElectronAccelerator(this.value, Platform);
        };
        /**
         * Format the binding to a format appropiate for the user settings file.
         */
        Keybinding.prototype.toUserSettingsLabel = function (Platform) {
            if (Platform === void 0) { Platform = defaultPlatform; }
            return Keybinding.toUserSettingsLabel(this.value, Platform);
        };
        Keybinding._cachedKeybindingRegex = null;
        return Keybinding;
    }());
    exports.Keybinding = Keybinding;
    /**
     * Print for Electron
     */
    var ElectronAcceleratorLabelProvider = (function () {
        function ElectronAcceleratorLabelProvider() {
            this.ctrlKeyLabel = 'Ctrl';
            this.shiftKeyLabel = 'Shift';
            this.altKeyLabel = 'Alt';
            this.cmdKeyLabel = 'Cmd';
            this.windowsKeyLabel = 'Super';
            this.modifierSeparator = '+';
        }
        ElectronAcceleratorLabelProvider.prototype.getLabelForKey = function (keyCode) {
            switch (keyCode) {
                case KeyCode.UpArrow:
                    return 'Up';
                case KeyCode.DownArrow:
                    return 'Down';
                case KeyCode.LeftArrow:
                    return 'Left';
                case KeyCode.RightArrow:
                    return 'Right';
            }
            return KeyCode.toString(keyCode);
        };
        ElectronAcceleratorLabelProvider.INSTANCE = new ElectronAcceleratorLabelProvider();
        return ElectronAcceleratorLabelProvider;
    }());
    exports.ElectronAcceleratorLabelProvider = ElectronAcceleratorLabelProvider;
    /**
     * Print for Mac UI
     */
    var MacUIKeyLabelProvider = (function () {
        function MacUIKeyLabelProvider() {
            this.ctrlKeyLabel = '\u2303';
            this.shiftKeyLabel = '\u21E7';
            this.altKeyLabel = '\u2325';
            this.cmdKeyLabel = '\u2318';
            this.windowsKeyLabel = nls.localize(0, null);
            this.modifierSeparator = '';
        }
        MacUIKeyLabelProvider.prototype.getLabelForKey = function (keyCode) {
            switch (keyCode) {
                case KeyCode.LeftArrow:
                    return MacUIKeyLabelProvider.leftArrowUnicodeLabel;
                case KeyCode.UpArrow:
                    return MacUIKeyLabelProvider.upArrowUnicodeLabel;
                case KeyCode.RightArrow:
                    return MacUIKeyLabelProvider.rightArrowUnicodeLabel;
                case KeyCode.DownArrow:
                    return MacUIKeyLabelProvider.downArrowUnicodeLabel;
            }
            return KeyCode.toString(keyCode);
        };
        MacUIKeyLabelProvider.INSTANCE = new MacUIKeyLabelProvider();
        MacUIKeyLabelProvider.leftArrowUnicodeLabel = String.fromCharCode(8592);
        MacUIKeyLabelProvider.upArrowUnicodeLabel = String.fromCharCode(8593);
        MacUIKeyLabelProvider.rightArrowUnicodeLabel = String.fromCharCode(8594);
        MacUIKeyLabelProvider.downArrowUnicodeLabel = String.fromCharCode(8595);
        return MacUIKeyLabelProvider;
    }());
    exports.MacUIKeyLabelProvider = MacUIKeyLabelProvider;
    /**
     * Aria label provider for Mac.
     */
    var AriaKeyLabelProvider = (function () {
        function AriaKeyLabelProvider() {
            this.ctrlKeyLabel = nls.localize(1, null);
            this.shiftKeyLabel = nls.localize(2, null);
            this.altKeyLabel = nls.localize(3, null);
            this.cmdKeyLabel = nls.localize(4, null);
            this.windowsKeyLabel = nls.localize(5, null);
            this.modifierSeparator = '+';
        }
        AriaKeyLabelProvider.prototype.getLabelForKey = function (keyCode) {
            return KeyCode.toString(keyCode);
        };
        AriaKeyLabelProvider.INSTANCE = new MacUIKeyLabelProvider();
        return AriaKeyLabelProvider;
    }());
    exports.AriaKeyLabelProvider = AriaKeyLabelProvider;
    /**
     * Print for Windows, Linux UI
     */
    var ClassicUIKeyLabelProvider = (function () {
        function ClassicUIKeyLabelProvider() {
            this.ctrlKeyLabel = nls.localize(6, null);
            this.shiftKeyLabel = nls.localize(7, null);
            this.altKeyLabel = nls.localize(8, null);
            this.cmdKeyLabel = nls.localize(9, null);
            this.windowsKeyLabel = nls.localize(10, null);
            this.modifierSeparator = '+';
        }
        ClassicUIKeyLabelProvider.prototype.getLabelForKey = function (keyCode) {
            return KeyCode.toString(keyCode);
        };
        ClassicUIKeyLabelProvider.INSTANCE = new ClassicUIKeyLabelProvider();
        return ClassicUIKeyLabelProvider;
    }());
    exports.ClassicUIKeyLabelProvider = ClassicUIKeyLabelProvider;
    /**
     * Print for the user settings file.
     */
    var UserSettingsKeyLabelProvider = (function () {
        function UserSettingsKeyLabelProvider() {
            this.ctrlKeyLabel = 'Ctrl';
            this.shiftKeyLabel = 'Shift';
            this.altKeyLabel = 'Alt';
            this.cmdKeyLabel = 'Meta';
            this.windowsKeyLabel = 'Meta';
            this.modifierSeparator = '+';
        }
        UserSettingsKeyLabelProvider.prototype.getLabelForKey = function (keyCode) {
            return USER_SETTINGS.fromKeyCode(keyCode);
        };
        UserSettingsKeyLabelProvider.INSTANCE = new UserSettingsKeyLabelProvider();
        return UserSettingsKeyLabelProvider;
    }());
    function _asString(keybinding, labelProvider, Platform) {
        var result = [], ctrlCmd = BinaryKeybindings.hasCtrlCmd(keybinding), shift = BinaryKeybindings.hasShift(keybinding), alt = BinaryKeybindings.hasAlt(keybinding), winCtrl = BinaryKeybindings.hasWinCtrl(keybinding), keyCode = BinaryKeybindings.extractKeyCode(keybinding);
        var keyLabel = labelProvider.getLabelForKey(keyCode);
        if (!keyLabel) {
            // cannot trigger this key code under this kb layout
            return '';
        }
        // translate modifier keys: Ctrl-Shift-Alt-Meta
        if ((ctrlCmd && !Platform.isMacintosh) || (winCtrl && Platform.isMacintosh)) {
            result.push(labelProvider.ctrlKeyLabel);
        }
        if (shift) {
            result.push(labelProvider.shiftKeyLabel);
        }
        if (alt) {
            result.push(labelProvider.altKeyLabel);
        }
        if (ctrlCmd && Platform.isMacintosh) {
            result.push(labelProvider.cmdKeyLabel);
        }
        if (winCtrl && !Platform.isMacintosh) {
            result.push(labelProvider.windowsKeyLabel);
        }
        // the actual key
        result.push(keyLabel);
        var actualResult = result.join(labelProvider.modifierSeparator);
        if (BinaryKeybindings.hasChord(keybinding)) {
            return actualResult + ' ' + _asString(BinaryKeybindings.extractChordPart(keybinding), labelProvider, Platform);
        }
        return actualResult;
    }
    function _pushKey(result, str) {
        if (result.length > 0) {
            result.push({
                tagName: 'span',
                text: '+'
            });
        }
        result.push({
            tagName: 'span',
            className: 'monaco-kbkey',
            text: str
        });
    }
    function _asHTML(keybinding, labelProvider, Platform, isChord) {
        if (isChord === void 0) { isChord = false; }
        var result = [], ctrlCmd = BinaryKeybindings.hasCtrlCmd(keybinding), shift = BinaryKeybindings.hasShift(keybinding), alt = BinaryKeybindings.hasAlt(keybinding), winCtrl = BinaryKeybindings.hasWinCtrl(keybinding), keyCode = BinaryKeybindings.extractKeyCode(keybinding);
        var keyLabel = labelProvider.getLabelForKey(keyCode);
        if (!keyLabel) {
            // cannot trigger this key code under this kb layout
            return [];
        }
        // translate modifier keys: Ctrl-Shift-Alt-Meta
        if ((ctrlCmd && !Platform.isMacintosh) || (winCtrl && Platform.isMacintosh)) {
            _pushKey(result, labelProvider.ctrlKeyLabel);
        }
        if (shift) {
            _pushKey(result, labelProvider.shiftKeyLabel);
        }
        if (alt) {
            _pushKey(result, labelProvider.altKeyLabel);
        }
        if (ctrlCmd && Platform.isMacintosh) {
            _pushKey(result, labelProvider.cmdKeyLabel);
        }
        if (winCtrl && !Platform.isMacintosh) {
            _pushKey(result, labelProvider.windowsKeyLabel);
        }
        // the actual key
        _pushKey(result, keyLabel);
        var chordTo = null;
        if (BinaryKeybindings.hasChord(keybinding)) {
            chordTo = _asHTML(BinaryKeybindings.extractChordPart(keybinding), labelProvider, Platform, true);
            result.push({
                tagName: 'span',
                text: ' '
            });
            result = result.concat(chordTo);
        }
        if (isChord) {
            return result;
        }
        return [{
                tagName: 'span',
                className: 'monaco-kb',
                children: result
            }];
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[56], __M([0,1,12,18,28]), function (require, exports, keyCodes_1, platform, browser) {
    'use strict';
    var KEY_CODE_MAP = {};
    (function () {
        KEY_CODE_MAP[3] = keyCodes_1.KeyCode.PauseBreak; // VK_CANCEL 0x03 Control-break processing
        KEY_CODE_MAP[8] = keyCodes_1.KeyCode.Backspace;
        KEY_CODE_MAP[9] = keyCodes_1.KeyCode.Tab;
        KEY_CODE_MAP[13] = keyCodes_1.KeyCode.Enter;
        KEY_CODE_MAP[16] = keyCodes_1.KeyCode.Shift;
        KEY_CODE_MAP[17] = keyCodes_1.KeyCode.Ctrl;
        KEY_CODE_MAP[18] = keyCodes_1.KeyCode.Alt;
        KEY_CODE_MAP[19] = keyCodes_1.KeyCode.PauseBreak;
        KEY_CODE_MAP[20] = keyCodes_1.KeyCode.CapsLock;
        KEY_CODE_MAP[27] = keyCodes_1.KeyCode.Escape;
        KEY_CODE_MAP[32] = keyCodes_1.KeyCode.Space;
        KEY_CODE_MAP[33] = keyCodes_1.KeyCode.PageUp;
        KEY_CODE_MAP[34] = keyCodes_1.KeyCode.PageDown;
        KEY_CODE_MAP[35] = keyCodes_1.KeyCode.End;
        KEY_CODE_MAP[36] = keyCodes_1.KeyCode.Home;
        KEY_CODE_MAP[37] = keyCodes_1.KeyCode.LeftArrow;
        KEY_CODE_MAP[38] = keyCodes_1.KeyCode.UpArrow;
        KEY_CODE_MAP[39] = keyCodes_1.KeyCode.RightArrow;
        KEY_CODE_MAP[40] = keyCodes_1.KeyCode.DownArrow;
        KEY_CODE_MAP[45] = keyCodes_1.KeyCode.Insert;
        KEY_CODE_MAP[46] = keyCodes_1.KeyCode.Delete;
        KEY_CODE_MAP[48] = keyCodes_1.KeyCode.KEY_0;
        KEY_CODE_MAP[49] = keyCodes_1.KeyCode.KEY_1;
        KEY_CODE_MAP[50] = keyCodes_1.KeyCode.KEY_2;
        KEY_CODE_MAP[51] = keyCodes_1.KeyCode.KEY_3;
        KEY_CODE_MAP[52] = keyCodes_1.KeyCode.KEY_4;
        KEY_CODE_MAP[53] = keyCodes_1.KeyCode.KEY_5;
        KEY_CODE_MAP[54] = keyCodes_1.KeyCode.KEY_6;
        KEY_CODE_MAP[55] = keyCodes_1.KeyCode.KEY_7;
        KEY_CODE_MAP[56] = keyCodes_1.KeyCode.KEY_8;
        KEY_CODE_MAP[57] = keyCodes_1.KeyCode.KEY_9;
        KEY_CODE_MAP[65] = keyCodes_1.KeyCode.KEY_A;
        KEY_CODE_MAP[66] = keyCodes_1.KeyCode.KEY_B;
        KEY_CODE_MAP[67] = keyCodes_1.KeyCode.KEY_C;
        KEY_CODE_MAP[68] = keyCodes_1.KeyCode.KEY_D;
        KEY_CODE_MAP[69] = keyCodes_1.KeyCode.KEY_E;
        KEY_CODE_MAP[70] = keyCodes_1.KeyCode.KEY_F;
        KEY_CODE_MAP[71] = keyCodes_1.KeyCode.KEY_G;
        KEY_CODE_MAP[72] = keyCodes_1.KeyCode.KEY_H;
        KEY_CODE_MAP[73] = keyCodes_1.KeyCode.KEY_I;
        KEY_CODE_MAP[74] = keyCodes_1.KeyCode.KEY_J;
        KEY_CODE_MAP[75] = keyCodes_1.KeyCode.KEY_K;
        KEY_CODE_MAP[76] = keyCodes_1.KeyCode.KEY_L;
        KEY_CODE_MAP[77] = keyCodes_1.KeyCode.KEY_M;
        KEY_CODE_MAP[78] = keyCodes_1.KeyCode.KEY_N;
        KEY_CODE_MAP[79] = keyCodes_1.KeyCode.KEY_O;
        KEY_CODE_MAP[80] = keyCodes_1.KeyCode.KEY_P;
        KEY_CODE_MAP[81] = keyCodes_1.KeyCode.KEY_Q;
        KEY_CODE_MAP[82] = keyCodes_1.KeyCode.KEY_R;
        KEY_CODE_MAP[83] = keyCodes_1.KeyCode.KEY_S;
        KEY_CODE_MAP[84] = keyCodes_1.KeyCode.KEY_T;
        KEY_CODE_MAP[85] = keyCodes_1.KeyCode.KEY_U;
        KEY_CODE_MAP[86] = keyCodes_1.KeyCode.KEY_V;
        KEY_CODE_MAP[87] = keyCodes_1.KeyCode.KEY_W;
        KEY_CODE_MAP[88] = keyCodes_1.KeyCode.KEY_X;
        KEY_CODE_MAP[89] = keyCodes_1.KeyCode.KEY_Y;
        KEY_CODE_MAP[90] = keyCodes_1.KeyCode.KEY_Z;
        KEY_CODE_MAP[93] = keyCodes_1.KeyCode.ContextMenu;
        KEY_CODE_MAP[96] = keyCodes_1.KeyCode.NUMPAD_0;
        KEY_CODE_MAP[97] = keyCodes_1.KeyCode.NUMPAD_1;
        KEY_CODE_MAP[98] = keyCodes_1.KeyCode.NUMPAD_2;
        KEY_CODE_MAP[99] = keyCodes_1.KeyCode.NUMPAD_3;
        KEY_CODE_MAP[100] = keyCodes_1.KeyCode.NUMPAD_4;
        KEY_CODE_MAP[101] = keyCodes_1.KeyCode.NUMPAD_5;
        KEY_CODE_MAP[102] = keyCodes_1.KeyCode.NUMPAD_6;
        KEY_CODE_MAP[103] = keyCodes_1.KeyCode.NUMPAD_7;
        KEY_CODE_MAP[104] = keyCodes_1.KeyCode.NUMPAD_8;
        KEY_CODE_MAP[105] = keyCodes_1.KeyCode.NUMPAD_9;
        KEY_CODE_MAP[106] = keyCodes_1.KeyCode.NUMPAD_MULTIPLY;
        KEY_CODE_MAP[107] = keyCodes_1.KeyCode.NUMPAD_ADD;
        KEY_CODE_MAP[108] = keyCodes_1.KeyCode.NUMPAD_SEPARATOR;
        KEY_CODE_MAP[109] = keyCodes_1.KeyCode.NUMPAD_SUBTRACT;
        KEY_CODE_MAP[110] = keyCodes_1.KeyCode.NUMPAD_DECIMAL;
        KEY_CODE_MAP[111] = keyCodes_1.KeyCode.NUMPAD_DIVIDE;
        KEY_CODE_MAP[112] = keyCodes_1.KeyCode.F1;
        KEY_CODE_MAP[113] = keyCodes_1.KeyCode.F2;
        KEY_CODE_MAP[114] = keyCodes_1.KeyCode.F3;
        KEY_CODE_MAP[115] = keyCodes_1.KeyCode.F4;
        KEY_CODE_MAP[116] = keyCodes_1.KeyCode.F5;
        KEY_CODE_MAP[117] = keyCodes_1.KeyCode.F6;
        KEY_CODE_MAP[118] = keyCodes_1.KeyCode.F7;
        KEY_CODE_MAP[119] = keyCodes_1.KeyCode.F8;
        KEY_CODE_MAP[120] = keyCodes_1.KeyCode.F9;
        KEY_CODE_MAP[121] = keyCodes_1.KeyCode.F10;
        KEY_CODE_MAP[122] = keyCodes_1.KeyCode.F11;
        KEY_CODE_MAP[123] = keyCodes_1.KeyCode.F12;
        KEY_CODE_MAP[124] = keyCodes_1.KeyCode.F13;
        KEY_CODE_MAP[125] = keyCodes_1.KeyCode.F14;
        KEY_CODE_MAP[126] = keyCodes_1.KeyCode.F15;
        KEY_CODE_MAP[127] = keyCodes_1.KeyCode.F16;
        KEY_CODE_MAP[128] = keyCodes_1.KeyCode.F17;
        KEY_CODE_MAP[129] = keyCodes_1.KeyCode.F18;
        KEY_CODE_MAP[130] = keyCodes_1.KeyCode.F19;
        KEY_CODE_MAP[144] = keyCodes_1.KeyCode.NumLock;
        KEY_CODE_MAP[145] = keyCodes_1.KeyCode.ScrollLock;
        KEY_CODE_MAP[186] = keyCodes_1.KeyCode.US_SEMICOLON;
        KEY_CODE_MAP[187] = keyCodes_1.KeyCode.US_EQUAL;
        KEY_CODE_MAP[188] = keyCodes_1.KeyCode.US_COMMA;
        KEY_CODE_MAP[189] = keyCodes_1.KeyCode.US_MINUS;
        KEY_CODE_MAP[190] = keyCodes_1.KeyCode.US_DOT;
        KEY_CODE_MAP[191] = keyCodes_1.KeyCode.US_SLASH;
        KEY_CODE_MAP[192] = keyCodes_1.KeyCode.US_BACKTICK;
        KEY_CODE_MAP[219] = keyCodes_1.KeyCode.US_OPEN_SQUARE_BRACKET;
        KEY_CODE_MAP[220] = keyCodes_1.KeyCode.US_BACKSLASH;
        KEY_CODE_MAP[221] = keyCodes_1.KeyCode.US_CLOSE_SQUARE_BRACKET;
        KEY_CODE_MAP[222] = keyCodes_1.KeyCode.US_QUOTE;
        KEY_CODE_MAP[223] = keyCodes_1.KeyCode.OEM_8;
        KEY_CODE_MAP[226] = keyCodes_1.KeyCode.OEM_102;
        if (browser.isIE11orEarlier) {
            KEY_CODE_MAP[91] = keyCodes_1.KeyCode.Meta;
        }
        else if (browser.isFirefox) {
            KEY_CODE_MAP[59] = keyCodes_1.KeyCode.US_SEMICOLON;
            KEY_CODE_MAP[107] = keyCodes_1.KeyCode.US_EQUAL;
            KEY_CODE_MAP[109] = keyCodes_1.KeyCode.US_MINUS;
            if (platform.isMacintosh) {
                KEY_CODE_MAP[224] = keyCodes_1.KeyCode.Meta;
            }
        }
        else if (browser.isWebKit) {
            KEY_CODE_MAP[91] = keyCodes_1.KeyCode.Meta;
            if (platform.isMacintosh) {
                // the two meta keys in the Mac have different key codes (91 and 93)
                KEY_CODE_MAP[93] = keyCodes_1.KeyCode.Meta;
            }
            else {
                KEY_CODE_MAP[92] = keyCodes_1.KeyCode.Meta;
            }
        }
    })();
    function lookupKeyCode(e) {
        return KEY_CODE_MAP[e.keyCode] || keyCodes_1.KeyCode.Unknown;
    }
    exports.lookupKeyCode = lookupKeyCode;
    var extractKeyCode = function extractKeyCode(e) {
        if (e.charCode) {
            // "keypress" events mostly
            var char = String.fromCharCode(e.charCode).toUpperCase();
            return keyCodes_1.KeyCode.fromString(char);
        }
        return lookupKeyCode(e);
    };
    function setExtractKeyCode(newExtractKeyCode) {
        extractKeyCode = newExtractKeyCode;
    }
    exports.setExtractKeyCode = setExtractKeyCode;
    var ctrlKeyMod = (platform.isMacintosh ? keyCodes_1.KeyMod.WinCtrl : keyCodes_1.KeyMod.CtrlCmd);
    var altKeyMod = keyCodes_1.KeyMod.Alt;
    var shiftKeyMod = keyCodes_1.KeyMod.Shift;
    var metaKeyMod = (platform.isMacintosh ? keyCodes_1.KeyMod.CtrlCmd : keyCodes_1.KeyMod.WinCtrl);
    var StandardKeyboardEvent = (function () {
        function StandardKeyboardEvent(source) {
            var e = source;
            this.browserEvent = e;
            this.target = e.target;
            this.ctrlKey = e.ctrlKey;
            this.shiftKey = e.shiftKey;
            this.altKey = e.altKey;
            this.metaKey = e.metaKey;
            this.keyCode = extractKeyCode(e);
            // console.info(e.type + ": keyCode: " + e.keyCode + ", which: " + e.which + ", charCode: " + e.charCode + ", detail: " + e.detail + " ====> " + this.keyCode + ' -- ' + KeyCode[this.keyCode]);
            this.ctrlKey = this.ctrlKey || this.keyCode === keyCodes_1.KeyCode.Ctrl;
            this.altKey = this.altKey || this.keyCode === keyCodes_1.KeyCode.Alt;
            this.shiftKey = this.shiftKey || this.keyCode === keyCodes_1.KeyCode.Shift;
            this.metaKey = this.metaKey || this.keyCode === keyCodes_1.KeyCode.Meta;
            this._asKeybinding = this._computeKeybinding();
        }
        StandardKeyboardEvent.prototype.preventDefault = function () {
            if (this.browserEvent && this.browserEvent.preventDefault) {
                this.browserEvent.preventDefault();
            }
        };
        StandardKeyboardEvent.prototype.stopPropagation = function () {
            if (this.browserEvent && this.browserEvent.stopPropagation) {
                this.browserEvent.stopPropagation();
            }
        };
        StandardKeyboardEvent.prototype.asKeybinding = function () {
            return this._asKeybinding;
        };
        StandardKeyboardEvent.prototype.equals = function (other) {
            return (this._asKeybinding === other);
        };
        StandardKeyboardEvent.prototype._computeKeybinding = function () {
            var key = keyCodes_1.KeyCode.Unknown;
            if (this.keyCode !== keyCodes_1.KeyCode.Ctrl && this.keyCode !== keyCodes_1.KeyCode.Shift && this.keyCode !== keyCodes_1.KeyCode.Alt && this.keyCode !== keyCodes_1.KeyCode.Meta) {
                key = this.keyCode;
            }
            var result = 0;
            if (this.ctrlKey) {
                result |= ctrlKeyMod;
            }
            if (this.altKey) {
                result |= altKeyMod;
            }
            if (this.shiftKey) {
                result |= shiftKeyMod;
            }
            if (this.metaKey) {
                result |= metaKeyMod;
            }
            result |= key;
            return result;
        };
        return StandardKeyboardEvent;
    }());
    exports.StandardKeyboardEvent = StandardKeyboardEvent;
});






define(__m[11], __M([0,1,14,8,23,3,26,28,56,39]), function (require, exports, async_1, errors_1, eventEmitter_1, lifecycle_1, types_1, browser_1, keyboardEvent_1, mouseEvent_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function clearNode(node) {
        while (node.firstChild) {
            node.removeChild(node.firstChild);
        }
    }
    exports.clearNode = clearNode;
    /**
     * Calls JSON.Stringify with a replacer to break apart any circular references.
     * This prevents JSON.stringify from throwing the exception
     *  "Uncaught TypeError: Converting circular structure to JSON"
     */
    function safeStringifyDOMAware(obj) {
        var seen = [];
        return JSON.stringify(obj, function (key, value) {
            // HTML elements are never going to serialize nicely
            if (value instanceof Element) {
                return '[Element]';
            }
            if (types_1.isObject(value) || Array.isArray(value)) {
                if (seen.indexOf(value) !== -1) {
                    return '[Circular]';
                }
                else {
                    seen.push(value);
                }
            }
            return value;
        });
    }
    exports.safeStringifyDOMAware = safeStringifyDOMAware;
    function isInDOM(node) {
        while (node) {
            if (node === document.body) {
                return true;
            }
            node = node.parentNode;
        }
        return false;
    }
    exports.isInDOM = isInDOM;
    var _blank = ' '.charCodeAt(0);
    var lastStart, lastEnd;
    function _findClassName(node, className) {
        var classes = node.className;
        if (!classes) {
            lastStart = -1;
            return;
        }
        className = className.trim();
        var classesLen = classes.length, classLen = className.length;
        if (classLen === 0) {
            lastStart = -1;
            return;
        }
        if (classesLen < classLen) {
            lastStart = -1;
            return;
        }
        if (classes === className) {
            lastStart = 0;
            lastEnd = classesLen;
            return;
        }
        var idx = -1, idxEnd;
        while ((idx = classes.indexOf(className, idx + 1)) >= 0) {
            idxEnd = idx + classLen;
            // a class that is followed by another class
            if ((idx === 0 || classes.charCodeAt(idx - 1) === _blank) && classes.charCodeAt(idxEnd) === _blank) {
                lastStart = idx;
                lastEnd = idxEnd + 1;
                return;
            }
            // last class
            if (idx > 0 && classes.charCodeAt(idx - 1) === _blank && idxEnd === classesLen) {
                lastStart = idx - 1;
                lastEnd = idxEnd;
                return;
            }
            // equal - duplicate of cmp above
            if (idx === 0 && idxEnd === classesLen) {
                lastStart = 0;
                lastEnd = idxEnd;
                return;
            }
        }
        lastStart = -1;
    }
    /**
     * @param node a dom node
     * @param className a class name
     * @return true if the className attribute of the provided node contains the provided className
     */
    function hasClass(node, className) {
        _findClassName(node, className);
        return lastStart !== -1;
    }
    exports.hasClass = hasClass;
    /**
     * Adds the provided className to the provided node. This is a no-op
     * if the class is already set.
     * @param node a dom node
     * @param className a class name
     */
    function addClass(node, className) {
        if (!node.className) {
            node.className = className;
        }
        else {
            _findClassName(node, className); // see if it's already there
            if (lastStart === -1) {
                node.className = node.className + ' ' + className;
            }
        }
    }
    exports.addClass = addClass;
    /**
     * Removes the className for the provided node. This is a no-op
     * if the class isn't present.
     * @param node a dom node
     * @param className a class name
     */
    function removeClass(node, className) {
        _findClassName(node, className);
        if (lastStart === -1) {
            return; // Prevent styles invalidation if not necessary
        }
        else {
            node.className = node.className.substring(0, lastStart) + node.className.substring(lastEnd);
        }
    }
    exports.removeClass = removeClass;
    /**
     * @param node a dom node
     * @param className a class name
     * @param shouldHaveIt
     */
    function toggleClass(node, className, shouldHaveIt) {
        _findClassName(node, className);
        if (lastStart !== -1 && (shouldHaveIt === void 0 || !shouldHaveIt)) {
            removeClass(node, className);
        }
        if (lastStart === -1 && (shouldHaveIt === void 0 || shouldHaveIt)) {
            addClass(node, className);
        }
    }
    exports.toggleClass = toggleClass;
    var DomListener = (function (_super) {
        __extends(DomListener, _super);
        function DomListener(node, type, handler, useCapture) {
            _super.call(this);
            this._node = node;
            this._type = type;
            this._useCapture = (useCapture || false);
            this._wrapHandler = function (e) {
                e = e || window.event;
                handler(e);
            };
            if (typeof this._node.addEventListener === 'function') {
                this._usedAddEventListener = true;
                this._node.addEventListener(this._type, this._wrapHandler, this._useCapture);
            }
            else {
                this._usedAddEventListener = false;
                this._node.attachEvent('on' + this._type, this._wrapHandler);
            }
        }
        DomListener.prototype.dispose = function () {
            if (!this._wrapHandler) {
                // Already disposed
                return;
            }
            if (this._usedAddEventListener) {
                this._node.removeEventListener(this._type, this._wrapHandler, this._useCapture);
            }
            else {
                this._node.detachEvent('on' + this._type, this._wrapHandler);
            }
            // Prevent leakers from holding on to the dom or handler func
            this._node = null;
            this._wrapHandler = null;
        };
        return DomListener;
    }(lifecycle_1.Disposable));
    function addDisposableListener(node, type, handler, useCapture) {
        return new DomListener(node, type, handler, useCapture);
    }
    exports.addDisposableListener = addDisposableListener;
    function _wrapAsStandardMouseEvent(handler) {
        return function (e) {
            return handler(new mouseEvent_1.StandardMouseEvent(e));
        };
    }
    function _wrapAsStandardKeyboardEvent(handler) {
        return function (e) {
            return handler(new keyboardEvent_1.StandardKeyboardEvent(e));
        };
    }
    exports.addStandardDisposableListener = function addStandardDisposableListener(node, type, handler, useCapture) {
        var wrapHandler = handler;
        if (type === 'click') {
            wrapHandler = _wrapAsStandardMouseEvent(handler);
        }
        else if (type === 'keydown' || type === 'keypress' || type === 'keyup') {
            wrapHandler = _wrapAsStandardKeyboardEvent(handler);
        }
        node.addEventListener(type, wrapHandler, useCapture || false);
        return {
            dispose: function () {
                if (!wrapHandler) {
                    // Already removed
                    return;
                }
                node.removeEventListener(type, wrapHandler, useCapture || false);
                // Prevent leakers from holding on to the dom node or handler func
                wrapHandler = null;
                node = null;
                handler = null;
            }
        };
    };
    function addDisposableNonBubblingMouseOutListener(node, handler) {
        return addDisposableListener(node, 'mouseout', function (e) {
            // Mouse out bubbles, so this is an attempt to ignore faux mouse outs coming from children elements
            var toElement = (e.relatedTarget || e.toElement);
            while (toElement && toElement !== node) {
                toElement = toElement.parentNode;
            }
            if (toElement === node) {
                return;
            }
            handler(e);
        });
    }
    exports.addDisposableNonBubblingMouseOutListener = addDisposableNonBubblingMouseOutListener;
    var _animationFrame = (function () {
        var emulatedRequestAnimationFrame = function (callback) {
            return setTimeout(function () { return callback(new Date().getTime()); }, 0);
        };
        var nativeRequestAnimationFrame = self.requestAnimationFrame
            || self.msRequestAnimationFrame
            || self.webkitRequestAnimationFrame
            || self.mozRequestAnimationFrame
            || self.oRequestAnimationFrame;
        var emulatedCancelAnimationFrame = function (id) { };
        var nativeCancelAnimationFrame = self.cancelAnimationFrame || self.cancelRequestAnimationFrame
            || self.msCancelAnimationFrame || self.msCancelRequestAnimationFrame
            || self.webkitCancelAnimationFrame || self.webkitCancelRequestAnimationFrame
            || self.mozCancelAnimationFrame || self.mozCancelRequestAnimationFrame
            || self.oCancelAnimationFrame || self.oCancelRequestAnimationFrame;
        var isNative = !!nativeRequestAnimationFrame;
        var request = nativeRequestAnimationFrame || emulatedRequestAnimationFrame;
        var cancel = nativeCancelAnimationFrame || emulatedCancelAnimationFrame;
        return {
            isNative: isNative,
            request: function (callback) {
                return request(callback);
            },
            cancel: function (id) {
                return cancel(id);
            }
        };
    })();
    var AnimationFrameQueueItem = (function () {
        function AnimationFrameQueueItem(runner, priority) {
            this._runner = runner;
            this.priority = priority;
            this._canceled = false;
        }
        AnimationFrameQueueItem.prototype.dispose = function () {
            this._canceled = true;
        };
        AnimationFrameQueueItem.prototype.execute = function () {
            if (this._canceled) {
                return;
            }
            try {
                this._runner();
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
            }
        };
        // Sort by priority (largest to lowest)
        AnimationFrameQueueItem.sort = function (a, b) {
            return b.priority - a.priority;
        };
        return AnimationFrameQueueItem;
    }());
    (function () {
        /**
         * The runners scheduled at the next animation frame
         */
        var NEXT_QUEUE = [];
        /**
         * The runners scheduled at the current animation frame
         */
        var CURRENT_QUEUE = null;
        /**
         * A flag to keep track if the native requestAnimationFrame was already called
         */
        var animFrameRequested = false;
        /**
         * A flag to indicate if currently handling a native requestAnimationFrame callback
         */
        var inAnimationFrameRunner = false;
        var animationFrameRunner = function () {
            animFrameRequested = false;
            CURRENT_QUEUE = NEXT_QUEUE;
            NEXT_QUEUE = [];
            inAnimationFrameRunner = true;
            while (CURRENT_QUEUE.length > 0) {
                CURRENT_QUEUE.sort(AnimationFrameQueueItem.sort);
                var top_1 = CURRENT_QUEUE.shift();
                top_1.execute();
            }
            inAnimationFrameRunner = false;
        };
        exports.scheduleAtNextAnimationFrame = function (runner, priority) {
            if (priority === void 0) { priority = 0; }
            var item = new AnimationFrameQueueItem(runner, priority);
            NEXT_QUEUE.push(item);
            if (!animFrameRequested) {
                animFrameRequested = true;
                // TODO@Alex: also check if it is electron
                if (browser_1.isChrome) {
                    var handle_1;
                    _animationFrame.request(function () {
                        clearTimeout(handle_1);
                        animationFrameRunner();
                    });
                    // This is a fallback in-case chrome dropped
                    // the request for an animation frame. This
                    // is sick but was spotted in the wild
                    handle_1 = setTimeout(animationFrameRunner, 1000);
                }
                else {
                    _animationFrame.request(animationFrameRunner);
                }
            }
            return item;
        };
        exports.runAtThisOrScheduleAtNextAnimationFrame = function (runner, priority) {
            if (inAnimationFrameRunner) {
                var item = new AnimationFrameQueueItem(runner, priority);
                CURRENT_QUEUE.push(item);
                return item;
            }
            else {
                return exports.scheduleAtNextAnimationFrame(runner, priority);
            }
        };
    })();
    var MINIMUM_TIME_MS = 16;
    var DEFAULT_EVENT_MERGER = function (lastEvent, currentEvent) {
        return currentEvent;
    };
    var TimeoutThrottledDomListener = (function (_super) {
        __extends(TimeoutThrottledDomListener, _super);
        function TimeoutThrottledDomListener(node, type, handler, eventMerger, minimumTimeMs) {
            if (eventMerger === void 0) { eventMerger = DEFAULT_EVENT_MERGER; }
            if (minimumTimeMs === void 0) { minimumTimeMs = MINIMUM_TIME_MS; }
            _super.call(this);
            var lastEvent = null;
            var lastHandlerTime = 0;
            var timeout = this._register(new async_1.TimeoutTimer());
            var invokeHandler = function () {
                lastHandlerTime = (new Date()).getTime();
                handler(lastEvent);
                lastEvent = null;
            };
            this._register(addDisposableListener(node, type, function (e) {
                lastEvent = eventMerger(lastEvent, e);
                var elapsedTime = (new Date()).getTime() - lastHandlerTime;
                if (elapsedTime >= minimumTimeMs) {
                    timeout.cancel();
                    invokeHandler();
                }
                else {
                    timeout.setIfNotSet(invokeHandler, minimumTimeMs - elapsedTime);
                }
            }));
        }
        return TimeoutThrottledDomListener;
    }(lifecycle_1.Disposable));
    function addDisposableThrottledListener(node, type, handler, eventMerger, minimumTimeMs) {
        return new TimeoutThrottledDomListener(node, type, handler, eventMerger, minimumTimeMs);
    }
    exports.addDisposableThrottledListener = addDisposableThrottledListener;
    function getComputedStyle(el) {
        return document.defaultView.getComputedStyle(el, null);
    }
    exports.getComputedStyle = getComputedStyle;
    // Adapted from WinJS
    // Converts a CSS positioning string for the specified element to pixels.
    var convertToPixels = (function () {
        return function (element, value) {
            return parseFloat(value) || 0;
        };
    })();
    function getDimension(element, cssPropertyName, jsPropertyName) {
        var computedStyle = getComputedStyle(element);
        var value = '0';
        if (computedStyle) {
            if (computedStyle.getPropertyValue) {
                value = computedStyle.getPropertyValue(cssPropertyName);
            }
            else {
                // IE8
                value = computedStyle.getAttribute(jsPropertyName);
            }
        }
        return convertToPixels(element, value);
    }
    var sizeUtils = {
        getBorderLeftWidth: function (element) {
            return getDimension(element, 'border-left-width', 'borderLeftWidth');
        },
        getBorderTopWidth: function (element) {
            return getDimension(element, 'border-top-width', 'borderTopWidth');
        },
        getBorderRightWidth: function (element) {
            return getDimension(element, 'border-right-width', 'borderRightWidth');
        },
        getBorderBottomWidth: function (element) {
            return getDimension(element, 'border-bottom-width', 'borderBottomWidth');
        },
        getPaddingLeft: function (element) {
            return getDimension(element, 'padding-left', 'paddingLeft');
        },
        getPaddingTop: function (element) {
            return getDimension(element, 'padding-top', 'paddingTop');
        },
        getPaddingRight: function (element) {
            return getDimension(element, 'padding-right', 'paddingRight');
        },
        getPaddingBottom: function (element) {
            return getDimension(element, 'padding-bottom', 'paddingBottom');
        },
        getMarginLeft: function (element) {
            return getDimension(element, 'margin-left', 'marginLeft');
        },
        getMarginTop: function (element) {
            return getDimension(element, 'margin-top', 'marginTop');
        },
        getMarginRight: function (element) {
            return getDimension(element, 'margin-right', 'marginRight');
        },
        getMarginBottom: function (element) {
            return getDimension(element, 'margin-bottom', 'marginBottom');
        },
        __commaSentinel: false
    };
    // ----------------------------------------------------------------------------------------
    // Position & Dimension
    function getTopLeftOffset(element) {
        // Adapted from WinJS.Utilities.getPosition
        // and added borders to the mix
        var offsetParent = element.offsetParent, top = element.offsetTop, left = element.offsetLeft;
        while ((element = element.parentNode) !== null && element !== document.body && element !== document.documentElement) {
            top -= element.scrollTop;
            var c = getComputedStyle(element);
            if (c) {
                left -= c.direction !== 'rtl' ? element.scrollLeft : -element.scrollLeft;
            }
            if (element === offsetParent) {
                left += sizeUtils.getBorderLeftWidth(element);
                top += sizeUtils.getBorderTopWidth(element);
                top += element.offsetTop;
                left += element.offsetLeft;
                offsetParent = element.offsetParent;
            }
        }
        return {
            left: left,
            top: top
        };
    }
    exports.getTopLeftOffset = getTopLeftOffset;
    /**
     * Returns the position of a dom node relative to the entire page.
     */
    function getDomNodePagePosition(domNode) {
        var bb = domNode.getBoundingClientRect();
        return {
            left: bb.left + exports.StandardWindow.scrollX,
            top: bb.top + exports.StandardWindow.scrollY,
            width: bb.width,
            height: bb.height
        };
    }
    exports.getDomNodePagePosition = getDomNodePagePosition;
    exports.StandardWindow = new (function () {
        function class_1() {
        }
        Object.defineProperty(class_1.prototype, "scrollX", {
            get: function () {
                if (typeof window.scrollX === 'number') {
                    // modern browsers
                    return window.scrollX;
                }
                else {
                    return document.body.scrollLeft + document.documentElement.scrollLeft;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(class_1.prototype, "scrollY", {
            get: function () {
                if (typeof window.scrollY === 'number') {
                    // modern browsers
                    return window.scrollY;
                }
                else {
                    return document.body.scrollTop + document.documentElement.scrollTop;
                }
            },
            enumerable: true,
            configurable: true
        });
        return class_1;
    }());
    // Adapted from WinJS
    // Gets the width of the content of the specified element. The content width does not include borders or padding.
    function getContentWidth(element) {
        var border = sizeUtils.getBorderLeftWidth(element) + sizeUtils.getBorderRightWidth(element);
        var padding = sizeUtils.getPaddingLeft(element) + sizeUtils.getPaddingRight(element);
        return element.offsetWidth - border - padding;
    }
    exports.getContentWidth = getContentWidth;
    // Adapted from WinJS
    // Gets the width of the element, including margins.
    function getTotalWidth(element) {
        var margin = sizeUtils.getMarginLeft(element) + sizeUtils.getMarginRight(element);
        return element.offsetWidth + margin;
    }
    exports.getTotalWidth = getTotalWidth;
    // Adapted from WinJS
    // Gets the height of the content of the specified element. The content height does not include borders or padding.
    function getContentHeight(element) {
        var border = sizeUtils.getBorderTopWidth(element) + sizeUtils.getBorderBottomWidth(element);
        var padding = sizeUtils.getPaddingTop(element) + sizeUtils.getPaddingBottom(element);
        return element.offsetHeight - border - padding;
    }
    exports.getContentHeight = getContentHeight;
    // Adapted from WinJS
    // Gets the height of the element, including its margins.
    function getTotalHeight(element) {
        var margin = sizeUtils.getMarginTop(element) + sizeUtils.getMarginBottom(element);
        return element.offsetHeight + margin;
    }
    exports.getTotalHeight = getTotalHeight;
    // Gets the left coordinate of the specified element relative to the specified parent.
    function getRelativeLeft(element, parent) {
        if (element === null) {
            return 0;
        }
        var elementPosition = getTopLeftOffset(element);
        var parentPosition = getTopLeftOffset(parent);
        return elementPosition.left - parentPosition.left;
    }
    function getLargestChildWidth(parent, children) {
        var childWidths = children.map(function (child) {
            return getTotalWidth(child) + getRelativeLeft(child, parent) || 0;
        });
        var maxWidth = Math.max.apply(Math, childWidths);
        return maxWidth;
    }
    exports.getLargestChildWidth = getLargestChildWidth;
    // ----------------------------------------------------------------------------------------
    function isAncestor(testChild, testAncestor) {
        while (testChild) {
            if (testChild === testAncestor) {
                return true;
            }
            testChild = testChild.parentNode;
        }
        return false;
    }
    exports.isAncestor = isAncestor;
    function findParentWithClass(node, clazz, stopAtClazz) {
        while (node) {
            if (hasClass(node, clazz)) {
                return node;
            }
            if (stopAtClazz && hasClass(node, stopAtClazz)) {
                return null;
            }
            node = node.parentNode;
        }
        return null;
    }
    exports.findParentWithClass = findParentWithClass;
    function createStyleSheet() {
        var style = document.createElement('style');
        style.type = 'text/css';
        style.media = 'screen';
        document.getElementsByTagName('head')[0].appendChild(style);
        return style;
    }
    exports.createStyleSheet = createStyleSheet;
    var sharedStyle = createStyleSheet();
    function getDynamicStyleSheetRules(style) {
        if (style && style.sheet && style.sheet.rules) {
            // Chrome, IE
            return style.sheet.rules;
        }
        if (style && style.sheet && style.sheet.cssRules) {
            // FF
            return style.sheet.cssRules;
        }
        return [];
    }
    function createCSSRule(selector, cssText, style) {
        if (style === void 0) { style = sharedStyle; }
        if (!style || !cssText) {
            return;
        }
        style.sheet.insertRule(selector + '{' + cssText + '}', 0);
    }
    exports.createCSSRule = createCSSRule;
    function getCSSRule(selector, style) {
        if (style === void 0) { style = sharedStyle; }
        if (!style) {
            return null;
        }
        var rules = getDynamicStyleSheetRules(style);
        for (var i = 0; i < rules.length; i++) {
            var rule = rules[i];
            var normalizedSelectorText = rule.selectorText.replace(/::/gi, ':');
            if (normalizedSelectorText === selector) {
                return rule;
            }
        }
        return null;
    }
    exports.getCSSRule = getCSSRule;
    function removeCSSRulesContainingSelector(ruleName, style) {
        if (style === void 0) { style = sharedStyle; }
        if (!style) {
            return;
        }
        var rules = getDynamicStyleSheetRules(style);
        var toDelete = [];
        for (var i = 0; i < rules.length; i++) {
            var rule = rules[i];
            var normalizedSelectorText = rule.selectorText.replace(/::/gi, ':');
            if (normalizedSelectorText.indexOf(ruleName) !== -1) {
                toDelete.push(i);
            }
        }
        for (var i = toDelete.length - 1; i >= 0; i--) {
            style.sheet.deleteRule(toDelete[i]);
        }
    }
    exports.removeCSSRulesContainingSelector = removeCSSRulesContainingSelector;
    function isHTMLElement(o) {
        if (typeof HTMLElement === 'object') {
            return o instanceof HTMLElement;
        }
        return o && typeof o === 'object' && o.nodeType === 1 && typeof o.nodeName === 'string';
    }
    exports.isHTMLElement = isHTMLElement;
    exports.EventType = {
        // Mouse
        CLICK: 'click',
        DBLCLICK: 'dblclick',
        MOUSE_UP: 'mouseup',
        MOUSE_DOWN: 'mousedown',
        MOUSE_OVER: 'mouseover',
        MOUSE_MOVE: 'mousemove',
        MOUSE_OUT: 'mouseout',
        CONTEXT_MENU: 'contextmenu',
        WHEEL: 'wheel',
        // Keyboard
        KEY_DOWN: 'keydown',
        KEY_PRESS: 'keypress',
        KEY_UP: 'keyup',
        // HTML Document
        LOAD: 'load',
        UNLOAD: 'unload',
        ABORT: 'abort',
        ERROR: 'error',
        RESIZE: 'resize',
        SCROLL: 'scroll',
        // Form
        SELECT: 'select',
        CHANGE: 'change',
        SUBMIT: 'submit',
        RESET: 'reset',
        FOCUS: 'focus',
        BLUR: 'blur',
        INPUT: 'input',
        // Local Storage
        STORAGE: 'storage',
        // Drag
        DRAG_START: 'dragstart',
        DRAG: 'drag',
        DRAG_ENTER: 'dragenter',
        DRAG_LEAVE: 'dragleave',
        DRAG_OVER: 'dragover',
        DROP: 'drop',
        DRAG_END: 'dragend',
        // Animation
        ANIMATION_START: browser_1.isWebKit ? 'webkitAnimationStart' : 'animationstart',
        ANIMATION_END: browser_1.isWebKit ? 'webkitAnimationEnd' : 'animationend',
        ANIMATION_ITERATION: browser_1.isWebKit ? 'webkitAnimationIteration' : 'animationiteration'
    };
    exports.EventHelper = {
        stop: function (e, cancelBubble) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            else {
                // IE8
                e.returnValue = false;
            }
            if (cancelBubble) {
                if (e.stopPropagation) {
                    e.stopPropagation();
                }
                else {
                    // IE8
                    e.cancelBubble = true;
                }
            }
        }
    };
    function saveParentsScrollTop(node) {
        var r = [];
        for (var i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {
            r[i] = node.scrollTop;
            node = node.parentNode;
        }
        return r;
    }
    exports.saveParentsScrollTop = saveParentsScrollTop;
    function restoreParentsScrollTop(node, state) {
        for (var i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {
            if (node.scrollTop !== state[i]) {
                node.scrollTop = state[i];
            }
            node = node.parentNode;
        }
    }
    exports.restoreParentsScrollTop = restoreParentsScrollTop;
    var FocusTracker = (function (_super) {
        __extends(FocusTracker, _super);
        function FocusTracker(element) {
            var _this = this;
            _super.call(this);
            var hasFocus = false;
            var loosingFocus = false;
            this._eventEmitter = this._register(new eventEmitter_1.EventEmitter());
            var onFocus = function (event) {
                loosingFocus = false;
                if (!hasFocus) {
                    hasFocus = true;
                    _this._eventEmitter.emit('focus', {});
                }
            };
            var onBlur = function (event) {
                if (hasFocus) {
                    loosingFocus = true;
                    window.setTimeout(function () {
                        if (loosingFocus) {
                            loosingFocus = false;
                            hasFocus = false;
                            _this._eventEmitter.emit('blur', {});
                        }
                    }, 0);
                }
            };
            this._register(addDisposableListener(element, exports.EventType.FOCUS, onFocus, true));
            this._register(addDisposableListener(element, exports.EventType.BLUR, onBlur, true));
        }
        FocusTracker.prototype.addFocusListener = function (fn) {
            return this._eventEmitter.addListener2('focus', fn);
        };
        FocusTracker.prototype.addBlurListener = function (fn) {
            return this._eventEmitter.addListener2('blur', fn);
        };
        return FocusTracker;
    }(lifecycle_1.Disposable));
    function trackFocus(element) {
        return new FocusTracker(element);
    }
    exports.trackFocus = trackFocus;
    function append(parent, child) {
        parent.appendChild(child);
        return child;
    }
    exports.append = append;
    var SELECTOR_REGEX = /([\w\-]+)?(#([\w\-]+))?((.([\w\-]+))*)/;
    // Similar to builder, but much more lightweight
    function emmet(description) {
        var match = SELECTOR_REGEX.exec(description);
        if (!match) {
            throw new Error('Bad use of emmet');
        }
        var result = document.createElement(match[1] || 'div');
        if (match[3]) {
            result.id = match[3];
        }
        if (match[4]) {
            result.className = match[4].replace(/\./g, ' ').trim();
        }
        return result;
    }
    exports.emmet = emmet;
    function show() {
        var elements = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            elements[_i - 0] = arguments[_i];
        }
        for (var _a = 0, elements_1 = elements; _a < elements_1.length; _a++) {
            var element = elements_1[_a];
            element.style.display = null;
        }
    }
    exports.show = show;
    function hide() {
        var elements = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            elements[_i - 0] = arguments[_i];
        }
        for (var _a = 0, elements_2 = elements; _a < elements_2.length; _a++) {
            var element = elements_2[_a];
            element.style.display = 'none';
        }
    }
    exports.hide = hide;
    function findParentWithAttribute(node, attribute) {
        while (node) {
            if (node instanceof HTMLElement && node.hasAttribute(attribute)) {
                return node;
            }
            node = node.parentNode;
        }
        return null;
    }
    function removeTabIndexAndUpdateFocus(node) {
        if (!node || !node.hasAttribute('tabIndex')) {
            return;
        }
        // If we are the currently focused element and tabIndex is removed,
        // standard DOM behavior is to move focus to the <body> element. We
        // typically never want that, rather put focus to the closest element
        // in the hierarchy of the parent DOM nodes.
        if (document.activeElement === node) {
            var parentFocusable = findParentWithAttribute(node.parentElement, 'tabIndex');
            if (parentFocusable) {
                parentFocusable.focus();
            }
        }
        node.removeAttribute('tabindex');
    }
    exports.removeTabIndexAndUpdateFocus = removeTabIndexAndUpdateFocus;
    function getElementsByTagName(tag) {
        return Array.prototype.slice.call(document.getElementsByTagName(tag), 0);
    }
    exports.getElementsByTagName = getElementsByTagName;
    function finalHandler(fn) {
        return function (e) {
            e.preventDefault();
            e.stopPropagation();
            fn(e);
        };
    }
    exports.finalHandler = finalHandler;
});






define(__m[35], __M([0,1,2,26,3,10,47,11,310]), function (require, exports, winjs_base_1, types, lifecycle_1, strings, assert, DOM) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Create a new builder from the element that is uniquely identified by the given identifier. If the
     *  second parameter "offdom" is set to true, the created elements will only be added to the provided
     *  element when the build() method is called.
     */
    function withElementById(id, offdom) {
        assert.ok(types.isString(id), 'Expected String as parameter');
        var element = document.getElementById(id);
        if (element) {
            return new Builder(element, offdom);
        }
        return null;
    }
    exports.withElementById = withElementById;
    exports.Build = {
        withElementById: withElementById
    };
    // --- Implementation starts here
    var MS_DATA_KEY = '_msDataKey';
    var DATA_BINDING_ID = '__$binding';
    var LISTENER_BINDING_ID = '__$listeners';
    var VISIBILITY_BINDING_ID = '__$visibility';
    var Position = (function () {
        function Position(x, y) {
            this.x = x;
            this.y = y;
        }
        return Position;
    }());
    exports.Position = Position;
    var Box = (function () {
        function Box(top, right, bottom, left) {
            this.top = top;
            this.right = right;
            this.bottom = bottom;
            this.left = left;
        }
        return Box;
    }());
    exports.Box = Box;
    var Dimension = (function () {
        function Dimension(width, height) {
            this.width = width;
            this.height = height;
        }
        Dimension.prototype.substract = function (box) {
            return new Dimension(this.width - box.left - box.right, this.height - box.top - box.bottom);
        };
        return Dimension;
    }());
    exports.Dimension = Dimension;
    function data(element) {
        if (!element[MS_DATA_KEY]) {
            element[MS_DATA_KEY] = {};
        }
        return element[MS_DATA_KEY];
    }
    function hasData(element) {
        return !!element[MS_DATA_KEY];
    }
    /**
     *  Wraps around the provided element to manipulate it and add more child elements.
     */
    var Builder = (function () {
        function Builder(element, offdom) {
            this.offdom = offdom;
            this.container = element;
            this.currentElement = element;
            this.createdElements = [];
            this.toUnbind = {};
            this.captureToUnbind = {};
        }
        /**
         *  Returns a new builder that lets the current HTML Element of this builder be the container
         *  for future additions on the builder.
         */
        Builder.prototype.asContainer = function () {
            return withBuilder(this, this.offdom);
        };
        /**
         *  Clones the builder providing the same properties as this one.
         */
        Builder.prototype.clone = function () {
            var builder = new Builder(this.container, this.offdom);
            builder.currentElement = this.currentElement;
            builder.createdElements = this.createdElements;
            builder.captureToUnbind = this.captureToUnbind;
            builder.toUnbind = this.toUnbind;
            return builder;
        };
        Builder.prototype.and = function (obj) {
            // Convert HTMLElement to Builder as necessary
            if (!(obj instanceof Builder) && !(obj instanceof MultiBuilder)) {
                obj = new Builder(obj, this.offdom);
            }
            // Wrap Builders into MultiBuilder
            var builders = [this];
            if (obj instanceof MultiBuilder) {
                for (var i = 0; i < obj.length; i++) {
                    builders.push(obj.item(i));
                }
            }
            else {
                builders.push(obj);
            }
            return new MultiBuilder(builders);
        };
        Builder.prototype.build = function (container, index) {
            assert.ok(this.offdom, 'This builder was not created off-dom, so build() can not be called.');
            // Use builders own container if present
            if (!container) {
                container = this.container;
            }
            else if (container instanceof Builder) {
                container = container.getHTMLElement();
            }
            assert.ok(container, 'Builder can only be build() with a container provided.');
            assert.ok(DOM.isHTMLElement(container), 'The container must either be a HTMLElement or a Builder.');
            var htmlContainer = container;
            // Append
            var i, len;
            var childNodes = htmlContainer.childNodes;
            if (types.isNumber(index) && index < childNodes.length) {
                for (i = 0, len = this.createdElements.length; i < len; i++) {
                    htmlContainer.insertBefore(this.createdElements[i], childNodes[index++]);
                }
            }
            else {
                for (i = 0, len = this.createdElements.length; i < len; i++) {
                    htmlContainer.appendChild(this.createdElements[i]);
                }
            }
            return this;
        };
        Builder.prototype.appendTo = function (container, index) {
            // Use builders own container if present
            if (!container) {
                container = this.container;
            }
            else if (container instanceof Builder) {
                container = container.getHTMLElement();
            }
            assert.ok(container, 'Builder can only be build() with a container provided.');
            assert.ok(DOM.isHTMLElement(container), 'The container must either be a HTMLElement or a Builder.');
            var htmlContainer = container;
            // Remove node from parent, if needed
            if (this.currentElement.parentNode) {
                this.currentElement.parentNode.removeChild(this.currentElement);
            }
            var childNodes = htmlContainer.childNodes;
            if (types.isNumber(index) && index < childNodes.length) {
                htmlContainer.insertBefore(this.currentElement, childNodes[index]);
            }
            else {
                htmlContainer.appendChild(this.currentElement);
            }
            return this;
        };
        Builder.prototype.append = function (child, index) {
            assert.ok(child, 'Need a child to append');
            if (DOM.isHTMLElement(child)) {
                child = withElement(child);
            }
            assert.ok(child instanceof Builder || child instanceof MultiBuilder, 'Need a child to append');
            child.appendTo(this, index);
            return this;
        };
        /**
         *  Removes the current element of this builder from its parent node.
         */
        Builder.prototype.offDOM = function () {
            if (this.currentElement.parentNode) {
                this.currentElement.parentNode.removeChild(this.currentElement);
            }
            return this;
        };
        /**
         *  Returns the HTML Element the builder is currently active on.
         */
        Builder.prototype.getHTMLElement = function () {
            return this.currentElement;
        };
        /**
         *  Returns the HTML Element the builder is building in.
         */
        Builder.prototype.getContainer = function () {
            return this.container;
        };
        // HTML Elements
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.div = function (attributes, fn) {
            return this.doElement('div', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.p = function (attributes, fn) {
            return this.doElement('p', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.ul = function (attributes, fn) {
            return this.doElement('ul', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.ol = function (attributes, fn) {
            return this.doElement('ol', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.li = function (attributes, fn) {
            return this.doElement('li', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.span = function (attributes, fn) {
            return this.doElement('span', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.img = function (attributes, fn) {
            return this.doElement('img', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.a = function (attributes, fn) {
            return this.doElement('a', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.header = function (attributes, fn) {
            return this.doElement('header', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.section = function (attributes, fn) {
            return this.doElement('section', attributes, fn);
        };
        /**
         *  Creates a new element of this kind as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.footer = function (attributes, fn) {
            return this.doElement('footer', attributes, fn);
        };
        /**
         *  Creates a new element of given tag name as child of the current element or parent.
         *  Accepts an object literal as first parameter that can be used to describe the
         *  attributes of the element.
         *  Accepts a function as second parameter that can be used to create child elements
         *  of the element. The function will be called with a new builder created with the
         *  provided element.
         */
        Builder.prototype.element = function (name, attributes, fn) {
            return this.doElement(name, attributes, fn);
        };
        Builder.prototype.doElement = function (name, attributesOrFn, fn) {
            // Create Element
            var element = document.createElement(name);
            this.currentElement = element;
            // Off-DOM: Remember in array of created elements
            if (this.offdom) {
                this.createdElements.push(element);
            }
            // Object (apply properties as attributes to HTML element)
            if (types.isObject(attributesOrFn)) {
                this.attr(attributesOrFn);
            }
            // Support second argument being function
            if (types.isFunction(attributesOrFn)) {
                fn = attributesOrFn;
            }
            // Apply Functions (Elements created in Functions will be added as child to current element)
            if (types.isFunction(fn)) {
                var builder = new Builder(element);
                fn.call(builder, builder); // Set both 'this' and the first parameter to the new builder
            }
            // Add to parent
            if (!this.offdom) {
                this.container.appendChild(element);
            }
            return this;
        };
        /**
         *  Calls focus() on the current HTML element;
         */
        Builder.prototype.domFocus = function () {
            this.currentElement.focus();
            return this;
        };
        /**
         *  Returns true if the current element of this builder is the active element.
         */
        Builder.prototype.hasFocus = function () {
            var activeElement = document.activeElement;
            return (activeElement === this.currentElement);
        };
        /**
         *  Calls select() on the current HTML element;
         */
        Builder.prototype.domSelect = function (range) {
            if (range === void 0) { range = null; }
            var input = this.currentElement;
            input.select();
            if (range) {
                input.setSelectionRange(range.start, range.end);
            }
            return this;
        };
        /**
         *  Calls blur() on the current HTML element;
         */
        Builder.prototype.domBlur = function () {
            this.currentElement.blur();
            return this;
        };
        /**
         *  Calls click() on the current HTML element;
         */
        Builder.prototype.domClick = function () {
            this.currentElement.click();
            return this;
        };
        Builder.prototype.on = function (arg1, fn, listenerToUnbindContainer, useCapture) {
            var _this = this;
            // Event Type Array
            if (types.isArray(arg1)) {
                arg1.forEach(function (type) {
                    _this.on(type, fn, listenerToUnbindContainer, useCapture);
                });
            }
            else {
                var type = arg1;
                // Add Listener
                var unbind_1 = DOM.addDisposableListener(this.currentElement, type, function (e) {
                    fn(e, _this, unbind_1); // Pass in Builder as Second Argument
                }, useCapture || false);
                // Remember for off() use
                if (useCapture) {
                    if (!this.captureToUnbind[type]) {
                        this.captureToUnbind[type] = [];
                    }
                    this.captureToUnbind[type].push(unbind_1);
                }
                else {
                    if (!this.toUnbind[type]) {
                        this.toUnbind[type] = [];
                    }
                    this.toUnbind[type].push(unbind_1);
                }
                // Bind to Element
                var listenerBinding = this.getProperty(LISTENER_BINDING_ID, []);
                listenerBinding.push(unbind_1);
                this.setProperty(LISTENER_BINDING_ID, listenerBinding);
                // Add to Array if passed in
                if (listenerToUnbindContainer && types.isArray(listenerToUnbindContainer)) {
                    listenerToUnbindContainer.push(unbind_1);
                }
            }
            return this;
        };
        Builder.prototype.off = function (arg1, useCapture) {
            var _this = this;
            // Event Type Array
            if (types.isArray(arg1)) {
                arg1.forEach(function (type) {
                    _this.off(type);
                });
            }
            else {
                var type = arg1;
                if (useCapture) {
                    if (this.captureToUnbind[type]) {
                        this.captureToUnbind[type] = lifecycle_1.dispose(this.captureToUnbind[type]);
                    }
                }
                else {
                    if (this.toUnbind[type]) {
                        this.toUnbind[type] = lifecycle_1.dispose(this.toUnbind[type]);
                    }
                }
            }
            return this;
        };
        Builder.prototype.once = function (arg1, fn, listenerToUnbindContainer, useCapture) {
            var _this = this;
            // Event Type Array
            if (types.isArray(arg1)) {
                arg1.forEach(function (type) {
                    _this.once(type, fn);
                });
            }
            else {
                var type = arg1;
                // Add Listener
                var unbind_2 = DOM.addDisposableListener(this.currentElement, type, function (e) {
                    fn(e, _this, unbind_2); // Pass in Builder as Second Argument
                    unbind_2.dispose();
                }, useCapture || false);
                // Add to Array if passed in
                if (listenerToUnbindContainer && types.isArray(listenerToUnbindContainer)) {
                    listenerToUnbindContainer.push(unbind_2);
                }
            }
            return this;
        };
        Builder.prototype.preventDefault = function (arg1, cancelBubble, listenerToUnbindContainer, useCapture) {
            var fn = function (e) {
                e.preventDefault();
                if (cancelBubble) {
                    if (e.stopPropagation) {
                        e.stopPropagation();
                    }
                    else {
                        e.cancelBubble = true;
                    }
                }
            };
            return this.on(arg1, fn, listenerToUnbindContainer);
        };
        Builder.prototype.attr = function (firstP, secondP) {
            // Apply Object Literal to Attributes of Element
            if (types.isObject(firstP)) {
                for (var prop in firstP) {
                    if (firstP.hasOwnProperty(prop)) {
                        var value = firstP[prop];
                        this.doSetAttr(prop, value);
                    }
                }
                return this;
            }
            // Get Attribute Value
            if (types.isString(firstP) && !types.isString(secondP)) {
                return this.currentElement.getAttribute(firstP);
            }
            // Set Attribute Value
            if (types.isString(firstP)) {
                if (!types.isString(secondP)) {
                    secondP = String(secondP);
                }
                this.doSetAttr(firstP, secondP);
            }
            return this;
        };
        Builder.prototype.doSetAttr = function (prop, value) {
            if (prop === 'class') {
                prop = 'addClass'; // Workaround for the issue that a function name can not be 'class' in ES
            }
            if (this[prop]) {
                if (types.isArray(value)) {
                    this[prop].apply(this, value);
                }
                else {
                    this[prop].call(this, value);
                }
            }
            else {
                this.currentElement.setAttribute(prop, value);
            }
        };
        /**
         * Removes an attribute by the given name.
         */
        Builder.prototype.removeAttribute = function (prop) {
            this.currentElement.removeAttribute(prop);
        };
        /**
         *  Sets the id attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.id = function (id) {
            this.currentElement.setAttribute('id', id);
            return this;
        };
        /**
         *  Sets the src attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.src = function (src) {
            this.currentElement.setAttribute('src', src);
            return this;
        };
        /**
         *  Sets the href attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.href = function (href) {
            this.currentElement.setAttribute('href', href);
            return this;
        };
        /**
         *  Sets the title attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.title = function (title) {
            this.currentElement.setAttribute('title', title);
            return this;
        };
        /**
         *  Sets the name attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.name = function (name) {
            this.currentElement.setAttribute('name', name);
            return this;
        };
        /**
         *  Sets the type attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.type = function (type) {
            this.currentElement.setAttribute('type', type);
            return this;
        };
        /**
         *  Sets the value attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.value = function (value) {
            this.currentElement.setAttribute('value', value);
            return this;
        };
        /**
         *  Sets the alt attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.alt = function (alt) {
            this.currentElement.setAttribute('alt', alt);
            return this;
        };
        /**
         *  Sets the name draggable to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.draggable = function (isDraggable) {
            this.currentElement.setAttribute('draggable', isDraggable ? 'true' : 'false');
            return this;
        };
        /**
         *  Sets the tabindex attribute to the value provided for the current HTML element of the builder.
         */
        Builder.prototype.tabindex = function (index) {
            this.currentElement.setAttribute('tabindex', index.toString());
            return this;
        };
        Builder.prototype.style = function (firstP, secondP) {
            // Apply Object Literal to Styles of Element
            if (types.isObject(firstP)) {
                for (var prop in firstP) {
                    if (firstP.hasOwnProperty(prop)) {
                        var value = firstP[prop];
                        this.doSetStyle(prop, value);
                    }
                }
            }
            else if (types.isString(firstP) && !types.isString(secondP)) {
                return this.currentElement.style[this.cssKeyToJavaScriptProperty(firstP)];
            }
            else if (types.isString(firstP) && types.isString(secondP)) {
                this.doSetStyle(firstP, secondP);
            }
            return this;
        };
        Builder.prototype.doSetStyle = function (key, value) {
            if (key.indexOf('-') >= 0) {
                var segments = key.split('-');
                key = segments[0];
                for (var i = 1; i < segments.length; i++) {
                    var segment = segments[i];
                    key = key + segment.charAt(0).toUpperCase() + segment.substr(1);
                }
            }
            this.currentElement.style[this.cssKeyToJavaScriptProperty(key)] = value;
        };
        Builder.prototype.cssKeyToJavaScriptProperty = function (key) {
            // Automagically convert dashes as they are not allowed when programmatically
            // setting a CSS style property
            if (key.indexOf('-') >= 0) {
                var segments = key.split('-');
                key = segments[0];
                for (var i = 1; i < segments.length; i++) {
                    var segment = segments[i];
                    key = key + segment.charAt(0).toUpperCase() + segment.substr(1);
                }
            }
            else if (key === 'float') {
                key = 'cssFloat';
            }
            return key;
        };
        /**
         *  Returns the computed CSS style for the current HTML element of the builder.
         */
        Builder.prototype.getComputedStyle = function () {
            return DOM.getComputedStyle(this.currentElement);
        };
        /**
         *  Adds the variable list of arguments as class names to the current HTML element of the builder.
         */
        Builder.prototype.addClass = function () {
            var _this = this;
            var classes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                classes[_i - 0] = arguments[_i];
            }
            classes.forEach(function (nameValue) {
                var names = nameValue.split(' ');
                names.forEach(function (name) {
                    DOM.addClass(_this.currentElement, name);
                });
            });
            return this;
        };
        /**
         *  Sets the class name of the current HTML element of the builder to the provided className.
         *  If shouldAddClass is provided - for true class is added, for false class is removed.
         */
        Builder.prototype.setClass = function (className, shouldAddClass) {
            if (shouldAddClass === void 0) { shouldAddClass = null; }
            if (shouldAddClass === null) {
                this.currentElement.className = className;
            }
            else if (shouldAddClass) {
                this.addClass(className);
            }
            else {
                this.removeClass(className);
            }
            return this;
        };
        /**
         *  Returns whether the current HTML element of the builder has the provided class assigned.
         */
        Builder.prototype.hasClass = function (className) {
            return DOM.hasClass(this.currentElement, className);
        };
        /**
         *  Removes the variable list of arguments as class names from the current HTML element of the builder.
         */
        Builder.prototype.removeClass = function () {
            var _this = this;
            var classes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                classes[_i - 0] = arguments[_i];
            }
            classes.forEach(function (nameValue) {
                var names = nameValue.split(' ');
                names.forEach(function (name) {
                    DOM.removeClass(_this.currentElement, name);
                });
            });
            return this;
        };
        /**
         *  Sets the first class to the current HTML element of the builder if the second class is currently set
         *  and vice versa otherwise.
         */
        Builder.prototype.swapClass = function (classA, classB) {
            if (this.hasClass(classA)) {
                this.removeClass(classA);
                this.addClass(classB);
            }
            else {
                this.removeClass(classB);
                this.addClass(classA);
            }
            return this;
        };
        /**
         *  Adds or removes the provided className for the current HTML element of the builder.
         */
        Builder.prototype.toggleClass = function (className) {
            if (this.hasClass(className)) {
                this.removeClass(className);
            }
            else {
                this.addClass(className);
            }
            return this;
        };
        /**
         *  Sets the CSS property color.
         */
        Builder.prototype.color = function (color) {
            this.currentElement.style.color = color;
            return this;
        };
        /**
         *  Sets the CSS property background.
         */
        Builder.prototype.background = function (color) {
            this.currentElement.style.backgroundColor = color;
            return this;
        };
        Builder.prototype.padding = function (top, right, bottom, left) {
            if (types.isString(top) && top.indexOf(' ') >= 0) {
                return this.padding.apply(this, top.split(' '));
            }
            if (!types.isUndefinedOrNull(top)) {
                this.currentElement.style.paddingTop = this.toPixel(top);
            }
            if (!types.isUndefinedOrNull(right)) {
                this.currentElement.style.paddingRight = this.toPixel(right);
            }
            if (!types.isUndefinedOrNull(bottom)) {
                this.currentElement.style.paddingBottom = this.toPixel(bottom);
            }
            if (!types.isUndefinedOrNull(left)) {
                this.currentElement.style.paddingLeft = this.toPixel(left);
            }
            return this;
        };
        Builder.prototype.margin = function (top, right, bottom, left) {
            if (types.isString(top) && top.indexOf(' ') >= 0) {
                return this.margin.apply(this, top.split(' '));
            }
            if (!types.isUndefinedOrNull(top)) {
                this.currentElement.style.marginTop = this.toPixel(top);
            }
            if (!types.isUndefinedOrNull(right)) {
                this.currentElement.style.marginRight = this.toPixel(right);
            }
            if (!types.isUndefinedOrNull(bottom)) {
                this.currentElement.style.marginBottom = this.toPixel(bottom);
            }
            if (!types.isUndefinedOrNull(left)) {
                this.currentElement.style.marginLeft = this.toPixel(left);
            }
            return this;
        };
        Builder.prototype.position = function (top, right, bottom, left, position) {
            if (types.isString(top) && top.indexOf(' ') >= 0) {
                return this.position.apply(this, top.split(' '));
            }
            if (!types.isUndefinedOrNull(top)) {
                this.currentElement.style.top = this.toPixel(top);
            }
            if (!types.isUndefinedOrNull(right)) {
                this.currentElement.style.right = this.toPixel(right);
            }
            if (!types.isUndefinedOrNull(bottom)) {
                this.currentElement.style.bottom = this.toPixel(bottom);
            }
            if (!types.isUndefinedOrNull(left)) {
                this.currentElement.style.left = this.toPixel(left);
            }
            if (!position) {
                position = 'absolute';
            }
            this.currentElement.style.position = position;
            return this;
        };
        Builder.prototype.size = function (width, height) {
            if (types.isString(width) && width.indexOf(' ') >= 0) {
                return this.size.apply(this, width.split(' '));
            }
            if (!types.isUndefinedOrNull(width)) {
                this.currentElement.style.width = this.toPixel(width);
            }
            if (!types.isUndefinedOrNull(height)) {
                this.currentElement.style.height = this.toPixel(height);
            }
            return this;
        };
        Builder.prototype.minSize = function (width, height) {
            if (types.isString(width) && width.indexOf(' ') >= 0) {
                return this.minSize.apply(this, width.split(' '));
            }
            if (!types.isUndefinedOrNull(width)) {
                this.currentElement.style.minWidth = this.toPixel(width);
            }
            if (!types.isUndefinedOrNull(height)) {
                this.currentElement.style.minHeight = this.toPixel(height);
            }
            return this;
        };
        Builder.prototype.maxSize = function (width, height) {
            if (types.isString(width) && width.indexOf(' ') >= 0) {
                return this.maxSize.apply(this, width.split(' '));
            }
            if (!types.isUndefinedOrNull(width)) {
                this.currentElement.style.maxWidth = this.toPixel(width);
            }
            if (!types.isUndefinedOrNull(height)) {
                this.currentElement.style.maxHeight = this.toPixel(height);
            }
            return this;
        };
        /**
         *  Sets the CSS property float.
         */
        Builder.prototype.float = function (float) {
            this.currentElement.style.cssFloat = float;
            return this;
        };
        /**
         *  Sets the CSS property clear.
         */
        Builder.prototype.clear = function (clear) {
            this.currentElement.style.clear = clear;
            return this;
        };
        /**
         *  Sets the CSS property for fonts back to default.
         */
        Builder.prototype.normal = function () {
            this.currentElement.style.fontStyle = 'normal';
            this.currentElement.style.fontWeight = 'normal';
            this.currentElement.style.textDecoration = 'none';
            return this;
        };
        /**
         *  Sets the CSS property font-style to italic.
         */
        Builder.prototype.italic = function () {
            this.currentElement.style.fontStyle = 'italic';
            return this;
        };
        /**
         *  Sets the CSS property font-weight to bold.
         */
        Builder.prototype.bold = function () {
            this.currentElement.style.fontWeight = 'bold';
            return this;
        };
        /**
         *  Sets the CSS property text-decoration to underline.
         */
        Builder.prototype.underline = function () {
            this.currentElement.style.textDecoration = 'underline';
            return this;
        };
        /**
         *  Sets the CSS property overflow.
         */
        Builder.prototype.overflow = function (overflow) {
            this.currentElement.style.overflow = overflow;
            return this;
        };
        /**
         *  Sets the CSS property display.
         */
        Builder.prototype.display = function (display) {
            this.currentElement.style.display = display;
            return this;
        };
        Builder.prototype.disable = function () {
            this.currentElement.setAttribute('disabled', 'disabled');
            return this;
        };
        Builder.prototype.enable = function () {
            this.currentElement.removeAttribute('disabled');
            return this;
        };
        /**
         *  Shows the current element of the builder.
         */
        Builder.prototype.show = function () {
            if (this.hasClass('hidden')) {
                this.removeClass('hidden');
            }
            this.attr('aria-hidden', 'false');
            // Cancel any pending showDelayed() invocation
            this.cancelVisibilityPromise();
            return this;
        };
        /**
         *  Shows the current builder element after the provided delay. If the builder
         *  was set to hidden using the hide() method before this method executed, the
         *  function will return without showing the current element. This is useful to
         *  only show the element when a specific delay is reached (e.g. for a long running
         *  operation.
         */
        Builder.prototype.showDelayed = function (delay) {
            var _this = this;
            // Cancel any pending showDelayed() invocation
            this.cancelVisibilityPromise();
            var promise = winjs_base_1.TPromise.timeout(delay);
            this.setProperty(VISIBILITY_BINDING_ID, promise);
            promise.done(function () {
                _this.removeProperty(VISIBILITY_BINDING_ID);
                _this.show();
            });
            return this;
        };
        /**
         *  Hides the current element of the builder.
         */
        Builder.prototype.hide = function () {
            if (!this.hasClass('hidden')) {
                this.addClass('hidden');
            }
            this.attr('aria-hidden', 'true');
            // Cancel any pending showDelayed() invocation
            this.cancelVisibilityPromise();
            return this;
        };
        /**
         *  Returns true if the current element of the builder is hidden.
         */
        Builder.prototype.isHidden = function () {
            return this.hasClass('hidden') || this.currentElement.style.display === 'none';
        };
        /**
         *  Toggles visibility of the current element of the builder.
         */
        Builder.prototype.toggleVisibility = function () {
            // Cancel any pending showDelayed() invocation
            this.cancelVisibilityPromise();
            this.swapClass('builder-visible', 'hidden');
            if (this.isHidden()) {
                this.attr('aria-hidden', 'true');
            }
            else {
                this.attr('aria-hidden', 'false');
            }
            return this;
        };
        Builder.prototype.cancelVisibilityPromise = function () {
            var promise = this.getProperty(VISIBILITY_BINDING_ID);
            if (promise) {
                promise.cancel();
                this.removeProperty(VISIBILITY_BINDING_ID);
            }
        };
        Builder.prototype.border = function (width, style, color) {
            if (types.isString(width) && width.indexOf(' ') >= 0) {
                return this.border.apply(this, width.split(' '));
            }
            this.currentElement.style.borderWidth = this.toPixel(width);
            if (color) {
                this.currentElement.style.borderColor = color;
            }
            if (style) {
                this.currentElement.style.borderStyle = style;
            }
            return this;
        };
        Builder.prototype.borderTop = function (width, style, color) {
            if (types.isString(width) && width.indexOf(' ') >= 0) {
                return this.borderTop.apply(this, width.split(' '));
            }
            this.currentElement.style.borderTopWidth = this.toPixel(width);
            if (color) {
                this.currentElement.style.borderTopColor = color;
            }
            if (style) {
                this.currentElement.style.borderTopStyle = style;
            }
            return this;
        };
        Builder.prototype.borderBottom = function (width, style, color) {
            if (types.isString(width) && width.indexOf(' ') >= 0) {
                return this.borderBottom.apply(this, width.split(' '));
            }
            this.currentElement.style.borderBottomWidth = this.toPixel(width);
            if (color) {
                this.currentElement.style.borderBottomColor = color;
            }
            if (style) {
                this.currentElement.style.borderBottomStyle = style;
            }
            return this;
        };
        Builder.prototype.borderLeft = function (width, style, color) {
            if (types.isString(width) && width.indexOf(' ') >= 0) {
                return this.borderLeft.apply(this, width.split(' '));
            }
            this.currentElement.style.borderLeftWidth = this.toPixel(width);
            if (color) {
                this.currentElement.style.borderLeftColor = color;
            }
            if (style) {
                this.currentElement.style.borderLeftStyle = style;
            }
            return this;
        };
        Builder.prototype.borderRight = function (width, style, color) {
            if (types.isString(width) && width.indexOf(' ') >= 0) {
                return this.borderRight.apply(this, width.split(' '));
            }
            this.currentElement.style.borderRightWidth = this.toPixel(width);
            if (color) {
                this.currentElement.style.borderRightColor = color;
            }
            if (style) {
                this.currentElement.style.borderRightStyle = style;
            }
            return this;
        };
        /**
         *  Sets the CSS property text-align.
         */
        Builder.prototype.textAlign = function (textAlign) {
            this.currentElement.style.textAlign = textAlign;
            return this;
        };
        /**
         *  Sets the CSS property vertical-align.
         */
        Builder.prototype.verticalAlign = function (valign) {
            this.currentElement.style.verticalAlign = valign;
            return this;
        };
        Builder.prototype.toPixel = function (obj) {
            if (obj.toString().indexOf('px') === -1) {
                return obj.toString() + 'px';
            }
            return obj;
        };
        /**
         *  Sets the innerHTML attribute.
         */
        Builder.prototype.innerHtml = function (html, append) {
            if (append) {
                this.currentElement.innerHTML += html;
            }
            else {
                this.currentElement.innerHTML = html;
            }
            return this;
        };
        /**
         *  Sets the textContent property of the element.
         *  All HTML special characters will be escaped.
         */
        Builder.prototype.text = function (text, append) {
            if (append) {
                // children is child Elements versus childNodes includes textNodes
                if (this.currentElement.children.length === 0) {
                    this.currentElement.textContent += text;
                }
                else {
                    // if there are elements inside this node, append the string as a new text node
                    // to avoid wiping out the innerHTML and replacing it with only text content
                    this.currentElement.appendChild(document.createTextNode(text));
                }
            }
            else {
                this.currentElement.textContent = text;
            }
            return this;
        };
        /**
         *  Sets the innerHTML attribute in escaped form.
         */
        Builder.prototype.safeInnerHtml = function (html, append) {
            return this.innerHtml(strings.escape(html), append);
        };
        /**
         *  Adds the provided object as property to the current element. Call getBinding()
         *  to retrieve it again.
         */
        Builder.prototype.bind = function (object) {
            bindElement(this.currentElement, object);
            return this;
        };
        /**
         *  Removes the binding of the current element.
         */
        Builder.prototype.unbind = function () {
            unbindElement(this.currentElement);
            return this;
        };
        /**
         *  Returns the object that was passed into the bind() call.
         */
        Builder.prototype.getBinding = function () {
            return getBindingFromElement(this.currentElement);
        };
        /**
         *  Allows to store arbritary data into the current element.
         */
        Builder.prototype.setProperty = function (key, value) {
            setPropertyOnElement(this.currentElement, key, value);
            return this;
        };
        /**
         *  Allows to get arbritary data from the current element.
         */
        Builder.prototype.getProperty = function (key, fallback) {
            return getPropertyFromElement(this.currentElement, key, fallback);
        };
        /**
         *  Removes a property from the current element that is stored under the given key.
         */
        Builder.prototype.removeProperty = function (key) {
            if (hasData(this.currentElement)) {
                delete data(this.currentElement)[key];
            }
            return this;
        };
        /**
         *  Returns a new builder with the parent element of the current element of the builder.
         */
        Builder.prototype.parent = function (offdom) {
            assert.ok(!this.offdom, 'Builder was created with offdom = true and thus has no parent set');
            return withElement(this.currentElement.parentNode, offdom);
        };
        /**
         *  Returns a new builder with all child elements of the current element of the builder.
         */
        Builder.prototype.children = function (offdom) {
            var children = this.currentElement.children;
            var builders = [];
            for (var i = 0; i < children.length; i++) {
                builders.push(withElement(children.item(i), offdom));
            }
            return new MultiBuilder(builders);
        };
        /**
         *  Removes the current HTMLElement from the given builder from this builder if this builders
         *  current HTMLElement is the direct parent.
         */
        Builder.prototype.removeChild = function (builder) {
            if (this.currentElement === builder.parent().getHTMLElement()) {
                this.currentElement.removeChild(builder.getHTMLElement());
            }
            return this;
        };
        /**
         *  Returns a new builder with all elements matching the provided selector scoped to the
         *  current element of the builder. Use Build.withElementsBySelector() to run the selector
         *  over the entire DOM.
         *  The returned builder is an instance of array that can have 0 elements if the selector does not match any
         *  elements.
         */
        Builder.prototype.select = function (selector, offdom) {
            assert.ok(types.isString(selector), 'Expected String as parameter');
            var elements = this.currentElement.querySelectorAll(selector);
            var builders = [];
            for (var i = 0; i < elements.length; i++) {
                builders.push(withElement(elements.item(i), offdom));
            }
            return new MultiBuilder(builders);
        };
        /**
         *  Returns true if the current element of the builder matches the given selector and false otherwise.
         */
        Builder.prototype.matches = function (selector) {
            var element = this.currentElement;
            var matches = element.webkitMatchesSelector || element.mozMatchesSelector || element.msMatchesSelector || element.oMatchesSelector;
            return matches && matches.call(element, selector);
        };
        /**
         *  Returns true if the current element of the builder has no children.
         */
        Builder.prototype.isEmpty = function () {
            return !this.currentElement.childNodes || this.currentElement.childNodes.length === 0;
        };
        /**
         * Recurse through all descendant nodes and remove their data binding.
         */
        Builder.prototype.unbindDescendants = function (current) {
            if (current && current.children) {
                for (var i = 0, length_1 = current.children.length; i < length_1; i++) {
                    var element = current.children.item(i);
                    // Unbind
                    if (hasData(element)) {
                        // Listeners
                        var listeners = data(element)[LISTENER_BINDING_ID];
                        if (types.isArray(listeners)) {
                            while (listeners.length) {
                                listeners.pop().dispose();
                            }
                        }
                        // Delete Data Slot
                        delete element[MS_DATA_KEY];
                    }
                    // Recurse
                    this.unbindDescendants(element);
                }
            }
        };
        /**
         *  Removes all HTML elements from the current element of the builder. Will also clean up any
         *  event listners registered and also clear any data binding and properties stored
         *  to any child element.
         */
        Builder.prototype.empty = function () {
            this.unbindDescendants(this.currentElement);
            this.clearChildren();
            if (this.offdom) {
                this.createdElements = [];
            }
            return this;
        };
        /**
         *  Removes all HTML elements from the current element of the builder.
         */
        Builder.prototype.clearChildren = function () {
            // Remove Elements
            if (this.currentElement) {
                DOM.clearNode(this.currentElement);
            }
            return this;
        };
        /**
         *  Removes the current HTML element and all its children from its parent and unbinds
         *  all listeners and properties set to the data slots.
         */
        Builder.prototype.destroy = function () {
            if (this.currentElement) {
                // Remove from parent
                if (this.currentElement.parentNode) {
                    this.currentElement.parentNode.removeChild(this.currentElement);
                }
                // Empty to clear listeners and bindings from children
                this.empty();
                // Unbind
                if (hasData(this.currentElement)) {
                    // Listeners
                    var listeners = data(this.currentElement)[LISTENER_BINDING_ID];
                    if (types.isArray(listeners)) {
                        while (listeners.length) {
                            listeners.pop().dispose();
                        }
                    }
                    // Delete Data Slot
                    delete this.currentElement[MS_DATA_KEY];
                }
            }
            var type;
            for (type in this.toUnbind) {
                if (this.toUnbind.hasOwnProperty(type) && types.isArray(this.toUnbind[type])) {
                    this.toUnbind[type] = lifecycle_1.dispose(this.toUnbind[type]);
                }
            }
            for (type in this.captureToUnbind) {
                if (this.captureToUnbind.hasOwnProperty(type) && types.isArray(this.captureToUnbind[type])) {
                    this.captureToUnbind[type] = lifecycle_1.dispose(this.captureToUnbind[type]);
                }
            }
            // Nullify fields
            this.currentElement = null;
            this.container = null;
            this.offdom = null;
            this.createdElements = null;
            this.captureToUnbind = null;
            this.toUnbind = null;
        };
        /**
         *  Removes the current HTML element and all its children from its parent and unbinds
         *  all listeners and properties set to the data slots.
         */
        Builder.prototype.dispose = function () {
            this.destroy();
        };
        /**
         *  Gets the size (in pixels) of an element, including the margin.
         */
        Builder.prototype.getTotalSize = function () {
            var totalWidth = DOM.getTotalWidth(this.currentElement);
            var totalHeight = DOM.getTotalHeight(this.currentElement);
            return new Dimension(totalWidth, totalHeight);
        };
        /**
         *  Gets the size (in pixels) of the inside of the element, excluding the border and padding.
         */
        Builder.prototype.getContentSize = function () {
            var contentWidth = DOM.getContentWidth(this.currentElement);
            var contentHeight = DOM.getContentHeight(this.currentElement);
            return new Dimension(contentWidth, contentHeight);
        };
        /**
         *  Another variant of getting the inner dimensions of an element.
         */
        Builder.prototype.getClientArea = function () {
            // 0.) Try with DOM clientWidth / clientHeight
            if (this.currentElement !== document.body) {
                return new Dimension(this.currentElement.clientWidth, this.currentElement.clientHeight);
            }
            // 1.) Try innerWidth / innerHeight
            if (window.innerWidth && window.innerHeight) {
                return new Dimension(window.innerWidth, window.innerHeight);
            }
            // 2.) Try with document.body.clientWidth / document.body.clientHeigh
            if (document.body && document.body.clientWidth && document.body.clientWidth) {
                return new Dimension(document.body.clientWidth, document.body.clientHeight);
            }
            // 3.) Try with document.documentElement.clientWidth / document.documentElement.clientHeight
            if (document.documentElement && document.documentElement.clientWidth && document.documentElement.clientHeight) {
                return new Dimension(document.documentElement.clientWidth, document.documentElement.clientHeight);
            }
            throw new Error('Unable to figure out browser width and height');
        };
        return Builder;
    }());
    exports.Builder = Builder;
    /**
     *  The multi builder provides the same methods as the builder, but allows to call
     *  them on an array of builders.
     */
    var MultiBuilder = (function (_super) {
        __extends(MultiBuilder, _super);
        function MultiBuilder(builders) {
            assert.ok(types.isArray(builders) || builders instanceof MultiBuilder, 'Expected Array or MultiBuilder as parameter');
            _super.call(this);
            this.length = 0;
            this.builders = [];
            // Add Builders to Array
            if (types.isArray(builders)) {
                for (var i = 0; i < builders.length; i++) {
                    if (builders[i] instanceof HTMLElement) {
                        this.push(withElement(builders[i]));
                    }
                    else {
                        this.push(builders[i]);
                    }
                }
            }
            else {
                for (var i = 0; i < builders.length; i++) {
                    this.push(builders.item(i));
                }
            }
            // Mixin Builder functions to operate on all builders
            var $outer = this;
            var propertyFn = function (prop) {
                $outer[prop] = function () {
                    var args = Array.prototype.slice.call(arguments);
                    var returnValues;
                    var mergeBuilders = false;
                    for (var i = 0; i < $outer.length; i++) {
                        var res = $outer.item(i)[prop].apply($outer.item(i), args);
                        // Merge MultiBuilders into one
                        if (res instanceof MultiBuilder) {
                            if (!returnValues) {
                                returnValues = [];
                            }
                            mergeBuilders = true;
                            for (var j = 0; j < res.length; j++) {
                                returnValues.push(res.item(j));
                            }
                        }
                        else if (!types.isUndefined(res) && !(res instanceof Builder)) {
                            if (!returnValues) {
                                returnValues = [];
                            }
                            returnValues.push(res);
                        }
                    }
                    if (returnValues && mergeBuilders) {
                        return new MultiBuilder(returnValues);
                    }
                    return returnValues || $outer;
                };
            };
            for (var prop in Builder.prototype) {
                if (prop !== 'clone' && prop !== 'and') {
                    if (Builder.prototype.hasOwnProperty(prop) && types.isFunction(Builder.prototype[prop])) {
                        propertyFn(prop);
                    }
                }
            }
        }
        MultiBuilder.prototype.item = function (i) {
            return this.builders[i];
        };
        MultiBuilder.prototype.push = function () {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i - 0] = arguments[_i];
            }
            for (var i = 0; i < items.length; i++) {
                this.builders.push(items[i]);
            }
            this.length = this.builders.length;
        };
        MultiBuilder.prototype.pop = function () {
            var element = this.builders.pop();
            this.length = this.builders.length;
            return element;
        };
        MultiBuilder.prototype.concat = function (items) {
            var elements = this.builders.concat(items);
            this.length = this.builders.length;
            return elements;
        };
        MultiBuilder.prototype.shift = function () {
            var element = this.builders.shift();
            this.length = this.builders.length;
            return element;
        };
        MultiBuilder.prototype.unshift = function (item) {
            var res = this.builders.unshift(item);
            this.length = this.builders.length;
            return res;
        };
        MultiBuilder.prototype.slice = function (start, end) {
            var elements = this.builders.slice(start, end);
            this.length = this.builders.length;
            return elements;
        };
        MultiBuilder.prototype.splice = function (start, deleteCount) {
            var elements = this.builders.splice(start, deleteCount);
            this.length = this.builders.length;
            return elements;
        };
        MultiBuilder.prototype.clone = function () {
            return new MultiBuilder(this);
        };
        MultiBuilder.prototype.and = function (obj) {
            // Convert HTMLElement to Builder as necessary
            if (!(obj instanceof Builder) && !(obj instanceof MultiBuilder)) {
                obj = new Builder(obj);
            }
            var builders = [];
            if (obj instanceof MultiBuilder) {
                for (var i = 0; i < obj.length; i++) {
                    builders.push(obj.item(i));
                }
            }
            else {
                builders.push(obj);
            }
            this.push.apply(this, builders);
            return this;
        };
        return MultiBuilder;
    }(Builder));
    exports.MultiBuilder = MultiBuilder;
    function withBuilder(builder, offdom) {
        if (builder instanceof MultiBuilder) {
            return new MultiBuilder(builder);
        }
        return new Builder(builder.getHTMLElement(), offdom);
    }
    function withElement(element, offdom) {
        return new Builder(element, offdom);
    }
    function offDOM() {
        return new Builder(null, true);
    }
    // Binding functions
    /**
     *  Allows to store arbritary data into element.
     */
    function setPropertyOnElement(element, key, value) {
        data(element)[key] = value;
    }
    exports.setPropertyOnElement = setPropertyOnElement;
    /**
     *  Allows to get arbritary data from element.
     */
    function getPropertyFromElement(element, key, fallback) {
        if (hasData(element)) {
            var value = data(element)[key];
            if (!types.isUndefined(value)) {
                return value;
            }
        }
        return fallback;
    }
    exports.getPropertyFromElement = getPropertyFromElement;
    /**
     *  Removes a property from an element.
     */
    function removePropertyFromElement(element, key) {
        if (hasData(element)) {
            delete data(element)[key];
        }
    }
    exports.removePropertyFromElement = removePropertyFromElement;
    /**
     *  Adds the provided object as property to the given element. Call getBinding()
     *  to retrieve it again.
     */
    function bindElement(element, object) {
        setPropertyOnElement(element, DATA_BINDING_ID, object);
    }
    exports.bindElement = bindElement;
    /**
     *  Removes the binding of the given element.
     */
    function unbindElement(element) {
        removePropertyFromElement(element, DATA_BINDING_ID);
    }
    exports.unbindElement = unbindElement;
    /**
     *  Returns the object that was passed into the bind() call for the element.
     */
    function getBindingFromElement(element) {
        return getPropertyFromElement(element, DATA_BINDING_ID);
    }
    exports.getBindingFromElement = getBindingFromElement;
    exports.Binding = {
        setPropertyOnElement: setPropertyOnElement,
        getPropertyFromElement: getPropertyFromElement,
        removePropertyFromElement: removePropertyFromElement,
        bindElement: bindElement,
        unbindElement: unbindElement,
        getBindingFromElement: getBindingFromElement
    };
    var SELECTOR_REGEX = /([\w\-]+)?(#([\w\-]+))?((.([\w\-]+))*)/;
    exports.$ = function (arg) {
        // Off-DOM use
        if (types.isUndefined(arg)) {
            return offDOM();
        }
        // Falsified values cause error otherwise
        if (!arg) {
            throw new Error('Bad use of $');
        }
        // Wrap the given element
        if (DOM.isHTMLElement(arg) || arg === window) {
            return withElement(arg);
        }
        // Wrap the given builders
        if (types.isArray(arg)) {
            return new MultiBuilder(arg);
        }
        // Wrap the given builder
        if (arg instanceof Builder) {
            return withBuilder(arg);
        }
        if (types.isString(arg)) {
            // Use the argument as HTML code
            if (arg[0] === '<') {
                var element = void 0;
                var container = document.createElement('div');
                container.innerHTML = strings.format.apply(strings, arguments);
                if (container.children.length === 0) {
                    throw new Error('Bad use of $');
                }
                if (container.children.length === 1) {
                    element = container.firstChild;
                    container.removeChild(element);
                    return withElement(element);
                }
                var builders = [];
                while (container.firstChild) {
                    element = container.firstChild;
                    container.removeChild(element);
                    builders.push(withElement(element));
                }
                return new MultiBuilder(builders);
            }
            else if (arguments.length === 1) {
                var match = SELECTOR_REGEX.exec(arg);
                if (!match) {
                    throw new Error('Bad use of $');
                }
                var tag = match[1] || 'div';
                var id = match[3] || undefined;
                var classes = (match[4] || '').replace(/\./g, ' ');
                var props = {};
                if (id) {
                    props['id'] = id;
                }
                if (classes) {
                    props['class'] = classes;
                }
                return offDOM().element(tag, props);
            }
            else {
                var result = offDOM();
                result.element.apply(result, arguments);
                return result;
            }
        }
        else {
            throw new Error('Bad use of $');
        }
    };
    exports.$.Box = Box;
    exports.$.Dimension = Dimension;
    exports.$.Position = Position;
    exports.$.Builder = Builder;
    exports.$.MultiBuilder = MultiBuilder;
    exports.$.Build = exports.Build;
    exports.$.Binding = exports.Binding;
});






define(__m[112], __M([0,1,3,11,149,39]), function (require, exports, lifecycle_1, dom, iframe_1, mouseEvent_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function standardMouseMoveMerger(lastEvent, currentEvent) {
        var ev = new mouseEvent_1.StandardMouseEvent(currentEvent);
        ev.preventDefault();
        return {
            leftButton: ev.leftButton,
            posx: ev.posx,
            posy: ev.posy
        };
    }
    exports.standardMouseMoveMerger = standardMouseMoveMerger;
    var GlobalMouseMoveMonitor = (function (_super) {
        __extends(GlobalMouseMoveMonitor, _super);
        function GlobalMouseMoveMonitor() {
            _super.call(this);
            this.hooks = [];
            this.mouseMoveEventMerger = null;
            this.mouseMoveCallback = null;
            this.onStopCallback = null;
        }
        GlobalMouseMoveMonitor.prototype.dispose = function () {
            this.stopMonitoring(false);
            _super.prototype.dispose.call(this);
        };
        GlobalMouseMoveMonitor.prototype.stopMonitoring = function (invokeStopCallback) {
            if (!this.isMonitoring()) {
                // Not monitoring
                return;
            }
            // Unhook
            this.hooks = lifecycle_1.dispose(this.hooks);
            this.mouseMoveEventMerger = null;
            this.mouseMoveCallback = null;
            var onStopCallback = this.onStopCallback;
            this.onStopCallback = null;
            if (invokeStopCallback) {
                onStopCallback();
            }
        };
        GlobalMouseMoveMonitor.prototype.isMonitoring = function () {
            return this.hooks.length > 0;
        };
        GlobalMouseMoveMonitor.prototype.startMonitoring = function (mouseMoveEventMerger, mouseMoveCallback, onStopCallback) {
            var _this = this;
            if (this.isMonitoring()) {
                // I am already hooked
                return;
            }
            this.mouseMoveEventMerger = mouseMoveEventMerger;
            this.mouseMoveCallback = mouseMoveCallback;
            this.onStopCallback = onStopCallback;
            var windowChain = iframe_1.IframeUtils.getSameOriginWindowChain();
            for (var i = 0; i < windowChain.length; i++) {
                this.hooks.push(dom.addDisposableThrottledListener(windowChain[i].window.document, 'mousemove', function (data) { return _this.mouseMoveCallback(data); }, function (lastEvent, currentEvent) { return _this.mouseMoveEventMerger(lastEvent, currentEvent); }));
                this.hooks.push(dom.addDisposableListener(windowChain[i].window.document, 'mouseup', function (e) { return _this.stopMonitoring(true); }));
            }
            if (iframe_1.IframeUtils.hasDifferentOriginAncestor()) {
                var lastSameOriginAncestor = windowChain[windowChain.length - 1];
                // We might miss a mouse up if it happens outside the iframe
                // This one is for Chrome
                this.hooks.push(dom.addDisposableListener(lastSameOriginAncestor.window.document, 'mouseout', function (browserEvent) {
                    var e = new mouseEvent_1.StandardMouseEvent(browserEvent);
                    if (e.target.tagName.toLowerCase() === 'html') {
                        _this.stopMonitoring(true);
                    }
                }));
                // This one is for FF
                this.hooks.push(dom.addDisposableListener(lastSameOriginAncestor.window.document, 'mouseover', function (browserEvent) {
                    var e = new mouseEvent_1.StandardMouseEvent(browserEvent);
                    if (e.target.tagName.toLowerCase() === 'html') {
                        _this.stopMonitoring(true);
                    }
                }));
                // This one is for IE
                this.hooks.push(dom.addDisposableListener(lastSameOriginAncestor.window.document.body, 'mouseleave', function (browserEvent) {
                    _this.stopMonitoring(true);
                }));
            }
        };
        return GlobalMouseMoveMonitor;
    }(lifecycle_1.Disposable));
    exports.GlobalMouseMoveMonitor = GlobalMouseMoveMonitor;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[71], __M([0,1,11,63,10,2,315]), function (require, exports, DOM, idGenerator_1, strings_1, winjs_base_1, marked_1) {
    'use strict';
    function renderMarkedString(markedStrings, options) {
        if (options === void 0) { options = {}; }
        var htmlContentElements = markedStrings.map(function (value) {
            if (typeof value === 'string') {
                return { markdown: value };
            }
            else if (typeof value === 'object') {
                return { code: value };
            }
            ;
        });
        return renderHtml(htmlContentElements, options);
    }
    exports.renderMarkedString = renderMarkedString;
    /**
     * Create html nodes for the given content element.
     *
     * @param content a html element description
     * @param actionCallback a callback function for any action links in the string. Argument is the zero-based index of the clicked action.
     */
    function renderHtml(content, options) {
        if (options === void 0) { options = {}; }
        if (typeof content === 'string') {
            return _renderHtml({ isText: true, text: content }, options);
        }
        else if (Array.isArray(content)) {
            return _renderHtml({ children: content }, options);
        }
        else if (content) {
            return _renderHtml(content, options);
        }
    }
    exports.renderHtml = renderHtml;
    function _renderHtml(content, options) {
        if (options === void 0) { options = {}; }
        var codeBlockRenderer = options.codeBlockRenderer, actionCallback = options.actionCallback;
        if (content.isText) {
            return document.createTextNode(content.text);
        }
        var tagName = getSafeTagName(content.tagName) || 'div';
        var element = document.createElement(tagName);
        if (content.className) {
            element.className = content.className;
        }
        if (content.text) {
            element.textContent = content.text;
        }
        if (content.style) {
            element.setAttribute('style', content.style);
        }
        if (content.customStyle) {
            Object.keys(content.customStyle).forEach(function (key) {
                element.style[key] = content.customStyle[key];
            });
        }
        if (content.children) {
            content.children.forEach(function (child) {
                element.appendChild(renderHtml(child, options));
            });
        }
        if (content.formattedText) {
            renderFormattedText(element, parseFormattedText(content.formattedText), actionCallback);
        }
        if (content.code && codeBlockRenderer) {
            // this is sort of legacy given that we have full
            // support for markdown. Turn this into markdown
            // and continue
            var _a = content.code, language = _a.language, value = _a.value;
            content.markdown = '```' + language + '\n' + value + '\n```';
        }
        if (content.markdown) {
            // signal to code-block render that the
            // element has been created
            var signalInnerHTML_1;
            var withInnerHTML_1 = new winjs_base_1.TPromise(function (c) { return signalInnerHTML_1 = c; });
            var renderer = new marked_1.marked.Renderer();
            renderer.link = function (href, title, text) {
                return "<a href=\"#\" data-href=\"" + href + "\" title=\"" + (title || text) + "\">" + text + "</a>";
            };
            renderer.paragraph = function (text) {
                return "<div>" + text + "</div>";
            };
            if (options.codeBlockRenderer) {
                renderer.code = function (code, lang) {
                    var value = options.codeBlockRenderer(lang, code);
                    if (typeof value === 'string') {
                        return value;
                    }
                    if (winjs_base_1.TPromise.is(value)) {
                        // when code-block rendering is async we return sync
                        // but update the node with the real result later.
                        var id_1 = idGenerator_1.defaultGenerator.nextId();
                        winjs_base_1.TPromise.join([value, withInnerHTML_1]).done(function (values) {
                            var value = values[0];
                            var span = element.querySelector("span[data-code=\"" + id_1 + "\"]");
                            if (span) {
                                span.innerHTML = value;
                            }
                        }, function (err) {
                            // ignore
                        });
                        return "<span data-code=\"" + id_1 + "\">" + strings_1.escape(code) + "</span>";
                    }
                    return code;
                };
            }
            if (options.actionCallback) {
                DOM.addStandardDisposableListener(element, 'click', function (event) {
                    if (event.target.tagName === 'A') {
                        var href = event.target.dataset['href'];
                        if (href) {
                            options.actionCallback(href, event);
                        }
                    }
                });
            }
            element.innerHTML = marked_1.marked(content.markdown, {
                sanitize: true,
                renderer: renderer
            });
            signalInnerHTML_1();
        }
        return element;
    }
    var SAFE_TAG_NAMES = {
        a: true,
        b: true,
        blockquote: true,
        code: true,
        del: true,
        dd: true,
        div: true,
        dl: true,
        dt: true,
        em: true,
        h1h2h3i: true,
        img: true,
        kbd: true,
        li: true,
        ol: true,
        p: true,
        pre: true,
        s: true,
        span: true,
        sup: true,
        sub: true,
        strong: true,
        strike: true,
        ul: true,
        br: true,
        hr: true,
    };
    function getSafeTagName(tagName) {
        if (!tagName) {
            return null;
        }
        if (SAFE_TAG_NAMES.hasOwnProperty(tagName)) {
            return tagName;
        }
        return null;
    }
    // --- formatted string parsing
    var StringStream = (function () {
        function StringStream(source) {
            this.source = source;
            this.index = 0;
        }
        StringStream.prototype.eos = function () {
            return this.index >= this.source.length;
        };
        StringStream.prototype.next = function () {
            var next = this.peek();
            this.advance();
            return next;
        };
        StringStream.prototype.peek = function () {
            return this.source[this.index];
        };
        StringStream.prototype.advance = function () {
            this.index++;
        };
        return StringStream;
    }());
    var FormatType;
    (function (FormatType) {
        FormatType[FormatType["Invalid"] = 0] = "Invalid";
        FormatType[FormatType["Root"] = 1] = "Root";
        FormatType[FormatType["Text"] = 2] = "Text";
        FormatType[FormatType["Bold"] = 3] = "Bold";
        FormatType[FormatType["Italics"] = 4] = "Italics";
        FormatType[FormatType["Action"] = 5] = "Action";
        FormatType[FormatType["ActionClose"] = 6] = "ActionClose";
        FormatType[FormatType["NewLine"] = 7] = "NewLine";
    })(FormatType || (FormatType = {}));
    function renderFormattedText(element, treeNode, actionCallback) {
        var child;
        if (treeNode.type === FormatType.Text) {
            child = document.createTextNode(treeNode.content);
        }
        else if (treeNode.type === FormatType.Bold) {
            child = document.createElement('b');
        }
        else if (treeNode.type === FormatType.Italics) {
            child = document.createElement('i');
        }
        else if (treeNode.type === FormatType.Action) {
            var a = document.createElement('a');
            a.href = '#';
            DOM.addStandardDisposableListener(a, 'click', function (event) {
                actionCallback(String(treeNode.index), event);
            });
            child = a;
        }
        else if (treeNode.type === FormatType.NewLine) {
            child = document.createElement('br');
        }
        else if (treeNode.type === FormatType.Root) {
            child = element;
        }
        if (element !== child) {
            element.appendChild(child);
        }
        if (Array.isArray(treeNode.children)) {
            treeNode.children.forEach(function (nodeChild) {
                renderFormattedText(child, nodeChild, actionCallback);
            });
        }
    }
    function parseFormattedText(content) {
        var root = {
            type: FormatType.Root,
            children: []
        };
        var actionItemIndex = 0;
        var current = root;
        var stack = [];
        var stream = new StringStream(content);
        while (!stream.eos()) {
            var next = stream.next();
            var isEscapedFormatType = (next === '\\' && formatTagType(stream.peek()) !== FormatType.Invalid);
            if (isEscapedFormatType) {
                next = stream.next(); // unread the backslash if it escapes a format tag type
            }
            if (!isEscapedFormatType && isFormatTag(next) && next === stream.peek()) {
                stream.advance();
                if (current.type === FormatType.Text) {
                    current = stack.pop();
                }
                var type = formatTagType(next);
                if (current.type === type || (current.type === FormatType.Action && type === FormatType.ActionClose)) {
                    current = stack.pop();
                }
                else {
                    var newCurrent = {
                        type: type,
                        children: []
                    };
                    if (type === FormatType.Action) {
                        newCurrent.index = actionItemIndex;
                        actionItemIndex++;
                    }
                    current.children.push(newCurrent);
                    stack.push(current);
                    current = newCurrent;
                }
            }
            else if (next === '\n') {
                if (current.type === FormatType.Text) {
                    current = stack.pop();
                }
                current.children.push({
                    type: FormatType.NewLine
                });
            }
            else {
                if (current.type !== FormatType.Text) {
                    var textCurrent = {
                        type: FormatType.Text,
                        content: next
                    };
                    current.children.push(textCurrent);
                    stack.push(current);
                    current = textCurrent;
                }
                else {
                    current.content += next;
                }
            }
        }
        if (current.type === FormatType.Text) {
            current = stack.pop();
        }
        if (stack.length) {
        }
        return root;
    }
    function isFormatTag(char) {
        return formatTagType(char) !== FormatType.Invalid;
    }
    function formatTagType(char) {
        switch (char) {
            case '*':
                return FormatType.Bold;
            case '_':
                return FormatType.Italics;
            case '[':
                return FormatType.Action;
            case ']':
                return FormatType.ActionClose;
            default:
                return FormatType.Invalid;
        }
    }
});






define(__m[27], __M([0,1,11]), function (require, exports, dom) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var FastDomNode = (function () {
        function FastDomNode(domNode) {
            this._domNode = domNode;
            this._maxWidth = -1;
            this._width = -1;
            this._height = -1;
            this._top = -1;
            this._left = -1;
            this._bottom = -1;
            this._right = -1;
            this._fontFamily = '';
            this._fontSize = -1;
            this._lineHeight = -1;
            this._className = '';
            this._display = '';
            this._position = '';
            this._visibility = '';
            this._transform = '';
            this._lineNumber = '';
        }
        Object.defineProperty(FastDomNode.prototype, "domNode", {
            get: function () {
                return this._domNode;
            },
            enumerable: true,
            configurable: true
        });
        FastDomNode.prototype.setMaxWidth = function (maxWidth) {
            if (this._maxWidth === maxWidth) {
                return;
            }
            this._maxWidth = maxWidth;
            this._domNode.style.maxWidth = this._maxWidth + 'px';
        };
        FastDomNode.prototype.setWidth = function (width) {
            if (this._width === width) {
                return;
            }
            this._width = width;
            this._domNode.style.width = this._width + 'px';
        };
        FastDomNode.prototype.setHeight = function (height) {
            if (this._height === height) {
                return;
            }
            this._height = height;
            this._domNode.style.height = this._height + 'px';
        };
        FastDomNode.prototype.setTop = function (top) {
            if (this._top === top) {
                return;
            }
            this._top = top;
            this._domNode.style.top = this._top + 'px';
        };
        FastDomNode.prototype.setLeft = function (left) {
            if (this._left === left) {
                return;
            }
            this._left = left;
            this._domNode.style.left = this._left + 'px';
        };
        FastDomNode.prototype.setBottom = function (bottom) {
            if (this._bottom === bottom) {
                return;
            }
            this._bottom = bottom;
            this._domNode.style.bottom = this._bottom + 'px';
        };
        FastDomNode.prototype.setRight = function (right) {
            if (this._right === right) {
                return;
            }
            this._right = right;
            this._domNode.style.right = this._right + 'px';
        };
        FastDomNode.prototype.setFontFamily = function (fontFamily) {
            if (this._fontFamily === fontFamily) {
                return;
            }
            this._fontFamily = fontFamily;
            this._domNode.style.fontFamily = this._fontFamily;
        };
        FastDomNode.prototype.setFontSize = function (fontSize) {
            if (this._fontSize === fontSize) {
                return;
            }
            this._fontSize = fontSize;
            this._domNode.style.fontSize = this._fontSize + 'px';
        };
        FastDomNode.prototype.setLineHeight = function (lineHeight) {
            if (this._lineHeight === lineHeight) {
                return;
            }
            this._lineHeight = lineHeight;
            this._domNode.style.lineHeight = this._lineHeight + 'px';
        };
        FastDomNode.prototype.setClassName = function (className) {
            if (this._className === className) {
                return;
            }
            this._className = className;
            this._domNode.className = this._className;
        };
        FastDomNode.prototype.toggleClassName = function (className, shouldHaveIt) {
            dom.toggleClass(this._domNode, className, shouldHaveIt);
            this._className = this._domNode.className;
        };
        FastDomNode.prototype.setDisplay = function (display) {
            if (this._display === display) {
                return;
            }
            this._display = display;
            this._domNode.style.display = this._display;
        };
        FastDomNode.prototype.setPosition = function (position) {
            if (this._position === position) {
                return;
            }
            this._position = position;
            this._domNode.style.position = this._position;
        };
        FastDomNode.prototype.setVisibility = function (visibility) {
            if (this._visibility === visibility) {
                return;
            }
            this._visibility = visibility;
            this._domNode.style.visibility = this._visibility;
        };
        FastDomNode.prototype.setTransform = function (transform) {
            if (this._transform === transform) {
                return;
            }
            this._transform = transform;
            this._setTransform(this._domNode, this._transform);
        };
        FastDomNode.prototype.setLineNumber = function (lineNumber) {
            if (this._lineNumber === lineNumber) {
                return;
            }
            this._lineNumber = lineNumber;
            this._domNode.setAttribute('lineNumber', this._lineNumber);
        };
        return FastDomNode;
    }());
    exports.FastDomNode = FastDomNode;
    var WebKitFastDomNode = (function (_super) {
        __extends(WebKitFastDomNode, _super);
        function WebKitFastDomNode() {
            _super.apply(this, arguments);
        }
        WebKitFastDomNode.prototype._setTransform = function (domNode, transform) {
            domNode.style.webkitTransform = transform;
        };
        return WebKitFastDomNode;
    }(FastDomNode));
    var StandardFastDomNode = (function (_super) {
        __extends(StandardFastDomNode, _super);
        function StandardFastDomNode() {
            _super.apply(this, arguments);
        }
        StandardFastDomNode.prototype._setTransform = function (domNode, transform) {
            domNode.style.transform = transform;
        };
        return StandardFastDomNode;
    }(FastDomNode));
    var useWebKitFastDomNode = false;
    (function () {
        var testDomNode = document.createElement('div');
        if (typeof testDomNode.style.webkitTransform !== 'undefined') {
            useWebKitFastDomNode = true;
        }
    })();
    function createFastDomNode(domNode) {
        if (useWebKitFastDomNode) {
            return new WebKitFastDomNode(domNode);
        }
        else {
            return new StandardFastDomNode(domNode);
        }
    }
    exports.createFastDomNode = createFastDomNode;
    exports.StyleMutator = {
        setMaxWidth: function (domNode, maxWidth) {
            var desiredValue = maxWidth + 'px';
            if (domNode.style.maxWidth !== desiredValue) {
                domNode.style.maxWidth = desiredValue;
            }
        },
        setWidth: function (domNode, width) {
            var desiredValue = width + 'px';
            if (domNode.style.width !== desiredValue) {
                domNode.style.width = desiredValue;
            }
        },
        setHeight: function (domNode, height) {
            var desiredValue = height + 'px';
            if (domNode.style.height !== desiredValue) {
                domNode.style.height = desiredValue;
            }
        },
        setTop: function (domNode, top) {
            var desiredValue = top + 'px';
            if (domNode.style.top !== desiredValue) {
                domNode.style.top = desiredValue;
                return true;
            }
            return false;
        },
        setLeft: function (domNode, left) {
            var desiredValue = left + 'px';
            if (domNode.style.left !== desiredValue) {
                domNode.style.left = desiredValue;
                return true;
            }
            return false;
        },
        setBottom: function (domNode, bottom) {
            var desiredValue = bottom + 'px';
            if (domNode.style.bottom !== desiredValue) {
                domNode.style.bottom = desiredValue;
            }
        },
        setRight: function (domNode, right) {
            var desiredValue = right + 'px';
            if (domNode.style.right !== desiredValue) {
                domNode.style.right = desiredValue;
            }
        },
        setFontSize: function (domNode, fontSize) {
            var desiredValue = fontSize + 'px';
            if (domNode.style.fontSize !== desiredValue) {
                domNode.style.fontSize = desiredValue;
            }
        },
        setLineHeight: function (domNode, lineHeight) {
            var desiredValue = lineHeight + 'px';
            if (domNode.style.lineHeight !== desiredValue) {
                domNode.style.lineHeight = desiredValue;
            }
        },
        setTransform: null,
        setDisplay: function (domNode, desiredValue) {
            if (domNode.style.display !== desiredValue) {
                domNode.style.display = desiredValue;
            }
        },
        setVisibility: function (domNode, desiredValue) {
            if (domNode.style.visibility !== desiredValue) {
                domNode.style.visibility = desiredValue;
            }
        },
    };
    // Define setTransform
    function setWebkitTransform(domNode, desiredValue) {
        if (domNode.getAttribute('data-transform') !== desiredValue) {
            domNode.setAttribute('data-transform', desiredValue);
            domNode.style.webkitTransform = desiredValue;
            return true;
        }
        return false;
    }
    function setTransform(domNode, desiredValue) {
        if (domNode.getAttribute('data-transform') !== desiredValue) {
            domNode.setAttribute('data-transform', desiredValue);
            domNode.style.transform = desiredValue;
            return true;
        }
        return false;
    }
    (function () {
        var testDomNode = document.createElement('div');
        if (typeof testDomNode.style.webkitTransform !== 'undefined') {
            exports.StyleMutator.setTransform = setWebkitTransform;
        }
        else {
            exports.StyleMutator.setTransform = setTransform;
        }
    })();
});

define(__m[69], __M([0,1,37,3,11]), function (require, exports, arrays, lifecycle_1, DomUtils) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EventType;
    (function (EventType) {
        EventType.Tap = '-monaco-gesturetap';
        EventType.Change = '-monaco-gesturechange';
        EventType.Start = '-monaco-gesturestart';
        EventType.End = '-monaco-gesturesend';
        EventType.Contextmenu = '-monaco-gesturecontextmenu';
    })(EventType = exports.EventType || (exports.EventType = {}));
    var Gesture = (function () {
        function Gesture(target) {
            this.callOnTarget = [];
            this.activeTouches = {};
            this.target = target;
            this.handle = null;
        }
        Gesture.prototype.dispose = function () {
            this.target = null;
            if (this.handle) {
                this.handle.dispose();
                this.handle = null;
            }
        };
        Object.defineProperty(Gesture.prototype, "target", {
            set: function (element) {
                var _this = this;
                this.callOnTarget = lifecycle_1.dispose(this.callOnTarget);
                this.activeTouches = {};
                this.targetElement = element;
                if (!this.targetElement) {
                    return;
                }
                this.callOnTarget.push(DomUtils.addDisposableListener(this.targetElement, 'touchstart', function (e) { return _this.onTouchStart(e); }));
                this.callOnTarget.push(DomUtils.addDisposableListener(this.targetElement, 'touchend', function (e) { return _this.onTouchEnd(e); }));
                this.callOnTarget.push(DomUtils.addDisposableListener(this.targetElement, 'touchmove', function (e) { return _this.onTouchMove(e); }));
            },
            enumerable: true,
            configurable: true
        });
        Gesture.newGestureEvent = function (type) {
            var event = document.createEvent('CustomEvent');
            event.initEvent(type, false, true);
            return event;
        };
        Gesture.prototype.onTouchStart = function (e) {
            var timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.
            e.preventDefault();
            e.stopPropagation();
            if (this.handle) {
                this.handle.dispose();
                this.handle = null;
            }
            for (var i = 0, len = e.targetTouches.length; i < len; i++) {
                var touch = e.targetTouches.item(i);
                this.activeTouches[touch.identifier] = {
                    id: touch.identifier,
                    initialTarget: touch.target,
                    initialTimeStamp: timestamp,
                    initialPageX: touch.pageX,
                    initialPageY: touch.pageY,
                    rollingTimestamps: [timestamp],
                    rollingPageX: [touch.pageX],
                    rollingPageY: [touch.pageY]
                };
                var evt = Gesture.newGestureEvent(EventType.Start);
                evt.pageX = touch.pageX;
                evt.pageY = touch.pageY;
                this.targetElement.dispatchEvent(evt);
            }
        };
        Gesture.prototype.onTouchEnd = function (e) {
            var timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.
            e.preventDefault();
            e.stopPropagation();
            var activeTouchCount = Object.keys(this.activeTouches).length;
            for (var i = 0, len = e.changedTouches.length; i < len; i++) {
                var touch = e.changedTouches.item(i);
                if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {
                    console.warn('move of an UNKNOWN touch', touch);
                    continue;
                }
                var data = this.activeTouches[touch.identifier], holdTime = Date.now() - data.initialTimeStamp;
                if (holdTime < Gesture.HOLD_DELAY
                    && Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)) < 30
                    && Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)) < 30) {
                    var evt = Gesture.newGestureEvent(EventType.Tap);
                    evt.initialTarget = data.initialTarget;
                    evt.pageX = arrays.tail(data.rollingPageX);
                    evt.pageY = arrays.tail(data.rollingPageY);
                    this.targetElement.dispatchEvent(evt);
                }
                else if (holdTime >= Gesture.HOLD_DELAY
                    && Math.abs(data.initialPageX - arrays.tail(data.rollingPageX)) < 30
                    && Math.abs(data.initialPageY - arrays.tail(data.rollingPageY)) < 30) {
                    var evt = Gesture.newGestureEvent(EventType.Contextmenu);
                    evt.initialTarget = data.initialTarget;
                    evt.pageX = arrays.tail(data.rollingPageX);
                    evt.pageY = arrays.tail(data.rollingPageY);
                    this.targetElement.dispatchEvent(evt);
                }
                else if (activeTouchCount === 1) {
                    var finalX = arrays.tail(data.rollingPageX);
                    var finalY = arrays.tail(data.rollingPageY);
                    var deltaT = arrays.tail(data.rollingTimestamps) - data.rollingTimestamps[0];
                    var deltaX = finalX - data.rollingPageX[0];
                    var deltaY = finalY - data.rollingPageY[0];
                    this.inertia(timestamp, // time now
                    Math.abs(deltaX) / deltaT, // speed
                    deltaX > 0 ? 1 : -1, // x direction
                    finalX, // x now
                    Math.abs(deltaY) / deltaT, // y speed
                    deltaY > 0 ? 1 : -1, // y direction
                    finalY // y now
                    );
                }
                // forget about this touch
                delete this.activeTouches[touch.identifier];
            }
        };
        Gesture.prototype.inertia = function (t1, vX, dirX, x, vY, dirY, y) {
            var _this = this;
            this.handle = DomUtils.scheduleAtNextAnimationFrame(function () {
                var now = Date.now();
                // velocity: old speed + accel_over_time
                var deltaT = now - t1, delta_pos_x = 0, delta_pos_y = 0, stopped = true;
                vX += Gesture.SCROLL_FRICTION * deltaT;
                vY += Gesture.SCROLL_FRICTION * deltaT;
                if (vX > 0) {
                    stopped = false;
                    delta_pos_x = dirX * vX * deltaT;
                }
                if (vY > 0) {
                    stopped = false;
                    delta_pos_y = dirY * vY * deltaT;
                }
                // dispatch translation event
                var evt = Gesture.newGestureEvent(EventType.Change);
                evt.translationX = delta_pos_x;
                evt.translationY = delta_pos_y;
                _this.targetElement.dispatchEvent(evt);
                if (!stopped) {
                    _this.inertia(now, vX, dirX, x + delta_pos_x, vY, dirY, y + delta_pos_y);
                }
            });
        };
        Gesture.prototype.onTouchMove = function (e) {
            var timestamp = Date.now(); // use Date.now() because on FF e.timeStamp is not epoch based.
            e.preventDefault();
            e.stopPropagation();
            for (var i = 0, len = e.changedTouches.length; i < len; i++) {
                var touch = e.changedTouches.item(i);
                if (!this.activeTouches.hasOwnProperty(String(touch.identifier))) {
                    console.warn('end of an UNKNOWN touch', touch);
                    continue;
                }
                var data = this.activeTouches[touch.identifier];
                var evt = Gesture.newGestureEvent(EventType.Change);
                evt.translationX = touch.pageX - arrays.tail(data.rollingPageX);
                evt.translationY = touch.pageY - arrays.tail(data.rollingPageY);
                evt.pageX = touch.pageX;
                evt.pageY = touch.pageY;
                this.targetElement.dispatchEvent(evt);
                // only keep a few data points, to average the final speed
                if (data.rollingPageX.length > 3) {
                    data.rollingPageX.shift();
                    data.rollingPageY.shift();
                    data.rollingTimestamps.shift();
                }
                data.rollingPageX.push(touch.pageX);
                data.rollingPageY.push(touch.pageY);
                data.rollingTimestamps.push(timestamp);
            }
        };
        Gesture.HOLD_DELAY = 700;
        Gesture.SCROLL_FRICTION = -0.005;
        return Gesture;
    }());
    exports.Gesture = Gesture;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[58], __M([0,1,510,3,35,18,50,11,60,26,23,69,56,12,376]), function (require, exports, nls, lifecycle, builder_1, platform, actions_1, DOM, events_1, types, eventEmitter_1, touch_1, keyboardEvent_1, keyCodes_1) {
    'use strict';
    var BaseActionItem = (function (_super) {
        __extends(BaseActionItem, _super);
        function BaseActionItem(context, action) {
            var _this = this;
            _super.call(this);
            this._callOnDispose = [];
            this._context = context || this;
            this._action = action;
            if (action instanceof actions_1.Action) {
                var l = action.addBulkListener2(function (events) {
                    if (!_this.builder) {
                        // we have not been rendered yet, so there
                        // is no point in updating the UI
                        return;
                    }
                    events.forEach(function (event) {
                        switch (event.getType()) {
                            case actions_1.Action.ENABLED:
                                _this._updateEnabled();
                                break;
                            case actions_1.Action.LABEL:
                                _this._updateLabel();
                                _this._updateTooltip();
                                break;
                            case actions_1.Action.TOOLTIP:
                                _this._updateTooltip();
                                break;
                            case actions_1.Action.CLASS:
                                _this._updateClass();
                                break;
                            case actions_1.Action.CHECKED:
                                _this._updateChecked();
                                break;
                            default:
                                _this._updateUnknown(event);
                                break;
                        }
                    });
                });
                this._callOnDispose.push(l);
            }
        }
        Object.defineProperty(BaseActionItem.prototype, "callOnDispose", {
            get: function () {
                return this._callOnDispose;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseActionItem.prototype, "actionRunner", {
            get: function () {
                return this._actionRunner;
            },
            set: function (actionRunner) {
                this._actionRunner = actionRunner;
            },
            enumerable: true,
            configurable: true
        });
        BaseActionItem.prototype.getAction = function () {
            return this._action;
        };
        BaseActionItem.prototype.isEnabled = function () {
            return this._action.enabled;
        };
        BaseActionItem.prototype.setActionContext = function (newContext) {
            this._context = newContext;
        };
        BaseActionItem.prototype.render = function (container) {
            var _this = this;
            this.builder = builder_1.$(container);
            this.gesture = new touch_1.Gesture(container);
            this.builder.on(DOM.EventType.CLICK, function (event) { return _this.onClick(event); });
            this.builder.on(touch_1.EventType.Tap, function (e) { return _this.onClick(e); });
            if (platform.isMacintosh) {
                this.builder.on(DOM.EventType.CONTEXT_MENU, function (event) { return _this.onClick(event); }); // https://github.com/Microsoft/vscode/issues/1011
            }
            this.builder.on(DOM.EventType.MOUSE_DOWN, function (e) {
                DOM.EventHelper.stop(e);
                if (e.button === 0 && _this._action.enabled) {
                    _this.builder.addClass('active');
                }
            });
            this.builder.on([DOM.EventType.MOUSE_UP, DOM.EventType.MOUSE_OUT], function (e) {
                DOM.EventHelper.stop(e);
                if (e.button === 0 && _this._action.enabled) {
                    _this.builder.removeClass('active');
                }
            });
        };
        BaseActionItem.prototype.onClick = function (event) {
            DOM.EventHelper.stop(event, true);
            var context;
            if (types.isUndefinedOrNull(this._context)) {
                context = event;
            }
            else {
                context = this._context;
                context.event = event;
            }
            this._actionRunner.run(this._action, context);
        };
        BaseActionItem.prototype.focus = function () {
            if (this.builder) {
                this.builder.domFocus();
            }
        };
        BaseActionItem.prototype.blur = function () {
            if (this.builder) {
                this.builder.domBlur();
            }
        };
        BaseActionItem.prototype._updateEnabled = function () {
            // implement in subclass
        };
        BaseActionItem.prototype._updateLabel = function () {
            // implement in subclass
        };
        BaseActionItem.prototype._updateTooltip = function () {
            // implement in subclass
        };
        BaseActionItem.prototype._updateClass = function () {
            // implement in subclass
        };
        BaseActionItem.prototype._updateChecked = function () {
            // implement in subclass
        };
        BaseActionItem.prototype._updateUnknown = function (event) {
            // can implement in subclass
        };
        BaseActionItem.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this.builder) {
                this.builder.destroy();
                this.builder = null;
            }
            if (this.gesture) {
                this.gesture.dispose();
                this.gesture = null;
            }
            this._callOnDispose = lifecycle.dispose(this._callOnDispose);
        };
        return BaseActionItem;
    }(eventEmitter_1.EventEmitter));
    exports.BaseActionItem = BaseActionItem;
    var Separator = (function (_super) {
        __extends(Separator, _super);
        function Separator(label, order) {
            _super.call(this, Separator.ID, label, label ? 'separator text' : 'separator');
            this.checked = false;
            this.enabled = false;
            this.order = order;
        }
        Separator.ID = 'vs.actions.separator';
        return Separator;
    }(actions_1.Action));
    exports.Separator = Separator;
    var ActionItem = (function (_super) {
        __extends(ActionItem, _super);
        function ActionItem(context, action, options) {
            if (options === void 0) { options = {}; }
            _super.call(this, context, action);
            this.options = options;
            this.options.icon = options.icon !== undefined ? options.icon : false;
            this.options.label = options.label !== undefined ? options.label : true;
            this.cssClass = '';
        }
        ActionItem.prototype.render = function (container) {
            _super.prototype.render.call(this, container);
            this.$e = builder_1.$('a.action-label').appendTo(this.builder);
            this.$e.attr({ role: 'button' });
            if (this.options.label && this.options.keybinding) {
                builder_1.$('span.keybinding').text(this.options.keybinding).appendTo(this.builder);
            }
            this._updateClass();
            this._updateLabel();
            this._updateTooltip();
            this._updateEnabled();
            this._updateChecked();
        };
        ActionItem.prototype.focus = function () {
            _super.prototype.focus.call(this);
            this.$e.domFocus();
        };
        ActionItem.prototype._updateLabel = function () {
            if (this.options.label) {
                this.$e.text(this.getAction().label);
            }
        };
        ActionItem.prototype._updateTooltip = function () {
            var title = null;
            if (this.getAction().tooltip) {
                title = this.getAction().tooltip;
            }
            else if (!this.options.label && this.getAction().label && this.options.icon) {
                title = this.getAction().label;
                if (this.options.keybinding) {
                    title = nls.localize(0, null, title, this.options.keybinding);
                }
            }
            if (title) {
                this.$e.attr({ title: title });
            }
        };
        ActionItem.prototype._updateClass = function () {
            if (this.cssClass) {
                this.$e.removeClass(this.cssClass);
            }
            if (this.options.icon) {
                this.cssClass = this.getAction().class;
                this.$e.addClass('icon');
                if (this.cssClass) {
                    this.$e.addClass(this.cssClass);
                }
                this._updateEnabled();
            }
            else {
                this.$e.removeClass('icon');
            }
        };
        ActionItem.prototype._updateEnabled = function () {
            if (this.getAction().enabled) {
                this.builder.removeClass('disabled');
                this.$e.removeClass('disabled');
                this.$e.attr({ tabindex: 0 });
            }
            else {
                this.builder.addClass('disabled');
                this.$e.addClass('disabled');
                DOM.removeTabIndexAndUpdateFocus(this.$e.getHTMLElement());
            }
        };
        ActionItem.prototype._updateChecked = function () {
            if (this.getAction().checked) {
                this.$e.addClass('checked');
            }
            else {
                this.$e.removeClass('checked');
            }
        };
        return ActionItem;
    }(BaseActionItem));
    exports.ActionItem = ActionItem;
    var ProgressItem = (function (_super) {
        __extends(ProgressItem, _super);
        function ProgressItem() {
            _super.apply(this, arguments);
        }
        ProgressItem.prototype.render = function (parent) {
            var container = document.createElement('div');
            builder_1.$(container).addClass('progress-item');
            var label = document.createElement('div');
            builder_1.$(label).addClass('label');
            label.textContent = this.getAction().label;
            label.title = this.getAction().label;
            _super.prototype.render.call(this, label);
            var progress = document.createElement('div');
            progress.textContent = '\u2026';
            builder_1.$(progress).addClass('tag', 'progress');
            var done = document.createElement('div');
            done.textContent = '\u2713';
            builder_1.$(done).addClass('tag', 'done');
            var error = document.createElement('div');
            error.textContent = '!';
            builder_1.$(error).addClass('tag', 'error');
            this.callOnDispose.push(this.addListener2(events_1.EventType.BEFORE_RUN, function () {
                builder_1.$(progress).addClass('active');
                builder_1.$(done).removeClass('active');
                builder_1.$(error).removeClass('active');
            }));
            this.callOnDispose.push(this.addListener2(events_1.EventType.RUN, function (result) {
                builder_1.$(progress).removeClass('active');
                if (result.error) {
                    builder_1.$(done).removeClass('active');
                    builder_1.$(error).addClass('active');
                }
                else {
                    builder_1.$(error).removeClass('active');
                    builder_1.$(done).addClass('active');
                }
            }));
            container.appendChild(label);
            container.appendChild(progress);
            container.appendChild(done);
            container.appendChild(error);
            parent.appendChild(container);
        };
        ProgressItem.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        return ProgressItem;
    }(BaseActionItem));
    exports.ProgressItem = ProgressItem;
    (function (ActionsOrientation) {
        ActionsOrientation[ActionsOrientation["HORIZONTAL"] = 1] = "HORIZONTAL";
        ActionsOrientation[ActionsOrientation["VERTICAL"] = 2] = "VERTICAL";
    })(exports.ActionsOrientation || (exports.ActionsOrientation = {}));
    var ActionsOrientation = exports.ActionsOrientation;
    var defaultOptions = {
        orientation: ActionsOrientation.HORIZONTAL,
        context: null
    };
    var ActionBar = (function (_super) {
        __extends(ActionBar, _super);
        function ActionBar(container, options) {
            var _this = this;
            if (options === void 0) { options = defaultOptions; }
            _super.call(this);
            this.options = options;
            this._context = options.context;
            this.toDispose = [];
            this._actionRunner = this.options.actionRunner;
            if (!this._actionRunner) {
                this._actionRunner = new actions_1.ActionRunner();
                this.toDispose.push(this._actionRunner);
            }
            this.toDispose.push(this.addEmitter2(this._actionRunner));
            this.items = [];
            this.focusedItem = undefined;
            this.domNode = document.createElement('div');
            this.domNode.className = 'monaco-action-bar';
            if (options.animated !== false) {
                DOM.addClass(this.domNode, 'animated');
            }
            var isVertical = this.options.orientation === ActionsOrientation.VERTICAL;
            if (isVertical) {
                this.domNode.className += ' vertical';
            }
            builder_1.$(this.domNode).on(DOM.EventType.KEY_DOWN, function (e) {
                var event = new keyboardEvent_1.StandardKeyboardEvent(e);
                var eventHandled = true;
                if (event.equals(isVertical ? keyCodes_1.CommonKeybindings.UP_ARROW : keyCodes_1.CommonKeybindings.LEFT_ARROW)) {
                    _this.focusPrevious();
                }
                else if (event.equals(isVertical ? keyCodes_1.CommonKeybindings.DOWN_ARROW : keyCodes_1.CommonKeybindings.RIGHT_ARROW)) {
                    _this.focusNext();
                }
                else if (event.equals(keyCodes_1.CommonKeybindings.ESCAPE)) {
                    _this.cancel();
                }
                else if (event.equals(keyCodes_1.CommonKeybindings.ENTER) || event.equals(keyCodes_1.CommonKeybindings.SPACE)) {
                }
                else {
                    eventHandled = false;
                }
                if (eventHandled) {
                    event.preventDefault();
                    event.stopPropagation();
                }
            });
            // Prevent native context menu on actions
            builder_1.$(this.domNode).on(DOM.EventType.CONTEXT_MENU, function (e) {
                e.preventDefault();
                e.stopPropagation();
            });
            builder_1.$(this.domNode).on(DOM.EventType.KEY_UP, function (e) {
                var event = new keyboardEvent_1.StandardKeyboardEvent(e);
                // Run action on Enter/Space
                if (event.equals(keyCodes_1.CommonKeybindings.ENTER) || event.equals(keyCodes_1.CommonKeybindings.SPACE)) {
                    _this.doTrigger(event);
                    event.preventDefault();
                    event.stopPropagation();
                }
                else if (event.equals(keyCodes_1.CommonKeybindings.TAB) || event.equals(keyCodes_1.CommonKeybindings.SHIFT_TAB)) {
                    _this.updateFocusedItem();
                }
            });
            this.focusTracker = DOM.trackFocus(this.domNode);
            this.focusTracker.addBlurListener(function () {
                if (document.activeElement === _this.domNode || !DOM.isAncestor(document.activeElement, _this.domNode)) {
                    _this.emit(DOM.EventType.BLUR, {});
                    _this.focusedItem = undefined;
                }
            });
            this.focusTracker.addFocusListener(function () { return _this.updateFocusedItem(); });
            this.actionsList = document.createElement('ul');
            this.actionsList.className = 'actions-container';
            this.actionsList.setAttribute('role', 'toolbar');
            if (this.options.ariaLabel) {
                this.actionsList.setAttribute('aria-label', this.options.ariaLabel);
            }
            this.domNode.appendChild(this.actionsList);
            container = (container instanceof builder_1.Builder) ? container.getHTMLElement() : container;
            container.appendChild(this.domNode);
        }
        ActionBar.prototype.setAriaLabel = function (label) {
            if (label) {
                this.actionsList.setAttribute('aria-label', label);
            }
            else {
                this.actionsList.removeAttribute('aria-label');
            }
        };
        ActionBar.prototype.updateFocusedItem = function () {
            for (var i = 0; i < this.actionsList.children.length; i++) {
                var elem = this.actionsList.children[i];
                if (DOM.isAncestor(document.activeElement, elem)) {
                    this.focusedItem = i;
                    break;
                }
            }
        };
        Object.defineProperty(ActionBar.prototype, "context", {
            get: function () {
                return this._context;
            },
            set: function (context) {
                this._context = context;
                this.items.forEach(function (i) { return i.setActionContext(context); });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ActionBar.prototype, "actionRunner", {
            get: function () {
                return this._actionRunner;
            },
            set: function (actionRunner) {
                if (actionRunner) {
                    this._actionRunner = actionRunner;
                    this.items.forEach(function (item) { return item.actionRunner = actionRunner; });
                }
            },
            enumerable: true,
            configurable: true
        });
        ActionBar.prototype.getContainer = function () {
            return builder_1.$(this.domNode);
        };
        ActionBar.prototype.push = function (actions, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            if (!Array.isArray(actions)) {
                actions = [actions];
            }
            var index = types.isNumber(options.index) ? options.index : null;
            actions.forEach(function (action) {
                var actionItemElement = document.createElement('li');
                actionItemElement.className = 'action-item';
                actionItemElement.setAttribute('role', 'presentation');
                var item = null;
                if (_this.options.actionItemProvider) {
                    item = _this.options.actionItemProvider(action);
                }
                if (!item) {
                    item = new ActionItem(_this.context, action, options);
                }
                item.actionRunner = _this._actionRunner;
                item.setActionContext(_this.context);
                _this.addEmitter2(item);
                item.render(actionItemElement);
                if (index === null || index < 0 || index >= _this.actionsList.children.length) {
                    _this.actionsList.appendChild(actionItemElement);
                }
                else {
                    _this.actionsList.insertBefore(actionItemElement, _this.actionsList.children[index++]);
                }
                _this.items.push(item);
            });
        };
        ActionBar.prototype.clear = function () {
            var item;
            while (item = this.items.pop()) {
                item.dispose();
            }
            builder_1.$(this.actionsList).empty();
        };
        ActionBar.prototype.length = function () {
            return this.items.length;
        };
        ActionBar.prototype.isEmpty = function () {
            return this.items.length === 0;
        };
        ActionBar.prototype.onContentsChange = function () {
            this.emit(events_1.EventType.CONTENTS_CHANGED);
        };
        ActionBar.prototype.focus = function (selectFirst) {
            if (selectFirst && typeof this.focusedItem === 'undefined') {
                this.focusedItem = 0;
            }
            this.updateFocus();
        };
        ActionBar.prototype.focusNext = function () {
            if (typeof this.focusedItem === 'undefined') {
                this.focusedItem = this.items.length - 1;
            }
            var startIndex = this.focusedItem;
            var item;
            do {
                this.focusedItem = (this.focusedItem + 1) % this.items.length;
                item = this.items[this.focusedItem];
            } while (this.focusedItem !== startIndex && !item.isEnabled());
            if (this.focusedItem === startIndex && !item.isEnabled()) {
                this.focusedItem = undefined;
            }
            this.updateFocus();
        };
        ActionBar.prototype.focusPrevious = function () {
            if (typeof this.focusedItem === 'undefined') {
                this.focusedItem = 0;
            }
            var startIndex = this.focusedItem;
            var item;
            do {
                this.focusedItem = this.focusedItem - 1;
                if (this.focusedItem < 0) {
                    this.focusedItem = this.items.length - 1;
                }
                item = this.items[this.focusedItem];
            } while (this.focusedItem !== startIndex && !item.isEnabled());
            if (this.focusedItem === startIndex && !item.isEnabled()) {
                this.focusedItem = undefined;
            }
            this.updateFocus();
        };
        ActionBar.prototype.updateFocus = function () {
            if (typeof this.focusedItem === 'undefined') {
                this.domNode.focus();
                return;
            }
            for (var i = 0; i < this.items.length; i++) {
                var item = this.items[i];
                var actionItem = item;
                if (i === this.focusedItem) {
                    if (types.isFunction(actionItem.focus)) {
                        actionItem.focus();
                    }
                }
                else {
                    if (types.isFunction(actionItem.blur)) {
                        actionItem.blur();
                    }
                }
            }
        };
        ActionBar.prototype.doTrigger = function (event) {
            if (typeof this.focusedItem === 'undefined') {
                return; //nothing to focus
            }
            // trigger action
            var actionItem = this.items[this.focusedItem];
            var context = (actionItem._context === null || actionItem._context === undefined) ? event : actionItem._context;
            this.run(actionItem._action, context).done();
        };
        ActionBar.prototype.cancel = function () {
            if (document.activeElement instanceof HTMLElement) {
                document.activeElement.blur(); // remove focus from focussed action
            }
            this.emit(events_1.EventType.CANCEL);
        };
        ActionBar.prototype.run = function (action, context) {
            return this._actionRunner.run(action, context);
        };
        ActionBar.prototype.dispose = function () {
            if (this.items !== null) {
                this.clear();
            }
            this.items = null;
            if (this.focusTracker) {
                this.focusTracker.dispose();
                this.focusTracker = null;
            }
            this.toDispose = lifecycle.dispose(this.toDispose);
            this.getContainer().destroy();
            _super.prototype.dispose.call(this);
        };
        return ActionBar;
    }(eventEmitter_1.EventEmitter));
    exports.ActionBar = ActionBar;
    var SelectActionItem = (function (_super) {
        __extends(SelectActionItem, _super);
        function SelectActionItem(ctx, action, options, selected) {
            _super.call(this, ctx, action);
            this.select = document.createElement('select');
            this.select.className = "action-bar-select " + (platform.isWindows ? 'windows' : '');
            this.options = options;
            this.selected = selected;
            this.toDispose = [];
            this.registerListeners();
        }
        SelectActionItem.prototype.setOptions = function (options, selected) {
            this.options = options;
            this.selected = selected;
            this.doSetOptions();
        };
        SelectActionItem.prototype.registerListeners = function () {
            var _this = this;
            this.toDispose.push(DOM.addStandardDisposableListener(this.select, 'change', function (e) {
                _this.actionRunner.run(_this._action, _this.getActionContext(e.target.value)).done();
            }));
        };
        SelectActionItem.prototype.getActionContext = function (option) {
            return option;
        };
        SelectActionItem.prototype.focus = function () {
            if (this.select) {
                this.select.focus();
            }
        };
        SelectActionItem.prototype.blur = function () {
            if (this.select) {
                this.select.blur();
            }
        };
        SelectActionItem.prototype.render = function (container) {
            DOM.addClass(container, 'select-container');
            container.appendChild(this.select);
            this.doSetOptions();
        };
        SelectActionItem.prototype.doSetOptions = function () {
            var _this = this;
            this.select.options.length = 0;
            this.options.forEach(function (option) {
                _this.select.add(_this.createOption(option));
            });
            if (this.selected >= 0) {
                this.select.selectedIndex = this.selected;
            }
        };
        SelectActionItem.prototype.createOption = function (value) {
            var option = document.createElement('option');
            option.value = value;
            option.text = value;
            return option;
        };
        SelectActionItem.prototype.dispose = function () {
            this.toDispose = lifecycle.dispose(this.toDispose);
            _super.prototype.dispose.call(this);
        };
        return SelectActionItem;
    }(BaseActionItem));
    exports.SelectActionItem = SelectActionItem;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[81], __M([0,1,183,18,35,380]), function (require, exports, nls, platform_1, builder_1) {
    'use strict';
    var ariaContainer;
    var alertContainer;
    var statusContainer;
    function setARIAContainer(parent) {
        ariaContainer = builder_1.$('.aria-container').appendTo(parent);
        alertContainer = builder_1.$('.alert').appendTo(ariaContainer).attr({ 'role': 'alert', 'aria-atomic': 'true' });
        statusContainer = builder_1.$('.status').appendTo(ariaContainer).attr({ 'role': 'status', 'aria-atomic': 'true' });
    }
    exports.setARIAContainer = setARIAContainer;
    /**
     * Given the provided message, will make sure that it is read as alert to screen readers.
     */
    function alert(msg) {
        insertMessage(alertContainer, msg);
    }
    exports.alert = alert;
    /**
     * Given the provided message, will make sure that it is read as status to screen readers.
     */
    function status(msg) {
        if (platform_1.isMacintosh) {
            alert(msg); // VoiceOver does not seem to support status role
        }
        else {
            insertMessage(statusContainer, msg);
        }
    }
    exports.status = status;
    function insertMessage(target, msg) {
        if (!ariaContainer) {
            // console.warn('ARIA support needs a container. Call setARIAContainer() first.');
            return;
        }
        if (target.getHTMLElement().textContent === msg) {
            msg = nls.localize(0, null, msg);
        }
        builder_1.$(target).empty();
        builder_1.$(target).text(msg);
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[145], __M([0,1,35,11,3,23,382]), function (require, exports, builder_1, DOM, lifecycle_1, eventEmitter_1) {
    'use strict';
    (function (AnchorAlignment) {
        AnchorAlignment[AnchorAlignment["LEFT"] = 0] = "LEFT";
        AnchorAlignment[AnchorAlignment["RIGHT"] = 1] = "RIGHT";
    })(exports.AnchorAlignment || (exports.AnchorAlignment = {}));
    var AnchorAlignment = exports.AnchorAlignment;
    (function (AnchorPosition) {
        AnchorPosition[AnchorPosition["BELOW"] = 0] = "BELOW";
        AnchorPosition[AnchorPosition["ABOVE"] = 1] = "ABOVE";
    })(exports.AnchorPosition || (exports.AnchorPosition = {}));
    var AnchorPosition = exports.AnchorPosition;
    function layout(view, around, viewport, anchorPosition, anchorAlignment) {
        var chooseBiased = function (a, aIsGood, b, bIsGood) {
            if (aIsGood) {
                return a;
            }
            if (bIsGood) {
                return b;
            }
            return a;
        };
        var chooseOne = function (a, aIsGood, b, bIsGood, aIsPreferred) {
            if (aIsPreferred) {
                return chooseBiased(a, aIsGood, b, bIsGood);
            }
            else {
                return chooseBiased(b, bIsGood, a, aIsGood);
            }
        };
        var top = (function () {
            // Compute both options (putting the segment above and below)
            var posAbove = around.top - view.height;
            var posBelow = around.top + around.height;
            // Check for both options if they are good
            var aboveIsGood = (posAbove >= viewport.top && posAbove + view.height <= viewport.top + viewport.height);
            var belowIsGood = (posBelow >= viewport.top && posBelow + view.height <= viewport.top + viewport.height);
            return chooseOne(posAbove, aboveIsGood, posBelow, belowIsGood, anchorPosition === AnchorPosition.ABOVE);
        })();
        var left = (function () {
            // Compute both options (aligning left and right)
            var posLeft = around.left;
            var posRight = around.left + around.width - view.width;
            // Check for both options if they are good
            var leftIsGood = (posLeft >= viewport.left && posLeft + view.width <= viewport.left + viewport.width);
            var rightIsGood = (posRight >= viewport.left && posRight + view.width <= viewport.left + viewport.width);
            return chooseOne(posLeft, leftIsGood, posRight, rightIsGood, anchorAlignment === AnchorAlignment.LEFT);
        })();
        return { top: top, left: left };
    }
    var ContextView = (function (_super) {
        __extends(ContextView, _super);
        function ContextView(container) {
            var _this = this;
            _super.call(this);
            this.$view = builder_1.$('.context-view').hide();
            this.setContainer(container);
            this.toDispose = [{
                    dispose: function () {
                        _this.setContainer(null);
                    }
                }];
            this.toDisposeOnClean = null;
        }
        ContextView.prototype.setContainer = function (container) {
            var _this = this;
            if (this.$container) {
                this.$container.off(ContextView.BUBBLE_UP_EVENTS);
                this.$container.off(ContextView.BUBBLE_DOWN_EVENTS, true);
                this.$container = null;
            }
            if (container) {
                this.$container = builder_1.$(container);
                this.$view.appendTo(this.$container);
                this.$container.on(ContextView.BUBBLE_UP_EVENTS, function (e) {
                    _this.onDOMEvent(e, document.activeElement, false);
                });
                this.$container.on(ContextView.BUBBLE_DOWN_EVENTS, function (e) {
                    _this.onDOMEvent(e, document.activeElement, true);
                }, null, true);
            }
        };
        ContextView.prototype.show = function (delegate) {
            if (this.isVisible()) {
                this.hide();
            }
            // Show static box
            this.$view.setClass('context-view').empty().style({ top: '0px', left: '0px' }).show();
            // Render content
            this.toDisposeOnClean = delegate.render(this.$view.getHTMLElement());
            // Set active delegate
            this.delegate = delegate;
            // Layout
            this.doLayout();
        };
        ContextView.prototype.layout = function () {
            if (!this.isVisible()) {
                return;
            }
            if (this.delegate.canRelayout === false) {
                this.hide();
                return;
            }
            if (this.delegate.layout) {
                this.delegate.layout();
            }
            this.doLayout();
        };
        ContextView.prototype.doLayout = function () {
            // Get anchor
            var anchor = this.delegate.getAnchor();
            // Compute around
            var around;
            // Get the element's position and size (to anchor the view)
            if (DOM.isHTMLElement(anchor)) {
                var elementPosition = DOM.getDomNodePagePosition(anchor);
                around = {
                    top: elementPosition.top,
                    left: elementPosition.left,
                    width: elementPosition.width,
                    height: elementPosition.height
                };
            }
            else {
                var realAnchor = anchor;
                around = {
                    top: realAnchor.y,
                    left: realAnchor.x,
                    width: realAnchor.width || 0,
                    height: realAnchor.height || 0
                };
            }
            var viewport = {
                top: DOM.StandardWindow.scrollY,
                left: DOM.StandardWindow.scrollX,
                height: window.innerHeight,
                width: window.innerWidth
            };
            // Get the view's size
            var viewSize = this.$view.getTotalSize();
            var view = { width: viewSize.width, height: viewSize.height };
            var anchorPosition = this.delegate.anchorPosition || AnchorPosition.BELOW;
            var anchorAlignment = this.delegate.anchorAlignment || AnchorAlignment.LEFT;
            var result = layout(view, around, viewport, anchorPosition, anchorAlignment);
            var containerPosition = DOM.getDomNodePagePosition(this.$container.getHTMLElement());
            result.top -= containerPosition.top;
            result.left -= containerPosition.left;
            this.$view.removeClass('top', 'bottom', 'left', 'right');
            this.$view.addClass(anchorPosition === AnchorPosition.BELOW ? 'bottom' : 'top');
            this.$view.addClass(anchorAlignment === AnchorAlignment.LEFT ? 'left' : 'right');
            this.$view.style({ top: result.top + 'px', left: result.left + 'px', width: 'initial' });
        };
        ContextView.prototype.hide = function (data) {
            if (this.delegate && this.delegate.onHide) {
                this.delegate.onHide(data);
            }
            this.delegate = null;
            if (this.toDisposeOnClean) {
                this.toDisposeOnClean.dispose();
                this.toDisposeOnClean = null;
            }
            this.$view.hide();
        };
        ContextView.prototype.isVisible = function () {
            return !!this.delegate;
        };
        ContextView.prototype.onDOMEvent = function (e, element, onCapture) {
            if (this.delegate) {
                if (this.delegate.onDOMEvent) {
                    this.delegate.onDOMEvent(e, document.activeElement);
                }
                else if (onCapture && !DOM.isAncestor(e.target, this.$container.getHTMLElement())) {
                    this.hide();
                }
            }
        };
        ContextView.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this.hide();
            this.toDispose = lifecycle_1.dispose(this.toDispose);
        };
        ContextView.BUBBLE_UP_EVENTS = ['click', 'keydown', 'focus', 'blur'];
        ContextView.BUBBLE_DOWN_EVENTS = ['click'];
        return ContextView;
    }(eventEmitter_1.EventEmitter));
    exports.ContextView = ContextView;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[248], __M([0,1,35,10,383]), function (require, exports, builder_1, strings) {
    'use strict';
    var CountBadge = (function () {
        function CountBadge(container, count, titleFormat) {
            this.$el = builder_1.$('.monaco-count-badge').appendTo(container);
            this.titleFormat = titleFormat || '';
            this.setCount(count || 0);
        }
        CountBadge.prototype.setCount = function (count) {
            this.count = count;
            this.render();
        };
        CountBadge.prototype.setTitleFormat = function (titleFormat) {
            this.titleFormat = titleFormat;
            this.render();
        };
        CountBadge.prototype.render = function () {
            this.$el.text('' + this.count);
            this.$el.title(strings.format(this.titleFormat, this.count));
        };
        CountBadge.prototype.dispose = function () {
            if (this.$el) {
                this.$el.destroy();
                this.$el = null;
            }
        };
        return CountBadge;
    }());
    exports.CountBadge = CountBadge;
});

define(__m[122], __M([0,1,10,11,31,273]), function (require, exports, strings_1, dom, objects, octiconLabel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var HighlightedLabel = (function () {
        function HighlightedLabel(container) {
            this.domNode = document.createElement('span');
            this.domNode.className = 'monaco-highlighted-label';
            this.didEverRender = false;
            container.appendChild(this.domNode);
        }
        Object.defineProperty(HighlightedLabel.prototype, "element", {
            get: function () {
                return this.domNode;
            },
            enumerable: true,
            configurable: true
        });
        HighlightedLabel.prototype.set = function (text, highlights) {
            if (highlights === void 0) { highlights = []; }
            if (!text) {
                text = '';
            }
            if (this.didEverRender && this.text === text && objects.equals(this.highlights, highlights)) {
                return;
            }
            if (!Array.isArray(highlights)) {
                highlights = [];
            }
            this.text = text;
            this.highlights = highlights;
            this.render();
        };
        HighlightedLabel.prototype.render = function () {
            dom.clearNode(this.domNode);
            var htmlContent = [], highlight, pos = 0;
            for (var i = 0; i < this.highlights.length; i++) {
                highlight = this.highlights[i];
                if (highlight.end === highlight.start) {
                    continue;
                }
                if (pos < highlight.start) {
                    htmlContent.push('<span>');
                    htmlContent.push(octiconLabel_1.expand(strings_1.escape(this.text.substring(pos, highlight.start))));
                    htmlContent.push('</span>');
                    pos = highlight.end;
                }
                htmlContent.push('<span class="highlight">');
                htmlContent.push(octiconLabel_1.expand(strings_1.escape(this.text.substring(highlight.start, highlight.end))));
                htmlContent.push('</span>');
                pos = highlight.end;
            }
            if (pos < this.text.length) {
                htmlContent.push('<span>');
                htmlContent.push(octiconLabel_1.expand(strings_1.escape(this.text.substring(pos))));
                htmlContent.push('</span>');
            }
            this.domNode.innerHTML = htmlContent.join('');
            this.didEverRender = true;
        };
        HighlightedLabel.prototype.dispose = function () {
            this.text = null;
            this.highlights = null;
        };
        return HighlightedLabel;
    }());
    exports.HighlightedLabel = HighlightedLabel;
});

define(__m[250], __M([0,1,11,38,26,122,142,387]), function (require, exports, dom, paths, types, highlightedLabel_1, labels_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var FileLabel = (function () {
        function FileLabel(container, arg2, arg3) {
            this.labelHighlights = [];
            this.domNode = dom.append(container, dom.emmet('.monaco-file-label'));
            this.labelNode = new highlightedLabel_1.HighlightedLabel(dom.append(this.domNode, dom.emmet('span.file-name')));
            this.directoryNode = dom.append(this.domNode, dom.emmet('span.file-path'));
            if (arg3) {
                this.basepath = getPath(arg3);
            }
            if (arg2) {
                this.setValue(arg2);
            }
        }
        FileLabel.prototype.getHTMLElement = function () {
            return this.domNode;
        };
        FileLabel.prototype.setValue = function (arg1, labelHighlights) {
            var newPath = getPath(arg1);
            this.path = newPath;
            this.labelHighlights = labelHighlights;
            this.render();
        };
        FileLabel.prototype.render = function () {
            this.domNode.title = this.path;
            this.labelNode.set(paths.basename(this.path), this.labelHighlights);
            var parent = paths.dirname(this.path);
            this.directoryNode.textContent = parent && parent !== '.' ? labels_1.getPathLabel(parent, this.basepath) : '';
        };
        return FileLabel;
    }());
    exports.FileLabel = FileLabel;
    function getPath(arg1) {
        if (!arg1) {
            return null;
        }
        if (typeof arg1 === 'string') {
            return arg1;
        }
        if (types.isFunction(arg1.getWorkspace)) {
            var ws = arg1.getWorkspace();
            return ws ? ws.resource.fsPath : void 0;
        }
        return arg1.fsPath;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[251], __M([0,1,35,396]), function (require, exports, builder_1) {
    'use strict';
    var LeftRightWidget = (function () {
        function LeftRightWidget(container, renderLeftFn, renderRightFn) {
            this.$el = builder_1.$('.monaco-left-right-widget').appendTo(container);
            this.toDispose = [
                renderRightFn(builder_1.$('.right').appendTo(this.$el).getHTMLElement()),
                renderLeftFn(builder_1.$('span.left').appendTo(this.$el).getHTMLElement())
            ].filter(function (x) { return !!x; });
        }
        LeftRightWidget.prototype.dispose = function () {
            if (this.$el) {
                this.$el.destroy();
                this.$el = null;
            }
        };
        return LeftRightWidget;
    }());
    exports.LeftRightWidget = LeftRightWidget;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[252], __M([0,1,11]), function (require, exports, dom_1) {
    "use strict";
    function getLastScrollTime(element) {
        var value = element.getAttribute('last-scroll-time');
        return value ? parseInt(value, 10) : 0;
    }
    function removeFromParent(element) {
        try {
            element.parentElement.removeChild(element);
        }
        catch (e) {
        }
    }
    var RowCache = (function () {
        function RowCache(renderers) {
            this.renderers = renderers;
            this.cache = Object.create(null);
            this.scrollingRow = null;
        }
        /**
         * Returns a row either by creating a new one or reusing
         * a previously released row which shares the same templateId.
         */
        RowCache.prototype.alloc = function (templateId) {
            var result = this.getTemplateCache(templateId).pop();
            if (!result) {
                var domNode = dom_1.emmet('.monaco-list-row');
                var renderer = this.renderers[templateId];
                var templateData = renderer.renderTemplate(domNode);
                result = { domNode: domNode, templateId: templateId, templateData: templateData };
            }
            return result;
        };
        /**
         * Releases the row for eventual reuse. The row's domNode
         * will eventually be removed from its parent, given that
         * it is not the currently scrolling row (for OS X ballistic
         * scrolling).
         */
        RowCache.prototype.release = function (row) {
            var lastScrollTime = getLastScrollTime(row.domNode);
            if (!lastScrollTime) {
                removeFromParent(row.domNode);
                this.getTemplateCache(row.templateId).push(row);
                return;
            }
            if (this.scrollingRow) {
                var lastKnownScrollTime = getLastScrollTime(this.scrollingRow.domNode);
                if (lastKnownScrollTime > lastScrollTime) {
                    removeFromParent(row.domNode);
                    this.getTemplateCache(row.templateId).push(row);
                    return;
                }
                if (this.scrollingRow.domNode.parentElement) {
                    removeFromParent(this.scrollingRow.domNode);
                    dom_1.removeClass(this.scrollingRow.domNode, 'scrolling');
                    this.getTemplateCache(this.scrollingRow.templateId).push(this.scrollingRow);
                }
            }
            this.scrollingRow = row;
            dom_1.addClass(this.scrollingRow.domNode, 'scrolling');
        };
        RowCache.prototype.getTemplateCache = function (templateId) {
            return this.cache[templateId] || (this.cache[templateId] = []);
        };
        RowCache.prototype.garbageCollect = function () {
            var _this = this;
            if (this.cache) {
                Object.keys(this.cache).forEach(function (templateId) {
                    _this.cache[templateId].forEach(function (cachedRow) {
                        var renderer = _this.renderers[templateId];
                        renderer.disposeTemplate(cachedRow.templateData);
                        cachedRow.domNode = null;
                        cachedRow.templateData = null;
                    });
                    delete _this.cache[templateId];
                });
            }
            if (this.scrollingRow) {
                var renderer = this.renderers[this.scrollingRow.templateId];
                renderer.disposeTemplate(this.scrollingRow.templateData);
                this.scrollingRow = null;
            }
        };
        RowCache.prototype.dispose = function () {
            this.garbageCollect();
            this.cache = null;
            this.renderers = null;
        };
        return RowCache;
    }());
    exports.RowCache = RowCache;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[253], __M([0,1,35,58,23,413]), function (require, exports, builder_1, actionbar_1, eventEmitter_1) {
    'use strict';
    var Menu = (function (_super) {
        __extends(Menu, _super);
        function Menu(container, actions, options) {
            if (options === void 0) { options = {}; }
            _super.call(this);
            builder_1.$(container).addClass('monaco-menu-container');
            var $menu = builder_1.$('.monaco-menu').appendTo(container);
            this.actionBar = new actionbar_1.ActionBar($menu, {
                orientation: actionbar_1.ActionsOrientation.VERTICAL,
                actionItemProvider: options.actionItemProvider,
                context: options.context,
                actionRunner: options.actionRunner
            });
            this.listener = this.addEmitter2(this.actionBar);
            this.actionBar.push(actions, { icon: true, label: true });
        }
        Menu.prototype.focus = function () {
            this.actionBar.focus();
        };
        Menu.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this.actionBar) {
                this.actionBar.dispose();
                this.actionBar = null;
            }
            if (this.listener) {
                this.listener.dispose();
                this.listener = null;
            }
        };
        return Menu;
    }(eventEmitter_1.EventEmitter));
    exports.Menu = Menu;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[254], __M([0,1,2,47,28,35,11,130,3,136]), function (require, exports, winjs_base_1, assert, browser, builder_1, DOM, uuid, lifecycle_1) {
    'use strict';
    var css_done = 'done';
    var css_active = 'active';
    var css_infinite = 'infinite';
    var css_discrete = 'discrete';
    var css_progress_container = 'progress-container';
    var css_progress_bit = 'progress-bit';
    /**
     * A progress bar with support for infinite or discrete progress.
     */
    var ProgressBar = (function () {
        function ProgressBar(builder) {
            this.toUnbind = [];
            this.workedVal = 0;
            this.create(builder);
        }
        ProgressBar.prototype.create = function (parent) {
            var _this = this;
            parent.div({ 'class': css_progress_container }, function (builder) {
                _this.element = builder.clone();
                builder.div({ 'class': css_progress_bit }).on([DOM.EventType.ANIMATION_START, DOM.EventType.ANIMATION_END, DOM.EventType.ANIMATION_ITERATION], function (e) {
                    switch (e.type) {
                        case DOM.EventType.ANIMATION_START:
                        case DOM.EventType.ANIMATION_END:
                            _this.animationRunning = e.type === DOM.EventType.ANIMATION_START;
                            break;
                        case DOM.EventType.ANIMATION_ITERATION:
                            if (_this.animationStopToken) {
                                _this.animationStopToken(null);
                            }
                            break;
                    }
                }, _this.toUnbind);
                _this.bit = builder.getHTMLElement();
            });
        };
        ProgressBar.prototype.off = function () {
            this.bit.style.width = 'inherit';
            this.bit.style.opacity = '1';
            this.element.removeClass(css_active);
            this.element.removeClass(css_infinite);
            this.element.removeClass(css_discrete);
            this.workedVal = 0;
            this.totalWork = undefined;
        };
        /**
         * Indicates to the progress bar that all work is done.
         */
        ProgressBar.prototype.done = function () {
            return this.doDone(true);
        };
        /**
         * Stops the progressbar from showing any progress instantly without fading out.
         */
        ProgressBar.prototype.stop = function () {
            return this.doDone(false);
        };
        ProgressBar.prototype.doDone = function (delayed) {
            var _this = this;
            this.element.addClass(css_done);
            // let it grow to 100% width and hide afterwards
            if (!this.element.hasClass(css_infinite)) {
                this.bit.style.width = 'inherit';
                if (delayed) {
                    winjs_base_1.TPromise.timeout(200).then(function () { return _this.off(); });
                }
                else {
                    this.off();
                }
            }
            else {
                this.bit.style.opacity = '0';
                if (delayed) {
                    winjs_base_1.TPromise.timeout(200).then(function () { return _this.off(); });
                }
                else {
                    this.off();
                }
            }
            return this;
        };
        /**
         * Use this mode to indicate progress that has no total number of work units.
         */
        ProgressBar.prototype.infinite = function () {
            this.bit.style.width = '2%';
            this.bit.style.opacity = '1';
            this.element.removeClass(css_discrete);
            this.element.removeClass(css_done);
            this.element.addClass(css_active);
            this.element.addClass(css_infinite);
            if (!browser.hasCSSAnimationSupport()) {
                // Use a generated token to avoid race conditions from reentrant calls to this function
                var currentProgressToken = uuid.v4().asHex();
                this.currentProgressToken = currentProgressToken;
                this.manualInfinite(currentProgressToken);
            }
            return this;
        };
        ProgressBar.prototype.manualInfinite = function (currentProgressToken) {
            var _this = this;
            this.bit.style.width = '5%';
            this.bit.style.display = 'inherit';
            var counter = 0;
            var animationFn = function () {
                winjs_base_1.TPromise.timeout(50).then(function () {
                    // Return if another manualInfinite() call was made
                    if (currentProgressToken !== _this.currentProgressToken) {
                        return;
                    }
                    else if (_this.element.hasClass(css_done)) {
                        _this.bit.style.display = 'none';
                        _this.bit.style.left = '0';
                    }
                    else if (_this.element.isHidden()) {
                        animationFn();
                    }
                    else {
                        counter = (counter + 1) % 95;
                        _this.bit.style.left = counter + '%';
                        animationFn();
                    }
                });
            };
            // Start Animation
            animationFn();
        };
        /**
         * Tells the progress bar the total number of work. Use in combination with workedVal() to let
         * the progress bar show the actual progress based on the work that is done.
         */
        ProgressBar.prototype.total = function (value) {
            this.workedVal = 0;
            this.totalWork = value;
            return this;
        };
        /**
         * Finds out if this progress bar is configured with total work
         */
        ProgressBar.prototype.hasTotal = function () {
            return !isNaN(this.totalWork);
        };
        /**
         * Tells the progress bar that an amount of work has been completed.
         */
        ProgressBar.prototype.worked = function (value) {
            assert.ok(!isNaN(this.totalWork), 'Total work not set');
            value = Number(value);
            assert.ok(!isNaN(value), 'Value is not a number');
            value = Math.max(1, value);
            this.workedVal += value;
            this.workedVal = Math.min(this.totalWork, this.workedVal);
            if (this.element.hasClass(css_infinite)) {
                this.element.removeClass(css_infinite);
            }
            if (this.element.hasClass(css_done)) {
                this.element.removeClass(css_done);
            }
            if (!this.element.hasClass(css_active)) {
                this.element.addClass(css_active);
            }
            if (!this.element.hasClass(css_discrete)) {
                this.element.addClass(css_discrete);
            }
            this.bit.style.width = 100 * (this.workedVal / this.totalWork) + '%';
            return this;
        };
        /**
         * Returns the builder this progress bar is building in.
         */
        ProgressBar.prototype.getContainer = function () {
            return builder_1.$(this.element);
        };
        ProgressBar.prototype.dispose = function () {
            this.toUnbind = lifecycle_1.dispose(this.toUnbind);
        };
        return ProgressBar;
    }());
    exports.ProgressBar = ProgressBar;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[123], __M([0,1,3,35,28,18,26,11,69,23,39,422]), function (require, exports, lifecycle_1, builder_1, browser_1, platform_1, types, DOM, touch_1, eventEmitter_1, mouseEvent_1) {
    'use strict';
    (function (Orientation) {
        Orientation[Orientation["VERTICAL"] = 0] = "VERTICAL";
        Orientation[Orientation["HORIZONTAL"] = 1] = "HORIZONTAL";
    })(exports.Orientation || (exports.Orientation = {}));
    var Orientation = exports.Orientation;
    var Sash = (function (_super) {
        __extends(Sash, _super);
        function Sash(container, layoutProvider, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            _super.call(this);
            this.$e = builder_1.$('.monaco-sash').appendTo(container);
            if (platform_1.isMacintosh) {
                this.$e.addClass('mac');
            }
            this.gesture = new touch_1.Gesture(this.$e.getHTMLElement());
            this.$e.on(DOM.EventType.MOUSE_DOWN, function (e) { _this.onMouseDown(e); });
            this.$e.on(DOM.EventType.DBLCLICK, function (e) { _this.emit('reset', e); });
            this.$e.on(touch_1.EventType.Start, function (e) { _this.onTouchStart(e); });
            this.orientation = options.orientation || Orientation.VERTICAL;
            this.$e.addClass(this.getOrientation());
            this.size = options.baseSize || 5;
            if (browser_1.isIPad) {
                this.size *= 4; // see also http://ux.stackexchange.com/questions/39023/what-is-the-optimum-button-size-of-touch-screen-applications
                this.$e.addClass('touch');
            }
            if (this.orientation === Orientation.HORIZONTAL) {
                this.$e.size(null, this.size);
            }
            else {
                this.$e.size(this.size);
            }
            this.isDisabled = false;
            this.hidden = false;
            this.layoutProvider = layoutProvider;
        }
        Sash.prototype.getHTMLElement = function () {
            return this.$e.getHTMLElement();
        };
        Sash.prototype.getOrientation = function () {
            return this.orientation === Orientation.HORIZONTAL ? 'horizontal' : 'vertical';
        };
        Sash.prototype.onMouseDown = function (e) {
            var _this = this;
            DOM.EventHelper.stop(e, false);
            if (this.isDisabled) {
                return;
            }
            builder_1.$(DOM.getElementsByTagName('iframe')).style('pointer-events', 'none'); // disable mouse events on iframes as long as we drag the sash
            var mouseDownEvent = new mouseEvent_1.StandardMouseEvent(e);
            var startX = mouseDownEvent.posx;
            var startY = mouseDownEvent.posy;
            var startEvent = {
                startX: startX,
                currentX: startX,
                startY: startY,
                currentY: startY
            };
            this.$e.addClass('active');
            this.emit('start', startEvent);
            var $window = builder_1.$(window);
            var containerCSSClass = this.getOrientation() + "-cursor-container" + (platform_1.isMacintosh ? '-mac' : '');
            var lastCurrentX = startX;
            var lastCurrentY = startY;
            $window.on('mousemove', function (e) {
                DOM.EventHelper.stop(e, false);
                var mouseMoveEvent = new mouseEvent_1.StandardMouseEvent(e);
                var event = {
                    startX: startX,
                    currentX: mouseMoveEvent.posx,
                    startY: startY,
                    currentY: mouseMoveEvent.posy
                };
                lastCurrentX = mouseMoveEvent.posx;
                lastCurrentY = mouseMoveEvent.posy;
                _this.emit('change', event);
            }).once('mouseup', function (e) {
                DOM.EventHelper.stop(e, false);
                _this.$e.removeClass('active');
                _this.emit('end');
                $window.off('mousemove');
                document.body.classList.remove(containerCSSClass);
                builder_1.$(DOM.getElementsByTagName('iframe')).style('pointer-events', 'auto');
            });
            document.body.classList.add(containerCSSClass);
        };
        Sash.prototype.onTouchStart = function (event) {
            var _this = this;
            DOM.EventHelper.stop(event);
            var listeners = [];
            var startX = event.pageX;
            var startY = event.pageY;
            this.emit('start', {
                startX: startX,
                currentX: startX,
                startY: startY,
                currentY: startY
            });
            var lastCurrentX = startX;
            var lastCurrentY = startY;
            listeners.push(DOM.addDisposableListener(this.$e.getHTMLElement(), touch_1.EventType.Change, function (event) {
                if (types.isNumber(event.pageX) && types.isNumber(event.pageY)) {
                    _this.emit('change', {
                        startX: startX,
                        currentX: event.pageX,
                        startY: startY,
                        currentY: event.pageY
                    });
                    lastCurrentX = event.pageX;
                    lastCurrentY = event.pageY;
                }
            }));
            listeners.push(DOM.addDisposableListener(this.$e.getHTMLElement(), touch_1.EventType.End, function (event) {
                _this.emit('end');
                lifecycle_1.dispose(listeners);
            }));
        };
        Sash.prototype.layout = function () {
            var style;
            if (this.orientation === Orientation.VERTICAL) {
                var verticalProvider = this.layoutProvider;
                style = { left: verticalProvider.getVerticalSashLeft(this) - (this.size / 2) + 'px' };
                if (verticalProvider.getVerticalSashTop) {
                    style.top = verticalProvider.getVerticalSashTop(this) + 'px';
                }
                if (verticalProvider.getVerticalSashHeight) {
                    style.height = verticalProvider.getVerticalSashHeight(this) + 'px';
                }
            }
            else {
                var horizontalProvider = this.layoutProvider;
                style = { top: horizontalProvider.getHorizontalSashTop(this) - (this.size / 2) + 'px' };
                if (horizontalProvider.getHorizontalSashLeft) {
                    style.left = horizontalProvider.getHorizontalSashLeft(this) + 'px';
                }
                if (horizontalProvider.getHorizontalSashWidth) {
                    style.width = horizontalProvider.getHorizontalSashWidth(this) + 'px';
                }
            }
            this.$e.style(style);
        };
        Sash.prototype.show = function () {
            this.hidden = false;
            this.$e.show();
        };
        Sash.prototype.hide = function () {
            this.hidden = true;
            this.$e.hide();
        };
        Sash.prototype.isHidden = function () {
            return this.hidden;
        };
        Sash.prototype.enable = function () {
            this.$e.removeClass('disabled');
            this.isDisabled = false;
        };
        Sash.prototype.disable = function () {
            this.$e.addClass('disabled');
            this.isDisabled = true;
        };
        Sash.prototype.dispose = function () {
            if (this.$e) {
                this.$e.destroy();
                this.$e = null;
            }
            _super.prototype.dispose.call(this);
        };
        return Sash;
    }(eventEmitter_1.EventEmitter));
    exports.Sash = Sash;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[44], __M([0,1,3,39,56,11]), function (require, exports, lifecycle_1, mouseEvent_1, keyboardEvent_1, DomUtils) {
    'use strict';
    var Widget = (function (_super) {
        __extends(Widget, _super);
        function Widget() {
            _super.apply(this, arguments);
        }
        Widget.prototype.onclick = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.CLICK, function (e) { return listener(new mouseEvent_1.StandardMouseEvent(e)); }));
        };
        Widget.prototype.onmousedown = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.MOUSE_DOWN, function (e) { return listener(new mouseEvent_1.StandardMouseEvent(e)); }));
        };
        Widget.prototype.onmouseover = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.MOUSE_OVER, function (e) { return listener(new mouseEvent_1.StandardMouseEvent(e)); }));
        };
        Widget.prototype.onnonbubblingmouseout = function (domNode, listener) {
            this._register(DomUtils.addDisposableNonBubblingMouseOutListener(domNode, function (e) { return listener(new mouseEvent_1.StandardMouseEvent(e)); }));
        };
        Widget.prototype.onkeydown = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.KEY_DOWN, function (e) { return listener(new keyboardEvent_1.StandardKeyboardEvent(e)); }));
        };
        Widget.prototype.onkeyup = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.KEY_UP, function (e) { return listener(new keyboardEvent_1.StandardKeyboardEvent(e)); }));
        };
        Widget.prototype.oninput = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.INPUT, listener));
        };
        Widget.prototype.onblur = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.BLUR, listener));
        };
        Widget.prototype.onfocus = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.FOCUS, listener));
        };
        Widget.prototype.onchange = function (domNode, listener) {
            this._register(DomUtils.addDisposableListener(domNode, DomUtils.EventType.CHANGE, listener));
        };
        return Widget;
    }(lifecycle_1.Disposable));
    exports.Widget = Widget;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[257], __M([0,1,11,12,44,381]), function (require, exports, DOM, keyCodes_1, widget_1) {
    'use strict';
    var Checkbox = (function (_super) {
        __extends(Checkbox, _super);
        function Checkbox(opts) {
            var _this = this;
            _super.call(this);
            this._opts = opts;
            this._checked = this._opts.isChecked;
            this.domNode = document.createElement('div');
            this.domNode.title = this._opts.title;
            this.domNode.className = this._className();
            this.domNode.tabIndex = 0;
            this.domNode.setAttribute('role', 'checkbox');
            this.domNode.setAttribute('aria-checked', String(this._checked));
            this.domNode.setAttribute('aria-label', this._opts.title);
            this.onclick(this.domNode, function (ev) {
                _this.checked = !_this._checked;
                _this._opts.onChange(false);
                ev.preventDefault();
            });
            this.onkeydown(this.domNode, function (keyboardEvent) {
                if (keyboardEvent.keyCode === keyCodes_1.KeyCode.Space || keyboardEvent.keyCode === keyCodes_1.KeyCode.Enter) {
                    _this.checked = !_this._checked;
                    _this._opts.onChange(true);
                    keyboardEvent.preventDefault();
                    return;
                }
                if (_this._opts.onKeyDown) {
                    _this._opts.onKeyDown(keyboardEvent);
                }
            });
        }
        Checkbox.prototype.focus = function () {
            this.domNode.focus();
        };
        Object.defineProperty(Checkbox.prototype, "checked", {
            get: function () {
                return this._checked;
            },
            set: function (newIsChecked) {
                this._checked = newIsChecked;
                this.domNode.setAttribute('aria-checked', String(this._checked));
                this.domNode.className = this._className();
            },
            enumerable: true,
            configurable: true
        });
        Checkbox.prototype._className = function () {
            return 'custom-checkbox ' + this._opts.actionClassName + ' ' + (this._checked ? 'checked' : 'unchecked');
        };
        Checkbox.prototype.width = function () {
            return 2 /*marginleft*/ + 2 /*border*/ + 2 /*padding*/ + 16 /* icon width */;
        };
        Checkbox.prototype.enable = function () {
            this.domNode.tabIndex = 0;
            this.domNode.setAttribute('aria-disabled', String(false));
        };
        Checkbox.prototype.disable = function () {
            DOM.removeTabIndexAndUpdateFocus(this.domNode);
            this.domNode.setAttribute('aria-disabled', String(true));
        };
        return Checkbox;
    }(widget_1.Widget));
    exports.Checkbox = Checkbox;
});






define(__m[98], __M([0,1,185,28,11,71,81,58,145,16,44,392]), function (require, exports, nls, Bal, dom, htmlContentRenderer_1, aria, actionbar_1, contextview_1, event_1, widget_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var $ = dom.emmet;
    (function (MessageType) {
        MessageType[MessageType["INFO"] = 1] = "INFO";
        MessageType[MessageType["WARNING"] = 2] = "WARNING";
        MessageType[MessageType["ERROR"] = 3] = "ERROR";
    })(exports.MessageType || (exports.MessageType = {}));
    var MessageType = exports.MessageType;
    var InputBox = (function (_super) {
        __extends(InputBox, _super);
        function InputBox(container, contextViewProvider, options) {
            var _this = this;
            _super.call(this);
            this.state = 'idle';
            this._onDidChange = this._register(new event_1.Emitter());
            this.onDidChange = this._onDidChange.event;
            this._onDidHeightChange = this._register(new event_1.Emitter());
            this.onDidHeightChange = this._onDidHeightChange.event;
            this.contextViewProvider = contextViewProvider;
            this.options = options || Object.create(null);
            this.message = null;
            this.cachedHeight = null;
            this.placeholder = this.options.placeholder || '';
            this.ariaLabel = this.options.ariaLabel || '';
            if (this.options.validationOptions) {
                this.validation = this.options.validationOptions.validation;
                this.showValidationMessage = this.options.validationOptions.showMessage || false;
            }
            this.element = dom.append(container, $('.monaco-inputbox.idle'));
            var tagName = this.options.flexibleHeight ? 'textarea' : 'input';
            var wrapper = dom.append(this.element, $('.wrapper'));
            this.input = dom.append(wrapper, $(tagName + '.input'));
            this.input.setAttribute('autocorrect', 'off');
            this.input.setAttribute('autocapitalize', 'off');
            this.input.setAttribute('spellcheck', 'false');
            this.onfocus(this.input, function () { return dom.addClass(_this.element, 'synthetic-focus'); });
            this.onblur(this.input, function () { return dom.removeClass(_this.element, 'synthetic-focus'); });
            if (this.options.flexibleHeight) {
                this.mirror = dom.append(wrapper, $('div.mirror'));
            }
            else {
                this.input.type = this.options.type || 'text';
                this.input.setAttribute('wrap', 'off');
            }
            if (this.ariaLabel) {
                this.input.setAttribute('aria-label', this.ariaLabel);
            }
            if (this.placeholder) {
                this.input.setAttribute('placeholder', this.placeholder);
                this.input.title = this.placeholder;
            }
            this.oninput(this.input, function () { return _this.onValueChange(); });
            this.onblur(this.input, function () { return _this.onBlur(); });
            this.onfocus(this.input, function () { return _this.onFocus(); });
            // Add placeholder shim for IE because IE decides to hide the placeholder on focus (we dont want that!)
            if (this.placeholder && Bal.isIE11orEarlier) {
                this.onclick(this.input, function (e) {
                    dom.EventHelper.stop(e, true);
                    _this.input.focus();
                });
                if (Bal.isIE9) {
                    this.onkeyup(this.input, function () { return _this.onValueChange(); });
                }
            }
            setTimeout(function () { return _this.layout(); }, 0);
            // Support actions
            if (this.options.actions) {
                this.actionbar = this._register(new actionbar_1.ActionBar(this.element));
                this.actionbar.push(this.options.actions, { icon: true, label: false });
            }
        }
        InputBox.prototype.onBlur = function () {
            this._hideMessage();
        };
        InputBox.prototype.onFocus = function () {
            this._showMessage();
        };
        InputBox.prototype.setPlaceHolder = function (placeHolder) {
            if (this.input) {
                this.input.setAttribute('placeholder', placeHolder);
            }
        };
        InputBox.prototype.setAriaLabel = function (label) {
            this.ariaLabel = label;
            if (this.input) {
                if (label) {
                    this.input.setAttribute('aria-label', this.ariaLabel);
                }
                else {
                    this.input.removeAttribute('aria-label');
                }
            }
        };
        InputBox.prototype.setContextViewProvider = function (contextViewProvider) {
            this.contextViewProvider = contextViewProvider;
        };
        Object.defineProperty(InputBox.prototype, "inputElement", {
            get: function () {
                return this.input;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBox.prototype, "value", {
            get: function () {
                return this.input.value;
            },
            set: function (newValue) {
                if (this.input.value !== newValue) {
                    this.input.value = newValue;
                    this.onValueChange();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(InputBox.prototype, "height", {
            get: function () {
                return this.cachedHeight === null ? dom.getTotalHeight(this.element) : this.cachedHeight;
            },
            enumerable: true,
            configurable: true
        });
        InputBox.prototype.focus = function () {
            this.input.focus();
        };
        InputBox.prototype.blur = function () {
            this.input.blur();
        };
        InputBox.prototype.hasFocus = function () {
            return document.activeElement === this.input;
        };
        InputBox.prototype.select = function (range) {
            if (range === void 0) { range = null; }
            this.input.select();
            if (range) {
                this.input.setSelectionRange(range.start, range.end);
            }
        };
        InputBox.prototype.enable = function () {
            this.input.removeAttribute('disabled');
        };
        InputBox.prototype.disable = function () {
            this.input.disabled = true;
            this._hideMessage();
        };
        InputBox.prototype.setEnabled = function (enabled) {
            if (enabled) {
                this.enable();
            }
            else {
                this.disable();
            }
        };
        Object.defineProperty(InputBox.prototype, "width", {
            get: function () {
                return dom.getTotalWidth(this.input);
            },
            set: function (width) {
                this.input.style.width = width + 'px';
            },
            enumerable: true,
            configurable: true
        });
        InputBox.prototype.showMessage = function (message, force) {
            this.message = message;
            dom.removeClass(this.element, 'idle');
            dom.removeClass(this.element, 'info');
            dom.removeClass(this.element, 'warning');
            dom.removeClass(this.element, 'error');
            dom.addClass(this.element, this.classForType(message.type));
            // ARIA Support
            var alertText;
            if (message.type === MessageType.ERROR) {
                alertText = nls.localize(0, null, message.content);
            }
            else if (message.type === MessageType.WARNING) {
                alertText = nls.localize(1, null, message.content);
            }
            else {
                alertText = nls.localize(2, null, message.content);
            }
            aria.alert(alertText);
            if (this.hasFocus() || force) {
                this._showMessage();
            }
        };
        InputBox.prototype.hideMessage = function () {
            this.message = null;
            dom.removeClass(this.element, 'info');
            dom.removeClass(this.element, 'warning');
            dom.removeClass(this.element, 'error');
            dom.addClass(this.element, 'idle');
            this._hideMessage();
        };
        InputBox.prototype.isInputValid = function () {
            return !!this.validation && !this.validation(this.value);
        };
        InputBox.prototype.validate = function () {
            var result = null;
            if (this.validation) {
                result = this.validation(this.value);
                if (!result) {
                    this.inputElement.removeAttribute('aria-invalid');
                    this.hideMessage();
                }
                else {
                    this.inputElement.setAttribute('aria-invalid', 'true');
                    this.showMessage(result);
                }
            }
            return !result;
        };
        InputBox.prototype.classForType = function (type) {
            switch (type) {
                case MessageType.INFO: return 'info';
                case MessageType.WARNING: return 'warning';
                default: return 'error';
            }
        };
        InputBox.prototype._showMessage = function () {
            var _this = this;
            if (!this.contextViewProvider || !this.message) {
                return;
            }
            var div;
            var layout = function () { return div.style.width = dom.getTotalWidth(_this.element) + 'px'; };
            this.state = 'open';
            this.contextViewProvider.showContextView({
                getAnchor: function () { return _this.element; },
                anchorAlignment: contextview_1.AnchorAlignment.RIGHT,
                render: function (container) {
                    div = dom.append(container, $('.monaco-inputbox-container'));
                    layout();
                    var renderOptions = {
                        tagName: 'span',
                        className: 'monaco-inputbox-message',
                    };
                    if (_this.message.formatContent) {
                        renderOptions.formattedText = _this.message.content;
                    }
                    else {
                        renderOptions.text = _this.message.content;
                    }
                    var spanElement = htmlContentRenderer_1.renderHtml(renderOptions);
                    dom.addClass(spanElement, _this.classForType(_this.message.type));
                    dom.append(div, spanElement);
                    return null;
                },
                layout: layout
            });
        };
        InputBox.prototype._hideMessage = function () {
            if (!this.contextViewProvider || this.state !== 'open') {
                return;
            }
            this.state = 'idle';
            this.contextViewProvider.hideContextView();
        };
        InputBox.prototype.onValueChange = function () {
            this._onDidChange.fire(this.value);
            this.validate();
            if (this.mirror) {
                var lastCharCode = this.value.charCodeAt(this.value.length - 1);
                var suffix = lastCharCode === 10 ? ' ' : '';
                this.mirror.textContent = this.value + suffix;
                this.layout();
            }
            if (this.state === 'open') {
                this.contextViewProvider.layout();
            }
        };
        InputBox.prototype.layout = function () {
            if (!this.mirror) {
                return;
            }
            var previousHeight = this.cachedHeight;
            this.cachedHeight = dom.getTotalHeight(this.mirror);
            if (previousHeight !== this.cachedHeight) {
                this.input.style.height = this.cachedHeight + 'px';
                this._onDidHeightChange.fire(this.cachedHeight);
            }
        };
        InputBox.prototype.dispose = function () {
            this._hideMessage();
            this.element = null;
            this.input = null;
            this.contextViewProvider = null;
            this.message = null;
            this.placeholder = null;
            this.ariaLabel = null;
            this.validation = null;
            this.showValidationMessage = null;
            this.state = null;
            this.actionbar = null;
            _super.prototype.dispose.call(this);
        };
        return InputBox;
    }(widget_1.Widget));
    exports.InputBox = InputBox;
});






define(__m[260], __M([0,1,184,11,98,257,44,16,12,390]), function (require, exports, nls, dom, inputBox_1, checkbox_1, widget_1, event_1, keyCodes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var NLS_REGEX_CHECKBOX_LABEL = nls.localize(0, null);
    var NLS_WHOLE_WORD_CHECKBOX_LABEL = nls.localize(1, null);
    var NLS_CASE_SENSITIVE_CHECKBOX_LABEL = nls.localize(2, null);
    var NLS_DEFAULT_LABEL = nls.localize(3, null);
    var FindInput = (function (_super) {
        __extends(FindInput, _super);
        function FindInput(parent, contextViewProvider, options) {
            var _this = this;
            _super.call(this);
            this._onDidOptionChange = this._register(new event_1.Emitter());
            this.onDidOptionChange = this._onDidOptionChange.event;
            this._onKeyDown = this._register(new event_1.Emitter());
            this.onKeyDown = this._onKeyDown.event;
            this._onInput = this._register(new event_1.Emitter());
            this.onInput = this._onInput.event;
            this._onKeyUp = this._register(new event_1.Emitter());
            this.onKeyUp = this._onKeyUp.event;
            this._onCaseSensitiveKeyDown = this._register(new event_1.Emitter());
            this.onCaseSensitiveKeyDown = this._onCaseSensitiveKeyDown.event;
            this.contextViewProvider = contextViewProvider;
            this.width = options.width || 100;
            this.placeholder = options.placeholder || '';
            this.validation = options.validation;
            this.label = options.label || NLS_DEFAULT_LABEL;
            this.regex = null;
            this.wholeWords = null;
            this.caseSensitive = null;
            this.domNode = null;
            this.inputBox = null;
            this.buildDomNode(options.appendCaseSensitiveLabel || '', options.appendWholeWordsLabel || '', options.appendRegexLabel || '');
            if (Boolean(parent)) {
                parent.appendChild(this.domNode);
            }
            this.onkeydown(this.inputBox.inputElement, function (e) { return _this._onKeyDown.fire(e); });
            this.onkeyup(this.inputBox.inputElement, function (e) { return _this._onKeyUp.fire(e); });
            this.oninput(this.inputBox.inputElement, function (e) { return _this._onInput.fire(); });
        }
        FindInput.prototype.enable = function () {
            dom.removeClass(this.domNode, 'disabled');
            this.inputBox.enable();
            this.regex.enable();
            this.wholeWords.enable();
            this.caseSensitive.enable();
        };
        FindInput.prototype.disable = function () {
            dom.addClass(this.domNode, 'disabled');
            this.inputBox.disable();
            this.regex.disable();
            this.wholeWords.disable();
            this.caseSensitive.disable();
        };
        FindInput.prototype.setEnabled = function (enabled) {
            if (enabled) {
                this.enable();
            }
            else {
                this.disable();
            }
        };
        FindInput.prototype.clear = function () {
            this.clearValidation();
            this.setValue('');
            this.focus();
        };
        FindInput.prototype.setWidth = function (newWidth) {
            this.width = newWidth;
            this.domNode.style.width = this.width + 'px';
            this.contextViewProvider.layout();
            this.setInputWidth();
        };
        FindInput.prototype.getValue = function () {
            return this.inputBox.value;
        };
        FindInput.prototype.setValue = function (value) {
            if (this.inputBox.value !== value) {
                this.inputBox.value = value;
            }
        };
        FindInput.prototype.setMatchCountState = function (state) {
            this.matchCount.setState(state);
            this.setInputWidth();
        };
        FindInput.prototype.select = function () {
            this.inputBox.select();
        };
        FindInput.prototype.focus = function () {
            this.inputBox.focus();
        };
        FindInput.prototype.getCaseSensitive = function () {
            return this.caseSensitive.checked;
        };
        FindInput.prototype.setCaseSensitive = function (value) {
            this.caseSensitive.checked = value;
            this.setInputWidth();
        };
        FindInput.prototype.getWholeWords = function () {
            return this.wholeWords.checked;
        };
        FindInput.prototype.setWholeWords = function (value) {
            this.wholeWords.checked = value;
            this.setInputWidth();
        };
        FindInput.prototype.getRegex = function () {
            return this.regex.checked;
        };
        FindInput.prototype.setRegex = function (value) {
            this.regex.checked = value;
            this.setInputWidth();
        };
        FindInput.prototype.focusOnCaseSensitive = function () {
            this.caseSensitive.focus();
        };
        FindInput.prototype.setInputWidth = function () {
            var w = this.width - this.matchCount.width() - this.caseSensitive.width() - this.wholeWords.width() - this.regex.width();
            this.inputBox.width = w;
        };
        FindInput.prototype.buildDomNode = function (appendCaseSensitiveLabel, appendWholeWordsLabel, appendRegexLabel) {
            var _this = this;
            this.domNode = document.createElement('div');
            this.domNode.style.width = this.width + 'px';
            dom.addClass(this.domNode, 'monaco-findInput');
            this.inputBox = this._register(new inputBox_1.InputBox(this.domNode, this.contextViewProvider, {
                placeholder: this.placeholder || '',
                ariaLabel: this.label || '',
                validationOptions: {
                    validation: this.validation || null,
                    showMessage: true
                }
            }));
            this.regex = this._register(new checkbox_1.Checkbox({
                actionClassName: 'regex',
                title: NLS_REGEX_CHECKBOX_LABEL + appendRegexLabel,
                isChecked: false,
                onChange: function (viaKeyboard) {
                    _this._onDidOptionChange.fire(viaKeyboard);
                    if (!viaKeyboard) {
                        _this.inputBox.focus();
                    }
                    _this.setInputWidth();
                    _this.validate();
                }
            }));
            this.wholeWords = this._register(new checkbox_1.Checkbox({
                actionClassName: 'whole-word',
                title: NLS_WHOLE_WORD_CHECKBOX_LABEL + appendWholeWordsLabel,
                isChecked: false,
                onChange: function (viaKeyboard) {
                    _this._onDidOptionChange.fire(viaKeyboard);
                    if (!viaKeyboard) {
                        _this.inputBox.focus();
                    }
                    _this.setInputWidth();
                    _this.validate();
                }
            }));
            this.caseSensitive = this._register(new checkbox_1.Checkbox({
                actionClassName: 'case-sensitive',
                title: NLS_CASE_SENSITIVE_CHECKBOX_LABEL + appendCaseSensitiveLabel,
                isChecked: false,
                onChange: function (viaKeyboard) {
                    _this._onDidOptionChange.fire(viaKeyboard);
                    if (!viaKeyboard) {
                        _this.inputBox.focus();
                    }
                    _this.setInputWidth();
                    _this.validate();
                },
                onKeyDown: function (e) {
                    _this._onCaseSensitiveKeyDown.fire(e);
                }
            }));
            this.matchCount = this._register(new MatchCount({
                onClick: function (e) {
                    _this.inputBox.focus();
                    e.preventDefault();
                }
            }));
            // Arrow-Key support to navigate between options
            var indexes = [this.caseSensitive.domNode, this.wholeWords.domNode, this.regex.domNode];
            this.onkeydown(this.domNode, function (event) {
                if (event.equals(keyCodes_1.CommonKeybindings.LEFT_ARROW) || event.equals(keyCodes_1.CommonKeybindings.RIGHT_ARROW) || event.equals(keyCodes_1.CommonKeybindings.ESCAPE)) {
                    var index = indexes.indexOf(document.activeElement);
                    if (index >= 0) {
                        var newIndex = void 0;
                        if (event.equals(keyCodes_1.CommonKeybindings.RIGHT_ARROW)) {
                            newIndex = (index + 1) % indexes.length;
                        }
                        else if (event.equals(keyCodes_1.CommonKeybindings.LEFT_ARROW)) {
                            if (index === 0) {
                                newIndex = indexes.length - 1;
                            }
                            else {
                                newIndex = index - 1;
                            }
                        }
                        if (event.equals(keyCodes_1.CommonKeybindings.ESCAPE)) {
                            indexes[index].blur();
                        }
                        else if (newIndex >= 0) {
                            indexes[newIndex].focus();
                        }
                        dom.EventHelper.stop(event, true);
                    }
                }
            });
            this.setInputWidth();
            var controls = document.createElement('div');
            controls.className = 'controls';
            controls.appendChild(this.matchCount.domNode);
            controls.appendChild(this.caseSensitive.domNode);
            controls.appendChild(this.wholeWords.domNode);
            controls.appendChild(this.regex.domNode);
            this.domNode.appendChild(controls);
        };
        FindInput.prototype.validate = function () {
            this.inputBox.validate();
        };
        FindInput.prototype.showMessage = function (message) {
            this.inputBox.showMessage(message);
        };
        FindInput.prototype.clearMessage = function () {
            this.inputBox.hideMessage();
        };
        FindInput.prototype.clearValidation = function () {
            this.inputBox.hideMessage();
        };
        FindInput.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        FindInput.OPTION_CHANGE = 'optionChange';
        return FindInput;
    }(widget_1.Widget));
    exports.FindInput = FindInput;
    var MatchCount = (function (_super) {
        __extends(MatchCount, _super);
        function MatchCount(opts) {
            _super.call(this);
            this.domNode = document.createElement('div');
            this.domNode.className = 'matchCount';
            this.setState({
                isVisible: false,
                count: '0',
                title: ''
            });
            this.onclick(this.domNode, opts.onClick);
        }
        MatchCount.prototype.width = function () {
            return this.isVisible ? 30 : 0;
        };
        MatchCount.prototype.setState = function (state) {
            dom.clearNode(this.domNode);
            this.domNode.appendChild(document.createTextNode(state.count));
            this.domNode.title = state.title;
            this.isVisible = state.isVisible;
            if (this.isVisible) {
                this.domNode.style.display = 'block';
            }
            else {
                this.domNode.style.display = 'none';
            }
        };
        return MatchCount;
    }(widget_1.Widget));
});






define(__m[100], __M([0,1,112,44,14]), function (require, exports, globalMouseMoveMonitor_1, widget_1, async_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The arrow image size.
     */
    exports.ARROW_IMG_SIZE = 11;
    var ScrollbarArrow = (function (_super) {
        __extends(ScrollbarArrow, _super);
        function ScrollbarArrow(opts) {
            var _this = this;
            _super.call(this);
            this._onActivate = opts.onActivate;
            this.bgDomNode = document.createElement('div');
            this.bgDomNode.className = 'arrow-background';
            this.bgDomNode.style.position = 'absolute';
            this.bgDomNode.style.width = opts.bgWidth + 'px';
            this.bgDomNode.style.height = opts.bgHeight + 'px';
            if (typeof opts.top !== 'undefined') {
                this.bgDomNode.style.top = '0px';
            }
            if (typeof opts.left !== 'undefined') {
                this.bgDomNode.style.left = '0px';
            }
            if (typeof opts.bottom !== 'undefined') {
                this.bgDomNode.style.bottom = '0px';
            }
            if (typeof opts.right !== 'undefined') {
                this.bgDomNode.style.right = '0px';
            }
            this.domNode = document.createElement('div');
            this.domNode.className = opts.className;
            this.domNode.style.position = 'absolute';
            this.domNode.style.width = exports.ARROW_IMG_SIZE + 'px';
            this.domNode.style.height = exports.ARROW_IMG_SIZE + 'px';
            if (typeof opts.top !== 'undefined') {
                this.domNode.style.top = opts.top + 'px';
            }
            if (typeof opts.left !== 'undefined') {
                this.domNode.style.left = opts.left + 'px';
            }
            if (typeof opts.bottom !== 'undefined') {
                this.domNode.style.bottom = opts.bottom + 'px';
            }
            if (typeof opts.right !== 'undefined') {
                this.domNode.style.right = opts.right + 'px';
            }
            this._mouseMoveMonitor = this._register(new globalMouseMoveMonitor_1.GlobalMouseMoveMonitor());
            this.onmousedown(this.bgDomNode, function (e) { return _this._arrowMouseDown(e); });
            this.onmousedown(this.domNode, function (e) { return _this._arrowMouseDown(e); });
            this._mousedownRepeatTimer = this._register(new async_1.IntervalTimer());
            this._mousedownScheduleRepeatTimer = this._register(new async_1.TimeoutTimer());
        }
        ScrollbarArrow.prototype._arrowMouseDown = function (e) {
            var _this = this;
            var scheduleRepeater = function () {
                _this._mousedownRepeatTimer.cancelAndSet(function () { return _this._onActivate(); }, 1000 / 24);
            };
            this._onActivate();
            this._mousedownRepeatTimer.cancel();
            this._mousedownScheduleRepeatTimer.cancelAndSet(scheduleRepeater, 200);
            this._mouseMoveMonitor.startMonitoring(globalMouseMoveMonitor_1.standardMouseMoveMerger, function (mouseMoveData) {
                /* Intentional empty */
            }, function () {
                _this._mousedownRepeatTimer.cancel();
                _this._mousedownScheduleRepeatTimer.cancel();
            });
            e.preventDefault();
        };
        return ScrollbarArrow;
    }(widget_1.Widget));
    exports.ScrollbarArrow = ScrollbarArrow;
});






define(__m[153], __M([0,1,18,11,39,112,44,27,100,201]), function (require, exports, Platform, DomUtils, mouseEvent_1, globalMouseMoveMonitor_1, widget_1, styleMutator_1, scrollbarArrow_1, scrollbarVisibilityController_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * The orthogonal distance to the slider at which dragging "resets". This implements "snapping"
     */
    var MOUSE_DRAG_RESET_DISTANCE = 140;
    var AbstractScrollbar = (function (_super) {
        __extends(AbstractScrollbar, _super);
        function AbstractScrollbar(opts) {
            var _this = this;
            _super.call(this);
            this._canUseTranslate3d = opts.canUseTranslate3d;
            this._lazyRender = opts.lazyRender;
            this._host = opts.host;
            this._scrollable = opts.scrollable;
            this._scrollbarState = opts.scrollbarState;
            this._visibilityController = this._register(new scrollbarVisibilityController_1.ScrollbarVisibilityController(opts.visibility, 'visible scrollbar ' + opts.extraScrollbarClassName, 'invisible scrollbar ' + opts.extraScrollbarClassName));
            this._mouseMoveMonitor = this._register(new globalMouseMoveMonitor_1.GlobalMouseMoveMonitor());
            this._shouldRender = true;
            this.domNode = styleMutator_1.createFastDomNode(document.createElement('div'));
            this._visibilityController.setDomNode(this.domNode);
            this.domNode.setPosition('absolute');
            this.onmousedown(this.domNode.domNode, function (e) { return _this._domNodeMouseDown(e); });
        }
        // ----------------- creation
        /**
         * Creates the dom node for an arrow & adds it to the container
         */
        AbstractScrollbar.prototype._createArrow = function (opts) {
            var arrow = this._register(new scrollbarArrow_1.ScrollbarArrow(opts));
            this.domNode.domNode.appendChild(arrow.bgDomNode);
            this.domNode.domNode.appendChild(arrow.domNode);
        };
        /**
         * Creates the slider dom node, adds it to the container & hooks up the events
         */
        AbstractScrollbar.prototype._createSlider = function (top, left, width, height) {
            var _this = this;
            this.slider = styleMutator_1.createFastDomNode(document.createElement('div'));
            this.slider.setClassName('slider');
            this.slider.setPosition('absolute');
            this.slider.setTop(top);
            this.slider.setLeft(left);
            this.slider.setWidth(width);
            this.slider.setHeight(height);
            this.domNode.domNode.appendChild(this.slider.domNode);
            this.onmousedown(this.slider.domNode, function (e) { return _this._sliderMouseDown(e); });
        };
        // ----------------- Update state
        AbstractScrollbar.prototype.setCanUseTranslate3d = function (canUseTranslate3d) {
            this._canUseTranslate3d = canUseTranslate3d;
            return true;
        };
        AbstractScrollbar.prototype._onElementSize = function (visibleSize) {
            if (this._scrollbarState.setVisibleSize(visibleSize)) {
                this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
                this._shouldRender = true;
                if (!this._lazyRender) {
                    this.render();
                }
            }
            return this._shouldRender;
        };
        AbstractScrollbar.prototype._onElementScrollSize = function (elementScrollSize) {
            if (this._scrollbarState.setScrollSize(elementScrollSize)) {
                this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
                this._shouldRender = true;
                if (!this._lazyRender) {
                    this.render();
                }
            }
            return this._shouldRender;
        };
        AbstractScrollbar.prototype._onElementScrollPosition = function (elementScrollPosition) {
            if (this._scrollbarState.setScrollPosition(elementScrollPosition)) {
                this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
                this._shouldRender = true;
                if (!this._lazyRender) {
                    this.render();
                }
            }
            return this._shouldRender;
        };
        // ----------------- rendering
        AbstractScrollbar.prototype.beginReveal = function () {
            this._visibilityController.setShouldBeVisible(true);
        };
        AbstractScrollbar.prototype.beginHide = function () {
            this._visibilityController.setShouldBeVisible(false);
        };
        AbstractScrollbar.prototype.render = function () {
            if (!this._shouldRender) {
                return;
            }
            this._shouldRender = false;
            if (this._canUseTranslate3d) {
                // Put the scrollbar in its own layer
                this.domNode.setTransform('translate3d(0px, 0px, 0px)');
            }
            else {
                this.domNode.setTransform('');
            }
            this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize());
            this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition());
        };
        // ----------------- DOM events
        AbstractScrollbar.prototype._domNodeMouseDown = function (e) {
            if (e.target !== this.domNode.domNode) {
                return;
            }
            this._onMouseDown(e);
        };
        AbstractScrollbar.prototype.delegateMouseDown = function (browserEvent) {
            var e = new mouseEvent_1.StandardMouseEvent(browserEvent);
            var domTop = this.domNode.domNode.getClientRects()[0].top;
            var sliderStart = domTop + this._scrollbarState.getSliderPosition();
            var sliderStop = domTop + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize();
            var mousePos = this._sliderMousePosition(e);
            if (sliderStart <= mousePos && mousePos <= sliderStop) {
                // Act as if it was a mouse down on the slider
                this._sliderMouseDown(e);
            }
            else {
                // Act as if it was a mouse down on the scrollbar
                this._onMouseDown(e);
            }
        };
        AbstractScrollbar.prototype._onMouseDown = function (e) {
            var domNodePosition = DomUtils.getDomNodePagePosition(this.domNode.domNode);
            var desiredSliderPosition = this._mouseDownRelativePosition(e, domNodePosition) - this._scrollbarState.getArrowSize() - this._scrollbarState.getSliderSize() / 2;
            this.setDesiredScrollPosition(this._scrollbarState.convertSliderPositionToScrollPosition(desiredSliderPosition));
            this._sliderMouseDown(e);
        };
        AbstractScrollbar.prototype._sliderMouseDown = function (e) {
            var _this = this;
            if (e.leftButton) {
                var initialMouseOrthogonalPosition_1 = this._sliderOrthogonalMousePosition(e);
                var initialScrollPosition_1 = this._getScrollPosition();
                var draggingDelta_1 = this._sliderMousePosition(e) - this._scrollbarState.getSliderPosition();
                this.slider.toggleClassName('active', true);
                this._mouseMoveMonitor.startMonitoring(globalMouseMoveMonitor_1.standardMouseMoveMerger, function (mouseMoveData) {
                    var mouseOrthogonalPosition = _this._sliderOrthogonalMousePosition(mouseMoveData);
                    var mouseOrthogonalDelta = Math.abs(mouseOrthogonalPosition - initialMouseOrthogonalPosition_1);
                    // console.log(initialMouseOrthogonalPosition + ' -> ' + mouseOrthogonalPosition + ': ' + mouseOrthogonalDelta);
                    if (Platform.isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE) {
                        // The mouse has wondered away from the scrollbar => reset dragging
                        _this.setDesiredScrollPosition(initialScrollPosition_1);
                    }
                    else {
                        var desiredSliderPosition = _this._sliderMousePosition(mouseMoveData) - draggingDelta_1;
                        _this.setDesiredScrollPosition(_this._scrollbarState.convertSliderPositionToScrollPosition(desiredSliderPosition));
                    }
                }, function () {
                    _this.slider.toggleClassName('active', false);
                    _this._host.onDragEnd();
                });
                e.preventDefault();
                this._host.onDragStart();
            }
        };
        AbstractScrollbar.prototype.validateScrollPosition = function (desiredScrollPosition) {
            return this._scrollbarState.validateScrollPosition(desiredScrollPosition);
        };
        AbstractScrollbar.prototype.setDesiredScrollPosition = function (desiredScrollPosition) {
            desiredScrollPosition = this.validateScrollPosition(desiredScrollPosition);
            var oldScrollPosition = this._getScrollPosition();
            this._setScrollPosition(desiredScrollPosition);
            var newScrollPosition = this._getScrollPosition();
            if (oldScrollPosition !== newScrollPosition) {
                this._onElementScrollPosition(this._getScrollPosition());
                return true;
            }
            return false;
        };
        return AbstractScrollbar;
    }(widget_1.Widget));
    exports.AbstractScrollbar = AbstractScrollbar;
});






define(__m[262], __M([0,1,153,39,41,135,100]), function (require, exports, abstractScrollbar_1, mouseEvent_1, scrollableElementOptions_1, scrollbarState_1, scrollbarArrow_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var HorizontalScrollbar = (function (_super) {
        __extends(HorizontalScrollbar, _super);
        function HorizontalScrollbar(scrollable, options, host) {
            var _this = this;
            _super.call(this, {
                canUseTranslate3d: options.canUseTranslate3d,
                lazyRender: options.lazyRender,
                host: host,
                scrollbarState: new scrollbarState_1.ScrollbarState((options.horizontalHasArrows ? options.arrowSize : 0), (options.horizontal === scrollableElementOptions_1.ScrollbarVisibility.Hidden ? 0 : options.horizontalScrollbarSize), (options.vertical === scrollableElementOptions_1.ScrollbarVisibility.Hidden ? 0 : options.verticalScrollbarSize)),
                visibility: options.horizontal,
                extraScrollbarClassName: 'horizontal',
                scrollable: scrollable
            });
            if (options.horizontalHasArrows) {
                var arrowDelta = (options.arrowSize - scrollbarArrow_1.ARROW_IMG_SIZE) / 2;
                var scrollbarDelta = (options.horizontalScrollbarSize - scrollbarArrow_1.ARROW_IMG_SIZE) / 2;
                this._createArrow({
                    className: 'left-arrow',
                    top: scrollbarDelta,
                    left: arrowDelta,
                    bottom: void 0,
                    right: void 0,
                    bgWidth: options.arrowSize,
                    bgHeight: options.horizontalScrollbarSize,
                    onActivate: function () { return _this._host.onMouseWheel(new mouseEvent_1.StandardMouseWheelEvent(null, 1, 0)); },
                });
                this._createArrow({
                    className: 'right-arrow',
                    top: scrollbarDelta,
                    left: void 0,
                    bottom: void 0,
                    right: arrowDelta,
                    bgWidth: options.arrowSize,
                    bgHeight: options.horizontalScrollbarSize,
                    onActivate: function () { return _this._host.onMouseWheel(new mouseEvent_1.StandardMouseWheelEvent(null, -1, 0)); },
                });
            }
            this._createSlider(Math.floor((options.horizontalScrollbarSize - options.horizontalSliderSize) / 2), 0, null, options.horizontalSliderSize);
        }
        HorizontalScrollbar.prototype._updateSlider = function (sliderSize, sliderPosition) {
            this.slider.setWidth(sliderSize);
            if (this._canUseTranslate3d) {
                this.slider.setTransform('translate3d(' + sliderPosition + 'px, 0px, 0px)');
                this.slider.setLeft(0);
            }
            else {
                this.slider.setTransform('');
                this.slider.setLeft(sliderPosition);
            }
        };
        HorizontalScrollbar.prototype._renderDomNode = function (largeSize, smallSize) {
            this.domNode.setWidth(largeSize);
            this.domNode.setHeight(smallSize);
            this.domNode.setLeft(0);
            this.domNode.setBottom(0);
        };
        HorizontalScrollbar.prototype.onDidScroll = function (e) {
            this._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender;
            this._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender;
            this._shouldRender = this._onElementSize(e.width) || this._shouldRender;
            return this._shouldRender;
        };
        HorizontalScrollbar.prototype._mouseDownRelativePosition = function (e, domNodePosition) {
            return e.posx - domNodePosition.left;
        };
        HorizontalScrollbar.prototype._sliderMousePosition = function (e) {
            return e.posx;
        };
        HorizontalScrollbar.prototype._sliderOrthogonalMousePosition = function (e) {
            return e.posy;
        };
        HorizontalScrollbar.prototype._getScrollPosition = function () {
            return this._scrollable.getScrollLeft();
        };
        HorizontalScrollbar.prototype._setScrollPosition = function (scrollPosition) {
            this._scrollable.updateState({
                scrollLeft: scrollPosition
            });
        };
        return HorizontalScrollbar;
    }(abstractScrollbar_1.AbstractScrollbar));
    exports.HorizontalScrollbar = HorizontalScrollbar;
});






define(__m[263], __M([0,1,153,39,41,135,100]), function (require, exports, abstractScrollbar_1, mouseEvent_1, scrollableElementOptions_1, scrollbarState_1, scrollbarArrow_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var VerticalScrollbar = (function (_super) {
        __extends(VerticalScrollbar, _super);
        function VerticalScrollbar(scrollable, options, host) {
            var _this = this;
            _super.call(this, {
                canUseTranslate3d: options.canUseTranslate3d,
                lazyRender: options.lazyRender,
                host: host,
                scrollbarState: new scrollbarState_1.ScrollbarState((options.verticalHasArrows ? options.arrowSize : 0), (options.vertical === scrollableElementOptions_1.ScrollbarVisibility.Hidden ? 0 : options.verticalScrollbarSize), 
                // give priority to vertical scroll bar over horizontal and let it scroll all the way to the bottom
                0),
                visibility: options.vertical,
                extraScrollbarClassName: 'vertical',
                scrollable: scrollable
            });
            if (options.verticalHasArrows) {
                var arrowDelta = (options.arrowSize - scrollbarArrow_1.ARROW_IMG_SIZE) / 2;
                var scrollbarDelta = (options.verticalScrollbarSize - scrollbarArrow_1.ARROW_IMG_SIZE) / 2;
                this._createArrow({
                    className: 'up-arrow',
                    top: arrowDelta,
                    left: scrollbarDelta,
                    bottom: void 0,
                    right: void 0,
                    bgWidth: options.verticalScrollbarSize,
                    bgHeight: options.arrowSize,
                    onActivate: function () { return _this._host.onMouseWheel(new mouseEvent_1.StandardMouseWheelEvent(null, 0, 1)); },
                });
                this._createArrow({
                    className: 'down-arrow',
                    top: void 0,
                    left: scrollbarDelta,
                    bottom: arrowDelta,
                    right: void 0,
                    bgWidth: options.verticalScrollbarSize,
                    bgHeight: options.arrowSize,
                    onActivate: function () { return _this._host.onMouseWheel(new mouseEvent_1.StandardMouseWheelEvent(null, 0, -1)); },
                });
            }
            this._createSlider(0, Math.floor((options.verticalScrollbarSize - options.verticalSliderSize) / 2), options.verticalSliderSize, null);
        }
        VerticalScrollbar.prototype._updateSlider = function (sliderSize, sliderPosition) {
            this.slider.setHeight(sliderSize);
            if (this._canUseTranslate3d) {
                this.slider.setTransform('translate3d(0px, ' + sliderPosition + 'px, 0px)');
                this.slider.setTop(0);
            }
            else {
                this.slider.setTransform('');
                this.slider.setTop(sliderPosition);
            }
        };
        VerticalScrollbar.prototype._renderDomNode = function (largeSize, smallSize) {
            this.domNode.setWidth(smallSize);
            this.domNode.setHeight(largeSize);
            this.domNode.setRight(0);
            this.domNode.setTop(0);
        };
        VerticalScrollbar.prototype.onDidScroll = function (e) {
            this._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender;
            this._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender;
            this._shouldRender = this._onElementSize(e.height) || this._shouldRender;
            return this._shouldRender;
        };
        VerticalScrollbar.prototype._mouseDownRelativePosition = function (e, domNodePosition) {
            return e.posy - domNodePosition.top;
        };
        VerticalScrollbar.prototype._sliderMousePosition = function (e) {
            return e.posy;
        };
        VerticalScrollbar.prototype._sliderOrthogonalMousePosition = function (e) {
            return e.posx;
        };
        VerticalScrollbar.prototype._getScrollPosition = function () {
            return this._scrollable.getScrollTop();
        };
        VerticalScrollbar.prototype._setScrollPosition = function (scrollPosition) {
            this._scrollable.updateState({
                scrollTop: scrollPosition
            });
        };
        return VerticalScrollbar;
    }(abstractScrollbar_1.AbstractScrollbar));
    exports.VerticalScrollbar = VerticalScrollbar;
});






define(__m[87], __M([0,1,28,11,18,39,262,263,41,3,195,44,14,27,16,423]), function (require, exports, Browser, DomUtils, Platform, mouseEvent_1, horizontalScrollbar_1, verticalScrollbar_1, scrollableElementOptions_1, lifecycle_1, scrollable_1, widget_1, async_1, styleMutator_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var HIDE_TIMEOUT = 500;
    var SCROLL_WHEEL_SENSITIVITY = 50;
    var ScrollableElement = (function (_super) {
        __extends(ScrollableElement, _super);
        function ScrollableElement(element, options) {
            var _this = this;
            _super.call(this);
            this._onScroll = this._register(new event_1.Emitter());
            this.onScroll = this._onScroll.event;
            element.style.overflow = 'hidden';
            this._options = resolveOptions(options);
            this._scrollable = this._register(new scrollable_1.Scrollable());
            this._register(this._scrollable.onScroll(function (e) {
                _this._onDidScroll(e);
                _this._onScroll.fire(e);
            }));
            // this._scrollable = this._register(new DelegateScrollable(scrollable, () => this._onScroll()));
            var scrollbarHost = {
                onMouseWheel: function (mouseWheelEvent) { return _this._onMouseWheel(mouseWheelEvent); },
                onDragStart: function () { return _this._onDragStart(); },
                onDragEnd: function () { return _this._onDragEnd(); },
            };
            this._verticalScrollbar = this._register(new verticalScrollbar_1.VerticalScrollbar(this._scrollable, this._options, scrollbarHost));
            this._horizontalScrollbar = this._register(new horizontalScrollbar_1.HorizontalScrollbar(this._scrollable, this._options, scrollbarHost));
            this._domNode = document.createElement('div');
            this._domNode.className = 'monaco-scrollable-element ' + this._options.className;
            this._domNode.setAttribute('role', 'presentation');
            this._domNode.style.position = 'relative';
            this._domNode.style.overflow = 'hidden';
            this._domNode.appendChild(element);
            this._domNode.appendChild(this._horizontalScrollbar.domNode.domNode);
            this._domNode.appendChild(this._verticalScrollbar.domNode.domNode);
            if (this._options.useShadows) {
                this._leftShadowDomNode = styleMutator_1.createFastDomNode(document.createElement('div'));
                this._leftShadowDomNode.setClassName('shadow');
                this._domNode.appendChild(this._leftShadowDomNode.domNode);
                this._topShadowDomNode = styleMutator_1.createFastDomNode(document.createElement('div'));
                this._topShadowDomNode.setClassName('shadow');
                this._domNode.appendChild(this._topShadowDomNode.domNode);
                this._topLeftShadowDomNode = styleMutator_1.createFastDomNode(document.createElement('div'));
                this._topLeftShadowDomNode.setClassName('shadow top-left-corner');
                this._domNode.appendChild(this._topLeftShadowDomNode.domNode);
            }
            this._listenOnDomNode = this._options.listenOnDomNode || this._domNode;
            this._mouseWheelToDispose = [];
            this._setListeningToMouseWheel(this._options.handleMouseWheel);
            this.onmouseover(this._listenOnDomNode, function (e) { return _this._onMouseOver(e); });
            this.onnonbubblingmouseout(this._listenOnDomNode, function (e) { return _this._onMouseOut(e); });
            this._hideTimeout = this._register(new async_1.TimeoutTimer());
            this._isDragging = false;
            this._mouseIsOver = false;
            this._shouldRender = true;
        }
        ScrollableElement.prototype.dispose = function () {
            this._mouseWheelToDispose = lifecycle_1.dispose(this._mouseWheelToDispose);
            _super.prototype.dispose.call(this);
        };
        /**
         * Get the generated 'scrollable' dom node
         */
        ScrollableElement.prototype.getDomNode = function () {
            return this._domNode;
        };
        ScrollableElement.prototype.getOverviewRulerLayoutInfo = function () {
            return {
                parent: this._domNode,
                insertBefore: this._verticalScrollbar.domNode.domNode,
            };
        };
        /**
         * Delegate a mouse down event to the vertical scrollbar.
         * This is to help with clicking somewhere else and having the scrollbar react.
         */
        ScrollableElement.prototype.delegateVerticalScrollbarMouseDown = function (browserEvent) {
            this._verticalScrollbar.delegateMouseDown(browserEvent);
        };
        ScrollableElement.prototype.updateState = function (newState) {
            this._scrollable.updateState(newState);
        };
        ScrollableElement.prototype.getWidth = function () {
            return this._scrollable.getWidth();
        };
        ScrollableElement.prototype.getScrollWidth = function () {
            return this._scrollable.getScrollWidth();
        };
        ScrollableElement.prototype.getScrollLeft = function () {
            return this._scrollable.getScrollLeft();
        };
        ScrollableElement.prototype.getHeight = function () {
            return this._scrollable.getHeight();
        };
        ScrollableElement.prototype.getScrollHeight = function () {
            return this._scrollable.getScrollHeight();
        };
        ScrollableElement.prototype.getScrollTop = function () {
            return this._scrollable.getScrollTop();
        };
        /**
         * Update the class name of the scrollable element.
         */
        ScrollableElement.prototype.updateClassName = function (newClassName) {
            this._options.className = newClassName;
            // Defaults are different on Macs
            if (Platform.isMacintosh) {
                this._options.className += ' mac';
            }
            this._domNode.className = 'monaco-scrollable-element ' + this._options.className;
        };
        /**
         * Update configuration options for the scrollbar.
         * Really this is Editor.IEditorScrollbarOptions, but base shouldn't
         * depend on Editor.
         */
        ScrollableElement.prototype.updateOptions = function (newOptions) {
            var massagedOptions = resolveOptions(newOptions);
            this._options.handleMouseWheel = massagedOptions.handleMouseWheel;
            this._options.mouseWheelScrollSensitivity = massagedOptions.mouseWheelScrollSensitivity;
            this._setListeningToMouseWheel(this._options.handleMouseWheel);
            this._shouldRender = this._horizontalScrollbar.setCanUseTranslate3d(massagedOptions.canUseTranslate3d) || this._shouldRender;
            this._shouldRender = this._verticalScrollbar.setCanUseTranslate3d(massagedOptions.canUseTranslate3d) || this._shouldRender;
            if (!this._options.lazyRender) {
                this._render();
            }
        };
        // -------------------- mouse wheel scrolling --------------------
        ScrollableElement.prototype._setListeningToMouseWheel = function (shouldListen) {
            var _this = this;
            var isListening = (this._mouseWheelToDispose.length > 0);
            if (isListening === shouldListen) {
                // No change
                return;
            }
            // Stop listening (if necessary)
            this._mouseWheelToDispose = lifecycle_1.dispose(this._mouseWheelToDispose);
            // Start listening (if necessary)
            if (shouldListen) {
                var onMouseWheel = function (browserEvent) {
                    var e = new mouseEvent_1.StandardMouseWheelEvent(browserEvent);
                    _this._onMouseWheel(e);
                };
                this._mouseWheelToDispose.push(DomUtils.addDisposableListener(this._listenOnDomNode, 'mousewheel', onMouseWheel));
                this._mouseWheelToDispose.push(DomUtils.addDisposableListener(this._listenOnDomNode, 'DOMMouseScroll', onMouseWheel));
            }
        };
        ScrollableElement.prototype._onMouseWheel = function (e) {
            if (Platform.isMacintosh && e.browserEvent && this._options.saveLastScrollTimeOnClassName) {
                // Mark dom node with timestamp of wheel event
                var target = e.browserEvent.target;
                if (target && target.nodeType === 1) {
                    var r = DomUtils.findParentWithClass(target, this._options.saveLastScrollTimeOnClassName);
                    if (r) {
                        r.setAttribute('last-scroll-time', String(new Date().getTime()));
                    }
                }
            }
            var desiredScrollTop = -1;
            var desiredScrollLeft = -1;
            if (e.deltaY || e.deltaX) {
                var deltaY = e.deltaY * this._options.mouseWheelScrollSensitivity;
                var deltaX = e.deltaX * this._options.mouseWheelScrollSensitivity;
                if (this._options.flipAxes) {
                    deltaY = e.deltaX;
                    deltaX = e.deltaY;
                }
                if (this._options.scrollYToX && !deltaX) {
                    deltaX = e.deltaY;
                    deltaY = 0;
                }
                if (Platform.isMacintosh) {
                    // Give preference to vertical scrolling
                    if (deltaY && Math.abs(deltaX) < 0.2) {
                        deltaX = 0;
                    }
                    if (Math.abs(deltaY) > Math.abs(deltaX) * 0.5) {
                        deltaX = 0;
                    }
                }
                if (deltaY) {
                    var currentScrollTop = this._scrollable.getScrollTop();
                    desiredScrollTop = this._verticalScrollbar.validateScrollPosition((desiredScrollTop !== -1 ? desiredScrollTop : currentScrollTop) - SCROLL_WHEEL_SENSITIVITY * deltaY);
                    if (desiredScrollTop === currentScrollTop) {
                        desiredScrollTop = -1;
                    }
                }
                if (deltaX) {
                    var currentScrollLeft = this._scrollable.getScrollLeft();
                    desiredScrollLeft = this._horizontalScrollbar.validateScrollPosition((desiredScrollLeft !== -1 ? desiredScrollLeft : currentScrollLeft) - SCROLL_WHEEL_SENSITIVITY * deltaX);
                    if (desiredScrollLeft === currentScrollLeft) {
                        desiredScrollLeft = -1;
                    }
                }
                if (desiredScrollTop !== -1 || desiredScrollLeft !== -1) {
                    if (desiredScrollTop !== -1) {
                        this._shouldRender = this._verticalScrollbar.setDesiredScrollPosition(desiredScrollTop) || this._shouldRender;
                        desiredScrollTop = -1;
                    }
                    if (desiredScrollLeft !== -1) {
                        this._shouldRender = this._horizontalScrollbar.setDesiredScrollPosition(desiredScrollLeft) || this._shouldRender;
                        desiredScrollLeft = -1;
                    }
                }
            }
            e.preventDefault();
            e.stopPropagation();
        };
        ScrollableElement.prototype._onDidScroll = function (e) {
            this._shouldRender = this._horizontalScrollbar.onDidScroll(e) || this._shouldRender;
            this._shouldRender = this._verticalScrollbar.onDidScroll(e) || this._shouldRender;
            if (this._options.useShadows) {
                this._shouldRender = true;
            }
            this._reveal();
            if (!this._options.lazyRender) {
                this._render();
            }
        };
        /**
         * Render / mutate the DOM now.
         * Should be used together with the ctor option `lazyRender`.
         */
        ScrollableElement.prototype.renderNow = function () {
            if (!this._options.lazyRender) {
                throw new Error('Please use `lazyRender` together with `renderNow`!');
            }
            this._render();
        };
        ScrollableElement.prototype._render = function () {
            if (!this._shouldRender) {
                return;
            }
            this._shouldRender = false;
            this._horizontalScrollbar.render();
            this._verticalScrollbar.render();
            if (this._options.useShadows) {
                var enableTop = this._scrollable.getScrollTop() > 0;
                var enableLeft = this._scrollable.getScrollLeft() > 0;
                this._leftShadowDomNode.setClassName('shadow' + (enableLeft ? ' left' : ''));
                this._topShadowDomNode.setClassName('shadow' + (enableTop ? ' top' : ''));
                this._topLeftShadowDomNode.setClassName('shadow top-left-corner' + (enableTop ? ' top' : '') + (enableLeft ? ' left' : ''));
            }
        };
        // -------------------- fade in / fade out --------------------
        ScrollableElement.prototype._onDragStart = function () {
            this._isDragging = true;
            this._reveal();
        };
        ScrollableElement.prototype._onDragEnd = function () {
            this._isDragging = false;
            this._hide();
        };
        ScrollableElement.prototype._onMouseOut = function (e) {
            this._mouseIsOver = false;
            this._hide();
        };
        ScrollableElement.prototype._onMouseOver = function (e) {
            this._mouseIsOver = true;
            this._reveal();
        };
        ScrollableElement.prototype._reveal = function () {
            this._verticalScrollbar.beginReveal();
            this._horizontalScrollbar.beginReveal();
            this._scheduleHide();
        };
        ScrollableElement.prototype._hide = function () {
            if (!this._mouseIsOver && !this._isDragging) {
                this._verticalScrollbar.beginHide();
                this._horizontalScrollbar.beginHide();
            }
        };
        ScrollableElement.prototype._scheduleHide = function () {
            var _this = this;
            this._hideTimeout.cancelAndSet(function () { return _this._hide(); }, HIDE_TIMEOUT);
        };
        return ScrollableElement;
    }(widget_1.Widget));
    exports.ScrollableElement = ScrollableElement;
    var DomScrollableElement = (function (_super) {
        __extends(DomScrollableElement, _super);
        function DomScrollableElement(element, options) {
            var _this = this;
            _super.call(this, element, options);
            this._element = element;
            this.onScroll(function (e) {
                if (e.scrollTopChanged) {
                    _this._element.scrollTop = e.scrollTop;
                }
                if (e.scrollLeftChanged) {
                    _this._element.scrollLeft = e.scrollLeft;
                }
            });
            this.scanDomNode();
        }
        DomScrollableElement.prototype.scanDomNode = function () {
            // widh, scrollLeft, scrollWidth, height, scrollTop, scrollHeight
            this.updateState({
                width: this._element.clientWidth,
                scrollWidth: this._element.scrollWidth,
                scrollLeft: this._element.scrollLeft,
                height: this._element.clientHeight,
                scrollHeight: this._element.scrollHeight,
                scrollTop: this._element.scrollTop,
            });
        };
        return DomScrollableElement;
    }(ScrollableElement));
    exports.DomScrollableElement = DomScrollableElement;
    function resolveOptions(opts) {
        var result = {
            canUseTranslate3d: opts.canUseTranslate3d && Browser.canUseTranslate3d,
            lazyRender: (typeof opts.lazyRender !== 'undefined' ? opts.lazyRender : false),
            className: (typeof opts.className !== 'undefined' ? opts.className : ''),
            useShadows: (typeof opts.useShadows !== 'undefined' ? opts.useShadows : true),
            handleMouseWheel: (typeof opts.handleMouseWheel !== 'undefined' ? opts.handleMouseWheel : true),
            flipAxes: (typeof opts.flipAxes !== 'undefined' ? opts.flipAxes : false),
            scrollYToX: (typeof opts.scrollYToX !== 'undefined' ? opts.scrollYToX : false),
            mouseWheelScrollSensitivity: (typeof opts.mouseWheelScrollSensitivity !== 'undefined' ? opts.mouseWheelScrollSensitivity : 1),
            arrowSize: (typeof opts.arrowSize !== 'undefined' ? opts.arrowSize : 11),
            listenOnDomNode: (typeof opts.listenOnDomNode !== 'undefined' ? opts.listenOnDomNode : null),
            horizontal: (typeof opts.horizontal !== 'undefined' ? opts.horizontal : scrollableElementOptions_1.ScrollbarVisibility.Auto),
            horizontalScrollbarSize: (typeof opts.horizontalScrollbarSize !== 'undefined' ? opts.horizontalScrollbarSize : 10),
            horizontalSliderSize: (typeof opts.horizontalSliderSize !== 'undefined' ? opts.horizontalSliderSize : 0),
            horizontalHasArrows: (typeof opts.horizontalHasArrows !== 'undefined' ? opts.horizontalHasArrows : false),
            vertical: (typeof opts.vertical !== 'undefined' ? opts.vertical : scrollableElementOptions_1.ScrollbarVisibility.Auto),
            verticalScrollbarSize: (typeof opts.verticalScrollbarSize !== 'undefined' ? opts.verticalScrollbarSize : 10),
            verticalHasArrows: (typeof opts.verticalHasArrows !== 'undefined' ? opts.verticalHasArrows : false),
            verticalSliderSize: (typeof opts.verticalSliderSize !== 'undefined' ? opts.verticalSliderSize : 0),
            saveLastScrollTimeOnClassName: (typeof opts.saveLastScrollTimeOnClassName !== 'undefined' ? opts.saveLastScrollTimeOnClassName : null)
        };
        result.horizontalSliderSize = (typeof opts.horizontalSliderSize !== 'undefined' ? opts.horizontalSliderSize : result.horizontalScrollbarSize);
        result.verticalSliderSize = (typeof opts.verticalSliderSize !== 'undefined' ? opts.verticalSliderSize : result.verticalScrollbarSize);
        // Defaults are different on Macs
        if (Platform.isMacintosh) {
            result.className += ' mac';
        }
        return result;
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[265], __M([0,1,31,3,69,11,87,41,258,252]), function (require, exports, objects_1, lifecycle_1, touch_1, DOM, scrollableElement_1, scrollableElementOptions_1, rangeMap_1, rowCache_1) {
    "use strict";
    var MouseEventTypes = [
        'click',
        'dblclick',
        'mouseup',
        'mousedown',
        'mouseover',
        'mousemove',
        'mouseout',
        'contextmenu'
    ];
    var DefaultOptions = {
        useShadows: true
    };
    var ListView = (function () {
        function ListView(container, delegate, renderers, options) {
            var _this = this;
            if (options === void 0) { options = DefaultOptions; }
            this.delegate = delegate;
            this.items = [];
            this.itemId = 0;
            this.rangeMap = new rangeMap_1.RangeMap();
            this.renderers = objects_1.toObject(renderers, function (r) { return r.templateId; });
            this.cache = new rowCache_1.RowCache(this.renderers);
            this.lastRenderTop = 0;
            this.lastRenderHeight = 0;
            this._domNode = document.createElement('div');
            this._domNode.className = 'monaco-list';
            this.rowsContainer = document.createElement('div');
            this.rowsContainer.className = 'monaco-list-rows';
            this.gesture = new touch_1.Gesture(this.rowsContainer);
            this.scrollableElement = new scrollableElement_1.ScrollableElement(this.rowsContainer, {
                canUseTranslate3d: false,
                horizontal: scrollableElementOptions_1.ScrollbarVisibility.Hidden,
                vertical: scrollableElementOptions_1.ScrollbarVisibility.Auto,
                useShadows: objects_1.getOrDefault(options, function (o) { return o.useShadows; }, DefaultOptions.useShadows),
                saveLastScrollTimeOnClassName: 'monaco-list-row'
            });
            var listener = this.scrollableElement.onScroll(function (e) { return _this.render(e.scrollTop, e.height); });
            this._domNode.appendChild(this.scrollableElement.getDomNode());
            container.appendChild(this._domNode);
            this.toDispose = [this.rangeMap, this.gesture, listener, this.scrollableElement];
            this.layout();
        }
        Object.defineProperty(ListView.prototype, "domNode", {
            get: function () {
                return this._domNode;
            },
            enumerable: true,
            configurable: true
        });
        ListView.prototype.splice = function (start, deleteCount) {
            var _this = this;
            var elements = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                elements[_i - 2] = arguments[_i];
            }
            var previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
            rangeMap_1.each(previousRenderRange, function (i) { return _this.removeItemFromDOM(_this.items[i]); });
            var inserted = elements.map(function (element) { return ({
                id: String(_this.itemId++),
                element: element,
                size: _this.delegate.getHeight(element),
                templateId: _this.delegate.getTemplateId(element),
                row: null
            }); });
            (_a = this.rangeMap).splice.apply(_a, [start, deleteCount].concat(inserted));
            var deleted = (_b = this.items).splice.apply(_b, [start, deleteCount].concat(inserted));
            var renderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
            rangeMap_1.each(renderRange, function (i) { return _this.insertItemInDOM(_this.items[i], i); });
            var scrollHeight = this.getContentHeight();
            this.rowsContainer.style.height = scrollHeight + "px";
            this.scrollableElement.updateState({ scrollHeight: scrollHeight });
            return deleted.map(function (i) { return i.element; });
            var _a, _b;
        };
        Object.defineProperty(ListView.prototype, "length", {
            get: function () {
                return this.items.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ListView.prototype, "renderHeight", {
            get: function () {
                return this.scrollableElement.getHeight();
            },
            enumerable: true,
            configurable: true
        });
        ListView.prototype.element = function (index) {
            return this.items[index].element;
        };
        ListView.prototype.elementHeight = function (index) {
            return this.items[index].size;
        };
        ListView.prototype.elementTop = function (index) {
            return this.rangeMap.positionAt(index);
        };
        ListView.prototype.indexAt = function (position) {
            return this.rangeMap.indexAt(position);
        };
        ListView.prototype.indexAfter = function (position) {
            return this.rangeMap.indexAfter(position);
        };
        ListView.prototype.layout = function (height) {
            this.scrollableElement.updateState({
                height: height || DOM.getContentHeight(this._domNode)
            });
        };
        // Render
        ListView.prototype.render = function (renderTop, renderHeight) {
            var _this = this;
            var previousRenderRange = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
            var renderRange = this.getRenderRange(renderTop, renderHeight);
            var rangesToInsert = rangeMap_1.relativeComplement(renderRange, previousRenderRange);
            var rangesToRemove = rangeMap_1.relativeComplement(previousRenderRange, renderRange);
            rangesToInsert.forEach(function (range) { return rangeMap_1.each(range, function (i) { return _this.insertItemInDOM(_this.items[i], i); }); });
            rangesToRemove.forEach(function (range) { return rangeMap_1.each(range, function (i) { return _this.removeItemFromDOM(_this.items[i]); }); });
            this.rowsContainer.style.transform = "translate3d(0px, -" + renderTop + "px, 0px)";
            this.lastRenderTop = renderTop;
            this.lastRenderHeight = renderHeight;
        };
        // DOM operations
        ListView.prototype.insertItemInDOM = function (item, index) {
            if (!item.row) {
                item.row = this.cache.alloc(item.templateId);
            }
            if (!item.row.domNode.parentElement) {
                this.rowsContainer.appendChild(item.row.domNode);
            }
            var renderer = this.renderers[item.templateId];
            item.row.domNode.style.top = this.elementTop(index) + "px";
            item.row.domNode.style.height = item.size + "px";
            item.row.domNode.setAttribute('data-index', "" + index);
            renderer.renderElement(item.element, index, item.row.templateData);
        };
        ListView.prototype.removeItemFromDOM = function (item) {
            this.cache.release(item.row);
            item.row = null;
        };
        ListView.prototype.getContentHeight = function () {
            return this.rangeMap.size;
        };
        ListView.prototype.getScrollTop = function () {
            return this.scrollableElement.getScrollTop();
        };
        ListView.prototype.setScrollTop = function (scrollTop) {
            this.scrollableElement.updateState({ scrollTop: scrollTop });
        };
        // Events
        ListView.prototype.addListener = function (type, handler, useCapture) {
            var _this = this;
            if (MouseEventTypes.indexOf(type) > -1) {
                var userHandler_1 = handler;
                handler = function (event) {
                    var index = _this.getItemIndex(event);
                    if (index < 0) {
                        return;
                    }
                    var element = _this.items[index].element;
                    userHandler_1(objects_1.assign(event, { element: element, index: index }));
                };
            }
            return DOM.addDisposableListener(this.domNode, type, handler, useCapture);
        };
        ListView.prototype.getItemIndex = function (event) {
            var target = event.target;
            while (target instanceof HTMLElement && target !== this.rowsContainer) {
                var element = target;
                var rawIndex = element.getAttribute('data-index');
                if (rawIndex) {
                    var index = Number(rawIndex);
                    if (!isNaN(index)) {
                        return index;
                    }
                }
                target = element.parentElement;
            }
            return -1;
        };
        ListView.prototype.getRenderRange = function (renderTop, renderHeight) {
            return {
                start: this.rangeMap.indexAt(renderTop),
                end: this.rangeMap.indexAfter(renderTop + renderHeight - 1)
            };
        };
        // Dispose
        ListView.prototype.dispose = function () {
            this.items = null;
            if (this._domNode && this._domNode.parentElement) {
                this._domNode.parentNode.removeChild(this._domNode);
                this._domNode = null;
            }
            this.toDispose = lifecycle_1.dispose(this.toDispose);
        };
        return ListView;
    }());
    exports.ListView = ListView;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[266], __M([0,1,3,26,11,16,137,265,404]), function (require, exports, lifecycle_1, types_1, DOM, event_1, event_2, listView_1) {
    "use strict";
    var TraitRenderer = (function () {
        function TraitRenderer(controller, renderer) {
            this.controller = controller;
            this.renderer = renderer;
        }
        Object.defineProperty(TraitRenderer.prototype, "templateId", {
            get: function () {
                return this.renderer.templateId;
            },
            enumerable: true,
            configurable: true
        });
        TraitRenderer.prototype.renderTemplate = function (container) {
            var data = this.renderer.renderTemplate(container);
            return { container: container, data: data };
        };
        TraitRenderer.prototype.renderElement = function (element, index, templateData) {
            this.controller.renderElement(element, index, templateData.container);
            this.renderer.renderElement(element, index, templateData.data);
        };
        TraitRenderer.prototype.disposeTemplate = function (templateData) {
            return this.renderer.disposeTemplate(templateData.data);
        };
        return TraitRenderer;
    }());
    var Trait = (function () {
        function Trait(_trait) {
            this._trait = _trait;
            this._onChange = new event_1.Emitter();
            this.indexes = [];
        }
        Object.defineProperty(Trait.prototype, "onChange", {
            get: function () { return this._onChange.event; },
            enumerable: true,
            configurable: true
        });
        Trait.prototype.splice = function (start, deleteCount, insertCount) {
            var diff = insertCount - deleteCount;
            var end = start + deleteCount;
            var indexes = [];
            for (var _i = 0, indexes_1 = indexes; _i < indexes_1.length; _i++) {
                var index = indexes_1[_i];
                if (index >= start && index < end) {
                    continue;
                }
                indexes.push(index > start ? index + diff : index);
            }
            this.indexes = indexes;
            this._onChange.fire({ indexes: indexes });
        };
        Trait.prototype.renderElement = function (element, index, container) {
            DOM.toggleClass(container, this._trait, this.contains(index));
        };
        Trait.prototype.set = function () {
            var indexes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                indexes[_i - 0] = arguments[_i];
            }
            var result = this.indexes;
            this.indexes = indexes;
            this._onChange.fire({ indexes: indexes });
            return result;
        };
        Trait.prototype.get = function () {
            return this.indexes;
        };
        Trait.prototype.contains = function (index) {
            return this.indexes.some(function (i) { return i === index; });
        };
        Trait.prototype.wrapRenderer = function (renderer) {
            return new TraitRenderer(this, renderer);
        };
        Trait.prototype.dispose = function () {
            this.indexes = null;
            this._onChange = lifecycle_1.dispose(this._onChange);
        };
        return Trait;
    }());
    var FocusTrait = (function (_super) {
        __extends(FocusTrait, _super);
        function FocusTrait(getElementId) {
            _super.call(this, 'focused');
            this.getElementId = getElementId;
        }
        FocusTrait.prototype.renderElement = function (element, index, container) {
            _super.prototype.renderElement.call(this, element, index, container);
            container.setAttribute('role', 'option');
            container.setAttribute('id', this.getElementId(index));
        };
        return FocusTrait;
    }(Trait));
    var Controller = (function () {
        function Controller(list, view) {
            var _this = this;
            this.list = list;
            this.view = view;
            this.toDispose = [];
            this.toDispose.push(view.addListener('mousedown', function (e) { return _this.onMouseDown(e); }));
            this.toDispose.push(view.addListener('click', function (e) { return _this.onClick(e); }));
        }
        Controller.prototype.onMouseDown = function (e) {
            e.preventDefault();
            e.stopPropagation();
        };
        Controller.prototype.onClick = function (e) {
            e.preventDefault();
            e.stopPropagation();
            this.view.domNode.focus();
            this.list.setFocus(e.index);
            this.list.setSelection(e.index);
        };
        Controller.prototype.dispose = function () {
            this.toDispose = lifecycle_1.dispose(this.toDispose);
        };
        return Controller;
    }());
    var DefaultOptions = {};
    var List = (function () {
        function List(container, delegate, renderers, options) {
            var _this = this;
            if (options === void 0) { options = DefaultOptions; }
            this.idPrefix = "list_id_" + ++List.InstanceCount;
            this.focus = new FocusTrait(function (i) { return _this.getElementId(i); });
            this.selection = new Trait('selected');
            this.eventBufferer = new event_1.EventBufferer();
            renderers = renderers.map(function (r) {
                r = _this.focus.wrapRenderer(r);
                r = _this.selection.wrapRenderer(r);
                return r;
            });
            this.view = new listView_1.ListView(container, delegate, renderers, options);
            this.view.domNode.setAttribute('role', 'listbox');
            this.view.domNode.tabIndex = 0;
            this.controller = new Controller(this, this.view);
            this._onDOMFocus = event_2.domEvent(this.view.domNode, 'focus');
        }
        Object.defineProperty(List.prototype, "onFocusChange", {
            get: function () {
                var _this = this;
                return this.eventBufferer.wrapEvent(event_1.mapEvent(this.focus.onChange, function (e) { return _this.toListEvent(e); }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(List.prototype, "onSelectionChange", {
            get: function () {
                var _this = this;
                return this.eventBufferer.wrapEvent(event_1.mapEvent(this.selection.onChange, function (e) { return _this.toListEvent(e); }));
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(List.prototype, "onDOMFocus", {
            get: function () { return this._onDOMFocus; },
            enumerable: true,
            configurable: true
        });
        List.prototype.splice = function (start, deleteCount) {
            var _this = this;
            var elements = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                elements[_i - 2] = arguments[_i];
            }
            this.eventBufferer.bufferEvents(function () {
                _this.focus.splice(start, deleteCount, elements.length);
                _this.selection.splice(start, deleteCount, elements.length);
                (_a = _this.view).splice.apply(_a, [start, deleteCount].concat(elements));
                var _a;
            });
        };
        Object.defineProperty(List.prototype, "length", {
            get: function () {
                return this.view.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(List.prototype, "contentHeight", {
            get: function () {
                return this.view.getContentHeight();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(List.prototype, "scrollTop", {
            get: function () {
                return this.view.getScrollTop();
            },
            enumerable: true,
            configurable: true
        });
        List.prototype.layout = function (height) {
            this.view.layout(height);
        };
        List.prototype.setSelection = function () {
            var _this = this;
            var indexes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                indexes[_i - 0] = arguments[_i];
            }
            this.eventBufferer.bufferEvents(function () {
                indexes = indexes.concat((_a = _this.selection).set.apply(_a, indexes));
                indexes.forEach(function (i) { return _this.view.splice(i, 1, _this.view.element(i)); });
                var _a;
            });
        };
        List.prototype.selectNext = function (n, loop) {
            if (n === void 0) { n = 1; }
            if (loop === void 0) { loop = false; }
            if (this.length === 0) {
                return;
            }
            var selection = this.selection.get();
            var index = selection.length > 0 ? selection[0] + n : 0;
            this.setSelection(loop ? index % this.length : Math.min(index, this.length - 1));
        };
        List.prototype.selectPrevious = function (n, loop) {
            if (n === void 0) { n = 1; }
            if (loop === void 0) { loop = false; }
            if (this.length === 0) {
                return;
            }
            var selection = this.selection.get();
            var index = selection.length > 0 ? selection[0] - n : 0;
            if (loop && index < 0) {
                index = this.length + (index % this.length);
            }
            this.setSelection(Math.max(index, 0));
        };
        List.prototype.getSelection = function () {
            return this.selection.get();
        };
        List.prototype.setFocus = function () {
            var _this = this;
            var indexes = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                indexes[_i - 0] = arguments[_i];
            }
            this.eventBufferer.bufferEvents(function () {
                indexes = indexes.concat((_a = _this.focus).set.apply(_a, indexes));
                indexes.forEach(function (i) { return _this.view.splice(i, 1, _this.view.element(i)); });
                var _a;
            });
        };
        List.prototype.focusNext = function (n, loop) {
            if (n === void 0) { n = 1; }
            if (loop === void 0) { loop = false; }
            if (this.length === 0) {
                return;
            }
            var focus = this.focus.get();
            var index = focus.length > 0 ? focus[0] + n : 0;
            this.setFocus(loop ? index % this.length : Math.min(index, this.length - 1));
        };
        List.prototype.focusPrevious = function (n, loop) {
            if (n === void 0) { n = 1; }
            if (loop === void 0) { loop = false; }
            if (this.length === 0) {
                return;
            }
            var focus = this.focus.get();
            var index = focus.length > 0 ? focus[0] - n : 0;
            if (loop && index < 0) {
                index = (this.length + (index % this.length)) % this.length;
            }
            this.setFocus(Math.max(index, 0));
        };
        List.prototype.focusNextPage = function () {
            var _this = this;
            var lastPageIndex = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
            lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;
            var lastPageElement = this.view.element(lastPageIndex);
            var currentlyFocusedElement = this.getFocusedElements()[0];
            if (currentlyFocusedElement !== lastPageElement) {
                this.setFocus(lastPageIndex);
            }
            else {
                var previousScrollTop = this.view.getScrollTop();
                this.view.setScrollTop(previousScrollTop + this.view.renderHeight - this.view.elementHeight(lastPageIndex));
                if (this.view.getScrollTop() !== previousScrollTop) {
                    // Let the scroll event listener run
                    setTimeout(function () { return _this.focusNextPage(); }, 0);
                }
            }
        };
        List.prototype.focusPreviousPage = function () {
            var _this = this;
            var firstPageIndex;
            var scrollTop = this.view.getScrollTop();
            if (scrollTop === 0) {
                firstPageIndex = this.view.indexAt(scrollTop);
            }
            else {
                firstPageIndex = this.view.indexAfter(scrollTop - 1);
            }
            var firstPageElement = this.view.element(firstPageIndex);
            var currentlyFocusedElement = this.getFocusedElements()[0];
            if (currentlyFocusedElement !== firstPageElement) {
                this.setFocus(firstPageIndex);
            }
            else {
                var previousScrollTop = scrollTop;
                this.view.setScrollTop(scrollTop - this.view.renderHeight);
                if (this.view.getScrollTop() !== previousScrollTop) {
                    // Let the scroll event listener run
                    setTimeout(function () { return _this.focusPreviousPage(); }, 0);
                }
            }
        };
        List.prototype.getFocus = function () {
            return this.focus.get();
        };
        List.prototype.getFocusedElements = function () {
            var _this = this;
            return this.getFocus().map(function (i) { return _this.view.element(i); });
        };
        List.prototype.reveal = function (index, relativeTop) {
            var scrollTop = this.view.getScrollTop();
            var elementTop = this.view.elementTop(index);
            var elementHeight = this.view.elementHeight(index);
            if (types_1.isNumber(relativeTop)) {
                relativeTop = relativeTop < 0 ? 0 : relativeTop;
                relativeTop = relativeTop > 1 ? 1 : relativeTop;
                // y = mx + b
                var m = elementHeight - this.view.renderHeight;
                this.view.setScrollTop(m * relativeTop + elementTop);
            }
            else {
                var viewItemBottom = elementTop + elementHeight;
                var wrapperBottom = scrollTop + this.view.renderHeight;
                if (elementTop < scrollTop) {
                    this.view.setScrollTop(elementTop);
                }
                else if (viewItemBottom >= wrapperBottom) {
                    this.view.setScrollTop(viewItemBottom - this.view.renderHeight);
                }
            }
        };
        List.prototype.getElementId = function (index) {
            return this.idPrefix + "_" + index;
        };
        List.prototype.toListEvent = function (_a) {
            var _this = this;
            var indexes = _a.indexes;
            return { indexes: indexes, elements: indexes.map(function (i) { return _this.view.element(i); }) };
        };
        List.prototype.dispose = function () {
            this.view = lifecycle_1.dispose(this.view);
            this.focus = lifecycle_1.dispose(this.focus);
            this.selection = lifecycle_1.dispose(this.selection);
        };
        List.InstanceCount = 0;
        return List;
    }());
    exports.List = List;
});






define(__m[267], __M([0,1,18,28,2,3,11,150,69,10,39,56,296,109,87,41,207,290,12]), function (require, exports, Platform, Browser, WinJS, Lifecycle, DOM, Diff, Touch, strings, Mouse, Keyboard, dnd, iterator_1, scrollableElement_1, scrollableElementOptions_1, treeViewModel_1, _, keyCodes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function getLastScrollTime(element) {
        var value = element.getAttribute('last-scroll-time');
        return value ? parseInt(value, 10) : 0;
    }
    function removeFromParent(element) {
        try {
            element.parentElement.removeChild(element);
        }
        catch (e) {
        }
    }
    var RowCache = (function () {
        function RowCache(context) {
            this.context = context;
            this._cache = { '': [] };
            this.scrollingRow = null;
        }
        RowCache.prototype.alloc = function (templateId) {
            var result = this.cache(templateId).pop();
            if (!result) {
                var content = document.createElement('div');
                content.className = 'content';
                var row = document.createElement('div');
                row.appendChild(content);
                result = {
                    element: row,
                    templateId: templateId,
                    templateData: this.context.renderer.renderTemplate(this.context.tree, templateId, content)
                };
            }
            return result;
        };
        RowCache.prototype.release = function (templateId, row) {
            var lastScrollTime = getLastScrollTime(row.element);
            if (!lastScrollTime) {
                removeFromParent(row.element);
                this.cache(templateId).push(row);
                return;
            }
            if (this.scrollingRow) {
                var lastKnownScrollTime = getLastScrollTime(this.scrollingRow.element);
                if (lastKnownScrollTime > lastScrollTime) {
                    removeFromParent(row.element);
                    this.cache(templateId).push(row);
                    return;
                }
                if (this.scrollingRow.element.parentElement) {
                    removeFromParent(this.scrollingRow.element);
                    DOM.removeClass(this.scrollingRow.element, 'scrolling');
                    this.cache(this.scrollingRow.templateId).push(this.scrollingRow);
                }
            }
            this.scrollingRow = row;
            DOM.addClass(this.scrollingRow.element, 'scrolling');
        };
        RowCache.prototype.cache = function (templateId) {
            return this._cache[templateId] || (this._cache[templateId] = []);
        };
        RowCache.prototype.garbageCollect = function () {
            var _this = this;
            if (this._cache) {
                Object.keys(this._cache).forEach(function (templateId) {
                    _this._cache[templateId].forEach(function (cachedRow) {
                        _this.context.renderer.disposeTemplate(_this.context.tree, templateId, cachedRow.templateData);
                        cachedRow.element = null;
                        cachedRow.templateData = null;
                    });
                    delete _this._cache[templateId];
                });
            }
            if (this.scrollingRow) {
                this.context.renderer.disposeTemplate(this.context.tree, this.scrollingRow.templateId, this.scrollingRow.templateData);
                this.scrollingRow = null;
            }
        };
        RowCache.prototype.dispose = function () {
            this.garbageCollect();
            this._cache = null;
            this.context = null;
        };
        return RowCache;
    }());
    exports.RowCache = RowCache;
    var ViewItem = (function () {
        function ViewItem(context, model) {
            var _this = this;
            this.context = context;
            this.model = model;
            this.id = this.model.id;
            this.row = null;
            this.top = 0;
            this.height = model.getHeight();
            this._styles = {};
            model.getAllTraits().forEach(function (t) { return _this._styles[t] = true; });
            if (model.isExpanded()) {
                this.addClass('expanded');
            }
        }
        Object.defineProperty(ViewItem.prototype, "expanded", {
            set: function (value) {
                value ? this.addClass('expanded') : this.removeClass('expanded');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewItem.prototype, "loading", {
            set: function (value) {
                value ? this.addClass('loading') : this.removeClass('loading');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewItem.prototype, "draggable", {
            get: function () {
                return this._draggable;
            },
            set: function (value) {
                this._draggable = value;
                this.render(true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewItem.prototype, "dropTarget", {
            set: function (value) {
                value ? this.addClass('drop-target') : this.removeClass('drop-target');
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewItem.prototype, "element", {
            get: function () {
                return this.row && this.row.element;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ViewItem.prototype, "templateId", {
            get: function () {
                return this._templateId || (this._templateId = (this.context.renderer.getTemplateId && this.context.renderer.getTemplateId(this.context.tree, this.model.getElement())));
            },
            enumerable: true,
            configurable: true
        });
        ViewItem.prototype.addClass = function (name) {
            this._styles[name] = true;
            this.render(true);
        };
        ViewItem.prototype.removeClass = function (name) {
            delete this._styles[name]; // is this slow?
            this.render(true);
        };
        ViewItem.prototype.render = function (skipUserRender) {
            var _this = this;
            if (skipUserRender === void 0) { skipUserRender = false; }
            if (!this.model || !this.element) {
                return;
            }
            var classes = ['monaco-tree-row'];
            classes.push.apply(classes, Object.keys(this._styles));
            if (this.model.hasChildren()) {
                classes.push('has-children');
            }
            this.element.className = classes.join(' ');
            this.element.draggable = this.draggable;
            this.element.style.height = this.height + 'px';
            // ARIA
            this.element.setAttribute('role', 'treeitem');
            if (this.model.hasTrait('focused')) {
                var base64Id = strings.safeBtoa(this.model.id);
                var ariaLabel = this.context.accessibilityProvider.getAriaLabel(this.context.tree, this.model.getElement());
                this.element.setAttribute('aria-selected', 'true');
                this.element.setAttribute('id', base64Id);
                if (ariaLabel) {
                    this.element.setAttribute('aria-label', ariaLabel);
                }
                else {
                    this.element.setAttribute('aria-labelledby', base64Id); // force screen reader to compute label from children (helps NVDA at least)
                }
            }
            else {
                this.element.setAttribute('aria-selected', 'false');
                this.element.removeAttribute('id');
                this.element.removeAttribute('aria-label');
                this.element.removeAttribute('aria-labelledby');
            }
            if (this.model.hasChildren()) {
                this.element.setAttribute('aria-expanded', String(this.model.isExpanded()));
            }
            else {
                this.element.removeAttribute('aria-expanded');
            }
            this.element.setAttribute('aria-level', String(this.model.getDepth()));
            if (this.context.options.paddingOnRow) {
                this.element.style.paddingLeft = this.context.options.twistiePixels + ((this.model.getDepth() - 1) * this.context.options.indentPixels) + 'px';
            }
            else {
                this.element.style.paddingLeft = ((this.model.getDepth() - 1) * this.context.options.indentPixels) + 'px';
                this.row.element.firstElementChild.style.paddingLeft = this.context.options.twistiePixels + 'px';
            }
            var uri = this.context.dnd.getDragURI(this.context.tree, this.model.getElement());
            if (uri !== this.uri) {
                if (this.unbindDragStart) {
                    this.unbindDragStart.dispose();
                    this.unbindDragStart = null;
                }
                if (uri) {
                    this.uri = uri;
                    this.draggable = true;
                    this.unbindDragStart = DOM.addDisposableListener(this.element, 'dragstart', function (e) {
                        _this.onDragStart(e);
                    });
                }
                else {
                    this.uri = null;
                }
            }
            if (!skipUserRender) {
                this.context.renderer.renderElement(this.context.tree, this.model.getElement(), this.templateId, this.row.templateData);
            }
        };
        ViewItem.prototype.insertInDOM = function (container, afterElement) {
            if (!this.row) {
                this.row = this.context.cache.alloc(this.templateId);
                // used in reverse lookup from HTMLElement to Item
                this.element[TreeView.BINDING] = this;
            }
            if (this.element.parentElement) {
                return;
            }
            if (afterElement === null) {
                container.appendChild(this.element);
            }
            else {
                try {
                    container.insertBefore(this.element, afterElement);
                }
                catch (e) {
                    console.warn('Failed to locate previous tree element');
                    container.appendChild(this.element);
                }
            }
            this.render();
        };
        ViewItem.prototype.removeFromDOM = function () {
            if (!this.row) {
                return;
            }
            if (this.unbindDragStart) {
                this.unbindDragStart.dispose();
                this.unbindDragStart = null;
            }
            this.uri = null;
            this.element[TreeView.BINDING] = null;
            this.context.cache.release(this.templateId, this.row);
            this.row = null;
        };
        ViewItem.prototype.dispose = function () {
            this.row = null;
            this.model = null;
        };
        return ViewItem;
    }());
    exports.ViewItem = ViewItem;
    var RootViewItem = (function (_super) {
        __extends(RootViewItem, _super);
        function RootViewItem(context, model, wrapper) {
            _super.call(this, context, model);
            this.row = {
                element: wrapper,
                templateData: null,
                templateId: null
            };
        }
        RootViewItem.prototype.render = function () {
            if (!this.model || !this.element) {
                return;
            }
            var classes = ['monaco-tree-wrapper'];
            classes.push.apply(classes, Object.keys(this._styles));
            if (this.model.hasChildren()) {
                classes.push('has-children');
            }
            this.element.className = classes.join(' ');
        };
        RootViewItem.prototype.insertInDOM = function (container, afterElement) {
            // noop
        };
        RootViewItem.prototype.removeFromDOM = function () {
            // noop
        };
        return RootViewItem;
    }(ViewItem));
    function reactionEquals(one, other) {
        if (!one && !other) {
            return true;
        }
        else if (!one || !other) {
            return false;
        }
        else if (one.accept !== other.accept) {
            return false;
        }
        else if (one.bubble !== other.bubble) {
            return false;
        }
        else if (one.effect !== other.effect) {
            return false;
        }
        else {
            return true;
        }
    }
    var TreeView = (function (_super) {
        __extends(TreeView, _super);
        function TreeView(context, container) {
            var _this = this;
            _super.call(this);
            this.lastClickTimeStamp = 0;
            this.isRefreshing = false;
            this.refreshingPreviousChildrenIds = {};
            this.context = {
                dataSource: context.dataSource,
                renderer: context.renderer,
                controller: context.controller,
                dnd: context.dnd,
                filter: context.filter,
                sorter: context.sorter,
                tree: context.tree,
                accessibilityProvider: context.accessibilityProvider,
                options: context.options,
                cache: new RowCache(context)
            };
            this.modelListeners = [];
            this.viewListeners = [];
            this.dragAndDropListeners = [];
            this.model = null;
            this.items = {};
            this.domNode = document.createElement('div');
            this.domNode.className = 'monaco-tree no-focused-item';
            this.domNode.tabIndex = 0;
            // ARIA
            this.domNode.setAttribute('role', 'tree');
            if (this.context.options.ariaLabel) {
                this.domNode.setAttribute('aria-label', this.context.options.ariaLabel);
            }
            if (this.context.options.alwaysFocused) {
                DOM.addClass(this.domNode, 'focused');
            }
            if (this.context.options.bare) {
                DOM.addClass(this.domNode, 'bare');
            }
            if (!this.context.options.paddingOnRow) {
                DOM.addClass(this.domNode, 'no-row-padding');
            }
            this.wrapper = document.createElement('div');
            this.wrapper.className = 'monaco-tree-wrapper';
            this.scrollableElement = new scrollableElement_1.ScrollableElement(this.wrapper, {
                canUseTranslate3d: false,
                horizontal: scrollableElementOptions_1.ScrollbarVisibility.Hidden,
                vertical: (typeof context.options.verticalScrollMode !== 'undefined' ? context.options.verticalScrollMode : scrollableElementOptions_1.ScrollbarVisibility.Auto),
                useShadows: context.options.useShadows,
                saveLastScrollTimeOnClassName: 'monaco-tree-row'
            });
            this.scrollableElement.onScroll(function (e) {
                _this.render(e.scrollTop, e.height);
                _this.emit('scroll', e); // TODO@Joao: is anyone interested in this event?
            });
            if (Browser.isIE11orEarlier) {
                this.wrapper.style.msTouchAction = 'none';
                this.wrapper.style.msContentZooming = 'none';
            }
            else {
                this.wrapperGesture = new Touch.Gesture(this.wrapper);
            }
            this.rowsContainer = document.createElement('div');
            this.rowsContainer.className = 'monaco-tree-rows';
            var focusTracker = DOM.trackFocus(this.domNode);
            focusTracker.addFocusListener(function () { return _this.onFocus(); });
            focusTracker.addBlurListener(function () { return _this.onBlur(); });
            this.viewListeners.push(focusTracker);
            this.viewListeners.push(DOM.addDisposableListener(this.domNode, 'keydown', function (e) { return _this.onKeyDown(e); }));
            this.viewListeners.push(DOM.addDisposableListener(this.domNode, 'keyup', function (e) { return _this.onKeyUp(e); }));
            this.viewListeners.push(DOM.addDisposableListener(this.domNode, 'mousedown', function (e) { return _this.onMouseDown(e); }));
            this.viewListeners.push(DOM.addDisposableListener(this.domNode, 'mouseup', function (e) { return _this.onMouseUp(e); }));
            this.viewListeners.push(DOM.addDisposableListener(this.wrapper, 'click', function (e) { return _this.onClick(e); }));
            this.viewListeners.push(DOM.addDisposableListener(this.domNode, 'contextmenu', function (e) { return _this.onContextMenu(e); }));
            this.viewListeners.push(DOM.addDisposableListener(this.wrapper, Touch.EventType.Tap, function (e) { return _this.onTap(e); }));
            this.viewListeners.push(DOM.addDisposableListener(this.wrapper, Touch.EventType.Change, function (e) { return _this.onTouchChange(e); }));
            if (Browser.isIE11orEarlier) {
                this.viewListeners.push(DOM.addDisposableListener(this.wrapper, 'MSPointerDown', function (e) { return _this.onMsPointerDown(e); }));
                this.viewListeners.push(DOM.addDisposableListener(this.wrapper, 'MSGestureTap', function (e) { return _this.onMsGestureTap(e); }));
                // these events come too fast, we throttle them
                this.viewListeners.push(DOM.addDisposableThrottledListener(this.wrapper, 'MSGestureChange', function (e) { return _this.onThrottledMsGestureChange(e); }, function (lastEvent, event) {
                    event.stopPropagation();
                    event.preventDefault();
                    var result = { translationY: event.translationY, translationX: event.translationX };
                    if (lastEvent) {
                        result.translationY += lastEvent.translationY;
                        result.translationX += lastEvent.translationX;
                    }
                    return result;
                }));
            }
            this.viewListeners.push(DOM.addDisposableListener(window, 'dragover', function (e) { return _this.onDragOver(e); }));
            this.viewListeners.push(DOM.addDisposableListener(window, 'drop', function (e) { return _this.onDrop(e); }));
            this.viewListeners.push(DOM.addDisposableListener(window, 'dragend', function (e) { return _this.onDragEnd(e); }));
            this.viewListeners.push(DOM.addDisposableListener(window, 'dragleave', function (e) { return _this.onDragOver(e); }));
            this.wrapper.appendChild(this.rowsContainer);
            this.domNode.appendChild(this.scrollableElement.getDomNode());
            container.appendChild(this.domNode);
            this.lastRenderTop = 0;
            this.lastRenderHeight = 0;
            this.didJustPressContextMenuKey = false;
            this.currentDropTarget = null;
            this.currentDropTargets = [];
            this.shouldInvalidateDropReaction = false;
            this.dragAndDropScrollInterval = null;
            this.dragAndDropScrollTimeout = null;
            this.onHiddenScrollTop = null;
            this.onRowsChanged();
            this.layout();
            this.setupMSGesture();
        }
        TreeView.prototype.createViewItem = function (item) {
            return new ViewItem(this.context, item);
        };
        TreeView.prototype.getHTMLElement = function () {
            return this.domNode;
        };
        TreeView.prototype.focus = function () {
            this.domNode.focus();
        };
        TreeView.prototype.isFocused = function () {
            return document.activeElement === this.domNode;
        };
        TreeView.prototype.blur = function () {
            this.domNode.blur();
        };
        TreeView.prototype.onVisible = function () {
            this.scrollTop = this.onHiddenScrollTop;
            this.onHiddenScrollTop = null;
            this.setupMSGesture();
        };
        TreeView.prototype.setupMSGesture = function () {
            var _this = this;
            if (window.MSGesture) {
                this.msGesture = new MSGesture();
                setTimeout(function () { return _this.msGesture.target = _this.wrapper; }, 100); // TODO@joh, TODO@IETeam
            }
        };
        TreeView.prototype.onHidden = function () {
            this.onHiddenScrollTop = this.scrollTop;
        };
        TreeView.prototype.isTreeVisible = function () {
            return this.onHiddenScrollTop === null;
        };
        TreeView.prototype.layout = function (height) {
            if (!this.isTreeVisible()) {
                return;
            }
            this.viewHeight = height || DOM.getContentHeight(this.wrapper); // render
        };
        TreeView.prototype.render = function (scrollTop, viewHeight) {
            var i;
            var stop;
            var renderTop = scrollTop;
            var renderBottom = scrollTop + viewHeight;
            var thisRenderBottom = this.lastRenderTop + this.lastRenderHeight;
            // when view scrolls down, start rendering from the renderBottom
            for (i = this.indexAfter(renderBottom) - 1, stop = this.indexAt(Math.max(thisRenderBottom, renderTop)); i >= stop; i--) {
                this.insertItemInDOM(this.itemAtIndex(i));
            }
            // when view scrolls up, start rendering from either this.renderTop or renderBottom
            for (i = Math.min(this.indexAt(this.lastRenderTop), this.indexAfter(renderBottom)) - 1, stop = this.indexAt(renderTop); i >= stop; i--) {
                this.insertItemInDOM(this.itemAtIndex(i));
            }
            // when view scrolls down, start unrendering from renderTop
            for (i = this.indexAt(this.lastRenderTop), stop = Math.min(this.indexAt(renderTop), this.indexAfter(thisRenderBottom)); i < stop; i++) {
                this.removeItemFromDOM(this.itemAtIndex(i));
            }
            // when view scrolls up, start unrendering from either renderBottom this.renderTop
            for (i = Math.max(this.indexAfter(renderBottom), this.indexAt(this.lastRenderTop)), stop = this.indexAfter(thisRenderBottom); i < stop; i++) {
                this.removeItemFromDOM(this.itemAtIndex(i));
            }
            var topItem = this.itemAtIndex(this.indexAt(renderTop));
            if (topItem) {
                this.rowsContainer.style.top = (topItem.top - renderTop) + 'px';
            }
            this.lastRenderTop = renderTop;
            this.lastRenderHeight = renderBottom - renderTop;
        };
        TreeView.prototype.setModel = function (newModel) {
            var _this = this;
            this.releaseModel();
            this.model = newModel;
            this.modelListeners.push(this.model.addBulkListener2(function (e) { return _this.onModelEvents(e); }));
        };
        TreeView.prototype.onModelEvents = function (events) {
            var elementsToRefresh = [];
            for (var i = 0, len = events.length; i < len; i++) {
                var event = events[i];
                var data = event.getData();
                switch (event.getType()) {
                    case 'refreshing':
                        this.onRefreshing();
                        break;
                    case 'refreshed':
                        this.onRefreshed();
                        break;
                    case 'clearingInput':
                        this.onClearingInput(data);
                        break;
                    case 'setInput':
                        this.onSetInput(data);
                        break;
                    case 'item:childrenRefreshing':
                        this.onItemChildrenRefreshing(data);
                        break;
                    case 'item:childrenRefreshed':
                        this.onItemChildrenRefreshed(data);
                        break;
                    case 'item:refresh':
                        elementsToRefresh.push(data.item);
                        break;
                    case 'item:expanding':
                        this.onItemExpanding(data);
                        break;
                    case 'item:expanded':
                        this.onItemExpanded(data);
                        break;
                    case 'item:collapsing':
                        this.onItemCollapsing(data);
                        break;
                    case 'item:reveal':
                        this.onItemReveal(data);
                        break;
                    case 'item:addTrait':
                        this.onItemAddTrait(data);
                        break;
                    case 'item:removeTrait':
                        this.onItemRemoveTrait(data);
                        break;
                    case 'focus':
                        this.onModelFocusChange();
                        break;
                }
            }
            if (elementsToRefresh.length > 0) {
                this.onItemsRefresh(elementsToRefresh);
            }
        };
        TreeView.prototype.onRefreshing = function () {
            this.isRefreshing = true;
        };
        TreeView.prototype.onRefreshed = function () {
            this.isRefreshing = false;
            this.onRowsChanged();
        };
        TreeView.prototype.onRowsChanged = function (scrollTop) {
            if (scrollTop === void 0) { scrollTop = this.scrollTop; }
            if (this.isRefreshing) {
                return;
            }
            this.scrollTop = scrollTop;
        };
        TreeView.prototype.focusNextPage = function (eventPayload) {
            var _this = this;
            var lastPageIndex = this.indexAt(this.scrollTop + this.viewHeight);
            lastPageIndex = lastPageIndex === 0 ? 0 : lastPageIndex - 1;
            var lastPageElement = this.itemAtIndex(lastPageIndex).model.getElement();
            var currentlyFocusedElement = this.model.getFocus();
            if (currentlyFocusedElement !== lastPageElement) {
                this.model.setFocus(lastPageElement, eventPayload);
            }
            else {
                var previousScrollTop = this.scrollTop;
                this.scrollTop += this.viewHeight;
                if (this.scrollTop !== previousScrollTop) {
                    // Let the scroll event listener run
                    setTimeout(function () {
                        _this.focusNextPage(eventPayload);
                    }, 0);
                }
            }
        };
        TreeView.prototype.focusPreviousPage = function (eventPayload) {
            var _this = this;
            var firstPageIndex;
            if (this.scrollTop === 0) {
                firstPageIndex = this.indexAt(this.scrollTop);
            }
            else {
                firstPageIndex = this.indexAfter(this.scrollTop - 1);
            }
            var firstPageElement = this.itemAtIndex(firstPageIndex).model.getElement();
            var currentlyFocusedElement = this.model.getFocus();
            if (currentlyFocusedElement !== firstPageElement) {
                this.model.setFocus(firstPageElement, eventPayload);
            }
            else {
                var previousScrollTop = this.scrollTop;
                this.scrollTop -= this.viewHeight;
                if (this.scrollTop !== previousScrollTop) {
                    // Let the scroll event listener run
                    setTimeout(function () {
                        _this.focusPreviousPage(eventPayload);
                    }, 0);
                }
            }
        };
        Object.defineProperty(TreeView.prototype, "viewHeight", {
            get: function () {
                return this.scrollableElement.getHeight();
            },
            set: function (viewHeight) {
                this.scrollableElement.updateState({
                    height: viewHeight,
                    scrollHeight: this.getTotalHeight()
                });
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TreeView.prototype, "scrollTop", {
            get: function () {
                return this.scrollableElement.getScrollTop();
            },
            set: function (scrollTop) {
                this.scrollableElement.updateState({
                    scrollTop: scrollTop,
                    scrollHeight: this.getTotalHeight()
                });
            },
            enumerable: true,
            configurable: true
        });
        TreeView.prototype.getScrollPosition = function () {
            var height = this.getTotalHeight() - this.viewHeight;
            return height <= 0 ? 0 : this.scrollTop / height;
        };
        TreeView.prototype.setScrollPosition = function (pos) {
            var height = this.getTotalHeight() - this.viewHeight;
            this.scrollTop = height * pos;
        };
        // Events
        TreeView.prototype.onClearingInput = function (e) {
            var item = e.item;
            if (item) {
                this.onRemoveItems(new iterator_1.MappedIterator(item.getNavigator(), function (item) { return item && item.id; }));
                this.onRowsChanged();
            }
        };
        TreeView.prototype.onSetInput = function (e) {
            this.context.cache.garbageCollect();
            this.inputItem = new RootViewItem(this.context, e.item, this.wrapper);
            this.emit('viewItem:create', { item: this.inputItem.model });
        };
        TreeView.prototype.onItemChildrenRefreshing = function (e) {
            var item = e.item;
            var viewItem = this.items[item.id];
            if (viewItem) {
                viewItem.loadingPromise = WinJS.TPromise.timeout(TreeView.LOADING_DECORATION_DELAY).then(function () {
                    viewItem.loadingPromise = null;
                    viewItem.loading = true;
                });
            }
            if (!e.isNested) {
                var childrenIds = [];
                var navigator = item.getNavigator();
                var childItem;
                while (childItem = navigator.next()) {
                    childrenIds.push(childItem.id);
                }
                this.refreshingPreviousChildrenIds[item.id] = childrenIds;
            }
        };
        TreeView.prototype.onItemChildrenRefreshed = function (e) {
            var _this = this;
            var item = e.item;
            var viewItem = this.items[item.id];
            if (viewItem) {
                if (viewItem.loadingPromise) {
                    viewItem.loadingPromise.cancel();
                    viewItem.loadingPromise = null;
                }
                viewItem.loading = false;
            }
            if (!e.isNested) {
                var previousChildrenIds = this.refreshingPreviousChildrenIds[item.id];
                var afterModelItems = [];
                var navigator = item.getNavigator();
                var childItem;
                while (childItem = navigator.next()) {
                    afterModelItems.push(childItem);
                }
                var skipDiff = Math.abs(previousChildrenIds.length - afterModelItems.length) > 1000;
                var diff = void 0;
                var doToInsertItemsAlreadyExist = void 0;
                if (!skipDiff) {
                    var lcs = new Diff.LcsDiff({
                        getLength: function () { return previousChildrenIds.length; },
                        getElementHash: function (i) { return previousChildrenIds[i]; }
                    }, {
                        getLength: function () { return afterModelItems.length; },
                        getElementHash: function (i) { return afterModelItems[i].id; }
                    }, null);
                    diff = lcs.ComputeDiff();
                    // this means that the result of the diff algorithm would result
                    // in inserting items that were already registered. this can only
                    // happen if the data provider returns bad ids OR if the sorting
                    // of the elements has changed
                    doToInsertItemsAlreadyExist = diff.some(function (d) {
                        if (d.modifiedLength > 0) {
                            for (var i = d.modifiedStart, len = d.modifiedStart + d.modifiedLength; i < len; i++) {
                                if (_this.items.hasOwnProperty(afterModelItems[i].id)) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    });
                }
                // 50 is an optimization number, at some point we're better off
                // just replacing everything
                if (!skipDiff && !doToInsertItemsAlreadyExist && diff.length < 50) {
                    for (var i = 0, len = diff.length; i < len; i++) {
                        var diffChange = diff[i];
                        if (diffChange.originalLength > 0) {
                            this.onRemoveItems(new iterator_1.ArrayIterator(previousChildrenIds, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength));
                        }
                        if (diffChange.modifiedLength > 0) {
                            var beforeItem = afterModelItems[diffChange.modifiedStart - 1] || item;
                            beforeItem = beforeItem.getDepth() > 0 ? beforeItem : null;
                            this.onInsertItems(new iterator_1.ArrayIterator(afterModelItems, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength), beforeItem ? beforeItem.id : null);
                        }
                    }
                }
                else if (skipDiff || diff.length) {
                    this.onRemoveItems(new iterator_1.ArrayIterator(previousChildrenIds));
                    this.onInsertItems(new iterator_1.ArrayIterator(afterModelItems));
                }
                if (skipDiff || diff.length) {
                    this.onRowsChanged();
                }
            }
        };
        TreeView.prototype.onItemsRefresh = function (items) {
            var _this = this;
            this.onRefreshItemSet(items.filter(function (item) { return _this.items.hasOwnProperty(item.id); }));
            this.onRowsChanged();
        };
        TreeView.prototype.onItemExpanding = function (e) {
            var viewItem = this.items[e.item.id];
            if (viewItem) {
                viewItem.expanded = true;
            }
        };
        TreeView.prototype.onItemExpanded = function (e) {
            var item = e.item;
            var viewItem = this.items[item.id];
            if (viewItem) {
                viewItem.expanded = true;
                var height = this.onInsertItems(item.getNavigator(), item.id);
                var scrollTop = this.scrollTop;
                if (viewItem.top + viewItem.height <= this.scrollTop) {
                    scrollTop += height;
                }
                this.onRowsChanged(scrollTop);
            }
        };
        TreeView.prototype.onItemCollapsing = function (e) {
            var item = e.item;
            var viewItem = this.items[item.id];
            if (viewItem) {
                viewItem.expanded = false;
                this.onRemoveItems(new iterator_1.MappedIterator(item.getNavigator(), function (item) { return item && item.id; }));
                this.onRowsChanged();
            }
        };
        TreeView.prototype.getRelativeTop = function (item) {
            if (item.isVisible()) {
                var viewItem = this.items[item.id];
                if (viewItem) {
                    return (viewItem.top - this.scrollTop) / (this.viewHeight - viewItem.height);
                }
            }
            return -1;
        };
        TreeView.prototype.onItemReveal = function (e) {
            var item = e.item;
            var relativeTop = e.relativeTop;
            var viewItem = this.items[item.id];
            if (viewItem) {
                if (relativeTop !== null) {
                    relativeTop = relativeTop < 0 ? 0 : relativeTop;
                    relativeTop = relativeTop > 1 ? 1 : relativeTop;
                    // y = mx + b
                    var m = viewItem.height - this.viewHeight;
                    this.scrollTop = m * relativeTop + viewItem.top;
                }
                else {
                    var viewItemBottom = viewItem.top + viewItem.height;
                    var wrapperBottom = this.scrollTop + this.viewHeight;
                    if (viewItem.top < this.scrollTop) {
                        this.scrollTop = viewItem.top;
                    }
                    else if (viewItemBottom >= wrapperBottom) {
                        this.scrollTop = viewItemBottom - this.viewHeight;
                    }
                }
            }
        };
        TreeView.prototype.onItemAddTrait = function (e) {
            var item = e.item;
            var trait = e.trait;
            var viewItem = this.items[item.id];
            if (viewItem) {
                viewItem.addClass(trait);
            }
            if (trait === 'highlighted') {
                DOM.addClass(this.domNode, trait);
                // Ugly Firefox fix: input fields can't be selected if parent nodes are draggable
                if (viewItem) {
                    this.highlightedItemWasDraggable = !!viewItem.draggable;
                    if (viewItem.draggable) {
                        viewItem.draggable = false;
                    }
                }
            }
        };
        TreeView.prototype.onItemRemoveTrait = function (e) {
            var item = e.item;
            var trait = e.trait;
            var viewItem = this.items[item.id];
            if (viewItem) {
                viewItem.removeClass(trait);
            }
            if (trait === 'highlighted') {
                DOM.removeClass(this.domNode, trait);
                // Ugly Firefox fix: input fields can't be selected if parent nodes are draggable
                if (this.highlightedItemWasDraggable) {
                    viewItem.draggable = true;
                }
                this.highlightedItemWasDraggable = false;
            }
        };
        TreeView.prototype.onModelFocusChange = function () {
            var focus = this.model && this.model.getFocus();
            DOM.toggleClass(this.domNode, 'no-focused-item', !focus);
            // ARIA
            if (focus) {
                this.domNode.setAttribute('aria-activedescendant', strings.safeBtoa(this.context.dataSource.getId(this.context.tree, focus)));
            }
            else {
                this.domNode.removeAttribute('aria-activedescendant');
            }
        };
        // HeightMap "events"
        TreeView.prototype.onInsertItem = function (item) {
            var _this = this;
            item.onDragStart = function (e) { _this.onDragStart(item, e); };
            item.needsRender = true;
            this.refreshViewItem(item);
            this.items[item.id] = item;
        };
        TreeView.prototype.onRefreshItem = function (item, needsRender) {
            if (needsRender === void 0) { needsRender = false; }
            item.needsRender = item.needsRender || needsRender;
            this.refreshViewItem(item);
        };
        TreeView.prototype.onRemoveItem = function (item) {
            this.removeItemFromDOM(item);
            item.dispose();
            this.emit('viewItem:dispose', { item: this.inputItem.model });
            delete this.items[item.id];
        };
        // ViewItem refresh
        TreeView.prototype.refreshViewItem = function (item) {
            item.render();
            if (this.shouldBeRendered(item)) {
                this.insertItemInDOM(item);
            }
            else {
                this.removeItemFromDOM(item);
            }
        };
        // DOM Events
        TreeView.prototype.onClick = function (e) {
            if (this.lastPointerType && this.lastPointerType !== 'mouse') {
                return;
            }
            var event = new Mouse.StandardMouseEvent(e);
            var item = this.getItemAround(event.target);
            if (!item) {
                return;
            }
            if (Browser.isIE10orLater && Date.now() - this.lastClickTimeStamp < 300) {
                // IE10+ doesn't set the detail property correctly. While IE10 simply
                // counts the number of clicks, IE11 reports always 1. To align with
                // other browser, we set the value to 2 if clicks events come in a 300ms
                // sequence.
                event.detail = 2;
            }
            this.lastClickTimeStamp = Date.now();
            this.context.controller.onClick(this.context.tree, item.model.getElement(), event);
        };
        TreeView.prototype.onMouseDown = function (e) {
            this.didJustPressContextMenuKey = false;
            if (!this.context.controller.onMouseDown) {
                return;
            }
            if (this.lastPointerType && this.lastPointerType !== 'mouse') {
                return;
            }
            var event = new Mouse.StandardMouseEvent(e);
            if (event.ctrlKey && Platform.isNative && Platform.isMacintosh) {
                return;
            }
            var item = this.getItemAround(event.target);
            if (!item) {
                return;
            }
            this.context.controller.onMouseDown(this.context.tree, item.model.getElement(), event);
        };
        TreeView.prototype.onMouseUp = function (e) {
            if (!this.context.controller.onMouseUp) {
                return;
            }
            if (this.lastPointerType && this.lastPointerType !== 'mouse') {
                return;
            }
            var event = new Mouse.StandardMouseEvent(e);
            if (event.ctrlKey && Platform.isNative && Platform.isMacintosh) {
                return;
            }
            var item = this.getItemAround(event.target);
            if (!item) {
                return;
            }
            this.context.controller.onMouseUp(this.context.tree, item.model.getElement(), event);
        };
        TreeView.prototype.onTap = function (e) {
            var item = this.getItemAround(e.initialTarget);
            if (!item) {
                return;
            }
            this.context.controller.onTap(this.context.tree, item.model.getElement(), e);
        };
        TreeView.prototype.onTouchChange = function (event) {
            event.preventDefault();
            event.stopPropagation();
            this.scrollTop -= event.translationY;
        };
        TreeView.prototype.onContextMenu = function (event) {
            var resultEvent;
            var element;
            if (event instanceof KeyboardEvent || this.didJustPressContextMenuKey) {
                this.didJustPressContextMenuKey = false;
                var keyboardEvent = new Keyboard.StandardKeyboardEvent(event);
                element = this.model.getFocus();
                if (!element) {
                    return;
                }
                var id = this.context.dataSource.getId(this.context.tree, element);
                var viewItem = this.items[id];
                var position = DOM.getDomNodePagePosition(viewItem.element);
                resultEvent = new _.KeyboardContextMenuEvent(position.left + position.width, position.top, keyboardEvent);
            }
            else {
                var mouseEvent = new Mouse.StandardMouseEvent(event);
                var item = this.getItemAround(mouseEvent.target);
                if (!item) {
                    return;
                }
                element = item.model.getElement();
                resultEvent = new _.MouseContextMenuEvent(mouseEvent);
            }
            this.context.controller.onContextMenu(this.context.tree, element, resultEvent);
        };
        TreeView.prototype.onKeyDown = function (e) {
            var event = new Keyboard.StandardKeyboardEvent(e);
            this.didJustPressContextMenuKey = event.keyCode === keyCodes_1.KeyCode.ContextMenu || (event.shiftKey && event.keyCode === keyCodes_1.KeyCode.F10);
            if (this.didJustPressContextMenuKey) {
                event.preventDefault();
                event.stopPropagation();
            }
            if (event.target && event.target.tagName && event.target.tagName.toLowerCase() === 'input') {
                return; // Ignore event if target is a form input field (avoids browser specific issues)
            }
            this.context.controller.onKeyDown(this.context.tree, event);
        };
        TreeView.prototype.onKeyUp = function (e) {
            if (this.didJustPressContextMenuKey) {
                this.onContextMenu(e);
            }
            this.didJustPressContextMenuKey = false;
            this.context.controller.onKeyUp(this.context.tree, new Keyboard.StandardKeyboardEvent(e));
        };
        TreeView.prototype.onDragStart = function (item, e) {
            if (this.model.getHighlight()) {
                return;
            }
            var element = item.model.getElement();
            var selection = this.model.getSelection();
            var elements;
            if (selection.indexOf(element) > -1) {
                elements = selection;
            }
            else {
                elements = [element];
            }
            e.dataTransfer.effectAllowed = 'copyMove';
            e.dataTransfer.setData('URL', item.uri);
            if (e.dataTransfer.setDragImage) {
                if (elements.length === 1 && item.element) {
                    e.dataTransfer.setDragImage(item.element, e.offsetX || 6, e.offsetY || 6);
                }
                else if (elements.length > 1) {
                    var dragImage = document.createElement('div');
                    dragImage.className = 'monaco-tree-drag-image';
                    dragImage.textContent = '' + elements.length;
                    document.body.appendChild(dragImage);
                    e.dataTransfer.setDragImage(dragImage, -10, -10);
                    setTimeout(function () { return document.body.removeChild(dragImage); }, 0);
                }
            }
            this.currentDragAndDropData = new dnd.ElementsDragAndDropData(elements);
            TreeView.currentExternalDragAndDropData = new dnd.ExternalElementsDragAndDropData(elements);
            this.context.dnd.onDragStart(this.context.tree, this.currentDragAndDropData, new Mouse.DragMouseEvent(e));
        };
        TreeView.prototype.setupDragAndDropScrollInterval = function () {
            var _this = this;
            var viewTop = DOM.getTopLeftOffset(this.wrapper).top;
            if (!this.dragAndDropScrollInterval) {
                this.dragAndDropScrollInterval = window.setInterval(function () {
                    if (_this.dragAndDropMouseY === undefined) {
                        return;
                    }
                    var diff = _this.dragAndDropMouseY - viewTop;
                    var scrollDiff = 0;
                    var upperLimit = _this.viewHeight - 35;
                    if (diff < 35) {
                        scrollDiff = Math.max(-14, 0.2 * (diff - 35));
                    }
                    else if (diff > upperLimit) {
                        scrollDiff = Math.min(14, 0.2 * (diff - upperLimit));
                    }
                    _this.scrollTop += scrollDiff;
                }, 10);
                this.cancelDragAndDropScrollTimeout();
                this.dragAndDropScrollTimeout = window.setTimeout(function () {
                    _this.cancelDragAndDropScrollInterval();
                    _this.dragAndDropScrollTimeout = null;
                }, 1000);
            }
        };
        TreeView.prototype.cancelDragAndDropScrollInterval = function () {
            if (this.dragAndDropScrollInterval) {
                window.clearInterval(this.dragAndDropScrollInterval);
                this.dragAndDropScrollInterval = null;
            }
            this.cancelDragAndDropScrollTimeout();
        };
        TreeView.prototype.cancelDragAndDropScrollTimeout = function () {
            if (this.dragAndDropScrollTimeout) {
                window.clearTimeout(this.dragAndDropScrollTimeout);
                this.dragAndDropScrollTimeout = null;
            }
        };
        TreeView.prototype.onDragOver = function (e) {
            var _this = this;
            var event = new Mouse.DragMouseEvent(e);
            var viewItem = this.getItemAround(event.target);
            if (!viewItem) {
                // dragging outside of tree
                if (this.currentDropTarget) {
                    // clear previously hovered element feedback
                    this.currentDropTargets.forEach(function (i) { return i.dropTarget = false; });
                    this.currentDropTargets = [];
                    if (this.currentDropPromise) {
                        this.currentDropPromise.cancel();
                        this.currentDropPromise = null;
                    }
                }
                this.cancelDragAndDropScrollInterval();
                this.currentDropTarget = null;
                this.currentDropElement = null;
                this.dragAndDropMouseY = null;
                return false;
            }
            // dragging inside the tree
            this.setupDragAndDropScrollInterval();
            this.dragAndDropMouseY = event.posy;
            if (!this.currentDragAndDropData) {
                // just started dragging
                if (TreeView.currentExternalDragAndDropData) {
                    this.currentDragAndDropData = TreeView.currentExternalDragAndDropData;
                }
                else {
                    if (!event.dataTransfer.types) {
                        return false;
                    }
                    this.currentDragAndDropData = new dnd.DesktopDragAndDropData();
                }
            }
            this.currentDragAndDropData.update(event);
            var element;
            var item = viewItem.model;
            var reaction;
            // check the bubble up behavior
            do {
                element = item ? item.getElement() : this.model.getInput();
                reaction = this.context.dnd.onDragOver(this.context.tree, this.currentDragAndDropData, element, event);
                if (!reaction || reaction.bubble !== _.DragOverBubble.BUBBLE_UP) {
                    break;
                }
                item = item && item.parent;
            } while (item);
            if (!item) {
                this.currentDropElement = null;
                return false;
            }
            var canDrop = reaction && reaction.accept;
            if (canDrop) {
                this.currentDropElement = item.getElement();
                event.preventDefault();
                event.dataTransfer.dropEffect = reaction.effect === _.DragOverEffect.COPY ? 'copy' : 'move';
            }
            else {
                this.currentDropElement = null;
            }
            // item is the model item where drop() should be called
            // can be null
            var currentDropTarget = item.id === this.inputItem.id ? this.inputItem : this.items[item.id];
            if (this.shouldInvalidateDropReaction || this.currentDropTarget !== currentDropTarget || !reactionEquals(this.currentDropElementReaction, reaction)) {
                this.shouldInvalidateDropReaction = false;
                if (this.currentDropTarget) {
                    this.currentDropTargets.forEach(function (i) { return i.dropTarget = false; });
                    this.currentDropTargets = [];
                    if (this.currentDropPromise) {
                        this.currentDropPromise.cancel();
                        this.currentDropPromise = null;
                    }
                }
                this.currentDropTarget = currentDropTarget;
                this.currentDropElementReaction = reaction;
                if (canDrop) {
                    // setup hover feedback for drop target
                    if (this.currentDropTarget) {
                        this.currentDropTarget.dropTarget = true;
                        this.currentDropTargets.push(this.currentDropTarget);
                    }
                    if (reaction.bubble === _.DragOverBubble.BUBBLE_DOWN) {
                        var nav = item.getNavigator();
                        var child;
                        while (child = nav.next()) {
                            viewItem = this.items[child.id];
                            if (viewItem) {
                                viewItem.dropTarget = true;
                                this.currentDropTargets.push(viewItem);
                            }
                        }
                    }
                    this.currentDropPromise = WinJS.TPromise.timeout(500).then(function () {
                        return _this.context.tree.expand(_this.currentDropElement).then(function () {
                            _this.shouldInvalidateDropReaction = true;
                        });
                    });
                }
            }
            return true;
        };
        TreeView.prototype.onDrop = function (e) {
            if (this.currentDropElement) {
                var event = new Mouse.DragMouseEvent(e);
                event.preventDefault();
                this.currentDragAndDropData.update(event);
                this.context.dnd.drop(this.context.tree, this.currentDragAndDropData, this.currentDropElement, event);
                this.onDragEnd(e);
            }
            this.cancelDragAndDropScrollInterval();
        };
        TreeView.prototype.onDragEnd = function (e) {
            if (this.currentDropTarget) {
                this.currentDropTargets.forEach(function (i) { return i.dropTarget = false; });
                this.currentDropTargets = [];
            }
            if (this.currentDropPromise) {
                this.currentDropPromise.cancel();
                this.currentDropPromise = null;
            }
            this.cancelDragAndDropScrollInterval();
            this.currentDragAndDropData = null;
            TreeView.currentExternalDragAndDropData = null;
            this.currentDropElement = null;
            this.currentDropTarget = null;
            this.dragAndDropMouseY = null;
        };
        TreeView.prototype.onFocus = function () {
            if (!this.context.options.alwaysFocused) {
                DOM.addClass(this.domNode, 'focused');
            }
        };
        TreeView.prototype.onBlur = function () {
            if (!this.context.options.alwaysFocused) {
                DOM.removeClass(this.domNode, 'focused');
            }
            this.domNode.removeAttribute('aria-activedescendant'); // ARIA
        };
        // MS specific DOM Events
        TreeView.prototype.onMsPointerDown = function (event) {
            if (!this.msGesture) {
                return;
            }
            // Circumvent IE11 breaking change in e.pointerType & TypeScript's stale definitions
            var pointerType = event.pointerType;
            if (pointerType === (event.MSPOINTER_TYPE_MOUSE || 'mouse')) {
                this.lastPointerType = 'mouse';
                return;
            }
            else if (pointerType === (event.MSPOINTER_TYPE_TOUCH || 'touch')) {
                this.lastPointerType = 'touch';
            }
            else {
                return;
            }
            event.stopPropagation();
            event.preventDefault();
            this.msGesture.addPointer(event.pointerId);
        };
        TreeView.prototype.onThrottledMsGestureChange = function (event) {
            this.scrollTop -= event.translationY;
        };
        TreeView.prototype.onMsGestureTap = function (event) {
            event.initialTarget = document.elementFromPoint(event.clientX, event.clientY);
            this.onTap(event);
        };
        // DOM changes
        TreeView.prototype.insertItemInDOM = function (item) {
            var elementAfter = null;
            var itemAfter = this.itemAfter(item);
            if (itemAfter && itemAfter.element) {
                elementAfter = itemAfter.element;
            }
            item.insertInDOM(this.rowsContainer, elementAfter);
        };
        TreeView.prototype.removeItemFromDOM = function (item) {
            item.removeFromDOM();
        };
        // Helpers
        TreeView.prototype.shouldBeRendered = function (item) {
            return item.top < this.lastRenderTop + this.lastRenderHeight && item.top + item.height > this.lastRenderTop;
        };
        TreeView.prototype.getItemAround = function (element) {
            var candidate = this.inputItem;
            do {
                if (element[TreeView.BINDING]) {
                    candidate = element[TreeView.BINDING];
                }
                if (element === this.wrapper || element === this.domNode) {
                    return candidate;
                }
                if (element === document.body) {
                    return null;
                }
            } while (element = element.parentElement);
        };
        // Cleanup
        TreeView.prototype.releaseModel = function () {
            if (this.model) {
                this.modelListeners = Lifecycle.dispose(this.modelListeners);
                this.model = null;
            }
        };
        TreeView.prototype.dispose = function () {
            // TODO@joao: improve
            this.scrollableElement.dispose();
            this.releaseModel();
            this.modelListeners = null;
            this.viewListeners = Lifecycle.dispose(this.viewListeners);
            if (this.domNode.parentNode) {
                this.domNode.parentNode.removeChild(this.domNode);
            }
            this.domNode = null;
            if (this.wrapperGesture) {
                this.wrapperGesture.dispose();
                this.wrapperGesture = null;
            }
            if (this.context.cache) {
                this.context.cache.dispose();
                this.context.cache = null;
            }
            _super.prototype.dispose.call(this);
        };
        TreeView.BINDING = 'monaco-tree-row';
        TreeView.LOADING_DECORATION_DELAY = 800;
        TreeView.currentExternalDragAndDropData = null;
        return TreeView;
    }(treeViewModel_1.HeightMap));
    exports.TreeView = TreeView;
});

define(__m[155], __M([0,1,256,3,118,11]), function (require, exports, flags, lifecycle_1, workerClient_1, dom) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function defaultGetWorkerUrl(workerId, label) {
        return require.toUrl('./' + workerId);
    }
    var getWorkerUrl = flags.getCrossOriginWorkerScriptUrl || defaultGetWorkerUrl;
    /**
     * A worker that uses HTML5 web workers so that is has
     * its own global scope and its own thread.
     */
    var WebWorker = (function () {
        function WebWorker(moduleId, id, label, onMessageCallback, onErrorCallback) {
            this.id = id;
            this.worker = new Worker(getWorkerUrl('workerMain.js', label));
            this.postMessage(moduleId);
            this.worker.onmessage = function (ev) {
                onMessageCallback(ev.data);
            };
            if (typeof this.worker.addEventListener === 'function') {
                this.worker.addEventListener('error', onErrorCallback);
            }
        }
        WebWorker.prototype.getId = function () {
            return this.id;
        };
        WebWorker.prototype.postMessage = function (msg) {
            this.worker.postMessage(msg);
        };
        WebWorker.prototype.dispose = function () {
            this.worker.terminate();
            this.worker = null;
        };
        return WebWorker;
    }());
    /**
     * A worker that runs in an iframe and therefore does have its
     * own global scope, but no own thread.
     */
    var FrameWorker = (function () {
        function FrameWorker(moduleId, id, onMessageCallback) {
            var _this = this;
            this.id = id;
            this._listeners = [];
            // Collect all messages sent to the worker until the iframe is loaded
            this.loaded = false;
            this.beforeLoadMessages = [];
            this.postMessage(moduleId);
            this.iframe = document.createElement('iframe');
            this.iframe.id = this.iframeId();
            this.iframe.src = require.toUrl('./workerMainCompatibility.html');
            this.iframe.frameborder = this.iframe.height = this.iframe.width = '0';
            this.iframe.style.display = 'none';
            this._listeners.push(dom.addDisposableListener(this.iframe, 'load', function () { return _this.onLoaded(); }));
            this.onMessage = function (ev) {
                onMessageCallback(ev.data);
            };
            this._listeners.push(dom.addDisposableListener(window, 'message', this.onMessage));
            document.body.appendChild(this.iframe);
        }
        FrameWorker.prototype.dispose = function () {
            this._listeners = lifecycle_1.dispose(this._listeners);
            window.removeEventListener('message', this.onMessage);
            window.frames[this.iframeId()].close();
        };
        FrameWorker.prototype.iframeId = function () {
            return 'worker_iframe_' + this.id;
        };
        FrameWorker.prototype.onLoaded = function () {
            this.loaded = true;
            while (this.beforeLoadMessages.length > 0) {
                this.postMessage(this.beforeLoadMessages.shift());
            }
        };
        FrameWorker.prototype.getId = function () {
            return this.id;
        };
        FrameWorker.prototype.postMessage = function (msg) {
            if (this.loaded === true) {
                var iframe = window.frames[this.iframeId()];
                if (iframe.postMessage) {
                    iframe.postMessage(msg, '*');
                }
                else {
                    iframe.contentWindow.postMessage(msg, '*');
                }
            }
            else {
                this.beforeLoadMessages.push(msg);
            }
        };
        return FrameWorker;
    }());
    var DefaultWorkerFactory = (function () {
        function DefaultWorkerFactory(fallbackToIframe) {
            this._fallbackToIframe = fallbackToIframe;
            this._webWorkerFailedBeforeError = false;
        }
        DefaultWorkerFactory.prototype.create = function (moduleId, onMessageCallback, onErrorCallback) {
            var _this = this;
            var workerId = (++DefaultWorkerFactory.LAST_WORKER_ID);
            if (this._fallbackToIframe) {
                if (this._webWorkerFailedBeforeError) {
                    // Avoid always trying to create web workers if they would just fail...
                    return new FrameWorker(moduleId, workerId, onMessageCallback);
                }
                try {
                    return new WebWorker(moduleId, workerId, 'service' + workerId, onMessageCallback, function (err) {
                        workerClient_1.logOnceWebWorkerWarning(err);
                        _this._webWorkerFailedBeforeError = err;
                        onErrorCallback(err);
                    });
                }
                catch (err) {
                    workerClient_1.logOnceWebWorkerWarning(err);
                    return new FrameWorker(moduleId, workerId, onMessageCallback);
                }
            }
            if (this._webWorkerFailedBeforeError) {
                throw this._webWorkerFailedBeforeError;
            }
            return new WebWorker(moduleId, workerId, 'service' + workerId, onMessageCallback, function (err) {
                workerClient_1.logOnceWebWorkerWarning(err);
                _this._webWorkerFailedBeforeError = err;
                onErrorCallback(err);
            });
        };
        DefaultWorkerFactory.LAST_WORKER_ID = 0;
        return DefaultWorkerFactory;
    }());
    exports.DefaultWorkerFactory = DefaultWorkerFactory;
});

define(__m[269], __M([0,1,21,4,7,22,11]), function (require, exports, position_1, range_1, editorCommon_1, editorBrowser_1, dom) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MouseTarget = (function () {
        function MouseTarget(element, type, mouseColumn, position, range, detail) {
            if (mouseColumn === void 0) { mouseColumn = 0; }
            if (position === void 0) { position = null; }
            if (range === void 0) { range = null; }
            if (detail === void 0) { detail = null; }
            this.element = element;
            this.type = type;
            this.mouseColumn = mouseColumn;
            this.position = position;
            if (!range && position) {
                range = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
            }
            this.range = range;
            this.detail = detail;
        }
        MouseTarget.prototype._typeToString = function () {
            if (this.type === editorCommon_1.MouseTargetType.TEXTAREA) {
                return 'TEXTAREA';
            }
            if (this.type === editorCommon_1.MouseTargetType.GUTTER_GLYPH_MARGIN) {
                return 'GUTTER_GLYPH_MARGIN';
            }
            if (this.type === editorCommon_1.MouseTargetType.GUTTER_LINE_NUMBERS) {
                return 'GUTTER_LINE_NUMBERS';
            }
            if (this.type === editorCommon_1.MouseTargetType.GUTTER_LINE_DECORATIONS) {
                return 'GUTTER_LINE_DECORATIONS';
            }
            if (this.type === editorCommon_1.MouseTargetType.GUTTER_VIEW_ZONE) {
                return 'GUTTER_VIEW_ZONE';
            }
            if (this.type === editorCommon_1.MouseTargetType.CONTENT_TEXT) {
                return 'CONTENT_TEXT';
            }
            if (this.type === editorCommon_1.MouseTargetType.CONTENT_EMPTY) {
                return 'CONTENT_EMPTY';
            }
            if (this.type === editorCommon_1.MouseTargetType.CONTENT_VIEW_ZONE) {
                return 'CONTENT_VIEW_ZONE';
            }
            if (this.type === editorCommon_1.MouseTargetType.CONTENT_WIDGET) {
                return 'CONTENT_WIDGET';
            }
            if (this.type === editorCommon_1.MouseTargetType.OVERVIEW_RULER) {
                return 'OVERVIEW_RULER';
            }
            if (this.type === editorCommon_1.MouseTargetType.SCROLLBAR) {
                return 'SCROLLBAR';
            }
            if (this.type === editorCommon_1.MouseTargetType.OVERLAY_WIDGET) {
                return 'OVERLAY_WIDGET';
            }
            return 'UNKNOWN';
        };
        MouseTarget.prototype.toString = function () {
            return this._typeToString() + ': ' + this.position + ' - ' + this.range + ' - ' + this.detail;
        };
        return MouseTarget;
    }());
    // e.g. of paths:
    // - overflow-guard/monaco-scrollable-element editor-scrollable vs/lines-content/view-lines/view-line
    // - overflow-guard/monaco-scrollable-element editor-scrollable vs/lines-content/view-lines/view-line/token comment js
    // etc.
    var REGEX = (function () {
        function nodeWithClass(className) {
            return '[^/]*' + className + '[^/]*';
        }
        function anyNode() {
            return '[^/]+';
        }
        var ANCHOR = '^' + editorBrowser_1.ClassNames.OVERFLOW_GUARD + '\\/';
        function createRegExp() {
            var pieces = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                pieces[_i - 0] = arguments[_i];
            }
            var forceEndMatch = false;
            if (pieces[pieces.length - 1] === '$') {
                forceEndMatch = true;
                pieces.pop();
            }
            return new RegExp(ANCHOR + pieces.join('\\/') + (forceEndMatch ? '$' : ''));
        }
        return {
            IS_TEXTAREA_COVER: createRegExp(nodeWithClass(editorBrowser_1.ClassNames.TEXTAREA_COVER), '$'),
            IS_TEXTAREA: createRegExp(editorBrowser_1.ClassNames.TEXTAREA, '$'),
            IS_VIEW_LINES: createRegExp(anyNode(), anyNode(), editorBrowser_1.ClassNames.VIEW_LINES, '$'),
            IS_CURSORS_LAYER: createRegExp(anyNode(), anyNode(), nodeWithClass(editorBrowser_1.ClassNames.VIEW_CURSORS_LAYER), '$'),
            IS_CHILD_OF_VIEW_LINES: createRegExp(anyNode(), anyNode(), editorBrowser_1.ClassNames.VIEW_LINES),
            IS_CHILD_OF_SCROLLABLE_ELEMENT: createRegExp(nodeWithClass(editorBrowser_1.ClassNames.SCROLLABLE_ELEMENT)),
            IS_CHILD_OF_CONTENT_WIDGETS: createRegExp(anyNode(), anyNode(), editorBrowser_1.ClassNames.CONTENT_WIDGETS),
            IS_CHILD_OF_OVERFLOWING_CONTENT_WIDGETS: new RegExp('^' + editorBrowser_1.ClassNames.OVERFLOWING_CONTENT_WIDGETS + '\\/'),
            IS_CHILD_OF_OVERLAY_WIDGETS: createRegExp(editorBrowser_1.ClassNames.OVERLAY_WIDGETS),
            IS_CHILD_OF_VIEW_OVERLAYS: createRegExp(editorBrowser_1.ClassNames.MARGIN_VIEW_OVERLAYS),
            IS_CHILD_OF_VIEW_ZONES: createRegExp(anyNode(), anyNode(), editorBrowser_1.ClassNames.VIEW_ZONES),
        };
    })();
    var MouseTargetFactory = (function () {
        function MouseTargetFactory(context, viewHelper) {
            this._context = context;
            this._viewHelper = viewHelper;
        }
        MouseTargetFactory.prototype.getClassNamePathTo = function (child, stopAt) {
            var path = [], className;
            while (child && child !== document.body) {
                if (child === stopAt) {
                    break;
                }
                if (child.nodeType === child.ELEMENT_NODE) {
                    className = child.className;
                    if (className) {
                        path.unshift(className);
                    }
                }
                child = child.parentNode;
            }
            return path.join('/');
        };
        MouseTargetFactory.prototype.mouseTargetIsWidget = function (e) {
            var t = e.target;
            var path = this.getClassNamePathTo(t, this._viewHelper.viewDomNode);
            // Is it a content widget?
            if (REGEX.IS_CHILD_OF_CONTENT_WIDGETS.test(path) || REGEX.IS_CHILD_OF_OVERFLOWING_CONTENT_WIDGETS.test(path)) {
                return true;
            }
            // Is it an overlay widget?
            if (REGEX.IS_CHILD_OF_OVERLAY_WIDGETS.test(path)) {
                return true;
            }
            return false;
        };
        MouseTargetFactory.prototype.createMouseTarget = function (layoutInfo, e, testEventTarget) {
            try {
                var r = this._unsafeCreateMouseTarget(layoutInfo, e, testEventTarget);
                return r;
            }
            catch (e) {
                return this.createMouseTargetFromUnknownTarget(e.target);
            }
        };
        MouseTargetFactory.prototype._unsafeCreateMouseTarget = function (layoutInfo, e, testEventTarget) {
            var mouseVerticalOffset = Math.max(0, this._viewHelper.getScrollTop() + (e.posy - e.editorPos.top));
            var mouseContentHorizontalOffset = this._viewHelper.getScrollLeft() + (e.posx - e.editorPos.left) - layoutInfo.contentLeft;
            var mouseColumn = this._getMouseColumn(mouseContentHorizontalOffset);
            var t = e.target;
            var path = this.getClassNamePathTo(t, this._viewHelper.viewDomNode);
            // Is it a content widget?
            if (REGEX.IS_CHILD_OF_CONTENT_WIDGETS.test(path) || REGEX.IS_CHILD_OF_OVERFLOWING_CONTENT_WIDGETS.test(path)) {
                return this.createMouseTargetFromContentWidgetsChild(t, mouseColumn);
            }
            // Is it an overlay widget?
            if (REGEX.IS_CHILD_OF_OVERLAY_WIDGETS.test(path)) {
                return this.createMouseTargetFromOverlayWidgetsChild(t, mouseColumn);
            }
            // Is it a cursor ?
            var lineNumberAttribute = t.hasAttribute && t.hasAttribute('lineNumber') ? t.getAttribute('lineNumber') : null;
            var columnAttribute = t.hasAttribute && t.hasAttribute('column') ? t.getAttribute('column') : null;
            if (lineNumberAttribute && columnAttribute) {
                return this.createMouseTargetFromViewCursor(t, parseInt(lineNumberAttribute, 10), parseInt(columnAttribute, 10), mouseColumn);
            }
            // Is it the textarea cover?
            if (REGEX.IS_TEXTAREA_COVER.test(path)) {
                if (this._context.configuration.editor.viewInfo.glyphMargin) {
                    return this.createMouseTargetFromGlyphMargin(t, mouseVerticalOffset, mouseColumn);
                }
                else if (this._context.configuration.editor.viewInfo.lineNumbers) {
                    return this.createMouseTargetFromLineNumbers(t, mouseVerticalOffset, mouseColumn);
                }
                else {
                    return this.createMouseTargetFromLinesDecorationsChild(t, mouseVerticalOffset, mouseColumn);
                }
            }
            // Is it the textarea?
            if (REGEX.IS_TEXTAREA.test(path)) {
                return new MouseTarget(t, editorCommon_1.MouseTargetType.TEXTAREA);
            }
            // Is it a view zone?
            if (REGEX.IS_CHILD_OF_VIEW_ZONES.test(path)) {
                // Check if it is at a view zone
                var viewZoneData = this._getZoneAtCoord(mouseVerticalOffset);
                if (viewZoneData) {
                    return new MouseTarget(t, editorCommon_1.MouseTargetType.CONTENT_VIEW_ZONE, mouseColumn, viewZoneData.position, null, viewZoneData);
                }
                return this.createMouseTargetFromUnknownTarget(t);
            }
            // Is it the view lines container?
            if (REGEX.IS_VIEW_LINES.test(path)) {
                // Sometimes, IE returns this target when right clicking on top of text
                // -> See Bug #12990: [F12] Context menu shows incorrect position while doing a resize
                // Check if it is below any lines and any view zones
                if (this._viewHelper.isAfterLines(mouseVerticalOffset)) {
                    return this.createMouseTargetFromViewLines(t, mouseVerticalOffset, mouseColumn);
                }
                // Check if it is at a view zone
                var viewZoneData = this._getZoneAtCoord(mouseVerticalOffset);
                if (viewZoneData) {
                    return new MouseTarget(t, editorCommon_1.MouseTargetType.CONTENT_VIEW_ZONE, mouseColumn, viewZoneData.position, null, viewZoneData);
                }
                // Check if it hits a position
                var hitTestResult = this._doHitTest(e, mouseVerticalOffset);
                if (hitTestResult.position) {
                    return this.createMouseTargetFromHitTestPosition(t, hitTestResult.position.lineNumber, hitTestResult.position.column, mouseContentHorizontalOffset, mouseColumn);
                }
                // Fall back to view lines
                return this.createMouseTargetFromViewLines(t, mouseVerticalOffset, mouseColumn);
            }
            // Is it a child of the view lines container?
            if (!testEventTarget || REGEX.IS_CHILD_OF_VIEW_LINES.test(path)) {
                var hitTestResult = this._doHitTest(e, mouseVerticalOffset);
                if (hitTestResult.position) {
                    return this.createMouseTargetFromHitTestPosition(t, hitTestResult.position.lineNumber, hitTestResult.position.column, mouseContentHorizontalOffset, mouseColumn);
                }
                else if (hitTestResult.hitTarget) {
                    t = hitTestResult.hitTarget;
                    path = this.getClassNamePathTo(t, this._viewHelper.viewDomNode);
                    // TODO@Alex: try again with this different target, but guard against recursion.
                    // Is it a cursor ?
                    var lineNumberAttribute_1 = t.hasAttribute && t.hasAttribute('lineNumber') ? t.getAttribute('lineNumber') : null;
                    var columnAttribute_1 = t.hasAttribute && t.hasAttribute('column') ? t.getAttribute('column') : null;
                    if (lineNumberAttribute_1 && columnAttribute_1) {
                        return this.createMouseTargetFromViewCursor(t, parseInt(lineNumberAttribute_1, 10), parseInt(columnAttribute_1, 10), mouseColumn);
                    }
                }
            }
            // Is it the cursors layer?
            if (REGEX.IS_CURSORS_LAYER.test(path)) {
                return new MouseTarget(t, editorCommon_1.MouseTargetType.UNKNOWN);
            }
            // Is it a child of the scrollable element?
            if (REGEX.IS_CHILD_OF_SCROLLABLE_ELEMENT.test(path)) {
                return this.createMouseTargetFromScrollbar(t, mouseVerticalOffset, mouseColumn);
            }
            if (REGEX.IS_CHILD_OF_VIEW_OVERLAYS.test(path)) {
                var offset = Math.abs(e.posx - e.editorPos.left);
                if (offset <= layoutInfo.glyphMarginWidth) {
                    // On the glyph margin
                    return this.createMouseTargetFromGlyphMargin(t, mouseVerticalOffset, mouseColumn);
                }
                offset -= layoutInfo.glyphMarginWidth;
                if (offset <= layoutInfo.lineNumbersWidth) {
                    // On the line numbers
                    return this.createMouseTargetFromLineNumbers(t, mouseVerticalOffset, mouseColumn);
                }
                offset -= layoutInfo.lineNumbersWidth;
                // On the line decorations
                return this.createMouseTargetFromLinesDecorationsChild(t, mouseVerticalOffset, mouseColumn);
            }
            if (/OverviewRuler/i.test(path)) {
                return this.createMouseTargetFromScrollbar(t, mouseVerticalOffset, mouseColumn);
            }
            return this.createMouseTargetFromUnknownTarget(t);
        };
        MouseTargetFactory.prototype._isChild = function (testChild, testAncestor, stopAt) {
            while (testChild && testChild !== document.body) {
                if (testChild === testAncestor) {
                    return true;
                }
                if (testChild === stopAt) {
                    return false;
                }
                testChild = testChild.parentNode;
            }
            return false;
        };
        MouseTargetFactory.prototype._findAttribute = function (element, attr, stopAt) {
            while (element && element !== document.body) {
                if (element.hasAttribute && element.hasAttribute(attr)) {
                    return element.getAttribute(attr);
                }
                if (element === stopAt) {
                    return null;
                }
                element = element.parentNode;
            }
            return null;
        };
        /**
         * Most probably WebKit browsers
         */
        MouseTargetFactory.prototype._doHitTestWithCaretRangeFromPoint = function (e, mouseVerticalOffset) {
            // In Chrome, especially on Linux it is possible to click between lines,
            // so try to adjust the `hity` below so that it lands in the center of a line
            var lineNumber = this._viewHelper.getLineNumberAtVerticalOffset(mouseVerticalOffset);
            var lineVerticalOffset = this._viewHelper.getVerticalOffsetForLineNumber(lineNumber);
            var centeredVerticalOffset = lineVerticalOffset + Math.floor(this._context.configuration.editor.lineHeight / 2);
            var adjustedPosy = e.posy + (centeredVerticalOffset - mouseVerticalOffset);
            if (adjustedPosy <= e.editorPos.top) {
                adjustedPosy = e.editorPos.top + 1;
            }
            if (adjustedPosy >= e.editorPos.top + this._context.configuration.editor.layoutInfo.height) {
                adjustedPosy = e.editorPos.top + this._context.configuration.editor.layoutInfo.height - 1;
            }
            var r = this._actualDoHitTestWithCaretRangeFromPoint(e.viewportx, adjustedPosy - dom.StandardWindow.scrollY);
            if (r.position) {
                return r;
            }
            // Also try to hit test without the adjustment (for the edge cases that we are near the top or bottom)
            return this._actualDoHitTestWithCaretRangeFromPoint(e.viewportx, e.viewporty);
        };
        MouseTargetFactory.prototype._actualDoHitTestWithCaretRangeFromPoint = function (hitx, hity) {
            var range = document.caretRangeFromPoint(hitx, hity);
            if (!range || !range.startContainer) {
                return {
                    position: null,
                    hitTarget: null
                };
            }
            // Chrome always hits a TEXT_NODE, while Edge sometimes hits a token span
            var startContainer = range.startContainer;
            var hitTarget;
            if (startContainer.nodeType === startContainer.TEXT_NODE) {
                // startContainer is expected to be the token text
                var parent1 = startContainer.parentNode; // expected to be the token span
                var parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line container span
                var parent3 = parent2 ? parent2.parentNode : null; // expected to be the view line div
                var parent3ClassName = parent3 && parent3.nodeType === parent3.ELEMENT_NODE ? parent3.className : null;
                if (parent3ClassName === editorBrowser_1.ClassNames.VIEW_LINE) {
                    return {
                        position: this._viewHelper.getPositionFromDOMInfo(parent1, range.startOffset),
                        hitTarget: null
                    };
                }
                else {
                    hitTarget = startContainer.parentNode;
                }
            }
            else if (startContainer.nodeType === startContainer.ELEMENT_NODE) {
                // startContainer is expected to be the token span
                var parent1 = startContainer.parentNode; // expected to be the view line container span
                var parent2 = parent1 ? parent1.parentNode : null; // expected to be the view line div
                var parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : null;
                if (parent2ClassName === editorBrowser_1.ClassNames.VIEW_LINE) {
                    return {
                        position: this._viewHelper.getPositionFromDOMInfo(startContainer, startContainer.textContent.length),
                        hitTarget: null
                    };
                }
                else {
                    hitTarget = startContainer;
                }
            }
            return {
                position: null,
                hitTarget: hitTarget
            };
        };
        /**
         * Most probably Gecko
         */
        MouseTargetFactory.prototype._doHitTestWithCaretPositionFromPoint = function (e) {
            var hitResult = document.caretPositionFromPoint(e.viewportx, e.viewporty);
            var range = document.createRange();
            range.setStart(hitResult.offsetNode, hitResult.offset);
            range.collapse(true);
            var resultPosition = this._viewHelper.getPositionFromDOMInfo(range.startContainer.parentNode, range.startOffset);
            range.detach();
            return {
                position: resultPosition,
                hitTarget: null
            };
        };
        /**
         * Most probably IE
         */
        MouseTargetFactory.prototype._doHitTestWithMoveToPoint = function (e) {
            var resultPosition = null;
            var resultHitTarget = null;
            var textRange = document.body.createTextRange();
            try {
                textRange.moveToPoint(e.viewportx, e.viewporty);
            }
            catch (err) {
                return {
                    position: null,
                    hitTarget: null
                };
            }
            textRange.collapse(true);
            // Now, let's do our best to figure out what we hit :)
            var parentElement = textRange ? textRange.parentElement() : null;
            var parent1 = parentElement ? parentElement.parentNode : null;
            var parent2 = parent1 ? parent1.parentNode : null;
            var parent2ClassName = parent2 && parent2.nodeType === parent2.ELEMENT_NODE ? parent2.className : '';
            if (parent2ClassName === editorBrowser_1.ClassNames.VIEW_LINE) {
                var rangeToContainEntireSpan = textRange.duplicate();
                rangeToContainEntireSpan.moveToElementText(parentElement);
                rangeToContainEntireSpan.setEndPoint('EndToStart', textRange);
                resultPosition = this._viewHelper.getPositionFromDOMInfo(parentElement, rangeToContainEntireSpan.text.length);
                // Move range out of the span node, IE doesn't like having many ranges in
                // the same spot and will act badly for lines containing dashes ('-')
                rangeToContainEntireSpan.moveToElementText(this._viewHelper.viewDomNode);
            }
            else {
                // Looks like we've hit the hover or something foreign
                resultHitTarget = parentElement;
            }
            // Move range out of the span node, IE doesn't like having many ranges in
            // the same spot and will act badly for lines containing dashes ('-')
            textRange.moveToElementText(this._viewHelper.viewDomNode);
            return {
                position: resultPosition,
                hitTarget: resultHitTarget
            };
        };
        MouseTargetFactory.prototype._doHitTest = function (e, mouseVerticalOffset) {
            // State of the art (18.10.2012):
            // The spec says browsers should support document.caretPositionFromPoint, but nobody implemented it (http://dev.w3.org/csswg/cssom-view/)
            // Gecko:
            //    - they tried to implement it once, but failed: https://bugzilla.mozilla.org/show_bug.cgi?id=654352
            //    - however, they do give out rangeParent/rangeOffset properties on mouse events
            // Webkit:
            //    - they have implemented a previous version of the spec which was using document.caretRangeFromPoint
            // IE:
            //    - they have a proprietary method on ranges, moveToPoint: https://msdn.microsoft.com/en-us/library/ie/ms536632(v=vs.85).aspx
            // Thank you browsers for making this so 'easy' :)
            if (document.caretRangeFromPoint) {
                return this._doHitTestWithCaretRangeFromPoint(e, mouseVerticalOffset);
            }
            else if (document.caretPositionFromPoint) {
                return this._doHitTestWithCaretPositionFromPoint(e);
            }
            else if (document.body.createTextRange) {
                return this._doHitTestWithMoveToPoint(e);
            }
            return {
                position: null,
                hitTarget: null
            };
        };
        MouseTargetFactory.prototype._getZoneAtCoord = function (mouseVerticalOffset) {
            // The target is either a view zone or the empty space after the last view-line
            var viewZoneWhitespace = this._viewHelper.getWhitespaceAtVerticalOffset(mouseVerticalOffset);
            if (viewZoneWhitespace) {
                var viewZoneMiddle = viewZoneWhitespace.verticalOffset + viewZoneWhitespace.height / 2, lineCount = this._context.model.getLineCount(), positionBefore = null, position = void 0, positionAfter = null;
                if (viewZoneWhitespace.afterLineNumber !== lineCount) {
                    // There are more lines after this view zone
                    positionAfter = new position_1.Position(viewZoneWhitespace.afterLineNumber + 1, 1);
                }
                if (viewZoneWhitespace.afterLineNumber > 0) {
                    // There are more lines above this view zone
                    positionBefore = new position_1.Position(viewZoneWhitespace.afterLineNumber, this._context.model.getLineMaxColumn(viewZoneWhitespace.afterLineNumber));
                }
                if (positionAfter === null) {
                    position = positionBefore;
                }
                else if (positionBefore === null) {
                    position = positionAfter;
                }
                else if (mouseVerticalOffset < viewZoneMiddle) {
                    position = positionBefore;
                }
                else {
                    position = positionAfter;
                }
                return {
                    viewZoneId: viewZoneWhitespace.id,
                    afterLineNumber: viewZoneWhitespace.afterLineNumber,
                    positionBefore: positionBefore,
                    positionAfter: positionAfter,
                    position: position
                };
            }
            return null;
        };
        MouseTargetFactory.prototype._getFullLineRangeAtCoord = function (mouseVerticalOffset) {
            if (this._viewHelper.isAfterLines(mouseVerticalOffset)) {
                // Below the last line
                var lineNumber_1 = this._context.model.getLineCount();
                var maxLineColumn_1 = this._context.model.getLineMaxColumn(lineNumber_1);
                return {
                    range: new range_1.Range(lineNumber_1, maxLineColumn_1, lineNumber_1, maxLineColumn_1),
                    isAfterLines: true
                };
            }
            var lineNumber = this._viewHelper.getLineNumberAtVerticalOffset(mouseVerticalOffset);
            var maxLineColumn = this._context.model.getLineMaxColumn(lineNumber);
            return {
                range: new range_1.Range(lineNumber, 1, lineNumber, maxLineColumn),
                isAfterLines: false
            };
        };
        MouseTargetFactory.prototype.getMouseColumn = function (layoutInfo, e) {
            var mouseContentHorizontalOffset = this._viewHelper.getScrollLeft() + (e.posx - e.editorPos.left) - layoutInfo.contentLeft;
            return this._getMouseColumn(mouseContentHorizontalOffset);
        };
        MouseTargetFactory.prototype._getMouseColumn = function (mouseContentHorizontalOffset) {
            if (mouseContentHorizontalOffset < 0) {
                return 1;
            }
            var charWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
            var chars = Math.round(mouseContentHorizontalOffset / charWidth);
            return (chars + 1);
        };
        MouseTargetFactory.prototype.createMouseTargetFromViewCursor = function (target, lineNumber, column, mouseColumn) {
            return new MouseTarget(target, editorCommon_1.MouseTargetType.CONTENT_TEXT, mouseColumn, new position_1.Position(lineNumber, column));
        };
        MouseTargetFactory.prototype.createMouseTargetFromViewLines = function (target, mouseVerticalOffset, mouseColumn) {
            // This most likely indicates it happened after the last view-line
            var lineCount = this._context.model.getLineCount();
            var maxLineColumn = this._context.model.getLineMaxColumn(lineCount);
            return new MouseTarget(target, editorCommon_1.MouseTargetType.CONTENT_EMPTY, mouseColumn, new position_1.Position(lineCount, maxLineColumn));
        };
        MouseTargetFactory.prototype.createMouseTargetFromHitTestPosition = function (target, lineNumber, column, mouseHorizontalOffset, mouseColumn) {
            var pos = new position_1.Position(lineNumber, column);
            var lineWidth = this._viewHelper.getLineWidth(lineNumber);
            if (mouseHorizontalOffset > lineWidth) {
                return new MouseTarget(target, editorCommon_1.MouseTargetType.CONTENT_EMPTY, mouseColumn, pos);
            }
            var visibleRange = this._viewHelper.visibleRangeForPosition2(lineNumber, column);
            if (!visibleRange) {
                return new MouseTarget(target, editorCommon_1.MouseTargetType.UNKNOWN, mouseColumn, pos);
            }
            var columnHorizontalOffset = visibleRange.left;
            if (mouseHorizontalOffset === columnHorizontalOffset) {
                return new MouseTarget(target, editorCommon_1.MouseTargetType.CONTENT_TEXT, mouseColumn, pos);
            }
            var mouseIsBetween;
            if (column > 1) {
                var prevColumnHorizontalOffset = visibleRange.left;
                mouseIsBetween = false;
                mouseIsBetween = mouseIsBetween || (prevColumnHorizontalOffset < mouseHorizontalOffset && mouseHorizontalOffset < columnHorizontalOffset); // LTR case
                mouseIsBetween = mouseIsBetween || (columnHorizontalOffset < mouseHorizontalOffset && mouseHorizontalOffset < prevColumnHorizontalOffset); // RTL case
                if (mouseIsBetween) {
                    var rng = new range_1.Range(lineNumber, column, lineNumber, column - 1);
                    return new MouseTarget(target, editorCommon_1.MouseTargetType.CONTENT_TEXT, mouseColumn, pos, rng);
                }
            }
            var lineMaxColumn = this._context.model.getLineMaxColumn(lineNumber);
            if (column < lineMaxColumn) {
                var nextColumnVisibleRange = this._viewHelper.visibleRangeForPosition2(lineNumber, column + 1);
                if (nextColumnVisibleRange) {
                    var nextColumnHorizontalOffset = nextColumnVisibleRange.left;
                    mouseIsBetween = false;
                    mouseIsBetween = mouseIsBetween || (columnHorizontalOffset < mouseHorizontalOffset && mouseHorizontalOffset < nextColumnHorizontalOffset); // LTR case
                    mouseIsBetween = mouseIsBetween || (nextColumnHorizontalOffset < mouseHorizontalOffset && mouseHorizontalOffset < columnHorizontalOffset); // RTL case
                    if (mouseIsBetween) {
                        var rng = new range_1.Range(lineNumber, column, lineNumber, column + 1);
                        return new MouseTarget(target, editorCommon_1.MouseTargetType.CONTENT_TEXT, mouseColumn, pos, rng);
                    }
                }
            }
            return new MouseTarget(target, editorCommon_1.MouseTargetType.CONTENT_TEXT, mouseColumn, pos);
        };
        MouseTargetFactory.prototype.createMouseTargetFromContentWidgetsChild = function (target, mouseColumn) {
            var widgetId = this._findAttribute(target, 'widgetId', this._viewHelper.viewDomNode);
            if (widgetId) {
                return new MouseTarget(target, editorCommon_1.MouseTargetType.CONTENT_WIDGET, mouseColumn, null, null, widgetId);
            }
            else {
                return new MouseTarget(target, editorCommon_1.MouseTargetType.UNKNOWN);
            }
        };
        MouseTargetFactory.prototype.createMouseTargetFromOverlayWidgetsChild = function (target, mouseColumn) {
            var widgetId = this._findAttribute(target, 'widgetId', this._viewHelper.viewDomNode);
            if (widgetId) {
                return new MouseTarget(target, editorCommon_1.MouseTargetType.OVERLAY_WIDGET, mouseColumn, null, null, widgetId);
            }
            else {
                return new MouseTarget(target, editorCommon_1.MouseTargetType.UNKNOWN);
            }
        };
        MouseTargetFactory.prototype.createMouseTargetFromLinesDecorationsChild = function (target, mouseVerticalOffset, mouseColumn) {
            var viewZoneData = this._getZoneAtCoord(mouseVerticalOffset);
            if (viewZoneData) {
                return new MouseTarget(target, editorCommon_1.MouseTargetType.GUTTER_VIEW_ZONE, mouseColumn, viewZoneData.position, null, viewZoneData);
            }
            var res = this._getFullLineRangeAtCoord(mouseVerticalOffset);
            return new MouseTarget(target, editorCommon_1.MouseTargetType.GUTTER_LINE_DECORATIONS, mouseColumn, new position_1.Position(res.range.startLineNumber, res.range.startColumn), res.range, res.isAfterLines);
        };
        MouseTargetFactory.prototype.createMouseTargetFromLineNumbers = function (target, mouseVerticalOffset, mouseColumn) {
            var viewZoneData = this._getZoneAtCoord(mouseVerticalOffset);
            if (viewZoneData) {
                return new MouseTarget(target, editorCommon_1.MouseTargetType.GUTTER_VIEW_ZONE, mouseColumn, viewZoneData.position, null, viewZoneData);
            }
            var res = this._getFullLineRangeAtCoord(mouseVerticalOffset);
            return new MouseTarget(target, editorCommon_1.MouseTargetType.GUTTER_LINE_NUMBERS, mouseColumn, new position_1.Position(res.range.startLineNumber, res.range.startColumn), res.range, res.isAfterLines);
        };
        MouseTargetFactory.prototype.createMouseTargetFromGlyphMargin = function (target, mouseVerticalOffset, mouseColumn) {
            var viewZoneData = this._getZoneAtCoord(mouseVerticalOffset);
            if (viewZoneData) {
                return new MouseTarget(target, editorCommon_1.MouseTargetType.GUTTER_VIEW_ZONE, mouseColumn, viewZoneData.position, null, viewZoneData);
            }
            var res = this._getFullLineRangeAtCoord(mouseVerticalOffset);
            return new MouseTarget(target, editorCommon_1.MouseTargetType.GUTTER_GLYPH_MARGIN, mouseColumn, new position_1.Position(res.range.startLineNumber, res.range.startColumn), res.range, res.isAfterLines);
        };
        MouseTargetFactory.prototype.createMouseTargetFromScrollbar = function (target, mouseVerticalOffset, mouseColumn) {
            var possibleLineNumber = this._viewHelper.getLineNumberAtVerticalOffset(mouseVerticalOffset);
            var maxColumn = this._context.model.getLineMaxColumn(possibleLineNumber);
            return new MouseTarget(target, editorCommon_1.MouseTargetType.SCROLLBAR, mouseColumn, new position_1.Position(possibleLineNumber, maxColumn));
        };
        MouseTargetFactory.prototype.createMouseTargetFromUnknownTarget = function (target) {
            var isInView = this._isChild(target, this._viewHelper.viewDomNode, this._viewHelper.viewDomNode);
            var widgetId = null;
            if (isInView) {
                widgetId = this._findAttribute(target, 'widgetId', this._viewHelper.viewDomNode);
            }
            if (widgetId) {
                return new MouseTarget(target, editorCommon_1.MouseTargetType.OVERLAY_WIDGET, null, null, widgetId);
            }
            else {
                return new MouseTarget(target, editorCommon_1.MouseTargetType.UNKNOWN);
            }
        };
        return MouseTargetFactory;
    }());
    exports.MouseTargetFactory = MouseTargetFactory;
});






define(__m[156], __M([0,1,3,39,11,112]), function (require, exports, lifecycle_1, mouseEvent_1, dom, globalMouseMoveMonitor_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditorMouseEvent = (function (_super) {
        __extends(EditorMouseEvent, _super);
        function EditorMouseEvent(e, editorViewDomNode) {
            _super.call(this, e);
            this.editorPos = dom.getDomNodePagePosition(editorViewDomNode);
            this.viewportx = this.posx - dom.StandardWindow.scrollX;
            this.viewporty = this.posy - dom.StandardWindow.scrollY;
        }
        return EditorMouseEvent;
    }(mouseEvent_1.StandardMouseEvent));
    exports.EditorMouseEvent = EditorMouseEvent;
    var EditorMouseEventFactory = (function () {
        function EditorMouseEventFactory(editorViewDomNode) {
            this._editorViewDomNode = editorViewDomNode;
        }
        EditorMouseEventFactory.prototype._create = function (e) {
            return new EditorMouseEvent(e, this._editorViewDomNode);
        };
        EditorMouseEventFactory.prototype.onContextMenu = function (target, callback) {
            var _this = this;
            return dom.addDisposableListener(target, 'contextmenu', function (e) {
                callback(_this._create(e));
            });
        };
        EditorMouseEventFactory.prototype.onMouseUp = function (target, callback) {
            var _this = this;
            return dom.addDisposableListener(target, 'mouseup', function (e) {
                callback(_this._create(e));
            });
        };
        EditorMouseEventFactory.prototype.onMouseDown = function (target, callback) {
            var _this = this;
            return dom.addDisposableListener(target, 'mousedown', function (e) {
                callback(_this._create(e));
            });
        };
        EditorMouseEventFactory.prototype.onMouseLeave = function (target, callback) {
            var _this = this;
            return dom.addDisposableNonBubblingMouseOutListener(target, function (e) {
                callback(_this._create(e));
            });
        };
        EditorMouseEventFactory.prototype.onMouseMoveThrottled = function (target, callback, merger, minimumTimeMs) {
            var _this = this;
            var myMerger = function (lastEvent, currentEvent) {
                return merger(lastEvent, _this._create(currentEvent));
            };
            return dom.addDisposableThrottledListener(target, 'mousemove', callback, myMerger, minimumTimeMs);
        };
        return EditorMouseEventFactory;
    }());
    exports.EditorMouseEventFactory = EditorMouseEventFactory;
    var GlobalEditorMouseMoveMonitor = (function (_super) {
        __extends(GlobalEditorMouseMoveMonitor, _super);
        function GlobalEditorMouseMoveMonitor(editorViewDomNode) {
            _super.call(this);
            this._editorViewDomNode = editorViewDomNode;
            this._globalMouseMoveMonitor = this._register(new globalMouseMoveMonitor_1.GlobalMouseMoveMonitor());
        }
        GlobalEditorMouseMoveMonitor.prototype.startMonitoring = function (merger, mouseMoveCallback, onStopCallback) {
            var _this = this;
            var myMerger = function (lastEvent, currentEvent) {
                return merger(lastEvent, new EditorMouseEvent(currentEvent, _this._editorViewDomNode));
            };
            this._globalMouseMoveMonitor.startMonitoring(myMerger, mouseMoveCallback, onStopCallback);
        };
        return GlobalEditorMouseMoveMonitor;
    }(lifecycle_1.Disposable));
    exports.GlobalEditorMouseMoveMonitor = GlobalEditorMouseMoveMonitor;
});






define(__m[271], __M([0,1,3,18,28,21,24,7,53,269,14,156]), function (require, exports, lifecycle_1, platform, browser, position_1, selection_1, editorCommon, viewEventHandler_1, mouseTarget_1, async_1, editorDom_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Merges mouse events when mouse move events are throttled
     */
    function createMouseMoveEventMerger(mouseTargetFactory) {
        return function (lastEvent, currentEvent) {
            var targetIsWidget = false;
            if (mouseTargetFactory) {
                targetIsWidget = mouseTargetFactory.mouseTargetIsWidget(currentEvent);
            }
            if (!targetIsWidget) {
                currentEvent.preventDefault();
            }
            return currentEvent;
        };
    }
    var EventGateKeeper = (function (_super) {
        __extends(EventGateKeeper, _super);
        function EventGateKeeper(destination, condition) {
            var _this = this;
            _super.call(this);
            this._destination = destination;
            this._condition = condition;
            this._retryTimer = this._register(new async_1.TimeoutTimer());
            this.handler = function (value) { return _this._handle(value); };
        }
        EventGateKeeper.prototype.dispose = function () {
            this._retryValue = null;
            _super.prototype.dispose.call(this);
        };
        EventGateKeeper.prototype._handle = function (value) {
            var _this = this;
            if (this._condition()) {
                this._retryTimer.cancel();
                this._retryValue = null;
                this._destination(value);
            }
            else {
                this._retryValue = value;
                this._retryTimer.setIfNotSet(function () {
                    var tmp = _this._retryValue;
                    _this._retryValue = null;
                    _this._handle(tmp);
                }, 10);
            }
        };
        return EventGateKeeper;
    }(lifecycle_1.Disposable));
    var MousePosition = (function () {
        function MousePosition(position, mouseColumn) {
            this.position = position;
            this.mouseColumn = mouseColumn;
        }
        return MousePosition;
    }());
    var MouseHandler = (function (_super) {
        __extends(MouseHandler, _super);
        function MouseHandler(context, viewController, viewHelper) {
            var _this = this;
            _super.call(this);
            this._context = context;
            this.viewController = viewController;
            this.viewHelper = viewHelper;
            this.mouseTargetFactory = new mouseTarget_1.MouseTargetFactory(this._context, viewHelper);
            this.listenersToRemove = [];
            this._mouseDownOperation = new MouseDownOperation(this._context, this.viewController, this.viewHelper, function (e, testEventTarget) { return _this._createMouseTarget(e, testEventTarget); }, function (e) { return _this._getMouseColumn(e); });
            this.toDispose = [];
            this.lastMouseLeaveTime = -1;
            var mouseEvents = new editorDom_1.EditorMouseEventFactory(this.viewHelper.viewDomNode);
            this.listenersToRemove.push(mouseEvents.onContextMenu(this.viewHelper.viewDomNode, function (e) { return _this._onContextMenu(e, true); }));
            this._mouseMoveEventHandler = new EventGateKeeper(function (e) { return _this._onMouseMove(e); }, function () { return !_this.viewHelper.isDirty(); });
            this.toDispose.push(this._mouseMoveEventHandler);
            this.listenersToRemove.push(mouseEvents.onMouseMoveThrottled(this.viewHelper.viewDomNode, this._mouseMoveEventHandler.handler, createMouseMoveEventMerger(this.mouseTargetFactory), MouseHandler.MOUSE_MOVE_MINIMUM_TIME));
            this.listenersToRemove.push(mouseEvents.onMouseUp(this.viewHelper.viewDomNode, function (e) { return _this._onMouseUp(e); }));
            this.listenersToRemove.push(mouseEvents.onMouseLeave(this.viewHelper.viewDomNode, function (e) { return _this._onMouseLeave(e); }));
            this.listenersToRemove.push(mouseEvents.onMouseDown(this.viewHelper.viewDomNode, function (e) { return _this._onMouseDown(e); }));
            this._context.addEventHandler(this);
        }
        MouseHandler.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);
            this.toDispose = lifecycle_1.dispose(this.toDispose);
            this._mouseDownOperation.dispose();
        };
        MouseHandler.prototype.onLayoutChanged = function (layoutInfo) {
            this._layoutInfo = layoutInfo;
            return false;
        };
        MouseHandler.prototype.onScrollChanged = function (e) {
            this._mouseDownOperation.onScrollChanged();
            return false;
        };
        MouseHandler.prototype.onCursorSelectionChanged = function (e) {
            this._mouseDownOperation.onCursorSelectionChanged(e);
            return false;
        };
        // --- end event handlers
        MouseHandler.prototype._createMouseTarget = function (e, testEventTarget) {
            return this.mouseTargetFactory.createMouseTarget(this._layoutInfo, e, testEventTarget);
        };
        MouseHandler.prototype._getMouseColumn = function (e) {
            return this.mouseTargetFactory.getMouseColumn(this._layoutInfo, e);
        };
        MouseHandler.prototype._onContextMenu = function (e, testEventTarget) {
            this.viewController.emitContextMenu({
                event: e,
                target: this._createMouseTarget(e, testEventTarget)
            });
        };
        MouseHandler.prototype._onMouseMove = function (e) {
            if (this._mouseDownOperation.isActive()) {
                // In selection/drag operation
                return;
            }
            var actualMouseMoveTime = e.timestamp;
            if (actualMouseMoveTime < this.lastMouseLeaveTime) {
                // Due to throttling, this event occured before the mouse left the editor, therefore ignore it.
                return;
            }
            this.viewController.emitMouseMove({
                event: e,
                target: this._createMouseTarget(e, true)
            });
        };
        MouseHandler.prototype._onMouseLeave = function (e) {
            this.lastMouseLeaveTime = (new Date()).getTime();
            this.viewController.emitMouseLeave({
                event: e,
                target: null
            });
        };
        MouseHandler.prototype._onMouseUp = function (e) {
            this.viewController.emitMouseUp({
                event: e,
                target: this._createMouseTarget(e, true)
            });
        };
        MouseHandler.prototype._onMouseDown = function (e) {
            var _this = this;
            var t = this._createMouseTarget(e, true);
            var targetIsContent = (t.type === editorCommon.MouseTargetType.CONTENT_TEXT || t.type === editorCommon.MouseTargetType.CONTENT_EMPTY);
            var targetIsGutter = (t.type === editorCommon.MouseTargetType.GUTTER_GLYPH_MARGIN || t.type === editorCommon.MouseTargetType.GUTTER_LINE_NUMBERS || t.type === editorCommon.MouseTargetType.GUTTER_LINE_DECORATIONS);
            var targetIsLineNumbers = (t.type === editorCommon.MouseTargetType.GUTTER_LINE_NUMBERS);
            var selectOnLineNumbers = this._context.configuration.editor.viewInfo.selectOnLineNumbers;
            var targetIsViewZone = (t.type === editorCommon.MouseTargetType.CONTENT_VIEW_ZONE || t.type === editorCommon.MouseTargetType.GUTTER_VIEW_ZONE);
            var shouldHandle = e.leftButton;
            if (platform.isMacintosh && e.ctrlKey) {
                shouldHandle = false;
            }
            if (shouldHandle && (targetIsContent || (targetIsLineNumbers && selectOnLineNumbers))) {
                if (browser.isIE11orEarlier) {
                    // IE does not want to focus when coming in from the browser's address bar
                    if (e.browserEvent.fromElement) {
                        e.preventDefault();
                        this.viewHelper.focusTextArea();
                    }
                    else {
                        // TODO@Alex -> cancel this if focus is lost
                        setTimeout(function () {
                            _this.viewHelper.focusTextArea();
                        });
                    }
                }
                else {
                    e.preventDefault();
                    this.viewHelper.focusTextArea();
                }
                this._mouseDownOperation.start(t.type, e);
            }
            else if (targetIsGutter) {
                // Do not steal focus
                e.preventDefault();
            }
            else if (targetIsViewZone) {
                var viewZoneData = t.detail;
                if (this.viewHelper.shouldSuppressMouseDownOnViewZone(viewZoneData.viewZoneId)) {
                    e.preventDefault();
                }
            }
            this.viewController.emitMouseDown({
                event: e,
                target: t
            });
        };
        MouseHandler.MOUSE_MOVE_MINIMUM_TIME = 100; // ms
        return MouseHandler;
    }(viewEventHandler_1.ViewEventHandler));
    exports.MouseHandler = MouseHandler;
    var MouseDownOperation = (function (_super) {
        __extends(MouseDownOperation, _super);
        function MouseDownOperation(context, viewController, viewHelper, createMouseTarget, getMouseColumn) {
            var _this = this;
            _super.call(this);
            this._context = context;
            this._viewController = viewController;
            this._viewHelper = viewHelper;
            this._createMouseTarget = createMouseTarget;
            this._getMouseColumn = getMouseColumn;
            this._currentSelection = new selection_1.Selection(1, 1, 1, 1);
            this._mouseState = new MouseDownState();
            this._onScrollTimeout = this._register(new async_1.TimeoutTimer());
            this._isActive = false;
            this._lastMouseEvent = null;
            this._mouseMoveMonitor = this._register(new editorDom_1.GlobalEditorMouseMoveMonitor(this._viewHelper.viewDomNode));
            this._mouseDownThenMoveEventHandler = this._register(new EventGateKeeper(function (e) { return _this._onMouseDownThenMove(e); }, function () { return !_this._viewHelper.isDirty(); }));
        }
        MouseDownOperation.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        MouseDownOperation.prototype.isActive = function () {
            return this._isActive;
        };
        MouseDownOperation.prototype._onMouseDownThenMove = function (e) {
            this._lastMouseEvent = e;
            this._mouseState.setModifiers(e);
            var position = this._findMousePosition(e, true);
            if (!position) {
                // Ignoring because position is unknown
                return;
            }
            this._dispatchMouse(position, true);
        };
        MouseDownOperation.prototype.start = function (targetType, e) {
            var _this = this;
            this._lastMouseEvent = e;
            this._mouseState.setStartedOnLineNumbers(targetType === editorCommon.MouseTargetType.GUTTER_LINE_NUMBERS);
            this._mouseState.setModifiers(e);
            var position = this._findMousePosition(e, true);
            if (!position) {
                // Ignoring because position is unknown
                return;
            }
            this._mouseState.trySetCount(e.detail, position.position);
            // Overwrite the detail of the MouseEvent, as it will be sent out in an event and contributions might rely on it.
            e.detail = this._mouseState.count;
            this._dispatchMouse(position, e.shiftKey);
            if (!this._isActive) {
                this._isActive = true;
                this._mouseMoveMonitor.startMonitoring(createMouseMoveEventMerger(null), this._mouseDownThenMoveEventHandler.handler, function () { return _this._stop(); });
            }
        };
        MouseDownOperation.prototype._stop = function () {
            this._isActive = false;
            this._onScrollTimeout.cancel();
        };
        MouseDownOperation.prototype.onScrollChanged = function () {
            var _this = this;
            if (!this._isActive) {
                return;
            }
            this._onScrollTimeout.setIfNotSet(function () {
                var position = _this._findMousePosition(_this._lastMouseEvent, false);
                if (!position) {
                    // Ignoring because position is unknown
                    return;
                }
                _this._dispatchMouse(position, true);
            }, 10);
        };
        MouseDownOperation.prototype.onCursorSelectionChanged = function (e) {
            this._currentSelection = e.selection;
        };
        MouseDownOperation.prototype._getPositionOutsideEditor = function (e) {
            var editorContent = e.editorPos;
            var mouseColumn = this._getMouseColumn(e);
            if (e.posy < editorContent.top) {
                var aboveLineNumber = this._viewHelper.getLineNumberAtVerticalOffset(Math.max(this._viewHelper.getScrollTop() - (editorContent.top - e.posy), 0));
                return new MousePosition(new position_1.Position(aboveLineNumber, 1), mouseColumn);
            }
            if (e.posy > editorContent.top + editorContent.height) {
                var belowLineNumber = this._viewHelper.getLineNumberAtVerticalOffset(this._viewHelper.getScrollTop() + (e.posy - editorContent.top));
                return new MousePosition(new position_1.Position(belowLineNumber, this._context.model.getLineMaxColumn(belowLineNumber)), mouseColumn);
            }
            var possibleLineNumber = this._viewHelper.getLineNumberAtVerticalOffset(this._viewHelper.getScrollTop() + (e.posy - editorContent.top));
            if (e.posx < editorContent.left) {
                return new MousePosition(new position_1.Position(possibleLineNumber, 1), mouseColumn);
            }
            if (e.posx > editorContent.left + editorContent.width) {
                return new MousePosition(new position_1.Position(possibleLineNumber, this._context.model.getLineMaxColumn(possibleLineNumber)), mouseColumn);
            }
            return null;
        };
        MouseDownOperation.prototype._findMousePosition = function (e, testEventTarget) {
            var positionOutsideEditor = this._getPositionOutsideEditor(e);
            if (positionOutsideEditor) {
                return positionOutsideEditor;
            }
            var t = this._createMouseTarget(e, testEventTarget);
            var hintedPosition = t.position;
            if (!hintedPosition) {
                return null;
            }
            if (t.type === editorCommon.MouseTargetType.CONTENT_VIEW_ZONE || t.type === editorCommon.MouseTargetType.GUTTER_VIEW_ZONE) {
                // Force position on view zones to go above or below depending on where selection started from
                var selectionStart = new position_1.Position(this._currentSelection.selectionStartLineNumber, this._currentSelection.selectionStartColumn);
                var viewZoneData = t.detail;
                var positionBefore = viewZoneData.positionBefore;
                var positionAfter = viewZoneData.positionAfter;
                if (positionBefore && positionAfter) {
                    if (positionBefore.isBefore(selectionStart)) {
                        return new MousePosition(positionBefore, t.mouseColumn);
                    }
                    else {
                        return new MousePosition(positionAfter, t.mouseColumn);
                    }
                }
            }
            return new MousePosition(hintedPosition, t.mouseColumn);
        };
        MouseDownOperation.prototype._dispatchMouse = function (position, inSelectionMode) {
            this._viewController.dispatchMouse({
                position: position.position,
                mouseColumn: position.mouseColumn,
                startedOnLineNumbers: this._mouseState.startedOnLineNumbers,
                inSelectionMode: inSelectionMode,
                mouseDownCount: this._mouseState.count,
                altKey: this._mouseState.altKey,
                ctrlKey: this._mouseState.ctrlKey,
                metaKey: this._mouseState.metaKey,
                shiftKey: this._mouseState.shiftKey,
            });
        };
        return MouseDownOperation;
    }(lifecycle_1.Disposable));
    var MouseDownState = (function () {
        function MouseDownState() {
            this._altKey = false;
            this._ctrlKey = false;
            this._metaKey = false;
            this._shiftKey = false;
            this._startedOnLineNumbers = false;
            this._lastMouseDownPosition = null;
            this._lastMouseDownPositionEqualCount = 0;
            this._lastMouseDownCount = 0;
            this._lastSetMouseDownCountTime = 0;
        }
        Object.defineProperty(MouseDownState.prototype, "altKey", {
            get: function () { return this._altKey; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MouseDownState.prototype, "ctrlKey", {
            get: function () { return this._ctrlKey; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MouseDownState.prototype, "metaKey", {
            get: function () { return this._metaKey; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MouseDownState.prototype, "shiftKey", {
            get: function () { return this._shiftKey; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MouseDownState.prototype, "startedOnLineNumbers", {
            get: function () { return this._startedOnLineNumbers; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MouseDownState.prototype, "count", {
            get: function () {
                return this._lastMouseDownCount;
            },
            enumerable: true,
            configurable: true
        });
        MouseDownState.prototype.setModifiers = function (source) {
            this._altKey = source.altKey;
            this._ctrlKey = source.ctrlKey;
            this._metaKey = source.metaKey;
            this._shiftKey = source.shiftKey;
        };
        MouseDownState.prototype.setStartedOnLineNumbers = function (startedOnLineNumbers) {
            this._startedOnLineNumbers = startedOnLineNumbers;
        };
        MouseDownState.prototype.trySetCount = function (setMouseDownCount, newMouseDownPosition) {
            // a. Invalidate multiple clicking if too much time has passed (will be hit by IE because the detail field of mouse events contains garbage in IE10)
            var currentTime = (new Date()).getTime();
            if (currentTime - this._lastSetMouseDownCountTime > MouseDownState.CLEAR_MOUSE_DOWN_COUNT_TIME) {
                setMouseDownCount = 1;
            }
            this._lastSetMouseDownCountTime = currentTime;
            // b. Ensure that we don't jump from single click to triple click in one go (will be hit by IE because the detail field of mouse events contains garbage in IE10)
            if (setMouseDownCount > this._lastMouseDownCount + 1) {
                setMouseDownCount = this._lastMouseDownCount + 1;
            }
            // c. Invalidate multiple clicking if the logical position is different
            if (this._lastMouseDownPosition && this._lastMouseDownPosition.equals(newMouseDownPosition)) {
                this._lastMouseDownPositionEqualCount++;
            }
            else {
                this._lastMouseDownPositionEqualCount = 1;
            }
            this._lastMouseDownPosition = newMouseDownPosition;
            // Finally set the lastMouseDownCount
            this._lastMouseDownCount = Math.min(setMouseDownCount, this._lastMouseDownPositionEqualCount);
        };
        MouseDownState.CLEAR_MOUSE_DOWN_COUNT_TIME = 400; // ms
        return MouseDownState;
    }());
});






define(__m[272], __M([0,1,11,69,271,156]), function (require, exports, dom, touch_1, mouseHandler_1, editorDom_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var gestureChangeEventMerger = function (lastEvent, currentEvent) {
        var r = {
            translationY: currentEvent.translationY,
            translationX: currentEvent.translationX
        };
        if (lastEvent) {
            r.translationY += lastEvent.translationY;
            r.translationX += lastEvent.translationX;
        }
        return r;
    };
    /**
     * Basically IE10 and IE11
     */
    var MsPointerHandler = (function (_super) {
        __extends(MsPointerHandler, _super);
        function MsPointerHandler(context, viewController, viewHelper) {
            var _this = this;
            _super.call(this, context, viewController, viewHelper);
            this.viewHelper.linesContentDomNode.style.msTouchAction = 'none';
            this.viewHelper.linesContentDomNode.style.msContentZooming = 'none';
            // TODO@Alex -> this expects that the view is added in 100 ms, might not be the case
            // This handler should be added when the dom node is in the dom tree
            this._installGestureHandlerTimeout = window.setTimeout(function () {
                _this._installGestureHandlerTimeout = -1;
                if (window.MSGesture) {
                    var touchGesture = new MSGesture();
                    var penGesture = new MSGesture();
                    touchGesture.target = _this.viewHelper.linesContentDomNode;
                    penGesture.target = _this.viewHelper.linesContentDomNode;
                    _this.viewHelper.linesContentDomNode.addEventListener('MSPointerDown', function (e) {
                        // Circumvent IE11 breaking change in e.pointerType & TypeScript's stale definitions
                        var pointerType = e.pointerType;
                        if (pointerType === (e.MSPOINTER_TYPE_MOUSE || 'mouse')) {
                            _this._lastPointerType = 'mouse';
                            return;
                        }
                        else if (pointerType === (e.MSPOINTER_TYPE_TOUCH || 'touch')) {
                            _this._lastPointerType = 'touch';
                            touchGesture.addPointer(e.pointerId);
                        }
                        else {
                            _this._lastPointerType = 'pen';
                            penGesture.addPointer(e.pointerId);
                        }
                    });
                    _this.listenersToRemove.push(dom.addDisposableThrottledListener(_this.viewHelper.linesContentDomNode, 'MSGestureChange', function (e) { return _this._onGestureChange(e); }, gestureChangeEventMerger));
                    _this.listenersToRemove.push(dom.addDisposableListener(_this.viewHelper.linesContentDomNode, 'MSGestureTap', function (e) { return _this._onCaptureGestureTap(e); }, true));
                }
            }, 100);
            this._lastPointerType = 'mouse';
        }
        MsPointerHandler.prototype._onMouseDown = function (e) {
            if (this._lastPointerType === 'mouse') {
                _super.prototype._onMouseDown.call(this, e);
            }
        };
        MsPointerHandler.prototype._onCaptureGestureTap = function (rawEvent) {
            var _this = this;
            var e = new editorDom_1.EditorMouseEvent(rawEvent, this.viewHelper.viewDomNode);
            var t = this._createMouseTarget(e, false);
            if (t.position) {
                this.viewController.moveTo('mouse', t.position);
            }
            // IE does not want to focus when coming in from the browser's address bar
            if (e.browserEvent.fromElement) {
                e.preventDefault();
                this.viewHelper.focusTextArea();
            }
            else {
                // TODO@Alex -> cancel this is focus is lost
                setTimeout(function () {
                    _this.viewHelper.focusTextArea();
                });
            }
        };
        MsPointerHandler.prototype._onGestureChange = function (e) {
            this.viewHelper.setScrollPosition({
                scrollLeft: this.viewHelper.getScrollLeft() - e.translationX,
                scrollTop: this.viewHelper.getScrollTop() - e.translationY,
            });
        };
        MsPointerHandler.prototype.dispose = function () {
            window.clearTimeout(this._installGestureHandlerTimeout);
            _super.prototype.dispose.call(this);
        };
        return MsPointerHandler;
    }(mouseHandler_1.MouseHandler));
    /**
     * Basically Edge but should be modified to handle any pointerEnabled, even without support of MSGesture
     */
    var StandardPointerHandler = (function (_super) {
        __extends(StandardPointerHandler, _super);
        function StandardPointerHandler(context, viewController, viewHelper) {
            var _this = this;
            _super.call(this, context, viewController, viewHelper);
            this.viewHelper.linesContentDomNode.style.touchAction = 'none';
            // TODO@Alex -> this expects that the view is added in 100 ms, might not be the case
            // This handler should be added when the dom node is in the dom tree
            this._installGestureHandlerTimeout = window.setTimeout(function () {
                _this._installGestureHandlerTimeout = -1;
                // TODO@Alex: replace the usage of MSGesture here with something that works across all browsers
                if (window.MSGesture) {
                    var touchGesture = new MSGesture();
                    var penGesture = new MSGesture();
                    touchGesture.target = _this.viewHelper.linesContentDomNode;
                    penGesture.target = _this.viewHelper.linesContentDomNode;
                    _this.viewHelper.linesContentDomNode.addEventListener('pointerdown', function (e) {
                        var pointerType = e.pointerType;
                        if (pointerType === 'mouse') {
                            _this._lastPointerType = 'mouse';
                            return;
                        }
                        else if (pointerType === 'touch') {
                            _this._lastPointerType = 'touch';
                            touchGesture.addPointer(e.pointerId);
                        }
                        else {
                            _this._lastPointerType = 'pen';
                            penGesture.addPointer(e.pointerId);
                        }
                    });
                    _this.listenersToRemove.push(dom.addDisposableThrottledListener(_this.viewHelper.linesContentDomNode, 'MSGestureChange', function (e) { return _this._onGestureChange(e); }, gestureChangeEventMerger));
                    _this.listenersToRemove.push(dom.addDisposableListener(_this.viewHelper.linesContentDomNode, 'MSGestureTap', function (e) { return _this._onCaptureGestureTap(e); }, true));
                }
            }, 100);
            this._lastPointerType = 'mouse';
        }
        StandardPointerHandler.prototype._onMouseDown = function (e) {
            if (this._lastPointerType === 'mouse') {
                _super.prototype._onMouseDown.call(this, e);
            }
        };
        StandardPointerHandler.prototype._onCaptureGestureTap = function (rawEvent) {
            var _this = this;
            var e = new editorDom_1.EditorMouseEvent(rawEvent, this.viewHelper.viewDomNode);
            var t = this._createMouseTarget(e, false);
            if (t.position) {
                this.viewController.moveTo('mouse', t.position);
            }
            // IE does not want to focus when coming in from the browser's address bar
            if (e.browserEvent.fromElement) {
                e.preventDefault();
                this.viewHelper.focusTextArea();
            }
            else {
                // TODO@Alex -> cancel this is focus is lost
                setTimeout(function () {
                    _this.viewHelper.focusTextArea();
                });
            }
        };
        StandardPointerHandler.prototype._onGestureChange = function (e) {
            this.viewHelper.setScrollPosition({
                scrollLeft: this.viewHelper.getScrollLeft() - e.translationX,
                scrollTop: this.viewHelper.getScrollTop() - e.translationY,
            });
        };
        StandardPointerHandler.prototype.dispose = function () {
            window.clearTimeout(this._installGestureHandlerTimeout);
            _super.prototype.dispose.call(this);
        };
        return StandardPointerHandler;
    }(mouseHandler_1.MouseHandler));
    var TouchHandler = (function (_super) {
        __extends(TouchHandler, _super);
        function TouchHandler(context, viewController, viewHelper) {
            var _this = this;
            _super.call(this, context, viewController, viewHelper);
            this.gesture = new touch_1.Gesture(this.viewHelper.linesContentDomNode);
            this.listenersToRemove.push(dom.addDisposableListener(this.viewHelper.linesContentDomNode, touch_1.EventType.Tap, function (e) { return _this.onTap(e); }));
            this.listenersToRemove.push(dom.addDisposableListener(this.viewHelper.linesContentDomNode, touch_1.EventType.Change, function (e) { return _this.onChange(e); }));
            this.listenersToRemove.push(dom.addDisposableListener(this.viewHelper.linesContentDomNode, touch_1.EventType.Contextmenu, function (e) { return _this._onContextMenu(new editorDom_1.EditorMouseEvent(e, _this.viewHelper.viewDomNode), false); }));
        }
        TouchHandler.prototype.dispose = function () {
            this.gesture.dispose();
            _super.prototype.dispose.call(this);
        };
        TouchHandler.prototype.onTap = function (event) {
            event.preventDefault();
            this.viewHelper.focusTextArea();
            var target = this._createMouseTarget(new editorDom_1.EditorMouseEvent(event, this.viewHelper.viewDomNode), false);
            if (target.position) {
                this.viewController.moveTo('mouse', target.position);
            }
        };
        TouchHandler.prototype.onChange = function (e) {
            this.viewHelper.setScrollPosition({
                scrollLeft: this.viewHelper.getScrollLeft() - e.translationX,
                scrollTop: this.viewHelper.getScrollTop() - e.translationY,
            });
        };
        return TouchHandler;
    }(mouseHandler_1.MouseHandler));
    var PointerHandler = (function () {
        function PointerHandler(context, viewController, viewHelper) {
            if (window.navigator.msPointerEnabled) {
                this.handler = new MsPointerHandler(context, viewController, viewHelper);
            }
            else if (window.TouchEvent) {
                this.handler = new TouchHandler(context, viewController, viewHelper);
            }
            else if (window.navigator.pointerEnabled) {
                this.handler = new StandardPointerHandler(context, viewController, viewHelper);
            }
            else {
                this.handler = new mouseHandler_1.MouseHandler(context, viewController, viewHelper);
            }
        }
        PointerHandler.prototype.onScrollChanged = function (e) {
            this.handler.onScrollChanged(e);
        };
        PointerHandler.prototype.dispose = function () {
            this.handler.dispose();
        };
        return PointerHandler;
    }());
    exports.PointerHandler = PointerHandler;
});






define(__m[159], __M([0,1,46,27]), function (require, exports, viewPart_1, styleMutator_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewLayer = (function (_super) {
        __extends(ViewLayer, _super);
        function ViewLayer(context) {
            var _this = this;
            _super.call(this, context);
            this.domNode = this._createDomNode();
            this._lines = [];
            this._rendLineNumberStart = 1;
            this._scrollDomNode = null;
            this._scrollDomNodeIsAbove = false;
            this._renderer = new ViewLayerRenderer(function () { return _this._createLine(); }, function () { return _this._extraDomNodeHTML(); });
        }
        ViewLayer.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._lines = null;
        };
        ViewLayer.prototype._extraDomNodeHTML = function () {
            return '';
        };
        // ---- begin view event handlers
        ViewLayer.prototype.onConfigurationChanged = function (e) {
            for (var i = 0; i < this._lines.length; i++) {
                this._lines[i].onConfigurationChanged(e);
            }
            return true;
        };
        ViewLayer.prototype.onLayoutChanged = function (layoutInfo) {
            return true;
        };
        ViewLayer.prototype.onScrollChanged = function (e) {
            return e.scrollTopChanged;
        };
        ViewLayer.prototype.onZonesChanged = function () {
            return true;
        };
        ViewLayer.prototype.onModelFlushed = function () {
            this._lines = [];
            this._rendLineNumberStart = 1;
            this._scrollDomNode = null;
            // No need to clear the dom node because a full .innerHTML will occur in ViewLayerRenderer._render
            return true;
        };
        ViewLayer.prototype.onModelLinesDeleted = function (e) {
            var from = Math.max(e.fromLineNumber - this._rendLineNumberStart, 0);
            var to = Math.min(e.toLineNumber - this._rendLineNumberStart, this._lines.length - 1);
            var i;
            // Adjust this._rendLineNumberStart
            if (e.fromLineNumber < this._rendLineNumberStart) {
                // Deleting lines starting above the viewport
                if (e.toLineNumber < this._rendLineNumberStart) {
                    // All deleted lines are above the viewport
                    this._rendLineNumberStart -= (e.toLineNumber - e.fromLineNumber + 1);
                }
                else {
                    // Some deleted lines are inside the viewport
                    this._rendLineNumberStart = e.fromLineNumber;
                }
            }
            // Remove lines if they fall in the viewport
            if (from <= to) {
                // Remove from DOM
                for (i = from; i <= to; i++) {
                    var lineDomNode = this._lines[i].getDomNode();
                    if (lineDomNode) {
                        this.domNode.domNode.removeChild(lineDomNode);
                    }
                }
                // Remove from array
                this._lines.splice(from, to - from + 1);
            }
            // Mark the rest of the visible lines as possibly invalid
            for (i = from; i < this._lines.length; i++) {
                this._lines[i].onLinesDeletedAbove();
            }
            return true;
        };
        ViewLayer.prototype.onModelLineChanged = function (e) {
            var lineIndex = e.lineNumber - this._rendLineNumberStart, shouldRender = false;
            if (lineIndex >= 0 && lineIndex < this._lines.length) {
                this._lines[lineIndex].onContentChanged();
                shouldRender = true;
            }
            // Mark the rest of the visible lines as possibly invalid
            for (var i = Math.max(lineIndex, 0); i < this._lines.length; i++) {
                this._lines[i].onLineChangedAbove();
                shouldRender = true;
            }
            return shouldRender;
        };
        ViewLayer.prototype.onModelLinesInserted = function (e) {
            var i;
            if (e.fromLineNumber <= this._rendLineNumberStart) {
                // a. We are inserting lines above the viewport
                this._rendLineNumberStart += (e.toLineNumber - e.fromLineNumber + 1);
                // Mark the visible lines as possibly invalid
                for (i = 0; i < this._lines.length; i++) {
                    this._lines[i].onLinesInsertedAbove();
                }
                return true;
            }
            if (e.fromLineNumber >= this._rendLineNumberStart + this._lines.length) {
                // b. We are inserting lines below the viewport
                return false;
            }
            // c. We are inserting lines in the viewport
            var insertFrom = Math.min(e.fromLineNumber - this._rendLineNumberStart, this._lines.length - 1);
            var insertTo = Math.min(e.toLineNumber - this._rendLineNumberStart, this._lines.length - 1);
            if (insertFrom <= insertTo) {
                // Insert lines that fall inside the viewport
                for (i = insertFrom; i <= insertTo; i++) {
                    var line = this._createLine();
                    this._lines.splice(i, 0, line);
                }
                // We need to remove lines that are pushed outside the viewport by this insertion,
                // due to the Math.min above on `insertTo`. Otherwise, it is possible for the next line
                // after the insertion to be marked `maybeInvalid` when it should be definitely `invalid`.
                var insertCount = insertTo - insertFrom + 1;
                for (i = 0; i < insertCount; i++) {
                    // Remove from array
                    var lastLine = this._lines.pop();
                    // Remove from DOM
                    var lineDomNode = lastLine.getDomNode();
                    if (lineDomNode) {
                        this.domNode.domNode.removeChild(lineDomNode);
                    }
                }
            }
            // Mark the rest of the lines as possibly invalid
            for (i = insertTo; i < this._lines.length; i++) {
                this._lines[i].onLinesInsertedAbove();
            }
            return true;
        };
        ViewLayer.prototype.onModelTokensChanged = function (e) {
            if (this._lines.length === 0) {
                return false;
            }
            var changedFromIndex = e.fromLineNumber - this._rendLineNumberStart;
            var changedToIndex = e.toLineNumber - this._rendLineNumberStart;
            if (changedToIndex < 0 || changedFromIndex >= this._lines.length) {
                return false;
            }
            var fromIndex = Math.min(Math.max(changedFromIndex, 0), this._lines.length - 1);
            var toIndex = Math.min(Math.max(changedToIndex, 0), this._lines.length - 1);
            var somethingMayHaveChanged = false;
            for (var i = fromIndex; i <= toIndex; i++) {
                somethingMayHaveChanged = true;
                this._lines[i].onTokensChanged();
            }
            return somethingMayHaveChanged;
        };
        // ---- end view event handlers
        ViewLayer.prototype._renderLines = function (linesViewportData) {
            var ctx = {
                domNode: this.domNode.domNode,
                rendLineNumberStart: this._rendLineNumberStart,
                lines: this._lines,
                linesLength: this._lines.length,
                getInlineDecorationsForLineInViewport: function (lineNumber) { return linesViewportData.getInlineDecorationsForLineInViewport(lineNumber); },
                viewportTop: linesViewportData.viewportTop,
                viewportHeight: linesViewportData.viewportHeight,
                scrollDomNode: this._scrollDomNode,
                scrollDomNodeIsAbove: this._scrollDomNodeIsAbove
            };
            // Decide if this render will do a single update (single large .innerHTML) or many updates (inserting/removing dom nodes)
            var resCtx = this._renderer.renderWithManyUpdates(ctx, linesViewportData.startLineNumber, linesViewportData.endLineNumber, linesViewportData.relativeVerticalOffset);
            this._rendLineNumberStart = resCtx.rendLineNumberStart;
            this._lines = resCtx.lines;
            this._scrollDomNode = resCtx.scrollDomNode;
            this._scrollDomNodeIsAbove = resCtx.scrollDomNodeIsAbove;
        };
        ViewLayer.prototype._createDomNode = function () {
            var domNode = styleMutator_1.createFastDomNode(document.createElement('div'));
            domNode.setClassName('view-layer');
            domNode.setPosition('absolute');
            domNode.domNode.setAttribute('role', 'presentation');
            domNode.domNode.setAttribute('aria-hidden', 'true');
            return domNode;
        };
        ViewLayer.prototype._createLine = function () {
            throw new Error('Implement me!');
        };
        return ViewLayer;
    }(viewPart_1.ViewPart));
    exports.ViewLayer = ViewLayer;
    var ViewLayerRenderer = (function () {
        function ViewLayerRenderer(createLine, extraDomNodeHTML) {
            this._createLine = createLine;
            this._extraDomNodeHTML = extraDomNodeHTML;
        }
        ViewLayerRenderer.prototype.renderWithManyUpdates = function (ctx, startLineNumber, stopLineNumber, deltaTop) {
            return this._render(ctx, startLineNumber, stopLineNumber, deltaTop);
        };
        ViewLayerRenderer.prototype._render = function (inContext, startLineNumber, stopLineNumber, deltaTop) {
            var ctx = {
                domNode: inContext.domNode,
                rendLineNumberStart: inContext.rendLineNumberStart,
                lines: inContext.lines.slice(0),
                linesLength: inContext.linesLength,
                getInlineDecorationsForLineInViewport: inContext.getInlineDecorationsForLineInViewport,
                viewportTop: inContext.viewportTop,
                viewportHeight: inContext.viewportHeight,
                scrollDomNode: inContext.scrollDomNode,
                scrollDomNodeIsAbove: inContext.scrollDomNodeIsAbove
            };
            var canRemoveScrollDomNode = true;
            if (ctx.scrollDomNode) {
                var time = this._getScrollDomNodeTime(ctx.scrollDomNode);
                if ((new Date()).getTime() - time < 1000) {
                    canRemoveScrollDomNode = false;
                }
            }
            if (canRemoveScrollDomNode && ((ctx.rendLineNumberStart + ctx.linesLength - 1 < startLineNumber) || (stopLineNumber < ctx.rendLineNumberStart))) {
                // There is no overlap whatsoever
                ctx.rendLineNumberStart = startLineNumber;
                ctx.linesLength = stopLineNumber - startLineNumber + 1;
                ctx.lines = [];
                for (var x = startLineNumber; x <= stopLineNumber; x++) {
                    ctx.lines[x - startLineNumber] = this._createLine();
                }
                this._finishRendering(ctx, true, deltaTop);
                ctx.scrollDomNode = null;
                return ctx;
            }
            // Update lines which will remain untouched
            this._renderUntouchedLines(ctx, Math.max(startLineNumber - ctx.rendLineNumberStart, 0), Math.min(stopLineNumber - ctx.rendLineNumberStart, ctx.linesLength - 1), deltaTop, startLineNumber);
            var fromLineNumber, toLineNumber, removeCnt;
            if (ctx.rendLineNumberStart > startLineNumber) {
                // Insert lines before
                fromLineNumber = startLineNumber;
                toLineNumber = Math.min(stopLineNumber, ctx.rendLineNumberStart - 1);
                if (fromLineNumber <= toLineNumber) {
                    this._insertLinesBefore(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);
                    ctx.linesLength += toLineNumber - fromLineNumber + 1;
                    // Clean garbage above
                    if (ctx.scrollDomNode && ctx.scrollDomNodeIsAbove) {
                        if (ctx.scrollDomNode.parentNode) {
                            ctx.scrollDomNode.parentNode.removeChild(ctx.scrollDomNode);
                        }
                        ctx.scrollDomNode = null;
                    }
                }
            }
            else if (ctx.rendLineNumberStart < startLineNumber) {
                // Remove lines before
                removeCnt = Math.min(ctx.linesLength, startLineNumber - ctx.rendLineNumberStart);
                if (removeCnt > 0) {
                    this._removeLinesBefore(ctx, removeCnt);
                    ctx.linesLength -= removeCnt;
                }
            }
            ctx.rendLineNumberStart = startLineNumber;
            if (ctx.rendLineNumberStart + ctx.linesLength - 1 < stopLineNumber) {
                // Insert lines after
                fromLineNumber = ctx.rendLineNumberStart + ctx.linesLength;
                toLineNumber = stopLineNumber;
                if (fromLineNumber <= toLineNumber) {
                    this._insertLinesAfter(ctx, fromLineNumber, toLineNumber, deltaTop, startLineNumber);
                    ctx.linesLength += toLineNumber - fromLineNumber + 1;
                    // Clean garbage below
                    if (ctx.scrollDomNode && !ctx.scrollDomNodeIsAbove) {
                        if (ctx.scrollDomNode.parentNode) {
                            ctx.scrollDomNode.parentNode.removeChild(ctx.scrollDomNode);
                        }
                        ctx.scrollDomNode = null;
                    }
                }
            }
            else if (ctx.rendLineNumberStart + ctx.linesLength - 1 > stopLineNumber) {
                // Remove lines after
                fromLineNumber = Math.max(0, stopLineNumber - ctx.rendLineNumberStart + 1);
                toLineNumber = ctx.linesLength - 1;
                removeCnt = toLineNumber - fromLineNumber + 1;
                if (removeCnt > 0) {
                    this._removeLinesAfter(ctx, removeCnt);
                    ctx.linesLength -= removeCnt;
                }
            }
            this._finishRendering(ctx, false, deltaTop);
            return ctx;
        };
        ViewLayerRenderer.prototype._renderUntouchedLines = function (ctx, startIndex, endIndex, deltaTop, deltaLN) {
            var i, lineNumber;
            for (i = startIndex; i <= endIndex; i++) {
                lineNumber = ctx.rendLineNumberStart + i;
                var lineDomNode = ctx.lines[i].getDomNode();
                if (lineDomNode) {
                    ctx.lines[i].layoutLine(lineNumber, deltaTop[lineNumber - deltaLN]);
                }
            }
        };
        ViewLayerRenderer.prototype._insertLinesBefore = function (ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {
            var newLines = [], line, lineNumber;
            for (lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
                line = this._createLine();
                newLines.push(line);
            }
            ctx.lines = newLines.concat(ctx.lines);
        };
        ViewLayerRenderer.prototype._getScrollDomNodeTime = function (domNode) {
            var lastScrollTime = domNode.getAttribute('last-scroll-time');
            if (lastScrollTime) {
                return parseInt(lastScrollTime, 10);
            }
            return 0;
        };
        ViewLayerRenderer.prototype._removeIfNotScrollDomNode = function (ctx, domNode, isAbove) {
            var time = this._getScrollDomNodeTime(domNode);
            if (!time) {
                ctx.domNode.removeChild(domNode);
                return;
            }
            if (ctx.scrollDomNode) {
                var otherTime = this._getScrollDomNodeTime(ctx.scrollDomNode);
                if (otherTime > time) {
                    // The other is the real scroll dom node
                    ctx.domNode.removeChild(domNode);
                    return;
                }
                if (ctx.scrollDomNode.parentNode) {
                    ctx.scrollDomNode.parentNode.removeChild(ctx.scrollDomNode);
                }
                ctx.scrollDomNode = null;
            }
            ctx.scrollDomNode = domNode;
            ctx.scrollDomNodeIsAbove = isAbove;
        };
        ViewLayerRenderer.prototype._removeLinesBefore = function (ctx, removeCount) {
            var i;
            for (i = 0; i < removeCount; i++) {
                var lineDomNode = ctx.lines[i].getDomNode();
                if (lineDomNode) {
                    this._removeIfNotScrollDomNode(ctx, lineDomNode, true);
                }
            }
            ctx.lines.splice(0, removeCount);
        };
        ViewLayerRenderer.prototype._insertLinesAfter = function (ctx, fromLineNumber, toLineNumber, deltaTop, deltaLN) {
            var newLines = [], line, lineNumber;
            for (lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
                line = this._createLine();
                newLines.push(line);
            }
            ctx.lines = ctx.lines.concat(newLines);
        };
        ViewLayerRenderer.prototype._removeLinesAfter = function (ctx, removeCount) {
            var i, removeIndex = ctx.linesLength - removeCount;
            for (i = 0; i < removeCount; i++) {
                var lineDomNode = ctx.lines[removeIndex + i].getDomNode();
                if (lineDomNode) {
                    this._removeIfNotScrollDomNode(ctx, lineDomNode, false);
                }
            }
            ctx.lines.splice(removeIndex, removeCount);
        };
        ViewLayerRenderer._resolveInlineDecorations = function (ctx) {
            var result = [];
            for (var i = 0, len = ctx.linesLength; i < len; i++) {
                var lineNumber = i + ctx.rendLineNumberStart;
                result[i] = ctx.getInlineDecorationsForLineInViewport(lineNumber);
            }
            return result;
        };
        ViewLayerRenderer.prototype._finishRenderingNewLines = function (ctx, domNodeIsEmpty, newLinesHTML, wasNew) {
            var lastChild = ctx.domNode.lastChild;
            if (domNodeIsEmpty || !lastChild) {
                ctx.domNode.innerHTML = this._extraDomNodeHTML() + newLinesHTML.join('');
            }
            else {
                lastChild.insertAdjacentHTML('afterend', newLinesHTML.join(''));
            }
            var currChild = ctx.domNode.lastChild;
            for (var i = ctx.linesLength - 1; i >= 0; i--) {
                var line = ctx.lines[i];
                if (wasNew[i]) {
                    line.setDomNode(currChild);
                    currChild = currChild.previousSibling;
                }
            }
        };
        ViewLayerRenderer.prototype._finishRenderingInvalidLines = function (ctx, invalidLinesHTML, wasInvalid) {
            var hugeDomNode = document.createElement('div');
            hugeDomNode.innerHTML = invalidLinesHTML.join('');
            var lineDomNode, source;
            for (var i = 0; i < ctx.linesLength; i++) {
                var line = ctx.lines[i];
                if (wasInvalid[i]) {
                    source = hugeDomNode.firstChild;
                    lineDomNode = line.getDomNode();
                    lineDomNode.parentNode.replaceChild(source, lineDomNode);
                    line.setDomNode(source);
                }
            }
        };
        ViewLayerRenderer.prototype._finishRendering = function (ctx, domNodeIsEmpty, deltaTop) {
            var inlineDecorations = ViewLayerRenderer._resolveInlineDecorations(ctx);
            var i, len, line, lineNumber, hadNewLine = false, wasNew = [], newLinesHTML = [], hadInvalidLine = false, wasInvalid = [], invalidLinesHTML = [];
            for (i = 0, len = ctx.linesLength; i < len; i++) {
                line = ctx.lines[i];
                lineNumber = i + ctx.rendLineNumberStart;
                if (line.shouldUpdateHTML(ctx.rendLineNumberStart, lineNumber, inlineDecorations[i])) {
                    var lineDomNode = line.getDomNode();
                    if (!lineDomNode) {
                        // Line is new
                        line.getLineOuterHTML(newLinesHTML, lineNumber, deltaTop[i]);
                        wasNew[i] = true;
                        hadNewLine = true;
                    }
                    else {
                        // Line is invalid
                        line.getLineOuterHTML(invalidLinesHTML, lineNumber, deltaTop[i]);
                        wasInvalid[i] = true;
                        hadInvalidLine = true;
                    }
                }
            }
            if (hadNewLine) {
                this._finishRenderingNewLines(ctx, domNodeIsEmpty, newLinesHTML, wasNew);
            }
            if (hadInvalidLine) {
                this._finishRenderingInvalidLines(ctx, invalidLinesHTML, wasInvalid);
            }
        };
        return ViewLayerRenderer;
    }());
});

define(__m[274], __M([0,1,3,11,87,7,22]), function (require, exports, lifecycle_1, dom, scrollableElement_1, editorCommon_1, editorBrowser_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function addPropertyIfPresent(src, dst, prop) {
        if (src.hasOwnProperty(prop)) {
            dst[prop] = src[prop];
        }
    }
    var ScrollManager = (function () {
        function ScrollManager(configuration, privateViewEventBus, linesContent, viewDomNode, overflowGuardDomNode) {
            var _this = this;
            this.toDispose = [];
            this.configuration = configuration;
            this.privateViewEventBus = privateViewEventBus;
            this.linesContent = linesContent;
            var configScrollbarOpts = this.configuration.editor.viewInfo.scrollbar;
            var scrollbarOptions = {
                canUseTranslate3d: this.configuration.editor.viewInfo.canUseTranslate3d,
                listenOnDomNode: viewDomNode,
                vertical: configScrollbarOpts.vertical,
                horizontal: configScrollbarOpts.horizontal,
                className: editorBrowser_1.ClassNames.SCROLLABLE_ELEMENT + ' ' + this.configuration.editor.viewInfo.theme,
                useShadows: false,
                lazyRender: true,
                saveLastScrollTimeOnClassName: editorBrowser_1.ClassNames.VIEW_LINE
            };
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'verticalHasArrows');
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'horizontalHasArrows');
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'verticalScrollbarSize');
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'verticalSliderSize');
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'horizontalScrollbarSize');
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'horizontalSliderSize');
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'handleMouseWheel');
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'arrowSize');
            addPropertyIfPresent(configScrollbarOpts, scrollbarOptions, 'mouseWheelScrollSensitivity');
            this.scrollbar = new scrollableElement_1.ScrollableElement(linesContent, scrollbarOptions);
            this.onLayoutInfoChanged();
            this.toDispose.push(this.scrollbar);
            this.toDispose.push(this.scrollbar.onScroll(function (e) {
                _this.privateViewEventBus.emit(editorCommon_1.EventType.ViewScrollChanged, e);
            }));
            this.toDispose.push(this.configuration.onDidChange(function (e) {
                _this.scrollbar.updateClassName(editorBrowser_1.ClassNames.SCROLLABLE_ELEMENT + ' ' + _this.configuration.editor.viewInfo.theme);
                if (e.viewInfo.scrollbar || e.viewInfo.canUseTranslate3d) {
                    var newOpts = {
                        canUseTranslate3d: _this.configuration.editor.viewInfo.canUseTranslate3d,
                        handleMouseWheel: _this.configuration.editor.viewInfo.scrollbar.handleMouseWheel,
                        mouseWheelScrollSensitivity: _this.configuration.editor.viewInfo.scrollbar.mouseWheelScrollSensitivity
                    };
                    _this.scrollbar.updateOptions(newOpts);
                }
            }));
            // When having a zone widget that calls .focus() on one of its dom elements,
            // the browser will try desperately to reveal that dom node, unexpectedly
            // changing the .scrollTop of this.linesContent
            var onBrowserDesperateReveal = function (domNode, lookAtScrollTop, lookAtScrollLeft) {
                var newScrollPosition = {};
                if (lookAtScrollTop) {
                    var deltaTop = domNode.scrollTop;
                    if (deltaTop) {
                        newScrollPosition.scrollTop = _this.getScrollTop() + deltaTop;
                        domNode.scrollTop = 0;
                    }
                }
                if (lookAtScrollLeft) {
                    var deltaLeft = domNode.scrollLeft;
                    if (deltaLeft) {
                        newScrollPosition.scrollLeft = _this.getScrollLeft() + deltaLeft;
                        domNode.scrollLeft = 0;
                    }
                }
                _this.setScrollPosition(newScrollPosition);
            };
            // I've seen this happen both on the view dom node & on the lines content dom node.
            this.toDispose.push(dom.addDisposableListener(viewDomNode, 'scroll', function (e) { return onBrowserDesperateReveal(viewDomNode, true, true); }));
            this.toDispose.push(dom.addDisposableListener(linesContent, 'scroll', function (e) { return onBrowserDesperateReveal(linesContent, true, false); }));
            this.toDispose.push(dom.addDisposableListener(overflowGuardDomNode, 'scroll', function (e) { return onBrowserDesperateReveal(overflowGuardDomNode, true, false); }));
        }
        ScrollManager.prototype.dispose = function () {
            this.toDispose = lifecycle_1.dispose(this.toDispose);
        };
        ScrollManager.prototype.renderScrollbar = function () {
            this.scrollbar.renderNow();
        };
        ScrollManager.prototype.onLayoutInfoChanged = function () {
            this.scrollbar.updateState({
                width: this.configuration.editor.layoutInfo.contentWidth,
                height: this.configuration.editor.layoutInfo.contentHeight
            });
        };
        ScrollManager.prototype.getOverviewRulerLayoutInfo = function () {
            return this.scrollbar.getOverviewRulerLayoutInfo();
        };
        ScrollManager.prototype.getScrollbarContainerDomNode = function () {
            return this.scrollbar.getDomNode();
        };
        ScrollManager.prototype.delegateVerticalScrollbarMouseDown = function (browserEvent) {
            this.scrollbar.delegateVerticalScrollbarMouseDown(browserEvent);
        };
        ScrollManager.prototype.getWidth = function () {
            return this.scrollbar.getWidth();
        };
        ScrollManager.prototype.getScrollWidth = function () {
            return this.scrollbar.getScrollWidth();
        };
        ScrollManager.prototype.getScrollLeft = function () {
            return this.scrollbar.getScrollLeft();
        };
        ScrollManager.prototype.getHeight = function () {
            return this.scrollbar.getHeight();
        };
        ScrollManager.prototype.getScrollHeight = function () {
            return this.scrollbar.getScrollHeight();
        };
        ScrollManager.prototype.getScrollTop = function () {
            return this.scrollbar.getScrollTop();
        };
        ScrollManager.prototype.setScrollPosition = function (position) {
            this.scrollbar.updateState(position);
        };
        ScrollManager.prototype.setScrollHeight = function (scrollHeight) {
            this.scrollbar.updateState({
                scrollHeight: scrollHeight
            });
        };
        ScrollManager.prototype.setScrollWidth = function (scrollWidth) {
            this.scrollbar.updateState({
                scrollWidth: scrollWidth
            });
        };
        return ScrollManager;
    }());
    exports.ScrollManager = ScrollManager;
});






define(__m[275], __M([0,1,7,409,53,274]), function (require, exports, editorCommon, linesLayout_1, viewEventHandler_1, scrollManager_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LayoutProvider = (function (_super) {
        __extends(LayoutProvider, _super);
        function LayoutProvider(configuration, model, privateViewEventBus, linesContent, viewDomNode, overflowGuardDomNode) {
            _super.call(this);
            this.configuration = configuration;
            this.privateViewEventBus = privateViewEventBus;
            this.model = model;
            this.scrollManager = new scrollManager_1.ScrollManager(configuration, privateViewEventBus, linesContent, viewDomNode, overflowGuardDomNode);
            this.configuration.setLineCount(this.model.getLineCount());
            this.linesLayout = new linesLayout_1.LinesLayout(configuration, model);
            this._updateHeight();
        }
        LayoutProvider.prototype.dispose = function () {
            this.scrollManager.dispose();
        };
        LayoutProvider.prototype.updateLineCount = function () {
            this.configuration.setLineCount(this.model.getLineCount());
        };
        // ---- begin view event handlers
        LayoutProvider.prototype.onZonesChanged = function () {
            this._updateHeight();
            return false;
        };
        LayoutProvider.prototype.onModelFlushed = function () {
            this.linesLayout.onModelFlushed();
            this.updateLineCount();
            this._updateHeight();
            return false;
        };
        LayoutProvider.prototype.onModelLinesDeleted = function (e) {
            this.linesLayout.onModelLinesDeleted(e);
            this.updateLineCount();
            this._updateHeight();
            return false;
        };
        LayoutProvider.prototype.onModelLinesInserted = function (e) {
            this.linesLayout.onModelLinesInserted(e);
            this.updateLineCount();
            this._updateHeight();
            return false;
        };
        LayoutProvider.prototype.onConfigurationChanged = function (e) {
            this.linesLayout.onConfigurationChanged(e);
            if (e.layoutInfo) {
                this.scrollManager.onLayoutInfoChanged();
                this._emitLayoutChangedEvent();
            }
            this._updateHeight();
            return false;
        };
        LayoutProvider.prototype._updateHeight = function () {
            this.scrollManager.setScrollHeight(this.getTotalHeight());
        };
        // ---- end view event handlers
        // ---- Layouting logic
        LayoutProvider.prototype.getCurrentViewport = function () {
            return new editorCommon.Viewport(this.scrollManager.getScrollTop(), this.scrollManager.getScrollLeft(), this.scrollManager.getWidth(), this.scrollManager.getHeight());
        };
        LayoutProvider.prototype.getCenteredViewLineNumberInViewport = function () {
            return this.linesLayout.getCenteredLineInViewport(this.getCurrentViewport());
        };
        LayoutProvider.prototype._emitLayoutChangedEvent = function () {
            this.privateViewEventBus.emit(editorCommon.EventType.ViewLayoutChanged, this.configuration.editor.layoutInfo);
        };
        LayoutProvider.prototype.emitLayoutChangedEvent = function () {
            this._emitLayoutChangedEvent();
        };
        LayoutProvider.prototype._computeScrollWidth = function (maxLineWidth, viewportWidth) {
            var isViewportWrapping = this.configuration.editor.wrappingInfo.isViewportWrapping;
            if (!isViewportWrapping) {
                return Math.max(maxLineWidth + LayoutProvider.LINES_HORIZONTAL_EXTRA_PX, viewportWidth);
            }
            return Math.max(maxLineWidth, viewportWidth);
        };
        LayoutProvider.prototype.onMaxLineWidthChanged = function (maxLineWidth) {
            var newScrollWidth = this._computeScrollWidth(maxLineWidth, this.getCurrentViewport().width);
            this.scrollManager.setScrollWidth(newScrollWidth);
            // The height might depend on the fact that there is a horizontal scrollbar or not
            this._updateHeight();
        };
        // ---- view state
        LayoutProvider.prototype.saveState = function () {
            var scrollTop = this.scrollManager.getScrollTop();
            var firstLineNumberInViewport = this.linesLayout.getLineNumberAtOrAfterVerticalOffset(scrollTop);
            var whitespaceAboveFirstLine = this.linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(firstLineNumberInViewport);
            return {
                scrollTop: scrollTop,
                scrollTopWithoutViewZones: scrollTop - whitespaceAboveFirstLine,
                scrollLeft: this.scrollManager.getScrollLeft()
            };
        };
        LayoutProvider.prototype.restoreState = function (state) {
            var restoreScrollTop = state.scrollTop;
            if (typeof state.scrollTopWithoutViewZones === 'number' && !this.linesLayout.hasWhitespace()) {
                restoreScrollTop = state.scrollTopWithoutViewZones;
            }
            this.scrollManager.setScrollPosition({
                scrollLeft: state.scrollLeft,
                scrollTop: restoreScrollTop
            });
        };
        // ---- IVerticalLayoutProvider
        LayoutProvider.prototype.addWhitespace = function (afterLineNumber, ordinal, height) {
            return this.linesLayout.insertWhitespace(afterLineNumber, ordinal, height);
        };
        LayoutProvider.prototype.changeWhitespace = function (id, newAfterLineNumber, newHeight) {
            return this.linesLayout.changeWhitespace(id, newAfterLineNumber, newHeight);
        };
        LayoutProvider.prototype.removeWhitespace = function (id) {
            return this.linesLayout.removeWhitespace(id);
        };
        LayoutProvider.prototype.getVerticalOffsetForLineNumber = function (lineNumber) {
            return this.linesLayout.getVerticalOffsetForLineNumber(lineNumber);
        };
        LayoutProvider.prototype.heightInPxForLine = function (lineNumber) {
            return this.linesLayout.getHeightForLineNumber(lineNumber);
        };
        LayoutProvider.prototype.isAfterLines = function (verticalOffset) {
            return this.linesLayout.isAfterLines(verticalOffset);
        };
        LayoutProvider.prototype.getLineNumberAtVerticalOffset = function (verticalOffset) {
            return this.linesLayout.getLineNumberAtOrAfterVerticalOffset(verticalOffset);
        };
        LayoutProvider.prototype.getTotalHeight = function () {
            var reserveHorizontalScrollbarHeight = 0;
            if (this.scrollManager.getScrollWidth() > this.scrollManager.getWidth()) {
                reserveHorizontalScrollbarHeight = this.configuration.editor.viewInfo.scrollbar.horizontalScrollbarSize;
            }
            return this.linesLayout.getTotalHeight(this.getCurrentViewport(), reserveHorizontalScrollbarHeight);
        };
        LayoutProvider.prototype.getWhitespaceAtVerticalOffset = function (verticalOffset) {
            return this.linesLayout.getWhitespaceAtVerticalOffset(verticalOffset);
        };
        LayoutProvider.prototype.getLinesViewportData = function () {
            return this.linesLayout.getLinesViewportData(this.getCurrentViewport());
        };
        LayoutProvider.prototype.getWhitespaceViewportData = function () {
            return this.linesLayout.getWhitespaceViewportData(this.getCurrentViewport());
        };
        LayoutProvider.prototype.getWhitespaces = function () {
            return this.linesLayout.getWhitespaces();
        };
        // ---- IScrollingProvider
        LayoutProvider.prototype.getOverviewRulerInsertData = function () {
            var layoutInfo = this.scrollManager.getOverviewRulerLayoutInfo();
            return {
                parent: layoutInfo.parent,
                insertBefore: layoutInfo.insertBefore
            };
        };
        LayoutProvider.prototype.getScrollbarContainerDomNode = function () {
            return this.scrollManager.getScrollbarContainerDomNode();
        };
        LayoutProvider.prototype.delegateVerticalScrollbarMouseDown = function (browserEvent) {
            this.scrollManager.delegateVerticalScrollbarMouseDown(browserEvent);
        };
        LayoutProvider.prototype.getScrollWidth = function () {
            return this.scrollManager.getScrollWidth();
        };
        LayoutProvider.prototype.getScrollLeft = function () {
            return this.scrollManager.getScrollLeft();
        };
        LayoutProvider.prototype.getScrollHeight = function () {
            return this.scrollManager.getScrollHeight();
        };
        LayoutProvider.prototype.getScrollTop = function () {
            return this.scrollManager.getScrollTop();
        };
        LayoutProvider.prototype.setScrollPosition = function (position) {
            this.scrollManager.setScrollPosition(position);
        };
        LayoutProvider.prototype.getScrolledTopFromAbsoluteTop = function (top) {
            return top - this.scrollManager.getScrollTop();
        };
        LayoutProvider.prototype.renderScrollbar = function () {
            this.scrollManager.renderScrollbar();
        };
        LayoutProvider.LINES_HORIZONTAL_EXTRA_PX = 30;
        return LayoutProvider;
    }(viewEventHandler_1.ViewEventHandler));
    exports.LayoutProvider = LayoutProvider;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[276], __M([0,1,11,27,22,46,443]), function (require, exports, dom, styleMutator_1, editorBrowser_1, viewPart_1) {
    'use strict';
    var ViewContentWidgets = (function (_super) {
        __extends(ViewContentWidgets, _super);
        function ViewContentWidgets(context, viewDomNode) {
            _super.call(this, context);
            this._viewDomNode = viewDomNode;
            this._widgets = {};
            this._contentWidth = 0;
            this._contentLeft = 0;
            this._lineHeight = this._context.configuration.editor.lineHeight;
            this._renderData = {};
            this.domNode = document.createElement('div');
            this.domNode.className = editorBrowser_1.ClassNames.CONTENT_WIDGETS;
            this.overflowingContentWidgetsDomNode = document.createElement('div');
            this.overflowingContentWidgetsDomNode.className = editorBrowser_1.ClassNames.OVERFLOWING_CONTENT_WIDGETS;
        }
        ViewContentWidgets.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._widgets = null;
            this.domNode = null;
        };
        // --- begin event handlers
        ViewContentWidgets.prototype.onModelFlushed = function () {
            return true;
        };
        ViewContentWidgets.prototype.onModelDecorationsChanged = function (e) {
            // true for inline decorations that can end up relayouting text
            return e.inlineDecorationsChanged;
        };
        ViewContentWidgets.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        ViewContentWidgets.prototype.onModelLineChanged = function (e) {
            return true;
        };
        ViewContentWidgets.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        ViewContentWidgets.prototype.onCursorPositionChanged = function (e) {
            return false;
        };
        ViewContentWidgets.prototype.onCursorSelectionChanged = function (e) {
            return false;
        };
        ViewContentWidgets.prototype.onCursorRevealRange = function (e) {
            return false;
        };
        ViewContentWidgets.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            return true;
        };
        ViewContentWidgets.prototype.onLayoutChanged = function (layoutInfo) {
            this._contentLeft = layoutInfo.contentLeft;
            if (this._contentWidth !== layoutInfo.contentWidth) {
                this._contentWidth = layoutInfo.contentWidth;
                // update the maxWidth on widgets nodes, such that `onReadAfterForcedLayout`
                // below can read out the adjusted width/height of widgets
                var keys = Object.keys(this._widgets);
                for (var i = 0, len = keys.length; i < len; i++) {
                    var widgetId = keys[i];
                    styleMutator_1.StyleMutator.setMaxWidth(this._widgets[widgetId].widget.getDomNode(), this._contentWidth);
                }
            }
            return true;
        };
        ViewContentWidgets.prototype.onScrollChanged = function (e) {
            return true;
        };
        ViewContentWidgets.prototype.onZonesChanged = function () {
            return true;
        };
        // ---- end view event handlers
        ViewContentWidgets.prototype.addWidget = function (widget) {
            var widgetData = {
                allowEditorOverflow: widget.allowEditorOverflow || false,
                widget: widget,
                position: null,
                preference: null,
                isVisible: false
            };
            this._widgets[widget.getId()] = widgetData;
            var domNode = widget.getDomNode();
            domNode.style.position = 'absolute';
            styleMutator_1.StyleMutator.setMaxWidth(domNode, this._contentWidth);
            styleMutator_1.StyleMutator.setVisibility(domNode, 'hidden');
            domNode.setAttribute('widgetId', widget.getId());
            if (widgetData.allowEditorOverflow) {
                this.overflowingContentWidgetsDomNode.appendChild(domNode);
            }
            else {
                this.domNode.appendChild(domNode);
            }
            this.setShouldRender();
        };
        ViewContentWidgets.prototype.setWidgetPosition = function (widget, position, preference) {
            var widgetData = this._widgets[widget.getId()];
            widgetData.position = position;
            widgetData.preference = preference;
            this.setShouldRender();
        };
        ViewContentWidgets.prototype.removeWidget = function (widget) {
            var widgetId = widget.getId();
            if (this._widgets.hasOwnProperty(widgetId)) {
                var widgetData = this._widgets[widgetId];
                delete this._widgets[widgetId];
                var domNode = widgetData.widget.getDomNode();
                domNode.parentNode.removeChild(domNode);
                domNode.removeAttribute('monaco-visible-content-widget');
                this.setShouldRender();
            }
        };
        ViewContentWidgets.prototype._layoutBoxInViewport = function (position, domNode, ctx) {
            var visibleRange = ctx.visibleRangeForPosition(position);
            if (!visibleRange) {
                return null;
            }
            var width = domNode.clientWidth;
            var height = domNode.clientHeight;
            // Our visible box is split horizontally by the current line => 2 boxes
            // a) the box above the line
            var aboveLineTop = visibleRange.top;
            var heightAboveLine = aboveLineTop;
            // b) the box under the line
            var underLineTop = visibleRange.top + this._lineHeight;
            var heightUnderLine = ctx.viewportHeight - underLineTop;
            var aboveTop = aboveLineTop - height;
            var fitsAbove = (heightAboveLine >= height);
            var belowTop = underLineTop;
            var fitsBelow = (heightUnderLine >= height);
            // And its left
            var actualLeft = visibleRange.left;
            if (actualLeft + width > ctx.viewportLeft + ctx.viewportWidth) {
                actualLeft = ctx.viewportLeft + ctx.viewportWidth - width;
            }
            if (actualLeft < ctx.viewportLeft) {
                actualLeft = ctx.viewportLeft;
            }
            return {
                aboveTop: aboveTop,
                fitsAbove: fitsAbove,
                belowTop: belowTop,
                fitsBelow: fitsBelow,
                left: actualLeft
            };
        };
        ViewContentWidgets.prototype._layoutBoxInPage = function (position, domNode, ctx) {
            var visibleRange = ctx.visibleRangeForPosition(position);
            if (!visibleRange) {
                return null;
            }
            var left0 = visibleRange.left - ctx.viewportLeft;
            var width = domNode.clientWidth, height = domNode.clientHeight;
            if (left0 + width < 0 || left0 > this._contentWidth) {
                return null;
            }
            var aboveTop = visibleRange.top - height;
            var belowTop = visibleRange.top + this._lineHeight;
            var left = left0 + this._contentLeft;
            var domNodePosition = dom.getDomNodePagePosition(this._viewDomNode);
            var absoluteAboveTop = domNodePosition.top + aboveTop - dom.StandardWindow.scrollY;
            var absoluteBelowTop = domNodePosition.top + belowTop - dom.StandardWindow.scrollY;
            var absoluteLeft = domNodePosition.left + left - dom.StandardWindow.scrollX;
            var INNER_WIDTH = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
            var INNER_HEIGHT = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
            // Leave some clearance to the bottom
            var BOTTOM_PADDING = 22;
            var fitsAbove = (absoluteAboveTop >= 0), fitsBelow = (absoluteBelowTop + height <= INNER_HEIGHT - BOTTOM_PADDING);
            if (absoluteLeft + width + 20 > INNER_WIDTH) {
                var delta = absoluteLeft - (INNER_WIDTH - width - 20);
                absoluteLeft -= delta;
                left -= delta;
            }
            if (absoluteLeft < 0) {
                var delta = absoluteLeft;
                absoluteLeft -= delta;
                left -= delta;
            }
            return {
                aboveTop: aboveTop,
                fitsAbove: fitsAbove,
                belowTop: belowTop,
                fitsBelow: fitsBelow,
                left: left
            };
        };
        ViewContentWidgets.prototype._prepareRenderWidgetAtExactPosition = function (position, ctx) {
            var visibleRange = ctx.visibleRangeForPosition(position);
            if (!visibleRange) {
                return null;
            }
            return {
                top: visibleRange.top,
                left: visibleRange.left
            };
        };
        ViewContentWidgets.prototype._prepareRenderWidget = function (widgetData, ctx) {
            var _this = this;
            if (!widgetData.position || !widgetData.preference) {
                return null;
            }
            // Do not trust that widgets have a valid position
            var validModelPosition = this._context.model.validateModelPosition(widgetData.position);
            if (!this._context.model.modelPositionIsVisible(validModelPosition)) {
                // this position is hidden by the view model
                return null;
            }
            var position = this._context.model.convertModelPositionToViewPosition(validModelPosition.lineNumber, validModelPosition.column);
            var placement = null;
            var fetchPlacement = function () {
                if (placement) {
                    return;
                }
                var domNode = widgetData.widget.getDomNode();
                if (widgetData.allowEditorOverflow) {
                    placement = _this._layoutBoxInPage(position, domNode, ctx);
                }
                else {
                    placement = _this._layoutBoxInViewport(position, domNode, ctx);
                }
            };
            // Do two passes, first for perfect fit, second picks first option
            for (var pass = 1; pass <= 2; pass++) {
                for (var i = 0; i < widgetData.preference.length; i++) {
                    var pref = widgetData.preference[i];
                    if (pref === editorBrowser_1.ContentWidgetPositionPreference.ABOVE) {
                        fetchPlacement();
                        if (!placement) {
                            // Widget outside of viewport
                            return null;
                        }
                        if (pass === 2 || placement.fitsAbove) {
                            return {
                                top: placement.aboveTop,
                                left: placement.left
                            };
                        }
                    }
                    else if (pref === editorBrowser_1.ContentWidgetPositionPreference.BELOW) {
                        fetchPlacement();
                        if (!placement) {
                            // Widget outside of viewport
                            return null;
                        }
                        if (pass === 2 || placement.fitsBelow) {
                            return {
                                top: placement.belowTop,
                                left: placement.left
                            };
                        }
                    }
                    else {
                        return this._prepareRenderWidgetAtExactPosition(position, ctx);
                    }
                }
            }
        };
        ViewContentWidgets.prototype.prepareRender = function (ctx) {
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
            var data = {};
            var keys = Object.keys(this._widgets);
            for (var i = 0, len = keys.length; i < len; i++) {
                var widgetId = keys[i];
                var renderData = this._prepareRenderWidget(this._widgets[widgetId], ctx);
                if (renderData) {
                    data[widgetId] = renderData;
                }
            }
            this._renderData = data;
        };
        ViewContentWidgets.prototype.render = function (ctx) {
            var data = this._renderData;
            var keys = Object.keys(this._widgets);
            for (var i = 0, len = keys.length; i < len; i++) {
                var widgetId = keys[i];
                var widget = this._widgets[widgetId];
                var domNode = this._widgets[widgetId].widget.getDomNode();
                if (data.hasOwnProperty(widgetId)) {
                    if (widget.allowEditorOverflow) {
                        styleMutator_1.StyleMutator.setTop(domNode, data[widgetId].top);
                        styleMutator_1.StyleMutator.setLeft(domNode, data[widgetId].left);
                    }
                    else {
                        styleMutator_1.StyleMutator.setTop(domNode, data[widgetId].top + ctx.viewportTop - ctx.bigNumbersDelta);
                        styleMutator_1.StyleMutator.setLeft(domNode, data[widgetId].left);
                    }
                    if (!widget.isVisible) {
                        styleMutator_1.StyleMutator.setVisibility(domNode, 'inherit');
                        domNode.setAttribute('monaco-visible-content-widget', 'true');
                        widget.isVisible = true;
                    }
                }
                else {
                    if (widget.isVisible) {
                        domNode.removeAttribute('monaco-visible-content-widget');
                        widget.isVisible = false;
                        styleMutator_1.StyleMutator.setVisibility(domNode, 'hidden');
                    }
                }
            }
        };
        return ViewContentWidgets;
    }(viewPart_1.ViewPart));
    exports.ViewContentWidgets = ViewContentWidgets;
});






define(__m[277], __M([0,1,28,27,172,103,22,397,102]), function (require, exports, browser, styleMutator_1, viewLineParts_1, viewLineRenderer_1, editorBrowser_1, rangeUtil_1, renderingContext_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewLine = (function () {
        function ViewLine(context) {
            this._context = context;
            this._renderWhitespace = this._context.configuration.editor.viewInfo.renderWhitespace;
            this._indentGuides = this._context.configuration.editor.viewInfo.indentGuides;
            this._spaceWidth = this._context.configuration.editor.fontInfo.spaceWidth;
            this._lineHeight = this._context.configuration.editor.lineHeight;
            this._stopRenderingLineAfter = this._context.configuration.editor.viewInfo.stopRenderingLineAfter;
            this._domNode = null;
            this._isInvalid = true;
            this._isMaybeInvalid = false;
            this._lineParts = null;
            this._charOffsetInPart = [];
            this._lastRenderedPartIndex = 0;
        }
        // --- begin IVisibleLineData
        ViewLine.prototype.getDomNode = function () {
            if (!this._domNode) {
                return null;
            }
            return this._domNode.domNode;
        };
        ViewLine.prototype.setDomNode = function (domNode) {
            this._domNode = styleMutator_1.createFastDomNode(domNode);
        };
        ViewLine.prototype.onContentChanged = function () {
            this._isInvalid = true;
        };
        ViewLine.prototype.onLinesInsertedAbove = function () {
            this._isMaybeInvalid = true;
        };
        ViewLine.prototype.onLinesDeletedAbove = function () {
            this._isMaybeInvalid = true;
        };
        ViewLine.prototype.onLineChangedAbove = function () {
            this._isMaybeInvalid = true;
        };
        ViewLine.prototype.onTokensChanged = function () {
            this._isMaybeInvalid = true;
        };
        ViewLine.prototype.onModelDecorationsChanged = function () {
            this._isMaybeInvalid = true;
        };
        ViewLine.prototype.onConfigurationChanged = function (e) {
            if (e.viewInfo.renderWhitespace) {
                this._renderWhitespace = this._context.configuration.editor.viewInfo.renderWhitespace;
            }
            if (e.viewInfo.indentGuides) {
                this._indentGuides = this._context.configuration.editor.viewInfo.indentGuides;
            }
            if (e.fontInfo) {
                this._spaceWidth = this._context.configuration.editor.fontInfo.spaceWidth;
            }
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            if (e.viewInfo.stopRenderingLineAfter) {
                this._stopRenderingLineAfter = this._context.configuration.editor.viewInfo.stopRenderingLineAfter;
            }
            this._isInvalid = true;
        };
        ViewLine.prototype.shouldUpdateHTML = function (startLineNumber, lineNumber, inlineDecorations) {
            var newLineParts = null;
            if (this._isMaybeInvalid || this._isInvalid) {
                // Compute new line parts only if there is some evidence that something might have changed
                newLineParts = viewLineParts_1.createLineParts(lineNumber, this._context.model.getLineMinColumn(lineNumber), this._context.model.getLineContent(lineNumber), this._context.model.getTabSize(), this._context.model.getLineTokens(lineNumber), inlineDecorations, this._renderWhitespace, this._indentGuides);
            }
            // Decide if isMaybeInvalid flips isInvalid to true
            if (this._isMaybeInvalid) {
                if (!this._isInvalid) {
                    if (!this._lineParts || !this._lineParts.equals(newLineParts)) {
                        this._isInvalid = true;
                    }
                }
                this._isMaybeInvalid = false;
            }
            if (this._isInvalid) {
                this._lineParts = newLineParts;
            }
            return this._isInvalid;
        };
        ViewLine.prototype.getLineOuterHTML = function (out, lineNumber, deltaTop) {
            out.push('<div lineNumber="');
            out.push(lineNumber.toString());
            out.push('" style="top:');
            out.push(deltaTop.toString());
            out.push('px;height:');
            out.push(this._lineHeight.toString());
            out.push('px;" class="');
            out.push(editorBrowser_1.ClassNames.VIEW_LINE);
            out.push('">');
            out.push(this.getLineInnerHTML(lineNumber));
            out.push('</div>');
        };
        ViewLine.prototype.getLineInnerHTML = function (lineNumber) {
            this._isInvalid = false;
            return this._render(lineNumber, this._lineParts);
        };
        ViewLine.prototype.layoutLine = function (lineNumber, deltaTop) {
            this._domNode.setLineNumber(String(lineNumber));
            this._domNode.setTop(deltaTop);
            this._domNode.setHeight(this._lineHeight);
        };
        // --- end IVisibleLineData
        ViewLine.prototype._render = function (lineNumber, lineParts) {
            this._cachedWidth = -1;
            var r = viewLineRenderer_1.renderLine(new viewLineRenderer_1.RenderLineInput(this._context.model.getLineContent(lineNumber), this._context.model.getTabSize(), this._spaceWidth, this._stopRenderingLineAfter, this._renderWhitespace, lineParts.getParts()));
            this._charOffsetInPart = r.charOffsetInPart;
            this._lastRenderedPartIndex = r.lastRenderedPartIndex;
            return r.output;
        };
        // --- Reading from the DOM methods
        ViewLine.prototype._getReadingTarget = function () {
            return this._domNode.domNode.firstChild;
        };
        /**
         * Width of the line in pixels
         */
        ViewLine.prototype.getWidth = function () {
            if (this._cachedWidth === -1) {
                this._cachedWidth = this._getReadingTarget().offsetWidth;
            }
            return this._cachedWidth;
        };
        /**
         * Visible ranges for a model range
         */
        ViewLine.prototype.getVisibleRangesForRange = function (startColumn, endColumn, clientRectDeltaLeft, endNode) {
            startColumn = startColumn | 0; // @perf
            endColumn = endColumn | 0; // @perf
            clientRectDeltaLeft = clientRectDeltaLeft | 0; // @perf
            var stopRenderingLineAfter = this._stopRenderingLineAfter | 0; // @perf
            if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter && endColumn > stopRenderingLineAfter) {
                // This range is obviously not visible
                return null;
            }
            if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter) {
                startColumn = stopRenderingLineAfter;
            }
            if (stopRenderingLineAfter !== -1 && endColumn > stopRenderingLineAfter) {
                endColumn = stopRenderingLineAfter;
            }
            return this._readVisibleRangesForRange(startColumn, endColumn, clientRectDeltaLeft, endNode);
        };
        ViewLine.prototype._readVisibleRangesForRange = function (startColumn, endColumn, clientRectDeltaLeft, endNode) {
            if (startColumn === endColumn) {
                return this._readRawVisibleRangesForPosition(startColumn, clientRectDeltaLeft, endNode);
            }
            else {
                return this._readRawVisibleRangesForRange(startColumn, endColumn, clientRectDeltaLeft, endNode);
            }
        };
        ViewLine.prototype._readRawVisibleRangesForPosition = function (column, clientRectDeltaLeft, endNode) {
            if (this._charOffsetInPart.length === 0) {
                // This line is empty
                return [new renderingContext_1.HorizontalRange(0, 0)];
            }
            var partIndex = findIndexInArrayWithMax(this._lineParts, column - 1, this._lastRenderedPartIndex);
            var charOffsetInPart = this._charOffsetInPart[column - 1];
            return rangeUtil_1.RangeUtil.readHorizontalRanges(this._getReadingTarget(), partIndex, charOffsetInPart, partIndex, charOffsetInPart, clientRectDeltaLeft, this._getScaleRatio(), endNode);
        };
        ViewLine.prototype._readRawVisibleRangesForRange = function (startColumn, endColumn, clientRectDeltaLeft, endNode) {
            if (startColumn === 1 && endColumn === this._charOffsetInPart.length) {
                // This branch helps IE with bidi text & gives a performance boost to other browsers when reading visible ranges for an entire line
                return [new renderingContext_1.HorizontalRange(0, this.getWidth())];
            }
            var startPartIndex = findIndexInArrayWithMax(this._lineParts, startColumn - 1, this._lastRenderedPartIndex);
            var startCharOffsetInPart = this._charOffsetInPart[startColumn - 1];
            var endPartIndex = findIndexInArrayWithMax(this._lineParts, endColumn - 1, this._lastRenderedPartIndex);
            var endCharOffsetInPart = this._charOffsetInPart[endColumn - 1];
            return rangeUtil_1.RangeUtil.readHorizontalRanges(this._getReadingTarget(), startPartIndex, startCharOffsetInPart, endPartIndex, endCharOffsetInPart, clientRectDeltaLeft, this._getScaleRatio(), endNode);
        };
        ViewLine.prototype._getScaleRatio = function () {
            return 1;
        };
        /**
         * Returns the column for the text found at a specific offset inside a rendered dom node
         */
        ViewLine.prototype.getColumnOfNodeOffset = function (lineNumber, spanNode, offset) {
            var spanNodeTextContentLength = spanNode.textContent.length;
            var spanIndex = -1;
            while (spanNode) {
                spanNode = spanNode.previousSibling;
                spanIndex++;
            }
            var lineParts = this._lineParts.getParts();
            return viewLineParts_1.getColumnOfLinePartOffset(this._stopRenderingLineAfter, lineParts, this._context.model.getLineMaxColumn(lineNumber), this._charOffsetInPart, spanIndex, spanNodeTextContentLength, offset);
        };
        return ViewLine;
    }());
    exports.ViewLine = ViewLine;
    var IEViewLine = (function (_super) {
        __extends(IEViewLine, _super);
        function IEViewLine(context) {
            _super.call(this, context);
        }
        IEViewLine.prototype._getScaleRatio = function () {
            return screen.logicalXDPI / screen.deviceXDPI;
        };
        return IEViewLine;
    }(ViewLine));
    var WebKitViewLine = (function (_super) {
        __extends(WebKitViewLine, _super);
        function WebKitViewLine(context) {
            _super.call(this, context);
        }
        WebKitViewLine.prototype._readVisibleRangesForRange = function (startColumn, endColumn, clientRectDeltaLeft, endNode) {
            var output = _super.prototype._readVisibleRangesForRange.call(this, startColumn, endColumn, clientRectDeltaLeft, endNode);
            if (!output || output.length === 0 || startColumn === endColumn || (startColumn === 1 && endColumn === this._charOffsetInPart.length)) {
                return output;
            }
            // WebKit is buggy and returns an expanded range (to contain words in some cases)
            // The last client rect is enlarged (I think)
            // This is an attempt to patch things up
            // Find position of previous column
            var beforeEndVisibleRanges = this._readRawVisibleRangesForPosition(endColumn - 1, clientRectDeltaLeft, endNode);
            // Find position of last column
            var endVisibleRanges = this._readRawVisibleRangesForPosition(endColumn, clientRectDeltaLeft, endNode);
            if (beforeEndVisibleRanges && beforeEndVisibleRanges.length > 0 && endVisibleRanges && endVisibleRanges.length > 0) {
                var beforeEndVisibleRange = beforeEndVisibleRanges[0];
                var endVisibleRange = endVisibleRanges[0];
                var isLTR = (beforeEndVisibleRange.left <= endVisibleRange.left);
                var lastRange = output[output.length - 1];
                if (isLTR && lastRange.left < endVisibleRange.left) {
                    // Trim down the width of the last visible range to not go after the last column's position
                    lastRange.width = endVisibleRange.left - lastRange.left;
                }
            }
            return output;
        };
        return WebKitViewLine;
    }(ViewLine));
    function findIndexInArrayWithMax(lineParts, desiredIndex, maxResult) {
        var r = lineParts.findIndexOfOffset(desiredIndex);
        return r <= maxResult ? r : maxResult;
    }
    exports.createLine = (function () {
        if (window.screen && window.screen.deviceXDPI && (navigator.userAgent.indexOf('Trident/6.0') >= 0 || navigator.userAgent.indexOf('Trident/5.0') >= 0)) {
            // IE11 doesn't need the screen.logicalXDPI / screen.deviceXDPI ratio multiplication
            // for TextRange.getClientRects() anymore
            return createIELine;
        }
        else if (browser.isWebKit) {
            return createWebKitLine;
        }
        return createNormalLine;
    })();
    function createIELine(context) {
        return new IEViewLine(context);
    }
    function createWebKitLine(context) {
        return new WebKitViewLine(context);
    }
    function createNormalLine(context) {
        return new ViewLine(context);
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[278], __M([0,1,27,22,46,191]), function (require, exports, styleMutator_1, editorBrowser_1, viewPart_1) {
    'use strict';
    var ViewOverlayWidgets = (function (_super) {
        __extends(ViewOverlayWidgets, _super);
        function ViewOverlayWidgets(context) {
            _super.call(this, context);
            this._widgets = {};
            this._verticalScrollbarWidth = 0;
            this._horizontalScrollbarHeight = 0;
            this._editorHeight = 0;
            this._editorWidth = 0;
            this.domNode = document.createElement('div');
            this.domNode.className = editorBrowser_1.ClassNames.OVERLAY_WIDGETS;
        }
        ViewOverlayWidgets.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._widgets = null;
        };
        // ---- begin view event handlers
        ViewOverlayWidgets.prototype.onLayoutChanged = function (layoutInfo) {
            this._verticalScrollbarWidth = layoutInfo.verticalScrollbarWidth;
            this._horizontalScrollbarHeight = layoutInfo.horizontalScrollbarHeight;
            this._editorHeight = layoutInfo.height;
            this._editorWidth = layoutInfo.width;
            return true;
        };
        // ---- end view event handlers
        ViewOverlayWidgets.prototype.addWidget = function (widget) {
            this._widgets[widget.getId()] = {
                widget: widget,
                preference: null
            };
            // This is sync because a widget wants to be in the dom
            var domNode = widget.getDomNode();
            domNode.style.position = 'absolute';
            domNode.setAttribute('widgetId', widget.getId());
            this.domNode.appendChild(domNode);
            this.setShouldRender();
        };
        ViewOverlayWidgets.prototype.setWidgetPosition = function (widget, preference) {
            var widgetData = this._widgets[widget.getId()];
            if (widgetData.preference === preference) {
                return false;
            }
            widgetData.preference = preference;
            this.setShouldRender();
            return true;
        };
        ViewOverlayWidgets.prototype.removeWidget = function (widget) {
            var widgetId = widget.getId();
            if (this._widgets.hasOwnProperty(widgetId)) {
                var widgetData = this._widgets[widgetId];
                var domNode = widgetData.widget.getDomNode();
                delete this._widgets[widgetId];
                domNode.parentNode.removeChild(domNode);
                this.setShouldRender();
            }
        };
        ViewOverlayWidgets.prototype._renderWidget = function (widgetData) {
            var _RESTORE_STYLE_TOP = 'data-editor-restoreStyleTop', domNode = widgetData.widget.getDomNode();
            if (widgetData.preference === null) {
                if (domNode.hasAttribute(_RESTORE_STYLE_TOP)) {
                    var previousTop = domNode.getAttribute(_RESTORE_STYLE_TOP);
                    domNode.removeAttribute(_RESTORE_STYLE_TOP);
                    domNode.style.top = previousTop;
                }
                return;
            }
            if (widgetData.preference === editorBrowser_1.OverlayWidgetPositionPreference.TOP_RIGHT_CORNER) {
                if (!domNode.hasAttribute(_RESTORE_STYLE_TOP)) {
                    domNode.setAttribute(_RESTORE_STYLE_TOP, domNode.style.top);
                }
                styleMutator_1.StyleMutator.setTop(domNode, 0);
                styleMutator_1.StyleMutator.setRight(domNode, (2 * this._verticalScrollbarWidth));
            }
            else if (widgetData.preference === editorBrowser_1.OverlayWidgetPositionPreference.BOTTOM_RIGHT_CORNER) {
                if (!domNode.hasAttribute(_RESTORE_STYLE_TOP)) {
                    domNode.setAttribute(_RESTORE_STYLE_TOP, domNode.style.top);
                }
                var widgetHeight = domNode.clientHeight;
                styleMutator_1.StyleMutator.setTop(domNode, (this._editorHeight - widgetHeight - 2 * this._horizontalScrollbarHeight));
                styleMutator_1.StyleMutator.setRight(domNode, (2 * this._verticalScrollbarWidth));
            }
            else if (widgetData.preference === editorBrowser_1.OverlayWidgetPositionPreference.TOP_CENTER) {
                if (!domNode.hasAttribute(_RESTORE_STYLE_TOP)) {
                    domNode.setAttribute(_RESTORE_STYLE_TOP, domNode.style.top);
                }
                styleMutator_1.StyleMutator.setTop(domNode, 0);
                domNode.style.right = '50%';
            }
        };
        ViewOverlayWidgets.prototype.prepareRender = function (ctx) {
            // Nothing to read
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
        };
        ViewOverlayWidgets.prototype.render = function (ctx) {
            styleMutator_1.StyleMutator.setWidth(this.domNode, this._editorWidth);
            var keys = Object.keys(this._widgets);
            for (var i = 0, len = keys.length; i < len; i++) {
                var widgetId = keys[i];
                this._renderWidget(this._widgets[widgetId]);
            }
        };
        return ViewOverlayWidgets;
    }(viewPart_1.ViewPart));
    exports.ViewOverlayWidgets = ViewOverlayWidgets;
});

define(__m[160], __M([0,1,27,7,28,395]), function (require, exports, styleMutator_1, editorCommon_1, browser, overviewZoneManager_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var OverviewRulerImpl = (function () {
        function OverviewRulerImpl(canvasLeftOffset, cssClassName, scrollHeight, lineHeight, canUseTranslate3d, minimumHeight, maximumHeight, getVerticalOffsetForLine) {
            var _this = this;
            this._canvasLeftOffset = canvasLeftOffset;
            this._domNode = document.createElement('canvas');
            this._domNode.className = cssClassName;
            this._domNode.style.position = 'absolute';
            this._lanesCount = 3;
            this._canUseTranslate3d = canUseTranslate3d;
            this._zoneManager = new overviewZoneManager_1.OverviewZoneManager(getVerticalOffsetForLine);
            this._zoneManager.setMinimumHeight(minimumHeight);
            this._zoneManager.setMaximumHeight(maximumHeight);
            this._zoneManager.setUseDarkColor(false);
            this._zoneManager.setDOMWidth(0);
            this._zoneManager.setDOMHeight(0);
            this._zoneManager.setOuterHeight(scrollHeight);
            this._zoneManager.setLineHeight(lineHeight);
            this._zoomListener = browser.onDidChangeZoomLevel(function () {
                _this._zoneManager.setPixelRatio(browser.getPixelRatio());
                _this._domNode.style.width = _this._zoneManager.getDOMWidth() + 'px';
                _this._domNode.style.height = _this._zoneManager.getDOMHeight() + 'px';
                _this._domNode.width = _this._zoneManager.getCanvasWidth();
                _this._domNode.height = _this._zoneManager.getCanvasHeight();
                _this.render(true);
            });
            this._zoneManager.setPixelRatio(browser.getPixelRatio());
        }
        OverviewRulerImpl.prototype.dispose = function () {
            this._zoomListener.dispose();
            this._zoneManager = null;
        };
        OverviewRulerImpl.prototype.setLayout = function (position, render) {
            styleMutator_1.StyleMutator.setTop(this._domNode, position.top);
            styleMutator_1.StyleMutator.setRight(this._domNode, position.right);
            var hasChanged = false;
            hasChanged = this._zoneManager.setDOMWidth(position.width) || hasChanged;
            hasChanged = this._zoneManager.setDOMHeight(position.height) || hasChanged;
            if (hasChanged) {
                this._domNode.style.width = this._zoneManager.getDOMWidth() + 'px';
                this._domNode.style.height = this._zoneManager.getDOMHeight() + 'px';
                this._domNode.width = this._zoneManager.getCanvasWidth();
                this._domNode.height = this._zoneManager.getCanvasHeight();
                if (render) {
                    this.render(true);
                }
            }
        };
        OverviewRulerImpl.prototype.getLanesCount = function () {
            return this._lanesCount;
        };
        OverviewRulerImpl.prototype.setLanesCount = function (newLanesCount, render) {
            this._lanesCount = newLanesCount;
            if (render) {
                this.render(true);
            }
        };
        OverviewRulerImpl.prototype.setUseDarkColor = function (useDarkColor, render) {
            this._zoneManager.setUseDarkColor(useDarkColor);
            if (render) {
                this.render(true);
            }
        };
        OverviewRulerImpl.prototype.getDomNode = function () {
            return this._domNode;
        };
        OverviewRulerImpl.prototype.getPixelWidth = function () {
            return this._zoneManager.getCanvasWidth();
        };
        OverviewRulerImpl.prototype.getPixelHeight = function () {
            return this._zoneManager.getCanvasHeight();
        };
        OverviewRulerImpl.prototype.setScrollHeight = function (scrollHeight, render) {
            this._zoneManager.setOuterHeight(scrollHeight);
            if (render) {
                this.render(true);
            }
        };
        OverviewRulerImpl.prototype.setLineHeight = function (lineHeight, render) {
            this._zoneManager.setLineHeight(lineHeight);
            if (render) {
                this.render(true);
            }
        };
        OverviewRulerImpl.prototype.setCanUseTranslate3d = function (canUseTranslate3d, render) {
            this._canUseTranslate3d = canUseTranslate3d;
            if (render) {
                this.render(true);
            }
        };
        OverviewRulerImpl.prototype.setZones = function (zones, render) {
            this._zoneManager.setZones(zones);
            if (render) {
                this.render(false);
            }
        };
        OverviewRulerImpl.prototype.render = function (forceRender) {
            if (!OverviewRulerImpl.hasCanvas) {
                return false;
            }
            if (this._zoneManager.getOuterHeight() === 0) {
                return false;
            }
            if (this._canUseTranslate3d) {
                styleMutator_1.StyleMutator.setTransform(this._domNode, 'translate3d(0px, 0px, 0px)');
            }
            else {
                styleMutator_1.StyleMutator.setTransform(this._domNode, '');
            }
            var width = this._zoneManager.getCanvasWidth();
            var height = this._zoneManager.getCanvasHeight();
            var colorZones = this._zoneManager.resolveColorZones();
            var id2Color = this._zoneManager.getId2Color();
            var ctx = this._domNode.getContext('2d');
            ctx.clearRect(0, 0, width, height);
            if (colorZones.length > 0) {
                var remainingWidth = width - this._canvasLeftOffset;
                if (this._lanesCount >= 3) {
                    this._renderThreeLanes(ctx, colorZones, id2Color, remainingWidth);
                }
                else if (this._lanesCount === 2) {
                    this._renderTwoLanes(ctx, colorZones, id2Color, remainingWidth);
                }
                else if (this._lanesCount === 1) {
                    this._renderOneLane(ctx, colorZones, id2Color, remainingWidth);
                }
            }
            return true;
        };
        OverviewRulerImpl.prototype._renderOneLane = function (ctx, colorZones, id2Color, w) {
            this._renderVerticalPatch(ctx, colorZones, id2Color, editorCommon_1.OverviewRulerLane.Left | editorCommon_1.OverviewRulerLane.Center | editorCommon_1.OverviewRulerLane.Right, this._canvasLeftOffset, w);
        };
        OverviewRulerImpl.prototype._renderTwoLanes = function (ctx, colorZones, id2Color, w) {
            var leftWidth = Math.floor(w / 2);
            var rightWidth = w - leftWidth;
            var leftOffset = this._canvasLeftOffset;
            var rightOffset = this._canvasLeftOffset + leftWidth;
            this._renderVerticalPatch(ctx, colorZones, id2Color, editorCommon_1.OverviewRulerLane.Left | editorCommon_1.OverviewRulerLane.Center, leftOffset, leftWidth);
            this._renderVerticalPatch(ctx, colorZones, id2Color, editorCommon_1.OverviewRulerLane.Right, rightOffset, rightWidth);
        };
        OverviewRulerImpl.prototype._renderThreeLanes = function (ctx, colorZones, id2Color, w) {
            var leftWidth = Math.floor(w / 3);
            var rightWidth = Math.floor(w / 3);
            var centerWidth = w - leftWidth - rightWidth;
            var leftOffset = this._canvasLeftOffset;
            var centerOffset = this._canvasLeftOffset + leftWidth;
            var rightOffset = this._canvasLeftOffset + leftWidth + centerWidth;
            this._renderVerticalPatch(ctx, colorZones, id2Color, editorCommon_1.OverviewRulerLane.Left, leftOffset, leftWidth);
            this._renderVerticalPatch(ctx, colorZones, id2Color, editorCommon_1.OverviewRulerLane.Center, centerOffset, centerWidth);
            this._renderVerticalPatch(ctx, colorZones, id2Color, editorCommon_1.OverviewRulerLane.Right, rightOffset, rightWidth);
        };
        OverviewRulerImpl.prototype._renderVerticalPatch = function (ctx, colorZones, id2Color, laneMask, xpos, width) {
            var currentColorId = 0;
            var currentFrom = 0;
            var currentTo = 0;
            for (var i = 0, len = colorZones.length; i < len; i++) {
                var zone = colorZones[i];
                if (!(zone.position & laneMask)) {
                    continue;
                }
                var zoneColorId = zone.colorId;
                var zoneFrom = zone.from;
                var zoneTo = zone.to;
                if (zoneColorId !== currentColorId) {
                    ctx.fillRect(xpos, currentFrom, width, currentTo - currentFrom);
                    currentColorId = zoneColorId;
                    ctx.fillStyle = id2Color[currentColorId];
                    currentFrom = zoneFrom;
                    currentTo = zoneTo;
                }
                else {
                    if (currentTo >= zoneFrom) {
                        currentTo = Math.max(currentTo, zoneTo);
                    }
                    else {
                        ctx.fillRect(xpos, currentFrom, width, currentTo - currentFrom);
                        currentFrom = zoneFrom;
                        currentTo = zoneTo;
                    }
                }
            }
            ctx.fillRect(xpos, currentFrom, width, currentTo - currentFrom);
        };
        OverviewRulerImpl.hasCanvas = (window.navigator.userAgent.indexOf('MSIE 8') === -1);
        return OverviewRulerImpl;
    }());
    exports.OverviewRulerImpl = OverviewRulerImpl;
});






define(__m[280], __M([0,1,53,160]), function (require, exports, viewEventHandler_1, overviewRulerImpl_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var OverviewRuler = (function (_super) {
        __extends(OverviewRuler, _super);
        function OverviewRuler(context, cssClassName, scrollHeight, minimumHeight, maximumHeight, getVerticalOffsetForLine) {
            _super.call(this);
            this._context = context;
            this._overviewRuler = new overviewRulerImpl_1.OverviewRulerImpl(0, cssClassName, scrollHeight, this._context.configuration.editor.lineHeight, this._context.configuration.editor.viewInfo.canUseTranslate3d, minimumHeight, maximumHeight, getVerticalOffsetForLine);
            this._context.addEventHandler(this);
        }
        OverviewRuler.prototype.destroy = function () {
            this.dispose();
        };
        OverviewRuler.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this._overviewRuler.dispose();
        };
        OverviewRuler.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._overviewRuler.setLineHeight(this._context.configuration.editor.lineHeight, true);
                return true;
            }
            if (e.viewInfo.canUseTranslate3d) {
                this._overviewRuler.setCanUseTranslate3d(this._context.configuration.editor.viewInfo.canUseTranslate3d, true);
                return true;
            }
            return false;
        };
        OverviewRuler.prototype.onZonesChanged = function () {
            return true;
        };
        OverviewRuler.prototype.onModelFlushed = function () {
            return true;
        };
        OverviewRuler.prototype.onScrollChanged = function (e) {
            this._overviewRuler.setScrollHeight(e.scrollHeight, true);
            return _super.prototype.onScrollChanged.call(this, e) || e.scrollHeightChanged;
        };
        OverviewRuler.prototype.getDomNode = function () {
            return this._overviewRuler.getDomNode();
        };
        OverviewRuler.prototype.setLayout = function (position) {
            this._overviewRuler.setLayout(position, true);
        };
        OverviewRuler.prototype.setZones = function (zones) {
            this._overviewRuler.setZones(zones, true);
        };
        return OverviewRuler;
    }(viewEventHandler_1.ViewEventHandler));
    exports.OverviewRuler = OverviewRuler;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[281], __M([0,1,27,46,192]), function (require, exports, styleMutator_1, viewPart_1) {
    'use strict';
    var Rulers = (function (_super) {
        __extends(Rulers, _super);
        function Rulers(context, layoutProvider) {
            _super.call(this, context);
            this._layoutProvider = layoutProvider;
            this.domNode = document.createElement('div');
            this.domNode.className = 'view-rulers';
            this._rulers = this._context.configuration.editor.viewInfo.rulers;
            this._height = this._context.configuration.editor.layoutInfo.contentHeight;
            this._typicalHalfwidthCharacterWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
        }
        Rulers.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        // --- begin event handlers
        Rulers.prototype.onConfigurationChanged = function (e) {
            if (e.viewInfo.rulers || e.layoutInfo || e.fontInfo) {
                this._rulers = this._context.configuration.editor.viewInfo.rulers;
                this._height = this._context.configuration.editor.layoutInfo.contentHeight;
                this._typicalHalfwidthCharacterWidth = this._context.configuration.editor.fontInfo.typicalHalfwidthCharacterWidth;
                return true;
            }
            return false;
        };
        Rulers.prototype.onScrollChanged = function (e) {
            return _super.prototype.onScrollChanged.call(this, e) || e.scrollHeightChanged;
        };
        // --- end event handlers
        Rulers.prototype.prepareRender = function (ctx) {
            // Nothing to read
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
        };
        Rulers.prototype.render = function (ctx) {
            var existingRulersLength = this.domNode.children.length;
            var max = Math.max(existingRulersLength, this._rulers.length);
            for (var i = 0; i < max; i++) {
                if (i >= this._rulers.length) {
                    this.domNode.removeChild(this.domNode.lastChild);
                    continue;
                }
                var node = void 0;
                if (i < existingRulersLength) {
                    node = this.domNode.children[i];
                }
                else {
                    node = document.createElement('div');
                    node.className = 'view-ruler';
                    this.domNode.appendChild(node);
                }
                styleMutator_1.StyleMutator.setHeight(node, Math.min(this._layoutProvider.getTotalHeight(), 1000000));
                styleMutator_1.StyleMutator.setLeft(node, this._rulers[i] * this._typicalHalfwidthCharacterWidth);
            }
        };
        return Rulers;
    }(viewPart_1.ViewPart));
    exports.Rulers = Rulers;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[282], __M([0,1,11,27,22,46,193]), function (require, exports, dom, styleMutator_1, editorBrowser_1, viewPart_1) {
    'use strict';
    var ScrollDecorationViewPart = (function (_super) {
        __extends(ScrollDecorationViewPart, _super);
        function ScrollDecorationViewPart(context) {
            _super.call(this, context);
            this._scrollTop = 0;
            this._width = 0;
            this._shouldShow = false;
            this._useShadows = this._context.configuration.editor.viewInfo.scrollbar.useShadows;
            this._domNode = document.createElement('div');
        }
        ScrollDecorationViewPart.prototype._updateShouldShow = function () {
            var newShouldShow = (this._useShadows && this._scrollTop > 0);
            if (this._shouldShow !== newShouldShow) {
                this._shouldShow = newShouldShow;
                return true;
            }
            return false;
        };
        ScrollDecorationViewPart.prototype.getDomNode = function () {
            return this._domNode;
        };
        // --- begin event handlers
        ScrollDecorationViewPart.prototype.onConfigurationChanged = function (e) {
            if (e.viewInfo.scrollbar) {
                this._useShadows = this._context.configuration.editor.viewInfo.scrollbar.useShadows;
            }
            return this._updateShouldShow();
        };
        ScrollDecorationViewPart.prototype.onLayoutChanged = function (layoutInfo) {
            if (this._width !== layoutInfo.width) {
                this._width = layoutInfo.width;
                return true;
            }
            return false;
        };
        ScrollDecorationViewPart.prototype.onScrollChanged = function (e) {
            this._scrollTop = e.scrollTop;
            return this._updateShouldShow();
        };
        // --- end event handlers
        ScrollDecorationViewPart.prototype.prepareRender = function (ctx) {
            // Nothing to read
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
        };
        ScrollDecorationViewPart.prototype.render = function (ctx) {
            styleMutator_1.StyleMutator.setWidth(this._domNode, this._width);
            dom.toggleClass(this._domNode, editorBrowser_1.ClassNames.SCROLL_DECORATION, this._shouldShow);
        };
        return ScrollDecorationViewPart;
    }(viewPart_1.ViewPart));
    exports.ScrollDecorationViewPart = ScrollDecorationViewPart;
});






define(__m[283], __M([0,1,8,27,22,46]), function (require, exports, errors_1, styleMutator_1, editorBrowser_1, viewPart_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewZones = (function (_super) {
        __extends(ViewZones, _super);
        function ViewZones(context, whitespaceManager) {
            _super.call(this, context);
            this._lineHeight = this._context.configuration.editor.lineHeight;
            this._whitespaceManager = whitespaceManager;
            this.domNode = document.createElement('div');
            this.domNode.className = editorBrowser_1.ClassNames.VIEW_ZONES;
            this.domNode.style.position = 'absolute';
            this.domNode.setAttribute('role', 'presentation');
            this.domNode.setAttribute('aria-hidden', 'true');
            this._zones = {};
        }
        ViewZones.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._whitespaceManager = null;
            this._zones = {};
        };
        // ---- begin view event handlers
        ViewZones.prototype._recomputeWhitespacesProps = function () {
            var hadAChange = false;
            var keys = Object.keys(this._zones);
            for (var i = 0, len = keys.length; i < len; i++) {
                var id = keys[i];
                var zone = this._zones[id];
                var props = this._computeWhitespaceProps(zone.delegate);
                if (this._whitespaceManager.changeWhitespace(parseInt(id, 10), props.afterViewLineNumber, props.heightInPx)) {
                    this._safeCallOnComputedHeight(zone.delegate, props.heightInPx);
                    hadAChange = true;
                }
            }
            return hadAChange;
        };
        ViewZones.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
                return this._recomputeWhitespacesProps();
            }
            return false;
        };
        ViewZones.prototype.onLineMappingChanged = function () {
            return this._recomputeWhitespacesProps();
        };
        ViewZones.prototype.onLayoutChanged = function (layoutInfo) {
            return true;
        };
        ViewZones.prototype.onScrollChanged = function (e) {
            return e.scrollTopChanged || e.scrollWidthChanged;
        };
        ViewZones.prototype.onZonesChanged = function () {
            return true;
        };
        ViewZones.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        ViewZones.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        // ---- end view event handlers
        ViewZones.prototype._getZoneOrdinal = function (zone) {
            if (typeof zone.afterColumn !== 'undefined') {
                return zone.afterColumn;
            }
            return 10000;
        };
        ViewZones.prototype._computeWhitespaceProps = function (zone) {
            if (zone.afterLineNumber === 0) {
                return {
                    afterViewLineNumber: 0,
                    heightInPx: this._heightInPixels(zone)
                };
            }
            var zoneAfterModelPosition;
            if (typeof zone.afterColumn !== 'undefined') {
                zoneAfterModelPosition = this._context.model.validateModelPosition({
                    lineNumber: zone.afterLineNumber,
                    column: zone.afterColumn
                });
            }
            else {
                var validAfterLineNumber = this._context.model.validateModelPosition({
                    lineNumber: zone.afterLineNumber,
                    column: 1
                }).lineNumber;
                zoneAfterModelPosition = {
                    lineNumber: validAfterLineNumber,
                    column: this._context.model.getModelLineMaxColumn(validAfterLineNumber)
                };
            }
            var zoneBeforeModelPosition;
            if (zoneAfterModelPosition.column === this._context.model.getModelLineMaxColumn(zoneAfterModelPosition.lineNumber)) {
                zoneBeforeModelPosition = this._context.model.validateModelPosition({
                    lineNumber: zoneAfterModelPosition.lineNumber + 1,
                    column: 1
                });
            }
            else {
                zoneBeforeModelPosition = this._context.model.validateModelPosition({
                    lineNumber: zoneAfterModelPosition.lineNumber,
                    column: zoneAfterModelPosition.column + 1
                });
            }
            var viewPosition = this._context.model.convertModelPositionToViewPosition(zoneAfterModelPosition.lineNumber, zoneAfterModelPosition.column);
            var isVisible = this._context.model.modelPositionIsVisible(zoneBeforeModelPosition);
            return {
                afterViewLineNumber: viewPosition.lineNumber,
                heightInPx: (isVisible ? this._heightInPixels(zone) : 0)
            };
        };
        ViewZones.prototype.addZone = function (zone) {
            var props = this._computeWhitespaceProps(zone);
            var whitespaceId = this._whitespaceManager.addWhitespace(props.afterViewLineNumber, this._getZoneOrdinal(zone), props.heightInPx);
            var myZone = {
                whitespaceId: whitespaceId,
                delegate: zone,
                isVisible: false
            };
            this._safeCallOnComputedHeight(myZone.delegate, props.heightInPx);
            myZone.delegate.domNode.style.position = 'absolute';
            myZone.delegate.domNode.style.width = '100%';
            styleMutator_1.StyleMutator.setDisplay(myZone.delegate.domNode, 'none');
            this._zones[myZone.whitespaceId.toString()] = myZone;
            myZone.delegate.domNode.setAttribute('monaco-view-zone', myZone.whitespaceId.toString());
            this.domNode.appendChild(myZone.delegate.domNode);
            this.setShouldRender();
            return myZone.whitespaceId;
        };
        ViewZones.prototype.removeZone = function (id) {
            if (this._zones.hasOwnProperty(id.toString())) {
                var zone = this._zones[id.toString()];
                delete this._zones[id.toString()];
                this._whitespaceManager.removeWhitespace(zone.whitespaceId);
                zone.delegate.domNode.removeAttribute('monaco-visible-view-zone');
                zone.delegate.domNode.removeAttribute('monaco-view-zone');
                zone.delegate.domNode.parentNode.removeChild(zone.delegate.domNode);
                this.setShouldRender();
                return true;
            }
            return false;
        };
        ViewZones.prototype.layoutZone = function (id) {
            var changed = false;
            if (this._zones.hasOwnProperty(id.toString())) {
                var zone = this._zones[id.toString()];
                var props = this._computeWhitespaceProps(zone.delegate);
                // let newOrdinal = this._getZoneOrdinal(zone.delegate);
                changed = this._whitespaceManager.changeWhitespace(zone.whitespaceId, props.afterViewLineNumber, props.heightInPx) || changed;
                // TODO@Alex: change `newOrdinal` too
                if (changed) {
                    this._safeCallOnComputedHeight(zone.delegate, props.heightInPx);
                    this.setShouldRender();
                }
            }
            return changed;
        };
        ViewZones.prototype.shouldSuppressMouseDownOnViewZone = function (id) {
            if (this._zones.hasOwnProperty(id.toString())) {
                var zone = this._zones[id.toString()];
                return zone.delegate.suppressMouseDown;
            }
            return false;
        };
        ViewZones.prototype._heightInPixels = function (zone) {
            if (typeof zone.heightInPx === 'number') {
                return zone.heightInPx;
            }
            if (typeof zone.heightInLines === 'number') {
                return this._lineHeight * zone.heightInLines;
            }
            return this._lineHeight;
        };
        ViewZones.prototype._safeCallOnComputedHeight = function (zone, height) {
            if (typeof zone.onComputedHeight === 'function') {
                try {
                    zone.onComputedHeight(height);
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                }
            }
        };
        ViewZones.prototype._safeCallOnDomNodeTop = function (zone, top) {
            if (typeof zone.onDomNodeTop === 'function') {
                try {
                    zone.onDomNodeTop(top);
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                }
            }
        };
        ViewZones.prototype.prepareRender = function (ctx) {
            // Nothing to read
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
        };
        ViewZones.prototype.render = function (ctx) {
            var visibleWhitespaces = this._whitespaceManager.getWhitespaceViewportData();
            var visibleZones = {};
            var hasVisibleZone = false;
            for (var i = 0, len = visibleWhitespaces.length; i < len; i++) {
                visibleZones[visibleWhitespaces[i].id.toString()] = visibleWhitespaces[i];
                hasVisibleZone = true;
            }
            var keys = Object.keys(this._zones);
            for (var i = 0, len = keys.length; i < len; i++) {
                var id = keys[i];
                var zone = this._zones[id];
                if (visibleZones.hasOwnProperty(id)) {
                    // zone is visible
                    styleMutator_1.StyleMutator.setTop(zone.delegate.domNode, (visibleZones[id].verticalOffset - ctx.bigNumbersDelta));
                    styleMutator_1.StyleMutator.setHeight(zone.delegate.domNode, visibleZones[id].height);
                    if (!zone.isVisible) {
                        styleMutator_1.StyleMutator.setDisplay(zone.delegate.domNode, 'block');
                        zone.delegate.domNode.setAttribute('monaco-visible-view-zone', 'true');
                        zone.isVisible = true;
                    }
                    this._safeCallOnDomNodeTop(zone.delegate, ctx.getScrolledTopFromAbsoluteTop(visibleZones[id].verticalOffset));
                }
                else {
                    if (zone.isVisible) {
                        styleMutator_1.StyleMutator.setDisplay(zone.delegate.domNode, 'none');
                        zone.delegate.domNode.removeAttribute('monaco-visible-view-zone');
                        zone.isVisible = false;
                    }
                    this._safeCallOnDomNodeTop(zone.delegate, ctx.getScrolledTopFromAbsoluteTop(-1000000));
                }
            }
            if (hasVisibleZone) {
                styleMutator_1.StyleMutator.setWidth(this.domNode, ctx.scrollWidth);
            }
        };
        return ViewZones;
    }(viewPart_1.ViewPart));
    exports.ViewZones = ViewZones;
});






define(__m[284], __M([0,1,14,16,12,3,148,21,4,7]), function (require, exports, async_1, event_1, keyCodes_1, lifecycle_1, textAreaState_1, position_1, range_1, editorCommon_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ReadFromTextArea;
    (function (ReadFromTextArea) {
        ReadFromTextArea[ReadFromTextArea["Type"] = 0] = "Type";
        ReadFromTextArea[ReadFromTextArea["Paste"] = 1] = "Paste";
    })(ReadFromTextArea || (ReadFromTextArea = {}));
    var TextAreaHandler = (function (_super) {
        __extends(TextAreaHandler, _super);
        function TextAreaHandler(Browser, strategy, textArea, model, flushAnyAccumulatedEvents) {
            var _this = this;
            _super.call(this);
            this._onKeyDown = this._register(new event_1.Emitter());
            this.onKeyDown = this._onKeyDown.event;
            this._onKeyUp = this._register(new event_1.Emitter());
            this.onKeyUp = this._onKeyUp.event;
            this._onCut = this._register(new event_1.Emitter());
            this.onCut = this._onCut.event;
            this._onPaste = this._register(new event_1.Emitter());
            this.onPaste = this._onPaste.event;
            this._onType = this._register(new event_1.Emitter());
            this.onType = this._onType.event;
            this._onCompositionStart = this._register(new event_1.Emitter());
            this.onCompositionStart = this._onCompositionStart.event;
            this._onCompositionUpdate = this._register(new event_1.Emitter());
            this.onCompositionUpdate = this._onCompositionUpdate.event;
            this._onCompositionEnd = this._register(new event_1.Emitter());
            this.onCompositionEnd = this._onCompositionEnd.event;
            this.Browser = Browser;
            this.textArea = textArea;
            this.model = model;
            this.flushAnyAccumulatedEvents = flushAnyAccumulatedEvents;
            this.selection = new range_1.Range(1, 1, 1, 1);
            this.selections = [new range_1.Range(1, 1, 1, 1)];
            this.cursorPosition = new position_1.Position(1, 1);
            this._nextCommand = ReadFromTextArea.Type;
            this.asyncTriggerCut = new async_1.RunOnceScheduler(function () { return _this._onCut.fire(); }, 0);
            this.lastCopiedValue = null;
            this.lastCopiedValueIsFromEmptySelection = false;
            this.textAreaState = textAreaState_1.createTextAreaState(strategy);
            this.hasFocus = false;
            this.lastCompositionEndTime = 0;
            this._register(this.textArea.onKeyDown(function (e) { return _this._onKeyDownHandler(e); }));
            this._register(this.textArea.onKeyUp(function (e) { return _this._onKeyUp.fire(e); }));
            this._register(this.textArea.onKeyPress(function (e) { return _this._onKeyPressHandler(e); }));
            this.textareaIsShownAtCursor = false;
            this._register(this.textArea.onCompositionStart(function (e) {
                if (_this.textareaIsShownAtCursor) {
                    return;
                }
                _this.textareaIsShownAtCursor = true;
                // In IE we cannot set .value when handling 'compositionstart' because the entire composition will get canceled.
                var shouldEmptyTextArea = true;
                if (shouldEmptyTextArea) {
                    if (!_this.Browser.isIE11orEarlier) {
                        _this.setTextAreaState('compositionstart', _this.textAreaState.toEmpty());
                    }
                }
                var showAtLineNumber;
                var showAtColumn;
                // In IE we cannot set .value when handling 'compositionstart' because the entire composition will get canceled.
                if (_this.Browser.isIE11orEarlier) {
                    // Ensure selection start is in viewport
                    showAtLineNumber = _this.selection.startLineNumber;
                    showAtColumn = (_this.selection.startColumn - _this.textAreaState.getSelectionStart());
                }
                else {
                    showAtLineNumber = _this.cursorPosition.lineNumber;
                    showAtColumn = _this.cursorPosition.column;
                }
                _this._onCompositionStart.fire({
                    showAtLineNumber: showAtLineNumber,
                    showAtColumn: showAtColumn
                });
            }));
            this._register(this.textArea.onCompositionUpdate(function (e) {
                _this.textAreaState = _this.textAreaState.fromText(e.data);
                var typeInput = _this.textAreaState.updateComposition();
                _this._onType.fire(typeInput);
                _this._onCompositionUpdate.fire(e);
            }));
            var readFromTextArea = function () {
                _this.textAreaState = _this.textAreaState.fromTextArea(_this.textArea);
                var typeInput = _this.textAreaState.deduceInput();
                // console.log('==> DEDUCED INPUT: ' + JSON.stringify(typeInput));
                if (_this._nextCommand === ReadFromTextArea.Type) {
                    if (typeInput.text !== '') {
                        _this._onType.fire(typeInput);
                    }
                }
                else {
                    _this.executePaste(typeInput.text);
                    _this._nextCommand = ReadFromTextArea.Type;
                }
            };
            this._register(this.textArea.onCompositionEnd(function (e) {
                // console.log('onCompositionEnd: ' + e.data);
                _this.textAreaState = _this.textAreaState.fromText(e.data);
                var typeInput = _this.textAreaState.updateComposition();
                _this._onType.fire(typeInput);
                _this.lastCompositionEndTime = (new Date()).getTime();
                if (!_this.textareaIsShownAtCursor) {
                    return;
                }
                _this.textareaIsShownAtCursor = false;
                _this._onCompositionEnd.fire();
            }));
            this._register(this.textArea.onInput(function () {
                // console.log('onInput: ' + this.textArea.getValue());
                if (_this.textareaIsShownAtCursor) {
                    // console.log('::ignoring input event because the textarea is shown at cursor: ' + this.textArea.getValue());
                    return;
                }
                readFromTextArea();
            }));
            // --- Clipboard operations
            this._register(this.textArea.onCut(function (e) {
                // Ensure we have the latest selection => ask all pending events to be sent
                _this.flushAnyAccumulatedEvents();
                _this._ensureClipboardGetsEditorSelection(e);
                _this.asyncTriggerCut.schedule();
            }));
            this._register(this.textArea.onCopy(function (e) {
                // Ensure we have the latest selection => ask all pending events to be sent
                _this.flushAnyAccumulatedEvents();
                _this._ensureClipboardGetsEditorSelection(e);
            }));
            this._register(this.textArea.onPaste(function (e) {
                if (e.canUseTextData()) {
                    _this.executePaste(e.getTextData());
                }
                else {
                    if (_this.textArea.getSelectionStart() !== _this.textArea.getSelectionEnd()) {
                        // Clean up the textarea, to get a clean paste
                        _this.setTextAreaState('paste', _this.textAreaState.toEmpty());
                    }
                    _this._nextCommand = ReadFromTextArea.Paste;
                }
            }));
            this._writePlaceholderAndSelectTextArea('ctor');
        }
        TextAreaHandler.prototype.dispose = function () {
            this.asyncTriggerCut.dispose();
            _super.prototype.dispose.call(this);
        };
        // --- begin event handlers
        TextAreaHandler.prototype.setStrategy = function (strategy) {
            this.textAreaState = this.textAreaState.toStrategy(strategy);
        };
        TextAreaHandler.prototype.setHasFocus = function (isFocused) {
            if (this.hasFocus === isFocused) {
                // no change
                return;
            }
            this.hasFocus = isFocused;
            if (this.hasFocus) {
                this._writePlaceholderAndSelectTextArea('focusgain');
            }
        };
        TextAreaHandler.prototype.setCursorSelections = function (primary, secondary) {
            this.selection = primary;
            this.selections = [primary].concat(secondary);
            this._writePlaceholderAndSelectTextArea('selection changed');
        };
        TextAreaHandler.prototype.setCursorPosition = function (primary) {
            this.cursorPosition = primary;
        };
        // --- end event handlers
        TextAreaHandler.prototype.setTextAreaState = function (reason, textAreaState) {
            if (!this.hasFocus) {
                textAreaState = textAreaState.resetSelection();
            }
            textAreaState.applyToTextArea(reason, this.textArea, this.hasFocus);
            this.textAreaState = textAreaState;
        };
        TextAreaHandler.prototype._onKeyDownHandler = function (e) {
            if (e.equals(keyCodes_1.CommonKeybindings.ESCAPE)) {
                // Prevent default always for `Esc`, otherwise it will generate a keypress
                // See https://msdn.microsoft.com/en-us/library/ie/ms536939(v=vs.85).aspx
                e.preventDefault();
            }
            this._onKeyDown.fire(e);
        };
        TextAreaHandler.prototype._onKeyPressHandler = function (e) {
            if (!this.hasFocus) {
                // Sometimes, when doing Alt-Tab, in FF, a 'keypress' is sent before a 'focus'
                return;
            }
        };
        // ------------- Operations that are always executed asynchronously
        TextAreaHandler.prototype.executePaste = function (txt) {
            if (txt === '') {
                return;
            }
            var pasteOnNewLine = false;
            if (this.Browser.enableEmptySelectionClipboard) {
                pasteOnNewLine = (txt === this.lastCopiedValue && this.lastCopiedValueIsFromEmptySelection);
            }
            this._onPaste.fire({
                text: txt,
                pasteOnNewLine: pasteOnNewLine
            });
        };
        TextAreaHandler.prototype.writePlaceholderAndSelectTextAreaSync = function () {
            this._writePlaceholderAndSelectTextArea('focusTextArea');
        };
        TextAreaHandler.prototype._writePlaceholderAndSelectTextArea = function (reason) {
            if (!this.textareaIsShownAtCursor) {
                // Do not write to the textarea if it is visible.
                if (this.Browser.isIPad) {
                    // Do not place anything in the textarea for the iPad
                    this.setTextAreaState(reason, this.textAreaState.toEmpty());
                }
                else {
                    this.setTextAreaState(reason, this.textAreaState.fromEditorSelection(this.model, this.selection));
                }
            }
        };
        // ------------- Clipboard operations
        TextAreaHandler.prototype._ensureClipboardGetsEditorSelection = function (e) {
            var whatToCopy = this._getPlainTextToCopy();
            if (e.canUseTextData()) {
                e.setTextData(whatToCopy);
            }
            else {
                this.setTextAreaState('copy or cut', this.textAreaState.fromText(whatToCopy));
            }
            if (this.Browser.enableEmptySelectionClipboard) {
                if (this.Browser.isFirefox) {
                    // When writing "LINE\r\n" to the clipboard and then pasting,
                    // Firefox pastes "LINE\n", so let's work around this quirk
                    this.lastCopiedValue = whatToCopy.replace(/\r\n/g, '\n');
                }
                else {
                    this.lastCopiedValue = whatToCopy;
                }
                var selections = this.selections;
                this.lastCopiedValueIsFromEmptySelection = (selections.length === 1 && selections[0].isEmpty());
            }
        };
        TextAreaHandler.prototype._getPlainTextToCopy = function () {
            var newLineCharacter = this.model.getEOL();
            var selections = this.selections;
            if (selections.length === 1) {
                var range = selections[0];
                if (range.isEmpty()) {
                    if (this.Browser.enableEmptySelectionClipboard) {
                        var modelLineNumber = this.model.convertViewPositionToModelPosition(range.startLineNumber, 1).lineNumber;
                        return this.model.getModelLineContent(modelLineNumber) + newLineCharacter;
                    }
                    else {
                        return '';
                    }
                }
                return this.model.getValueInRange(range, editorCommon_1.EndOfLinePreference.TextDefined);
            }
            else {
                selections = selections.slice(0).sort(range_1.Range.compareRangesUsingStarts);
                var result = [];
                for (var i = 0; i < selections.length; i++) {
                    result.push(this.model.getValueInRange(selections[i], editorCommon_1.EndOfLinePreference.TextDefined));
                }
                return result.join(newLineCharacter);
            }
        };
        return TextAreaHandler;
    }(lifecycle_1.Disposable));
    exports.TextAreaHandler = TextAreaHandler;
});






define(__m[162], __M([0,1,12,27,21,22,44]), function (require, exports, keyCodes_1, styleMutator_1, position_1, editorBrowser, widget_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ContentHoverWidget = (function (_super) {
        __extends(ContentHoverWidget, _super);
        function ContentHoverWidget(id, editor) {
            var _this = this;
            _super.call(this);
            // Editor.IContentWidget.allowEditorOverflow
            this.allowEditorOverflow = true;
            this._id = id;
            this._editor = editor;
            this._isVisible = false;
            this._containerDomNode = document.createElement('div');
            this._containerDomNode.className = 'monaco-editor-hover monaco-editor-background';
            this._domNode = document.createElement('div');
            this._domNode.style.display = 'inline-block';
            this._containerDomNode.appendChild(this._domNode);
            this._containerDomNode.tabIndex = 0;
            this.onkeydown(this._containerDomNode, function (e) {
                if (e.equals(keyCodes_1.CommonKeybindings.ESCAPE)) {
                    _this.hide();
                }
            });
            this._editor.applyFontInfo(this._domNode);
            this._register(this._editor.onDidChangeConfiguration(function (e) {
                if (e.fontInfo) {
                    _this._editor.applyFontInfo(_this._domNode);
                }
            }));
            this._editor.addContentWidget(this);
            this._showAtPosition = null;
        }
        ContentHoverWidget.prototype.getId = function () {
            return this._id;
        };
        ContentHoverWidget.prototype.getDomNode = function () {
            return this._containerDomNode;
        };
        ContentHoverWidget.prototype.showAt = function (position, focus) {
            // Position has changed
            this._showAtPosition = new position_1.Position(position.lineNumber, position.column);
            this._isVisible = true;
            var editorMaxWidth = Math.min(800, parseInt(this._containerDomNode.style.maxWidth, 10));
            // When scrolled horizontally, the div does not want to occupy entire visible area.
            styleMutator_1.StyleMutator.setWidth(this._containerDomNode, editorMaxWidth);
            styleMutator_1.StyleMutator.setHeight(this._containerDomNode, 0);
            styleMutator_1.StyleMutator.setLeft(this._containerDomNode, 0);
            var renderedWidth = Math.min(editorMaxWidth, this._domNode.clientWidth + 5);
            var renderedHeight = this._domNode.clientHeight + 1;
            styleMutator_1.StyleMutator.setWidth(this._containerDomNode, renderedWidth);
            styleMutator_1.StyleMutator.setHeight(this._containerDomNode, renderedHeight);
            this._editor.layoutContentWidget(this);
            // Simply force a synchronous render on the editor
            // such that the widget does not really render with left = '0px'
            this._editor.render();
            this._stoleFocus = focus;
            if (focus) {
                this._containerDomNode.focus();
            }
        };
        ContentHoverWidget.prototype.hide = function () {
            if (!this._isVisible) {
                return;
            }
            this._isVisible = false;
            this._editor.layoutContentWidget(this);
            if (this._stoleFocus) {
                this._editor.focus();
            }
        };
        ContentHoverWidget.prototype.getPosition = function () {
            if (this._isVisible) {
                return {
                    position: this._showAtPosition,
                    preference: [
                        editorBrowser.ContentWidgetPositionPreference.ABOVE,
                        editorBrowser.ContentWidgetPositionPreference.BELOW
                    ]
                };
            }
            return null;
        };
        ContentHoverWidget.prototype.dispose = function () {
            this._editor.removeContentWidget(this);
            _super.prototype.dispose.call(this);
        };
        return ContentHoverWidget;
    }(widget_1.Widget));
    exports.ContentHoverWidget = ContentHoverWidget;
    var GlyphHoverWidget = (function (_super) {
        __extends(GlyphHoverWidget, _super);
        function GlyphHoverWidget(id, editor) {
            var _this = this;
            _super.call(this);
            this._id = id;
            this._editor = editor;
            this._isVisible = false;
            this._domNode = document.createElement('div');
            this._domNode.className = 'monaco-editor-hover monaco-editor-background';
            this._domNode.style.display = 'none';
            this._domNode.setAttribute('aria-hidden', 'true');
            this._domNode.setAttribute('role', 'presentation');
            this._showAtLineNumber = -1;
            this._editor.applyFontInfo(this._domNode);
            this._register(this._editor.onDidChangeConfiguration(function (e) {
                if (e.fontInfo) {
                    _this._editor.applyFontInfo(_this._domNode);
                }
            }));
            this._editor.addOverlayWidget(this);
        }
        GlyphHoverWidget.prototype.getId = function () {
            return this._id;
        };
        GlyphHoverWidget.prototype.getDomNode = function () {
            return this._domNode;
        };
        GlyphHoverWidget.prototype.showAt = function (lineNumber) {
            this._showAtLineNumber = lineNumber;
            if (!this._isVisible) {
                this._isVisible = true;
                this._domNode.style.display = 'block';
            }
            var editorLayout = this._editor.getLayoutInfo();
            var topForLineNumber = this._editor.getTopForLineNumber(this._showAtLineNumber);
            var editorScrollTop = this._editor.getScrollTop();
            this._domNode.style.left = (editorLayout.glyphMarginLeft + editorLayout.glyphMarginWidth) + 'px';
            this._domNode.style.top = (topForLineNumber - editorScrollTop) + 'px';
        };
        GlyphHoverWidget.prototype.hide = function () {
            if (!this._isVisible) {
                return;
            }
            this._isVisible = false;
            this._domNode.style.display = 'none';
        };
        GlyphHoverWidget.prototype.getPosition = function () {
            return null;
        };
        GlyphHoverWidget.prototype.dispose = function () {
            this._editor.removeOverlayWidget(this);
            _super.prototype.dispose.call(this);
        };
        return GlyphHoverWidget;
    }(widget_1.Widget));
    exports.GlyphHoverWidget = GlyphHoverWidget;
});






define(__m[286], __M([0,1,129,162]), function (require, exports, hoverOperation_1, hoverWidgets_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MarginComputer = (function () {
        function MarginComputer(editor) {
            this._editor = editor;
            this._lineNumber = -1;
        }
        MarginComputer.prototype.setLineNumber = function (lineNumber) {
            this._lineNumber = lineNumber;
            this._result = [];
        };
        MarginComputer.prototype.clearResult = function () {
            this._result = [];
        };
        MarginComputer.prototype.computeSync = function () {
            var result = [], lineDecorations = this._editor.getLineDecorations(this._lineNumber), i, len, d;
            for (i = 0, len = lineDecorations.length; i < len; i++) {
                d = lineDecorations[i];
                if (d.options.glyphMarginClassName && d.options.glyphMarginHoverMessage) {
                    result.push({
                        value: d.options.glyphMarginHoverMessage
                    });
                }
            }
            return result;
        };
        MarginComputer.prototype.onResult = function (result, isFromSynchronousComputation) {
            this._result = this._result.concat(result);
        };
        MarginComputer.prototype.getResult = function () {
            return this._result;
        };
        MarginComputer.prototype.getResultWithLoadingMessage = function () {
            return this.getResult();
        };
        return MarginComputer;
    }());
    var ModesGlyphHoverWidget = (function (_super) {
        __extends(ModesGlyphHoverWidget, _super);
        function ModesGlyphHoverWidget(editor) {
            var _this = this;
            _super.call(this, ModesGlyphHoverWidget.ID, editor);
            this._lastLineNumber = -1;
            this._computer = new MarginComputer(this._editor);
            this._hoverOperation = new hoverOperation_1.HoverOperation(this._computer, function (result) { return _this._withResult(result); }, null, function (result) { return _this._withResult(result); });
        }
        ModesGlyphHoverWidget.prototype.dispose = function () {
            this._hoverOperation.cancel();
            _super.prototype.dispose.call(this);
        };
        ModesGlyphHoverWidget.prototype.onModelDecorationsChanged = function () {
            if (this._isVisible) {
                // The decorations have changed and the hover is visible,
                // we need to recompute the displayed text
                this._hoverOperation.cancel();
                this._computer.clearResult();
                this._hoverOperation.start();
            }
        };
        ModesGlyphHoverWidget.prototype.startShowingAt = function (lineNumber) {
            if (this._lastLineNumber === lineNumber) {
                // We have to show the widget at the exact same line number as before, so no work is needed
                return;
            }
            this._hoverOperation.cancel();
            this.hide();
            this._lastLineNumber = lineNumber;
            this._computer.setLineNumber(lineNumber);
            this._hoverOperation.start();
        };
        ModesGlyphHoverWidget.prototype.hide = function () {
            this._lastLineNumber = -1;
            this._hoverOperation.cancel();
            _super.prototype.hide.call(this);
        };
        ModesGlyphHoverWidget.prototype._withResult = function (result) {
            this._messages = result;
            if (this._messages.length > 0) {
                this._renderMessages(this._lastLineNumber, this._messages);
            }
            else {
                this.hide();
            }
        };
        ModesGlyphHoverWidget.prototype._renderMessages = function (lineNumber, messages) {
            var fragment = document.createDocumentFragment();
            messages.forEach(function (msg) {
                var row = document.createElement('div');
                var span = null;
                if (msg.className) {
                    span = document.createElement('span');
                    span.textContent = msg.value;
                    span.className = msg.className;
                    row.appendChild(span);
                }
                else {
                    row.textContent = msg.value;
                }
                fragment.appendChild(row);
            });
            this._domNode.textContent = '';
            this._domNode.appendChild(fragment);
            // show
            this.showAt(lineNumber);
        };
        ModesGlyphHoverWidget.ID = 'editor.contrib.modesGlyphHoverWidget';
        return ModesGlyphHoverWidget;
    }(hoverWidgets_1.GlyphHoverWidget));
    exports.ModesGlyphHoverWidget = ModesGlyphHoverWidget;
});

define(__m[287], __M([0,1,3,11,21,22]), function (require, exports, lifecycle_1, dom, position_1, editorBrowser_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LightBulpWidget = (function () {
        function LightBulpWidget(editor, onclick) {
            // Editor.IContentWidget.allowEditorOverflow
            this.allowEditorOverflow = true;
            this.editor = editor;
            this.onclick = onclick;
            this.toDispose = [];
            this.editor.addContentWidget(this);
        }
        LightBulpWidget.prototype.dispose = function () {
            this.editor.removeContentWidget(this);
            this.toDispose = lifecycle_1.dispose(this.toDispose);
        };
        LightBulpWidget.prototype.getId = function () {
            return '__lightBulpWidget';
        };
        LightBulpWidget.prototype.getDomNode = function () {
            var _this = this;
            if (!this.domNode) {
                this.domNode = document.createElement('div');
                this.domNode.style.width = '20px';
                this.domNode.style.height = '20px';
                this.domNode.className = 'lightbulp-glyph';
                this.toDispose.push(dom.addDisposableListener(this.domNode, 'click', function (e) {
                    _this.editor.focus();
                    _this.onclick(_this.position);
                }));
            }
            return this.domNode;
        };
        LightBulpWidget.prototype.getPosition = function () {
            return this.visible
                ? { position: this.position, preference: [editorBrowser_1.ContentWidgetPositionPreference.BELOW, editorBrowser_1.ContentWidgetPositionPreference.ABOVE] }
                : null;
        };
        LightBulpWidget.prototype.show = function (where) {
            if (this.visible && position_1.Position.equals(this.position, where)) {
                return;
            }
            this.position = where;
            this.visible = true;
            this.editor.layoutContentWidget(this);
        };
        LightBulpWidget.prototype.hide = function () {
            if (!this.visible) {
                return;
            }
            this.visible = false;
            this.editor.layoutContentWidget(this);
        };
        return LightBulpWidget;
    }());
    exports.LightBulpWidget = LightBulpWidget;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[164], __M([0,1,3,31,11,123,4,244]), function (require, exports, lifecycle_1, objects, dom, sash_1, range_1) {
    'use strict';
    var defaultOptions = {
        showArrow: true,
        showFrame: true,
        frameColor: '',
        className: ''
    };
    var WIDGET_ID = 'vs.editor.contrib.zoneWidget';
    var ViewZoneDelegate = (function () {
        function ViewZoneDelegate(domNode, afterLineNumber, afterColumn, heightInLines, onDomNodeTop, onComputedHeight) {
            this.domNode = domNode;
            this.afterLineNumber = afterLineNumber;
            this.afterColumn = afterColumn;
            this.heightInLines = heightInLines;
            this._onDomNodeTop = onDomNodeTop;
            this._onComputedHeight = onComputedHeight;
        }
        ViewZoneDelegate.prototype.onDomNodeTop = function (top) {
            this._onDomNodeTop(top);
        };
        ViewZoneDelegate.prototype.onComputedHeight = function (height) {
            this._onComputedHeight(height);
        };
        return ViewZoneDelegate;
    }());
    exports.ViewZoneDelegate = ViewZoneDelegate;
    var OverlayWidgetDelegate = (function () {
        function OverlayWidgetDelegate(id, domNode) {
            this._id = id;
            this._domNode = domNode;
        }
        OverlayWidgetDelegate.prototype.getId = function () {
            return this._id;
        };
        OverlayWidgetDelegate.prototype.getDomNode = function () {
            return this._domNode;
        };
        OverlayWidgetDelegate.prototype.getPosition = function () {
            return null;
        };
        return OverlayWidgetDelegate;
    }());
    exports.OverlayWidgetDelegate = OverlayWidgetDelegate;
    var ZoneWidget = (function () {
        function ZoneWidget(editor, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            this._viewZone = null;
            this._overlayWidget = null;
            this._disposables = new lifecycle_1.Disposables();
            this.container = null;
            this.editor = editor;
            this.options = objects.mixin(objects.clone(defaultOptions), options);
            this.domNode = document.createElement('div');
            if (!this.options.isAccessible) {
                this.domNode.setAttribute('aria-hidden', 'true');
                this.domNode.setAttribute('role', 'presentation');
            }
            this._disposables.add(this.editor.onDidLayoutChange(function (info) {
                var width = _this._getWidth(info);
                _this.domNode.style.width = width + 'px';
                _this._onWidth(width);
            }));
        }
        ZoneWidget.prototype.create = function () {
            dom.addClass(this.domNode, 'zone-widget');
            dom.addClass(this.domNode, this.options.className);
            this.container = document.createElement('div');
            dom.addClass(this.container, 'zone-widget-container');
            this.domNode.appendChild(this.container);
            this._fillContainer(this.container);
            this._initSash();
        };
        ZoneWidget.prototype._getWidth = function (info) {
            if (info === void 0) { info = this.editor.getLayoutInfo(); }
            return info.width - info.verticalScrollbarWidth;
        };
        ZoneWidget.prototype._onViewZoneTop = function (top) {
            this.domNode.style.top = top + 'px';
        };
        ZoneWidget.prototype._onViewZoneHeight = function (height) {
            this.domNode.style.height = height + "px";
            var containerHeight = height - this._decoratingElementsHeight();
            this.container.style.height = containerHeight + "px";
            this._doLayout(containerHeight, this._getWidth());
            this._resizeSash.layout();
        };
        ZoneWidget.prototype.show = function (rangeOrPos, heightInLines) {
            var range = range_1.Range.isIRange(rangeOrPos)
                ? rangeOrPos
                : new range_1.Range(rangeOrPos.lineNumber, rangeOrPos.column, rangeOrPos.lineNumber, rangeOrPos.column);
            this._showImpl(range, heightInLines);
        };
        ZoneWidget.prototype._decoratingElementsHeight = function () {
            var lineHeight = this.editor.getConfiguration().lineHeight;
            var result = 0;
            if (this.options.showArrow) {
                var arrowHeight = Math.round(lineHeight / 3);
                result += 2 * arrowHeight;
            }
            if (this.options.showFrame) {
                var frameThickness = Math.round(lineHeight / 9);
                result += 2 * frameThickness;
            }
            return result;
        };
        ZoneWidget.prototype._showImpl = function (where, heightInLines) {
            var _this = this;
            var position = {
                lineNumber: where.startLineNumber,
                column: where.startColumn
            };
            var width = this._getWidth();
            this.domNode.style.width = width + "px";
            // Reveal position, to get the line rendered, such that the arrow can be positioned properly
            this.editor.revealPosition(position);
            // Render the widget as zone (rendering) and widget (lifecycle)
            var viewZoneDomNode = document.createElement('div'), arrow = document.createElement('div'), lineHeight = this.editor.getConfiguration().lineHeight, arrowHeight = 0, frameThickness = 0;
            // Render the arrow one 1/3 of an editor line height
            if (this.options.showArrow) {
                arrowHeight = Math.round(lineHeight / 3);
                arrow = document.createElement('div');
                arrow.className = 'zone-widget-arrow below';
                arrow.style.top = -arrowHeight + 'px';
                arrow.style.borderWidth = arrowHeight + 'px';
                arrow.style.left = this.editor.getOffsetForColumn(position.lineNumber, position.column) + 'px';
                arrow.style.borderBottomColor = this.options.frameColor;
                viewZoneDomNode.appendChild(arrow);
            }
            // Render the frame as 1/9 of an editor line height
            if (this.options.showFrame) {
                frameThickness = Math.round(lineHeight / 9);
            }
            // insert zone widget
            this.editor.changeViewZones(function (accessor) {
                if (_this._viewZone) {
                    accessor.removeZone(_this._viewZone.id);
                }
                if (_this._overlayWidget) {
                    _this.editor.removeOverlayWidget(_this._overlayWidget);
                    _this._overlayWidget = null;
                }
                _this.domNode.style.top = '-1000px';
                _this._viewZone = new ViewZoneDelegate(viewZoneDomNode, position.lineNumber, position.column, heightInLines, function (top) { return _this._onViewZoneTop(top); }, function (height) { return _this._onViewZoneHeight(height); });
                _this._viewZone.id = accessor.addZone(_this._viewZone);
                _this._overlayWidget = new OverlayWidgetDelegate(WIDGET_ID + _this._viewZone.id, _this.domNode);
                _this.editor.addOverlayWidget(_this._overlayWidget);
            });
            if (this.options.showFrame) {
                this.container.style.borderTopColor = this.options.frameColor;
                this.container.style.borderBottomColor = this.options.frameColor;
                this.container.style.borderTopWidth = frameThickness + 'px';
                this.container.style.borderBottomWidth = frameThickness + 'px';
            }
            var containerHeight = heightInLines * lineHeight - this._decoratingElementsHeight();
            this.container.style.top = arrowHeight + 'px';
            this.container.style.height = containerHeight + 'px';
            this.container.style.overflow = 'hidden';
            this._doLayout(containerHeight, width);
            this.editor.setSelection(where);
            // Reveal the line above or below the zone widget, to get the zone widget in the viewport
            var revealLineNumber = Math.min(this.editor.getModel().getLineCount(), Math.max(1, where.endLineNumber + 1));
            this.editor.revealLine(revealLineNumber);
            this.position = position;
        };
        ZoneWidget.prototype.dispose = function () {
            var _this = this;
            this._disposables.dispose();
            if (this._overlayWidget) {
                this.editor.removeOverlayWidget(this._overlayWidget);
                this._overlayWidget = null;
            }
            if (this._viewZone) {
                this.editor.changeViewZones(function (accessor) {
                    accessor.removeZone(_this._viewZone.id);
                    _this._viewZone = null;
                });
            }
        };
        ZoneWidget.prototype._onWidth = function (widthInPixel) {
            // implement in subclass
        };
        ZoneWidget.prototype._doLayout = function (heightInPixel, widthInPixel) {
            // implement in subclass
        };
        // --- sash
        ZoneWidget.prototype._initSash = function () {
            var _this = this;
            this._resizeSash = new sash_1.Sash(this.domNode, this, { orientation: sash_1.Orientation.HORIZONTAL });
            if (!this.options.isResizeable) {
                this._resizeSash.hide();
                this._resizeSash.disable();
            }
            var data;
            this._disposables.add(this._resizeSash.addListener2('start', function (e) {
                if (_this._viewZone) {
                    data = {
                        startY: e.startY,
                        heightInLines: _this._viewZone.heightInLines,
                    };
                }
            }));
            this._disposables.add(this._resizeSash.addListener2('end', function () {
                data = undefined;
            }));
            this._disposables.add(this._resizeSash.addListener2('change', function (evt) {
                if (data) {
                    var lineDelta = (evt.currentY - data.startY) / _this.editor.getConfiguration().lineHeight;
                    var roundedLineDelta = lineDelta < 0 ? Math.ceil(lineDelta) : Math.floor(lineDelta);
                    var newHeightInLines_1 = data.heightInLines + roundedLineDelta;
                    if (newHeightInLines_1 > 5 && newHeightInLines_1 < 35) {
                        _this.editor.changeViewZones(function (accessor) {
                            _this._viewZone.heightInLines = newHeightInLines_1;
                            accessor.layoutZone(_this._viewZone.id);
                        });
                    }
                }
            }));
        };
        ZoneWidget.prototype.getHorizontalSashLeft = function () {
            return 0;
        };
        ZoneWidget.prototype.getHorizontalSashTop = function () {
            return parseInt(this.domNode.style.height) - (this._decoratingElementsHeight() / 2);
        };
        ZoneWidget.prototype.getHorizontalSashWidth = function () {
            return this.editor.getLayoutInfo().width;
        };
        return ZoneWidget;
    }());
    exports.ZoneWidget = ZoneWidget;
});

define(__m[289], __M([5,6]), function(nls, data) { return nls.create("vs/base/common/severity", data); });
define(__m[32], __M([0,1,289,10]), function (require, exports, nls, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Severity;
    (function (Severity) {
        Severity[Severity["Ignore"] = 0] = "Ignore";
        Severity[Severity["Info"] = 1] = "Info";
        Severity[Severity["Warning"] = 2] = "Warning";
        Severity[Severity["Error"] = 3] = "Error";
    })(Severity || (Severity = {}));
    var Severity;
    (function (Severity) {
        var _error = 'error', _warning = 'warning', _warn = 'warn', _info = 'info';
        var _displayStrings = Object.create(null);
        _displayStrings[Severity.Error] = nls.localize(0, null);
        _displayStrings[Severity.Warning] = nls.localize(1, null);
        _displayStrings[Severity.Info] = nls.localize(2, null);
        /**
         * Parses 'error', 'warning', 'warn', 'info' in call casings
         * and falls back to ignore.
         */
        function fromValue(value) {
            if (!value) {
                return Severity.Ignore;
            }
            if (strings.equalsIgnoreCase(_error, value)) {
                return Severity.Error;
            }
            if (strings.equalsIgnoreCase(_warning, value) || strings.equalsIgnoreCase(_warn, value)) {
                return Severity.Warning;
            }
            if (strings.equalsIgnoreCase(_info, value)) {
                return Severity.Info;
            }
            return Severity.Ignore;
        }
        Severity.fromValue = fromValue;
        function toString(value) {
            return _displayStrings[value] || strings.empty;
        }
        Severity.toString = toString;
        function compare(a, b) {
            return b - a;
        }
        Severity.compare = compare;
    })(Severity || (Severity = {}));
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Severity;
});

define(__m[169], __M([0,1,16,12,21,4,24,2,104,32,29]), function (require, exports, event_1, keyCodes_1, position_1, range_1, selection_1, winjs_base_1, cancellation_1, severity_1, uri_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function createMonacoBaseAPI() {
        return {
            editor: undefined,
            languages: undefined,
            CancellationTokenSource: cancellation_1.CancellationTokenSource,
            Emitter: event_1.Emitter,
            KeyCode: keyCodes_1.KeyCode,
            KeyMod: keyCodes_1.KeyMod,
            Position: position_1.Position,
            Range: range_1.Range,
            Selection: selection_1.Selection,
            SelectionDirection: selection_1.SelectionDirection,
            Severity: severity_1.default,
            Promise: winjs_base_1.TPromise,
            Uri: uri_1.default
        };
    }
    exports.createMonacoBaseAPI = createMonacoBaseAPI;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[292], __M([0,1,29,2,4,65,285,419,377,386,76,169]), function (require, exports, uri_1, winjs_base_1, range_1, filters_1, diffComputer_1, mirrorModel2_1, linkComputer_1, inplaceReplaceSupport_1, wordHelper_1, standaloneBase_1) {
    'use strict';
    /**
     * @internal
     */
    var MirrorModel = (function (_super) {
        __extends(MirrorModel, _super);
        function MirrorModel() {
            _super.apply(this, arguments);
        }
        Object.defineProperty(MirrorModel.prototype, "uri", {
            get: function () {
                return this._uri;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MirrorModel.prototype, "version", {
            get: function () {
                return this._versionId;
            },
            enumerable: true,
            configurable: true
        });
        MirrorModel.prototype.getValue = function () {
            return this.getText();
        };
        MirrorModel.prototype.getLinesContent = function () {
            return this._lines.slice(0);
        };
        MirrorModel.prototype.getLineCount = function () {
            return this._lines.length;
        };
        MirrorModel.prototype.getLineContent = function (lineNumber) {
            return this._lines[lineNumber - 1];
        };
        MirrorModel.prototype.getWordAtPosition = function (position, wordDefinition) {
            var wordAtText = wordHelper_1.getWordAtText(position.column, wordHelper_1.ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);
            if (wordAtText) {
                return new range_1.Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);
            }
            return null;
        };
        MirrorModel.prototype.getWordUntilPosition = function (position, wordDefinition) {
            var wordAtPosition = this.getWordAtPosition(position, wordDefinition);
            if (!wordAtPosition) {
                return {
                    word: '',
                    startColumn: position.column,
                    endColumn: position.column
                };
            }
            return {
                word: this._lines[position.lineNumber - 1].substring(wordAtPosition.startColumn - 1, position.column - 1),
                startColumn: wordAtPosition.startColumn,
                endColumn: position.column
            };
        };
        MirrorModel.prototype._getAllWords = function (wordDefinition) {
            var _this = this;
            var result = [];
            this._lines.forEach(function (line) {
                _this._wordenize(line, wordDefinition).forEach(function (info) {
                    result.push(line.substring(info.start, info.end));
                });
            });
            return result;
        };
        MirrorModel.prototype.getAllUniqueWords = function (wordDefinition, skipWordOnce) {
            var foundSkipWord = false;
            var uniqueWords = {};
            return this._getAllWords(wordDefinition).filter(function (word) {
                if (skipWordOnce && !foundSkipWord && skipWordOnce === word) {
                    foundSkipWord = true;
                    return false;
                }
                else if (uniqueWords[word]) {
                    return false;
                }
                else {
                    uniqueWords[word] = true;
                    return true;
                }
            });
        };
        // TODO@Joh, TODO@Alex - remove these and make sure the super-things work
        MirrorModel.prototype._wordenize = function (content, wordDefinition) {
            var result = [];
            var match;
            while (match = wordDefinition.exec(content)) {
                if (match[0].length === 0) {
                    // it did match the empty string
                    break;
                }
                result.push({ start: match.index, end: match.index + match[0].length });
            }
            return result;
        };
        MirrorModel.prototype.getValueInRange = function (range) {
            if (range.startLineNumber === range.endLineNumber) {
                return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);
            }
            var lineEnding = this._eol, startLineIndex = range.startLineNumber - 1, endLineIndex = range.endLineNumber - 1, resultLines = [];
            resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));
            for (var i = startLineIndex + 1; i < endLineIndex; i++) {
                resultLines.push(this._lines[i]);
            }
            resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));
            return resultLines.join(lineEnding);
        };
        return MirrorModel;
    }(mirrorModel2_1.MirrorModel2));
    exports.MirrorModel = MirrorModel;
    /**
     * @internal
     */
    var BaseEditorSimpleWorker = (function () {
        function BaseEditorSimpleWorker() {
            this._foreignModule = null;
        }
        // ---- BEGIN diff --------------------------------------------------------------------------
        BaseEditorSimpleWorker.prototype.computeDiff = function (originalUrl, modifiedUrl, ignoreTrimWhitespace) {
            var original = this._getModel(originalUrl);
            var modified = this._getModel(modifiedUrl);
            if (!original || !modified) {
                return null;
            }
            var originalLines = original.getLinesContent();
            var modifiedLines = modified.getLinesContent();
            var diffComputer = new diffComputer_1.DiffComputer(originalLines, modifiedLines, {
                shouldPostProcessCharChanges: true,
                shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,
                shouldConsiderTrimWhitespaceInEmptyCase: true
            });
            return winjs_base_1.TPromise.as(diffComputer.computeDiff());
        };
        BaseEditorSimpleWorker.prototype.computeDirtyDiff = function (originalUrl, modifiedUrl, ignoreTrimWhitespace) {
            var original = this._getModel(originalUrl);
            var modified = this._getModel(modifiedUrl);
            if (!original || !modified) {
                return null;
            }
            var originalLines = original.getLinesContent();
            var modifiedLines = modified.getLinesContent();
            var diffComputer = new diffComputer_1.DiffComputer(originalLines, modifiedLines, {
                shouldPostProcessCharChanges: false,
                shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,
                shouldConsiderTrimWhitespaceInEmptyCase: false
            });
            return winjs_base_1.TPromise.as(diffComputer.computeDiff());
        };
        // ---- END diff --------------------------------------------------------------------------
        BaseEditorSimpleWorker.prototype.computeLinks = function (modelUrl) {
            var model = this._getModel(modelUrl);
            if (!model) {
                return null;
            }
            return winjs_base_1.TPromise.as(linkComputer_1.computeLinks(model));
        };
        // ---- BEGIN suggest --------------------------------------------------------------------------
        BaseEditorSimpleWorker.prototype.textualSuggest = function (modelUrl, position, wordDef, wordDefFlags) {
            var model = this._getModel(modelUrl);
            if (!model) {
                return null;
            }
            return winjs_base_1.TPromise.as(this._suggestFiltered(model, position, new RegExp(wordDef, wordDefFlags)));
        };
        BaseEditorSimpleWorker.prototype._suggestFiltered = function (model, position, wordDefRegExp) {
            var value = this._suggestUnfiltered(model, position, wordDefRegExp);
            // filter suggestions
            return [{
                    currentWord: value.currentWord,
                    suggestions: value.suggestions.filter(function (element) { return !!filters_1.fuzzyContiguousFilter(value.currentWord, element.label); }),
                    incomplete: value.incomplete
                }];
        };
        BaseEditorSimpleWorker.prototype._suggestUnfiltered = function (model, position, wordDefRegExp) {
            var currentWord = model.getWordUntilPosition(position, wordDefRegExp).word;
            var allWords = model.getAllUniqueWords(wordDefRegExp, currentWord);
            var suggestions = allWords.filter(function (word) {
                return !(/^-?\d*\.?\d/.test(word)); // filter out numbers
            }).map(function (word) {
                return {
                    type: 'text',
                    label: word,
                    codeSnippet: word,
                    noAutoAccept: true
                };
            });
            return {
                currentWord: currentWord,
                suggestions: suggestions
            };
        };
        // ---- END suggest --------------------------------------------------------------------------
        BaseEditorSimpleWorker.prototype.navigateValueSet = function (modelUrl, range, up, wordDef, wordDefFlags) {
            var model = this._getModel(modelUrl);
            if (!model) {
                return null;
            }
            var wordDefRegExp = new RegExp(wordDef, wordDefFlags);
            if (range.startColumn === range.endColumn) {
                range.endColumn += 1;
            }
            var selectionText = model.getValueInRange(range);
            var wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);
            var word = null;
            if (wordRange !== null) {
                word = model.getValueInRange(wordRange);
            }
            var result = inplaceReplaceSupport_1.BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);
            return winjs_base_1.TPromise.as(result);
        };
        // ---- BEGIN foreign module support --------------------------------------------------------------------------
        BaseEditorSimpleWorker.prototype.loadForeignModule = function (moduleId, createData) {
            var _this = this;
            return new winjs_base_1.TPromise(function (c, e) {
                // Use the global require to be sure to get the global config
                self.require([moduleId], function (foreignModule) {
                    var ctx = {
                        getMirrorModels: function () {
                            return _this._getModels();
                        }
                    };
                    _this._foreignModule = foreignModule.create(ctx, createData);
                    var methods = [];
                    for (var prop in _this._foreignModule) {
                        if (typeof _this._foreignModule[prop] === 'function') {
                            methods.push(prop);
                        }
                    }
                    c(methods);
                }, e);
            });
        };
        // foreign method request
        BaseEditorSimpleWorker.prototype.fmr = function (method, args) {
            if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {
                return winjs_base_1.TPromise.wrapError(new Error('Missing requestHandler or method: ' + method));
            }
            try {
                return winjs_base_1.TPromise.as(this._foreignModule[method].apply(this._foreignModule, args));
            }
            catch (e) {
                return winjs_base_1.TPromise.wrapError(e);
            }
        };
        return BaseEditorSimpleWorker;
    }());
    exports.BaseEditorSimpleWorker = BaseEditorSimpleWorker;
    /**
     * @internal
     */
    var EditorSimpleWorkerImpl = (function (_super) {
        __extends(EditorSimpleWorkerImpl, _super);
        function EditorSimpleWorkerImpl() {
            _super.call(this);
            this._models = Object.create(null);
        }
        EditorSimpleWorkerImpl.prototype.dispose = function () {
            this._models = Object.create(null);
        };
        EditorSimpleWorkerImpl.prototype._getModel = function (uri) {
            return this._models[uri];
        };
        EditorSimpleWorkerImpl.prototype._getModels = function () {
            var _this = this;
            var all = [];
            Object.keys(this._models).forEach(function (key) { return all.push(_this._models[key]); });
            return all;
        };
        EditorSimpleWorkerImpl.prototype.acceptNewModel = function (data) {
            this._models[data.url] = new MirrorModel(uri_1.default.parse(data.url), data.value.lines, data.value.EOL, data.versionId);
        };
        EditorSimpleWorkerImpl.prototype.acceptModelChanged = function (strURL, events) {
            if (!this._models[strURL]) {
                return;
            }
            var model = this._models[strURL];
            model.onEvents(events);
        };
        EditorSimpleWorkerImpl.prototype.acceptRemovedModel = function (strURL) {
            if (!this._models[strURL]) {
                return;
            }
            delete this._models[strURL];
        };
        return EditorSimpleWorkerImpl;
    }(BaseEditorSimpleWorker));
    exports.EditorSimpleWorkerImpl = EditorSimpleWorkerImpl;
    /**
     * Called on the worker side
     * @internal
     */
    function create() {
        return new EditorSimpleWorkerImpl();
    }
    exports.create = create;
    var global = self;
    var isWebWorker = (typeof global.importScripts === 'function');
    if (isWebWorker) {
        global.monaco = standaloneBase_1.createMonacoBaseAPI();
    }
});

define(__m[293], __M([5,6]), function(nls, data) { return nls.create("vs/base/parts/quickopen/browser/quickOpenModel", data); });
define(__m[294], __M([5,6]), function(nls, data) { return nls.create("vs/base/parts/quickopen/browser/quickOpenWidget", data); });
define(__m[295], __M([5,6]), function(nls, data) { return nls.create("vs/base/parts/tree/browser/treeDefaults", data); });





define(__m[75], __M([0,1,295,2,50,18,8,11,12]), function (require, exports, nls, winjs_base_1, actions_1, platform, errors, dom, keyCodes_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LegacyRenderer = (function () {
        function LegacyRenderer() {
        }
        LegacyRenderer.prototype.getHeight = function (tree, element) {
            return 20;
        };
        LegacyRenderer.prototype.getTemplateId = function (tree, element) {
            return 'legacy';
        };
        LegacyRenderer.prototype.renderTemplate = function (tree, templateId, container) {
            return {
                root: container,
                element: null,
                previousCleanupFn: null
            };
        };
        LegacyRenderer.prototype.renderElement = function (tree, element, templateId, templateData) {
            if (templateData.previousCleanupFn) {
                templateData.previousCleanupFn(tree, templateData.element);
            }
            while (templateData.root.firstChild) {
                templateData.root.removeChild(templateData.root.firstChild);
            }
            templateData.element = element;
            templateData.previousCleanupFn = this.render(tree, element, templateData.root);
        };
        LegacyRenderer.prototype.disposeTemplate = function (tree, templateId, templateData) {
            if (templateData.previousCleanupFn) {
                templateData.previousCleanupFn(tree, templateData.element);
            }
            templateData.root = null;
            templateData.element = null;
            templateData.previousCleanupFn = null;
        };
        LegacyRenderer.prototype.render = function (tree, element, container, previousCleanupFn) {
            container.textContent = '' + element;
            return null;
        };
        return LegacyRenderer;
    }());
    exports.LegacyRenderer = LegacyRenderer;
    (function (ClickBehavior) {
        /**
         * Handle the click when the mouse button is pressed but not released yet.
         */
        ClickBehavior[ClickBehavior["ON_MOUSE_DOWN"] = 0] = "ON_MOUSE_DOWN";
        /**
         * Handle the click when the mouse button is released.
         */
        ClickBehavior[ClickBehavior["ON_MOUSE_UP"] = 1] = "ON_MOUSE_UP";
    })(exports.ClickBehavior || (exports.ClickBehavior = {}));
    var ClickBehavior = exports.ClickBehavior;
    var KeybindingDispatcher = (function () {
        function KeybindingDispatcher() {
            this._arr = [];
        }
        KeybindingDispatcher.prototype.set = function (keybinding, callback) {
            this._arr.push({
                keybinding: keybinding,
                callback: callback
            });
        };
        KeybindingDispatcher.prototype.dispatch = function (keybinding) {
            // Loop from the last to the first to handle overwrites
            for (var i = this._arr.length - 1; i >= 0; i--) {
                var item = this._arr[i];
                if (keybinding === item.keybinding) {
                    return item.callback;
                }
            }
            return null;
        };
        return KeybindingDispatcher;
    }());
    exports.KeybindingDispatcher = KeybindingDispatcher;
    var DefaultController = (function () {
        function DefaultController(options) {
            var _this = this;
            if (options === void 0) { options = { clickBehavior: ClickBehavior.ON_MOUSE_UP }; }
            this.options = options;
            this.downKeyBindingDispatcher = new KeybindingDispatcher();
            this.downKeyBindingDispatcher.set(keyCodes_1.CommonKeybindings.SPACE, function (t, e) { return _this.onSpace(t, e); });
            this.downKeyBindingDispatcher.set(keyCodes_1.CommonKeybindings.UP_ARROW, function (t, e) { return _this.onUp(t, e); });
            this.downKeyBindingDispatcher.set(keyCodes_1.CommonKeybindings.PAGE_UP, function (t, e) { return _this.onPageUp(t, e); });
            this.downKeyBindingDispatcher.set(keyCodes_1.CommonKeybindings.DOWN_ARROW, function (t, e) { return _this.onDown(t, e); });
            this.downKeyBindingDispatcher.set(keyCodes_1.CommonKeybindings.PAGE_DOWN, function (t, e) { return _this.onPageDown(t, e); });
            this.downKeyBindingDispatcher.set(keyCodes_1.CommonKeybindings.LEFT_ARROW, function (t, e) { return _this.onLeft(t, e); });
            this.downKeyBindingDispatcher.set(keyCodes_1.CommonKeybindings.RIGHT_ARROW, function (t, e) { return _this.onRight(t, e); });
            this.downKeyBindingDispatcher.set(keyCodes_1.CommonKeybindings.ESCAPE, function (t, e) { return _this.onEscape(t, e); });
            this.upKeyBindingDispatcher = new KeybindingDispatcher();
            this.upKeyBindingDispatcher.set(keyCodes_1.CommonKeybindings.ENTER, this.onEnter.bind(this));
            this.upKeyBindingDispatcher.set(keyCodes_1.CommonKeybindings.CTRLCMD_ENTER, this.onEnter.bind(this));
        }
        DefaultController.prototype.onMouseDown = function (tree, element, event, origin) {
            if (origin === void 0) { origin = 'mouse'; }
            if (this.options.clickBehavior === ClickBehavior.ON_MOUSE_DOWN && event.leftButton) {
                if (event.target) {
                    if (event.target.tagName && event.target.tagName.toLowerCase() === 'input') {
                        return false; // Ignore event if target is a form input field (avoids browser specific issues)
                    }
                    if (dom.findParentWithClass(event.target, 'monaco-action-bar', 'row')) {
                        return false; // Ignore event if target is over an action bar of the row
                    }
                }
                // Propagate to onLeftClick now
                return this.onLeftClick(tree, element, event, origin);
            }
            return false;
        };
        DefaultController.prototype.onClick = function (tree, element, event) {
            var isMac = platform.isMacintosh;
            // A Ctrl click on the Mac is a context menu event
            if (isMac && event.ctrlKey) {
                event.preventDefault();
                event.stopPropagation();
                return false;
            }
            if (event.middleButton) {
                return false; // Give contents of the item a chance to handle this (e.g. open link in new tab)
            }
            if (event.target && event.target.tagName && event.target.tagName.toLowerCase() === 'input') {
                return false; // Ignore event if target is a form input field (avoids browser specific issues)
            }
            if (this.options.clickBehavior === ClickBehavior.ON_MOUSE_DOWN && event.leftButton) {
                return false; // Already handled by onMouseDown
            }
            return this.onLeftClick(tree, element, event);
        };
        DefaultController.prototype.onLeftClick = function (tree, element, eventish, origin) {
            if (origin === void 0) { origin = 'mouse'; }
            var payload = { origin: origin, originalEvent: eventish };
            if (tree.getInput() === element) {
                tree.clearFocus(payload);
                tree.clearSelection(payload);
            }
            else {
                var isMouseDown = eventish && eventish.browserEvent && eventish.browserEvent.type === 'mousedown';
                if (!isMouseDown) {
                    eventish.preventDefault(); // we cannot preventDefault onMouseDown because this would break DND otherwise
                }
                eventish.stopPropagation();
                tree.DOMFocus();
                tree.setSelection([element], payload);
                tree.setFocus(element, payload);
                if (tree.isExpanded(element)) {
                    tree.collapse(element).done(null, errors.onUnexpectedError);
                }
                else {
                    tree.expand(element).done(null, errors.onUnexpectedError);
                }
            }
            return true;
        };
        DefaultController.prototype.onContextMenu = function (tree, element, event) {
            if (event.target && event.target.tagName && event.target.tagName.toLowerCase() === 'input') {
                return false; // allow context menu on input fields
            }
            // Prevent native context menu from showing up
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            return false;
        };
        DefaultController.prototype.onTap = function (tree, element, event) {
            var target = event.initialTarget;
            if (target && target.tagName && target.tagName.toLowerCase() === 'input') {
                return false; // Ignore event if target is a form input field (avoids browser specific issues)
            }
            return this.onLeftClick(tree, element, event, 'touch');
        };
        DefaultController.prototype.onKeyDown = function (tree, event) {
            return this.onKey(this.downKeyBindingDispatcher, tree, event);
        };
        DefaultController.prototype.onKeyUp = function (tree, event) {
            return this.onKey(this.upKeyBindingDispatcher, tree, event);
        };
        DefaultController.prototype.onKey = function (bindings, tree, event) {
            var handler = bindings.dispatch(event.asKeybinding());
            if (handler) {
                if (handler(tree, event)) {
                    event.preventDefault();
                    event.stopPropagation();
                    return true;
                }
            }
            return false;
        };
        DefaultController.prototype.onUp = function (tree, event) {
            var payload = { origin: 'keyboard', originalEvent: event };
            if (tree.getHighlight()) {
                tree.clearHighlight(payload);
            }
            else {
                tree.focusPrevious(1, payload);
                tree.reveal(tree.getFocus()).done(null, errors.onUnexpectedError);
            }
            return true;
        };
        DefaultController.prototype.onPageUp = function (tree, event) {
            var payload = { origin: 'keyboard', originalEvent: event };
            if (tree.getHighlight()) {
                tree.clearHighlight(payload);
            }
            else {
                tree.focusPreviousPage(payload);
                tree.reveal(tree.getFocus()).done(null, errors.onUnexpectedError);
            }
            return true;
        };
        DefaultController.prototype.onDown = function (tree, event) {
            var payload = { origin: 'keyboard', originalEvent: event };
            if (tree.getHighlight()) {
                tree.clearHighlight(payload);
            }
            else {
                tree.focusNext(1, payload);
                tree.reveal(tree.getFocus()).done(null, errors.onUnexpectedError);
            }
            return true;
        };
        DefaultController.prototype.onPageDown = function (tree, event) {
            var payload = { origin: 'keyboard', originalEvent: event };
            if (tree.getHighlight()) {
                tree.clearHighlight(payload);
            }
            else {
                tree.focusNextPage(payload);
                tree.reveal(tree.getFocus()).done(null, errors.onUnexpectedError);
            }
            return true;
        };
        DefaultController.prototype.onLeft = function (tree, event) {
            var payload = { origin: 'keyboard', originalEvent: event };
            if (tree.getHighlight()) {
                tree.clearHighlight(payload);
            }
            else {
                var focus = tree.getFocus();
                tree.collapse(focus).then(function (didCollapse) {
                    if (focus && !didCollapse) {
                        tree.focusParent(payload);
                        return tree.reveal(tree.getFocus());
                    }
                }).done(null, errors.onUnexpectedError);
            }
            return true;
        };
        DefaultController.prototype.onRight = function (tree, event) {
            var payload = { origin: 'keyboard', originalEvent: event };
            if (tree.getHighlight()) {
                tree.clearHighlight(payload);
            }
            else {
                var focus = tree.getFocus();
                tree.expand(focus).done(null, errors.onUnexpectedError);
            }
            return true;
        };
        DefaultController.prototype.onEnter = function (tree, event) {
            var payload = { origin: 'keyboard', originalEvent: event };
            if (tree.getHighlight()) {
                return false;
            }
            var focus = tree.getFocus();
            if (focus) {
                tree.setSelection([focus], payload);
            }
            return true;
        };
        DefaultController.prototype.onSpace = function (tree, event) {
            if (tree.getHighlight()) {
                return false;
            }
            var focus = tree.getFocus();
            if (focus) {
                tree.toggleExpansion(focus);
            }
            return true;
        };
        DefaultController.prototype.onEscape = function (tree, event) {
            var payload = { origin: 'keyboard', originalEvent: event };
            if (tree.getHighlight()) {
                tree.clearHighlight(payload);
                return true;
            }
            if (tree.getSelection().length) {
                tree.clearSelection(payload);
                return true;
            }
            if (tree.getFocus()) {
                tree.clearFocus(payload);
                return true;
            }
            return false;
        };
        return DefaultController;
    }());
    exports.DefaultController = DefaultController;
    var DefaultDragAndDrop = (function () {
        function DefaultDragAndDrop() {
        }
        DefaultDragAndDrop.prototype.getDragURI = function (tree, element) {
            return null;
        };
        DefaultDragAndDrop.prototype.onDragStart = function (tree, data, originalEvent) {
            return;
        };
        DefaultDragAndDrop.prototype.onDragOver = function (tree, data, targetElement, originalEvent) {
            return null;
        };
        DefaultDragAndDrop.prototype.drop = function (tree, data, targetElement, originalEvent) {
            return;
        };
        return DefaultDragAndDrop;
    }());
    exports.DefaultDragAndDrop = DefaultDragAndDrop;
    var DefaultFilter = (function () {
        function DefaultFilter() {
        }
        DefaultFilter.prototype.isVisible = function (tree, element) {
            return true;
        };
        return DefaultFilter;
    }());
    exports.DefaultFilter = DefaultFilter;
    var DefaultSorter = (function () {
        function DefaultSorter() {
        }
        DefaultSorter.prototype.compare = function (tree, element, otherElement) {
            return 0;
        };
        return DefaultSorter;
    }());
    exports.DefaultSorter = DefaultSorter;
    var DefaultAccessibilityProvider = (function () {
        function DefaultAccessibilityProvider() {
        }
        DefaultAccessibilityProvider.prototype.getAriaLabel = function (tree, element) {
            return null;
        };
        return DefaultAccessibilityProvider;
    }());
    exports.DefaultAccessibilityProvider = DefaultAccessibilityProvider;
    var CollapseAllAction = (function (_super) {
        __extends(CollapseAllAction, _super);
        function CollapseAllAction(viewer, enabled) {
            _super.call(this, 'vs.tree.collapse', nls.localize(0, null), 'monaco-tree-action collapse-all', enabled);
            this.viewer = viewer;
        }
        CollapseAllAction.prototype.run = function (context) {
            if (this.viewer.getHighlight()) {
                return winjs_base_1.TPromise.as(null); // Global action disabled if user is in edit mode from another action
            }
            this.viewer.collapseAll();
            this.viewer.clearSelection();
            this.viewer.clearFocus();
            this.viewer.DOMFocus();
            this.viewer.focusFirst();
            return winjs_base_1.TPromise.as(null);
        };
        return CollapseAllAction;
    }(actions_1.Action));
    exports.CollapseAllAction = CollapseAllAction;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[105], __M([0,1,293,2,26,65,10,38,288,58,75,122,11,259]), function (require, exports, nls, winjs_base_1, types, filters, strings, paths, comparers_1, actionbar_1, treeDefaults_1, highlightedLabel_1, DOM, scorer) {
    'use strict';
    var IDS = 0;
    var QuickOpenEntry = (function () {
        function QuickOpenEntry(highlights) {
            if (highlights === void 0) { highlights = []; }
            this.id = (IDS++).toString();
            this.labelHighlights = highlights;
            this.descriptionHighlights = [];
        }
        /**
         * A unique identifier for the entry
         */
        QuickOpenEntry.prototype.getId = function () {
            return this.id;
        };
        /**
         * The label of the entry to identify it from others in the list
         */
        QuickOpenEntry.prototype.getLabel = function () {
            return null;
        };
        /**
         * The label of the entry to use when a screen reader wants to read about the entry
         */
        QuickOpenEntry.prototype.getAriaLabel = function () {
            return this.getLabel();
        };
        /**
         * Detail information about the entry that is optional and can be shown below the label
         */
        QuickOpenEntry.prototype.getDetail = function () {
            return null;
        };
        /**
         * The icon of the entry to identify it from others in the list
         */
        QuickOpenEntry.prototype.getIcon = function () {
            return null;
        };
        /**
         * A secondary description that is optional and can be shown right to the label
         */
        QuickOpenEntry.prototype.getDescription = function () {
            return null;
        };
        /**
         * A resource for this entry. Resource URIs can be used to compare different kinds of entries and group
         * them together.
         */
        QuickOpenEntry.prototype.getResource = function () {
            return null;
        };
        /**
         * Extra CSS class name to add to the quick open entry to do custom styling of entries.
         */
        QuickOpenEntry.prototype.getExtraClass = function () {
            return null;
        };
        /**
         * Allows to reuse the same model while filtering. Hidden entries will not show up in the viewer.
         */
        QuickOpenEntry.prototype.isHidden = function () {
            return this.hidden;
        };
        /**
         * Allows to reuse the same model while filtering. Hidden entries will not show up in the viewer.
         */
        QuickOpenEntry.prototype.setHidden = function (hidden) {
            this.hidden = hidden;
        };
        /**
         * Allows to set highlight ranges that should show up for the entry label and optionally description if set.
         */
        QuickOpenEntry.prototype.setHighlights = function (labelHighlights, descriptionHighlights, detailHighlights) {
            this.labelHighlights = labelHighlights;
            this.descriptionHighlights = descriptionHighlights;
            this.detailHighlights = detailHighlights;
        };
        /**
         * Allows to return highlight ranges that should show up for the entry label and description.
         */
        QuickOpenEntry.prototype.getHighlights = function () {
            return [this.labelHighlights, this.descriptionHighlights, this.detailHighlights];
        };
        /**
         * Called when the entry is selected for opening. Returns a boolean value indicating if an action was performed or not.
         * The mode parameter gives an indication if the element is previewed (using arrow keys) or opened.
         *
         * The context parameter provides additional context information how the run was triggered.
         */
        QuickOpenEntry.prototype.run = function (mode, context) {
            return false;
        };
        /**
         * A good default sort implementation for quick open entries respecting highlight information
         * as well as associated resources.
         */
        QuickOpenEntry.compare = function (elementA, elementB, lookFor) {
            // Normalize
            if (lookFor) {
                lookFor = strings.stripWildcards(lookFor).toLowerCase();
            }
            // Give matches with label highlights higher priority over
            // those with only description highlights
            var labelHighlightsA = elementA.getHighlights()[0] || [];
            var labelHighlightsB = elementB.getHighlights()[0] || [];
            if (labelHighlightsA.length && !labelHighlightsB.length) {
                return -1;
            }
            else if (!labelHighlightsA.length && labelHighlightsB.length) {
                return 1;
            }
            // Fallback to the full path if labels are identical and we have associated resources
            var nameA = elementA.getLabel();
            var nameB = elementB.getLabel();
            if (nameA === nameB) {
                var resourceA = elementA.getResource();
                var resourceB = elementB.getResource();
                if (resourceA && resourceB) {
                    nameA = resourceA.fsPath;
                    nameB = resourceB.fsPath;
                }
            }
            return comparers_1.compareAnything(nameA, nameB, lookFor);
        };
        QuickOpenEntry.compareByScore = function (elementA, elementB, lookFor, lookForNormalizedLower, scorerCache) {
            var labelA = elementA.getLabel();
            var labelB = elementB.getLabel();
            // treat prefix matches highest in any case
            var prefixCompare = comparers_1.compareByPrefix(labelA, labelB, lookFor);
            if (prefixCompare) {
                return prefixCompare;
            }
            // Give higher importance to label score
            var labelAScore = scorer.score(labelA, lookFor, scorerCache);
            var labelBScore = scorer.score(labelB, lookFor, scorerCache);
            // Useful for understanding the scoring
            // elementA.setPrefix(labelAScore + ' ');
            // elementB.setPrefix(labelBScore + ' ');
            if (labelAScore !== labelBScore) {
                return labelAScore > labelBScore ? -1 : 1;
            }
            // Score on full resource path comes next (if available)
            var resourceA = elementA.getResource();
            var resourceB = elementB.getResource();
            if (resourceA && resourceB) {
                var resourceAScore = scorer.score(resourceA.fsPath, lookFor, scorerCache);
                var resourceBScore = scorer.score(resourceB.fsPath, lookFor, scorerCache);
                // Useful for understanding the scoring
                // elementA.setPrefix(elementA.getPrefix() + ' ' + resourceAScore + ': ');
                // elementB.setPrefix(elementB.getPrefix() + ' ' + resourceBScore + ': ');
                if (resourceAScore !== resourceBScore) {
                    return resourceAScore > resourceBScore ? -1 : 1;
                }
            }
            // At this place, the scores are identical so we check for string lengths and favor shorter ones
            if (labelA.length !== labelB.length) {
                return labelA.length < labelB.length ? -1 : 1;
            }
            if (resourceA && resourceB && resourceA.fsPath.length !== resourceB.fsPath.length) {
                return resourceA.fsPath.length < resourceB.fsPath.length ? -1 : 1;
            }
            // Finally compare by label or resource path
            if (labelA === labelB && resourceA && resourceB) {
                return comparers_1.compareAnything(resourceA.fsPath, resourceB.fsPath, lookForNormalizedLower);
            }
            return comparers_1.compareAnything(labelA, labelB, lookForNormalizedLower);
        };
        /**
         * A good default highlight implementation for an entry with label and description.
         */
        QuickOpenEntry.highlight = function (entry, lookFor, fuzzyHighlight) {
            if (fuzzyHighlight === void 0) { fuzzyHighlight = false; }
            var labelHighlights = [];
            var descriptionHighlights = [];
            var normalizedLookFor = strings.stripWildcards(lookFor);
            var label = entry.getLabel();
            var description = entry.getDescription();
            // Highlight file aware
            if (entry.getResource()) {
                // Highlight entire label and description if searching for full absolute path
                if (lookFor.toLowerCase() === entry.getResource().fsPath.toLowerCase()) {
                    labelHighlights.push({ start: 0, end: label.length });
                    descriptionHighlights.push({ start: 0, end: description.length });
                }
                else if (fuzzyHighlight || lookFor.indexOf(paths.nativeSep) >= 0) {
                    var candidateLabelHighlights = filters.matchesFuzzy(lookFor, label, fuzzyHighlight);
                    if (!candidateLabelHighlights) {
                        var pathPrefix = description ? (description + paths.nativeSep) : '';
                        var pathPrefixLength_1 = pathPrefix.length;
                        // If there are no highlights in the label, build a path out of description and highlight and match on both,
                        // then extract the individual label and description highlights back to the original positions
                        var pathHighlights = filters.matchesFuzzy(lookFor, pathPrefix + label, fuzzyHighlight);
                        if (!pathHighlights && lookFor !== normalizedLookFor) {
                            pathHighlights = filters.matchesFuzzy(normalizedLookFor, pathPrefix + label, fuzzyHighlight);
                        }
                        if (pathHighlights) {
                            pathHighlights.forEach(function (h) {
                                // Match overlaps label and description part, we need to split it up
                                if (h.start < pathPrefixLength_1 && h.end > pathPrefixLength_1) {
                                    labelHighlights.push({ start: 0, end: h.end - pathPrefixLength_1 });
                                    descriptionHighlights.push({ start: h.start, end: pathPrefixLength_1 });
                                }
                                else if (h.start >= pathPrefixLength_1) {
                                    labelHighlights.push({ start: h.start - pathPrefixLength_1, end: h.end - pathPrefixLength_1 });
                                }
                                else {
                                    descriptionHighlights.push(h);
                                }
                            });
                        }
                    }
                    else {
                        labelHighlights = candidateLabelHighlights;
                    }
                }
                else {
                    labelHighlights = filters.matchesFuzzy(lookFor, label);
                }
            }
            else {
                labelHighlights = filters.matchesFuzzy(lookFor, label);
            }
            return { labelHighlights: labelHighlights, descriptionHighlights: descriptionHighlights };
        };
        return QuickOpenEntry;
    }());
    exports.QuickOpenEntry = QuickOpenEntry;
    var QuickOpenEntryItem = (function (_super) {
        __extends(QuickOpenEntryItem, _super);
        function QuickOpenEntryItem() {
            _super.apply(this, arguments);
        }
        /**
         * Must return the height as being used by the render function.
         */
        QuickOpenEntryItem.prototype.getHeight = function () {
            return 0;
        };
        /**
         * Allows to present the quick open entry in a custom way inside the tree.
         */
        QuickOpenEntryItem.prototype.render = function (tree, container, previousCleanupFn) {
            return null;
        };
        return QuickOpenEntryItem;
    }(QuickOpenEntry));
    exports.QuickOpenEntryItem = QuickOpenEntryItem;
    var QuickOpenEntryGroup = (function (_super) {
        __extends(QuickOpenEntryGroup, _super);
        function QuickOpenEntryGroup(entry, groupLabel, withBorder) {
            _super.call(this);
            this.entry = entry;
            this.groupLabel = groupLabel;
            this.withBorder = withBorder;
        }
        /**
         * The label of the group or null if none.
         */
        QuickOpenEntryGroup.prototype.getGroupLabel = function () {
            return this.groupLabel;
        };
        QuickOpenEntryGroup.prototype.setGroupLabel = function (groupLabel) {
            this.groupLabel = groupLabel;
        };
        /**
         * Whether to show a border on top of the group entry or not.
         */
        QuickOpenEntryGroup.prototype.showBorder = function () {
            return this.withBorder;
        };
        QuickOpenEntryGroup.prototype.setShowBorder = function (showBorder) {
            this.withBorder = showBorder;
        };
        QuickOpenEntryGroup.prototype.getLabel = function () {
            return this.entry ? this.entry.getLabel() : _super.prototype.getLabel.call(this);
        };
        QuickOpenEntryGroup.prototype.getAriaLabel = function () {
            return this.entry ? this.entry.getAriaLabel() : _super.prototype.getAriaLabel.call(this);
        };
        QuickOpenEntryGroup.prototype.getDetail = function () {
            return this.entry ? this.entry.getDetail() : _super.prototype.getDetail.call(this);
        };
        QuickOpenEntryGroup.prototype.getResource = function () {
            return this.entry ? this.entry.getResource() : _super.prototype.getResource.call(this);
        };
        QuickOpenEntryGroup.prototype.getIcon = function () {
            return this.entry ? this.entry.getIcon() : _super.prototype.getIcon.call(this);
        };
        QuickOpenEntryGroup.prototype.getDescription = function () {
            return this.entry ? this.entry.getDescription() : _super.prototype.getDescription.call(this);
        };
        QuickOpenEntryGroup.prototype.getEntry = function () {
            return this.entry;
        };
        QuickOpenEntryGroup.prototype.getHighlights = function () {
            return this.entry ? this.entry.getHighlights() : _super.prototype.getHighlights.call(this);
        };
        QuickOpenEntryGroup.prototype.getExtraClass = function () {
            return this.entry ? this.entry.getExtraClass() : _super.prototype.getExtraClass.call(this);
        };
        QuickOpenEntryGroup.prototype.isHidden = function () {
            return this.entry ? this.entry.isHidden() : _super.prototype.isHidden.call(this);
        };
        QuickOpenEntryGroup.prototype.setHighlights = function (labelHighlights, descriptionHighlights, detailHighlights) {
            this.entry ? this.entry.setHighlights(labelHighlights, descriptionHighlights, detailHighlights) : _super.prototype.setHighlights.call(this, labelHighlights, descriptionHighlights, detailHighlights);
        };
        QuickOpenEntryGroup.prototype.setHidden = function (hidden) {
            this.entry ? this.entry.setHidden(hidden) : _super.prototype.setHidden.call(this, hidden);
        };
        QuickOpenEntryGroup.prototype.run = function (mode, context) {
            return this.entry ? this.entry.run(mode, context) : _super.prototype.run.call(this, mode, context);
        };
        return QuickOpenEntryGroup;
    }(QuickOpenEntry));
    exports.QuickOpenEntryGroup = QuickOpenEntryGroup;
    var templateEntry = 'quickOpenEntry';
    var templateEntryGroup = 'quickOpenEntryGroup';
    var templateEntryItem = 'quickOpenEntryItem';
    var EntryItemRenderer = (function (_super) {
        __extends(EntryItemRenderer, _super);
        function EntryItemRenderer() {
            _super.apply(this, arguments);
        }
        EntryItemRenderer.prototype.getTemplateId = function (tree, element) {
            return templateEntryItem;
        };
        EntryItemRenderer.prototype.render = function (tree, element, container, previousCleanupFn) {
            if (element instanceof QuickOpenEntryItem) {
                return element.render(tree, container, previousCleanupFn);
            }
            return _super.prototype.render.call(this, tree, element, container, previousCleanupFn);
        };
        return EntryItemRenderer;
    }(treeDefaults_1.LegacyRenderer));
    var NoActionProvider = (function () {
        function NoActionProvider() {
        }
        NoActionProvider.prototype.hasActions = function (tree, element) {
            return false;
        };
        NoActionProvider.prototype.getActions = function (tree, element) {
            return winjs_base_1.TPromise.as(null);
        };
        NoActionProvider.prototype.hasSecondaryActions = function (tree, element) {
            return false;
        };
        NoActionProvider.prototype.getSecondaryActions = function (tree, element) {
            return winjs_base_1.TPromise.as(null);
        };
        NoActionProvider.prototype.getActionItem = function (tree, element, action) {
            return null;
        };
        return NoActionProvider;
    }());
    var Renderer = (function () {
        function Renderer(actionProvider, actionRunner) {
            if (actionProvider === void 0) { actionProvider = new NoActionProvider(); }
            if (actionRunner === void 0) { actionRunner = null; }
            this.actionProvider = actionProvider;
            this.actionRunner = actionRunner;
            this.entryItemRenderer = new EntryItemRenderer();
        }
        Renderer.prototype.getHeight = function (entry) {
            if (entry instanceof QuickOpenEntryItem) {
                return entry.getHeight();
            }
            if (entry.getDetail()) {
                return 44;
            }
            return 22;
        };
        Renderer.prototype.getTemplateId = function (entry) {
            if (entry instanceof QuickOpenEntryItem) {
                return templateEntryItem;
            }
            if (entry instanceof QuickOpenEntryGroup) {
                return templateEntryGroup;
            }
            return templateEntry;
        };
        Renderer.prototype.renderTemplate = function (templateId, container) {
            // Entry Item
            if (templateId === templateEntryItem) {
                return this.entryItemRenderer.renderTemplate(null, templateId, container);
            }
            // Entry Group
            var group;
            if (templateId === templateEntryGroup) {
                group = document.createElement('div');
                DOM.addClass(group, 'results-group');
                container.appendChild(group);
            }
            // Action Bar
            DOM.addClass(container, 'actions');
            var entryContainer = document.createElement('div');
            DOM.addClass(entryContainer, 'sub-content');
            container.appendChild(entryContainer);
            var actionBarContainer = document.createElement('div');
            DOM.addClass(actionBarContainer, 'primary-action-bar');
            container.appendChild(actionBarContainer);
            var actionBar = new actionbar_1.ActionBar(actionBarContainer, {
                actionRunner: this.actionRunner
            });
            // Entry
            var entry = document.createElement('div');
            DOM.addClass(entry, 'quick-open-entry');
            entryContainer.appendChild(entry);
            // Icon
            var icon = document.createElement('span');
            entry.appendChild(icon);
            // Label
            var label = new highlightedLabel_1.HighlightedLabel(entry);
            // Description
            var descriptionContainer = document.createElement('span');
            entry.appendChild(descriptionContainer);
            DOM.addClass(descriptionContainer, 'quick-open-entry-description');
            var description = new highlightedLabel_1.HighlightedLabel(descriptionContainer);
            // Detail
            var detailContainer = document.createElement('div');
            entry.appendChild(detailContainer);
            DOM.addClass(detailContainer, 'quick-open-entry-meta');
            var detail = new highlightedLabel_1.HighlightedLabel(detailContainer);
            return {
                container: container,
                entry: entry,
                icon: icon,
                label: label,
                detail: detail,
                description: description,
                group: group,
                actionBar: actionBar
            };
        };
        Renderer.prototype.renderElement = function (entry, templateId, templateData) {
            // Entry Item
            if (templateId === templateEntryItem) {
                this.entryItemRenderer.renderElement(null, entry, templateId, templateData);
                return;
            }
            var data = templateData;
            // Action Bar
            if (this.actionProvider.hasActions(null, entry)) {
                DOM.addClass(data.container, 'has-actions');
            }
            else {
                DOM.removeClass(data.container, 'has-actions');
            }
            data.actionBar.context = entry; // make sure the context is the current element
            this.actionProvider.getActions(null, entry).then(function (actions) {
                // TODO@Ben this will not work anymore as soon as quick open has more actions
                // but as long as there is only one are ok
                if (data.actionBar.isEmpty() && actions && actions.length > 0) {
                    data.actionBar.push(actions, { icon: true, label: false });
                }
                else if (!data.actionBar.isEmpty() && (!actions || actions.length === 0)) {
                    data.actionBar.clear();
                }
            });
            // Entry group
            if (entry instanceof QuickOpenEntryGroup) {
                var group = entry;
                // Border
                if (group.showBorder()) {
                    DOM.addClass(data.container, 'results-group-separator');
                }
                else {
                    DOM.removeClass(data.container, 'results-group-separator');
                }
                // Group Label
                var groupLabel = group.getGroupLabel() || '';
                templateData.group.textContent = groupLabel;
            }
            // Normal Entry
            if (entry instanceof QuickOpenEntry) {
                var _a = entry.getHighlights(), labelHighlights = _a[0], descriptionHighlights = _a[1], detailHighlights = _a[2];
                // Extra Class
                var extraClass = entry.getExtraClass();
                if (extraClass) {
                    DOM.addClass(data.entry, extraClass);
                }
                else {
                    data.entry.className = 'quick-open-entry';
                }
                // Icon
                var iconClass = entry.getIcon() ? ('quick-open-entry-icon ' + entry.getIcon()) : '';
                data.icon.className = iconClass;
                // Label
                data.label.set(entry.getLabel(), labelHighlights || []);
                // Meta
                data.detail.set(entry.getDetail(), detailHighlights);
                // Description
                data.description.set(entry.getDescription(), descriptionHighlights || []);
                data.description.element.title = entry.getDescription();
            }
        };
        Renderer.prototype.disposeTemplate = function (templateId, templateData) {
            if (templateId === templateEntryItem) {
                this.entryItemRenderer.disposeTemplate(null, templateId, templateData);
            }
            else {
                var data = templateData;
                data.actionBar.dispose();
                data.actionBar = null;
                data.container = null;
                data.entry = null;
                data.description.dispose();
                data.description = null;
                data.detail.dispose();
                data.detail = null;
                data.group = null;
                data.icon = null;
                data.label.dispose();
                data.label = null;
            }
        };
        return Renderer;
    }());
    var QuickOpenModel = (function () {
        function QuickOpenModel(entries, actionProvider) {
            if (entries === void 0) { entries = []; }
            if (actionProvider === void 0) { actionProvider = new NoActionProvider(); }
            this._entries = entries;
            this._dataSource = this;
            this._renderer = new Renderer(actionProvider);
            this._filter = this;
            this._runner = this;
            this._accessibilityProvider = this;
        }
        Object.defineProperty(QuickOpenModel.prototype, "entries", {
            get: function () { return this._entries; },
            set: function (entries) {
                this._entries = entries;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickOpenModel.prototype, "dataSource", {
            get: function () { return this._dataSource; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickOpenModel.prototype, "renderer", {
            get: function () { return this._renderer; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickOpenModel.prototype, "filter", {
            get: function () { return this._filter; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickOpenModel.prototype, "runner", {
            get: function () { return this._runner; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(QuickOpenModel.prototype, "accessibilityProvider", {
            get: function () { return this._accessibilityProvider; },
            enumerable: true,
            configurable: true
        });
        /**
         * Adds entries that should show up in the quick open viewer.
         */
        QuickOpenModel.prototype.addEntries = function (entries) {
            if (types.isArray(entries)) {
                this._entries = this._entries.concat(entries);
            }
        };
        /**
         * Set the entries that should show up in the quick open viewer.
         */
        QuickOpenModel.prototype.setEntries = function (entries) {
            if (types.isArray(entries)) {
                this._entries = entries;
            }
        };
        /**
         * Get the entries that should show up in the quick open viewer.
         *
         * @visibleOnly optional parameter to only return visible entries
         */
        QuickOpenModel.prototype.getEntries = function (visibleOnly) {
            if (visibleOnly) {
                return this._entries.filter(function (e) { return !e.isHidden(); });
            }
            return this._entries;
        };
        QuickOpenModel.prototype.getId = function (entry) {
            return entry.getId();
        };
        QuickOpenModel.prototype.getLabel = function (entry) {
            return entry.getLabel();
        };
        QuickOpenModel.prototype.getAriaLabel = function (entry) {
            var ariaLabel = entry.getAriaLabel();
            if (ariaLabel) {
                return nls.localize(0, null, entry.getAriaLabel());
            }
            return nls.localize(1, null);
        };
        QuickOpenModel.prototype.isVisible = function (entry) {
            return !entry.isHidden();
        };
        QuickOpenModel.prototype.run = function (entry, mode, context) {
            return entry.run(mode, context);
        };
        return QuickOpenModel;
    }());
    exports.QuickOpenModel = QuickOpenModel;
});






define(__m[106], __M([0,1,75,23,206,267,109,438]), function (require, exports, TreeDefaults, Events, Model, View, iterator_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var TreeContext = (function () {
        function TreeContext(tree, configuration, options) {
            if (options === void 0) { options = {}; }
            this.tree = tree;
            this.configuration = configuration;
            this.options = options;
            if (!configuration.dataSource) {
                throw new Error('You must provide a Data Source to the tree.');
            }
            this.dataSource = configuration.dataSource;
            this.renderer = configuration.renderer || new TreeDefaults.LegacyRenderer();
            this.controller = configuration.controller || new TreeDefaults.DefaultController();
            this.dnd = configuration.dnd || new TreeDefaults.DefaultDragAndDrop();
            this.filter = configuration.filter || new TreeDefaults.DefaultFilter();
            this.sorter = configuration.sorter || null;
            this.accessibilityProvider = configuration.accessibilityProvider || new TreeDefaults.DefaultAccessibilityProvider();
        }
        return TreeContext;
    }());
    exports.TreeContext = TreeContext;
    var Tree = (function (_super) {
        __extends(Tree, _super);
        function Tree(container, configuration, options) {
            if (options === void 0) { options = {}; }
            _super.call(this);
            this.container = container;
            this.configuration = configuration;
            this.options = options;
            this.options.twistiePixels = typeof this.options.twistiePixels === 'number' ? this.options.twistiePixels : 32;
            this.options.indentPixels = typeof this.options.indentPixels === 'number' ? this.options.indentPixels : 12;
            this.options.alwaysFocused = this.options.alwaysFocused === true ? true : false;
            this.options.bare = this.options.bare === true ? true : false;
            this.options.useShadows = this.options.useShadows === false ? false : true;
            this.options.paddingOnRow = this.options.paddingOnRow === false ? false : true;
            this.context = new TreeContext(this, configuration, options);
            this.model = new Model.TreeModel(this.context);
            this.view = new View.TreeView(this.context, this.container);
            this.view.setModel(this.model);
            this.addEmitter2(this.model);
            this.addEmitter2(this.view);
        }
        Tree.prototype.getHTMLElement = function () {
            return this.view.getHTMLElement();
        };
        Tree.prototype.layout = function (height) {
            this.view.layout(height);
        };
        Tree.prototype.DOMFocus = function () {
            this.view.focus();
        };
        Tree.prototype.isDOMFocused = function () {
            return this.view.isFocused();
        };
        Tree.prototype.DOMBlur = function () {
            this.view.blur();
        };
        Tree.prototype.onVisible = function () {
            this.view.onVisible();
        };
        Tree.prototype.onHidden = function () {
            this.view.onHidden();
        };
        Tree.prototype.setInput = function (element) {
            return this.model.setInput(element);
        };
        Tree.prototype.getInput = function () {
            return this.model.getInput();
        };
        Tree.prototype.refresh = function (element, recursive) {
            if (element === void 0) { element = null; }
            if (recursive === void 0) { recursive = true; }
            return this.model.refresh(element, recursive);
        };
        Tree.prototype.refreshAll = function (elements, recursive) {
            if (recursive === void 0) { recursive = true; }
            return this.model.refreshAll(elements, recursive);
        };
        Tree.prototype.expand = function (element) {
            return this.model.expand(element);
        };
        Tree.prototype.expandAll = function (elements) {
            return this.model.expandAll(elements);
        };
        Tree.prototype.collapse = function (element, recursive) {
            if (recursive === void 0) { recursive = false; }
            return this.model.collapse(element);
        };
        Tree.prototype.collapseAll = function (elements, recursive) {
            if (elements === void 0) { elements = null; }
            if (recursive === void 0) { recursive = false; }
            return this.model.collapseAll(elements, recursive);
        };
        Tree.prototype.toggleExpansion = function (element) {
            return this.model.toggleExpansion(element);
        };
        Tree.prototype.toggleExpansionAll = function (elements) {
            return this.model.toggleExpansionAll(elements);
        };
        Tree.prototype.isExpanded = function (element) {
            return this.model.isExpanded(element);
        };
        Tree.prototype.getExpandedElements = function () {
            return this.model.getExpandedElements();
        };
        Tree.prototype.reveal = function (element, relativeTop) {
            if (relativeTop === void 0) { relativeTop = null; }
            return this.model.reveal(element, relativeTop);
        };
        Tree.prototype.getRelativeTop = function (element) {
            var item = this.model.getItem(element);
            return this.view.getRelativeTop(item);
        };
        Tree.prototype.getScrollPosition = function () {
            return this.view.getScrollPosition();
        };
        Tree.prototype.setScrollPosition = function (pos) {
            this.view.setScrollPosition(pos);
        };
        Tree.prototype.getContentHeight = function () {
            return this.view.getTotalHeight();
        };
        Tree.prototype.setHighlight = function (element, eventPayload) {
            this.model.setHighlight(element, eventPayload);
        };
        Tree.prototype.getHighlight = function () {
            return this.model.getHighlight();
        };
        Tree.prototype.isHighlighted = function (element) {
            return this.model.isFocused(element);
        };
        Tree.prototype.clearHighlight = function (eventPayload) {
            this.model.setHighlight(null, eventPayload);
        };
        Tree.prototype.select = function (element, eventPayload) {
            this.model.select(element, eventPayload);
        };
        Tree.prototype.selectRange = function (fromElement, toElement, eventPayload) {
            this.model.selectRange(fromElement, toElement, eventPayload);
        };
        Tree.prototype.deselectRange = function (fromElement, toElement, eventPayload) {
            this.model.deselectRange(fromElement, toElement, eventPayload);
        };
        Tree.prototype.selectAll = function (elements, eventPayload) {
            this.model.selectAll(elements, eventPayload);
        };
        Tree.prototype.deselect = function (element, eventPayload) {
            this.model.deselect(element, eventPayload);
        };
        Tree.prototype.deselectAll = function (elements, eventPayload) {
            this.model.deselectAll(elements, eventPayload);
        };
        Tree.prototype.setSelection = function (elements, eventPayload) {
            this.model.setSelection(elements, eventPayload);
        };
        Tree.prototype.toggleSelection = function (element, eventPayload) {
            this.model.toggleSelection(element, eventPayload);
        };
        Tree.prototype.isSelected = function (element) {
            return this.model.isSelected(element);
        };
        Tree.prototype.getSelection = function () {
            return this.model.getSelection();
        };
        Tree.prototype.clearSelection = function (eventPayload) {
            this.model.setSelection([], eventPayload);
        };
        Tree.prototype.selectNext = function (count, clearSelection, eventPayload) {
            this.model.selectNext(count, clearSelection, eventPayload);
        };
        Tree.prototype.selectPrevious = function (count, clearSelection, eventPayload) {
            this.model.selectPrevious(count, clearSelection, eventPayload);
        };
        Tree.prototype.selectParent = function (clearSelection, eventPayload) {
            this.model.selectParent(clearSelection, eventPayload);
        };
        Tree.prototype.setFocus = function (element, eventPayload) {
            this.model.setFocus(element, eventPayload);
        };
        Tree.prototype.isFocused = function (element) {
            return this.model.isFocused(element);
        };
        Tree.prototype.getFocus = function () {
            return this.model.getFocus();
        };
        Tree.prototype.focusNext = function (count, eventPayload) {
            this.model.focusNext(count, eventPayload);
        };
        Tree.prototype.focusPrevious = function (count, eventPayload) {
            this.model.focusPrevious(count, eventPayload);
        };
        Tree.prototype.focusParent = function (eventPayload) {
            this.model.focusParent(eventPayload);
        };
        Tree.prototype.focusFirst = function (eventPayload) {
            this.model.focusFirst(eventPayload);
        };
        Tree.prototype.focusNth = function (index, eventPayload) {
            this.model.focusNth(index, eventPayload);
        };
        Tree.prototype.focusLast = function (eventPayload) {
            this.model.focusLast(eventPayload);
        };
        Tree.prototype.focusNextPage = function (eventPayload) {
            this.view.focusNextPage(eventPayload);
        };
        Tree.prototype.focusPreviousPage = function (eventPayload) {
            this.view.focusPreviousPage(eventPayload);
        };
        Tree.prototype.clearFocus = function (eventPayload) {
            this.model.setFocus(null, eventPayload);
        };
        Tree.prototype.addTraits = function (trait, elements) {
            this.model.addTraits(trait, elements);
        };
        Tree.prototype.removeTraits = function (trait, elements) {
            this.model.removeTraits(trait, elements);
        };
        Tree.prototype.toggleTrait = function (trait, element) {
            this.model.hasTrait(trait, element) ? this.model.removeTraits(trait, [element])
                : this.model.addTraits(trait, [element]);
        };
        Tree.prototype.hasTrait = function (trait, element) {
            return this.model.hasTrait(trait, element);
        };
        Tree.prototype.getNavigator = function () {
            return new iterator_1.MappedNavigator(this.model.getNavigator(), function (i) { return i && i.getElement(); });
        };
        Tree.prototype.dispose = function () {
            if (this.model !== null) {
                this.model.dispose();
                this.model = null;
            }
            if (this.view !== null) {
                this.view.dispose();
                this.view = null;
            }
            _super.prototype.dispose.call(this);
        };
        return Tree;
    }(Events.EventEmitter));
    exports.Tree = Tree;
});






define(__m[299], __M([0,1,294,2,18,28,60,26,8,130,91,205,35,98,32,106,254,56,75,11,12,3,41,429]), function (require, exports, nls, winjs_base_1, platform, browser, events_1, types, errors, uuid, quickOpen_1, quickOpenViewer_1, builder_1, inputBox_1, severity_1, treeImpl_1, progressbar_1, keyboardEvent_1, treeDefaults_1, DOM, keyCodes_1, lifecycle_1, scrollableElementOptions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var QuickOpenController = (function (_super) {
        __extends(QuickOpenController, _super);
        function QuickOpenController() {
            _super.apply(this, arguments);
        }
        QuickOpenController.prototype.onContextMenu = function (tree, element, event) {
            if (platform.isMacintosh) {
                return this.onLeftClick(tree, element, event); // https://github.com/Microsoft/vscode/issues/1011
            }
            return _super.prototype.onContextMenu.call(this, tree, element, event);
        };
        return QuickOpenController;
    }(treeDefaults_1.DefaultController));
    exports.QuickOpenController = QuickOpenController;
    (function (HideReason) {
        HideReason[HideReason["ELEMENT_SELECTED"] = 0] = "ELEMENT_SELECTED";
        HideReason[HideReason["FOCUS_LOST"] = 1] = "FOCUS_LOST";
        HideReason[HideReason["CANCELED"] = 2] = "CANCELED";
    })(exports.HideReason || (exports.HideReason = {}));
    var HideReason = exports.HideReason;
    var DEFAULT_INPUT_ARIA_LABEL = nls.localize(0, null);
    var QuickOpenWidget = (function () {
        function QuickOpenWidget(container, callbacks, options, usageLogger) {
            this.toUnbind = [];
            this.container = container;
            this.callbacks = callbacks;
            this.options = options;
            this.usageLogger = usageLogger;
            this.model = null;
        }
        QuickOpenWidget.prototype.getModel = function () {
            return this.model;
        };
        QuickOpenWidget.prototype.setCallbacks = function (callbacks) {
            this.callbacks = callbacks;
        };
        QuickOpenWidget.prototype.create = function () {
            var _this = this;
            this.builder = builder_1.$().div(function (div) {
                // Eventing
                div.on(DOM.EventType.KEY_DOWN, function (e) {
                    var keyboardEvent = new keyboardEvent_1.StandardKeyboardEvent(e);
                    if (keyboardEvent.keyCode === keyCodes_1.KeyCode.Escape) {
                        DOM.EventHelper.stop(e, true);
                        _this.hide(HideReason.CANCELED);
                    }
                })
                    .on(DOM.EventType.CONTEXT_MENU, function (e) { return DOM.EventHelper.stop(e, true); }) // Do this to fix an issue on Mac where the menu goes into the way
                    .on(DOM.EventType.FOCUS, function (e) { return _this.gainingFocus(); }, null, true)
                    .on(DOM.EventType.BLUR, function (e) { return _this.loosingFocus(e); }, null, true);
                // Progress Bar
                _this.progressBar = new progressbar_1.ProgressBar(div.clone());
                _this.progressBar.getContainer().hide();
                // Input Field
                div.div({ 'class': 'quick-open-input' }, function (inputContainer) {
                    _this.inputContainer = inputContainer;
                    _this.inputBox = new inputBox_1.InputBox(inputContainer.getHTMLElement(), null, {
                        placeholder: _this.options.inputPlaceHolder || '',
                        ariaLabel: DEFAULT_INPUT_ARIA_LABEL
                    });
                    // ARIA
                    _this.inputElement = _this.inputBox.inputElement;
                    _this.inputElement.setAttribute('role', 'combobox');
                    _this.inputElement.setAttribute('aria-haspopup', 'false');
                    _this.inputElement.setAttribute('aria-autocomplete', 'list');
                    DOM.addDisposableListener(_this.inputBox.inputElement, DOM.EventType.KEY_DOWN, function (e) {
                        var keyboardEvent = new keyboardEvent_1.StandardKeyboardEvent(e);
                        // Do not handle Tab: It is used to navigate between elements without mouse
                        if (keyboardEvent.keyCode === keyCodes_1.KeyCode.Tab) {
                            return;
                        }
                        else if (keyboardEvent.keyCode === keyCodes_1.KeyCode.Tab || keyboardEvent.keyCode === keyCodes_1.KeyCode.DownArrow || keyboardEvent.keyCode === keyCodes_1.KeyCode.UpArrow || keyboardEvent.keyCode === keyCodes_1.KeyCode.PageDown || keyboardEvent.keyCode === keyCodes_1.KeyCode.PageUp) {
                            DOM.EventHelper.stop(e, true);
                            _this.navigateInTree(keyboardEvent.keyCode, keyboardEvent.shiftKey);
                        }
                        else if (keyboardEvent.keyCode === keyCodes_1.KeyCode.Enter) {
                            DOM.EventHelper.stop(e, true);
                            var focus_1 = _this.tree.getFocus();
                            if (focus_1) {
                                _this.elementSelected(focus_1, e);
                            }
                        }
                        else if (browser.isIE9 && (keyboardEvent.keyCode === keyCodes_1.KeyCode.Backspace || keyboardEvent.keyCode === keyCodes_1.KeyCode.Delete)) {
                            _this.onType();
                        }
                    });
                    DOM.addDisposableListener(_this.inputBox.inputElement, DOM.EventType.INPUT, function (e) {
                        _this.onType();
                    });
                });
                // Tree
                _this.treeContainer = div.div({
                    'class': 'quick-open-tree'
                }, function (div) {
                    _this.tree = new treeImpl_1.Tree(div.getHTMLElement(), {
                        dataSource: new quickOpenViewer_1.DataSource(_this),
                        controller: new QuickOpenController({ clickBehavior: treeDefaults_1.ClickBehavior.ON_MOUSE_UP }),
                        renderer: new quickOpenViewer_1.Renderer(_this),
                        filter: new quickOpenViewer_1.Filter(_this),
                        accessibilityProvider: new quickOpenViewer_1.AccessibilityProvider(_this)
                    }, {
                        twistiePixels: 11,
                        indentPixels: 0,
                        alwaysFocused: true,
                        verticalScrollMode: scrollableElementOptions_1.ScrollbarVisibility.Visible,
                        ariaLabel: nls.localize(1, null)
                    });
                    _this.treeElement = _this.tree.getHTMLElement();
                    // Handle Focus and Selection event
                    _this.toUnbind.push(_this.tree.addListener2(events_1.EventType.FOCUS, function (event) {
                        _this.elementFocused(event.focus, event);
                    }));
                    _this.toUnbind.push(_this.tree.addListener2(events_1.EventType.SELECTION, function (event) {
                        if (event.selection && event.selection.length > 0) {
                            _this.elementSelected(event.selection[0], event);
                        }
                    }));
                }).
                    on(DOM.EventType.KEY_DOWN, function (e) {
                    var keyboardEvent = new keyboardEvent_1.StandardKeyboardEvent(e);
                    // Only handle when in quick navigation mode
                    if (!_this.quickNavigateConfiguration) {
                        return;
                    }
                    // Support keyboard navigation in quick navigation mode
                    if (keyboardEvent.keyCode === keyCodes_1.KeyCode.DownArrow || keyboardEvent.keyCode === keyCodes_1.KeyCode.UpArrow || keyboardEvent.keyCode === keyCodes_1.KeyCode.PageDown || keyboardEvent.keyCode === keyCodes_1.KeyCode.PageUp) {
                        DOM.EventHelper.stop(e, true);
                        _this.navigateInTree(keyboardEvent.keyCode);
                    }
                }).
                    on(DOM.EventType.KEY_UP, function (e) {
                    var keyboardEvent = new keyboardEvent_1.StandardKeyboardEvent(e);
                    var keyCode = keyboardEvent.keyCode;
                    // Only handle when in quick navigation mode
                    if (!_this.quickNavigateConfiguration) {
                        return;
                    }
                    // Select element when keys are pressed that signal it
                    var quickNavKeys = _this.quickNavigateConfiguration.keybindings;
                    var wasTriggerKeyPressed = keyCode === keyCodes_1.KeyCode.Enter || quickNavKeys.some(function (k) {
                        if (k.hasShift() && keyCode === keyCodes_1.KeyCode.Shift) {
                            if (keyboardEvent.ctrlKey || keyboardEvent.altKey || keyboardEvent.metaKey) {
                                return false; // this is an optimistic check for the shift key being used to navigate back in quick open
                            }
                            return true;
                        }
                        if (k.hasAlt() && keyCode === keyCodes_1.KeyCode.Alt) {
                            return true;
                        }
                        // Mac is a bit special
                        if (platform.isMacintosh) {
                            if (k.hasCtrlCmd() && keyCode === keyCodes_1.KeyCode.Meta) {
                                return true;
                            }
                            if (k.hasWinCtrl() && keyCode === keyCodes_1.KeyCode.Ctrl) {
                                return true;
                            }
                        }
                        else {
                            if (k.hasCtrlCmd() && keyCode === keyCodes_1.KeyCode.Ctrl) {
                                return true;
                            }
                            if (k.hasWinCtrl() && keyCode === keyCodes_1.KeyCode.Meta) {
                                return true;
                            }
                        }
                        return false;
                    });
                    if (wasTriggerKeyPressed) {
                        var focus_2 = _this.tree.getFocus();
                        if (focus_2) {
                            _this.elementSelected(focus_2, e);
                        }
                    }
                }).
                    clone();
            })
                .addClass('quick-open-widget')
                .addClass((browser.isIE10orEarlier) ? ' no-shadow' : '')
                .build(this.container);
            // Support layout
            if (this.layoutDimensions) {
                this.layout(this.layoutDimensions);
            }
        };
        QuickOpenWidget.prototype.onType = function () {
            var value = this.inputBox.value;
            // Adjust help text as needed if present
            if (this.helpText) {
                if (value) {
                    this.helpText.hide();
                }
                else {
                    this.helpText.show();
                }
            }
            // Send to callbacks
            this.callbacks.onType(value);
        };
        QuickOpenWidget.prototype.quickNavigate = function (configuration, next) {
            if (this.isVisible) {
                // Transition into quick navigate mode if not yet done
                if (!this.quickNavigateConfiguration) {
                    this.quickNavigateConfiguration = configuration;
                    this.tree.DOMFocus();
                }
                // Navigate
                this.navigateInTree(next ? keyCodes_1.KeyCode.DownArrow : keyCodes_1.KeyCode.UpArrow);
            }
        };
        QuickOpenWidget.prototype.navigateInTree = function (keyCode, isShift) {
            var model = this.tree.getInput();
            var entries = model ? model.entries : [];
            var focus = this.tree.getFocus();
            var cycled = false;
            var revealToTop = false;
            // Support cycle-through navigation
            if (entries.length > 1) {
                // Up from no entry or first entry goes down to last
                if ((keyCode === keyCodes_1.KeyCode.UpArrow || (keyCode === keyCodes_1.KeyCode.Tab && isShift)) && (focus === entries[0] || !focus)) {
                    this.tree.focusLast();
                    cycled = true;
                }
                else if ((keyCode === keyCodes_1.KeyCode.DownArrow || keyCode === keyCodes_1.KeyCode.Tab && !isShift) && focus === entries[entries.length - 1]) {
                    this.tree.focusFirst();
                    cycled = true;
                }
            }
            // Normal Navigation
            if (!cycled) {
                switch (keyCode) {
                    case keyCodes_1.KeyCode.DownArrow:
                        this.tree.focusNext();
                        break;
                    case keyCodes_1.KeyCode.UpArrow:
                        this.tree.focusPrevious();
                        break;
                    case keyCodes_1.KeyCode.PageDown:
                        this.tree.focusNextPage();
                        break;
                    case keyCodes_1.KeyCode.PageUp:
                        this.tree.focusPreviousPage();
                        break;
                    case keyCodes_1.KeyCode.Tab:
                        if (isShift) {
                            this.tree.focusPrevious();
                        }
                        else {
                            this.tree.focusNext();
                        }
                        break;
                }
            }
            // Reveal
            focus = this.tree.getFocus();
            if (focus) {
                revealToTop ? this.tree.reveal(focus, 0).done(null, errors.onUnexpectedError) : this.tree.reveal(focus).done(null, errors.onUnexpectedError);
            }
        };
        QuickOpenWidget.prototype.elementFocused = function (value, event) {
            if (!value || !this.isVisible()) {
                return;
            }
            // ARIA
            this.inputElement.setAttribute('aria-activedescendant', this.treeElement.getAttribute('aria-activedescendant'));
            var context = { event: event, keymods: this.extractKeyMods(event), quickNavigateConfiguration: this.quickNavigateConfiguration };
            this.model.runner.run(value, quickOpen_1.Mode.PREVIEW, context);
        };
        QuickOpenWidget.prototype.elementSelected = function (value, event) {
            var hide = true;
            // Trigger open of element on selection
            if (this.isVisible()) {
                var context = { event: event, keymods: this.extractKeyMods(event), quickNavigateConfiguration: this.quickNavigateConfiguration };
                hide = this.model.runner.run(value, quickOpen_1.Mode.OPEN, context);
            }
            // add telemetry when an item is accepted, logging the index of the item in the list and the length of the list
            // to measure the rate of the success and the relevance of the order
            if (this.usageLogger) {
                var indexOfAcceptedElement = this.model.entries.indexOf(value);
                var entriesCount = this.model.entries.length;
                this.usageLogger.publicLog('quickOpenWidgetItemAccepted', { index: indexOfAcceptedElement, count: entriesCount, isQuickNavigate: this.quickNavigateConfiguration ? true : false });
            }
            // Hide if command was run successfully
            if (hide) {
                this.hide(HideReason.ELEMENT_SELECTED);
            }
        };
        QuickOpenWidget.prototype.extractKeyMods = function (event) {
            var isCtrlCmd = event && (event.ctrlKey || event.metaKey || (event.payload && event.payload.originalEvent && (event.payload.originalEvent.ctrlKey || event.payload.originalEvent.metaKey)));
            return isCtrlCmd ? [keyCodes_1.KeyMod.CtrlCmd] : [];
        };
        QuickOpenWidget.prototype.show = function (param, options) {
            this.visible = true;
            this.isLoosingFocus = false;
            this.quickNavigateConfiguration = options ? options.quickNavigateConfiguration : void 0;
            // Adjust UI for quick navigate mode
            if (this.quickNavigateConfiguration) {
                this.inputContainer.hide();
                if (this.options.enableAnimations) {
                    this.treeContainer.removeClass('transition');
                }
                this.builder.show();
                this.tree.DOMFocus();
            }
            else {
                this.inputContainer.show();
                if (this.options.enableAnimations) {
                    this.treeContainer.addClass('transition');
                }
                this.builder.show();
                this.inputBox.focus();
            }
            // Adjust Help text for IE
            if (this.helpText) {
                if (this.quickNavigateConfiguration || types.isString(param)) {
                    this.helpText.hide();
                }
                else {
                    this.helpText.show();
                }
            }
            // Show based on param
            if (types.isString(param)) {
                this.doShowWithPrefix(param);
            }
            else {
                this.doShowWithInput(param, options && options.autoFocus ? options.autoFocus : {});
            }
            if (this.callbacks.onShow) {
                this.callbacks.onShow();
            }
        };
        QuickOpenWidget.prototype.doShowWithPrefix = function (prefix) {
            this.inputBox.value = prefix;
            this.callbacks.onType(prefix);
        };
        QuickOpenWidget.prototype.doShowWithInput = function (input, autoFocus) {
            this.setInput(input, autoFocus);
        };
        QuickOpenWidget.prototype.setInputAndLayout = function (input, autoFocus) {
            var _this = this;
            // Use a generated token to avoid race conditions from setting input
            var currentInputToken = uuid.generateUuid();
            this.currentInputToken = currentInputToken;
            // setInput and Layout
            this.setTreeHeightForInput(input).then(function () {
                if (_this.currentInputToken === currentInputToken) {
                    _this.tree.setInput(null).then(function () {
                        _this.model = input;
                        // ARIA
                        _this.inputElement.setAttribute('aria-haspopup', String(input && input.entries && input.entries.length > 0));
                        return _this.tree.setInput(input);
                    }).done(function () {
                        // Indicate entries to tree
                        _this.tree.layout();
                        // Handle auto focus
                        if (input && input.entries.some(function (e) { return _this.isElementVisible(input, e); })) {
                            _this.autoFocus(input, autoFocus);
                        }
                    }, errors.onUnexpectedError);
                }
            });
        };
        QuickOpenWidget.prototype.isElementVisible = function (input, e) {
            if (!input.filter) {
                return true;
            }
            return input.filter.isVisible(e);
        };
        QuickOpenWidget.prototype.autoFocus = function (input, autoFocus) {
            var _this = this;
            if (autoFocus === void 0) { autoFocus = {}; }
            var entries = input.entries.filter(function (e) { return _this.isElementVisible(input, e); });
            // First check for auto focus of prefix matches
            if (autoFocus.autoFocusPrefixMatch) {
                var caseSensitiveMatch = void 0;
                var caseInsensitiveMatch = void 0;
                var prefix = autoFocus.autoFocusPrefixMatch;
                var lowerCasePrefix = prefix.toLowerCase();
                for (var i = 0; i < entries.length; i++) {
                    var entry = entries[i];
                    var label = input.dataSource.getLabel(entry);
                    if (!caseSensitiveMatch && label.indexOf(prefix) === 0) {
                        caseSensitiveMatch = entry;
                    }
                    else if (!caseInsensitiveMatch && label.toLowerCase().indexOf(lowerCasePrefix) === 0) {
                        caseInsensitiveMatch = entry;
                    }
                    if (caseSensitiveMatch && caseInsensitiveMatch) {
                        break;
                    }
                }
                var entryToFocus = caseSensitiveMatch || caseInsensitiveMatch;
                if (entryToFocus) {
                    this.tree.setFocus(entryToFocus);
                    this.tree.reveal(entryToFocus, 0).done(null, errors.onUnexpectedError);
                    return;
                }
            }
            // Second check for auto focus of first entry
            if (autoFocus.autoFocusFirstEntry) {
                this.tree.focusFirst();
                this.tree.reveal(this.tree.getFocus(), 0).done(null, errors.onUnexpectedError);
            }
            else if (typeof autoFocus.autoFocusIndex === 'number') {
                if (entries.length > autoFocus.autoFocusIndex) {
                    this.tree.focusNth(autoFocus.autoFocusIndex);
                    this.tree.reveal(this.tree.getFocus()).done(null, errors.onUnexpectedError);
                }
            }
            else if (autoFocus.autoFocusSecondEntry) {
                if (entries.length > 1) {
                    this.tree.focusNth(1);
                }
            }
            else if (autoFocus.autoFocusLastEntry) {
                if (entries.length > 1) {
                    this.tree.focusLast();
                }
            }
        };
        QuickOpenWidget.prototype.refresh = function (input, autoFocus) {
            var _this = this;
            if (!this.isVisible()) {
                return;
            }
            // Apply height & Refresh
            this.setTreeHeightForInput(input).then(function () {
                _this.tree.refresh().done(function () {
                    // Indicate entries to tree
                    _this.tree.layout();
                    // Handle auto focus
                    if (!_this.tree.getFocus() && input && input.entries.some(function (e) { return _this.isElementVisible(input, e); })) {
                        _this.autoFocus(input, autoFocus);
                    }
                }, errors.onUnexpectedError);
            });
        };
        QuickOpenWidget.prototype.setTreeHeightForInput = function (input) {
            var _this = this;
            var newHeight = this.getHeight(input) + 'px';
            var oldHeight = this.treeContainer.style('height');
            // Apply
            this.treeContainer.style({ height: newHeight });
            // Return instantly if we don't CSS transition or the height is the same as old
            if (!this.treeContainer.hasClass('transition') || oldHeight === newHeight) {
                return winjs_base_1.TPromise.as(null);
            }
            // Otherwise return promise that only fulfills when the CSS transition has ended
            return new winjs_base_1.TPromise(function (c, e) {
                var unbind = [];
                var complete = false;
                var completeHandler = function () {
                    if (!complete) {
                        complete = true;
                        unbind = lifecycle_1.dispose(unbind);
                        c(null);
                    }
                };
                _this.treeContainer.once('webkitTransitionEnd', completeHandler, unbind);
                _this.treeContainer.once('transitionend', completeHandler, unbind);
            });
        };
        QuickOpenWidget.prototype.getHeight = function (input) {
            var _this = this;
            var renderer = input.renderer;
            if (!input) {
                var itemHeight = renderer.getHeight(null);
                return this.options.minItemsToShow ? this.options.minItemsToShow * itemHeight : 0;
            }
            var height = 0;
            var preferredItemsHeight;
            if (this.layoutDimensions && this.layoutDimensions.height) {
                preferredItemsHeight = (this.layoutDimensions.height - 50 /* subtract height of input field (30px) and some spacing (drop shadow) to fit */) * 0.40 /* max 40% of screen */;
            }
            if (!preferredItemsHeight || preferredItemsHeight > QuickOpenWidget.MAX_ITEMS_HEIGHT) {
                preferredItemsHeight = QuickOpenWidget.MAX_ITEMS_HEIGHT;
            }
            var entries = input.entries.filter(function (e) { return _this.isElementVisible(input, e); });
            var maxEntries = this.options.maxItemsToShow || entries.length;
            for (var i = 0; i < maxEntries && i < entries.length; i++) {
                var entryHeight = renderer.getHeight(entries[i]);
                if (height + entryHeight <= preferredItemsHeight) {
                    height += entryHeight;
                }
                else {
                    break;
                }
            }
            return height;
        };
        QuickOpenWidget.prototype.hide = function (reason) {
            var _this = this;
            if (!this.isVisible()) {
                return;
            }
            this.visible = false;
            this.builder.hide();
            this.builder.domBlur();
            // report failure cases
            if (reason === HideReason.CANCELED) {
                if (this.model) {
                    var entriesCount = this.model.entries.filter(function (e) { return _this.isElementVisible(_this.model, e); }).length;
                    if (this.usageLogger) {
                        this.usageLogger.publicLog('quickOpenWidgetCancelled', { count: entriesCount, isQuickNavigate: this.quickNavigateConfiguration ? true : false });
                    }
                }
            }
            // Clear input field and clear tree
            this.inputBox.value = '';
            this.tree.setInput(null);
            // ARIA
            this.inputElement.setAttribute('aria-haspopup', 'false');
            // Reset Tree Height
            this.treeContainer.style({ height: (this.options.minItemsToShow ? this.options.minItemsToShow * 22 : 0) + 'px' });
            // Clear any running Progress
            this.progressBar.stop().getContainer().hide();
            // Clear Focus
            if (this.tree.isDOMFocused()) {
                this.tree.DOMBlur();
            }
            else if (this.inputBox.hasFocus()) {
                this.inputBox.blur();
            }
            // Callbacks
            if (reason === HideReason.CANCELED) {
                this.callbacks.onCancel();
            }
            else {
                this.callbacks.onOk();
            }
            if (this.callbacks.onHide) {
                this.callbacks.onHide(reason === HideReason.FOCUS_LOST);
            }
        };
        QuickOpenWidget.prototype.getQuickNavigateConfiguration = function () {
            return this.quickNavigateConfiguration;
        };
        QuickOpenWidget.prototype.setPlaceHolder = function (placeHolder) {
            if (this.inputBox) {
                this.inputBox.setPlaceHolder(placeHolder);
            }
        };
        QuickOpenWidget.prototype.setValue = function (value) {
            if (this.inputBox) {
                this.inputBox.value = value;
                this.inputBox.select();
            }
        };
        QuickOpenWidget.prototype.setPassword = function (isPassword) {
            if (this.inputBox) {
                this.inputBox.inputElement.type = isPassword ? 'password' : 'text';
            }
        };
        QuickOpenWidget.prototype.setInput = function (input, autoFocus, ariaLabel) {
            if (!this.isVisible()) {
                return;
            }
            // Adapt tree height to entries and apply input
            this.setInputAndLayout(input, autoFocus);
            // Apply ARIA
            if (this.inputBox) {
                this.inputBox.setAriaLabel(ariaLabel || DEFAULT_INPUT_ARIA_LABEL);
            }
        };
        QuickOpenWidget.prototype.getInput = function () {
            return this.tree.getInput();
        };
        QuickOpenWidget.prototype.showInputDecoration = function (decoration) {
            if (this.inputBox) {
                this.inputBox.showMessage({ type: decoration === severity_1.default.Info ? inputBox_1.MessageType.INFO : decoration === severity_1.default.Warning ? inputBox_1.MessageType.WARNING : inputBox_1.MessageType.ERROR, content: '' });
            }
        };
        QuickOpenWidget.prototype.clearInputDecoration = function () {
            if (this.inputBox) {
                this.inputBox.hideMessage();
            }
        };
        QuickOpenWidget.prototype.runFocus = function () {
            var focus = this.tree.getFocus();
            if (focus) {
                this.elementSelected(focus);
                return true;
            }
            return false;
        };
        QuickOpenWidget.prototype.getProgressBar = function () {
            return this.progressBar;
        };
        QuickOpenWidget.prototype.setExtraClass = function (clazz) {
            var previousClass = this.builder.getProperty('extra-class');
            if (previousClass) {
                this.builder.removeClass(previousClass);
            }
            if (clazz) {
                this.builder.addClass(clazz);
                this.builder.setProperty('extra-class', clazz);
            }
            else if (previousClass) {
                this.builder.removeProperty('extra-class');
            }
        };
        QuickOpenWidget.prototype.isVisible = function () {
            return this.visible;
        };
        QuickOpenWidget.prototype.layout = function (dimension) {
            this.layoutDimensions = dimension;
            // Apply to quick open width (height is dynamic by number of items to show)
            var quickOpenWidth = Math.min(this.layoutDimensions.width * 0.62 /* golden cut */, QuickOpenWidget.MAX_WIDTH);
            if (this.builder) {
                // quick open
                this.builder.style({
                    width: quickOpenWidth + 'px',
                    marginLeft: '-' + (quickOpenWidth / 2) + 'px'
                });
                // input field
                this.inputContainer.style({
                    width: (quickOpenWidth - 12) + 'px'
                });
            }
        };
        QuickOpenWidget.prototype.gainingFocus = function () {
            this.isLoosingFocus = false;
        };
        QuickOpenWidget.prototype.loosingFocus = function (e) {
            var _this = this;
            if (!this.isVisible()) {
                return;
            }
            var relatedTarget = e.relatedTarget;
            if (!this.quickNavigateConfiguration && DOM.isAncestor(relatedTarget, this.builder.getHTMLElement())) {
                return; // user clicked somewhere into quick open widget, do not close thereby
            }
            this.isLoosingFocus = true;
            winjs_base_1.TPromise.timeout(0).then(function () {
                if (!_this.isLoosingFocus) {
                    return;
                }
                var veto = _this.callbacks.onFocusLost && _this.callbacks.onFocusLost();
                if (!veto) {
                    _this.hide(HideReason.FOCUS_LOST);
                }
            });
        };
        QuickOpenWidget.prototype.dispose = function () {
            this.toUnbind = lifecycle_1.dispose(this.toUnbind);
            this.progressBar.dispose();
            this.inputBox.dispose();
            this.tree.dispose();
        };
        QuickOpenWidget.MAX_WIDTH = 600; // Max total width of quick open widget
        QuickOpenWidget.MAX_ITEMS_HEIGHT = 20 * 22; // Max height of item list below input field
        return QuickOpenWidget;
    }());
    exports.QuickOpenWidget = QuickOpenWidget;
});

define(__m[300], __M([0,1,35,299,22]), function (require, exports, builder_1, quickOpenWidget_1, editorBrowser_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var QuickOpenEditorWidget = (function () {
        function QuickOpenEditorWidget(codeEditor, onOk, onCancel, onType, configuration) {
            this.codeEditor = codeEditor;
            this.create(onOk, onCancel, onType, configuration);
        }
        QuickOpenEditorWidget.prototype.create = function (onOk, onCancel, onType, configuration) {
            this.domNode = builder_1.$().div().getHTMLElement();
            this.quickOpenWidget = new quickOpenWidget_1.QuickOpenWidget(this.domNode, {
                onOk: onOk,
                onCancel: onCancel,
                onType: onType
            }, {
                inputPlaceHolder: null,
                inputAriaLabel: configuration.inputAriaLabel
            }, null);
            this.quickOpenWidget.create();
            this.codeEditor.addOverlayWidget(this);
        };
        QuickOpenEditorWidget.prototype.setInput = function (model, focus) {
            this.quickOpenWidget.setInput(model, focus);
        };
        QuickOpenEditorWidget.prototype.getId = function () {
            return QuickOpenEditorWidget.ID;
        };
        QuickOpenEditorWidget.prototype.getDomNode = function () {
            return this.domNode;
        };
        QuickOpenEditorWidget.prototype.destroy = function () {
            this.codeEditor.removeOverlayWidget(this);
            this.quickOpenWidget.dispose();
        };
        QuickOpenEditorWidget.prototype.isVisible = function () {
            return this.visible;
        };
        QuickOpenEditorWidget.prototype.show = function (value) {
            this.visible = true;
            var editorLayout = this.codeEditor.getLayoutInfo();
            if (editorLayout) {
                this.quickOpenWidget.layout(new builder_1.Dimension(editorLayout.width, editorLayout.height));
            }
            this.quickOpenWidget.show(value);
            this.codeEditor.layoutOverlayWidget(this);
        };
        QuickOpenEditorWidget.prototype.hide = function () {
            this.visible = false;
            this.quickOpenWidget.hide();
            this.codeEditor.layoutOverlayWidget(this);
        };
        QuickOpenEditorWidget.prototype.getPosition = function () {
            if (this.visible) {
                return {
                    preference: editorBrowser_1.OverlayWidgetPositionPreference.TOP_CENTER
                };
            }
            return null;
        };
        QuickOpenEditorWidget.ID = 'editor.contrib.quickOpenEditorWidget';
        return QuickOpenEditorWidget;
    }());
    exports.QuickOpenEditorWidget = QuickOpenEditorWidget;
});

define(__m[301], __M([5,6]), function(nls, data) { return nls.create("vs/editor/browser/standalone/standaloneSchemas", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[302], __M([0,1,301]), function (require, exports, nls) {
    'use strict';
    var global = self;
    global.MonacoEditorSchemas = global.MonacoEditorSchemas || {};
    var MonacoEditorSchemas = global.MonacoEditorSchemas;
    MonacoEditorSchemas['http://json.schemastore.org/project'] = {
        'title': nls.localize(0, null),
        '$schema': 'http://json-schema.org/draft-04/schema#',
        'id': 'http://json.schemastore.org/project',
        'type': 'object',
        'definitions': {
            'compilationOptions': {
                'description': nls.localize(1, null),
                'type': 'object',
                'properties': {
                    'define': {
                        'type': 'array',
                        'items': {
                            'type': 'string',
                            'uniqueItems': true
                        }
                    },
                    'warningsAsErrors': {
                        'type': 'boolean',
                        'default': false
                    },
                    'allowUnsafe': {
                        'type': 'boolean',
                        'default': false
                    },
                    'optimize': {
                        'type': 'boolean',
                        'default': false
                    },
                    'languageVersion': {
                        'type': 'string',
                        'enum': ['csharp1', 'csharp2', 'csharp3', 'csharp4', 'csharp5', 'csharp6', 'experimental']
                    }
                }
            },
            'configType': {
                'type': 'object',
                'properties': {
                    'dependencies': { '$ref': '#/definitions/dependencies' },
                    'compilationOptions': { '$ref': '#/definitions/compilationOptions' },
                    'frameworkAssemblies': { '$ref': '#/definitions/dependencies' }
                }
            },
            'dependencies': {
                'type': 'object',
                'additionalProperties': {
                    'type': ['string', 'object'],
                    'properties': {
                        'version': {
                            'type': 'string',
                            'description': nls.localize(2, null)
                        },
                        'type': {
                            'type': 'string',
                            'default': 'default',
                            'enum': ['default', 'build'],
                            'description': nls.localize(3, null)
                        }
                    },
                    'id': 'nugget-package'
                },
                'description': nls.localize(4, null),
                'id': 'nugget-packages'
            },
            'script': {
                'type': ['string', 'array'],
                'items': {
                    'type': 'string'
                },
                'description': nls.localize(5, null)
            }
        },
        'properties': {
            'authors': {
                'description': nls.localize(6, null),
                'type': 'array',
                'items': {
                    'type': 'string',
                    'uniqueItems': true
                }
            },
            'bundleExclude': {
                'description': nls.localize(7, null),
                'type': ['string', 'array'],
                'items': {
                    'type': 'string'
                },
                'default': ''
            },
            'code': {
                'description': nls.localize(8, null),
                'type': ['string', 'array'],
                'items': {
                    'type': 'string'
                },
                'default': '**\\*.cs'
            },
            'commands': {
                'description': nls.localize(9, null),
                'type': 'object',
                'additionalProperties': {
                    'type': 'string'
                }
            },
            'compilationOptions': { '$ref': '#/definitions/compilationOptions' },
            'configurations': {
                'type': 'object',
                'description': nls.localize(10, null),
                'additionalProperties': {
                    'type': 'object',
                    'properties': {
                        'compilationOptions': { '$ref': '#/definitions/compilationOptions' }
                    }
                }
            },
            'dependencies': { '$ref': '#/definitions/dependencies' },
            'description': {
                'description': nls.localize(11, null),
                'type': 'string'
            },
            'exclude': {
                'description': nls.localize(12, null),
                'type': ['string', 'array'],
                'items': {
                    'type': 'string'
                },
                'default': ['bin/**/*.*', 'obj/**/*.*']
            },
            'frameworks': {
                'description': nls.localize(13, null),
                'type': 'object',
                'additionalProperties': { '$ref': '#/definitions/configType' }
            },
            'preprocess': {
                'description': nls.localize(14, null),
                'type': 'string',
                'default': 'Compiler\\Preprocess\\**\\*.cs'
            },
            'resources': {
                'description': nls.localize(15, null),
                'type': ['string', 'array'],
                'items': {
                    'type': 'string'
                },
                'default': 'Compiler\\Resources\\**\\*.cs'
            },
            'scripts': {
                'type': 'object',
                'description': nls.localize(16, null),
                'properties': {
                    'prepack': { '$ref': '#/definitions/script' },
                    'postpack': { '$ref': '#/definitions/script' },
                    'prebundle': { '$ref': '#/definitions/script' },
                    'postbundle': { '$ref': '#/definitions/script' },
                    'prerestore': { '$ref': '#/definitions/script' },
                    'postrestore': { '$ref': '#/definitions/script' },
                    'prepare': { '$ref': '#/definitions/script' }
                }
            },
            'shared': {
                'description': nls.localize(17, null),
                'type': ['string', 'array'],
                'items': {
                    'type': 'string'
                },
                'default': 'Compiler\\Shared\\**\\*.cs'
            },
            'version': {
                'description': nls.localize(18, null),
                'type': 'string'
            },
            'webroot': {
                'description': nls.localize(19, null),
                'type': 'string'
            }
        }
    };
    MonacoEditorSchemas['http://json.schemastore.org/bower'] = {
        'title': nls.localize(20, null),
        '$schema': 'http://json-schema.org/draft-04/schema#',
        'id': 'http://json.schemastore.org/bower',
        'type': 'object',
        'required': ['name'],
        'patternProperties': {
            '^_': {
                'description': nls.localize(21, null),
                'additionalProperties': true,
                'additionalItems': true
            }
        },
        'properties': {
            'name': {
                'description': nls.localize(22, null),
                'type': 'string',
                'maxLength': 50
            },
            'description': {
                'description': nls.localize(23, null),
                'type': 'string'
            },
            'version': {
                'description': nls.localize(24, null),
                'type': 'string'
            },
            'main': {
                'description': nls.localize(25, null),
                'type': ['string', 'array']
            },
            'license': {
                'description': nls.localize(26, null),
                'type': ['string', 'array'],
                'maxLength': 140
            },
            'ignore': {
                'description': nls.localize(27, null),
                'type': ['string', 'array']
            },
            'keywords': {
                'description': nls.localize(28, null),
                'type': 'array',
                'items': {
                    'type': 'string',
                    'maxLength': 50
                }
            },
            'authors': {
                'description': nls.localize(29, null),
                'type': 'array',
                'items': {
                    'type': ['string', 'object']
                }
            },
            'homepage': {
                'description': nls.localize(30, null),
                'type': 'string'
            },
            'repository': {
                'description': nls.localize(31, null),
                'type': 'object',
                'properties': {
                    'type': {
                        'type': 'string',
                        'enum': ['git']
                    },
                    'url': {
                        'type': 'string'
                    }
                }
            },
            'dependencies': {
                'id': 'bower-packages',
                'description': nls.localize(32, null),
                'type': 'object',
                'additionalProperties': {
                    'id': 'bower-package',
                    'type': 'string'
                }
            },
            'devDependencies': {
                'id': 'bower-packages',
                'description': nls.localize(33, null),
                'type': 'object',
                'additionalProperties': {
                    'id': 'bower-package',
                    'type': 'string'
                }
            },
            'resolutions': {
                'description': nls.localize(34, null),
                'type': 'object'
            },
            'private': {
                'description': nls.localize(35, null),
                'type': 'boolean'
            },
            'exportsOverride': {
                'description': nls.localize(36, null),
                'type': 'object',
                'additionalProperties': {
                    'type': 'object',
                    'additionalProperties': {
                        'type': 'string'
                    }
                }
            },
            'moduleType': {
                'description': nls.localize(37, null),
                'type': 'array',
                'items': {
                    'enum': ['amd', 'es6', 'globals', 'node', 'yui']
                }
            }
        }
    };
    MonacoEditorSchemas['http://json.schemastore.org/package'] = {
        'id': 'http://json.schemastore.org/package',
        'description': nls.localize(38, null),
        'type': 'object',
        'required': ['name', 'version'],
        'definitions': {
            'person': {
                'description': nls.localize(39, null),
                'type': ['object', 'string'],
                'required': ['name'],
                'properties': {
                    'name': {
                        'type': 'string'
                    },
                    'url': {
                        'type': 'string',
                        'format': 'uri'
                    },
                    'email': {
                        'type': 'string',
                        'format': 'email'
                    }
                }
            },
            'dependency': {
                'id': 'npm-packages',
                'description': nls.localize(40, null),
                'type': 'object',
                'additionalProperties': {
                    'type': 'string'
                }
            }
        },
        'patternProperties': {
            '^_': {
                'description': nls.localize(41, null),
                'additionalProperties': true,
                'additionalItems': true
            }
        },
        'properties': {
            'name': {
                'description': nls.localize(42, null),
                'type': 'string'
            },
            'version': {
                'description': nls.localize(43, null),
                'type': 'string'
            },
            'description': {
                'description': nls.localize(44, null),
                'type': 'string'
            },
            'icon': {
                'description': nls.localize(45, null),
                'type': 'string'
            },
            'keywords': {
                'description': nls.localize(46, null),
                'type': 'array'
            },
            'homepage': {
                'description': nls.localize(47, null),
                'type': 'string'
            },
            'bugs': {
                'description': nls.localize(48, null),
                'type': ['object', 'string'],
                'properties': {
                    'url': {
                        'type': 'string',
                        'description': nls.localize(49, null),
                        'format': 'uri'
                    },
                    'email': {
                        'type': 'string',
                        'description': nls.localize(50, null)
                    }
                }
            },
            'license': {
                'type': 'string',
                'description': nls.localize(51, null)
            },
            'licenses': {
                'description': nls.localize(52, null),
                'type': 'array',
                'items': {
                    'type': 'object',
                    'properties': {
                        'type': {
                            'type': 'string'
                        },
                        'url': {
                            'type': 'string',
                            'format': 'uri'
                        }
                    }
                }
            },
            'author': {
                '$ref': '#/definitions/person'
            },
            'contributors': {
                'description': nls.localize(53, null),
                'type': 'array',
                'items': {
                    '$ref': '#/definitions/person'
                }
            },
            'maintainers': {
                'description': nls.localize(54, null),
                'type': 'array',
                'items': {
                    '$ref': '#/definitions/person'
                }
            },
            'files': {
                'description': nls.localize(55, null),
                'type': 'array',
                'items': {
                    'type': 'string'
                }
            },
            'main': {
                'description': nls.localize(56, null),
                'type': 'string'
            },
            'bin': {
                'type': ['string', 'object'],
                'additionalProperties': {
                    'type': 'string'
                }
            },
            'man': {
                'type': ['array', 'string'],
                'description': nls.localize(57, null),
                'items': {
                    'type': 'string'
                }
            },
            'directories': {
                'type': 'object',
                'properties': {
                    'bin': {
                        'description': nls.localize(58, null),
                        'type': 'string'
                    },
                    'doc': {
                        'description': nls.localize(59, null),
                        'type': 'string'
                    },
                    'example': {
                        'description': nls.localize(60, null),
                        'type': 'string'
                    },
                    'lib': {
                        'description': nls.localize(61, null),
                        'type': 'string'
                    },
                    'man': {
                        'description': nls.localize(62, null),
                        'type': 'string'
                    },
                    'test': {
                        'type': 'string'
                    }
                }
            },
            'repository': {
                'description': nls.localize(63, null),
                'type': 'object',
                'properties': {
                    'type': {
                        'type': 'string'
                    },
                    'url': {
                        'type': 'string'
                    }
                }
            },
            'scripts': {
                'description': nls.localize(64, null),
                'type': 'object',
                'additionalProperties': {
                    'type': 'string'
                }
            },
            'config': {
                'description': nls.localize(65, null),
                'type': 'object',
                'additionalProperties': true
            },
            'dependencies': {
                '$ref': '#/definitions/dependency'
            },
            'devDependencies': {
                '$ref': '#/definitions/dependency'
            },
            'bundleDependencies': {
                'type': 'array',
                'description': nls.localize(66, null),
                'items': {
                    'type': 'string'
                }
            },
            'bundledDependencies': {
                'type': 'array',
                'description': nls.localize(67, null),
                'items': {
                    'type': 'string'
                }
            },
            'optionalDependencies': {
                '$ref': '#/definitions/dependency'
            },
            'peerDependencies': {
                '$ref': '#/definitions/dependency'
            },
            'engines': {
                'type': 'object',
                'additionalProperties': {
                    'type': 'string'
                }
            },
            'engineStrict': {
                'type': 'boolean'
            },
            'os': {
                'type': 'array',
                'items': {
                    'type': 'string'
                }
            },
            'cpu': {
                'type': 'array',
                'items': {
                    'type': 'string'
                }
            },
            'preferGlobal': {
                'type': 'boolean',
                'description': nls.localize(68, null)
            },
            'private': {
                'type': 'boolean',
                'description': nls.localize(69, null)
            },
            'publishConfig': {
                'type': 'object',
                'additionalProperties': true
            },
            'dist': {
                'type': 'object',
                'properties': {
                    'shasum': {
                        'type': 'string'
                    },
                    'tarball': {
                        'type': 'string'
                    }
                }
            },
            'readme': {
                'type': 'string'
            }
        }
    };
    MonacoEditorSchemas['http://json.schemastore.org/global'] = {
        'title': nls.localize(70, null),
        'type': 'object',
        'additionalProperties': true,
        'required': ['projects'],
        'properties': {
            'projects': {
                'type': 'array',
                'description': nls.localize(71, null),
                'items': {
                    'type': 'string'
                }
            },
            'sources': {
                'type': 'array',
                'description': nls.localize(72, null),
                'items': {
                    'type': 'string'
                }
            },
            'sdk': {
                'type': 'object',
                'description': nls.localize(73, null),
                'properties': {
                    'version': {
                        'type': 'string',
                        'description': nls.localize(74, null)
                    },
                    'runtime': {
                        'type': 'string',
                        'description': nls.localize(75, null),
                    },
                    'architecture': {
                        'type': 'string',
                        'description': nls.localize(76, null)
                    }
                }
            }
        }
    };
    MonacoEditorSchemas['http://json.schemastore.org/tsconfig'] = {
        'title': nls.localize(77, null),
        '$schema': 'http://json-schema.org/draft-04/schema#',
        'type': 'object',
        'default': { 'compilerOptions': { 'target': 'ES5', 'module': 'commonjs' } },
        'properties': {
            'compilerOptions': {
                'type': 'object',
                'description': nls.localize(78, null),
                'properties': {
                    'charset': {
                        'description': nls.localize(79, null),
                        'type': 'string'
                    },
                    'declaration': {
                        'description': nls.localize(80, null),
                        'type': 'boolean'
                    },
                    'diagnostics': {
                        'description': nls.localize(81, null),
                        'type': 'boolean'
                    },
                    'emitBOM': {
                        'description': nls.localize(82, null),
                        'type': 'boolean'
                    },
                    'inlineSourceMap': {
                        'description': nls.localize(83, null),
                        'type': 'boolean'
                    },
                    'inlineSources': {
                        'description': nls.localize(84, null),
                        'type': 'boolean'
                    },
                    'listFiles': {
                        'description': nls.localize(85, null),
                        'type': 'boolean'
                    },
                    'locale': {
                        'description': nls.localize(86, null),
                        'type': 'string'
                    },
                    'mapRoot': {
                        'description': nls.localize(87, null),
                        'type': 'string',
                        'format': 'uri'
                    },
                    'module': {
                        'description': nls.localize(88, null),
                        'enum': ['commonjs', 'amd', 'umd', 'system']
                    },
                    'newLine': {
                        'description': nls.localize(89, null),
                        'enum': ['CRLF', 'LF']
                    },
                    'noEmit': {
                        'description': nls.localize(90, null),
                        'type': 'boolean'
                    },
                    'noEmitOnError': {
                        'description': nls.localize(91, null),
                        'type': 'boolean'
                    },
                    'noEmitHelpers': {
                        'description': nls.localize(92, null),
                        'type': 'boolean'
                    },
                    'noImplicitAny': {
                        'description': nls.localize(93, null),
                        'type': 'boolean'
                    },
                    'noLib': {
                        'description': nls.localize(94, null),
                        'type': 'boolean'
                    },
                    'noResolve': {
                        'description': nls.localize(95, null),
                        'type': 'boolean'
                    },
                    'out': {
                        'description': nls.localize(96, null),
                        'type': 'string',
                        'format': 'uri'
                    },
                    'outDir': {
                        'description': nls.localize(97, null),
                        'type': 'string',
                        'format': 'uri'
                    },
                    'preserveConstEnums': {
                        'description': nls.localize(98, null),
                        'type': 'boolean'
                    },
                    'removeComments': {
                        'description': nls.localize(99, null),
                        'type': 'boolean'
                    },
                    'rootDir': {
                        'description': nls.localize(100, null),
                        'type': 'string'
                    },
                    'sourceMap': {
                        'description': nls.localize(101, null),
                        'type': 'boolean'
                    },
                    'sourceRoot': {
                        'description': nls.localize(102, null),
                        'type': 'string',
                        'format': 'uri'
                    },
                    'suppressImplicitAnyIndexErrors': {
                        'description': nls.localize(103, null),
                        'type': 'boolean'
                    },
                    'target': {
                        'description': nls.localize(104, null),
                        'enum': ['ES3', 'ES5', 'ES6', 'es3', 'es5', 'es6'],
                        'default': 'ES3'
                    },
                    'watch': {
                        'description': nls.localize(105, null),
                        'type': 'boolean'
                    },
                    'jsx': {
                        'description': nls.localize(106, null),
                        'enum': ['react', 'preserve'],
                        'default': 'react'
                    },
                    'emitDecoratorMetadata': {
                        'description': nls.localize(107, null),
                        'type': 'boolean'
                    },
                    'isolatedModules': {
                        'description': nls.localize(108, null),
                        'type': 'boolean'
                    },
                    'experimentalDecorators': {
                        'description': nls.localize(109, null),
                        'type': 'boolean'
                    },
                    'experimentalAsyncFunctions': {
                        'description': nls.localize(110, null),
                        'type': 'boolean'
                    }
                }
            },
            'files': {
                'type': 'array',
                'description': nls.localize(111, null),
                'items': {
                    'type': 'string',
                    'format': 'uri'
                }
            }
        }
    };
    MonacoEditorSchemas['http://opentools.azurewebsites.net/jsconfig'] = {
        'title': nls.localize(112, null),
        'type': 'object',
        'default': { 'compilerOptions': { 'target': 'ES6' } },
        'properties': {
            'compilerOptions': {
                'type': 'object',
                'description': nls.localize(113, null),
                'properties': {
                    'charset': {
                        'description': nls.localize(114, null),
                        'type': 'string'
                    },
                    'diagnostics': {
                        'description': nls.localize(115, null),
                        'type': 'boolean'
                    },
                    'locale': {
                        'description': nls.localize(116, null),
                        'type': 'string'
                    },
                    'mapRoot': {
                        'description': nls.localize(117, null),
                        'type': 'string',
                        'format': 'uri'
                    },
                    'module': {
                        'description': nls.localize(118, null),
                        'enum': ['commonjs', 'amd', 'system', 'umd']
                    },
                    'noLib': {
                        'description': nls.localize(119, null),
                        'type': 'boolean'
                    },
                    'target': {
                        'description': nls.localize(120, null),
                        'enum': ['ES3', 'ES5', 'ES6', 'es3', 'es5', 'es6'],
                        'default': 'ES3'
                    },
                    'experimentalDecorators': {
                        'description': nls.localize(121, null),
                        'type': 'boolean'
                    }
                }
            },
            'files': {
                'type': 'array',
                'description': nls.localize(122, null),
                'items': {
                    'type': 'string',
                    'format': 'uri'
                }
            },
            'exclude': {
                'type': 'array',
                'description': nls.localize(123, null),
                'items': {
                    'type': 'string',
                    'format': 'uri'
                }
            }
        }
    };
});

define(__m[303], __M([5,6]), function(nls, data) { return nls.create("vs/editor/common/config/commonEditorConfig", data); });
define(__m[304], __M([5,6]), function(nls, data) { return nls.create("vs/editor/common/config/defaultConfig", data); });
define(__m[55], __M([0,1,304,18,76]), function (require, exports, nls, platform, wordHelper_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.DEFAULT_INDENTATION = {
        tabSize: 4,
        insertSpaces: true,
        detectIndentation: true
    };
    exports.DEFAULT_TRIM_AUTO_WHITESPACE = true;
    var DEFAULT_WINDOWS_FONT_FAMILY = 'Consolas, \'Courier New\', monospace';
    var DEFAULT_MAC_FONT_FAMILY = 'Menlo, Monaco, \'Courier New\', monospace';
    var DEFAULT_LINUX_FONT_FAMILY = '\'Droid Sans Mono\', \'Courier New\', monospace, \'Droid Sans Fallback\'';
    /**
     * Determined from empirical observations.
     */
    exports.GOLDEN_LINE_HEIGHT_RATIO = platform.isMacintosh ? 1.5 : 1.35;
    var ConfigClass = (function () {
        function ConfigClass() {
            this.editor = {
                experimentalScreenReader: true,
                rulers: [],
                wordSeparators: wordHelper_1.USUAL_WORD_SEPARATORS,
                selectionClipboard: true,
                ariaLabel: nls.localize(0, null),
                lineNumbers: true,
                selectOnLineNumbers: true,
                lineNumbersMinChars: 5,
                glyphMargin: false,
                lineDecorationsWidth: 10,
                revealHorizontalRightPadding: 30,
                roundedSelection: true,
                theme: 'vs',
                readOnly: false,
                scrollbar: {
                    verticalScrollbarSize: 14,
                    horizontal: 'auto',
                    useShadows: true,
                    verticalHasArrows: false,
                    horizontalHasArrows: false
                },
                overviewRulerLanes: 2,
                cursorBlinking: 'blink',
                cursorStyle: 'line',
                fontLigatures: false,
                disableTranslate3d: false,
                hideCursorInOverviewRuler: false,
                scrollBeyondLastLine: true,
                automaticLayout: false,
                wrappingColumn: 300,
                wrappingIndent: 'same',
                wordWrapBreakBeforeCharacters: '([{+',
                wordWrapBreakAfterCharacters: ' \t})]?|&,;',
                wordWrapBreakObtrusiveCharacters: '.',
                tabFocusMode: false,
                // Features
                hover: true,
                contextmenu: true,
                mouseWheelScrollSensitivity: 1,
                quickSuggestions: true,
                quickSuggestionsDelay: 10,
                parameterHints: true,
                iconsInSuggestions: true,
                autoClosingBrackets: true,
                formatOnType: false,
                suggestOnTriggerCharacters: true,
                acceptSuggestionOnEnter: true,
                selectionHighlight: true,
                outlineMarkers: false,
                referenceInfos: true,
                folding: true,
                renderWhitespace: false,
                indentGuides: false,
                useTabStops: true,
                fontFamily: (platform.isMacintosh ? DEFAULT_MAC_FONT_FAMILY : (platform.isLinux ? DEFAULT_LINUX_FONT_FAMILY : DEFAULT_WINDOWS_FONT_FAMILY)),
                fontSize: (platform.isMacintosh ? 12 : 14),
                lineHeight: 0
            };
        }
        return ConfigClass;
    }());
    exports.DefaultConfig = new ConfigClass();
});






define(__m[177], __M([0,1,23,10,21,4,7,165,298,55,80]), function (require, exports, eventEmitter_1, strings, position_1, range_1, editorCommon, modelLine_1, indentationGuesser_1, defaultConfig_1, prefixSumComputer_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LIMIT_FIND_COUNT = 999;
    exports.LONG_LINE_BOUNDARY = 1000;
    var TextModel = (function (_super) {
        __extends(TextModel, _super);
        function TextModel(allowedEventTypes, rawText) {
            allowedEventTypes.push(editorCommon.EventType.ModelRawContentChanged, editorCommon.EventType.ModelOptionsChanged);
            _super.call(this, allowedEventTypes);
            this._shouldSimplifyMode = (rawText.length > TextModel.MODEL_SYNC_LIMIT);
            this._shouldDenyMode = (rawText.length > TextModel.MODEL_TOKENIZATION_LIMIT);
            this._options = rawText.options;
            this._constructLines(rawText);
            this._setVersionId(1);
            this._isDisposed = false;
            this._isDisposing = false;
        }
        TextModel.prototype.isTooLargeForHavingAMode = function () {
            return this._shouldDenyMode;
        };
        TextModel.prototype.isTooLargeForHavingARichMode = function () {
            return this._shouldSimplifyMode;
        };
        TextModel.prototype.getOptions = function () {
            return this._options;
        };
        TextModel.prototype.updateOptions = function (newOpts) {
            var somethingChanged = false;
            var changed = {
                tabSize: false,
                insertSpaces: false,
                trimAutoWhitespace: false
            };
            if (typeof newOpts.insertSpaces !== 'undefined') {
                if (this._options.insertSpaces !== newOpts.insertSpaces) {
                    somethingChanged = true;
                    changed.insertSpaces = true;
                    this._options.insertSpaces = newOpts.insertSpaces;
                }
            }
            if (typeof newOpts.tabSize !== 'undefined') {
                if (this._options.tabSize !== newOpts.tabSize) {
                    somethingChanged = true;
                    changed.tabSize = true;
                    this._options.tabSize = newOpts.tabSize;
                }
            }
            if (typeof newOpts.trimAutoWhitespace !== 'undefined') {
                if (this._options.trimAutoWhitespace !== newOpts.trimAutoWhitespace) {
                    somethingChanged = true;
                    changed.trimAutoWhitespace = true;
                    this._options.trimAutoWhitespace = newOpts.trimAutoWhitespace;
                }
            }
            if (somethingChanged) {
                this.emit(editorCommon.EventType.ModelOptionsChanged, changed);
            }
        };
        TextModel.prototype.detectIndentation = function (defaultInsertSpaces, defaultTabSize) {
            var lines = this._lines.map(function (line) { return line.text; });
            var guessedIndentation = indentationGuesser_1.guessIndentation(lines, defaultTabSize, defaultInsertSpaces);
            this.updateOptions({
                insertSpaces: guessedIndentation.insertSpaces,
                tabSize: guessedIndentation.tabSize
            });
        };
        TextModel.prototype._normalizeIndentationFromWhitespace = function (str) {
            var tabSize = this._options.tabSize;
            var insertSpaces = this._options.insertSpaces;
            var spacesCnt = 0;
            for (var i = 0; i < str.length; i++) {
                if (str.charAt(i) === '\t') {
                    spacesCnt += tabSize;
                }
                else {
                    spacesCnt++;
                }
            }
            var result = '';
            if (!insertSpaces) {
                var tabsCnt = Math.floor(spacesCnt / tabSize);
                spacesCnt = spacesCnt % tabSize;
                for (var i = 0; i < tabsCnt; i++) {
                    result += '\t';
                }
            }
            for (var i = 0; i < spacesCnt; i++) {
                result += ' ';
            }
            return result;
        };
        TextModel.prototype.normalizeIndentation = function (str) {
            var firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);
            if (firstNonWhitespaceIndex === -1) {
                firstNonWhitespaceIndex = str.length;
            }
            return this._normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex)) + str.substring(firstNonWhitespaceIndex);
        };
        TextModel.prototype.getOneIndent = function () {
            var tabSize = this._options.tabSize;
            var insertSpaces = this._options.insertSpaces;
            if (insertSpaces) {
                var result = '';
                for (var i = 0; i < tabSize; i++) {
                    result += ' ';
                }
                return result;
            }
            else {
                return '\t';
            }
        };
        TextModel.prototype.getVersionId = function () {
            return this._versionId;
        };
        TextModel.prototype.getAlternativeVersionId = function () {
            return this._alternativeVersionId;
        };
        TextModel.prototype._ensureLineStarts = function () {
            if (!this._lineStarts) {
                var lineStartValues = [];
                var eolLength = this._EOL.length;
                for (var i = 0, len = this._lines.length; i < len; i++) {
                    lineStartValues.push(this._lines[i].text.length + eolLength);
                }
                this._lineStarts = new prefixSumComputer_1.PrefixSumComputer(lineStartValues);
            }
        };
        TextModel.prototype.getOffsetAt = function (rawPosition) {
            var position = this.validatePosition(rawPosition);
            this._ensureLineStarts();
            return this._lineStarts.getAccumulatedValue(position.lineNumber - 2) + position.column - 1;
        };
        TextModel.prototype.getPositionAt = function (offset) {
            offset = Math.floor(offset);
            offset = Math.max(0, offset);
            this._ensureLineStarts();
            var out = this._lineStarts.getIndexOf(offset);
            var lineLength = this._lines[out.index].text.length;
            // Ensure we return a valid position
            return new position_1.Position(out.index + 1, Math.min(out.remainder + 1, lineLength + 1));
        };
        TextModel.prototype._increaseVersionId = function () {
            this._setVersionId(this._versionId + 1);
        };
        TextModel.prototype._setVersionId = function (newVersionId) {
            this._versionId = newVersionId;
            this._alternativeVersionId = this._versionId;
        };
        TextModel.prototype._overwriteAlternativeVersionId = function (newAlternativeVersionId) {
            this._alternativeVersionId = newAlternativeVersionId;
        };
        TextModel.prototype.isDisposed = function () {
            return this._isDisposed;
        };
        TextModel.prototype.dispose = function () {
            this._isDisposed = true;
            // Null out members, such that any use of a disposed model will throw exceptions sooner rather than later
            this._lines = null;
            this._EOL = null;
            this._BOM = null;
            _super.prototype.dispose.call(this);
        };
        TextModel.prototype._createContentChangedFlushEvent = function () {
            return {
                changeType: editorCommon.EventType.ModelRawContentChangedFlush,
                detail: null,
                // TODO@Alex -> remove these fields from here
                versionId: -1,
                isUndoing: false,
                isRedoing: false
            };
        };
        TextModel.prototype._emitContentChanged2 = function (startLineNumber, startColumn, endLineNumber, endColumn, rangeLength, text, isUndoing, isRedoing) {
            var e = {
                range: new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn),
                rangeLength: rangeLength,
                text: text,
                eol: this._EOL,
                versionId: this.getVersionId(),
                isUndoing: isUndoing,
                isRedoing: isRedoing
            };
            if (!this._isDisposing) {
                this.emit(editorCommon.EventType.ModelContentChanged2, e);
            }
        };
        TextModel.prototype._resetValue = function (e, newValue) {
            this._constructLines(newValue);
            this._increaseVersionId();
            e.detail = this.toRawText();
            e.versionId = this._versionId;
        };
        TextModel.prototype.toRawText = function () {
            return {
                BOM: this._BOM,
                EOL: this._EOL,
                lines: this.getLinesContent(),
                length: this.getValueLength(),
                options: this._options
            };
        };
        TextModel.prototype.equals = function (other) {
            if (this._BOM !== other.BOM) {
                return false;
            }
            if (this._EOL !== other.EOL) {
                return false;
            }
            if (this._lines.length !== other.lines.length) {
                return false;
            }
            for (var i = 0, len = this._lines.length; i < len; i++) {
                if (this._lines[i].text !== other.lines[i]) {
                    return false;
                }
            }
            return true;
        };
        TextModel.prototype.setValue = function (value) {
            if (value === null) {
                // There's nothing to do
                return;
            }
            var rawText = null;
            rawText = TextModel.toRawText(value, {
                tabSize: this._options.tabSize,
                insertSpaces: this._options.insertSpaces,
                trimAutoWhitespace: this._options.trimAutoWhitespace,
                detectIndentation: false,
                defaultEOL: this._options.defaultEOL
            });
            this.setValueFromRawText(rawText);
        };
        TextModel.prototype.setValueFromRawText = function (newValue) {
            if (newValue === null) {
                // There's nothing to do
                return;
            }
            var oldFullModelRange = this.getFullModelRange();
            var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
            var endLineNumber = this.getLineCount();
            var endColumn = this.getLineMaxColumn(endLineNumber);
            var e = this._createContentChangedFlushEvent();
            this._resetValue(e, newValue);
            this._emitModelContentChangedFlushEvent(e);
            this._emitContentChanged2(1, 1, endLineNumber, endColumn, oldModelValueLength, this.getValue(), false, false);
        };
        TextModel.prototype.getValue = function (eol, preserveBOM) {
            if (preserveBOM === void 0) { preserveBOM = false; }
            var fullModelRange = this.getFullModelRange();
            var fullModelValue = this.getValueInRange(fullModelRange, eol);
            if (preserveBOM) {
                return this._BOM + fullModelValue;
            }
            return fullModelValue;
        };
        TextModel.prototype.getValueLength = function (eol, preserveBOM) {
            if (preserveBOM === void 0) { preserveBOM = false; }
            var fullModelRange = this.getFullModelRange();
            var fullModelValue = this.getValueLengthInRange(fullModelRange, eol);
            if (preserveBOM) {
                return this._BOM.length + fullModelValue;
            }
            return fullModelValue;
        };
        TextModel.prototype.getEmptiedValueInRange = function (rawRange, fillCharacter, eol) {
            if (fillCharacter === void 0) { fillCharacter = ''; }
            if (eol === void 0) { eol = editorCommon.EndOfLinePreference.TextDefined; }
            var range = this.validateRange(rawRange);
            if (range.isEmpty()) {
                return '';
            }
            if (range.startLineNumber === range.endLineNumber) {
                return this._repeatCharacter(fillCharacter, range.endColumn - range.startColumn);
            }
            var lineEnding = this._getEndOfLine(eol), startLineIndex = range.startLineNumber - 1, endLineIndex = range.endLineNumber - 1, resultLines = [];
            resultLines.push(this._repeatCharacter(fillCharacter, this._lines[startLineIndex].text.length - range.startColumn + 1));
            for (var i = startLineIndex + 1; i < endLineIndex; i++) {
                resultLines.push(this._repeatCharacter(fillCharacter, this._lines[i].text.length));
            }
            resultLines.push(this._repeatCharacter(fillCharacter, range.endColumn - 1));
            return resultLines.join(lineEnding);
        };
        TextModel.prototype._repeatCharacter = function (fillCharacter, count) {
            var r = '';
            for (var i = 0; i < count; i++) {
                r += fillCharacter;
            }
            return r;
        };
        TextModel.prototype.getValueInRange = function (rawRange, eol) {
            if (eol === void 0) { eol = editorCommon.EndOfLinePreference.TextDefined; }
            var range = this.validateRange(rawRange);
            if (range.isEmpty()) {
                return '';
            }
            if (range.startLineNumber === range.endLineNumber) {
                return this._lines[range.startLineNumber - 1].text.substring(range.startColumn - 1, range.endColumn - 1);
            }
            var lineEnding = this._getEndOfLine(eol), startLineIndex = range.startLineNumber - 1, endLineIndex = range.endLineNumber - 1, resultLines = [];
            resultLines.push(this._lines[startLineIndex].text.substring(range.startColumn - 1));
            for (var i = startLineIndex + 1; i < endLineIndex; i++) {
                resultLines.push(this._lines[i].text);
            }
            resultLines.push(this._lines[endLineIndex].text.substring(0, range.endColumn - 1));
            return resultLines.join(lineEnding);
        };
        TextModel.prototype.getValueLengthInRange = function (rawRange, eol) {
            if (eol === void 0) { eol = editorCommon.EndOfLinePreference.TextDefined; }
            var range = this.validateRange(rawRange);
            if (range.isEmpty()) {
                return 0;
            }
            if (range.startLineNumber === range.endLineNumber) {
                return (range.endColumn - range.startColumn);
            }
            var startOffset = this.getOffsetAt(new position_1.Position(range.startLineNumber, range.startColumn));
            var endOffset = this.getOffsetAt(new position_1.Position(range.endLineNumber, range.endColumn));
            return endOffset - startOffset;
        };
        TextModel.prototype.isDominatedByLongLines = function () {
            var smallLineCharCount = 0, longLineCharCount = 0, i, len, lines = this._lines, lineLength;
            for (i = 0, len = this._lines.length; i < len; i++) {
                lineLength = lines[i].text.length;
                if (lineLength >= exports.LONG_LINE_BOUNDARY) {
                    longLineCharCount += lineLength;
                }
                else {
                    smallLineCharCount += lineLength;
                }
            }
            return (longLineCharCount > smallLineCharCount);
        };
        TextModel.prototype.getLineCount = function () {
            return this._lines.length;
        };
        TextModel.prototype.getLineContent = function (lineNumber) {
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            return this._lines[lineNumber - 1].text;
        };
        TextModel.prototype.getLinesContent = function () {
            var r = [];
            for (var i = 0, len = this._lines.length; i < len; i++) {
                r[i] = this._lines[i].text;
            }
            return r;
        };
        TextModel.prototype.getEOL = function () {
            return this._EOL;
        };
        TextModel.prototype.setEOL = function (eol) {
            var newEOL = (eol === editorCommon.EndOfLineSequence.CRLF ? '\r\n' : '\n');
            if (this._EOL === newEOL) {
                // Nothing to do
                return;
            }
            var oldFullModelRange = this.getFullModelRange();
            var oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);
            var endLineNumber = this.getLineCount();
            var endColumn = this.getLineMaxColumn(endLineNumber);
            this._EOL = newEOL;
            this._lineStarts = null;
            this._increaseVersionId();
            var e = this._createContentChangedFlushEvent();
            e.detail = this.toRawText();
            e.versionId = this._versionId;
            this._emitModelContentChangedFlushEvent(e);
            this._emitContentChanged2(1, 1, endLineNumber, endColumn, oldModelValueLength, this.getValue(), false, false);
        };
        TextModel.prototype.getLineMinColumn = function (lineNumber) {
            return 1;
        };
        TextModel.prototype.getLineMaxColumn = function (lineNumber) {
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            return this._lines[lineNumber - 1].text.length + 1;
        };
        TextModel.prototype.getLineFirstNonWhitespaceColumn = function (lineNumber) {
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            var result = strings.firstNonWhitespaceIndex(this._lines[lineNumber - 1].text);
            if (result === -1) {
                return 0;
            }
            return result + 1;
        };
        TextModel.prototype.getLineLastNonWhitespaceColumn = function (lineNumber) {
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            var result = strings.lastNonWhitespaceIndex(this._lines[lineNumber - 1].text);
            if (result === -1) {
                return 0;
            }
            return result + 2;
        };
        TextModel.prototype.validateLineNumber = function (lineNumber) {
            if (lineNumber < 1) {
                lineNumber = 1;
            }
            if (lineNumber > this._lines.length) {
                lineNumber = this._lines.length;
            }
            return lineNumber;
        };
        TextModel.prototype.validatePosition = function (position) {
            var lineNumber = position.lineNumber ? position.lineNumber : 1;
            var column = position.column ? position.column : 1;
            if (lineNumber < 1) {
                lineNumber = 1;
                column = 1;
            }
            else if (lineNumber > this._lines.length) {
                lineNumber = this._lines.length;
                column = this.getLineMaxColumn(lineNumber);
            }
            else {
                var maxColumn = this.getLineMaxColumn(lineNumber);
                if (column < 1) {
                    column = 1;
                }
                else if (column > maxColumn) {
                    column = maxColumn;
                }
            }
            return new position_1.Position(lineNumber, column);
        };
        TextModel.prototype.validateRange = function (range) {
            var start = this.validatePosition(new position_1.Position(range.startLineNumber, range.startColumn));
            var end = this.validatePosition(new position_1.Position(range.endLineNumber, range.endColumn));
            return new range_1.Range(start.lineNumber, start.column, end.lineNumber, end.column);
        };
        TextModel.prototype.modifyPosition = function (rawPosition, offset) {
            return this.getPositionAt(this.getOffsetAt(rawPosition) + offset);
        };
        TextModel.prototype.getFullModelRange = function () {
            var lineCount = this.getLineCount();
            return new range_1.Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));
        };
        TextModel.prototype._emitModelContentChangedFlushEvent = function (e) {
            if (!this._isDisposing) {
                this.emit(editorCommon.EventType.ModelRawContentChanged, e);
            }
        };
        TextModel.toRawText = function (rawText, opts) {
            // Count the number of lines that end with \r\n
            var carriageReturnCnt = 0, lastCarriageReturnIndex = -1;
            while ((lastCarriageReturnIndex = rawText.indexOf('\r', lastCarriageReturnIndex + 1)) !== -1) {
                carriageReturnCnt++;
            }
            // Split the text into lines
            var lines = rawText.split(/\r\n|\r|\n/);
            // Remove the BOM (if present)
            var BOM = '';
            if (strings.startsWithUTF8BOM(lines[0])) {
                BOM = strings.UTF8_BOM_CHARACTER;
                lines[0] = lines[0].substr(1);
            }
            var lineFeedCnt = lines.length - 1;
            var EOL = '';
            if (lineFeedCnt === 0) {
                // This is an empty file or a file with precisely one line
                EOL = (opts.defaultEOL === editorCommon.DefaultEndOfLine.LF ? '\n' : '\r\n');
            }
            else if (carriageReturnCnt > lineFeedCnt / 2) {
                // More than half of the file contains \r\n ending lines
                EOL = '\r\n';
            }
            else {
                // At least one line more ends in \n
                EOL = '\n';
            }
            var resolvedOpts;
            if (opts.detectIndentation) {
                var guessedIndentation = indentationGuesser_1.guessIndentation(lines, opts.tabSize, opts.insertSpaces);
                resolvedOpts = {
                    tabSize: guessedIndentation.tabSize,
                    insertSpaces: guessedIndentation.insertSpaces,
                    trimAutoWhitespace: opts.trimAutoWhitespace,
                    defaultEOL: opts.defaultEOL
                };
            }
            else {
                resolvedOpts = {
                    tabSize: opts.tabSize,
                    insertSpaces: opts.insertSpaces,
                    trimAutoWhitespace: opts.trimAutoWhitespace,
                    defaultEOL: opts.defaultEOL
                };
            }
            return {
                BOM: BOM,
                EOL: EOL,
                lines: lines,
                length: rawText.length,
                options: resolvedOpts
            };
        };
        TextModel.prototype._constructLines = function (rawText) {
            var rawLines = rawText.lines, modelLines = [], i, len;
            for (i = 0, len = rawLines.length; i < len; i++) {
                modelLines.push(new modelLine_1.ModelLine(i + 1, rawLines[i]));
            }
            this._BOM = rawText.BOM;
            this._EOL = rawText.EOL;
            this._lines = modelLines;
            this._lineStarts = null;
        };
        TextModel.prototype._getEndOfLine = function (eol) {
            switch (eol) {
                case editorCommon.EndOfLinePreference.LF:
                    return '\n';
                case editorCommon.EndOfLinePreference.CRLF:
                    return '\r\n';
                case editorCommon.EndOfLinePreference.TextDefined:
                    return this.getEOL();
            }
            throw new Error('Unknown EOL preference');
        };
        TextModel.prototype.findMatches = function (searchString, rawSearchScope, isRegex, matchCase, wholeWord, limitResultCount) {
            if (limitResultCount === void 0) { limitResultCount = LIMIT_FIND_COUNT; }
            var regex = strings.createSafeRegExp(searchString, isRegex, matchCase, wholeWord);
            if (!regex) {
                return [];
            }
            var searchRange;
            if (range_1.Range.isIRange(rawSearchScope)) {
                searchRange = rawSearchScope;
            }
            else {
                searchRange = this.getFullModelRange();
            }
            return this._doFindMatches(searchRange, regex, limitResultCount);
        };
        TextModel.prototype.findNextMatch = function (searchString, rawSearchStart, isRegex, matchCase, wholeWord) {
            var regex = strings.createSafeRegExp(searchString, isRegex, matchCase, wholeWord);
            if (!regex) {
                return null;
            }
            var searchStart = this.validatePosition(rawSearchStart), lineCount = this.getLineCount(), startLineNumber = searchStart.lineNumber, text, r;
            // Look in first line
            text = this._lines[startLineNumber - 1].text.substring(searchStart.column - 1);
            r = this._findMatchInLine(regex, text, startLineNumber, searchStart.column - 1);
            if (r) {
                return r;
            }
            for (var i = 1; i <= lineCount; i++) {
                var lineIndex = (startLineNumber + i - 1) % lineCount;
                text = this._lines[lineIndex].text;
                r = this._findMatchInLine(regex, text, lineIndex + 1, 0);
                if (r) {
                    return r;
                }
            }
            return null;
        };
        TextModel.prototype.findPreviousMatch = function (searchString, rawSearchStart, isRegex, matchCase, wholeWord) {
            var regex = strings.createSafeRegExp(searchString, isRegex, matchCase, wholeWord);
            if (!regex) {
                return null;
            }
            var searchStart = this.validatePosition(rawSearchStart), lineCount = this.getLineCount(), startLineNumber = searchStart.lineNumber, text, r;
            // Look in first line
            text = this._lines[startLineNumber - 1].text.substring(0, searchStart.column - 1);
            r = this._findLastMatchInLine(regex, text, startLineNumber);
            if (r) {
                return r;
            }
            for (var i = 1; i <= lineCount; i++) {
                var lineIndex = (lineCount + startLineNumber - i - 1) % lineCount;
                text = this._lines[lineIndex].text;
                r = this._findLastMatchInLine(regex, text, lineIndex + 1);
                if (r) {
                    return r;
                }
            }
            return null;
        };
        TextModel.prototype._doFindMatches = function (searchRange, searchRegex, limitResultCount) {
            var result = [], text, counter = 0;
            // Early case for a search range that starts & stops on the same line number
            if (searchRange.startLineNumber === searchRange.endLineNumber) {
                text = this._lines[searchRange.startLineNumber - 1].text.substring(searchRange.startColumn - 1, searchRange.endColumn - 1);
                counter = this._findMatchesInLine(searchRegex, text, searchRange.startLineNumber, searchRange.startColumn - 1, counter, result, limitResultCount);
                return result;
            }
            // Collect results from first line
            text = this._lines[searchRange.startLineNumber - 1].text.substring(searchRange.startColumn - 1);
            counter = this._findMatchesInLine(searchRegex, text, searchRange.startLineNumber, searchRange.startColumn - 1, counter, result, limitResultCount);
            // Collect results from middle lines
            for (var lineNumber = searchRange.startLineNumber + 1; lineNumber < searchRange.endLineNumber && counter < limitResultCount; lineNumber++) {
                counter = this._findMatchesInLine(searchRegex, this._lines[lineNumber - 1].text, lineNumber, 0, counter, result, limitResultCount);
            }
            // Collect results from last line
            if (counter < limitResultCount) {
                text = this._lines[searchRange.endLineNumber - 1].text.substring(0, searchRange.endColumn - 1);
                counter = this._findMatchesInLine(searchRegex, text, searchRange.endLineNumber, 0, counter, result, limitResultCount);
            }
            return result;
        };
        TextModel.prototype._findMatchInLine = function (searchRegex, text, lineNumber, deltaOffset) {
            var m = searchRegex.exec(text);
            if (!m) {
                return null;
            }
            return new range_1.Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset);
        };
        TextModel.prototype._findLastMatchInLine = function (searchRegex, text, lineNumber) {
            var bestResult = null;
            var m;
            while ((m = searchRegex.exec(text))) {
                var result = new range_1.Range(lineNumber, m.index + 1, lineNumber, m.index + 1 + m[0].length);
                if (result.equalsRange(bestResult)) {
                    break;
                }
                bestResult = result;
            }
            return bestResult;
        };
        TextModel.prototype._findMatchesInLine = function (searchRegex, text, lineNumber, deltaOffset, counter, result, limitResultCount) {
            var m;
            // Reset regex to search from the beginning
            searchRegex.lastIndex = 0;
            do {
                m = searchRegex.exec(text);
                if (m) {
                    var range = new range_1.Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset);
                    // Exit early if the regex matches the same range
                    if (range.equalsRange(result[result.length - 1])) {
                        return counter;
                    }
                    result.push(range);
                    counter++;
                    if (counter >= limitResultCount) {
                        return counter;
                    }
                }
            } while (m);
            return counter;
        };
        TextModel.MODEL_SYNC_LIMIT = 5 * 1024 * 1024; // 5 MB
        TextModel.MODEL_TOKENIZATION_LIMIT = 20 * 1024 * 1024; // 20 MB
        TextModel.DEFAULT_CREATION_OPTIONS = {
            tabSize: defaultConfig_1.DEFAULT_INDENTATION.tabSize,
            insertSpaces: defaultConfig_1.DEFAULT_INDENTATION.insertSpaces,
            detectIndentation: false,
            defaultEOL: editorCommon.DefaultEndOfLine.LF,
            trimAutoWhitespace: defaultConfig_1.DEFAULT_TRIM_AUTO_WHITESPACE,
        };
        return TextModel;
    }(eventEmitter_1.OrderGuaranteeEventEmitter));
    exports.TextModel = TextModel;
    var RawText = (function () {
        function RawText() {
        }
        RawText.fromString = function (rawText, opts) {
            return TextModel.toRawText(rawText, opts);
        };
        RawText.fromStringWithModelOptions = function (rawText, model) {
            var opts = model.getOptions();
            return TextModel.toRawText(rawText, {
                tabSize: opts.tabSize,
                insertSpaces: opts.insertSpaces,
                trimAutoWhitespace: opts.trimAutoWhitespace,
                detectIndentation: false,
                defaultEOL: opts.defaultEOL
            });
        };
        return RawText;
    }());
    exports.RawText = RawText;
});

define(__m[307], __M([5,6]), function(nls, data) { return nls.create("vs/editor/common/controller/cursor", data); });





define(__m[308], __M([0,1,307,8,23,3,110,220,173,21,4,24,7,40]), function (require, exports, nls, errors_1, eventEmitter_1, lifecycle_1, replaceCommand_1, cursorCollection_1, oneCursor_1, position_1, range_1, selection_1, editorCommon, languageConfigurationRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var RevealTarget;
    (function (RevealTarget) {
        RevealTarget[RevealTarget["Primary"] = 0] = "Primary";
        RevealTarget[RevealTarget["TopMost"] = 1] = "TopMost";
        RevealTarget[RevealTarget["BottomMost"] = 2] = "BottomMost";
    })(RevealTarget || (RevealTarget = {}));
    var Cursor = (function (_super) {
        __extends(Cursor, _super);
        function Cursor(editorId, configuration, model, viewModelHelper, enableEmptySelectionClipboard) {
            var _this = this;
            _super.call(this, [
                editorCommon.EventType.CursorPositionChanged,
                editorCommon.EventType.CursorSelectionChanged,
                editorCommon.EventType.CursorRevealRange,
                editorCommon.EventType.CursorScrollRequest
            ]);
            this._columnSelectToLineNumber = 0;
            this._columnSelectToVisualColumn = 0;
            this.editorId = editorId;
            this.configuration = configuration;
            this.model = model;
            this.viewModelHelper = viewModelHelper;
            this.enableEmptySelectionClipboard = enableEmptySelectionClipboard;
            if (!this.viewModelHelper) {
                this.viewModelHelper = {
                    viewModel: this.model,
                    convertModelPositionToViewPosition: function (lineNumber, column) {
                        return new position_1.Position(lineNumber, column);
                    },
                    convertModelRangeToViewRange: function (modelRange) {
                        return modelRange;
                    },
                    convertViewToModelPosition: function (lineNumber, column) {
                        return new position_1.Position(lineNumber, column);
                    },
                    convertViewSelectionToModelSelection: function (viewSelection) {
                        return viewSelection;
                    },
                    validateViewPosition: function (viewLineNumber, viewColumn, modelPosition) {
                        return modelPosition;
                    },
                    validateViewRange: function (viewStartLineNumber, viewStartColumn, viewEndLineNumber, viewEndColumn, modelRange) {
                        return modelRange;
                    }
                };
            }
            this.cursors = new cursorCollection_1.CursorCollection(this.editorId, this.model, this.configuration, this.viewModelHelper);
            this.cursorUndoStack = [];
            this.typingListeners = {};
            this._isHandling = false;
            this.modelUnbinds = [];
            this.modelUnbinds.push(this.model.onDidChangeRawContent(function (e) {
                _this._onModelContentChanged(e);
            }));
            this.modelUnbinds.push(this.model.onDidChangeMode(function (e) {
                _this._onModelModeChanged();
            }));
            this.modelUnbinds.push(languageConfigurationRegistry_1.LanguageConfigurationRegistry.onDidChange(function () {
                // TODO@Alex: react only if certain supports changed? (and if my model's mode changed)
                _this._onModelModeChanged();
            }));
            this._handlers = {};
            this._registerHandlers();
        }
        Cursor.prototype.dispose = function () {
            this.modelUnbinds = lifecycle_1.dispose(this.modelUnbinds);
            this.model = null;
            this.cursors.dispose();
            this.cursors = null;
            this.configuration = null;
            this.viewModelHelper = null;
            _super.prototype.dispose.call(this);
        };
        Cursor.prototype.saveState = function () {
            var selections = this.cursors.getSelections(), result = [], selection;
            for (var i = 0; i < selections.length; i++) {
                selection = selections[i];
                result.push({
                    inSelectionMode: !selection.isEmpty(),
                    selectionStart: {
                        lineNumber: selection.selectionStartLineNumber,
                        column: selection.selectionStartColumn,
                    },
                    position: {
                        lineNumber: selection.positionLineNumber,
                        column: selection.positionColumn,
                    }
                });
            }
            return result;
        };
        Cursor.prototype.restoreState = function (states) {
            var _this = this;
            var desiredSelections = [], state;
            for (var i = 0; i < states.length; i++) {
                state = states[i];
                var positionLineNumber = 1, positionColumn = 1;
                // Avoid missing properties on the literal
                if (state.position && state.position.lineNumber) {
                    positionLineNumber = state.position.lineNumber;
                }
                if (state.position && state.position.column) {
                    positionColumn = state.position.column;
                }
                var selectionStartLineNumber = positionLineNumber, selectionStartColumn = positionColumn;
                // Avoid missing properties on the literal
                if (state.selectionStart && state.selectionStart.lineNumber) {
                    selectionStartLineNumber = state.selectionStart.lineNumber;
                }
                if (state.selectionStart && state.selectionStart.column) {
                    selectionStartColumn = state.selectionStart.column;
                }
                desiredSelections.push({
                    selectionStartLineNumber: selectionStartLineNumber,
                    selectionStartColumn: selectionStartColumn,
                    positionLineNumber: positionLineNumber,
                    positionColumn: positionColumn
                });
            }
            this._onHandler('restoreState', function (ctx) {
                _this.cursors.setSelections(desiredSelections);
                return false;
            }, 'restoreState', null);
        };
        Cursor.prototype.setEditableRange = function (range) {
            this.model.setEditableRange(range);
        };
        Cursor.prototype.getEditableRange = function () {
            return this.model.getEditableRange();
        };
        Cursor.prototype.addTypingListener = function (character, callback) {
            if (!this.typingListeners.hasOwnProperty(character)) {
                this.typingListeners[character] = [];
            }
            this.typingListeners[character].push(callback);
        };
        Cursor.prototype.removeTypingListener = function (character, callback) {
            if (this.typingListeners.hasOwnProperty(character)) {
                var listeners = this.typingListeners[character];
                for (var i = 0; i < listeners.length; i++) {
                    if (listeners[i] === callback) {
                        listeners.splice(i, 1);
                        return;
                    }
                }
            }
        };
        Cursor.prototype._onModelModeChanged = function () {
            // the mode of this model has changed
            this.cursors.updateMode();
        };
        Cursor.prototype._onModelContentChanged = function (e) {
            var _this = this;
            if (e.changeType === editorCommon.EventType.ModelRawContentChangedFlush) {
                // a model.setValue() was called
                this.cursors.dispose();
                this.cursors = new cursorCollection_1.CursorCollection(this.editorId, this.model, this.configuration, this.viewModelHelper);
                this.emitCursorPositionChanged('model', editorCommon.CursorChangeReason.ContentFlush);
                this.emitCursorSelectionChanged('model', editorCommon.CursorChangeReason.ContentFlush);
            }
            else {
                if (!this._isHandling) {
                    this._onHandler('recoverSelectionFromMarkers', function (ctx) {
                        var result = _this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor.recoverSelectionFromMarkers(oneCtx); });
                        ctx.shouldPushStackElementBefore = false;
                        ctx.shouldPushStackElementAfter = false;
                        return result;
                    }, 'modelChange', null);
                }
            }
        };
        // ------ some getters/setters
        Cursor.prototype.getSelection = function () {
            return this.cursors.getSelection(0);
        };
        Cursor.prototype.getSelections = function () {
            return this.cursors.getSelections();
        };
        Cursor.prototype.getPosition = function () {
            return this.cursors.getPosition(0);
        };
        Cursor.prototype.setSelections = function (source, selections) {
            var _this = this;
            this._onHandler('setSelections', function (ctx) {
                ctx.shouldReveal = false;
                _this.cursors.setSelections(selections);
                return false;
            }, source, null);
        };
        // ------ auxiliary handling logic
        Cursor.prototype._createAndInterpretHandlerCtx = function (eventSource, eventData, callback) {
            var currentHandlerCtx = {
                cursorPositionChangeReason: editorCommon.CursorChangeReason.NotSet,
                shouldReveal: true,
                shouldRevealVerticalInCenter: false,
                shouldRevealHorizontal: true,
                shouldRevealTarget: RevealTarget.Primary,
                eventSource: eventSource,
                eventData: eventData,
                executeCommands: [],
                isAutoWhitespaceCommand: [],
                hasExecutedCommands: false,
                isCursorUndo: false,
                postOperationRunnables: [],
                shouldPushStackElementBefore: false,
                shouldPushStackElementAfter: false,
                requestScrollDeltaLines: 0,
                setColumnSelectToLineNumber: 0,
                setColumnSelectToVisualColumn: 0
            };
            callback(currentHandlerCtx);
            this._interpretHandlerContext(currentHandlerCtx);
            this.cursors.normalize();
            return currentHandlerCtx.hasExecutedCommands;
        };
        Cursor.prototype._onHandler = function (command, handler, source, data) {
            this._isHandling = true;
            this.charactersTyped = '';
            var handled = false;
            try {
                var oldSelections = this.cursors.getSelections();
                var oldViewSelections = this.cursors.getViewSelections();
                var prevCursorsState = this.cursors.saveState();
                var eventSource = source;
                var cursorPositionChangeReason;
                var shouldReveal;
                var shouldRevealVerticalInCenter;
                var shouldRevealHorizontal;
                var shouldRevealTarget;
                var isCursorUndo;
                var requestScrollDeltaLines;
                var hasExecutedCommands = this._createAndInterpretHandlerCtx(eventSource, data, function (currentHandlerCtx) {
                    handled = handler(currentHandlerCtx);
                    cursorPositionChangeReason = currentHandlerCtx.cursorPositionChangeReason;
                    shouldReveal = currentHandlerCtx.shouldReveal;
                    shouldRevealTarget = currentHandlerCtx.shouldRevealTarget;
                    shouldRevealVerticalInCenter = currentHandlerCtx.shouldRevealVerticalInCenter;
                    shouldRevealHorizontal = currentHandlerCtx.shouldRevealHorizontal;
                    isCursorUndo = currentHandlerCtx.isCursorUndo;
                    requestScrollDeltaLines = currentHandlerCtx.requestScrollDeltaLines;
                });
                if (hasExecutedCommands) {
                    this.cursorUndoStack = [];
                }
                // Ping typing listeners after the model emits events & after I emit events
                for (var i = 0; i < this.charactersTyped.length; i++) {
                    var chr = this.charactersTyped.charAt(i);
                    if (this.typingListeners.hasOwnProperty(chr)) {
                        var listeners = this.typingListeners[chr].slice(0);
                        for (var j = 0, lenJ = listeners.length; j < lenJ; j++) {
                            // Hoping that listeners understand that the view might be in an awkward state
                            try {
                                listeners[j]();
                            }
                            catch (e) {
                                errors_1.onUnexpectedError(e);
                            }
                        }
                    }
                }
                var newSelections = this.cursors.getSelections();
                var newViewSelections = this.cursors.getViewSelections();
                var somethingChanged = false;
                if (oldSelections.length !== newSelections.length) {
                    somethingChanged = true;
                }
                else {
                    for (var i = 0, len = oldSelections.length; !somethingChanged && i < len; i++) {
                        if (!oldSelections[i].equalsSelection(newSelections[i])) {
                            somethingChanged = true;
                        }
                    }
                    for (var i = 0, len = oldViewSelections.length; !somethingChanged && i < len; i++) {
                        if (!oldViewSelections[i].equalsSelection(newViewSelections[i])) {
                            somethingChanged = true;
                        }
                    }
                }
                if (somethingChanged) {
                    if (!hasExecutedCommands && !isCursorUndo) {
                        this.cursorUndoStack.push(prevCursorsState);
                    }
                    if (this.cursorUndoStack.length > 50) {
                        this.cursorUndoStack = this.cursorUndoStack.splice(0, this.cursorUndoStack.length - 50);
                    }
                    this.emitCursorPositionChanged(eventSource, cursorPositionChangeReason);
                    if (shouldReveal) {
                        this.emitCursorRevealRange(shouldRevealTarget, shouldRevealVerticalInCenter ? editorCommon.VerticalRevealType.Center : editorCommon.VerticalRevealType.Simple, shouldRevealHorizontal);
                    }
                    this.emitCursorSelectionChanged(eventSource, cursorPositionChangeReason);
                }
                if (requestScrollDeltaLines) {
                    this.emitCursorScrollRequest(requestScrollDeltaLines);
                }
            }
            catch (err) {
                errors_1.onUnexpectedError(err);
            }
            this._isHandling = false;
            return handled;
        };
        Cursor.prototype._interpretHandlerContext = function (ctx) {
            if (ctx.shouldPushStackElementBefore) {
                this.model.pushStackElement();
                ctx.shouldPushStackElementBefore = false;
            }
            this._columnSelectToLineNumber = ctx.setColumnSelectToLineNumber;
            this._columnSelectToVisualColumn = ctx.setColumnSelectToVisualColumn;
            ctx.hasExecutedCommands = this._internalExecuteCommands(ctx.executeCommands, ctx.isAutoWhitespaceCommand, ctx.postOperationRunnables) || ctx.hasExecutedCommands;
            ctx.executeCommands = [];
            if (ctx.shouldPushStackElementAfter) {
                this.model.pushStackElement();
                ctx.shouldPushStackElementAfter = false;
            }
            var hasPostOperationRunnables = false;
            for (var i = 0, len = ctx.postOperationRunnables.length; i < len; i++) {
                if (ctx.postOperationRunnables[i]) {
                    hasPostOperationRunnables = true;
                    break;
                }
            }
            if (hasPostOperationRunnables) {
                var postOperationRunnables = ctx.postOperationRunnables.slice(0);
                ctx.postOperationRunnables = [];
                this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
                    if (postOperationRunnables[cursorIndex]) {
                        postOperationRunnables[cursorIndex](oneCtx);
                    }
                    return false;
                });
                this._interpretHandlerContext(ctx);
            }
        };
        Cursor.prototype._interpretCommandResult = function (cursorState) {
            if (!cursorState) {
                return false;
            }
            this.cursors.setSelections(cursorState);
            return true;
        };
        Cursor.prototype._getEditOperationsFromCommand = function (ctx, majorIdentifier, command, isAutoWhitespaceCommand) {
            var _this = this;
            // This method acts as a transaction, if the command fails
            // everything it has done is ignored
            var operations = [], operationMinor = 0;
            var addEditOperation = function (selection, text) {
                if (selection.isEmpty() && text === '') {
                    // This command wants to add a no-op => no thank you
                    return;
                }
                operations.push({
                    identifier: {
                        major: majorIdentifier,
                        minor: operationMinor++
                    },
                    range: selection,
                    text: text,
                    forceMoveMarkers: false,
                    isAutoWhitespaceEdit: isAutoWhitespaceCommand
                });
            };
            var hadTrackedRange = false;
            var trackSelection = function (selection, trackPreviousOnEmpty) {
                var selectionMarkerStickToPreviousCharacter, positionMarkerStickToPreviousCharacter;
                if (selection.isEmpty()) {
                    // Try to lock it with surrounding text
                    if (typeof trackPreviousOnEmpty === 'boolean') {
                        selectionMarkerStickToPreviousCharacter = trackPreviousOnEmpty;
                        positionMarkerStickToPreviousCharacter = trackPreviousOnEmpty;
                    }
                    else {
                        var maxLineColumn = _this.model.getLineMaxColumn(selection.startLineNumber);
                        if (selection.startColumn === maxLineColumn) {
                            selectionMarkerStickToPreviousCharacter = true;
                            positionMarkerStickToPreviousCharacter = true;
                        }
                        else {
                            selectionMarkerStickToPreviousCharacter = false;
                            positionMarkerStickToPreviousCharacter = false;
                        }
                    }
                }
                else {
                    if (selection.getDirection() === selection_1.SelectionDirection.LTR) {
                        selectionMarkerStickToPreviousCharacter = false;
                        positionMarkerStickToPreviousCharacter = true;
                    }
                    else {
                        selectionMarkerStickToPreviousCharacter = true;
                        positionMarkerStickToPreviousCharacter = false;
                    }
                }
                var l = ctx.selectionStartMarkers.length;
                ctx.selectionStartMarkers[l] = _this.model._addMarker(selection.selectionStartLineNumber, selection.selectionStartColumn, selectionMarkerStickToPreviousCharacter);
                ctx.positionMarkers[l] = _this.model._addMarker(selection.positionLineNumber, selection.positionColumn, positionMarkerStickToPreviousCharacter);
                return l.toString();
            };
            var editOperationBuilder = {
                addEditOperation: addEditOperation,
                trackSelection: trackSelection
            };
            try {
                command.getEditOperations(this.model, editOperationBuilder);
            }
            catch (e) {
                e.friendlyMessage = nls.localize(0, null);
                errors_1.onUnexpectedError(e);
                return {
                    operations: [],
                    hadTrackedRange: false
                };
            }
            return {
                operations: operations,
                hadTrackedRange: hadTrackedRange
            };
        };
        Cursor.prototype._getEditOperations = function (ctx, commands, isAutoWhitespaceCommand) {
            var oneResult;
            var operations = [];
            var hadTrackedRanges = [];
            var anyoneHadTrackedRange;
            for (var i = 0; i < commands.length; i++) {
                if (commands[i]) {
                    oneResult = this._getEditOperationsFromCommand(ctx, i, commands[i], isAutoWhitespaceCommand[i]);
                    operations = operations.concat(oneResult.operations);
                    hadTrackedRanges[i] = oneResult.hadTrackedRange;
                    anyoneHadTrackedRange = anyoneHadTrackedRange || hadTrackedRanges[i];
                }
                else {
                    hadTrackedRanges[i] = false;
                }
            }
            return {
                operations: operations,
                hadTrackedRanges: hadTrackedRanges,
                anyoneHadTrackedRange: anyoneHadTrackedRange
            };
        };
        Cursor.prototype._getLoserCursorMap = function (operations) {
            // This is destructive on the array
            operations = operations.slice(0);
            // Sort operations with last one first
            operations.sort(function (a, b) {
                // Note the minus!
                return -(range_1.Range.compareRangesUsingEnds(a.range, b.range));
            });
            // Operations can not overlap!
            var loserCursorsMap = {};
            var previousOp;
            var currentOp;
            var loserMajor;
            for (var i = 1; i < operations.length; i++) {
                previousOp = operations[i - 1];
                currentOp = operations[i];
                if (previousOp.range.getStartPosition().isBefore(currentOp.range.getEndPosition())) {
                    if (previousOp.identifier.major > currentOp.identifier.major) {
                        // previousOp loses the battle
                        loserMajor = previousOp.identifier.major;
                    }
                    else {
                        loserMajor = currentOp.identifier.major;
                    }
                    loserCursorsMap[loserMajor.toString()] = true;
                    for (var j = 0; j < operations.length; j++) {
                        if (operations[j].identifier.major === loserMajor) {
                            operations.splice(j, 1);
                            if (j < i) {
                                i--;
                            }
                            j--;
                        }
                    }
                    if (i > 0) {
                        i--;
                    }
                }
            }
            return loserCursorsMap;
        };
        Cursor.prototype._collapseDeleteCommands = function (rawCmds, isAutoWhitespaceCommand, postOperationRunnables) {
            if (rawCmds.length === 1) {
                return;
            }
            // Merge adjacent delete commands
            var allAreDeleteCommands = rawCmds.every(function (command) {
                if (!(command instanceof replaceCommand_1.ReplaceCommand)) {
                    return false;
                }
                var replCmd = command;
                if (replCmd.getText().length > 0) {
                    return false;
                }
                return true;
            });
            if (!allAreDeleteCommands) {
                return;
            }
            var commands = rawCmds;
            var cursors = commands.map(function (cmd, i) {
                return {
                    range: commands[i].getRange(),
                    postOperationRunnable: postOperationRunnables[i],
                    order: i
                };
            });
            cursors.sort(function (a, b) {
                return range_1.Range.compareRangesUsingStarts(a.range, b.range);
            });
            var previousCursor = cursors[0];
            for (var i = 1; i < cursors.length; i++) {
                if (previousCursor.range.endLineNumber === cursors[i].range.startLineNumber && previousCursor.range.endColumn === cursors[i].range.startColumn) {
                    // Merge ranges
                    var mergedRange = new range_1.Range(previousCursor.range.startLineNumber, previousCursor.range.startColumn, cursors[i].range.endLineNumber, cursors[i].range.endColumn);
                    previousCursor.range = mergedRange;
                    commands[cursors[i].order].setRange(mergedRange);
                    commands[previousCursor.order].setRange(mergedRange);
                }
                else {
                    // Push previous cursor
                    previousCursor = cursors[i];
                }
            }
        };
        Cursor.prototype._internalExecuteCommands = function (commands, isAutoWhitespaceCommand, postOperationRunnables) {
            var ctx = {
                selectionStartMarkers: [],
                positionMarkers: []
            };
            this._collapseDeleteCommands(commands, isAutoWhitespaceCommand, postOperationRunnables);
            var r = this._innerExecuteCommands(ctx, commands, isAutoWhitespaceCommand, postOperationRunnables);
            for (var i = 0; i < ctx.selectionStartMarkers.length; i++) {
                this.model._removeMarker(ctx.selectionStartMarkers[i]);
                this.model._removeMarker(ctx.positionMarkers[i]);
            }
            return r;
        };
        Cursor.prototype._arrayIsEmpty = function (commands) {
            var i, len;
            for (i = 0, len = commands.length; i < len; i++) {
                if (commands[i]) {
                    return false;
                }
            }
            return true;
        };
        Cursor.prototype._innerExecuteCommands = function (ctx, commands, isAutoWhitespaceCommand, postOperationRunnables) {
            var _this = this;
            if (this.configuration.editor.readOnly) {
                return false;
            }
            if (this._arrayIsEmpty(commands)) {
                return false;
            }
            var selectionsBefore = this.cursors.getSelections();
            var commandsData = this._getEditOperations(ctx, commands, isAutoWhitespaceCommand);
            if (commandsData.operations.length === 0 && !commandsData.anyoneHadTrackedRange) {
                return false;
            }
            var rawOperations = commandsData.operations;
            var editableRange = this.model.getEditableRange();
            var editableRangeStart = editableRange.getStartPosition();
            var editableRangeEnd = editableRange.getEndPosition();
            for (var i = 0; i < rawOperations.length; i++) {
                var operationRange = rawOperations[i].range;
                if (!editableRangeStart.isBeforeOrEqual(operationRange.getStartPosition()) || !operationRange.getEndPosition().isBeforeOrEqual(editableRangeEnd)) {
                    // These commands are outside of the editable range
                    return false;
                }
            }
            var loserCursorsMap = this._getLoserCursorMap(rawOperations);
            if (loserCursorsMap.hasOwnProperty('0')) {
                // These commands are very messed up
                console.warn('Ignoring commands');
                return false;
            }
            // Remove operations belonging to losing cursors
            var filteredOperations = [];
            for (var i = 0; i < rawOperations.length; i++) {
                if (!loserCursorsMap.hasOwnProperty(rawOperations[i].identifier.major.toString())) {
                    filteredOperations.push(rawOperations[i]);
                }
            }
            var selectionsAfter = this.model.pushEditOperations(selectionsBefore, filteredOperations, function (inverseEditOperations) {
                var groupedInverseEditOperations = [];
                for (var i = 0; i < selectionsBefore.length; i++) {
                    groupedInverseEditOperations[i] = [];
                }
                for (var i = 0; i < inverseEditOperations.length; i++) {
                    var op = inverseEditOperations[i];
                    if (!op.identifier) {
                        // perhaps auto whitespace trim edits
                        continue;
                    }
                    groupedInverseEditOperations[op.identifier.major].push(op);
                }
                var minorBasedSorter = function (a, b) {
                    return a.identifier.minor - b.identifier.minor;
                };
                var cursorSelections = [];
                for (var i = 0; i < selectionsBefore.length; i++) {
                    if (groupedInverseEditOperations[i].length > 0 || commandsData.hadTrackedRanges[i]) {
                        groupedInverseEditOperations[i].sort(minorBasedSorter);
                        cursorSelections[i] = commands[i].computeCursorState(_this.model, {
                            getInverseEditOperations: function () {
                                return groupedInverseEditOperations[i];
                            },
                            getTrackedSelection: function (id) {
                                var idx = parseInt(id, 10);
                                var selectionStartMarker = _this.model._getMarker(ctx.selectionStartMarkers[idx]);
                                var positionMarker = _this.model._getMarker(ctx.positionMarkers[idx]);
                                return new selection_1.Selection(selectionStartMarker.lineNumber, selectionStartMarker.column, positionMarker.lineNumber, positionMarker.column);
                            }
                        });
                    }
                    else {
                        cursorSelections[i] = selectionsBefore[i];
                    }
                }
                return cursorSelections;
            });
            // Extract losing cursors
            var losingCursorIndex;
            var losingCursors = [];
            for (losingCursorIndex in loserCursorsMap) {
                if (loserCursorsMap.hasOwnProperty(losingCursorIndex)) {
                    losingCursors.push(parseInt(losingCursorIndex, 10));
                }
            }
            // Sort losing cursors descending
            losingCursors.sort(function (a, b) {
                return b - a;
            });
            // Remove losing cursors
            for (var i = 0; i < losingCursors.length; i++) {
                selectionsAfter.splice(losingCursors[i], 1);
                postOperationRunnables.splice(losingCursors[i], 1);
            }
            return this._interpretCommandResult(selectionsAfter);
        };
        // -----------------------------------------------------------------------------------------------------------
        // ----- emitting events
        Cursor.prototype.emitCursorPositionChanged = function (source, reason) {
            var positions = this.cursors.getPositions();
            var primaryPosition = positions[0];
            var secondaryPositions = positions.slice(1);
            var viewPositions = this.cursors.getViewPositions();
            var primaryViewPosition = viewPositions[0];
            var secondaryViewPositions = viewPositions.slice(1);
            var isInEditableRange = true;
            if (this.model.hasEditableRange()) {
                var editableRange = this.model.getEditableRange();
                if (!editableRange.containsPosition(primaryPosition)) {
                    isInEditableRange = false;
                }
            }
            var e = {
                position: primaryPosition,
                viewPosition: primaryViewPosition,
                secondaryPositions: secondaryPositions,
                secondaryViewPositions: secondaryViewPositions,
                reason: reason,
                source: source,
                isInEditableRange: isInEditableRange
            };
            this.emit(editorCommon.EventType.CursorPositionChanged, e);
        };
        Cursor.prototype.emitCursorSelectionChanged = function (source, reason) {
            var selections = this.cursors.getSelections();
            var primarySelection = selections[0];
            var secondarySelections = selections.slice(1);
            var viewSelections = this.cursors.getViewSelections();
            var primaryViewSelection = viewSelections[0];
            var secondaryViewSelections = viewSelections.slice(1);
            var e = {
                selection: primarySelection,
                viewSelection: primaryViewSelection,
                secondarySelections: secondarySelections,
                secondaryViewSelections: secondaryViewSelections,
                source: source,
                reason: reason
            };
            this.emit(editorCommon.EventType.CursorSelectionChanged, e);
        };
        Cursor.prototype.emitCursorScrollRequest = function (lineScrollOffset) {
            var e = {
                deltaLines: lineScrollOffset
            };
            this.emit(editorCommon.EventType.CursorScrollRequest, e);
        };
        Cursor.prototype.emitCursorRevealRange = function (revealTarget, verticalType, revealHorizontal) {
            var positions = this.cursors.getPositions();
            var viewPositions = this.cursors.getViewPositions();
            var position = positions[0];
            var viewPosition = viewPositions[0];
            if (revealTarget === RevealTarget.TopMost) {
                for (var i = 1; i < positions.length; i++) {
                    if (positions[i].isBefore(position)) {
                        position = positions[i];
                        viewPosition = viewPositions[i];
                    }
                }
            }
            else if (revealTarget === RevealTarget.BottomMost) {
                for (var i = 1; i < positions.length; i++) {
                    if (position.isBeforeOrEqual(positions[i])) {
                        position = positions[i];
                        viewPosition = viewPositions[i];
                    }
                }
            }
            else {
                if (positions.length > 1) {
                    // no revealing!
                    return;
                }
            }
            var range = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
            var viewRange = new range_1.Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column);
            var e = {
                range: range,
                viewRange: viewRange,
                verticalType: verticalType,
                revealHorizontal: revealHorizontal
            };
            this.emit(editorCommon.EventType.CursorRevealRange, e);
        };
        // -----------------------------------------------------------------------------------------------------------
        // ----- handlers beyond this point
        Cursor.prototype.trigger = function (source, handlerId, payload) {
            if (!this._handlers.hasOwnProperty(handlerId)) {
                return;
            }
            var handler = this._handlers[handlerId];
            this._onHandler(handlerId, handler, source, payload);
        };
        Cursor.prototype._registerHandlers = function () {
            var _this = this;
            var H = editorCommon.Handler;
            this._handlers[H.JumpToBracket] = function (ctx) { return _this._jumpToBracket(ctx); };
            this._handlers[H.MoveTo] = function (ctx) { return _this._moveTo(false, ctx); };
            this._handlers[H.MoveToSelect] = function (ctx) { return _this._moveTo(true, ctx); };
            this._handlers[H.ColumnSelect] = function (ctx) { return _this._columnSelectMouse(ctx); };
            this._handlers[H.AddCursorUp] = function (ctx) { return _this._addCursorUp(ctx); };
            this._handlers[H.AddCursorDown] = function (ctx) { return _this._addCursorDown(ctx); };
            this._handlers[H.CreateCursor] = function (ctx) { return _this._createCursor(ctx); };
            this._handlers[H.LastCursorMoveToSelect] = function (ctx) { return _this._lastCursorMoveTo(ctx); };
            this._handlers[H.CursorLeft] = function (ctx) { return _this._moveLeft(false, ctx); };
            this._handlers[H.CursorLeftSelect] = function (ctx) { return _this._moveLeft(true, ctx); };
            this._handlers[H.CursorWordLeft] = function (ctx) { return _this._moveWordLeft(false, oneCursor_1.WordNavigationType.WordStart, ctx); };
            this._handlers[H.CursorWordStartLeft] = function (ctx) { return _this._moveWordLeft(false, oneCursor_1.WordNavigationType.WordStart, ctx); };
            this._handlers[H.CursorWordEndLeft] = function (ctx) { return _this._moveWordLeft(false, oneCursor_1.WordNavigationType.WordEnd, ctx); };
            this._handlers[H.CursorWordLeftSelect] = function (ctx) { return _this._moveWordLeft(true, oneCursor_1.WordNavigationType.WordStart, ctx); };
            this._handlers[H.CursorWordStartLeftSelect] = function (ctx) { return _this._moveWordLeft(true, oneCursor_1.WordNavigationType.WordStart, ctx); };
            this._handlers[H.CursorWordEndLeftSelect] = function (ctx) { return _this._moveWordLeft(true, oneCursor_1.WordNavigationType.WordEnd, ctx); };
            this._handlers[H.CursorRight] = function (ctx) { return _this._moveRight(false, ctx); };
            this._handlers[H.CursorRightSelect] = function (ctx) { return _this._moveRight(true, ctx); };
            this._handlers[H.CursorWordRight] = function (ctx) { return _this._moveWordRight(false, oneCursor_1.WordNavigationType.WordEnd, ctx); };
            this._handlers[H.CursorWordStartRight] = function (ctx) { return _this._moveWordRight(false, oneCursor_1.WordNavigationType.WordStart, ctx); };
            this._handlers[H.CursorWordEndRight] = function (ctx) { return _this._moveWordRight(false, oneCursor_1.WordNavigationType.WordEnd, ctx); };
            this._handlers[H.CursorWordRightSelect] = function (ctx) { return _this._moveWordRight(true, oneCursor_1.WordNavigationType.WordEnd, ctx); };
            this._handlers[H.CursorWordStartRightSelect] = function (ctx) { return _this._moveWordRight(true, oneCursor_1.WordNavigationType.WordStart, ctx); };
            this._handlers[H.CursorWordEndRightSelect] = function (ctx) { return _this._moveWordRight(true, oneCursor_1.WordNavigationType.WordEnd, ctx); };
            this._handlers[H.CursorUp] = function (ctx) { return _this._moveUp(false, false, ctx); };
            this._handlers[H.CursorUpSelect] = function (ctx) { return _this._moveUp(true, false, ctx); };
            this._handlers[H.CursorDown] = function (ctx) { return _this._moveDown(false, false, ctx); };
            this._handlers[H.CursorDownSelect] = function (ctx) { return _this._moveDown(true, false, ctx); };
            this._handlers[H.CursorPageUp] = function (ctx) { return _this._moveUp(false, true, ctx); };
            this._handlers[H.CursorPageUpSelect] = function (ctx) { return _this._moveUp(true, true, ctx); };
            this._handlers[H.CursorPageDown] = function (ctx) { return _this._moveDown(false, true, ctx); };
            this._handlers[H.CursorPageDownSelect] = function (ctx) { return _this._moveDown(true, true, ctx); };
            this._handlers[H.CursorHome] = function (ctx) { return _this._moveToBeginningOfLine(false, ctx); };
            this._handlers[H.CursorHomeSelect] = function (ctx) { return _this._moveToBeginningOfLine(true, ctx); };
            this._handlers[H.CursorEnd] = function (ctx) { return _this._moveToEndOfLine(false, ctx); };
            this._handlers[H.CursorEndSelect] = function (ctx) { return _this._moveToEndOfLine(true, ctx); };
            this._handlers[H.CursorTop] = function (ctx) { return _this._moveToBeginningOfBuffer(false, ctx); };
            this._handlers[H.CursorTopSelect] = function (ctx) { return _this._moveToBeginningOfBuffer(true, ctx); };
            this._handlers[H.CursorBottom] = function (ctx) { return _this._moveToEndOfBuffer(false, ctx); };
            this._handlers[H.CursorBottomSelect] = function (ctx) { return _this._moveToEndOfBuffer(true, ctx); };
            this._handlers[H.CursorColumnSelectLeft] = function (ctx) { return _this._columnSelectLeft(ctx); };
            this._handlers[H.CursorColumnSelectRight] = function (ctx) { return _this._columnSelectRight(ctx); };
            this._handlers[H.CursorColumnSelectUp] = function (ctx) { return _this._columnSelectUp(false, ctx); };
            this._handlers[H.CursorColumnSelectPageUp] = function (ctx) { return _this._columnSelectUp(true, ctx); };
            this._handlers[H.CursorColumnSelectDown] = function (ctx) { return _this._columnSelectDown(false, ctx); };
            this._handlers[H.CursorColumnSelectPageDown] = function (ctx) { return _this._columnSelectDown(true, ctx); };
            this._handlers[H.SelectAll] = function (ctx) { return _this._selectAll(ctx); };
            this._handlers[H.LineSelect] = function (ctx) { return _this._line(false, ctx); };
            this._handlers[H.LineSelectDrag] = function (ctx) { return _this._line(true, ctx); };
            this._handlers[H.LastCursorLineSelect] = function (ctx) { return _this._lastCursorLine(false, ctx); };
            this._handlers[H.LastCursorLineSelectDrag] = function (ctx) { return _this._lastCursorLine(true, ctx); };
            this._handlers[H.LineInsertBefore] = function (ctx) { return _this._lineInsertBefore(ctx); };
            this._handlers[H.LineInsertAfter] = function (ctx) { return _this._lineInsertAfter(ctx); };
            this._handlers[H.LineBreakInsert] = function (ctx) { return _this._lineBreakInsert(ctx); };
            this._handlers[H.WordSelect] = function (ctx) { return _this._word(false, ctx); };
            this._handlers[H.WordSelectDrag] = function (ctx) { return _this._word(true, ctx); };
            this._handlers[H.LastCursorWordSelect] = function (ctx) { return _this._lastCursorWord(ctx); };
            this._handlers[H.CancelSelection] = function (ctx) { return _this._cancelSelection(ctx); };
            this._handlers[H.RemoveSecondaryCursors] = function (ctx) { return _this._removeSecondaryCursors(ctx); };
            this._handlers[H.Type] = function (ctx) { return _this._type(ctx); };
            this._handlers[H.ReplacePreviousChar] = function (ctx) { return _this._replacePreviousChar(ctx); };
            this._handlers[H.Tab] = function (ctx) { return _this._tab(ctx); };
            this._handlers[H.Indent] = function (ctx) { return _this._indent(ctx); };
            this._handlers[H.Outdent] = function (ctx) { return _this._outdent(ctx); };
            this._handlers[H.Paste] = function (ctx) { return _this._paste(ctx); };
            this._handlers[H.ScrollLineUp] = function (ctx) { return _this._scrollUp(false, ctx); };
            this._handlers[H.ScrollLineDown] = function (ctx) { return _this._scrollDown(false, ctx); };
            this._handlers[H.ScrollPageUp] = function (ctx) { return _this._scrollUp(true, ctx); };
            this._handlers[H.ScrollPageDown] = function (ctx) { return _this._scrollDown(true, ctx); };
            this._handlers[H.DeleteLeft] = function (ctx) { return _this._deleteLeft(ctx); };
            this._handlers[H.DeleteWordLeft] = function (ctx) { return _this._deleteWordLeft(true, oneCursor_1.WordNavigationType.WordStart, ctx); };
            this._handlers[H.DeleteWordStartLeft] = function (ctx) { return _this._deleteWordLeft(false, oneCursor_1.WordNavigationType.WordStart, ctx); };
            this._handlers[H.DeleteWordEndLeft] = function (ctx) { return _this._deleteWordLeft(false, oneCursor_1.WordNavigationType.WordEnd, ctx); };
            this._handlers[H.DeleteRight] = function (ctx) { return _this._deleteRight(ctx); };
            this._handlers[H.DeleteWordRight] = function (ctx) { return _this._deleteWordRight(true, oneCursor_1.WordNavigationType.WordEnd, ctx); };
            this._handlers[H.DeleteWordStartRight] = function (ctx) { return _this._deleteWordRight(false, oneCursor_1.WordNavigationType.WordStart, ctx); };
            this._handlers[H.DeleteWordEndRight] = function (ctx) { return _this._deleteWordRight(false, oneCursor_1.WordNavigationType.WordEnd, ctx); };
            this._handlers[H.DeleteAllLeft] = function (ctx) { return _this._deleteAllLeft(ctx); };
            this._handlers[H.DeleteAllRight] = function (ctx) { return _this._deleteAllRight(ctx); };
            this._handlers[H.Cut] = function (ctx) { return _this._cut(ctx); };
            this._handlers[H.ExpandLineSelection] = function (ctx) { return _this._expandLineSelection(ctx); };
            this._handlers[H.Undo] = function (ctx) { return _this._undo(ctx); };
            this._handlers[H.CursorUndo] = function (ctx) { return _this._cursorUndo(ctx); };
            this._handlers[H.Redo] = function (ctx) { return _this._redo(ctx); };
            this._handlers[H.ExecuteCommand] = function (ctx) { return _this._externalExecuteCommand(ctx); };
            this._handlers[H.ExecuteCommands] = function (ctx) { return _this._externalExecuteCommands(ctx); };
        };
        Cursor.prototype._invokeForAllSorted = function (ctx, callable, pushStackElementBefore, pushStackElementAfter) {
            if (pushStackElementBefore === void 0) { pushStackElementBefore = true; }
            if (pushStackElementAfter === void 0) { pushStackElementAfter = true; }
            return this._doInvokeForAll(ctx, true, callable, pushStackElementBefore, pushStackElementAfter);
        };
        Cursor.prototype._invokeForAll = function (ctx, callable, pushStackElementBefore, pushStackElementAfter) {
            if (pushStackElementBefore === void 0) { pushStackElementBefore = true; }
            if (pushStackElementAfter === void 0) { pushStackElementAfter = true; }
            return this._doInvokeForAll(ctx, false, callable, pushStackElementBefore, pushStackElementAfter);
        };
        Cursor.prototype._doInvokeForAll = function (ctx, sorted, callable, pushStackElementBefore, pushStackElementAfter) {
            if (pushStackElementBefore === void 0) { pushStackElementBefore = true; }
            if (pushStackElementAfter === void 0) { pushStackElementAfter = true; }
            var result = false;
            var cursors = this.cursors.getAll();
            if (sorted) {
                cursors = cursors.sort(function (a, b) {
                    return range_1.Range.compareRangesUsingStarts(a.getSelection(), b.getSelection());
                });
            }
            var context;
            ctx.shouldPushStackElementBefore = pushStackElementBefore;
            ctx.shouldPushStackElementAfter = pushStackElementAfter;
            for (var i = 0; i < cursors.length; i++) {
                context = {
                    cursorPositionChangeReason: editorCommon.CursorChangeReason.NotSet,
                    shouldReveal: true,
                    shouldRevealVerticalInCenter: false,
                    shouldRevealHorizontal: true,
                    executeCommand: null,
                    isAutoWhitespaceCommand: false,
                    postOperationRunnable: null,
                    shouldPushStackElementBefore: false,
                    shouldPushStackElementAfter: false,
                    requestScrollDeltaLines: 0
                };
                result = callable(i, cursors[i], context) || result;
                if (i === 0) {
                    ctx.cursorPositionChangeReason = context.cursorPositionChangeReason;
                    ctx.shouldRevealHorizontal = context.shouldRevealHorizontal;
                    ctx.shouldReveal = context.shouldReveal;
                    ctx.shouldRevealVerticalInCenter = context.shouldRevealVerticalInCenter;
                    ctx.requestScrollDeltaLines = context.requestScrollDeltaLines;
                }
                ctx.shouldPushStackElementBefore = ctx.shouldPushStackElementBefore || context.shouldPushStackElementBefore;
                ctx.shouldPushStackElementAfter = ctx.shouldPushStackElementAfter || context.shouldPushStackElementAfter;
                ctx.executeCommands[i] = context.executeCommand;
                ctx.isAutoWhitespaceCommand[i] = context.isAutoWhitespaceCommand;
                ctx.postOperationRunnables[i] = context.postOperationRunnable;
            }
            return result;
        };
        Cursor.prototype._jumpToBracket = function (ctx) {
            this.cursors.killSecondaryCursors();
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.jumpToBracket(oneCursor, oneCtx); });
        };
        Cursor.prototype._moveTo = function (inSelectionMode, ctx) {
            this.cursors.killSecondaryCursors();
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveTo(oneCursor, inSelectionMode, ctx.eventData.position, ctx.eventData.viewPosition, ctx.eventSource, oneCtx); });
        };
        Cursor.prototype._getColumnSelectToLineNumber = function () {
            if (!this._columnSelectToLineNumber) {
                var primaryCursor = this.cursors.getAll()[0];
                var primaryPos = primaryCursor.getViewPosition();
                return primaryPos.lineNumber;
            }
            return this._columnSelectToLineNumber;
        };
        Cursor.prototype._getColumnSelectToVisualColumn = function () {
            if (!this._columnSelectToVisualColumn) {
                var primaryCursor = this.cursors.getAll()[0];
                var primaryPos = primaryCursor.getViewPosition();
                return primaryCursor.getViewVisibleColumnFromColumn(primaryPos.lineNumber, primaryPos.column);
            }
            return this._columnSelectToVisualColumn;
        };
        Cursor.prototype._columnSelectMouse = function (ctx) {
            var cursors = this.cursors.getAll();
            var result = oneCursor_1.OneCursorOp.columnSelectMouse(cursors[0], ctx.eventData.position, ctx.eventData.viewPosition, ctx.eventData.mouseColumn - 1);
            ctx.shouldRevealTarget = (result.reversed ? RevealTarget.TopMost : RevealTarget.BottomMost);
            ctx.shouldReveal = true;
            ctx.setColumnSelectToLineNumber = result.toLineNumber;
            ctx.setColumnSelectToVisualColumn = result.toVisualColumn;
            this.cursors.setSelections(result.selections, result.viewSelections);
            return true;
        };
        Cursor.prototype._columnSelectOp = function (ctx, op) {
            var primary = this.cursors.getAll()[0];
            var result = op(primary, this._getColumnSelectToLineNumber(), this._getColumnSelectToVisualColumn());
            ctx.shouldRevealTarget = (result.reversed ? RevealTarget.TopMost : RevealTarget.BottomMost);
            ctx.shouldReveal = true;
            ctx.setColumnSelectToLineNumber = result.toLineNumber;
            ctx.setColumnSelectToVisualColumn = result.toVisualColumn;
            this.cursors.setSelections(result.selections, result.viewSelections);
            return true;
        };
        Cursor.prototype._columnSelectLeft = function (ctx) {
            return this._columnSelectOp(ctx, function (cursor, toViewLineNumber, toViewVisualColumn) { return oneCursor_1.OneCursorOp.columnSelectLeft(cursor, toViewLineNumber, toViewVisualColumn); });
        };
        Cursor.prototype._columnSelectRight = function (ctx) {
            return this._columnSelectOp(ctx, function (cursor, toViewLineNumber, toViewVisualColumn) { return oneCursor_1.OneCursorOp.columnSelectRight(cursor, toViewLineNumber, toViewVisualColumn); });
        };
        Cursor.prototype._columnSelectUp = function (isPaged, ctx) {
            return this._columnSelectOp(ctx, function (cursor, toViewLineNumber, toViewVisualColumn) { return oneCursor_1.OneCursorOp.columnSelectUp(isPaged, cursor, toViewLineNumber, toViewVisualColumn); });
        };
        Cursor.prototype._columnSelectDown = function (isPaged, ctx) {
            return this._columnSelectOp(ctx, function (cursor, toViewLineNumber, toViewVisualColumn) { return oneCursor_1.OneCursorOp.columnSelectDown(isPaged, cursor, toViewLineNumber, toViewVisualColumn); });
        };
        Cursor.prototype._createCursor = function (ctx) {
            if (this.configuration.editor.readOnly || this.model.hasEditableRange()) {
                return false;
            }
            this.cursors.addSecondaryCursor({
                selectionStartLineNumber: 1,
                selectionStartColumn: 1,
                positionLineNumber: 1,
                positionColumn: 1
            });
            // Manually move to get events
            var lastAddedCursor = this.cursors.getLastAddedCursor();
            this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
                if (oneCursor === lastAddedCursor) {
                    if (ctx.eventData.wholeLine) {
                        return oneCursor_1.OneCursorOp.line(oneCursor, false, ctx.eventData.position, ctx.eventData.viewPosition, oneCtx);
                    }
                    else {
                        return oneCursor_1.OneCursorOp.moveTo(oneCursor, false, ctx.eventData.position, ctx.eventData.viewPosition, ctx.eventSource, oneCtx);
                    }
                }
                return false;
            });
            ctx.shouldReveal = false;
            ctx.shouldRevealHorizontal = false;
            return true;
        };
        Cursor.prototype._lastCursorMoveTo = function (ctx) {
            if (this.configuration.editor.readOnly || this.model.hasEditableRange()) {
                return false;
            }
            var lastAddedCursor = this.cursors.getLastAddedCursor();
            this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
                if (oneCursor === lastAddedCursor) {
                    return oneCursor_1.OneCursorOp.moveTo(oneCursor, true, ctx.eventData.position, ctx.eventData.viewPosition, ctx.eventSource, oneCtx);
                }
                return false;
            });
            ctx.shouldReveal = false;
            ctx.shouldRevealHorizontal = false;
            return true;
        };
        Cursor.prototype._addCursorUp = function (ctx) {
            if (this.configuration.editor.readOnly) {
                return false;
            }
            var originalCnt = this.cursors.getSelections().length;
            this.cursors.duplicateCursors();
            ctx.shouldRevealTarget = RevealTarget.TopMost;
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
                if (cursorIndex >= originalCnt) {
                    return oneCursor_1.OneCursorOp.translateUp(oneCursor, oneCtx);
                }
                return false;
            });
        };
        Cursor.prototype._addCursorDown = function (ctx) {
            if (this.configuration.editor.readOnly) {
                return false;
            }
            var originalCnt = this.cursors.getSelections().length;
            this.cursors.duplicateCursors();
            ctx.shouldRevealTarget = RevealTarget.BottomMost;
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
                if (cursorIndex >= originalCnt) {
                    return oneCursor_1.OneCursorOp.translateDown(oneCursor, oneCtx);
                }
                return false;
            });
        };
        Cursor.prototype._moveLeft = function (inSelectionMode, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveLeft(oneCursor, inSelectionMode, oneCtx); });
        };
        Cursor.prototype._moveWordLeft = function (inSelectionMode, wordNavigationType, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveWordLeft(oneCursor, inSelectionMode, wordNavigationType, oneCtx); });
        };
        Cursor.prototype._moveRight = function (inSelectionMode, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveRight(oneCursor, inSelectionMode, oneCtx); });
        };
        Cursor.prototype._moveWordRight = function (inSelectionMode, wordNavigationType, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveWordRight(oneCursor, inSelectionMode, wordNavigationType, oneCtx); });
        };
        Cursor.prototype._moveDown = function (inSelectionMode, isPaged, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveDown(oneCursor, inSelectionMode, isPaged, ctx.eventData && ctx.eventData.pageSize || 0, oneCtx); });
        };
        Cursor.prototype._moveUp = function (inSelectionMode, isPaged, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveUp(oneCursor, inSelectionMode, isPaged, ctx.eventData && ctx.eventData.pageSize || 0, oneCtx); });
        };
        Cursor.prototype._moveToBeginningOfLine = function (inSelectionMode, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveToBeginningOfLine(oneCursor, inSelectionMode, oneCtx); });
        };
        Cursor.prototype._moveToEndOfLine = function (inSelectionMode, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveToEndOfLine(oneCursor, inSelectionMode, oneCtx); });
        };
        Cursor.prototype._moveToBeginningOfBuffer = function (inSelectionMode, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveToBeginningOfBuffer(oneCursor, inSelectionMode, oneCtx); });
        };
        Cursor.prototype._moveToEndOfBuffer = function (inSelectionMode, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.moveToEndOfBuffer(oneCursor, inSelectionMode, oneCtx); });
        };
        Cursor.prototype._selectAll = function (ctx) {
            this.cursors.killSecondaryCursors();
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.selectAll(oneCursor, oneCtx); });
        };
        Cursor.prototype._line = function (inSelectionMode, ctx) {
            this.cursors.killSecondaryCursors();
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.line(oneCursor, inSelectionMode, ctx.eventData.position, ctx.eventData.viewPosition, oneCtx); });
        };
        Cursor.prototype._lastCursorLine = function (inSelectionMode, ctx) {
            if (this.configuration.editor.readOnly || this.model.hasEditableRange()) {
                return false;
            }
            var lastAddedCursor = this.cursors.getLastAddedCursor();
            this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
                if (oneCursor === lastAddedCursor) {
                    return oneCursor_1.OneCursorOp.line(oneCursor, inSelectionMode, ctx.eventData.position, ctx.eventData.viewPosition, oneCtx);
                }
                return false;
            });
            ctx.shouldReveal = false;
            ctx.shouldRevealHorizontal = false;
            return true;
        };
        Cursor.prototype._expandLineSelection = function (ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.expandLineSelection(oneCursor, oneCtx); });
        };
        Cursor.prototype._lineInsertBefore = function (ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.lineInsertBefore(oneCursor, oneCtx); });
        };
        Cursor.prototype._lineInsertAfter = function (ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.lineInsertAfter(oneCursor, oneCtx); });
        };
        Cursor.prototype._lineBreakInsert = function (ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.lineBreakInsert(oneCursor, oneCtx); });
        };
        Cursor.prototype._word = function (inSelectionMode, ctx) {
            this.cursors.killSecondaryCursors();
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.word(oneCursor, inSelectionMode, ctx.eventData.position, oneCtx); });
        };
        Cursor.prototype._lastCursorWord = function (ctx) {
            if (this.configuration.editor.readOnly || this.model.hasEditableRange()) {
                return false;
            }
            var lastAddedCursor = this.cursors.getLastAddedCursor();
            this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
                if (oneCursor === lastAddedCursor) {
                    return oneCursor_1.OneCursorOp.word(oneCursor, true, ctx.eventData.position, oneCtx);
                }
                return false;
            });
            ctx.shouldReveal = false;
            ctx.shouldRevealHorizontal = false;
            return true;
        };
        Cursor.prototype._removeSecondaryCursors = function (ctx) {
            this.cursors.killSecondaryCursors();
            return true;
        };
        Cursor.prototype._cancelSelection = function (ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.cancelSelection(oneCursor, oneCtx); });
        };
        Cursor.prototype._type = function (ctx) {
            var _this = this;
            var text = ctx.eventData.text;
            if (ctx.eventSource === 'keyboard') {
                // If this event is coming straight from the keyboard, look for electric characters and enter
                var i, len, chr;
                for (i = 0, len = text.length; i < len; i++) {
                    chr = text.charAt(i);
                    this.charactersTyped += chr;
                    // Here we must interpret each typed character individually, that's why we create a new context
                    ctx.hasExecutedCommands = this._createAndInterpretHandlerCtx(ctx.eventSource, ctx.eventData, function (charHandlerCtx) {
                        _this._invokeForAll(charHandlerCtx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.type(oneCursor, chr, oneCtx); }, false, false);
                        // The last typed character gets to win
                        ctx.cursorPositionChangeReason = charHandlerCtx.cursorPositionChangeReason;
                        ctx.shouldReveal = charHandlerCtx.shouldReveal;
                        ctx.shouldRevealVerticalInCenter = charHandlerCtx.shouldRevealVerticalInCenter;
                        ctx.shouldRevealHorizontal = charHandlerCtx.shouldRevealHorizontal;
                    }) || ctx.hasExecutedCommands;
                }
            }
            else {
                this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.actualType(oneCursor, text, false, oneCtx); });
            }
            return true;
        };
        Cursor.prototype._replacePreviousChar = function (ctx) {
            var text = ctx.eventData.text;
            var replaceCharCnt = ctx.eventData.replaceCharCnt;
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.replacePreviousChar(oneCursor, text, replaceCharCnt, oneCtx); });
        };
        Cursor.prototype._tab = function (ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.tab(oneCursor, oneCtx); }, false, false);
        };
        Cursor.prototype._indent = function (ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.indent(oneCursor, oneCtx); });
        };
        Cursor.prototype._outdent = function (ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.outdent(oneCursor, oneCtx); });
        };
        Cursor.prototype._paste = function (ctx) {
            var distributedPaste = this._distributePasteToCursors(ctx);
            if (distributedPaste) {
                return this._invokeForAllSorted(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.paste(oneCursor, distributedPaste[cursorIndex], false, oneCtx); });
            }
            else {
                return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.paste(oneCursor, ctx.eventData.text, ctx.eventData.pasteOnNewLine, oneCtx); });
            }
        };
        Cursor.prototype._scrollUp = function (isPaged, ctx) {
            ctx.requestScrollDeltaLines = isPaged ? -this.cursors.getAll()[0].getPageSize() : -1;
            return true;
        };
        Cursor.prototype._scrollDown = function (isPaged, ctx) {
            ctx.requestScrollDeltaLines = isPaged ? this.cursors.getAll()[0].getPageSize() : 1;
            return true;
        };
        Cursor.prototype._distributePasteToCursors = function (ctx) {
            if (ctx.eventData.pasteOnNewLine) {
                return null;
            }
            var selections = this.cursors.getSelections();
            if (selections.length === 1) {
                return null;
            }
            for (var i = 0; i < selections.length; i++) {
                if (selections[i].startLineNumber !== selections[i].endLineNumber) {
                    return null;
                }
            }
            var pastePieces = ctx.eventData.text.split(/\r\n|\r|\n/);
            if (pastePieces.length !== selections.length) {
                return null;
            }
            return pastePieces;
        };
        Cursor.prototype._deleteLeft = function (ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.deleteLeft(oneCursor, oneCtx); }, false, false);
        };
        Cursor.prototype._deleteWordLeft = function (whitespaceHeuristics, wordNavigationType, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.deleteWordLeft(oneCursor, whitespaceHeuristics, wordNavigationType, oneCtx); }, false, false);
        };
        Cursor.prototype._deleteRight = function (ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.deleteRight(oneCursor, oneCtx); }, false, false);
        };
        Cursor.prototype._deleteWordRight = function (whitespaceHeuristics, wordNavigationType, ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.deleteWordRight(oneCursor, whitespaceHeuristics, wordNavigationType, oneCtx); }, false, false);
        };
        Cursor.prototype._deleteAllLeft = function (ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.deleteAllLeft(oneCursor, oneCtx); }, false, false);
        };
        Cursor.prototype._deleteAllRight = function (ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.deleteAllRight(oneCursor, oneCtx); }, false, false);
        };
        Cursor.prototype._cut = function (ctx) {
            var _this = this;
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) { return oneCursor_1.OneCursorOp.cut(oneCursor, _this.enableEmptySelectionClipboard, oneCtx); });
        };
        Cursor.prototype._undo = function (ctx) {
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Undo;
            ctx.hasExecutedCommands = true;
            this._interpretCommandResult(this.model.undo());
            return true;
        };
        Cursor.prototype._cursorUndo = function (ctx) {
            if (this.cursorUndoStack.length === 0) {
                return false;
            }
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Undo;
            ctx.isCursorUndo = true;
            this.cursors.restoreState(this.cursorUndoStack.pop());
            return true;
        };
        Cursor.prototype._redo = function (ctx) {
            ctx.cursorPositionChangeReason = editorCommon.CursorChangeReason.Redo;
            ctx.hasExecutedCommands = true;
            this._interpretCommandResult(this.model.redo());
            return true;
        };
        Cursor.prototype._externalExecuteCommand = function (ctx) {
            this.cursors.killSecondaryCursors();
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
                oneCtx.shouldPushStackElementBefore = true;
                oneCtx.shouldPushStackElementAfter = true;
                oneCtx.executeCommand = ctx.eventData;
                return false;
            });
        };
        Cursor.prototype._externalExecuteCommands = function (ctx) {
            return this._invokeForAll(ctx, function (cursorIndex, oneCursor, oneCtx) {
                oneCtx.shouldPushStackElementBefore = true;
                oneCtx.shouldPushStackElementAfter = true;
                oneCtx.executeCommand = ctx.eventData[cursorIndex];
                return false;
            });
        };
        return Cursor;
    }(eventEmitter_1.EventEmitter));
    exports.Cursor = Cursor;
});

define(__m[309], __M([5,6]), function(nls, data) { return nls.create("vs/editor/common/model/textModelWithTokens", data); });





define(__m[180], __M([0,1,309,14,8,3,143,59,2,7,177,176,306,121,49,83,88,305,154,40]), function (require, exports, nls, async_1, errors_1, lifecycle_1, stopwatch_1, timer, winjs_base_1, editorCommon, textModel_1, textModelWithTokensHelpers_1, tokenIterator_1, nullMode_1, supports_1, richEditBrackets_1, modeTransition_1, lineToken_1, tokensBinaryEncoding_1, languageConfigurationRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ModeToModelBinder = (function () {
        function ModeToModelBinder(modePromise, model) {
            var _this = this;
            this._modePromise = modePromise;
            // Create an external mode promise that fires after the mode is set to the model
            this._externalModePromise = new winjs_base_1.TPromise(function (c, e, p) {
                _this._externalModePromise_c = c;
                _this._externalModePromise_e = e;
            }, function () {
                // this promise cannot be canceled
            });
            this._model = model;
            this._isDisposed = false;
            // Ensure asynchronicity
            winjs_base_1.TPromise.timeout(0).then(function () {
                return _this._modePromise;
            }).then(function (mode) {
                if (_this._isDisposed) {
                    _this._externalModePromise_c(false);
                    return;
                }
                var model = _this._model;
                _this.dispose();
                model.setMode(mode);
                model._warmUpTokens();
                _this._externalModePromise_c(true);
            }).done(null, function (err) {
                _this._externalModePromise_e(err);
                errors_1.onUnexpectedError(err);
            });
        }
        ModeToModelBinder.prototype.getModePromise = function () {
            return this._externalModePromise;
        };
        ModeToModelBinder.prototype.dispose = function () {
            this._modePromise = null;
            this._model = null;
            this._isDisposed = true;
        };
        return ModeToModelBinder;
    }());
    var FullModelRetokenizer = (function () {
        function FullModelRetokenizer(retokenizePromise, model) {
            var _this = this;
            this._retokenizePromise = retokenizePromise;
            this._model = model;
            this._isDisposed = false;
            this.isFulfilled = false;
            // Ensure asynchronicity
            winjs_base_1.TPromise.timeout(0).then(function () {
                return _this._retokenizePromise;
            }).then(function () {
                if (_this._isDisposed) {
                    return;
                }
                _this.isFulfilled = true;
                _this._model.onRetokenizerFulfilled();
            }).done(null, errors_1.onUnexpectedError);
        }
        FullModelRetokenizer.prototype.getRange = function () {
            return null;
        };
        FullModelRetokenizer.prototype.dispose = function () {
            this._retokenizePromise = null;
            this._model = null;
            this._isDisposed = true;
        };
        return FullModelRetokenizer;
    }());
    exports.FullModelRetokenizer = FullModelRetokenizer;
    var LineContext = (function () {
        function LineContext(topLevelMode, line) {
            this.modeTransitions = line.getModeTransitions(topLevelMode);
            this._text = line.text;
            this._lineTokens = line.getTokens();
        }
        LineContext.prototype.getLineContent = function () {
            return this._text;
        };
        LineContext.prototype.getTokenCount = function () {
            return this._lineTokens.getTokenCount();
        };
        LineContext.prototype.getTokenStartIndex = function (tokenIndex) {
            return this._lineTokens.getTokenStartIndex(tokenIndex);
        };
        LineContext.prototype.getTokenEndIndex = function (tokenIndex) {
            return this._lineTokens.getTokenEndIndex(tokenIndex, this._text.length);
        };
        LineContext.prototype.getTokenType = function (tokenIndex) {
            return this._lineTokens.getTokenType(tokenIndex);
        };
        LineContext.prototype.getTokenText = function (tokenIndex) {
            var startIndex = this._lineTokens.getTokenStartIndex(tokenIndex);
            var endIndex = this._lineTokens.getTokenEndIndex(tokenIndex, this._text.length);
            return this._text.substring(startIndex, endIndex);
        };
        LineContext.prototype.findIndexOfOffset = function (offset) {
            return this._lineTokens.findIndexOfOffset(offset);
        };
        return LineContext;
    }());
    var TextModelWithTokens = (function (_super) {
        __extends(TextModelWithTokens, _super);
        function TextModelWithTokens(allowedEventTypes, rawText, shouldAutoTokenize, modeOrPromise) {
            var _this = this;
            allowedEventTypes.push(editorCommon.EventType.ModelTokensChanged);
            allowedEventTypes.push(editorCommon.EventType.ModelModeChanged);
            allowedEventTypes.push(editorCommon.EventType.ModelModeSupportChanged);
            _super.call(this, allowedEventTypes, rawText);
            this._shouldAutoTokenize = shouldAutoTokenize;
            this._mode = null;
            this._modeListener = null;
            this._modeToModelBinder = null;
            this._tokensInflatorMap = null;
            this._invalidLineStartIndex = 0;
            this._lastState = null;
            this._revalidateTokensTimeout = -1;
            this._scheduleRetokenizeNow = null;
            this._retokenizers = null;
            if (!modeOrPromise) {
                this._mode = new nullMode_1.NullMode();
            }
            else if (winjs_base_1.TPromise.is(modeOrPromise)) {
                // TODO@Alex: To avoid mode id changes, we check if this promise is resolved
                var promiseValue = modeOrPromise._value;
                if (promiseValue && typeof promiseValue.getId === 'function') {
                    // The promise is already resolved
                    this._mode = this._massageMode(promiseValue);
                    this._resetModeListener(this._mode);
                }
                else {
                    var modePromise = modeOrPromise;
                    this._modeToModelBinder = new ModeToModelBinder(modePromise, this);
                    this._mode = new nullMode_1.NullMode();
                }
            }
            else {
                this._mode = this._massageMode(modeOrPromise);
                this._resetModeListener(this._mode);
            }
            this._revalidateTokensTimeout = -1;
            this._scheduleRetokenizeNow = new async_1.RunOnceScheduler(function () { return _this._retokenizeNow(); }, 200);
            this._retokenizers = [];
            this._resetTokenizationState();
        }
        TextModelWithTokens.prototype.dispose = function () {
            if (this._modeToModelBinder) {
                this._modeToModelBinder.dispose();
                this._modeToModelBinder = null;
            }
            this._resetModeListener(null);
            this._clearTimers();
            this._mode = null;
            this._lastState = null;
            this._tokensInflatorMap = null;
            this._retokenizers = lifecycle_1.dispose(this._retokenizers);
            this._scheduleRetokenizeNow.dispose();
            _super.prototype.dispose.call(this);
        };
        TextModelWithTokens.prototype._massageMode = function (mode) {
            if (this.isTooLargeForHavingAMode()) {
                return new nullMode_1.NullMode();
            }
            if (this.isTooLargeForHavingARichMode()) {
                return mode.toSimplifiedMode();
            }
            return mode;
        };
        TextModelWithTokens.prototype.whenModeIsReady = function () {
            var _this = this;
            if (this._modeToModelBinder) {
                // Still waiting for some mode to load
                return this._modeToModelBinder.getModePromise().then(function () { return _this._mode; });
            }
            return winjs_base_1.TPromise.as(this._mode);
        };
        TextModelWithTokens.prototype.onRetokenizerFulfilled = function () {
            this._scheduleRetokenizeNow.schedule();
        };
        TextModelWithTokens.prototype._retokenizeNow = function () {
            var fulfilled = this._retokenizers.filter(function (r) { return r.isFulfilled; });
            this._retokenizers = this._retokenizers.filter(function (r) { return !r.isFulfilled; });
            var hasFullModel = false;
            for (var i = 0; i < fulfilled.length; i++) {
                if (!fulfilled[i].getRange()) {
                    hasFullModel = true;
                }
            }
            if (hasFullModel) {
                // Just invalidate all the lines
                for (var i = 0, len = this._lines.length; i < len; i++) {
                    this._lines[i].isInvalid = true;
                }
                this._invalidLineStartIndex = 0;
            }
            else {
                var minLineNumber = Number.MAX_VALUE;
                for (var i = 0; i < fulfilled.length; i++) {
                    var range = fulfilled[i].getRange();
                    minLineNumber = Math.min(minLineNumber, range.startLineNumber);
                    for (var lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {
                        this._lines[lineNumber - 1].isInvalid = true;
                    }
                }
                if (minLineNumber - 1 < this._invalidLineStartIndex) {
                    if (this._invalidLineStartIndex < this._lines.length) {
                        this._lines[this._invalidLineStartIndex].isInvalid = true;
                    }
                    this._invalidLineStartIndex = minLineNumber - 1;
                }
            }
            this._beginBackgroundTokenization();
            for (var i = 0; i < fulfilled.length; i++) {
                fulfilled[i].dispose();
            }
        };
        TextModelWithTokens.prototype._createRetokenizer = function (retokenizePromise, lineNumber) {
            return new FullModelRetokenizer(retokenizePromise, this);
        };
        TextModelWithTokens.prototype._resetValue = function (e, newValue) {
            _super.prototype._resetValue.call(this, e, newValue);
            // Cancel tokenization, clear all tokens and begin tokenizing
            this._resetTokenizationState();
        };
        TextModelWithTokens.prototype._resetMode = function (e, newMode) {
            // Cancel tokenization, clear all tokens and begin tokenizing
            this._mode = newMode;
            this._resetModeListener(newMode);
            this._resetTokenizationState();
            this.emitModelTokensChangedEvent(1, this.getLineCount());
        };
        TextModelWithTokens.prototype._resetModeListener = function (newMode) {
            var _this = this;
            if (this._modeListener) {
                this._modeListener.dispose();
                this._modeListener = null;
            }
            if (newMode && typeof newMode.addSupportChangedListener === 'function') {
                this._modeListener = newMode.addSupportChangedListener(function (e) { return _this._onModeSupportChanged(e); });
            }
        };
        TextModelWithTokens.prototype._onModeSupportChanged = function (e) {
            this._emitModelModeSupportChangedEvent(e);
            if (e.tokenizationSupport) {
                this._resetTokenizationState();
                this.emitModelTokensChangedEvent(1, this.getLineCount());
            }
        };
        TextModelWithTokens.prototype._resetTokenizationState = function () {
            this._retokenizers = lifecycle_1.dispose(this._retokenizers);
            this._scheduleRetokenizeNow.cancel();
            this._clearTimers();
            for (var i = 0; i < this._lines.length; i++) {
                this._lines[i].setState(null);
            }
            this._initializeTokenizationState();
        };
        TextModelWithTokens.prototype._clearTimers = function () {
            if (this._revalidateTokensTimeout !== -1) {
                clearTimeout(this._revalidateTokensTimeout);
                this._revalidateTokensTimeout = -1;
            }
        };
        TextModelWithTokens.prototype._initializeTokenizationState = function () {
            // Initialize tokenization states
            var initialState = null;
            if (this._mode.tokenizationSupport) {
                try {
                    initialState = this._mode.tokenizationSupport.getInitialState();
                }
                catch (e) {
                    e.friendlyMessage = TextModelWithTokens.MODE_TOKENIZATION_FAILED_MSG;
                    errors_1.onUnexpectedError(e);
                    this._mode = new nullMode_1.NullMode();
                }
            }
            if (!initialState) {
                initialState = new nullMode_1.NullState(this._mode, null);
            }
            this._lines[0].setState(initialState);
            this._lastState = null;
            this._tokensInflatorMap = new tokensBinaryEncoding_1.TokensInflatorMap();
            this._invalidLineStartIndex = 0;
            this._beginBackgroundTokenization();
        };
        TextModelWithTokens.prototype.getLineTokens = function (lineNumber, inaccurateTokensAcceptable) {
            if (inaccurateTokensAcceptable === void 0) { inaccurateTokensAcceptable = false; }
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            if (!inaccurateTokensAcceptable) {
                this._updateTokensUntilLine(lineNumber, true);
            }
            return this._lines[lineNumber - 1].getTokens();
        };
        TextModelWithTokens.prototype.getLineContext = function (lineNumber) {
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            this._updateTokensUntilLine(lineNumber, true);
            return new LineContext(this._mode, this._lines[lineNumber - 1]);
        };
        TextModelWithTokens.prototype._getInternalTokens = function (lineNumber) {
            this._updateTokensUntilLine(lineNumber, true);
            return this._lines[lineNumber - 1].getTokens();
        };
        TextModelWithTokens.prototype.getMode = function () {
            return this._mode;
        };
        TextModelWithTokens.prototype.setMode = function (newModeOrPromise) {
            if (!newModeOrPromise) {
                // There's nothing to do
                return;
            }
            if (this._modeToModelBinder) {
                this._modeToModelBinder.dispose();
                this._modeToModelBinder = null;
            }
            if (winjs_base_1.TPromise.is(newModeOrPromise)) {
                this._modeToModelBinder = new ModeToModelBinder(newModeOrPromise, this);
            }
            else {
                var actualNewMode = this._massageMode(newModeOrPromise);
                if (this._mode !== actualNewMode) {
                    var e2 = {
                        oldMode: this._mode,
                        newMode: actualNewMode
                    };
                    this._resetMode(e2, actualNewMode);
                    this._emitModelModeChangedEvent(e2);
                }
            }
        };
        TextModelWithTokens.prototype.getModeIdAtPosition = function (_lineNumber, _column) {
            var validPosition = this.validatePosition({
                lineNumber: _lineNumber,
                column: _column
            });
            var lineNumber = validPosition.lineNumber;
            var column = validPosition.column;
            if (column === 1) {
                return this.getStateBeforeLine(lineNumber).getMode().getId();
            }
            else if (column === this.getLineMaxColumn(lineNumber)) {
                return this.getStateAfterLine(lineNumber).getMode().getId();
            }
            else {
                var modeTransitions = this._getLineModeTransitions(lineNumber);
                var modeTransitionIndex = modeTransition_1.ModeTransition.findIndexInSegmentsArray(modeTransitions, column - 1);
                return modeTransitions[modeTransitionIndex].modeId;
            }
        };
        TextModelWithTokens.prototype._invalidateLine = function (lineIndex) {
            this._lines[lineIndex].isInvalid = true;
            if (lineIndex < this._invalidLineStartIndex) {
                if (this._invalidLineStartIndex < this._lines.length) {
                    this._lines[this._invalidLineStartIndex].isInvalid = true;
                }
                this._invalidLineStartIndex = lineIndex;
                this._beginBackgroundTokenization();
            }
        };
        TextModelWithTokens._toLineTokens = function (tokens) {
            if (!tokens || tokens.length === 0) {
                return [];
            }
            if (tokens[0] instanceof lineToken_1.LineToken) {
                return tokens;
            }
            var result = [];
            for (var i = 0, len = tokens.length; i < len; i++) {
                result[i] = new lineToken_1.LineToken(tokens[i].startIndex, tokens[i].type);
            }
            return result;
        };
        TextModelWithTokens._toModeTransitions = function (modeTransitions) {
            if (!modeTransitions || modeTransitions.length === 0) {
                return [];
            }
            if (modeTransitions[0] instanceof modeTransition_1.ModeTransition) {
                return modeTransitions;
            }
            var result = [];
            for (var i = 0, len = modeTransitions.length; i < len; i++) {
                result[i] = new modeTransition_1.ModeTransition(modeTransitions[i].startIndex, modeTransitions[i].mode);
            }
            return result;
        };
        TextModelWithTokens.prototype._updateLineTokens = function (lineIndex, map, topLevelMode, r) {
            this._lines[lineIndex].setTokens(map, TextModelWithTokens._toLineTokens(r.tokens), topLevelMode, TextModelWithTokens._toModeTransitions(r.modeTransitions));
        };
        TextModelWithTokens.prototype._beginBackgroundTokenization = function () {
            var _this = this;
            if (this._shouldAutoTokenize && this._revalidateTokensTimeout === -1) {
                this._revalidateTokensTimeout = setTimeout(function () {
                    _this._revalidateTokensTimeout = -1;
                    _this._revalidateTokensNow();
                }, 0);
            }
        };
        TextModelWithTokens.prototype._warmUpTokens = function () {
            // Warm up first 100 lines (if it takes less than 50ms)
            var maxLineNumber = Math.min(100, this.getLineCount());
            var toLineNumber = maxLineNumber;
            for (var lineNumber = 1; lineNumber <= maxLineNumber; lineNumber++) {
                var text = this._lines[lineNumber - 1].text;
                if (text.length >= 200) {
                    // This line is over 200 chars long, so warm up without it
                    toLineNumber = lineNumber - 1;
                    break;
                }
            }
            this._revalidateTokensNow(toLineNumber);
        };
        TextModelWithTokens.prototype._revalidateTokensNow = function (toLineNumber) {
            if (toLineNumber === void 0) { toLineNumber = this._invalidLineStartIndex + 1000000; }
            var t1 = timer.start(timer.Topic.EDITOR, 'backgroundTokenization');
            toLineNumber = Math.min(this._lines.length, toLineNumber);
            var MAX_ALLOWED_TIME = 20, fromLineNumber = this._invalidLineStartIndex + 1, tokenizedChars = 0, currentCharsToTokenize = 0, currentEstimatedTimeToTokenize = 0, sw = stopwatch_1.StopWatch.create(false), elapsedTime;
            // Tokenize at most 1000 lines. Estimate the tokenization speed per character and stop when:
            // - MAX_ALLOWED_TIME is reached
            // - tokenizing the next line would go above MAX_ALLOWED_TIME
            for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
                elapsedTime = sw.elapsed();
                if (elapsedTime > MAX_ALLOWED_TIME) {
                    // Stop if MAX_ALLOWED_TIME is reached
                    toLineNumber = lineNumber - 1;
                    break;
                }
                // Compute how many characters will be tokenized for this line
                currentCharsToTokenize = this._lines[lineNumber - 1].text.length;
                if (tokenizedChars > 0) {
                    // If we have enough history, estimate how long tokenizing this line would take
                    currentEstimatedTimeToTokenize = (elapsedTime / tokenizedChars) * currentCharsToTokenize;
                    if (elapsedTime + currentEstimatedTimeToTokenize > MAX_ALLOWED_TIME) {
                        // Tokenizing this line will go above MAX_ALLOWED_TIME
                        toLineNumber = lineNumber - 1;
                        break;
                    }
                }
                this._updateTokensUntilLine(lineNumber, false);
                tokenizedChars += currentCharsToTokenize;
            }
            elapsedTime = sw.elapsed();
            if (fromLineNumber <= toLineNumber) {
                this.emitModelTokensChangedEvent(fromLineNumber, toLineNumber);
            }
            if (this._invalidLineStartIndex < this._lines.length) {
                this._beginBackgroundTokenization();
            }
            t1.stop();
        };
        TextModelWithTokens.prototype.getStateBeforeLine = function (lineNumber) {
            this._updateTokensUntilLine(lineNumber - 1, true);
            return this._lines[lineNumber - 1].getState();
        };
        TextModelWithTokens.prototype.getStateAfterLine = function (lineNumber) {
            this._updateTokensUntilLine(lineNumber, true);
            return lineNumber < this._lines.length ? this._lines[lineNumber].getState() : this._lastState;
        };
        TextModelWithTokens.prototype._getLineModeTransitions = function (lineNumber) {
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            this._updateTokensUntilLine(lineNumber, true);
            return this._lines[lineNumber - 1].getModeTransitions(this._mode);
        };
        TextModelWithTokens.prototype._updateTokensUntilLine = function (lineNumber, emitEvents) {
            var linesLength = this._lines.length;
            var endLineIndex = lineNumber - 1;
            var stopLineTokenizationAfter = 1000000000; // 1 billion, if a line is so long, you have other trouble :).
            var fromLineNumber = this._invalidLineStartIndex + 1, toLineNumber = lineNumber;
            // Validate all states up to and including endLineIndex
            for (var lineIndex = this._invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {
                var endStateIndex = lineIndex + 1;
                var r = null;
                var text = this._lines[lineIndex].text;
                if (this._mode.tokenizationSupport) {
                    try {
                        // Tokenize only the first X characters
                        r = this._mode.tokenizationSupport.tokenize(this._lines[lineIndex].text, this._lines[lineIndex].getState(), 0, stopLineTokenizationAfter);
                    }
                    catch (e) {
                        e.friendlyMessage = TextModelWithTokens.MODE_TOKENIZATION_FAILED_MSG;
                        errors_1.onUnexpectedError(e);
                    }
                    if (r && r.retokenize) {
                        this._retokenizers.push(this._createRetokenizer(r.retokenize, lineIndex + 1));
                    }
                    if (r && r.tokens && r.tokens.length > 0) {
                        // Cannot have a stop offset before the last token
                        r.actualStopOffset = Math.max(r.actualStopOffset, r.tokens[r.tokens.length - 1].startIndex + 1);
                    }
                    if (r && r.actualStopOffset < text.length) {
                        // Treat the rest of the line (if above limit) as one default token
                        r.tokens.push({
                            startIndex: r.actualStopOffset,
                            type: ''
                        });
                        // Use as end state the starting state
                        r.endState = this._lines[lineIndex].getState();
                    }
                }
                if (!r) {
                    r = nullMode_1.nullTokenize(this._mode, text, this._lines[lineIndex].getState());
                }
                if (!r.modeTransitions) {
                    r.modeTransitions = [];
                }
                if (r.modeTransitions.length === 0) {
                    // Make sure there is at least the transition to the top-most mode
                    r.modeTransitions.push({
                        startIndex: 0,
                        mode: this._mode
                    });
                }
                this._updateLineTokens(lineIndex, this._tokensInflatorMap, this._mode, r);
                if (this._lines[lineIndex].isInvalid) {
                    this._lines[lineIndex].isInvalid = false;
                }
                if (endStateIndex < linesLength) {
                    if (this._lines[endStateIndex].getState() !== null && r.endState.equals(this._lines[endStateIndex].getState())) {
                        // The end state of this line remains the same
                        var nextInvalidLineIndex = lineIndex + 1;
                        while (nextInvalidLineIndex < linesLength) {
                            if (this._lines[nextInvalidLineIndex].isInvalid) {
                                break;
                            }
                            if (nextInvalidLineIndex + 1 < linesLength) {
                                if (this._lines[nextInvalidLineIndex + 1].getState() === null) {
                                    break;
                                }
                            }
                            else {
                                if (this._lastState === null) {
                                    break;
                                }
                            }
                            nextInvalidLineIndex++;
                        }
                        this._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, nextInvalidLineIndex);
                        lineIndex = nextInvalidLineIndex - 1; // -1 because the outer loop increments it
                    }
                    else {
                        this._lines[endStateIndex].setState(r.endState);
                    }
                }
                else {
                    this._lastState = r.endState;
                }
            }
            this._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, endLineIndex + 1);
            if (emitEvents && fromLineNumber <= toLineNumber) {
                this.emitModelTokensChangedEvent(fromLineNumber, toLineNumber);
            }
        };
        TextModelWithTokens.prototype.emitModelTokensChangedEvent = function (fromLineNumber, toLineNumber) {
            var e = {
                fromLineNumber: fromLineNumber,
                toLineNumber: toLineNumber
            };
            if (!this._isDisposing) {
                this.emit(editorCommon.EventType.ModelTokensChanged, e);
            }
        };
        TextModelWithTokens.prototype._emitModelModeChangedEvent = function (e) {
            if (!this._isDisposing) {
                this.emit(editorCommon.EventType.ModelModeChanged, e);
            }
        };
        TextModelWithTokens.prototype._emitModelModeSupportChangedEvent = function (e) {
            if (!this._isDisposing) {
                this.emit(editorCommon.EventType.ModelModeSupportChanged, e);
            }
        };
        // Having tokens allows implementing additional helper methods
        TextModelWithTokens.prototype._lineIsTokenized = function (lineNumber) {
            return this._invalidLineStartIndex > lineNumber - 1;
        };
        TextModelWithTokens.prototype._getWordDefinition = function () {
            return textModelWithTokensHelpers_1.WordHelper.massageWordDefinitionOf(this._mode);
        };
        TextModelWithTokens.prototype.getWordAtPosition = function (position) {
            return textModelWithTokensHelpers_1.WordHelper.getWordAtPosition(this, this.validatePosition(position));
        };
        TextModelWithTokens.prototype.getWordUntilPosition = function (position) {
            var wordAtPosition = this.getWordAtPosition(position);
            if (!wordAtPosition) {
                return {
                    word: '',
                    startColumn: position.column,
                    endColumn: position.column
                };
            }
            return {
                word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),
                startColumn: wordAtPosition.startColumn,
                endColumn: position.column
            };
        };
        TextModelWithTokens.prototype.tokenIterator = function (position, callback) {
            var iter = new tokenIterator_1.TokenIterator(this, this.validatePosition(position));
            var result = callback(iter);
            iter._invalidate();
            return result;
        };
        TextModelWithTokens.prototype.findMatchingBracketUp = function (bracket, _position) {
            var position = this.validatePosition(_position);
            var modeTransitions = this._lines[position.lineNumber - 1].getModeTransitions(this._mode);
            var currentModeIndex = modeTransition_1.ModeTransition.findIndexInSegmentsArray(modeTransitions, position.column - 1);
            var currentMode = modeTransitions[currentModeIndex];
            var currentModeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(currentMode.modeId);
            if (!currentModeBrackets) {
                return null;
            }
            var data = currentModeBrackets.textIsBracket[bracket];
            if (!data) {
                return null;
            }
            return this._findMatchingBracketUp(data, position);
        };
        TextModelWithTokens.prototype.matchBracket = function (position) {
            return this._matchBracket(this.validatePosition(position));
        };
        TextModelWithTokens.prototype._matchBracket = function (position) {
            var lineNumber = position.lineNumber;
            var lineText = this._lines[lineNumber - 1].text;
            var lineTokens = this._lines[lineNumber - 1].getTokens();
            var currentTokenIndex = lineTokens.findIndexOfOffset(position.column - 1);
            var currentTokenStart = lineTokens.getTokenStartIndex(currentTokenIndex);
            var modeTransitions = this._lines[lineNumber - 1].getModeTransitions(this._mode);
            var currentModeIndex = modeTransition_1.ModeTransition.findIndexInSegmentsArray(modeTransitions, position.column - 1);
            var currentMode = modeTransitions[currentModeIndex];
            var currentModeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(currentMode.modeId);
            // If position is in between two tokens, try first looking in the previous token
            if (currentTokenIndex > 0 && currentTokenStart === position.column - 1) {
                var prevTokenIndex = currentTokenIndex - 1;
                var prevTokenType = lineTokens.getTokenType(prevTokenIndex);
                // check that previous token is not to be ignored
                if (!supports_1.ignoreBracketsInToken(prevTokenType)) {
                    var prevTokenStart = lineTokens.getTokenStartIndex(prevTokenIndex);
                    var prevMode = currentMode;
                    var prevModeBrackets = currentModeBrackets;
                    // check if previous token is in a different mode
                    if (currentModeIndex > 0 && currentMode.startIndex === position.column - 1) {
                        prevMode = modeTransitions[currentModeIndex - 1];
                        prevModeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(prevMode.modeId);
                    }
                    if (prevModeBrackets) {
                        // limit search in case previous token is very large, there's no need to go beyond `maxBracketLength`
                        prevTokenStart = Math.max(prevTokenStart, position.column - 1 - prevModeBrackets.maxBracketLength);
                        var foundBracket = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(prevModeBrackets.reversedRegex, lineNumber, lineText, prevTokenStart, currentTokenStart);
                        // check that we didn't hit a bracket too far away from position
                        if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {
                            var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);
                            var r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText]);
                            // check that we can actually match this bracket
                            if (r) {
                                return r;
                            }
                        }
                    }
                }
            }
            // check that the token is not to be ignored
            if (!supports_1.ignoreBracketsInToken(lineTokens.getTokenType(currentTokenIndex))) {
                if (currentModeBrackets) {
                    // limit search to not go before `maxBracketLength`
                    currentTokenStart = Math.max(currentTokenStart, position.column - 1 - currentModeBrackets.maxBracketLength);
                    // limit search to not go after `maxBracketLength`
                    var currentTokenEnd = lineTokens.getTokenEndIndex(currentTokenIndex, lineText.length);
                    currentTokenEnd = Math.min(currentTokenEnd, position.column - 1 + currentModeBrackets.maxBracketLength);
                    // it might still be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets
                    while (true) {
                        var foundBracket = richEditBrackets_1.BracketsUtils.findNextBracketInText(currentModeBrackets.forwardRegex, lineNumber, lineText.substring(currentTokenStart, currentTokenEnd), currentTokenStart);
                        if (!foundBracket) {
                            // there are no brackets in this text
                            break;
                        }
                        // check that we didn't hit a bracket too far away from position
                        if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {
                            var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);
                            var r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText]);
                            // check that we can actually match this bracket
                            if (r) {
                                return r;
                            }
                        }
                        currentTokenStart = foundBracket.endColumn - 1;
                    }
                }
            }
            return null;
        };
        TextModelWithTokens.prototype._matchFoundBracket = function (foundBracket, data, isOpen) {
            if (isOpen) {
                var matched = this._findMatchingBracketDown(data, foundBracket.getEndPosition());
                if (matched) {
                    return [foundBracket, matched];
                }
            }
            else {
                var matched = this._findMatchingBracketUp(data, foundBracket.getStartPosition());
                if (matched) {
                    return [foundBracket, matched];
                }
            }
            return null;
        };
        TextModelWithTokens.prototype._findMatchingBracketUp = function (bracket, position) {
            // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));
            var modeId = bracket.modeId;
            var reversedBracketRegex = bracket.reversedRegex;
            var count = -1;
            for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
                var lineTokens = this._lines[lineNumber - 1].getTokens();
                var lineText = this._lines[lineNumber - 1].text;
                var modeTransitions = this._lines[lineNumber - 1].getModeTransitions(this._mode);
                var currentModeIndex = modeTransitions.length - 1;
                var currentModeStart = modeTransitions[currentModeIndex].startIndex;
                var currentModeId = modeTransitions[currentModeIndex].modeId;
                var tokensLength = lineTokens.getTokenCount() - 1;
                var currentTokenEnd = lineText.length;
                if (lineNumber === position.lineNumber) {
                    tokensLength = lineTokens.findIndexOfOffset(position.column - 1);
                    currentTokenEnd = position.column - 1;
                    currentModeIndex = modeTransition_1.ModeTransition.findIndexInSegmentsArray(modeTransitions, position.column - 1);
                    currentModeStart = modeTransitions[currentModeIndex].startIndex;
                    currentModeId = modeTransitions[currentModeIndex].modeId;
                }
                for (var tokenIndex = tokensLength; tokenIndex >= 0; tokenIndex--) {
                    var currentTokenType = lineTokens.getTokenType(tokenIndex);
                    var currentTokenStart = lineTokens.getTokenStartIndex(tokenIndex);
                    if (currentTokenStart < currentModeStart) {
                        currentModeIndex--;
                        currentModeStart = modeTransitions[currentModeIndex].startIndex;
                        currentModeId = modeTransitions[currentModeIndex].modeId;
                    }
                    if (currentModeId === modeId && !supports_1.ignoreBracketsInToken(currentTokenType)) {
                        while (true) {
                            var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(reversedBracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd);
                            if (!r) {
                                break;
                            }
                            var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);
                            if (hitText === bracket.open) {
                                count++;
                            }
                            else if (hitText === bracket.close) {
                                count--;
                            }
                            if (count === 0) {
                                return r;
                            }
                            currentTokenEnd = r.startColumn - 1;
                        }
                    }
                    currentTokenEnd = currentTokenStart;
                }
            }
            return null;
        };
        TextModelWithTokens.prototype._findMatchingBracketDown = function (bracket, position) {
            // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));
            var modeId = bracket.modeId;
            var bracketRegex = bracket.forwardRegex;
            var count = 1;
            for (var lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {
                var lineTokens = this._lines[lineNumber - 1].getTokens();
                var lineText = this._lines[lineNumber - 1].text;
                var modeTransitions = this._lines[lineNumber - 1].getModeTransitions(this._mode);
                var currentModeIndex = 0;
                var nextModeStart = (currentModeIndex + 1 < modeTransitions.length ? modeTransitions[currentModeIndex + 1].startIndex : lineText.length + 1);
                var currentModeId = modeTransitions[currentModeIndex].modeId;
                var startTokenIndex = 0;
                var currentTokenStart = lineTokens.getTokenStartIndex(startTokenIndex);
                if (lineNumber === position.lineNumber) {
                    startTokenIndex = lineTokens.findIndexOfOffset(position.column - 1);
                    currentTokenStart = Math.max(currentTokenStart, position.column - 1);
                    currentModeIndex = modeTransition_1.ModeTransition.findIndexInSegmentsArray(modeTransitions, position.column - 1);
                    nextModeStart = (currentModeIndex + 1 < modeTransitions.length ? modeTransitions[currentModeIndex + 1].startIndex : lineText.length + 1);
                    currentModeId = modeTransitions[currentModeIndex].modeId;
                }
                for (var tokenIndex = startTokenIndex, tokensLength = lineTokens.getTokenCount(); tokenIndex < tokensLength; tokenIndex++) {
                    var currentTokenType = lineTokens.getTokenType(tokenIndex);
                    var currentTokenEnd = lineTokens.getTokenEndIndex(tokenIndex, lineText.length);
                    if (currentTokenStart >= nextModeStart) {
                        currentModeIndex++;
                        nextModeStart = (currentModeIndex + 1 < modeTransitions.length ? modeTransitions[currentModeIndex + 1].startIndex : lineText.length + 1);
                        currentModeId = modeTransitions[currentModeIndex].modeId;
                    }
                    if (currentModeId === modeId && !supports_1.ignoreBracketsInToken(currentTokenType)) {
                        while (true) {
                            var r = richEditBrackets_1.BracketsUtils.findNextBracketInToken(bracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd);
                            if (!r) {
                                break;
                            }
                            var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);
                            if (hitText === bracket.open) {
                                count++;
                            }
                            else if (hitText === bracket.close) {
                                count--;
                            }
                            if (count === 0) {
                                return r;
                            }
                            currentTokenStart = r.endColumn - 1;
                        }
                    }
                    currentTokenStart = currentTokenEnd;
                }
            }
            return null;
        };
        TextModelWithTokens.prototype.findPrevBracket = function (_position) {
            var position = this.validatePosition(_position);
            var reversedBracketRegex = /[\(\)\[\]\{\}]/; // TODO@Alex: use mode's brackets
            for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
                var lineTokens = this._lines[lineNumber - 1].getTokens();
                var lineText = this._lines[lineNumber - 1].text;
                var tokensLength = lineTokens.getTokenCount() - 1;
                var currentTokenEnd = lineText.length;
                if (lineNumber === position.lineNumber) {
                    tokensLength = lineTokens.findIndexOfOffset(position.column - 1);
                    currentTokenEnd = position.column - 1;
                }
                for (var tokenIndex = tokensLength; tokenIndex >= 0; tokenIndex--) {
                    var currentTokenType = lineTokens.getTokenType(tokenIndex);
                    var currentTokenStart = lineTokens.getTokenStartIndex(tokenIndex);
                    if (!supports_1.ignoreBracketsInToken(currentTokenType)) {
                        var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(reversedBracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd);
                        if (r) {
                            return this._toFoundBracket(r);
                        }
                    }
                    currentTokenEnd = currentTokenStart;
                }
            }
            return null;
        };
        TextModelWithTokens.prototype.findNextBracket = function (_position) {
            var position = this.validatePosition(_position);
            var bracketRegex = /[\(\)\[\]\{\}]/; // TODO@Alex: use mode's brackets
            for (var lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {
                var lineTokens = this._lines[lineNumber - 1].getTokens();
                var lineText = this._lines[lineNumber - 1].text;
                var startTokenIndex = 0;
                var currentTokenStart = lineTokens.getTokenStartIndex(startTokenIndex);
                if (lineNumber === position.lineNumber) {
                    startTokenIndex = lineTokens.findIndexOfOffset(position.column - 1);
                    currentTokenStart = Math.max(currentTokenStart, position.column - 1);
                }
                for (var tokenIndex = startTokenIndex, tokensLength = lineTokens.getTokenCount(); tokenIndex < tokensLength; tokenIndex++) {
                    var currentTokenType = lineTokens.getTokenType(tokenIndex);
                    var currentTokenEnd = lineTokens.getTokenEndIndex(tokenIndex, lineText.length);
                    if (!supports_1.ignoreBracketsInToken(currentTokenType)) {
                        var r = richEditBrackets_1.BracketsUtils.findNextBracketInToken(bracketRegex, lineNumber, lineText, currentTokenStart, currentTokenEnd);
                        if (r) {
                            return this._toFoundBracket(r);
                        }
                    }
                    currentTokenStart = currentTokenEnd;
                }
            }
            return null;
        };
        TextModelWithTokens.prototype._toFoundBracket = function (r) {
            if (!r) {
                return null;
            }
            var text = this.getValueInRange(r);
            // TODO@Alex: use mode's brackets
            switch (text) {
                case '(': return { range: r, open: '(', close: ')', isOpen: true };
                case ')': return { range: r, open: '(', close: ')', isOpen: false };
                case '[': return { range: r, open: '[', close: ']', isOpen: true };
                case ']': return { range: r, open: '[', close: ']', isOpen: false };
                case '{': return { range: r, open: '{', close: '}', isOpen: true };
                case '}': return { range: r, open: '{', close: '}', isOpen: false };
            }
            return null;
        };
        TextModelWithTokens.MODE_TOKENIZATION_FAILED_MSG = nls.localize(0, null);
        return TextModelWithTokens;
    }(textModel_1.TextModel));
    exports.TextModelWithTokens = TextModelWithTokens;
});






define(__m[311], __M([0,1,63,21,180]), function (require, exports, idGenerator_1, position_1, textModelWithTokens_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LineMarker = (function () {
        function LineMarker(id, column, stickToPreviousCharacter) {
            this.id = id;
            this.column = column;
            this.stickToPreviousCharacter = stickToPreviousCharacter;
            this.oldLineNumber = 0;
            this.oldColumn = 0;
            this.line = null;
        }
        LineMarker.prototype.toString = function () {
            return '{\'' + this.id + '\';' + this.column + ',' + this.stickToPreviousCharacter + ',[' + this.oldLineNumber + ',' + this.oldColumn + ']}';
        };
        return LineMarker;
    }());
    exports.LineMarker = LineMarker;
    var _INSTANCE_COUNT = 0;
    var TextModelWithMarkers = (function (_super) {
        __extends(TextModelWithMarkers, _super);
        function TextModelWithMarkers(allowedEventTypes, rawText, modeOrPromise) {
            _super.call(this, allowedEventTypes, rawText, true, modeOrPromise);
            this._markerIdGenerator = new idGenerator_1.IdGenerator((++_INSTANCE_COUNT) + ';');
            this._markerIdToMarker = {};
        }
        TextModelWithMarkers.prototype.dispose = function () {
            this._markerIdToMarker = null;
            _super.prototype.dispose.call(this);
        };
        TextModelWithMarkers.prototype._resetValue = function (e, newValue) {
            _super.prototype._resetValue.call(this, e, newValue);
            // Destroy all my markers
            this._markerIdToMarker = {};
        };
        TextModelWithMarkers.prototype._addMarker = function (lineNumber, column, stickToPreviousCharacter) {
            var pos = this.validatePosition(new position_1.Position(lineNumber, column));
            var marker = new LineMarker(this._markerIdGenerator.nextId(), pos.column, stickToPreviousCharacter);
            this._markerIdToMarker[marker.id] = marker;
            this._lines[pos.lineNumber - 1].addMarker(marker);
            return marker.id;
        };
        TextModelWithMarkers.prototype._addMarkers = function (newMarkers) {
            var addMarkersPerLine = Object.create(null);
            var result = [];
            for (var i = 0, len = newMarkers.length; i < len; i++) {
                var newMarker = newMarkers[i];
                var marker = new LineMarker(this._markerIdGenerator.nextId(), newMarker.column, newMarker.stickToPreviousCharacter);
                this._markerIdToMarker[marker.id] = marker;
                if (!addMarkersPerLine[newMarker.lineNumber]) {
                    addMarkersPerLine[newMarker.lineNumber] = [];
                }
                addMarkersPerLine[newMarker.lineNumber].push(marker);
                result.push(marker.id);
            }
            var lineNumbers = Object.keys(addMarkersPerLine);
            for (var i = 0, len = lineNumbers.length; i < len; i++) {
                var lineNumber = parseInt(lineNumbers[i], 10);
                this._lines[lineNumber - 1].addMarkers(addMarkersPerLine[lineNumbers[i]]);
            }
            return result;
        };
        TextModelWithMarkers.prototype._changeMarker = function (id, lineNumber, column) {
            if (this._markerIdToMarker.hasOwnProperty(id)) {
                var marker = this._markerIdToMarker[id];
                var newPos = this.validatePosition(new position_1.Position(lineNumber, column));
                if (newPos.lineNumber !== marker.line.lineNumber) {
                    // Move marker between lines
                    marker.line.removeMarker(marker);
                    this._lines[newPos.lineNumber - 1].addMarker(marker);
                }
                // Update marker column
                marker.column = newPos.column;
            }
        };
        TextModelWithMarkers.prototype._changeMarkerStickiness = function (id, newStickToPreviousCharacter) {
            if (this._markerIdToMarker.hasOwnProperty(id)) {
                var marker = this._markerIdToMarker[id];
                if (marker.stickToPreviousCharacter !== newStickToPreviousCharacter) {
                    marker.stickToPreviousCharacter = newStickToPreviousCharacter;
                }
            }
        };
        TextModelWithMarkers.prototype._getMarker = function (id) {
            if (this._markerIdToMarker.hasOwnProperty(id)) {
                var marker = this._markerIdToMarker[id];
                return new position_1.Position(marker.line.lineNumber, marker.column);
            }
            return null;
        };
        TextModelWithMarkers.prototype._getMarkersCount = function () {
            return Object.keys(this._markerIdToMarker).length;
        };
        TextModelWithMarkers.prototype._getLineMarkers = function (lineNumber) {
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
            }
            return this._lines[lineNumber - 1].getMarkers();
        };
        TextModelWithMarkers.prototype._removeMarker = function (id) {
            if (this._markerIdToMarker.hasOwnProperty(id)) {
                var marker = this._markerIdToMarker[id];
                marker.line.removeMarker(marker);
                delete this._markerIdToMarker[id];
            }
        };
        TextModelWithMarkers.prototype._removeMarkers = function (ids) {
            var removeMarkersPerLine = Object.create(null);
            for (var i = 0, len = ids.length; i < len; i++) {
                var id = ids[i];
                if (!this._markerIdToMarker.hasOwnProperty(id)) {
                    continue;
                }
                var marker = this._markerIdToMarker[id];
                var lineNumber = marker.line.lineNumber;
                if (!removeMarkersPerLine[lineNumber]) {
                    removeMarkersPerLine[lineNumber] = Object.create(null);
                }
                removeMarkersPerLine[lineNumber][id] = true;
                delete this._markerIdToMarker[id];
            }
            var lineNumbers = Object.keys(removeMarkersPerLine);
            for (var i = 0, len = lineNumbers.length; i < len; i++) {
                var lineNumber = parseInt(lineNumbers[i], 10);
                this._lines[lineNumber - 1].removeMarkers(removeMarkersPerLine[lineNumbers[i]]);
            }
        };
        TextModelWithMarkers.prototype._getMarkersInMap = function (markersMap) {
            var result = [];
            var keys = Object.keys(markersMap);
            for (var i = 0, len = keys.length; i < len; i++) {
                var markerId = keys[i];
                if (this._markerIdToMarker.hasOwnProperty(markerId)) {
                    result.push(this._markerIdToMarker[markerId]);
                }
            }
            return result;
        };
        return TextModelWithMarkers;
    }(textModelWithTokens_1.TextModelWithTokens));
    exports.TextModelWithMarkers = TextModelWithMarkers;
});






define(__m[312], __M([0,1,63,4,7,311,180]), function (require, exports, idGenerator_1, range_1, editorCommon, textModelWithMarkers_1, textModelWithTokens_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var TrackedRangeModelRetokenizer = (function (_super) {
        __extends(TrackedRangeModelRetokenizer, _super);
        function TrackedRangeModelRetokenizer(retokenizePromise, lineNumber, model) {
            _super.call(this, retokenizePromise, model);
            this.trackedRangeId = model.addTrackedRange({
                startLineNumber: lineNumber,
                startColumn: 1,
                endLineNumber: lineNumber,
                endColumn: model.getLineMaxColumn(lineNumber)
            }, editorCommon.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);
        }
        TrackedRangeModelRetokenizer.prototype.getRange = function () {
            return this._model.getTrackedRange(this.trackedRangeId);
        };
        TrackedRangeModelRetokenizer.prototype.dispose = function () {
            var model = this._model;
            // if this .dispose() is being called as part of the model.dispose(), then the tracked ranges might no longer be available (e.g. throw exceptions)
            if (model.isValidTrackedRange(this.trackedRangeId)) {
                model.removeTrackedRange(this.trackedRangeId);
            }
            _super.prototype.dispose.call(this);
        };
        return TrackedRangeModelRetokenizer;
    }(textModelWithTokens_1.FullModelRetokenizer));
    var TrackedRange = (function () {
        function TrackedRange(id, startMarkedId, endMarkerId) {
            this.id = id;
            this.startMarkerId = startMarkedId;
            this.endMarkerId = endMarkerId;
        }
        return TrackedRange;
    }());
    var _INSTANCE_COUNT = 0;
    var TextModelWithTrackedRanges = (function (_super) {
        __extends(TextModelWithTrackedRanges, _super);
        function TextModelWithTrackedRanges(allowedEventTypes, rawText, modeOrPromise) {
            _super.call(this, allowedEventTypes, rawText, modeOrPromise);
            this._rangeIdGenerator = new idGenerator_1.IdGenerator((++_INSTANCE_COUNT) + ';');
            this._ranges = {};
            this._markerIdToRangeId = {};
            this._multiLineTrackedRanges = {};
        }
        TextModelWithTrackedRanges.prototype._createRetokenizer = function (retokenizePromise, lineNumber) {
            return new TrackedRangeModelRetokenizer(retokenizePromise, lineNumber, this);
        };
        TextModelWithTrackedRanges.prototype.dispose = function () {
            this._ranges = null;
            this._markerIdToRangeId = null;
            this._multiLineTrackedRanges = null;
            _super.prototype.dispose.call(this);
        };
        TextModelWithTrackedRanges.prototype._resetValue = function (e, newValue) {
            _super.prototype._resetValue.call(this, e, newValue);
            // Destroy all my tracked ranges
            this._ranges = {};
            this._markerIdToRangeId = {};
            this._multiLineTrackedRanges = {};
        };
        TextModelWithTrackedRanges.prototype._setRangeIsMultiLine = function (rangeId, rangeIsMultiLine) {
            var rangeWasMultiLine = this._multiLineTrackedRanges.hasOwnProperty(rangeId);
            if (!rangeWasMultiLine && rangeIsMultiLine) {
                this._multiLineTrackedRanges[rangeId] = true;
            }
            else if (rangeWasMultiLine && !rangeIsMultiLine) {
                delete this._multiLineTrackedRanges[rangeId];
            }
        };
        TextModelWithTrackedRanges.prototype._shouldStartMarkerSticksToPreviousCharacter = function (stickiness) {
            if (stickiness === editorCommon.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges || stickiness === editorCommon.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore) {
                return true;
            }
            return false;
        };
        TextModelWithTrackedRanges.prototype._shouldEndMarkerSticksToPreviousCharacter = function (stickiness) {
            if (stickiness === editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges || stickiness === editorCommon.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore) {
                return true;
            }
            return false;
        };
        TextModelWithTrackedRanges.prototype._getTrackedRangesCount = function () {
            return Object.keys(this._ranges).length;
        };
        TextModelWithTrackedRanges.prototype.addTrackedRange = function (textRange, stickiness) {
            textRange = this.validateRange(textRange);
            var startMarkerSticksToPreviousCharacter = this._shouldStartMarkerSticksToPreviousCharacter(stickiness);
            var endMarkerSticksToPreviousCharacter = this._shouldEndMarkerSticksToPreviousCharacter(stickiness);
            var startMarkerId = this._addMarker(textRange.startLineNumber, textRange.startColumn, startMarkerSticksToPreviousCharacter);
            var endMarkerId = this._addMarker(textRange.endLineNumber, textRange.endColumn, endMarkerSticksToPreviousCharacter);
            var range = new TrackedRange(this._rangeIdGenerator.nextId(), startMarkerId, endMarkerId);
            this._ranges[range.id] = range;
            this._markerIdToRangeId[startMarkerId] = range.id;
            this._markerIdToRangeId[endMarkerId] = range.id;
            this._setRangeIsMultiLine(range.id, (textRange.startLineNumber !== textRange.endLineNumber));
            return range.id;
        };
        TextModelWithTrackedRanges.prototype._addTrackedRanges = function (textRanges, stickinessArr) {
            var addMarkers = [];
            for (var i = 0, len = textRanges.length; i < len; i++) {
                var textRange = textRanges[i];
                var stickiness = stickinessArr[i];
                addMarkers.push({
                    lineNumber: textRange.startLineNumber,
                    column: textRange.startColumn,
                    stickToPreviousCharacter: this._shouldStartMarkerSticksToPreviousCharacter(stickiness)
                });
                addMarkers.push({
                    lineNumber: textRange.endLineNumber,
                    column: textRange.endColumn,
                    stickToPreviousCharacter: this._shouldEndMarkerSticksToPreviousCharacter(stickiness)
                });
            }
            var markerIds = this._addMarkers(addMarkers);
            var result = [];
            for (var i = 0, len = textRanges.length; i < len; i++) {
                var textRange = textRanges[i];
                var startMarkerId = markerIds[2 * i];
                var endMarkerId = markerIds[2 * i + 1];
                var range = new TrackedRange(this._rangeIdGenerator.nextId(), startMarkerId, endMarkerId);
                this._ranges[range.id] = range;
                this._markerIdToRangeId[startMarkerId] = range.id;
                this._markerIdToRangeId[endMarkerId] = range.id;
                this._setRangeIsMultiLine(range.id, (textRange.startLineNumber !== textRange.endLineNumber));
                result.push(range.id);
            }
            return result;
        };
        TextModelWithTrackedRanges.prototype.changeTrackedRange = function (rangeId, newTextRange) {
            if (this._ranges.hasOwnProperty(rangeId)) {
                newTextRange = this.validateRange(newTextRange);
                var range = this._ranges[rangeId];
                this._changeMarker(range.startMarkerId, newTextRange.startLineNumber, newTextRange.startColumn);
                this._changeMarker(range.endMarkerId, newTextRange.endLineNumber, newTextRange.endColumn);
                this._setRangeIsMultiLine(range.id, (newTextRange.startLineNumber !== newTextRange.endLineNumber));
            }
        };
        TextModelWithTrackedRanges.prototype.changeTrackedRangeStickiness = function (rangeId, newStickiness) {
            if (this._ranges.hasOwnProperty(rangeId)) {
                var range = this._ranges[rangeId];
                this._changeMarkerStickiness(range.startMarkerId, this._shouldStartMarkerSticksToPreviousCharacter(newStickiness));
                this._changeMarkerStickiness(range.endMarkerId, this._shouldEndMarkerSticksToPreviousCharacter(newStickiness));
            }
        };
        TextModelWithTrackedRanges.prototype.isValidTrackedRange = function (rangeId) {
            if (this._isDisposed || !this._ranges) {
                return false;
            }
            return this._ranges.hasOwnProperty(rangeId);
        };
        TextModelWithTrackedRanges.prototype.removeTrackedRange = function (rangeId) {
            if (this._ranges.hasOwnProperty(rangeId)) {
                var range = this._ranges[rangeId];
                this._removeMarker(range.startMarkerId);
                this._removeMarker(range.endMarkerId);
                this._setRangeIsMultiLine(range.id, false);
                delete this._ranges[range.id];
                delete this._markerIdToRangeId[range.startMarkerId];
                delete this._markerIdToRangeId[range.endMarkerId];
            }
        };
        TextModelWithTrackedRanges.prototype.removeTrackedRanges = function (ids) {
            var removeMarkers = [];
            for (var i = 0, len = ids.length; i < len; i++) {
                var rangeId = ids[i];
                if (!this._ranges.hasOwnProperty(rangeId)) {
                    continue;
                }
                var range = this._ranges[rangeId];
                removeMarkers.push(range.startMarkerId);
                removeMarkers.push(range.endMarkerId);
                this._setRangeIsMultiLine(range.id, false);
                delete this._ranges[range.id];
                delete this._markerIdToRangeId[range.startMarkerId];
                delete this._markerIdToRangeId[range.endMarkerId];
            }
            if (removeMarkers.length > 0) {
                this._removeMarkers(removeMarkers);
            }
        };
        TextModelWithTrackedRanges.prototype._newEditorRange = function (startPosition, endPosition) {
            if (endPosition.isBefore(startPosition)) {
                // This tracked range has turned in on itself (end marker before start marker)
                // This can happen in extreme editing conditions where lots of text is removed and lots is added
                // Treat it as a collapsed range
                return new range_1.Range(startPosition.lineNumber, startPosition.column, startPosition.lineNumber, startPosition.column);
            }
            return new range_1.Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);
        };
        TextModelWithTrackedRanges.prototype.getTrackedRange = function (rangeId) {
            var range = this._ranges[rangeId];
            var startMarker = this._getMarker(range.startMarkerId);
            var endMarker = this._getMarker(range.endMarkerId);
            return this._newEditorRange(startMarker, endMarker);
        };
        /**
         * Fetch only multi-line ranges that intersect with the given line number range
         */
        TextModelWithTrackedRanges.prototype._getMultiLineTrackedRanges = function (filterStartLineNumber, filterEndLineNumber) {
            var result = [];
            var keys = Object.keys(this._multiLineTrackedRanges);
            for (var i = 0, len = keys.length; i < len; i++) {
                var rangeId = keys[i];
                var range = this._ranges[rangeId];
                var startMarker = this._getMarker(range.startMarkerId);
                if (startMarker.lineNumber > filterEndLineNumber) {
                    continue;
                }
                var endMarker = this._getMarker(range.endMarkerId);
                if (endMarker.lineNumber < filterStartLineNumber) {
                    continue;
                }
                result.push({
                    id: range.id,
                    range: this._newEditorRange(startMarker, endMarker)
                });
            }
            return result;
        };
        TextModelWithTrackedRanges.prototype.getLinesTrackedRanges = function (startLineNumber, endLineNumber) {
            var result = this._getMultiLineTrackedRanges(startLineNumber, endLineNumber), resultMap = {}, lineMarkers, lineMarker, rangeId, i, len, lineNumber, startMarker, endMarker;
            for (i = 0, len = result.length; i < len; i++) {
                resultMap[result[i].id] = true;
            }
            for (lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {
                lineMarkers = this._getLineMarkers(lineNumber);
                for (i = 0, len = lineMarkers.length; i < len; i++) {
                    lineMarker = lineMarkers[i];
                    if (this._markerIdToRangeId.hasOwnProperty(lineMarker.id)) {
                        rangeId = this._markerIdToRangeId[lineMarker.id];
                        if (!resultMap.hasOwnProperty(rangeId)) {
                            startMarker = this._getMarker(this._ranges[rangeId].startMarkerId);
                            endMarker = this._getMarker(this._ranges[rangeId].endMarkerId);
                            result.push({
                                id: rangeId,
                                range: this._newEditorRange(startMarker, endMarker)
                            });
                            resultMap[rangeId] = true;
                        }
                    }
                }
            }
            return result;
        };
        TextModelWithTrackedRanges.prototype._onChangedMarkers = function (changedMarkers) {
            var changedRanges = {}, changedRange, range, rangeId, marker, i, len;
            for (i = 0, len = changedMarkers.length; i < len; i++) {
                marker = changedMarkers[i];
                if (this._markerIdToRangeId.hasOwnProperty(marker.id)) {
                    rangeId = this._markerIdToRangeId[marker.id];
                    range = this._ranges[rangeId];
                    if (changedRanges.hasOwnProperty(range.id)) {
                        changedRange = changedRanges[range.id];
                    }
                    else {
                        changedRange = {
                            startLineNumber: 0,
                            startColumn: 0,
                            endLineNumber: 0,
                            endColumn: 0
                        };
                        changedRanges[range.id] = changedRange;
                    }
                    if (marker.id === range.startMarkerId) {
                        changedRange.startLineNumber = marker.oldLineNumber;
                        changedRange.startColumn = marker.oldColumn;
                    }
                    else {
                        changedRange.endLineNumber = marker.oldLineNumber;
                        changedRange.endColumn = marker.oldColumn;
                    }
                    this._setRangeIsMultiLine(range.id, (this._getMarker(range.startMarkerId).lineNumber !== this._getMarker(range.endMarkerId).lineNumber));
                }
            }
            return changedRanges;
        };
        return TextModelWithTrackedRanges;
    }(textModelWithMarkers_1.TextModelWithMarkers));
    exports.TextModelWithTrackedRanges = TextModelWithTrackedRanges;
});






define(__m[313], __M([0,1,8,92,10,63,4,7,312]), function (require, exports, errors_1, htmlContent_1, strings, idGenerator_1, range_1, editorCommon, textModelWithTrackedRanges_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var DeferredEventsBuilder = (function () {
        function DeferredEventsBuilder() {
            this.changedMarkers = {};
            this.oldDecorationRange = {};
            this.oldDecorationOptions = {};
            this.newOrChangedDecorations = {};
            this.removedDecorations = {};
        }
        // --- Build decoration events
        DeferredEventsBuilder.prototype.addNewDecoration = function (id) {
            this.newOrChangedDecorations[id] = true;
        };
        DeferredEventsBuilder.prototype.addRemovedDecoration = function (id, ownerId, range, options) {
            if (this.newOrChangedDecorations.hasOwnProperty(id)) {
                delete this.newOrChangedDecorations[id];
            }
            if (!this.oldDecorationRange.hasOwnProperty(id)) {
                this.oldDecorationRange[id] = range;
            }
            if (!this.oldDecorationOptions.hasOwnProperty(id)) {
                this.oldDecorationOptions[id] = options;
            }
            this.removedDecorations[id] = true;
        };
        DeferredEventsBuilder.prototype.addMovedDecoration = function (id, oldRange) {
            if (!this.oldDecorationRange.hasOwnProperty(id)) {
                this.oldDecorationRange[id] = oldRange;
            }
            this.newOrChangedDecorations[id] = true;
        };
        DeferredEventsBuilder.prototype.addUpdatedDecoration = function (id, oldOptions) {
            if (!this.oldDecorationOptions.hasOwnProperty(id)) {
                this.oldDecorationOptions[id] = oldOptions;
            }
            this.newOrChangedDecorations[id] = true;
        };
        return DeferredEventsBuilder;
    }());
    exports.DeferredEventsBuilder = DeferredEventsBuilder;
    var _INSTANCE_COUNT = 0;
    var TextModelWithDecorations = (function (_super) {
        __extends(TextModelWithDecorations, _super);
        function TextModelWithDecorations(allowedEventTypes, rawText, modeOrPromise) {
            allowedEventTypes.push(editorCommon.EventType.ModelDecorationsChanged);
            _super.call(this, allowedEventTypes, rawText, modeOrPromise);
            // Initialize decorations
            this._decorationIdGenerator = new idGenerator_1.IdGenerator((++_INSTANCE_COUNT) + ';');
            this.decorations = {};
            this.rangeIdToDecorationId = {};
            this._currentDeferredEvents = null;
        }
        TextModelWithDecorations.prototype.dispose = function () {
            this.decorations = null;
            this.rangeIdToDecorationId = null;
            _super.prototype.dispose.call(this);
        };
        TextModelWithDecorations.prototype._resetValue = function (e, newValue) {
            _super.prototype._resetValue.call(this, e, newValue);
            // Destroy all my decorations
            this.decorations = {};
            this.rangeIdToDecorationId = {};
        };
        TextModelWithDecorations.prototype.changeDecorations = function (callback, ownerId) {
            var _this = this;
            if (ownerId === void 0) { ownerId = 0; }
            return this._withDeferredEvents(function (deferredEventsBuilder) {
                var changeAccessor = {
                    addDecoration: function (range, options) {
                        return _this._addDecorationImpl(deferredEventsBuilder, ownerId, _this.validateRange(range), _normalizeOptions(options));
                    },
                    changeDecoration: function (id, newRange) {
                        _this._changeDecorationImpl(deferredEventsBuilder, id, _this.validateRange(newRange));
                    },
                    changeDecorationOptions: function (id, options) {
                        _this._changeDecorationOptionsImpl(deferredEventsBuilder, id, _normalizeOptions(options));
                    },
                    removeDecoration: function (id) {
                        _this._removeDecorationImpl(deferredEventsBuilder, id);
                    },
                    deltaDecorations: function (oldDecorations, newDecorations) {
                        return _this._deltaDecorationsImpl(deferredEventsBuilder, ownerId, oldDecorations, _this._normalizeDeltaDecorations(newDecorations));
                    }
                };
                var result = null;
                try {
                    result = callback(changeAccessor);
                }
                catch (e) {
                    errors_1.onUnexpectedError(e);
                }
                // Invalidate change accessor
                changeAccessor.addDecoration = null;
                changeAccessor.changeDecoration = null;
                changeAccessor.removeDecoration = null;
                changeAccessor.deltaDecorations = null;
                return result;
            });
        };
        TextModelWithDecorations.prototype.deltaDecorations = function (oldDecorations, newDecorations, ownerId) {
            if (ownerId === void 0) { ownerId = 0; }
            if (!oldDecorations) {
                oldDecorations = [];
            }
            return this.changeDecorations(function (changeAccessor) {
                return changeAccessor.deltaDecorations(oldDecorations, newDecorations);
            }, ownerId);
        };
        TextModelWithDecorations.prototype.removeAllDecorationsWithOwnerId = function (ownerId) {
            var toRemove = [];
            var keys = Object.keys(this.decorations);
            for (var i = 0, len = keys.length; i < len; i++) {
                var decorationId = keys[i];
                var decoration = this.decorations[decorationId];
                if (decoration.ownerId === ownerId) {
                    toRemove.push(decoration.id);
                }
            }
            this._removeDecorationsImpl(null, toRemove);
        };
        TextModelWithDecorations.prototype.getDecorationOptions = function (decorationId) {
            if (this.decorations.hasOwnProperty(decorationId)) {
                return this.decorations[decorationId].options;
            }
            return null;
        };
        TextModelWithDecorations.prototype.getDecorationRange = function (decorationId) {
            if (this.decorations.hasOwnProperty(decorationId)) {
                var decoration = this.decorations[decorationId];
                return this.getTrackedRange(decoration.rangeId);
            }
            return null;
        };
        TextModelWithDecorations.prototype.getLineDecorations = function (lineNumber, ownerId, filterOutValidation) {
            if (ownerId === void 0) { ownerId = 0; }
            if (filterOutValidation === void 0) { filterOutValidation = false; }
            if (lineNumber < 1 || lineNumber > this.getLineCount()) {
                return [];
            }
            return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);
        };
        TextModelWithDecorations.prototype._getDecorationsInRange = function (startLineNumber, startColumn, endLineNumber, endColumn, ownerId, filterOutValidation) {
            var result = [], decoration, lineRanges = this.getLinesTrackedRanges(startLineNumber, endLineNumber), i, lineRange, len;
            for (i = 0, len = lineRanges.length; i < len; i++) {
                lineRange = lineRanges[i];
                // Look at line range only if there is a corresponding decoration for it
                if (this.rangeIdToDecorationId.hasOwnProperty(lineRange.id)) {
                    decoration = this.decorations[this.rangeIdToDecorationId[lineRange.id]];
                    if (ownerId && decoration.ownerId && decoration.ownerId !== ownerId) {
                        continue;
                    }
                    if (filterOutValidation) {
                        if (decoration.options.className === editorCommon.ClassName.EditorErrorDecoration || decoration.options.className === editorCommon.ClassName.EditorWarningDecoration) {
                            continue;
                        }
                    }
                    if (lineRange.range.startLineNumber === startLineNumber && lineRange.range.endColumn < startColumn) {
                        continue;
                    }
                    if (lineRange.range.endLineNumber === endLineNumber && lineRange.range.startColumn > endColumn) {
                        continue;
                    }
                    result.push({
                        id: decoration.id,
                        ownerId: decoration.ownerId,
                        range: lineRange.range,
                        options: decoration.options
                    });
                }
            }
            return result;
        };
        TextModelWithDecorations.prototype.getLinesDecorations = function (startLineNumber, endLineNumber, ownerId, filterOutValidation) {
            if (ownerId === void 0) { ownerId = 0; }
            if (filterOutValidation === void 0) { filterOutValidation = false; }
            var lineCount = this.getLineCount();
            startLineNumber = Math.min(lineCount, Math.max(1, startLineNumber));
            endLineNumber = Math.min(lineCount, Math.max(1, endLineNumber));
            return this._getDecorationsInRange(startLineNumber, 1, endLineNumber, Number.MAX_VALUE, ownerId, filterOutValidation);
        };
        TextModelWithDecorations.prototype.getDecorationsInRange = function (range, ownerId, filterOutValidation) {
            var validatedRange = this.validateRange(range);
            return this._getDecorationsInRange(validatedRange.startLineNumber, validatedRange.startColumn, validatedRange.endLineNumber, validatedRange.endColumn, ownerId, filterOutValidation);
        };
        TextModelWithDecorations.prototype.getAllDecorations = function (ownerId, filterOutValidation) {
            if (ownerId === void 0) { ownerId = 0; }
            if (filterOutValidation === void 0) { filterOutValidation = false; }
            var result = [];
            var keys = Object.keys(this.decorations);
            for (var i = 0, len = keys.length; i < len; i++) {
                var decorationId = keys[i];
                var decoration = this.decorations[decorationId];
                if (ownerId && decoration.ownerId && decoration.ownerId !== ownerId) {
                    continue;
                }
                if (filterOutValidation) {
                    if (decoration.options.className === editorCommon.ClassName.EditorErrorDecoration || decoration.options.className === editorCommon.ClassName.EditorWarningDecoration) {
                        continue;
                    }
                }
                result.push({
                    id: decoration.id,
                    ownerId: decoration.ownerId,
                    range: this.getTrackedRange(decoration.rangeId),
                    options: decoration.options
                });
            }
            return result;
        };
        TextModelWithDecorations.prototype._withDeferredEvents = function (callback) {
            var _this = this;
            return this.deferredEmit(function () {
                var createDeferredEvents = _this._currentDeferredEvents ? false : true;
                if (createDeferredEvents) {
                    _this._currentDeferredEvents = new DeferredEventsBuilder();
                }
                try {
                    var result = callback(_this._currentDeferredEvents);
                    if (createDeferredEvents) {
                        _this._handleCollectedEvents(_this._currentDeferredEvents);
                    }
                }
                finally {
                    if (createDeferredEvents) {
                        _this._currentDeferredEvents = null;
                    }
                }
                return result;
            });
        };
        TextModelWithDecorations.prototype._handleCollectedEvents = function (b) {
            // Normalize changed markers into an array
            var changedMarkers = this._getMarkersInMap(b.changedMarkers);
            // Collect changed tracked ranges
            var changedRanges = this._onChangedMarkers(changedMarkers);
            // Collect decoration change events with the deferred event builder
            this._onChangedRanges(b, changedRanges);
            // Emit a single decorations changed event
            this._handleCollectedDecorationsEvents(b);
            // Reset markers for next round of events
            for (var i = 0, len = changedMarkers.length; i < len; i++) {
                changedMarkers[i].oldLineNumber = 0;
                changedMarkers[i].oldColumn = 0;
            }
        };
        TextModelWithDecorations.prototype._onChangedRanges = function (eventBuilder, changedRanges) {
            var keys = Object.keys(changedRanges);
            for (var i = 0, len = keys.length; i < len; i++) {
                var rangeId = keys[i];
                if (this.rangeIdToDecorationId.hasOwnProperty(rangeId)) {
                    var decorationId = this.rangeIdToDecorationId[rangeId];
                    eventBuilder.addMovedDecoration(decorationId, changedRanges[rangeId]);
                }
            }
        };
        TextModelWithDecorations.prototype._handleCollectedDecorationsEvents = function (b) {
            var addedOrChangedDecorations = [], removedDecorations = [], decorationIds = [], decorationData, oldRange;
            var keys = Object.keys(b.newOrChangedDecorations);
            for (var i = 0, len = keys.length; i < len; i++) {
                var decorationId = keys[i];
                decorationIds.push(decorationId);
                decorationData = this._getDecorationData(decorationId);
                decorationData.isForValidation = (decorationData.options.className === editorCommon.ClassName.EditorErrorDecoration || decorationData.options.className === editorCommon.ClassName.EditorWarningDecoration);
                addedOrChangedDecorations.push(decorationData);
                if (b.oldDecorationRange.hasOwnProperty(decorationId)) {
                    oldRange = b.oldDecorationRange[decorationId];
                    oldRange.startLineNumber = oldRange.startLineNumber || decorationData.range.startLineNumber;
                    oldRange.startColumn = oldRange.startColumn || decorationData.range.startColumn;
                    oldRange.endLineNumber = oldRange.endLineNumber || decorationData.range.endLineNumber;
                    oldRange.endColumn = oldRange.endColumn || decorationData.range.endColumn;
                }
            }
            keys = Object.keys(b.removedDecorations);
            for (var i = 0, len = keys.length; i < len; i++) {
                var decorationId = keys[i];
                decorationIds.push(decorationId);
                removedDecorations.push(decorationId);
            }
            if (decorationIds.length > 0) {
                var e = {
                    ids: decorationIds,
                    addedOrChangedDecorations: addedOrChangedDecorations,
                    removedDecorations: removedDecorations,
                    oldOptions: b.oldDecorationOptions,
                    oldRanges: b.oldDecorationRange
                };
                this.emitModelDecorationsChangedEvent(e);
            }
        };
        TextModelWithDecorations.prototype._getDecorationData = function (decorationId) {
            var decoration = this.decorations[decorationId];
            return {
                id: decoration.id,
                ownerId: decoration.ownerId,
                range: this.getTrackedRange(decoration.rangeId),
                isForValidation: false,
                options: decoration.options
            };
        };
        TextModelWithDecorations.prototype.emitModelDecorationsChangedEvent = function (e) {
            if (!this._isDisposing) {
                this.emit(editorCommon.EventType.ModelDecorationsChanged, e);
            }
        };
        TextModelWithDecorations.prototype._normalizeDeltaDecorations = function (deltaDecorations) {
            var result = [];
            for (var i = 0, len = deltaDecorations.length; i < len; i++) {
                var deltaDecoration = deltaDecorations[i];
                result.push(new ModelDeltaDecoration(i, this.validateRange(deltaDecoration.range), _normalizeOptions(deltaDecoration.options)));
            }
            return result;
        };
        TextModelWithDecorations.prototype._addDecorationImpl = function (eventBuilder, ownerId, range, options) {
            var rangeId = this.addTrackedRange(range, options.stickiness);
            var decoration = new ModelInternalDecoration(this._decorationIdGenerator.nextId(), ownerId, rangeId, options);
            this.decorations[decoration.id] = decoration;
            this.rangeIdToDecorationId[rangeId] = decoration.id;
            eventBuilder.addNewDecoration(decoration.id);
            return decoration.id;
        };
        TextModelWithDecorations.prototype._addDecorationsImpl = function (eventBuilder, ownerId, newDecorations) {
            var rangeIds = this._addTrackedRanges(newDecorations.map(function (d) { return d.range; }), newDecorations.map(function (d) { return d.options.stickiness; }));
            var result = [];
            for (var i = 0, len = newDecorations.length; i < len; i++) {
                var rangeId = rangeIds[i];
                var decoration = new ModelInternalDecoration(this._decorationIdGenerator.nextId(), ownerId, rangeId, newDecorations[i].options);
                this.decorations[decoration.id] = decoration;
                this.rangeIdToDecorationId[rangeId] = decoration.id;
                eventBuilder.addNewDecoration(decoration.id);
                result.push(decoration.id);
            }
            return result;
        };
        TextModelWithDecorations.prototype._changeDecorationImpl = function (eventBuilder, id, newRange) {
            if (this.decorations.hasOwnProperty(id)) {
                var decoration = this.decorations[id];
                var oldRange = this.getTrackedRange(decoration.rangeId);
                this.changeTrackedRange(decoration.rangeId, newRange);
                eventBuilder.addMovedDecoration(id, oldRange);
            }
        };
        TextModelWithDecorations.prototype._changeDecorationOptionsImpl = function (eventBuilder, id, options) {
            if (this.decorations.hasOwnProperty(id)) {
                var decoration = this.decorations[id];
                var oldOptions = decoration.options;
                if (oldOptions.stickiness !== options.stickiness) {
                    this.changeTrackedRangeStickiness(decoration.rangeId, options.stickiness);
                }
                decoration.options = options;
                eventBuilder.addUpdatedDecoration(id, oldOptions);
            }
        };
        TextModelWithDecorations.prototype._removeDecorationImpl = function (eventBuilder, id) {
            if (this.decorations.hasOwnProperty(id)) {
                var decoration = this.decorations[id];
                var oldRange = null;
                if (eventBuilder) {
                    oldRange = this.getTrackedRange(decoration.rangeId);
                }
                this.removeTrackedRange(decoration.rangeId);
                delete this.rangeIdToDecorationId[decoration.rangeId];
                delete this.decorations[id];
                if (eventBuilder) {
                    eventBuilder.addRemovedDecoration(id, decoration.ownerId, oldRange, decoration.options);
                }
            }
        };
        TextModelWithDecorations.prototype._removeDecorationsImpl = function (eventBuilder, ids) {
            var removeTrackedRanges = [];
            for (var i = 0, len = ids.length; i < len; i++) {
                var id = ids[i];
                if (!this.decorations.hasOwnProperty(id)) {
                    continue;
                }
                var decoration = this.decorations[id];
                if (eventBuilder) {
                    var oldRange = this.getTrackedRange(decoration.rangeId);
                    eventBuilder.addRemovedDecoration(id, decoration.ownerId, oldRange, decoration.options);
                }
                removeTrackedRanges.push(decoration.rangeId);
                delete this.rangeIdToDecorationId[decoration.rangeId];
                delete this.decorations[id];
            }
            if (removeTrackedRanges.length > 0) {
                this.removeTrackedRanges(removeTrackedRanges);
            }
        };
        TextModelWithDecorations.prototype._resolveOldDecorations = function (oldDecorations) {
            var result = [];
            for (var i = 0, len = oldDecorations.length; i < len; i++) {
                var id = oldDecorations[i];
                if (!this.decorations.hasOwnProperty(id)) {
                    continue;
                }
                var decoration = this.decorations[id];
                result.push({
                    id: id,
                    range: this.getTrackedRange(decoration.rangeId),
                    options: decoration.options
                });
            }
            return result;
        };
        TextModelWithDecorations.prototype._deltaDecorationsImpl = function (eventBuilder, ownerId, oldDecorationsIds, newDecorations) {
            if (oldDecorationsIds.length === 0) {
                // Nothing to remove
                return this._addDecorationsImpl(eventBuilder, ownerId, newDecorations);
            }
            if (newDecorations.length === 0) {
                // Nothing to add
                this._removeDecorationsImpl(eventBuilder, oldDecorationsIds);
                return [];
            }
            var oldDecorations = this._resolveOldDecorations(oldDecorationsIds);
            oldDecorations.sort(function (a, b) { return range_1.Range.compareRangesUsingStarts(a.range, b.range); });
            newDecorations.sort(function (a, b) { return range_1.Range.compareRangesUsingStarts(a.range, b.range); });
            var result = [], oldDecorationsIndex = 0, oldDecorationsLength = oldDecorations.length, newDecorationsIndex = 0, newDecorationsLength = newDecorations.length, decorationsToAdd = [], decorationsToRemove = [];
            while (oldDecorationsIndex < oldDecorationsLength && newDecorationsIndex < newDecorationsLength) {
                var oldDecoration = oldDecorations[oldDecorationsIndex];
                var newDecoration = newDecorations[newDecorationsIndex];
                var comparison = range_1.Range.compareRangesUsingStarts(oldDecoration.range, newDecoration.range);
                if (comparison < 0) {
                    // `oldDecoration` is before `newDecoration` => remove `oldDecoration`
                    decorationsToRemove.push(oldDecoration.id);
                    oldDecorationsIndex++;
                    continue;
                }
                if (comparison > 0) {
                    // `newDecoration` is before `oldDecoration` => add `newDecoration`
                    decorationsToAdd.push(newDecoration);
                    newDecorationsIndex++;
                    continue;
                }
                // The ranges of `oldDecoration` and `newDecoration` are equal
                if (!oldDecoration.options.equals(newDecoration.options)) {
                    // The options do not match => remove `oldDecoration`
                    decorationsToRemove.push(oldDecoration.id);
                    oldDecorationsIndex++;
                    continue;
                }
                // Bingo! We can reuse `oldDecoration` for `newDecoration`
                result[newDecoration.index] = oldDecoration.id;
                oldDecorationsIndex++;
                newDecorationsIndex++;
            }
            while (oldDecorationsIndex < oldDecorationsLength) {
                // No more new decorations => remove decoration at `oldDecorationsIndex`
                decorationsToRemove.push(oldDecorations[oldDecorationsIndex].id);
                oldDecorationsIndex++;
            }
            while (newDecorationsIndex < newDecorationsLength) {
                // No more old decorations => add decoration at `newDecorationsIndex`
                decorationsToAdd.push(newDecorations[newDecorationsIndex]);
                newDecorationsIndex++;
            }
            // Remove `decorationsToRemove`
            if (decorationsToRemove.length > 0) {
                this._removeDecorationsImpl(eventBuilder, decorationsToRemove);
            }
            // Add `decorationsToAdd`
            if (decorationsToAdd.length > 0) {
                var newIds = this._addDecorationsImpl(eventBuilder, ownerId, decorationsToAdd);
                for (var i = 0, len = decorationsToAdd.length; i < len; i++) {
                    result[decorationsToAdd[i].index] = newIds[i];
                }
            }
            return result;
        };
        return TextModelWithDecorations;
    }(textModelWithTrackedRanges_1.TextModelWithTrackedRanges));
    exports.TextModelWithDecorations = TextModelWithDecorations;
    function cleanClassName(className) {
        return className.replace(/[^a-z0-9\-]/gi, ' ');
    }
    var ModelInternalDecoration = (function () {
        function ModelInternalDecoration(id, ownerId, rangeId, options) {
            this.id = id;
            this.ownerId = ownerId;
            this.rangeId = rangeId;
            this.options = options;
        }
        return ModelInternalDecoration;
    }());
    var ModelDecorationOptions = (function () {
        function ModelDecorationOptions(options) {
            this.stickiness = options.stickiness || editorCommon.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges;
            this.className = cleanClassName(options.className || strings.empty);
            this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || strings.empty;
            this.hoverMessage = options.hoverMessage || [];
            this.isWholeLine = options.isWholeLine || false;
            this.overviewRuler = _normalizeOverviewRulerOptions(options.overviewRuler, options.showInOverviewRuler);
            this.glyphMarginClassName = cleanClassName(options.glyphMarginClassName || strings.empty);
            this.linesDecorationsClassName = cleanClassName(options.linesDecorationsClassName || strings.empty);
            this.inlineClassName = cleanClassName(options.inlineClassName || strings.empty);
            this.beforeContentClassName = cleanClassName(options.beforeContentClassName || strings.empty);
            this.afterContentClassName = cleanClassName(options.afterContentClassName || strings.empty);
        }
        ModelDecorationOptions._overviewRulerEquals = function (a, b) {
            return (a.color === b.color
                && a.position === b.position
                && a.darkColor === b.darkColor);
        };
        ModelDecorationOptions.prototype.equals = function (other) {
            return (this.stickiness === other.stickiness
                && this.className === other.className
                && this.glyphMarginHoverMessage === other.glyphMarginHoverMessage
                && this.isWholeLine === other.isWholeLine
                && this.showInOverviewRuler === other.showInOverviewRuler
                && this.glyphMarginClassName === other.glyphMarginClassName
                && this.linesDecorationsClassName === other.linesDecorationsClassName
                && this.inlineClassName === other.inlineClassName
                && this.beforeContentClassName === other.beforeContentClassName
                && this.afterContentClassName === other.afterContentClassName
                && htmlContent_1.markedStringsEquals(this.hoverMessage, other.hoverMessage)
                && ModelDecorationOptions._overviewRulerEquals(this.overviewRuler, other.overviewRuler));
        };
        return ModelDecorationOptions;
    }());
    var ModelDeltaDecoration = (function () {
        function ModelDeltaDecoration(index, range, options) {
            this.index = index;
            this.range = range;
            this.options = options;
        }
        return ModelDeltaDecoration;
    }());
    function _normalizeOptions(options) {
        return new ModelDecorationOptions(options);
    }
    var ModelDecorationOverviewRulerOptions = (function () {
        function ModelDecorationOverviewRulerOptions(options, legacyShowInOverviewRuler) {
            this.color = strings.empty;
            this.darkColor = strings.empty;
            this.position = editorCommon.OverviewRulerLane.Center;
            if (legacyShowInOverviewRuler) {
                this.color = legacyShowInOverviewRuler;
            }
            if (options && options.color) {
                this.color = options.color;
            }
            if (options && options.darkColor) {
                this.darkColor = options.darkColor;
            }
            if (options && options.hasOwnProperty('position')) {
                this.position = options.position;
            }
        }
        return ModelDecorationOverviewRulerOptions;
    }());
    function _normalizeOverviewRulerOptions(options, legacyShowInOverviewRuler) {
        if (legacyShowInOverviewRuler === void 0) { legacyShowInOverviewRuler = null; }
        return new ModelDecorationOverviewRulerOptions(options, legacyShowInOverviewRuler);
    }
});






define(__m[314], __M([0,1,4,7,211,165,313,10]), function (require, exports, range_1, editorCommon, editStack_1, modelLine_1, textModelWithDecorations_1, strings) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditableTextModel = (function (_super) {
        __extends(EditableTextModel, _super);
        function EditableTextModel(allowedEventTypes, rawText, modeOrPromise) {
            allowedEventTypes.push(editorCommon.EventType.ModelRawContentChanged);
            allowedEventTypes.push(editorCommon.EventType.ModelContentChanged2);
            _super.call(this, allowedEventTypes, rawText, modeOrPromise);
            this._commandManager = new editStack_1.EditStack(this);
            this._isUndoing = false;
            this._isRedoing = false;
            this._hasEditableRange = false;
            this._editableRangeId = null;
            this._trimAutoWhitespaceLines = null;
        }
        EditableTextModel.prototype.onDidChangeRawContent = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelRawContentChanged, listener);
        };
        EditableTextModel.prototype.onDidChangeContent = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelContentChanged2, listener);
        };
        EditableTextModel.prototype.dispose = function () {
            this._commandManager = null;
            _super.prototype.dispose.call(this);
        };
        EditableTextModel.prototype._resetValue = function (e, newValue) {
            _super.prototype._resetValue.call(this, e, newValue);
            // Destroy my edit history and settings
            this._commandManager = new editStack_1.EditStack(this);
            this._hasEditableRange = false;
            this._editableRangeId = null;
            this._trimAutoWhitespaceLines = null;
        };
        EditableTextModel.prototype.pushStackElement = function () {
            this._commandManager.pushStackElement();
        };
        EditableTextModel.prototype.pushEditOperations = function (beforeCursorState, editOperations, cursorStateComputer) {
            var _this = this;
            return this.deferredEmit(function () {
                if (_this._options.trimAutoWhitespace && _this._trimAutoWhitespaceLines) {
                    // Go through each saved line number and insert a trim whitespace edit
                    // if it is safe to do so (no conflicts with other edits).
                    var incomingEdits = editOperations.map(function (op) {
                        return {
                            range: _this.validateRange(op.range),
                            text: op.text
                        };
                    });
                    // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor
                    // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace
                    var editsAreNearCursors = true;
                    for (var i = 0, len = beforeCursorState.length; i < len; i++) {
                        var sel = beforeCursorState[i];
                        var foundEditNearSel = false;
                        for (var j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
                            var editRange = incomingEdits[j].range;
                            var selIsAbove = editRange.startLineNumber > sel.endLineNumber;
                            var selIsBelow = sel.startLineNumber > editRange.endLineNumber;
                            if (!selIsAbove && !selIsBelow) {
                                foundEditNearSel = true;
                                break;
                            }
                        }
                        if (!foundEditNearSel) {
                            editsAreNearCursors = false;
                            break;
                        }
                    }
                    if (editsAreNearCursors) {
                        for (var i = 0, len = _this._trimAutoWhitespaceLines.length; i < len; i++) {
                            var trimLineNumber = _this._trimAutoWhitespaceLines[i];
                            var maxLineColumn = _this.getLineMaxColumn(trimLineNumber);
                            var allowTrimLine = true;
                            for (var j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {
                                var editRange = incomingEdits[j].range;
                                var editText = incomingEdits[j].text;
                                if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {
                                    // `trimLine` is completely outside this edit
                                    continue;
                                }
                                // At this point:
                                //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber
                                if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn
                                    && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\n') {
                                    // This edit inserts a new line (and maybe other text) after `trimLine`
                                    continue;
                                }
                                // Looks like we can't trim this line as it would interfere with an incoming edit
                                allowTrimLine = false;
                                break;
                            }
                            if (allowTrimLine) {
                                editOperations.push({
                                    identifier: null,
                                    range: new range_1.Range(trimLineNumber, 1, trimLineNumber, maxLineColumn),
                                    text: null,
                                    forceMoveMarkers: false,
                                    isAutoWhitespaceEdit: false
                                });
                            }
                        }
                    }
                    _this._trimAutoWhitespaceLines = null;
                }
                return _this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer);
            });
        };
        /**
         * Transform operations such that they represent the same logic edit,
         * but that they also do not cause OOM crashes.
         */
        EditableTextModel.prototype._reduceOperations = function (operations) {
            if (operations.length < 1000) {
                // We know from empirical testing that a thousand edits work fine regardless of their shape.
                return operations;
            }
            // At one point, due to how events are emitted and how each operation is handled,
            // some operations can trigger a high ammount of temporary string allocations,
            // that will immediately get edited again.
            // e.g. a formatter inserting ridiculous ammounts of \n on a model with a single line
            // Therefore, the strategy is to collapse all the operations into a huge single edit operation
            return [this._toSingleEditOperation(operations)];
        };
        EditableTextModel.prototype._toSingleEditOperation = function (operations) {
            var forceMoveMarkers = false, firstEditRange = operations[0].range, lastEditRange = operations[operations.length - 1].range, entireEditRange = new range_1.Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn), lastEndLineNumber = firstEditRange.startLineNumber, lastEndColumn = firstEditRange.startColumn, result = [];
            for (var i = 0, len = operations.length; i < len; i++) {
                var operation = operations[i], range = operation.range;
                forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;
                // (1) -- Push old text
                for (var lineNumber = lastEndLineNumber; lineNumber < range.startLineNumber; lineNumber++) {
                    if (lineNumber === lastEndLineNumber) {
                        result.push(this._lines[lineNumber - 1].text.substring(lastEndColumn - 1));
                    }
                    else {
                        result.push('\n');
                        result.push(this._lines[lineNumber - 1].text);
                    }
                }
                if (range.startLineNumber === lastEndLineNumber) {
                    result.push(this._lines[range.startLineNumber - 1].text.substring(lastEndColumn - 1, range.startColumn - 1));
                }
                else {
                    result.push('\n');
                    result.push(this._lines[range.startLineNumber - 1].text.substring(0, range.startColumn - 1));
                }
                // (2) -- Push new text
                if (operation.lines) {
                    for (var j = 0, lenJ = operation.lines.length; j < lenJ; j++) {
                        if (j !== 0) {
                            result.push('\n');
                        }
                        result.push(operation.lines[j]);
                    }
                }
                lastEndLineNumber = operation.range.endLineNumber;
                lastEndColumn = operation.range.endColumn;
            }
            return {
                sortIndex: 0,
                identifier: operations[0].identifier,
                range: entireEditRange,
                rangeLength: this.getValueLengthInRange(entireEditRange),
                lines: result.join('').split('\n'),
                forceMoveMarkers: forceMoveMarkers,
                isAutoWhitespaceEdit: false
            };
        };
        EditableTextModel._sortOpsAscending = function (a, b) {
            var r = range_1.Range.compareRangesUsingEnds(a.range, b.range);
            if (r === 0) {
                return a.sortIndex - b.sortIndex;
            }
            return r;
        };
        EditableTextModel._sortOpsDescending = function (a, b) {
            var r = range_1.Range.compareRangesUsingEnds(a.range, b.range);
            if (r === 0) {
                return b.sortIndex - a.sortIndex;
            }
            return -r;
        };
        EditableTextModel.prototype.applyEdits = function (rawOperations) {
            if (rawOperations.length === 0) {
                return [];
            }
            var operations = [];
            for (var i = 0; i < rawOperations.length; i++) {
                var op = rawOperations[i];
                var validatedRange = this.validateRange(op.range);
                operations[i] = {
                    sortIndex: i,
                    identifier: op.identifier,
                    range: validatedRange,
                    rangeLength: this.getValueLengthInRange(validatedRange),
                    lines: op.text ? op.text.split(/\r\n|\r|\n/) : null,
                    forceMoveMarkers: op.forceMoveMarkers,
                    isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false
                };
            }
            // Sort operations ascending
            operations.sort(EditableTextModel._sortOpsAscending);
            for (var i = 0, count = operations.length - 1; i < count; i++) {
                var rangeEnd = operations[i].range.getEndPosition();
                var nextRangeStart = operations[i + 1].range.getStartPosition();
                if (nextRangeStart.isBefore(rangeEnd)) {
                    // overlapping ranges
                    throw new Error('Overlapping ranges are not allowed!');
                }
            }
            operations = this._reduceOperations(operations);
            var editableRange = this.getEditableRange();
            var editableRangeStart = editableRange.getStartPosition();
            var editableRangeEnd = editableRange.getEndPosition();
            for (var i = 0; i < operations.length; i++) {
                var operationRange = operations[i].range;
                if (!editableRangeStart.isBeforeOrEqual(operationRange.getStartPosition()) || !operationRange.getEndPosition().isBeforeOrEqual(editableRangeEnd)) {
                    throw new Error('Editing outside of editable range not allowed!');
                }
            }
            // Delta encode operations
            var reverseRanges = EditableTextModel._getInverseEditRanges(operations);
            var reverseOperations = [];
            var newTrimAutoWhitespaceCandidates = [];
            for (var i = 0; i < operations.length; i++) {
                var op = operations[i];
                var reverseRange = reverseRanges[i];
                reverseOperations[i] = {
                    identifier: op.identifier,
                    range: reverseRange,
                    text: this.getValueInRange(op.range),
                    forceMoveMarkers: op.forceMoveMarkers
                };
                if (this._options.trimAutoWhitespace && op.isAutoWhitespaceEdit && op.range.isEmpty()) {
                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit
                    for (var lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {
                        var currentLineContent = '';
                        if (lineNumber === reverseRange.startLineNumber) {
                            currentLineContent = this.getLineContent(op.range.startLineNumber);
                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {
                                continue;
                            }
                        }
                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });
                    }
                }
            }
            this._applyEdits(operations);
            this._trimAutoWhitespaceLines = null;
            if (this._options.trimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {
                // sort line numbers auto whitespace removal candidates for next edit descending
                newTrimAutoWhitespaceCandidates.sort(function (a, b) { return b.lineNumber - a.lineNumber; });
                this._trimAutoWhitespaceLines = [];
                for (var i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {
                    var lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;
                    if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {
                        // Do not have the same line number twice
                        continue;
                    }
                    var prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;
                    var lineContent = this.getLineContent(lineNumber);
                    if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {
                        continue;
                    }
                    this._trimAutoWhitespaceLines.push(lineNumber);
                }
            }
            return reverseOperations;
        };
        /**
         * Assumes `operations` are validated and sorted ascending
         */
        EditableTextModel._getInverseEditRanges = function (operations) {
            var result = [];
            var prevOpEndLineNumber;
            var prevOpEndColumn;
            var prevOp = null;
            for (var i = 0, len = operations.length; i < len; i++) {
                var op = operations[i];
                var startLineNumber = void 0;
                var startColumn = void 0;
                if (prevOp) {
                    if (prevOp.range.endLineNumber === op.range.startLineNumber) {
                        startLineNumber = prevOpEndLineNumber;
                        startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);
                    }
                    else {
                        startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);
                        startColumn = op.range.startColumn;
                    }
                }
                else {
                    startLineNumber = op.range.startLineNumber;
                    startColumn = op.range.startColumn;
                }
                var resultRange = void 0;
                if (op.lines && op.lines.length > 0) {
                    // the operation inserts something
                    var lineCount = op.lines.length;
                    var firstLine = op.lines[0];
                    var lastLine = op.lines[lineCount - 1];
                    if (lineCount === 1) {
                        // single line insert
                        resultRange = new range_1.Range(startLineNumber, startColumn, startLineNumber, startColumn + firstLine.length);
                    }
                    else {
                        // multi line insert
                        resultRange = new range_1.Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, lastLine.length + 1);
                    }
                }
                else {
                    // There is nothing to insert
                    resultRange = new range_1.Range(startLineNumber, startColumn, startLineNumber, startColumn);
                }
                prevOpEndLineNumber = resultRange.endLineNumber;
                prevOpEndColumn = resultRange.endColumn;
                result.push(resultRange);
                prevOp = op;
            }
            return result;
        };
        EditableTextModel.prototype._applyEdits = function (operations) {
            var _this = this;
            // Sort operations descending
            operations.sort(EditableTextModel._sortOpsDescending);
            this._withDeferredEvents(function (deferredEventsBuilder) {
                var contentChangedEvents = [];
                var contentChanged2Events = [];
                var lineEditsQueue = [];
                var queueLineEdit = function (lineEdit) {
                    if (lineEdit.startColumn === lineEdit.endColumn && lineEdit.text.length === 0) {
                        // empty edit => ignore it
                        return;
                    }
                    lineEditsQueue.push(lineEdit);
                };
                var flushLineEdits = function () {
                    if (lineEditsQueue.length === 0) {
                        return;
                    }
                    lineEditsQueue.reverse();
                    // `lineEditsQueue` now contains edits from smaller (line number,column) to larger (line number,column)
                    var currentLineNumber = lineEditsQueue[0].lineNumber;
                    var currentLineNumberStart = 0;
                    for (var i = 1, len = lineEditsQueue.length; i < len; i++) {
                        var lineNumber = lineEditsQueue[i].lineNumber;
                        if (lineNumber === currentLineNumber) {
                            continue;
                        }
                        _this._invalidateLine(currentLineNumber - 1);
                        _this._lines[currentLineNumber - 1].applyEdits(deferredEventsBuilder.changedMarkers, lineEditsQueue.slice(currentLineNumberStart, i));
                        if (_this._lineStarts) {
                            // update prefix sum
                            _this._lineStarts.changeValue(currentLineNumber - 1, _this._lines[currentLineNumber - 1].text.length + _this._EOL.length);
                        }
                        contentChangedEvents.push(_this._createLineChangedEvent(currentLineNumber));
                        currentLineNumber = lineNumber;
                        currentLineNumberStart = i;
                    }
                    _this._invalidateLine(currentLineNumber - 1);
                    _this._lines[currentLineNumber - 1].applyEdits(deferredEventsBuilder.changedMarkers, lineEditsQueue.slice(currentLineNumberStart, lineEditsQueue.length));
                    if (_this._lineStarts) {
                        // update prefix sum
                        _this._lineStarts.changeValue(currentLineNumber - 1, _this._lines[currentLineNumber - 1].text.length + _this._EOL.length);
                    }
                    contentChangedEvents.push(_this._createLineChangedEvent(currentLineNumber));
                    lineEditsQueue = [];
                };
                var minTouchedLineNumber = operations[operations.length - 1].range.startLineNumber;
                var maxTouchedLineNumber = operations[0].range.endLineNumber + 1;
                var totalLinesCountDelta = 0;
                for (var i = 0, len = operations.length; i < len; i++) {
                    var op = operations[i];
                    // console.log();
                    // console.log('-------------------');
                    // console.log('OPERATION #' + (i));
                    // console.log('op: ', op);
                    // console.log('<<<\n' + this._lines.map(l => l.text).join('\n') + '\n>>>');
                    var startLineNumber = op.range.startLineNumber;
                    var startColumn = op.range.startColumn;
                    var endLineNumber = op.range.endLineNumber;
                    var endColumn = op.range.endColumn;
                    if (startLineNumber === endLineNumber && startColumn === endColumn && (!op.lines || op.lines.length === 0)) {
                        // no-op
                        continue;
                    }
                    var deletingLinesCnt = endLineNumber - startLineNumber;
                    var insertingLinesCnt = (op.lines ? op.lines.length - 1 : 0);
                    var editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);
                    totalLinesCountDelta += (insertingLinesCnt - deletingLinesCnt);
                    // Iterating descending to overlap with previous op
                    // in case there are common lines being edited in both
                    for (var j = editingLinesCnt; j >= 0; j--) {
                        var editLineNumber = startLineNumber + j;
                        queueLineEdit({
                            lineNumber: editLineNumber,
                            startColumn: (editLineNumber === startLineNumber ? startColumn : 1),
                            endColumn: (editLineNumber === endLineNumber ? endColumn : _this.getLineMaxColumn(editLineNumber)),
                            text: (op.lines ? op.lines[j] : ''),
                            forceMoveMarkers: op.forceMoveMarkers
                        });
                    }
                    if (editingLinesCnt < deletingLinesCnt) {
                        // Must delete some lines
                        // Flush any pending line edits
                        flushLineEdits();
                        var spliceStartLineNumber = startLineNumber + editingLinesCnt;
                        var spliceStartColumn = _this.getLineMaxColumn(spliceStartLineNumber);
                        var endLineRemains = _this._lines[endLineNumber - 1].split(deferredEventsBuilder.changedMarkers, endColumn, false);
                        _this._invalidateLine(spliceStartLineNumber - 1);
                        var spliceCnt = endLineNumber - spliceStartLineNumber;
                        // Collect all these markers
                        var markersOnDeletedLines = [];
                        for (var j = 0; j < spliceCnt; j++) {
                            var deleteLineIndex = spliceStartLineNumber + j;
                            markersOnDeletedLines = markersOnDeletedLines.concat(_this._lines[deleteLineIndex].deleteLine(deferredEventsBuilder.changedMarkers, spliceStartColumn, deleteLineIndex + 1));
                        }
                        _this._lines.splice(spliceStartLineNumber, spliceCnt);
                        if (_this._lineStarts) {
                            // update prefix sum
                            _this._lineStarts.removeValues(spliceStartLineNumber, spliceCnt);
                        }
                        // Reconstruct first line
                        _this._lines[spliceStartLineNumber - 1].append(deferredEventsBuilder.changedMarkers, endLineRemains);
                        if (_this._lineStarts) {
                            // update prefix sum
                            _this._lineStarts.changeValue(spliceStartLineNumber - 1, _this._lines[spliceStartLineNumber - 1].text.length + _this._EOL.length);
                        }
                        _this._lines[spliceStartLineNumber - 1].addMarkers(markersOnDeletedLines);
                        contentChangedEvents.push(_this._createLineChangedEvent(spliceStartLineNumber));
                        contentChangedEvents.push(_this._createLinesDeletedEvent(spliceStartLineNumber + 1, spliceStartLineNumber + spliceCnt));
                    }
                    if (editingLinesCnt < insertingLinesCnt) {
                        // Must insert some lines
                        // Flush any pending line edits
                        flushLineEdits();
                        var spliceLineNumber = startLineNumber + editingLinesCnt;
                        var spliceColumn = (spliceLineNumber === startLineNumber ? startColumn : 1);
                        if (op.lines) {
                            spliceColumn += op.lines[editingLinesCnt].length;
                        }
                        // Split last line
                        var leftoverLine = _this._lines[spliceLineNumber - 1].split(deferredEventsBuilder.changedMarkers, spliceColumn, op.forceMoveMarkers);
                        if (_this._lineStarts) {
                            // update prefix sum
                            _this._lineStarts.changeValue(spliceLineNumber - 1, _this._lines[spliceLineNumber - 1].text.length + _this._EOL.length);
                        }
                        contentChangedEvents.push(_this._createLineChangedEvent(spliceLineNumber));
                        _this._invalidateLine(spliceLineNumber - 1);
                        // Lines in the middle
                        var newLinesContent = [];
                        var newLinesLengths = [];
                        for (var j = editingLinesCnt + 1; j <= insertingLinesCnt; j++) {
                            var newLineNumber = startLineNumber + j;
                            _this._lines.splice(newLineNumber - 1, 0, new modelLine_1.ModelLine(newLineNumber, op.lines[j]));
                            newLinesContent.push(op.lines[j]);
                            newLinesLengths.push(op.lines[j].length + _this._EOL.length);
                        }
                        newLinesContent[newLinesContent.length - 1] += leftoverLine.text;
                        if (_this._lineStarts) {
                            // update prefix sum
                            _this._lineStarts.insertValues(startLineNumber + editingLinesCnt, newLinesLengths);
                        }
                        // Last line
                        _this._lines[startLineNumber + insertingLinesCnt - 1].append(deferredEventsBuilder.changedMarkers, leftoverLine);
                        if (_this._lineStarts) {
                            // update prefix sum
                            _this._lineStarts.changeValue(startLineNumber + insertingLinesCnt - 1, _this._lines[startLineNumber + insertingLinesCnt - 1].text.length + _this._EOL.length);
                        }
                        contentChangedEvents.push(_this._createLinesInsertedEvent(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLinesContent.join('\n')));
                    }
                    contentChanged2Events.push({
                        range: new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn),
                        rangeLength: op.rangeLength,
                        text: op.lines ? op.lines.join(_this.getEOL()) : '',
                        eol: _this._EOL,
                        versionId: -1,
                        isUndoing: _this._isUndoing,
                        isRedoing: _this._isRedoing
                    });
                }
                flushLineEdits();
                maxTouchedLineNumber = Math.max(1, Math.min(_this.getLineCount(), maxTouchedLineNumber + totalLinesCountDelta));
                if (totalLinesCountDelta !== 0) {
                    // must update line numbers all the way to the bottom
                    maxTouchedLineNumber = _this.getLineCount();
                }
                for (var lineNumber = minTouchedLineNumber; lineNumber <= maxTouchedLineNumber; lineNumber++) {
                    _this._lines[lineNumber - 1].updateLineNumber(deferredEventsBuilder.changedMarkers, lineNumber);
                }
                if (contentChangedEvents.length !== 0 || contentChanged2Events.length !== 0) {
                    if (contentChangedEvents.length === 0) {
                        // Fabricate a fake line changed event to get an event out
                        // This most likely occurs when there edit operations are no-ops
                        contentChangedEvents.push(_this._createLineChangedEvent(minTouchedLineNumber));
                    }
                    var versionBumps = Math.max(contentChangedEvents.length, contentChanged2Events.length);
                    var finalVersionId = _this.getVersionId() + versionBumps;
                    _this._setVersionId(finalVersionId);
                    for (var i = contentChangedEvents.length - 1, versionId = finalVersionId; i >= 0; i--, versionId--) {
                        contentChangedEvents[i].versionId = versionId;
                    }
                    for (var i = contentChanged2Events.length - 1, versionId = finalVersionId; i >= 0; i--, versionId--) {
                        contentChanged2Events[i].versionId = versionId;
                    }
                    for (var i = 0, len = contentChangedEvents.length; i < len; i++) {
                        _this.emit(editorCommon.EventType.ModelRawContentChanged, contentChangedEvents[i]);
                    }
                    for (var i = 0, len = contentChanged2Events.length; i < len; i++) {
                        _this.emit(editorCommon.EventType.ModelContentChanged2, contentChanged2Events[i]);
                    }
                }
                // this._assertLineNumbersOK();
            });
        };
        EditableTextModel.prototype._assertLineNumbersOK = function () {
            var foundMarkersCnt = 0;
            for (var i = 0, len = this._lines.length; i < len; i++) {
                var line = this._lines[i];
                var lineNumber = i + 1;
                if (line.lineNumber !== lineNumber) {
                    throw new Error('Invalid lineNumber at line: ' + lineNumber + '; text is: ' + this.getValue());
                }
                var markers = line.getMarkers();
                for (var j = 0, lenJ = markers.length; j < lenJ; j++) {
                    foundMarkersCnt++;
                    var markerId = markers[j].id;
                    var marker = this._markerIdToMarker[markerId];
                    if (marker.line !== line) {
                        throw new Error('Misplaced marker with id ' + markerId);
                    }
                }
            }
            var totalMarkersCnt = Object.keys(this._markerIdToMarker).length;
            if (totalMarkersCnt !== foundMarkersCnt) {
                throw new Error('There are misplaced markers!');
            }
        };
        EditableTextModel.prototype.undo = function () {
            var _this = this;
            return this._withDeferredEvents(function () {
                _this._isUndoing = true;
                var r = _this._commandManager.undo();
                _this._isUndoing = false;
                if (!r) {
                    return null;
                }
                _this._overwriteAlternativeVersionId(r.recordedVersionId);
                return r.selections;
            });
        };
        EditableTextModel.prototype.redo = function () {
            var _this = this;
            return this._withDeferredEvents(function () {
                _this._isRedoing = true;
                var r = _this._commandManager.redo();
                _this._isRedoing = false;
                if (!r) {
                    return null;
                }
                _this._overwriteAlternativeVersionId(r.recordedVersionId);
                return r.selections;
            });
        };
        EditableTextModel.prototype.setEditableRange = function (range) {
            this._commandManager.clear();
            if (this._hasEditableRange) {
                this.removeTrackedRange(this._editableRangeId);
                this._editableRangeId = null;
                this._hasEditableRange = false;
            }
            if (range) {
                this._hasEditableRange = true;
                this._editableRangeId = this.addTrackedRange(range, editorCommon.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges);
            }
        };
        EditableTextModel.prototype.hasEditableRange = function () {
            return this._hasEditableRange;
        };
        EditableTextModel.prototype.getEditableRange = function () {
            if (this._hasEditableRange) {
                return this.getTrackedRange(this._editableRangeId);
            }
            else {
                return this.getFullModelRange();
            }
        };
        EditableTextModel.prototype._createLineChangedEvent = function (lineNumber) {
            return {
                changeType: editorCommon.EventType.ModelRawContentChangedLineChanged,
                lineNumber: lineNumber,
                detail: this._lines[lineNumber - 1].text,
                versionId: -1,
                isUndoing: this._isUndoing,
                isRedoing: this._isRedoing
            };
        };
        EditableTextModel.prototype._createLinesDeletedEvent = function (fromLineNumber, toLineNumber) {
            return {
                changeType: editorCommon.EventType.ModelRawContentChangedLinesDeleted,
                fromLineNumber: fromLineNumber,
                toLineNumber: toLineNumber,
                versionId: -1,
                isUndoing: this._isUndoing,
                isRedoing: this._isRedoing
            };
        };
        EditableTextModel.prototype._createLinesInsertedEvent = function (fromLineNumber, toLineNumber, newLinesContent) {
            return {
                changeType: editorCommon.EventType.ModelRawContentChangedLinesInserted,
                fromLineNumber: fromLineNumber,
                toLineNumber: toLineNumber,
                detail: newLinesContent,
                versionId: -1,
                isUndoing: this._isUndoing,
                isRedoing: this._isRedoing
            };
        };
        return EditableTextModel;
    }(textModelWithDecorations_1.TextModelWithDecorations));
    exports.EditableTextModel = EditableTextModel;
});






define(__m[125], __M([0,1,29,7,314,177]), function (require, exports, uri_1, editorCommon_1, editableTextModel_1, textModel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // The hierarchy is:
    // Model -> EditableTextModel -> TextModelWithDecorations -> TextModelWithTrackedRanges -> TextModelWithMarkers -> TextModelWithTokens -> TextModel
    var MODEL_ID = 0;
    var aliveModels = {};
    // var LAST_CNT = 0;
    // setInterval(() => {
    // 	var cnt = Object.keys(aliveModels).length;
    // 	if (cnt === LAST_CNT) {
    // 		return;
    // 	}
    // 	console.warn('ALIVE MODELS:');
    // 	console.log(Object.keys(aliveModels).join('\n'));
    // 	LAST_CNT = cnt;
    // }, 100);
    var Model = (function (_super) {
        __extends(Model, _super);
        /**
         * Instantiates a new model
         * @param rawText
         *   The raw text buffer. It may start with a UTF-16 BOM, which can be
         *   optionally preserved when doing a getValue call. The lines may be
         *   separated by different EOL combinations, such as \n or \r\n. These
         *   can also be preserved when doing a getValue call.
         * @param mode
         *   The language service name this model is bound to.
         * @param associatedResource
         *   The resource associated with this model. If the value is not provided an
         *   unique in memory URL is constructed as the associated resource.
         */
        function Model(rawText, modeOrPromise, associatedResource) {
            if (associatedResource === void 0) { associatedResource = null; }
            _super.call(this, [
                editorCommon_1.EventType.ModelDispose
            ], rawText, modeOrPromise);
            // Generate a new unique model id
            MODEL_ID++;
            this.id = '$model' + MODEL_ID;
            if (typeof associatedResource === 'undefined' || associatedResource === null) {
                this._associatedResource = uri_1.default.parse('inmemory://model/' + MODEL_ID);
            }
            else {
                this._associatedResource = associatedResource;
            }
            if (aliveModels[String(this._associatedResource)]) {
                throw new Error('Cannot instantiate a second Model with the same URI!');
            }
            this._attachedEditorCount = 0;
            aliveModels[String(this._associatedResource)] = true;
            // console.log('ALIVE MODELS: ' + Object.keys(aliveModels).join('\n'));
        }
        Model.prototype.onDidChangeModeSupport = function (listener) {
            return this.addListener2(editorCommon_1.EventType.ModelModeSupportChanged, listener);
        };
        Model.prototype.onDidChangeDecorations = function (listener) {
            return this.addListener2(editorCommon_1.EventType.ModelDecorationsChanged, listener);
        };
        Model.prototype.onDidChangeOptions = function (listener) {
            return this.addListener2(editorCommon_1.EventType.ModelOptionsChanged, listener);
        };
        Model.prototype.onWillDispose = function (listener) {
            return this.addListener2(editorCommon_1.EventType.ModelDispose, listener);
        };
        Model.prototype.onDidChangeMode = function (listener) {
            return this.addListener2(editorCommon_1.EventType.ModelModeChanged, listener);
        };
        Model.prototype.addBulkListener = function (listener) {
            return _super.prototype.addBulkListener.call(this, listener);
        };
        Model.createFromString = function (text, options, mode, uri) {
            if (options === void 0) { options = textModel_1.TextModel.DEFAULT_CREATION_OPTIONS; }
            if (mode === void 0) { mode = null; }
            if (uri === void 0) { uri = null; }
            var rawText = textModel_1.TextModel.toRawText(text, options);
            return new Model(rawText, mode, uri);
        };
        Model.prototype.getModeId = function () {
            return this.getMode().getId();
        };
        Model.prototype.destroy = function () {
            this.dispose();
        };
        Model.prototype.dispose = function () {
            this._isDisposing = true;
            delete aliveModels[String(this._associatedResource)];
            this.emit(editorCommon_1.EventType.ModelDispose);
            _super.prototype.dispose.call(this);
            this._isDisposing = false;
            // console.log('ALIVE MODELS: ' + Object.keys(aliveModels).join('\n'));
        };
        Model.prototype.onBeforeAttached = function () {
            this._attachedEditorCount++;
            // Warm up tokens for the editor
            this._warmUpTokens();
        };
        Model.prototype.onBeforeDetached = function () {
            this._attachedEditorCount--;
            // Intentional empty (for now)
        };
        Model.prototype.isAttachedToEditor = function () {
            return this._attachedEditorCount > 0;
        };
        Object.defineProperty(Model.prototype, "uri", {
            get: function () {
                return this._associatedResource;
            },
            enumerable: true,
            configurable: true
        });
        return Model;
    }(editableTextModel_1.EditableTextModel));
    exports.Model = Model;
});

define(__m[316], __M([5,6]), function(nls, data) { return nls.create("vs/editor/common/modes/modesRegistry", data); });
define(__m[317], __M([5,6]), function(nls, data) { return nls.create("vs/editor/common/modes/supports/suggestSupport", data); });
define(__m[318], __M([5,6]), function(nls, data) { return nls.create("vs/editor/common/services/bulkEdit", data); });
define(__m[319], __M([5,6]), function(nls, data) { return nls.create("vs/editor/common/services/modeServiceImpl", data); });
define(__m[320], __M([5,6]), function(nls, data) { return nls.create("vs/editor/common/services/modelServiceImpl", data); });
define(__m[321], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/accessibility/browser/accessibility", data); });
define(__m[322], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/carretOperations/common/carretOperations", data); });
define(__m[323], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/clipboard/browser/clipboard", data); });
define(__m[324], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/comment/common/comment", data); });
define(__m[325], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/contextmenu/browser/contextmenu", data); });
define(__m[326], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/defineKeybinding/browser/defineKeybinding", data); });
define(__m[327], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/find/browser/findWidget", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[328], __M([0,1,327,8,12,10,11,260,98,44,22,128,212]), function (require, exports, nls, errors_1, keyCodes_1, strings, dom, findInput_1, inputBox_1, widget_1, editorBrowser_1, findModel_1) {
    'use strict';
    var NLS_FIND_INPUT_LABEL = nls.localize(0, null);
    var NLS_FIND_INPUT_PLACEHOLDER = nls.localize(1, null);
    var NLS_PREVIOUS_MATCH_BTN_LABEL = nls.localize(2, null);
    var NLS_NEXT_MATCH_BTN_LABEL = nls.localize(3, null);
    var NLS_TOGGLE_SELECTION_FIND_TITLE = nls.localize(4, null);
    var NLS_CLOSE_BTN_LABEL = nls.localize(5, null);
    var NLS_REPLACE_INPUT_LABEL = nls.localize(6, null);
    var NLS_REPLACE_INPUT_PLACEHOLDER = nls.localize(7, null);
    var NLS_REPLACE_BTN_LABEL = nls.localize(8, null);
    var NLS_REPLACE_ALL_BTN_LABEL = nls.localize(9, null);
    var NLS_TOGGLE_REPLACE_MODE_BTN_LABEL = nls.localize(10, null);
    var NLS_MATCHES_COUNT_LIMIT_TITLE = nls.localize(11, null);
    var NLS_MATCHES_LOCATION = nls.localize(12, null);
    var NLS_NO_RESULTS = nls.localize(13, null);
    var FindWidget = (function (_super) {
        __extends(FindWidget, _super);
        function FindWidget(codeEditor, controller, state, contextViewProvider, keybindingService) {
            var _this = this;
            _super.call(this);
            this._codeEditor = codeEditor;
            this._controller = controller;
            this._state = state;
            this._contextViewProvider = contextViewProvider;
            this._keybindingService = keybindingService;
            this._isVisible = false;
            this._isReplaceVisible = false;
            this._register(this._state.addChangeListener(function (e) { return _this._onStateChanged(e); }));
            this._buildDomNode();
            this._updateButtons();
            this.focusTracker = this._register(dom.trackFocus(this._findInput.inputBox.inputElement));
            this.focusTracker.addFocusListener(function () { return _this._reseedFindScope(); });
            this._register(this._codeEditor.onDidChangeConfiguration(function (e) {
                if (e.readOnly) {
                    if (_this._codeEditor.getConfiguration().readOnly) {
                        // Hide replace part if editor becomes read only
                        _this._state.change({ isReplaceRevealed: false }, false);
                    }
                    _this._updateButtons();
                }
            }));
            this._register(this._codeEditor.onDidChangeCursorSelection(function () {
                if (_this._isVisible) {
                    _this._updateToggleSelectionFindButton();
                }
            }));
            this._codeEditor.addOverlayWidget(this);
        }
        FindWidget.prototype._reseedFindScope = function () {
            var selection = this._codeEditor.getSelection();
            if (selection.startLineNumber !== selection.endLineNumber) {
                // Reseed find scope
                this._state.change({ searchScope: selection }, true);
            }
        };
        // ----- IOverlayWidget API
        FindWidget.prototype.getId = function () {
            return FindWidget.ID;
        };
        FindWidget.prototype.getDomNode = function () {
            return this._domNode;
        };
        FindWidget.prototype.getPosition = function () {
            if (this._isVisible) {
                return {
                    preference: editorBrowser_1.OverlayWidgetPositionPreference.TOP_RIGHT_CORNER
                };
            }
            return null;
        };
        // ----- React to state changes
        FindWidget.prototype._onStateChanged = function (e) {
            if (e.searchString) {
                this._findInput.setValue(this._state.searchString);
                this._updateButtons();
            }
            if (e.replaceString) {
                this._replaceInputBox.value = this._state.replaceString;
            }
            if (e.isRevealed) {
                if (this._state.isRevealed) {
                    this._reveal(true);
                }
                else {
                    this._hide(true);
                }
            }
            if (e.isReplaceRevealed) {
                if (this._state.isReplaceRevealed) {
                    if (!this._codeEditor.getConfiguration().readOnly && !this._isReplaceVisible) {
                        this._isReplaceVisible = true;
                        this._updateButtons();
                    }
                }
                else {
                    if (this._isReplaceVisible) {
                        this._isReplaceVisible = false;
                        this._updateButtons();
                    }
                }
            }
            if (e.isRegex) {
                this._findInput.setRegex(this._state.isRegex);
            }
            if (e.wholeWord) {
                this._findInput.setWholeWords(this._state.wholeWord);
            }
            if (e.matchCase) {
                this._findInput.setCaseSensitive(this._state.matchCase);
            }
            if (e.searchScope) {
                if (this._state.searchScope) {
                    this._toggleSelectionFind.checked = true;
                }
                else {
                    this._toggleSelectionFind.checked = false;
                }
                this._updateToggleSelectionFindButton();
            }
            if (e.searchString || e.matchesCount || e.matchesPosition) {
                var showRedOutline = (this._state.searchString.length > 0 && this._state.matchesCount === 0);
                dom.toggleClass(this._domNode, 'no-results', showRedOutline);
                this._updateMatchesCount();
            }
        };
        FindWidget.prototype._updateMatchesCount = function () {
            if (this._state.matchesCount >= findModel_1.MATCHES_LIMIT) {
                this._matchesCount.title = NLS_MATCHES_COUNT_LIMIT_TITLE;
            }
            else {
                this._matchesCount.title = '';
            }
            // remove previous content
            if (this._matchesCount.firstChild) {
                this._matchesCount.removeChild(this._matchesCount.firstChild);
            }
            var label;
            if (this._state.matchesCount > 0) {
                var matchesCount = String(this._state.matchesCount);
                if (this._state.matchesCount >= findModel_1.MATCHES_LIMIT) {
                    matchesCount += '+';
                }
                var matchesPosition = String(this._state.matchesPosition);
                if (matchesPosition === '0') {
                    matchesPosition = '?';
                }
                label = strings.format(NLS_MATCHES_LOCATION, matchesPosition, matchesCount);
            }
            else {
                label = NLS_NO_RESULTS;
            }
            this._matchesCount.appendChild(document.createTextNode(label));
        };
        // ----- actions
        /**
         * If 'selection find' is ON we should not disable the button (its function is to cancel 'selection find').
         * If 'selection find' is OFF we enable the button only if there is a multi line selection.
         */
        FindWidget.prototype._updateToggleSelectionFindButton = function () {
            var selection = this._codeEditor.getSelection();
            var isMultiLineSelection = selection ? (selection.startLineNumber !== selection.endLineNumber) : false;
            var isChecked = this._toggleSelectionFind.checked;
            this._toggleSelectionFind.setEnabled(this._isVisible && (isChecked || isMultiLineSelection));
        };
        FindWidget.prototype._updateButtons = function () {
            this._findInput.setEnabled(this._isVisible);
            this._replaceInputBox.setEnabled(this._isVisible && this._isReplaceVisible);
            this._updateToggleSelectionFindButton();
            this._closeBtn.setEnabled(this._isVisible);
            var findInputIsNonEmpty = (this._state.searchString.length > 0);
            this._prevBtn.setEnabled(this._isVisible && findInputIsNonEmpty);
            this._nextBtn.setEnabled(this._isVisible && findInputIsNonEmpty);
            this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
            this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && findInputIsNonEmpty);
            dom.toggleClass(this._domNode, 'replaceToggled', this._isReplaceVisible);
            this._toggleReplaceBtn.toggleClass('collapse', !this._isReplaceVisible);
            this._toggleReplaceBtn.toggleClass('expand', this._isReplaceVisible);
            this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
            var canReplace = !this._codeEditor.getConfiguration().readOnly;
            this._toggleReplaceBtn.setEnabled(this._isVisible && canReplace);
        };
        FindWidget.prototype._reveal = function (animate) {
            var _this = this;
            if (!this._isVisible) {
                this._isVisible = true;
                this._updateButtons();
                setTimeout(function () {
                    dom.addClass(_this._domNode, 'visible');
                    if (!animate) {
                        dom.addClass(_this._domNode, 'noanimation');
                        setTimeout(function () {
                            dom.removeClass(_this._domNode, 'noanimation');
                        }, 200);
                    }
                }, 0);
                this._codeEditor.layoutOverlayWidget(this);
            }
        };
        FindWidget.prototype._hide = function (focusTheEditor) {
            if (this._isVisible) {
                this._isVisible = false;
                this._updateButtons();
                dom.removeClass(this._domNode, 'visible');
                if (focusTheEditor) {
                    this._codeEditor.focus();
                }
                this._codeEditor.layoutOverlayWidget(this);
            }
        };
        // ----- Public
        FindWidget.prototype.focusFindInput = function () {
            this._findInput.select();
            // Edge browser requires focus() in addition to select()
            this._findInput.focus();
        };
        FindWidget.prototype.focusReplaceInput = function () {
            this._replaceInputBox.select();
            // Edge browser requires focus() in addition to select()
            this._replaceInputBox.focus();
        };
        FindWidget.prototype._onFindInputKeyDown = function (e) {
            switch (e.asKeybinding()) {
                case keyCodes_1.CommonKeybindings.ENTER:
                    this._codeEditor.getAction(findModel_1.FIND_IDS.NextMatchFindAction).run().done(null, errors_1.onUnexpectedError);
                    e.preventDefault();
                    return;
                case keyCodes_1.CommonKeybindings.SHIFT_ENTER:
                    this._codeEditor.getAction(findModel_1.FIND_IDS.PreviousMatchFindAction).run().done(null, errors_1.onUnexpectedError);
                    e.preventDefault();
                    return;
                case keyCodes_1.CommonKeybindings.TAB:
                    if (this._isReplaceVisible) {
                        this._replaceInputBox.focus();
                    }
                    else {
                        this._findInput.focusOnCaseSensitive();
                    }
                    e.preventDefault();
                    return;
                case keyCodes_1.CommonKeybindings.CTRLCMD_DOWN_ARROW:
                    this._codeEditor.focus();
                    e.preventDefault();
                    return;
            }
        };
        FindWidget.prototype._onReplaceInputKeyDown = function (e) {
            switch (e.asKeybinding()) {
                case keyCodes_1.CommonKeybindings.ENTER:
                    this._controller.replace();
                    e.preventDefault();
                    return;
                case keyCodes_1.CommonKeybindings.CTRLCMD_ENTER:
                    this._controller.replaceAll();
                    e.preventDefault();
                    return;
                case keyCodes_1.CommonKeybindings.TAB:
                    this._findInput.focusOnCaseSensitive();
                    e.preventDefault();
                    return;
                case keyCodes_1.CommonKeybindings.SHIFT_TAB:
                    this._findInput.focus();
                    e.preventDefault();
                    return;
                case keyCodes_1.CommonKeybindings.CTRLCMD_DOWN_ARROW:
                    this._codeEditor.focus();
                    e.preventDefault();
                    return;
            }
        };
        // ----- initialization
        FindWidget.prototype._keybindingLabelFor = function (actionId) {
            var keybindings = this._keybindingService.lookupKeybindings(actionId);
            if (keybindings.length === 0) {
                return '';
            }
            return ' (' + this._keybindingService.getLabelFor(keybindings[0]) + ')';
        };
        FindWidget.prototype._buildFindPart = function () {
            var _this = this;
            // Find input
            this._findInput = this._register(new findInput_1.FindInput(null, this._contextViewProvider, {
                width: FindWidget.FIND_INPUT_AREA_WIDTH,
                label: NLS_FIND_INPUT_LABEL,
                placeholder: NLS_FIND_INPUT_PLACEHOLDER,
                appendCaseSensitiveLabel: this._keybindingLabelFor(findModel_1.FIND_IDS.ToggleCaseSensitiveCommand),
                appendWholeWordsLabel: this._keybindingLabelFor(findModel_1.FIND_IDS.ToggleWholeWordCommand),
                appendRegexLabel: this._keybindingLabelFor(findModel_1.FIND_IDS.ToggleRegexCommand),
                validation: function (value) {
                    if (value.length === 0) {
                        return null;
                    }
                    if (!_this._findInput.getRegex()) {
                        return null;
                    }
                    try {
                        /* tslint:disable:no-unused-expression */
                        new RegExp(value);
                        /* tslint:enable:no-unused-expression */
                        return null;
                    }
                    catch (e) {
                        return { content: e.message };
                    }
                }
            }));
            this._register(this._findInput.onKeyDown(function (e) { return _this._onFindInputKeyDown(e); }));
            this._register(this._findInput.onInput(function () {
                _this._state.change({ searchString: _this._findInput.getValue() }, true);
            }));
            this._register(this._findInput.onDidOptionChange(function () {
                _this._state.change({
                    isRegex: _this._findInput.getRegex(),
                    wholeWord: _this._findInput.getWholeWords(),
                    matchCase: _this._findInput.getCaseSensitive()
                }, true);
            }));
            this._register(this._findInput.onCaseSensitiveKeyDown(function (e) {
                if (e.equals(keyCodes_1.CommonKeybindings.SHIFT_TAB)) {
                    if (_this._isReplaceVisible) {
                        _this._replaceInputBox.focus();
                        e.preventDefault();
                    }
                }
            }));
            this._matchesCount = document.createElement('div');
            this._matchesCount.className = 'matchesCount';
            this._updateMatchesCount();
            // Previous button
            this._prevBtn = this._register(new SimpleButton({
                label: NLS_PREVIOUS_MATCH_BTN_LABEL + this._keybindingLabelFor(findModel_1.FIND_IDS.PreviousMatchFindAction),
                className: 'previous',
                onTrigger: function () {
                    _this._codeEditor.getAction(findModel_1.FIND_IDS.PreviousMatchFindAction).run().done(null, errors_1.onUnexpectedError);
                },
                onKeyDown: function (e) { }
            }));
            // Next button
            this._nextBtn = this._register(new SimpleButton({
                label: NLS_NEXT_MATCH_BTN_LABEL + this._keybindingLabelFor(findModel_1.FIND_IDS.NextMatchFindAction),
                className: 'next',
                onTrigger: function () {
                    _this._codeEditor.getAction(findModel_1.FIND_IDS.NextMatchFindAction).run().done(null, errors_1.onUnexpectedError);
                },
                onKeyDown: function (e) { }
            }));
            var findPart = document.createElement('div');
            findPart.className = 'find-part';
            findPart.appendChild(this._findInput.domNode);
            findPart.appendChild(this._matchesCount);
            findPart.appendChild(this._prevBtn.domNode);
            findPart.appendChild(this._nextBtn.domNode);
            // Toggle selection button
            this._toggleSelectionFind = this._register(new SimpleCheckbox({
                parent: findPart,
                title: NLS_TOGGLE_SELECTION_FIND_TITLE,
                onChange: function () {
                    if (_this._toggleSelectionFind.checked) {
                        _this._reseedFindScope();
                    }
                    else {
                        _this._state.change({ searchScope: null }, true);
                    }
                }
            }));
            // Close button
            this._closeBtn = this._register(new SimpleButton({
                label: NLS_CLOSE_BTN_LABEL + this._keybindingLabelFor(findModel_1.FIND_IDS.CloseFindWidgetCommand),
                className: 'close-fw',
                onTrigger: function () {
                    _this._state.change({ isRevealed: false }, false);
                },
                onKeyDown: function (e) {
                    if (e.equals(keyCodes_1.CommonKeybindings.TAB)) {
                        if (_this._isReplaceVisible) {
                            if (_this._replaceBtn.isEnabled()) {
                                _this._replaceBtn.focus();
                            }
                            else {
                                _this._codeEditor.focus();
                            }
                            e.preventDefault();
                        }
                    }
                }
            }));
            findPart.appendChild(this._closeBtn.domNode);
            return findPart;
        };
        FindWidget.prototype._buildReplacePart = function () {
            var _this = this;
            // Replace input
            var replaceInput = document.createElement('div');
            replaceInput.className = 'replace-input';
            replaceInput.style.width = FindWidget.REPLACE_INPUT_AREA_WIDTH + 'px';
            this._replaceInputBox = this._register(new inputBox_1.InputBox(replaceInput, null, {
                ariaLabel: NLS_REPLACE_INPUT_LABEL,
                placeholder: NLS_REPLACE_INPUT_PLACEHOLDER
            }));
            this._register(dom.addStandardDisposableListener(this._replaceInputBox.inputElement, 'keydown', function (e) { return _this._onReplaceInputKeyDown(e); }));
            this._register(dom.addStandardDisposableListener(this._replaceInputBox.inputElement, 'input', function (e) {
                _this._state.change({ replaceString: _this._replaceInputBox.value }, false);
            }));
            // Replace one button
            this._replaceBtn = this._register(new SimpleButton({
                label: NLS_REPLACE_BTN_LABEL + this._keybindingLabelFor(findModel_1.FIND_IDS.ReplaceOneAction),
                className: 'replace',
                onTrigger: function () {
                    _this._controller.replace();
                },
                onKeyDown: function (e) {
                    if (e.equals(keyCodes_1.CommonKeybindings.SHIFT_TAB)) {
                        _this._closeBtn.focus();
                        e.preventDefault();
                    }
                }
            }));
            // Replace all button
            this._replaceAllBtn = this._register(new SimpleButton({
                label: NLS_REPLACE_ALL_BTN_LABEL + this._keybindingLabelFor(findModel_1.FIND_IDS.ReplaceAllAction),
                className: 'replace-all',
                onTrigger: function () {
                    _this._controller.replaceAll();
                },
                onKeyDown: function (e) { }
            }));
            var replacePart = document.createElement('div');
            replacePart.className = 'replace-part';
            replacePart.appendChild(replaceInput);
            replacePart.appendChild(this._replaceBtn.domNode);
            replacePart.appendChild(this._replaceAllBtn.domNode);
            return replacePart;
        };
        FindWidget.prototype._buildDomNode = function () {
            var _this = this;
            // Find part
            var findPart = this._buildFindPart();
            // Replace part
            var replacePart = this._buildReplacePart();
            // Toggle replace button
            this._toggleReplaceBtn = this._register(new SimpleButton({
                label: NLS_TOGGLE_REPLACE_MODE_BTN_LABEL,
                className: 'toggle left',
                onTrigger: function () {
                    _this._state.change({ isReplaceRevealed: !_this._isReplaceVisible }, true);
                },
                onKeyDown: function (e) { }
            }));
            this._toggleReplaceBtn.toggleClass('expand', this._isReplaceVisible);
            this._toggleReplaceBtn.toggleClass('collapse', !this._isReplaceVisible);
            this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
            // Widget
            this._domNode = document.createElement('div');
            this._domNode.className = 'editor-widget find-widget';
            this._domNode.setAttribute('aria-hidden', 'false');
            this._domNode.appendChild(this._toggleReplaceBtn.domNode);
            this._domNode.appendChild(findPart);
            this._domNode.appendChild(replacePart);
        };
        FindWidget.ID = 'editor.contrib.findWidget';
        FindWidget.PART_WIDTH = 275;
        FindWidget.FIND_INPUT_AREA_WIDTH = FindWidget.PART_WIDTH - 54;
        FindWidget.REPLACE_INPUT_AREA_WIDTH = FindWidget.FIND_INPUT_AREA_WIDTH;
        return FindWidget;
    }(widget_1.Widget));
    exports.FindWidget = FindWidget;
    var SimpleCheckbox = (function (_super) {
        __extends(SimpleCheckbox, _super);
        function SimpleCheckbox(opts) {
            var _this = this;
            _super.call(this);
            this._opts = opts;
            this._domNode = document.createElement('div');
            this._domNode.className = 'monaco-checkbox';
            this._domNode.title = this._opts.title;
            this._checkbox = document.createElement('input');
            this._checkbox.type = 'checkbox';
            this._checkbox.className = 'checkbox';
            this._checkbox.id = 'checkbox-' + SimpleCheckbox._COUNTER++;
            this._label = document.createElement('label');
            this._label.className = 'label';
            // Connect the label and the checkbox. Checkbox will get checked when the label recieves a click.
            this._label.htmlFor = this._checkbox.id;
            this._domNode.appendChild(this._checkbox);
            this._domNode.appendChild(this._label);
            this._opts.parent.appendChild(this._domNode);
            this.onchange(this._checkbox, function (e) {
                _this._opts.onChange();
            });
        }
        Object.defineProperty(SimpleCheckbox.prototype, "domNode", {
            get: function () {
                return this._domNode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SimpleCheckbox.prototype, "checked", {
            get: function () {
                return this._checkbox.checked;
            },
            set: function (newValue) {
                this._checkbox.checked = newValue;
            },
            enumerable: true,
            configurable: true
        });
        SimpleCheckbox.prototype.focus = function () {
            this._checkbox.focus();
        };
        SimpleCheckbox.prototype.enable = function () {
            this._checkbox.removeAttribute('disabled');
        };
        SimpleCheckbox.prototype.disable = function () {
            this._checkbox.disabled = true;
        };
        SimpleCheckbox.prototype.setEnabled = function (enabled) {
            if (enabled) {
                this.enable();
            }
            else {
                this.disable();
            }
        };
        SimpleCheckbox._COUNTER = 0;
        return SimpleCheckbox;
    }(widget_1.Widget));
    var SimpleButton = (function (_super) {
        __extends(SimpleButton, _super);
        function SimpleButton(opts) {
            var _this = this;
            _super.call(this);
            this._opts = opts;
            this._domNode = document.createElement('div');
            this._domNode.title = this._opts.label;
            this._domNode.tabIndex = 0;
            this._domNode.className = 'button ' + this._opts.className;
            this._domNode.setAttribute('role', 'button');
            this._domNode.setAttribute('aria-label', this._opts.label);
            this.onclick(this._domNode, function (e) {
                _this._opts.onTrigger();
                e.preventDefault();
            });
            this.onkeydown(this._domNode, function (e) {
                if (e.equals(keyCodes_1.CommonKeybindings.SPACE) || e.equals(keyCodes_1.CommonKeybindings.ENTER)) {
                    _this._opts.onTrigger();
                    e.preventDefault();
                    return;
                }
                _this._opts.onKeyDown(e);
            });
        }
        Object.defineProperty(SimpleButton.prototype, "domNode", {
            get: function () {
                return this._domNode;
            },
            enumerable: true,
            configurable: true
        });
        SimpleButton.prototype.isEnabled = function () {
            return (this._domNode.tabIndex >= 0);
        };
        SimpleButton.prototype.focus = function () {
            this._domNode.focus();
        };
        SimpleButton.prototype.setEnabled = function (enabled) {
            dom.toggleClass(this._domNode, 'disabled', !enabled);
            this._domNode.setAttribute('aria-disabled', String(!enabled));
            this._domNode.tabIndex = enabled ? 0 : -1;
        };
        SimpleButton.prototype.setExpanded = function (expanded) {
            this._domNode.setAttribute('aria-expanded', String(expanded));
        };
        SimpleButton.prototype.toggleClass = function (className, shouldHaveIt) {
            dom.toggleClass(this._domNode, className, shouldHaveIt);
        };
        return SimpleButton;
    }(widget_1.Widget));
});

define(__m[329], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/find/common/findController", data); });
define(__m[330], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/folding/browser/folding", data); });
define(__m[331], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/format/common/formatActions", data); });
define(__m[332], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/goToDeclaration/browser/goToDeclaration", data); });
define(__m[333], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/gotoError/browser/gotoError", data); });
define(__m[334], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/hover/browser/hover", data); });
define(__m[335], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/hover/browser/modesContentHover", data); });
define(__m[336], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/inPlaceReplace/common/inPlaceReplace", data); });
define(__m[337], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/indentation/common/indentation", data); });
define(__m[338], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/linesOperations/common/linesOperations", data); });
define(__m[339], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/links/browser/links", data); });
define(__m[340], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/multicursor/common/multicursor", data); });
define(__m[341], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/parameterHints/browser/parameterHints", data); });
define(__m[342], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/parameterHints/browser/parameterHintsWidget", data); });
define(__m[343], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/quickFix/browser/quickFix", data); });
define(__m[344], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/quickFix/browser/quickFixSelectionWidget", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[345], __M([0,1,344,8,2,11,75,106,22,81,41,3,230]), function (require, exports, nls, errors_1, winjs_base_1, dom, treeDefaults_1, treeImpl_1, editorBrowser_1, aria_1, scrollableElementOptions_1, lifecycle_1) {
    'use strict';
    var $ = dom.emmet;
    function isQuickFix(quickfix) {
        return quickfix
            && typeof quickfix.command === 'object'
            && typeof quickfix.command.title === 'string';
    }
    function getAriaAlertLabel(item) {
        return nls.localize(0, null, item.command.title);
    }
    // To be used as a tree element when we want to show a message
    var Message = (function () {
        function Message(parent, message) {
            this.parent = parent;
            this.message = message;
            // nothing to do
        }
        return Message;
    }());
    exports.Message = Message;
    var MessageRoot = (function () {
        function MessageRoot(message) {
            this.child = new Message(this, message);
        }
        return MessageRoot;
    }());
    exports.MessageRoot = MessageRoot;
    var DataSource = (function () {
        function DataSource() {
            this.root = null;
        }
        DataSource.prototype.isRoot = function (element) {
            if (element instanceof MessageRoot) {
                return true;
            }
            else if (element instanceof Message) {
                return false;
            }
            else if (Array.isArray(element)) {
                this.root = element;
                return true;
            }
            else {
                return false;
            }
        };
        DataSource.prototype.getId = function (tree, element) {
            if (element instanceof MessageRoot) {
                return 'messageroot';
            }
            else if (element instanceof Message) {
                return 'message' + element.message;
            }
            else if (Array.isArray(element)) {
                return 'root';
            }
            else if (isQuickFix(element)) {
                return element.id;
            }
            else {
                throw errors_1.illegalArgument('element');
            }
        };
        DataSource.prototype.getParent = function (tree, element) {
            if (element instanceof MessageRoot) {
                return winjs_base_1.TPromise.as(null);
            }
            else if (element instanceof Message) {
                return winjs_base_1.TPromise.as(element.parent);
            }
            return winjs_base_1.TPromise.as(this.isRoot(element) ? null : this.root);
        };
        DataSource.prototype.getChildren = function (tree, element) {
            if (element instanceof MessageRoot) {
                return winjs_base_1.TPromise.as([element.child]);
            }
            else if (element instanceof Message) {
                return winjs_base_1.TPromise.as([]);
            }
            return winjs_base_1.TPromise.as(this.isRoot(element) ? element : []);
        };
        DataSource.prototype.hasChildren = function (tree, element) {
            return this.isRoot(element);
        };
        return DataSource;
    }());
    var Controller = (function (_super) {
        __extends(Controller, _super);
        function Controller() {
            _super.apply(this, arguments);
        }
        /* protected */ Controller.prototype.onLeftClick = function (tree, element, event) {
            event.preventDefault();
            event.stopPropagation();
            if (!(element instanceof Message)) {
                tree.setSelection([element], { origin: 'mouse' });
            }
            return true;
        };
        return Controller;
    }(treeDefaults_1.DefaultController));
    var AccessibilityProvider = (function () {
        function AccessibilityProvider() {
        }
        AccessibilityProvider.prototype.getAriaLabel = function (tree, element) {
            if (isQuickFix(element)) {
                return getAriaAlertLabel(element);
            }
        };
        return AccessibilityProvider;
    }());
    exports.AccessibilityProvider = AccessibilityProvider;
    function getHeight(tree, element) {
        // var fix = <IQuickFix2>element;
        // if (!(element instanceof Message) && !!fix.documentation && tree.isFocused(fix)) {
        // 	return 35;
        // }
        return 19;
    }
    var Renderer = (function () {
        function Renderer() {
        }
        Renderer.prototype.getHeight = function (tree, element) {
            return getHeight(tree, element);
        };
        Renderer.prototype.getTemplateId = function (tree, element) {
            return element instanceof Message ? 'message' : 'default';
        };
        Renderer.prototype.renderTemplate = function (tree, templateId, container) {
            if (templateId === 'message') {
                var messageElement = dom.append(container, $('span'));
                messageElement.style.opacity = '0.7';
                messageElement.style.paddingLeft = '12px';
                return { element: messageElement };
            }
            var result = {};
            var text = dom.append(container, $('.text'));
            result['main'] = dom.append(text, $('.main'));
            var docs = dom.append(text, $('.docs'));
            result['documentationLabel'] = dom.append(docs, $('span.docs-label'));
            return result;
        };
        Renderer.prototype.renderElement = function (tree, element, templateId, templateData) {
            if (templateId === 'message') {
                templateData.element.textContent = element.message;
                return;
            }
            var quickFix = element;
            templateData.main.textContent = quickFix.command.title;
            templateData.documentationLabel.textContent = '';
        };
        Renderer.prototype.disposeTemplate = function (tree, templateId, templateData) {
            // noop
        };
        return Renderer;
    }());
    var QuickFixSelectionWidget = (function () {
        function QuickFixSelectionWidget(editor, telemetryService, onShown, onHidden) {
            var _this = this;
            // Editor.IContentWidget.allowEditorOverflow
            this.allowEditorOverflow = true;
            this.editor = editor;
            this._onShown = onShown;
            this._onHidden = onHidden;
            this.shouldShowEmptyList = true;
            this.isActive = false;
            this.isLoading = false;
            this.isAuto = false;
            this.modelListenersToRemove = [];
            this.model = null;
            this.telemetryData = Object.create(null);
            this.telemetryService = telemetryService;
            this.listenersToRemove = [];
            this.domnode = $('.editor-widget.quickfix-widget.monaco-editor-background.no-icons');
            this.domnode.style.width = QuickFixSelectionWidget.WIDTH + 'px';
            this.tree = new treeImpl_1.Tree(this.domnode, {
                dataSource: new DataSource(),
                renderer: new Renderer(),
                controller: new Controller(),
                accessibilityProvider: new AccessibilityProvider()
            }, {
                twistiePixels: 0,
                alwaysFocused: true,
                verticalScrollMode: scrollableElementOptions_1.ScrollbarVisibility.Visible,
                useShadows: false,
                ariaLabel: nls.localize(3, null)
            });
            this.listenersToRemove.push(this.tree.addListener2('selection', function (e) {
                if (e.selection && e.selection.length > 0) {
                    var element = e.selection[0];
                    if (isQuickFix(element) && !(element instanceof MessageRoot) && !(element instanceof Message)) {
                        _this.telemetryData.selectedIndex = _this.tree.getInput().indexOf(element);
                        _this.telemetryData.wasCancelled = false;
                        _this.submitTelemetryData();
                        aria_1.alert(nls.localize(4, null, element.command.title));
                        _this.model.accept(element, _this.range);
                        _this.editor.focus();
                    }
                }
            }));
            var oldFocus = null;
            this.listenersToRemove.push(this.tree.addListener2('focus', function (e) {
                var focus = e.focus;
                var payload = e.payload;
                if (focus === oldFocus) {
                    return;
                }
                var elementsToRefresh = [];
                if (oldFocus) {
                    elementsToRefresh.push(oldFocus);
                }
                if (focus) {
                    elementsToRefresh.push(focus);
                    if (isQuickFix(focus)) {
                        _this._ariaAlert(getAriaAlertLabel(focus));
                    }
                }
                oldFocus = focus;
                _this.tree.refreshAll(elementsToRefresh).done(function () {
                    _this.updateWidgetHeight();
                    if (focus) {
                        return _this.tree.reveal(focus, (payload && payload.firstSuggestion) ? 0 : null);
                    }
                }, errors_1.onUnexpectedError);
            }));
            this.editor.addContentWidget(this);
            this.listenersToRemove.push(this.editor.onDidChangeCursorSelection(function (e) {
                if (_this.isActive) {
                    _this.editor.layoutContentWidget(_this);
                }
            }));
            this.hide();
        }
        QuickFixSelectionWidget.prototype._ariaAlert = function (newAriaAlertLabel) {
            if (this._lastAriaAlertLabel === newAriaAlertLabel) {
                return;
            }
            this._lastAriaAlertLabel = newAriaAlertLabel;
            if (this._lastAriaAlertLabel) {
                aria_1.alert(this._lastAriaAlertLabel);
            }
        };
        QuickFixSelectionWidget.prototype.setModel = function (newModel) {
            var _this = this;
            this.releaseModel();
            this.model = newModel;
            var timer = null, loadingHandle;
            this.modelListenersToRemove.push(this.model.addListener2('loading', function (e) {
                if (!_this.isActive) {
                    timer = _this.telemetryService.timedPublicLog('QuickFixSelectionWidgetLoadingTime');
                    _this.isLoading = true;
                    _this.isAuto = !!e.auto;
                    if (!_this.isAuto) {
                        loadingHandle = setTimeout(function () {
                            dom.removeClass(_this.domnode, 'empty');
                            _this.tree.setInput(QuickFixSelectionWidget.LOADING_MESSAGE).done(null, errors_1.onUnexpectedError);
                            _this.updateWidgetHeight();
                            _this.show();
                        }, 50);
                    }
                    if (!e.retrigger) {
                        _this.telemetryData = {
                            wasAutomaticallyTriggered: e.characterTriggered
                        };
                    }
                }
            }));
            this.modelListenersToRemove.push(this.model.addListener2('suggest', function (e) {
                _this.isLoading = false;
                if (typeof loadingHandle !== 'undefined') {
                    clearTimeout(loadingHandle);
                    loadingHandle = void 0;
                }
                var fixes = e.fixes;
                var bestFixIndex = -1;
                var bestFix = fixes[0];
                var bestScore = -1;
                for (var i = 0, len = fixes.length; i < len; i++) {
                    var fix = fixes[i];
                    var score = fix.score;
                    if (score > bestScore) {
                        bestScore = score;
                        bestFix = fix;
                        bestFixIndex = i;
                    }
                }
                dom.removeClass(_this.domnode, 'empty');
                _this.tree.setInput(fixes).done(null, errors_1.onUnexpectedError);
                _this.tree.setFocus(bestFix, { firstSuggestion: true });
                _this.updateWidgetHeight();
                _this.range = e.range;
                _this.show();
                _this.telemetryData = _this.telemetryData || {};
                _this.telemetryData.suggestionCount = fixes.length;
                _this.telemetryData.suggestedIndex = bestFixIndex;
                if (timer) {
                    timer.data = { reason: 'results' };
                    timer.stop();
                    timer = null;
                }
            }));
            this.modelListenersToRemove.push(this.model.addListener2('empty', function (e) {
                var wasLoading = _this.isLoading;
                _this.isLoading = false;
                if (typeof loadingHandle !== 'undefined') {
                    clearTimeout(loadingHandle);
                    loadingHandle = void 0;
                }
                if (e.auto) {
                    _this.hide();
                }
                else if (wasLoading) {
                    if (_this.shouldShowEmptyList) {
                        dom.removeClass(_this.domnode, 'empty');
                        _this.tree.setInput(QuickFixSelectionWidget.NO_SUGGESTIONS_MESSAGE).done(null, errors_1.onUnexpectedError);
                        _this.updateWidgetHeight();
                        _this.show();
                    }
                    else {
                        _this.hide();
                    }
                }
                else {
                    dom.addClass(_this.domnode, 'empty');
                }
                if (timer) {
                    timer.data = { reason: 'empty' };
                    timer.stop();
                    timer = null;
                }
            }));
            this.modelListenersToRemove.push(this.model.addListener2('cancel', function (e) {
                _this.isLoading = false;
                if (typeof loadingHandle !== 'undefined') {
                    clearTimeout(loadingHandle);
                    loadingHandle = void 0;
                }
                if (!e.retrigger) {
                    _this.hide();
                    if (_this.telemetryData) {
                        _this.telemetryData.selectedIndex = -1;
                        _this.telemetryData.wasCancelled = true;
                        _this.submitTelemetryData();
                    }
                }
                if (timer) {
                    timer.data = { reason: 'cancel' };
                    timer.stop();
                    timer = null;
                }
            }));
        };
        QuickFixSelectionWidget.prototype.selectNextPage = function () {
            if (this.isLoading) {
                return !this.isAuto;
            }
            if (this.isActive) {
                this.tree.focusNextPage();
                return true;
            }
            return false;
        };
        QuickFixSelectionWidget.prototype.selectNext = function () {
            if (this.isLoading) {
                return !this.isAuto;
            }
            if (this.isActive) {
                var focus = this.tree.getFocus();
                this.tree.focusNext(1);
                if (focus === this.tree.getFocus()) {
                    this.tree.focusFirst();
                }
                return true;
            }
            return false;
        };
        QuickFixSelectionWidget.prototype.selectPreviousPage = function () {
            if (this.isLoading) {
                return !this.isAuto;
            }
            if (this.isActive) {
                this.tree.focusPreviousPage();
                return true;
            }
            return false;
        };
        QuickFixSelectionWidget.prototype.selectPrevious = function () {
            if (this.isLoading) {
                return !this.isAuto;
            }
            if (this.isActive) {
                var focus = this.tree.getFocus();
                this.tree.focusPrevious(1);
                if (focus === this.tree.getFocus()) {
                    this.tree.focusLast();
                }
                return true;
            }
            return false;
        };
        QuickFixSelectionWidget.prototype.acceptSelectedSuggestion = function () {
            if (this.isLoading) {
                return !this.isAuto;
            }
            if (this.isActive) {
                var focus = this.tree.getFocus();
                if (focus) {
                    this.tree.setSelection([focus]);
                }
                else {
                    this.model.cancelDialog();
                }
                return true;
            }
            return false;
        };
        QuickFixSelectionWidget.prototype.releaseModel = function () {
            this.modelListenersToRemove = lifecycle_1.dispose(this.modelListenersToRemove);
            this.model = null;
        };
        QuickFixSelectionWidget.prototype.show = function () {
            this.isActive = true;
            this.tree.layout();
            this.editor.layoutContentWidget(this);
            this._onShown();
        };
        QuickFixSelectionWidget.prototype.hide = function () {
            this._onHidden();
            this.isActive = false;
            this.editor.layoutContentWidget(this);
        };
        QuickFixSelectionWidget.prototype.getPosition = function () {
            if (this.isActive) {
                return {
                    position: this.editor.getPosition(),
                    preference: [editorBrowser_1.ContentWidgetPositionPreference.BELOW, editorBrowser_1.ContentWidgetPositionPreference.ABOVE]
                };
            }
            return null;
        };
        QuickFixSelectionWidget.prototype.getDomNode = function () {
            return this.domnode;
        };
        QuickFixSelectionWidget.prototype.getId = function () {
            return QuickFixSelectionWidget.ID;
        };
        QuickFixSelectionWidget.prototype.submitTelemetryData = function () {
            this.telemetryService.publicLog('QuickFixSelectionWidget', this.telemetryData);
            this.telemetryData = Object.create(null);
        };
        QuickFixSelectionWidget.prototype.updateWidgetHeight = function () {
            var input = this.tree.getInput();
            var height;
            if (input === QuickFixSelectionWidget.LOADING_MESSAGE || input === QuickFixSelectionWidget.NO_SUGGESTIONS_MESSAGE) {
                height = 19;
            }
            else {
                var fixes = input;
                height = Math.min(fixes.length - 1, 11) * 19;
                var focus = this.tree.getFocus();
                height += focus ? getHeight(this.tree, focus) : 19;
            }
            this.domnode.style.height = height + 'px';
            this.tree.layout(height);
            this.editor.layoutContentWidget(this);
        };
        QuickFixSelectionWidget.prototype.destroy = function () {
            this.releaseModel();
            this.domnode = null;
            this.tree.dispose();
            this.tree = null;
            this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);
        };
        QuickFixSelectionWidget.ID = 'editor.widget.QuickFixSelectionWidget';
        QuickFixSelectionWidget.WIDTH = 360;
        QuickFixSelectionWidget.LOADING_MESSAGE = new MessageRoot(nls.localize(1, null));
        QuickFixSelectionWidget.NO_SUGGESTIONS_MESSAGE = new MessageRoot(nls.localize(2, null));
        return QuickFixSelectionWidget;
    }());
    exports.QuickFixSelectionWidget = QuickFixSelectionWidget;
});

define(__m[346], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/quickOpen/browser/gotoLine", data); });
define(__m[347], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/quickOpen/browser/gotoLine.contribution", data); });
define(__m[348], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/quickOpen/browser/quickCommand", data); });
define(__m[349], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/quickOpen/browser/quickCommand.contribution", data); });
define(__m[350], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/quickOpen/browser/quickOutline", data); });
define(__m[351], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/quickOpen/browser/quickOutline.contribution", data); });
define(__m[352], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/referenceSearch/browser/referenceSearch", data); });
define(__m[353], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/referenceSearch/browser/referencesController", data); });
define(__m[354], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/referenceSearch/browser/referencesWidget", data); });
define(__m[355], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/rename/browser/rename", data); });
define(__m[356], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/rename/browser/renameInputField", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[357], __M([0,1,356,8,3,2,4,22,239]), function (require, exports, nls_1, errors_1, lifecycle_1, winjs_base_1, range_1, editorBrowser_1) {
    'use strict';
    var RenameInputField = (function () {
        function RenameInputField(editor) {
            // Editor.IContentWidget.allowEditorOverflow
            this.allowEditorOverflow = true;
            this._currentAcceptInput = null;
            this._currentCancelInput = null;
            this._editor = editor;
            this._editor.addContentWidget(this);
        }
        RenameInputField.prototype.dispose = function () {
            this._editor.removeContentWidget(this);
        };
        RenameInputField.prototype.getId = function () {
            return '__renameInputWidget';
        };
        RenameInputField.prototype.getDomNode = function () {
            if (!this._domNode) {
                this._inputField = document.createElement('input');
                this._inputField.className = 'rename-input';
                this._inputField.type = 'text';
                this._inputField.setAttribute('aria-label', nls_1.localize(0, null));
                this._domNode = document.createElement('div');
                this._domNode.style.height = this._editor.getConfiguration().lineHeight + "px";
                this._domNode.className = 'monaco-editor rename-box';
                this._domNode.appendChild(this._inputField);
            }
            return this._domNode;
        };
        RenameInputField.prototype.getPosition = function () {
            return this._visible
                ? { position: this._position, preference: [editorBrowser_1.ContentWidgetPositionPreference.BELOW, editorBrowser_1.ContentWidgetPositionPreference.ABOVE] }
                : null;
        };
        RenameInputField.prototype.acceptInput = function () {
            if (this._currentAcceptInput) {
                this._currentAcceptInput();
            }
        };
        RenameInputField.prototype.cancelInput = function () {
            if (this._currentCancelInput) {
                this._currentCancelInput();
            }
        };
        RenameInputField.prototype.getInput = function (where, value, selectionStart, selectionEnd) {
            var _this = this;
            this._position = { lineNumber: where.startLineNumber, column: where.startColumn };
            this._inputField.value = value;
            this._inputField.setAttribute('selectionStart', selectionStart.toString());
            this._inputField.setAttribute('selectionEnd', selectionEnd.toString());
            this._inputField.size = Math.max((where.endColumn - where.startColumn) * 1.1, 20);
            var disposeOnDone = [], always;
            always = function () {
                lifecycle_1.dispose(disposeOnDone);
                _this._hide();
            };
            return new winjs_base_1.TPromise(function (c, e) {
                _this._currentCancelInput = function () {
                    _this._currentAcceptInput = null;
                    _this._currentCancelInput = null;
                    e(errors_1.canceled());
                    return true;
                };
                _this._currentAcceptInput = function () {
                    if (_this._inputField.value.trim().length === 0 || _this._inputField.value === value) {
                        // empty or whitespace only or not changed
                        _this._currentCancelInput();
                        return;
                    }
                    _this._currentAcceptInput = null;
                    _this._currentCancelInput = null;
                    c(_this._inputField.value);
                };
                var onCursorChanged = function () {
                    if (!range_1.Range.containsPosition(where, _this._editor.getPosition())) {
                        _this._currentCancelInput();
                    }
                };
                disposeOnDone.push(_this._editor.onDidChangeCursorSelection(onCursorChanged));
                disposeOnDone.push(_this._editor.onDidBlurEditor(_this._currentCancelInput));
                _this._show();
            }, this._currentCancelInput).then(function (newValue) {
                always();
                return newValue;
            }, function (err) {
                always();
                return winjs_base_1.TPromise.wrapError(err);
            });
        };
        RenameInputField.prototype._show = function () {
            var _this = this;
            this._editor.revealLineInCenterIfOutsideViewport(this._position.lineNumber);
            this._visible = true;
            this._editor.layoutContentWidget(this);
            setTimeout(function () {
                _this._inputField.focus();
                _this._inputField.setSelectionRange(parseInt(_this._inputField.getAttribute('selectionStart')), parseInt(_this._inputField.getAttribute('selectionEnd')));
            }, 25);
        };
        RenameInputField.prototype._hide = function () {
            this._visible = false;
            this._editor.layoutContentWidget(this);
        };
        return RenameInputField;
    }());
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = RenameInputField;
});

define(__m[358], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/rename/common/rename", data); });
define(__m[359], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/smartSelect/common/jumpToBracket", data); });
define(__m[360], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/smartSelect/common/smartSelect", data); });
define(__m[361], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/suggest/browser/suggest", data); });
define(__m[362], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/suggest/browser/suggestWidget", data); });
define(__m[363], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/toggleTabFocusMode/common/toggleTabFocusMode", data); });
define(__m[364], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/toggleWordWrap/common/toggleWordWrap", data); });
define(__m[365], __M([5,6]), function(nls, data) { return nls.create("vs/editor/contrib/zoneWidget/browser/peekViewWidget", data); });
define(__m[366], __M([5,6]), function(nls, data) { return nls.create("vs/languages/html/common/html.contribution", data); });
define(__m[367], __M([5,6]), function(nls, data) { return nls.create("vs/platform/actions/browser/menuItemActionItem", data); });
define(__m[368], __M([5,6]), function(nls, data) { return nls.create("vs/platform/configuration/common/configurationRegistry", data); });
define(__m[369], __M([5,6]), function(nls, data) { return nls.create("vs/platform/extensions/common/abstractExtensionService", data); });
define(__m[370], __M([5,6]), function(nls, data) { return nls.create("vs/platform/extensions/common/extensionsRegistry", data); });
define(__m[371], __M([5,6]), function(nls, data) { return nls.create("vs/platform/jsonschemas/common/jsonContributionRegistry", data); });
define(__m[372], __M([5,6]), function(nls, data) { return nls.create("vs/platform/keybinding/browser/keybindingServiceImpl", data); });
define(__m[373], __M([5,6]), function(nls, data) { return nls.create("vs/platform/message/common/message", data); });
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[374], __M([0,1,35,3,39,50,253,60,32,245]), function (require, exports, builder_1, lifecycle_1, mouseEvent_1, actions_1, menu_1, events_1, severity_1) {
    'use strict';
    var ContextMenuHandler = (function () {
        function ContextMenuHandler(element, contextViewService, telemetryService, messageService) {
            var _this = this;
            this.setContainer(element);
            this.contextViewService = contextViewService;
            this.telemetryService = telemetryService;
            this.messageService = messageService;
            this.actionRunner = new actions_1.ActionRunner();
            this.menuContainerElement = null;
            this.toDispose = [];
            var hideViewOnRun = false;
            this.toDispose.push(this.actionRunner.addListener2(events_1.EventType.BEFORE_RUN, function (e) {
                if (_this.telemetryService) {
                    _this.telemetryService.publicLog('workbenchActionExecuted', { id: e.action.id, From: 'contextMenu' });
                }
                hideViewOnRun = !!e.retainActionItem;
                if (!hideViewOnRun) {
                    _this.contextViewService.hideContextView(false);
                }
            }));
            this.toDispose.push(this.actionRunner.addListener2(events_1.EventType.RUN, function (e) {
                if (hideViewOnRun) {
                    _this.contextViewService.hideContextView(false);
                }
                hideViewOnRun = false;
                if (e.error && _this.messageService) {
                    _this.messageService.show(severity_1.default.Error, e.error);
                }
            }));
        }
        ContextMenuHandler.prototype.setContainer = function (container) {
            var _this = this;
            if (this.$el) {
                this.$el.off(['click', 'mousedown']);
                this.$el = null;
            }
            if (container) {
                this.$el = builder_1.$(container);
                this.$el.on('mousedown', function (e) { return _this.onMouseDown(e); });
            }
        };
        ContextMenuHandler.prototype.showContextMenu = function (delegate) {
            var _this = this;
            delegate.getActions().done(function (actions) {
                _this.contextViewService.showContextView({
                    getAnchor: function () { return delegate.getAnchor(); },
                    canRelayout: false,
                    render: function (container) {
                        _this.menuContainerElement = container;
                        var className = delegate.getMenuClassName ? delegate.getMenuClassName() : '';
                        if (className) {
                            container.className += ' ' + className;
                        }
                        var menu = new menu_1.Menu(container, actions, {
                            actionItemProvider: delegate.getActionItem,
                            context: delegate.getActionsContext ? delegate.getActionsContext() : null,
                            actionRunner: _this.actionRunner
                        });
                        var listener1 = menu.addListener2(events_1.EventType.CANCEL, function (e) {
                            _this.contextViewService.hideContextView(true);
                        });
                        var listener2 = menu.addListener2(events_1.EventType.BLUR, function (e) {
                            _this.contextViewService.hideContextView(true);
                        });
                        menu.focus();
                        return lifecycle_1.combinedDisposable(listener1, listener2, menu);
                    },
                    onHide: function (didCancel) {
                        if (delegate.onHide) {
                            delegate.onHide(didCancel);
                        }
                        _this.menuContainerElement = null;
                    }
                });
            });
        };
        ContextMenuHandler.prototype.onMouseDown = function (e) {
            if (!this.menuContainerElement) {
                return;
            }
            var event = new mouseEvent_1.StandardMouseEvent(e);
            var element = event.target;
            while (element) {
                if (element === this.menuContainerElement) {
                    return;
                }
                element = element.parentElement;
            }
            this.contextViewService.hideContextView();
        };
        ContextMenuHandler.prototype.dispose = function () {
            this.setContainer(null);
        };
        return ContextMenuHandler;
    }());
    exports.ContextMenuHandler = ContextMenuHandler;
});






define(__m[68], __M([0,1,8]), function (require, exports, errors_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var AbstractDescriptor = (function () {
        function AbstractDescriptor(_staticArguments) {
            this._staticArguments = _staticArguments;
            // empty
        }
        AbstractDescriptor.prototype.appendStaticArguments = function (more) {
            this._staticArguments.push.apply(this._staticArguments, more);
        };
        AbstractDescriptor.prototype.staticArguments = function (nth) {
            if (isNaN(nth)) {
                return this._staticArguments.slice(0);
            }
            else {
                return this._staticArguments[nth];
            }
        };
        AbstractDescriptor.prototype._validate = function (type) {
            if (!type) {
                throw errors_1.illegalArgument('can not be falsy');
            }
        };
        return AbstractDescriptor;
    }());
    exports.AbstractDescriptor = AbstractDescriptor;
    var SyncDescriptor = (function (_super) {
        __extends(SyncDescriptor, _super);
        function SyncDescriptor(_ctor) {
            var staticArguments = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                staticArguments[_i - 1] = arguments[_i];
            }
            _super.call(this, staticArguments);
            this._ctor = _ctor;
        }
        Object.defineProperty(SyncDescriptor.prototype, "ctor", {
            get: function () {
                return this._ctor;
            },
            enumerable: true,
            configurable: true
        });
        SyncDescriptor.prototype.bind = function () {
            var moreStaticArguments = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                moreStaticArguments[_i - 0] = arguments[_i];
            }
            var allArgs = [];
            allArgs = allArgs.concat(this.staticArguments());
            allArgs = allArgs.concat(moreStaticArguments);
            return new (SyncDescriptor.bind.apply(SyncDescriptor, [void 0].concat([this._ctor], allArgs)))();
        };
        return SyncDescriptor;
    }(AbstractDescriptor));
    exports.SyncDescriptor = SyncDescriptor;
    exports.createSyncDescriptor = function (ctor) {
        var staticArguments = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            staticArguments[_i - 1] = arguments[_i];
        }
        return new (SyncDescriptor.bind.apply(SyncDescriptor, [void 0].concat([ctor], staticArguments)))();
    };
    var AsyncDescriptor = (function (_super) {
        __extends(AsyncDescriptor, _super);
        function AsyncDescriptor(_moduleName, _ctorName) {
            var staticArguments = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                staticArguments[_i - 2] = arguments[_i];
            }
            _super.call(this, staticArguments);
            this._moduleName = _moduleName;
            this._ctorName = _ctorName;
            if (typeof _moduleName !== 'string') {
                throw new Error('Invalid AsyncDescriptor arguments, expected `moduleName` to be a string!');
            }
        }
        AsyncDescriptor.create = function (moduleName, ctorName) {
            return new AsyncDescriptor(moduleName, ctorName);
        };
        Object.defineProperty(AsyncDescriptor.prototype, "moduleName", {
            get: function () {
                return this._moduleName;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AsyncDescriptor.prototype, "ctorName", {
            get: function () {
                return this._ctorName;
            },
            enumerable: true,
            configurable: true
        });
        AsyncDescriptor.prototype.bind = function () {
            var moreStaticArguments = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                moreStaticArguments[_i - 0] = arguments[_i];
            }
            var allArgs = [];
            allArgs = allArgs.concat(this.staticArguments());
            allArgs = allArgs.concat(moreStaticArguments);
            return new (AsyncDescriptor.bind.apply(AsyncDescriptor, [void 0].concat([this.moduleName, this.ctorName], allArgs)))();
        };
        return AsyncDescriptor;
    }(AbstractDescriptor));
    exports.AsyncDescriptor = AsyncDescriptor;
    var _createAsyncDescriptor = function (moduleName, ctorName) {
        var staticArguments = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            staticArguments[_i - 2] = arguments[_i];
        }
        return new (AsyncDescriptor.bind.apply(AsyncDescriptor, [void 0].concat([moduleName, ctorName], staticArguments)))();
    };
    exports.createAsyncDescriptor0 = _createAsyncDescriptor;
    exports.createAsyncDescriptor1 = _createAsyncDescriptor;
    exports.createAsyncDescriptor2 = _createAsyncDescriptor;
    exports.createAsyncDescriptor3 = _createAsyncDescriptor;
    exports.createAsyncDescriptor4 = _createAsyncDescriptor;
    exports.createAsyncDescriptor5 = _createAsyncDescriptor;
    exports.createAsyncDescriptor6 = _createAsyncDescriptor;
    exports.createAsyncDescriptor7 = _createAsyncDescriptor;
});

define(__m[15], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // ------ internal util
    var _util;
    (function (_util) {
        _util.DI_TARGET = '$di$target';
        _util.DI_DEPENDENCIES = '$di$dependencies';
        function getServiceDependencies(ctor) {
            return ctor[_util.DI_DEPENDENCIES] || [];
        }
        _util.getServiceDependencies = getServiceDependencies;
    })(_util = exports._util || (exports._util = {}));
    exports.IInstantiationService = createDecorator('instantiationService');
    function storeServiceDependency(id, target, index, optional) {
        if (target[_util.DI_TARGET] === target) {
            target[_util.DI_DEPENDENCIES].push({ id: id, index: index, optional: optional });
        }
        else {
            target[_util.DI_DEPENDENCIES] = [{ id: id, index: index, optional: optional }];
            target[_util.DI_TARGET] = target;
        }
    }
    /**
     * A *only* valid way to create a {{ServiceIdentifier}}.
     */
    function createDecorator(serviceId) {
        var id = function (target, key, index) {
            if (arguments.length !== 3) {
                throw new Error('@IServiceName-decorator can only be used to decorate a parameter');
            }
            storeServiceDependency(id, target, index, false);
        };
        id.toString = function () { return serviceId; };
        return id;
    }
    exports.createDecorator = createDecorator;
    /**
     * Mark a service dependency as optional.
     */
    function optional(serviceIdentifier) {
        return function (target, key, index) {
            if (arguments.length !== 3) {
                throw new Error('@optional-decorator can only be used to decorate a parameter');
            }
            storeServiceDependency(serviceIdentifier, target, index, true);
        };
    }
    exports.optional = optional;
});

define(__m[54], __M([0,1,15]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ID_CODE_EDITOR_SERVICE = 'codeEditorService';
    exports.ICodeEditorService = instantiation_1.createDecorator(exports.ID_CODE_EDITOR_SERVICE);
});

define(__m[378], __M([0,1,16,54]), function (require, exports, event_1, codeEditorService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var AbstractCodeEditorService = (function () {
        function AbstractCodeEditorService() {
            this.serviceId = codeEditorService_1.ICodeEditorService;
            this._codeEditors = Object.create(null);
            this._onCodeEditorAdd = new event_1.Emitter();
            this._onCodeEditorRemove = new event_1.Emitter();
        }
        AbstractCodeEditorService.prototype.addCodeEditor = function (editor) {
            this._codeEditors[editor.getId()] = editor;
            this._onCodeEditorAdd.fire(editor);
        };
        Object.defineProperty(AbstractCodeEditorService.prototype, "onCodeEditorAdd", {
            get: function () {
                return this._onCodeEditorAdd.event;
            },
            enumerable: true,
            configurable: true
        });
        AbstractCodeEditorService.prototype.removeCodeEditor = function (editor) {
            if (delete this._codeEditors[editor.getId()]) {
                this._onCodeEditorRemove.fire(editor);
            }
        };
        Object.defineProperty(AbstractCodeEditorService.prototype, "onCodeEditorRemove", {
            get: function () {
                return this._onCodeEditorRemove.event;
            },
            enumerable: true,
            configurable: true
        });
        AbstractCodeEditorService.prototype.getCodeEditor = function (editorId) {
            return this._codeEditors[editorId] || null;
        };
        AbstractCodeEditorService.prototype.listCodeEditors = function () {
            var _this = this;
            return Object.keys(this._codeEditors).map(function (id) { return _this._codeEditors[id]; });
        };
        AbstractCodeEditorService.prototype.getFocusedCodeEditor = function () {
            var editorWithWidgetFocus = null;
            var editors = this.listCodeEditors();
            for (var i = 0; i < editors.length; i++) {
                var editor = editors[i];
                if (editor.isFocused()) {
                    // bingo!
                    return editor;
                }
                if (editor.hasWidgetFocus()) {
                    editorWithWidgetFocus = editor;
                }
            }
            return editorWithWidgetFocus;
        };
        return AbstractCodeEditorService;
    }());
    exports.AbstractCodeEditorService = AbstractCodeEditorService;
});






define(__m[379], __M([0,1,31,10,29,11,7,378,3]), function (require, exports, objects, strings, uri_1, dom, editorCommon_1, abstractCodeEditorService_1, lifecycle_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CodeEditorServiceImpl = (function (_super) {
        __extends(CodeEditorServiceImpl, _super);
        function CodeEditorServiceImpl(styleSheet) {
            if (styleSheet === void 0) { styleSheet = dom.createStyleSheet(); }
            _super.call(this);
            this._styleSheet = styleSheet;
            this._decorationOptionProviders = Object.create(null);
        }
        CodeEditorServiceImpl.prototype.registerDecorationType = function (key, options, parentTypeKey) {
            var provider = this._decorationOptionProviders[key];
            if (!provider) {
                if (!parentTypeKey) {
                    provider = new DecorationTypeOptionsProvider(this._styleSheet, key, options);
                }
                else {
                    provider = new DecorationSubTypeOptionsProvider(this._styleSheet, key, parentTypeKey, options);
                }
                this._decorationOptionProviders[key] = provider;
            }
            provider.refCount++;
        };
        CodeEditorServiceImpl.prototype.removeDecorationType = function (key) {
            var provider = this._decorationOptionProviders[key];
            if (provider) {
                provider.refCount--;
                if (provider.refCount <= 0) {
                    delete this._decorationOptionProviders[key];
                    provider.dispose();
                    this.listCodeEditors().forEach(function (ed) { return ed.removeDecorations(key); });
                }
            }
        };
        CodeEditorServiceImpl.prototype.resolveDecorationOptions = function (decorationTypeKey, writable) {
            var provider = this._decorationOptionProviders[decorationTypeKey];
            if (!provider) {
                throw new Error('Unknown decoration type key: ' + decorationTypeKey);
            }
            return provider.getOptions(this, writable);
        };
        return CodeEditorServiceImpl;
    }(abstractCodeEditorService_1.AbstractCodeEditorService));
    exports.CodeEditorServiceImpl = CodeEditorServiceImpl;
    var DecorationSubTypeOptionsProvider = (function () {
        function DecorationSubTypeOptionsProvider(styleSheet, key, parentTypeKey, options) {
            this._parentTypeKey = parentTypeKey;
            this.refCount = 0;
            var themedOpts = getThemedRenderOptions(options);
            this._beforeContentClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, parentTypeKey, ModelDecorationCSSRuleType.BeforeContentClassName, {
                light: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.light.before),
                dark: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.dark.before)
            });
            this._afterContentClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, parentTypeKey, ModelDecorationCSSRuleType.AfterContentClassName, {
                light: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.light.after),
                dark: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.dark.after)
            });
            if (this._beforeContentClassName || this._afterContentClassName) {
                this._disposable = lifecycle_1.toDisposable(function () {
                    dom.removeCSSRulesContainingSelector(CSSNameHelper.getDeletionSubstring(key), styleSheet);
                });
            }
        }
        DecorationSubTypeOptionsProvider.prototype.getOptions = function (codeEditorService, writable) {
            var options = codeEditorService.resolveDecorationOptions(this._parentTypeKey, true);
            if (this._beforeContentClassName) {
                options.beforeContentClassName = this._beforeContentClassName;
            }
            if (this._afterContentClassName) {
                options.afterContentClassName = this._afterContentClassName;
            }
            return options;
        };
        DecorationSubTypeOptionsProvider.prototype.dispose = function () {
            if (this._disposable) {
                this._disposable.dispose();
                delete this._disposable;
            }
        };
        return DecorationSubTypeOptionsProvider;
    }());
    var DecorationTypeOptionsProvider = (function () {
        function DecorationTypeOptionsProvider(styleSheet, key, options) {
            this.refCount = 0;
            var themedOpts = getThemedRenderOptions(options);
            this.className = DecorationRenderHelper.createCSSRules(styleSheet, key, null, ModelDecorationCSSRuleType.ClassName, {
                light: DecorationRenderHelper.getCSSTextForModelDecorationClassName(themedOpts.light),
                dark: DecorationRenderHelper.getCSSTextForModelDecorationClassName(themedOpts.dark)
            });
            this.inlineClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, null, ModelDecorationCSSRuleType.InlineClassName, {
                light: DecorationRenderHelper.getCSSTextForModelDecorationInlineClassName(themedOpts.light),
                dark: DecorationRenderHelper.getCSSTextForModelDecorationInlineClassName(themedOpts.dark)
            });
            this.beforeContentClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, null, ModelDecorationCSSRuleType.BeforeContentClassName, {
                light: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.light.before),
                dark: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.dark.before)
            });
            this.afterContentClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, null, ModelDecorationCSSRuleType.AfterContentClassName, {
                light: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.light.after),
                dark: DecorationRenderHelper.getCSSTextForModelDecorationContentClassName(themedOpts.dark.after)
            });
            this.glyphMarginClassName = DecorationRenderHelper.createCSSRules(styleSheet, key, null, ModelDecorationCSSRuleType.GlyphMarginClassName, {
                light: DecorationRenderHelper.getCSSTextForModelDecorationGlyphMarginClassName(themedOpts.light),
                dark: DecorationRenderHelper.getCSSTextForModelDecorationGlyphMarginClassName(themedOpts.dark)
            });
            this.isWholeLine = Boolean(options.isWholeLine);
            if (typeof themedOpts.light.overviewRulerColor !== 'undefined'
                || typeof themedOpts.dark.overviewRulerColor !== 'undefined') {
                this.overviewRuler = {
                    color: themedOpts.light.overviewRulerColor || themedOpts.dark.overviewRulerColor,
                    darkColor: themedOpts.dark.overviewRulerColor || themedOpts.light.overviewRulerColor,
                    position: options.overviewRulerLane || editorCommon_1.OverviewRulerLane.Center
                };
            }
            this._disposable = lifecycle_1.toDisposable(function () {
                dom.removeCSSRulesContainingSelector(CSSNameHelper.getDeletionSubstring(key), styleSheet);
            });
        }
        DecorationTypeOptionsProvider.prototype.getOptions = function (codeEditorService, writable) {
            if (!writable) {
                return this;
            }
            return {
                inlineClassName: this.inlineClassName,
                beforeContentClassName: this.beforeContentClassName,
                afterContentClassName: this.afterContentClassName,
                className: this.className,
                glyphMarginClassName: this.glyphMarginClassName,
                isWholeLine: this.isWholeLine,
                overviewRuler: this.overviewRuler,
                stickiness: this.stickiness
            };
        };
        DecorationTypeOptionsProvider.prototype.dispose = function () {
            if (this._disposable) {
                this._disposable.dispose();
                delete this._disposable;
            }
        };
        return DecorationTypeOptionsProvider;
    }());
    var DecorationRenderHelper = (function () {
        function DecorationRenderHelper() {
        }
        /**
         * Build the CSS for decorations styled via `className`.
         */
        DecorationRenderHelper.getCSSTextForModelDecorationClassName = function (opts) {
            var cssTextArr = [];
            DecorationRenderHelper.collectCSSText(opts, ['backgroundColor', 'outline', 'outlineColor', 'outlineStyle', 'outlineWidth'], cssTextArr);
            DecorationRenderHelper.collectBorderSettingsCSSText(opts, cssTextArr);
            return cssTextArr.join('');
        };
        /**
         * Build the CSS for decorations styled via `inlineClassName`.
         */
        DecorationRenderHelper.getCSSTextForModelDecorationInlineClassName = function (opts) {
            var cssTextArr = [];
            DecorationRenderHelper.collectCSSText(opts, ['textDecoration', 'cursor', 'color', 'letterSpacing'], cssTextArr);
            return cssTextArr.join('');
        };
        /**
         * Build the CSS for decorations styled before or after content.
         */
        DecorationRenderHelper.getCSSTextForModelDecorationContentClassName = function (opts) {
            var cssTextArr = [];
            if (typeof opts !== 'undefined') {
                DecorationRenderHelper.collectBorderSettingsCSSText(opts, cssTextArr);
                if (typeof opts.contentIconPath !== 'undefined') {
                    cssTextArr.push(strings.format(this._CSS_MAP.contentIconPath, uri_1.default.file(opts.contentIconPath).toString()));
                }
                if (typeof opts.contentText !== 'undefined') {
                    var escaped = opts.contentText.replace(/\"/g, '\\\"');
                    cssTextArr.push(strings.format(this._CSS_MAP.contentText, escaped));
                }
                DecorationRenderHelper.collectCSSText(opts, ['textDecoration', 'color', 'backgroundColor', 'margin'], cssTextArr);
                if (DecorationRenderHelper.collectCSSText(opts, ['width', 'height'], cssTextArr)) {
                    cssTextArr.push('display:inline-block;');
                }
            }
            return cssTextArr.join('');
        };
        /**
         * Build the CSS for decorations styled via `glpyhMarginClassName`.
         */
        DecorationRenderHelper.getCSSTextForModelDecorationGlyphMarginClassName = function (opts) {
            var cssTextArr = [];
            if (typeof opts.gutterIconPath !== 'undefined') {
                cssTextArr.push(strings.format(this._CSS_MAP.gutterIconPath, uri_1.default.parse(opts.gutterIconPath).toString()));
                if (typeof opts.gutterIconSize !== 'undefined') {
                    cssTextArr.push(strings.format(this._CSS_MAP.gutterIconSize, opts.gutterIconSize));
                }
            }
            return cssTextArr.join('');
        };
        DecorationRenderHelper.collectBorderSettingsCSSText = function (opts, cssTextArr) {
            if (DecorationRenderHelper.collectCSSText(opts, DecorationRenderHelper.border_rules, cssTextArr)) {
                cssTextArr.push(strings.format('box-sizing: border-box;'));
                return true;
            }
            return false;
        };
        DecorationRenderHelper.collectCSSText = function (opts, properties, cssTextArr) {
            var lenBefore = cssTextArr.length;
            for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
                var property = properties_1[_i];
                if (typeof opts[property] !== 'undefined') {
                    cssTextArr.push(strings.format(this._CSS_MAP[property], opts[property]));
                }
            }
            return cssTextArr.length !== lenBefore;
        };
        /**
         * Create CSS rules for `cssTexts` with the generated class names from `ruleType`
         */
        DecorationRenderHelper.createCSSRules = function (styleSheet, key, parentKey, ruleType, cssTexts) {
            function createCSSSelector(themeType, cssText) {
                var selector = CSSNameHelper.getSelector(themeType, key, parentKey, ruleType);
                dom.createCSSRule(selector, cssText, styleSheet);
            }
            var hasContent = false;
            if (cssTexts.light.length > 0) {
                createCSSSelector(ThemeType.Light, cssTexts.light);
                hasContent = true;
            }
            if (cssTexts.dark.length > 0) {
                createCSSSelector(ThemeType.Dark, cssTexts.dark);
                createCSSSelector(ThemeType.HighContrastBlack, cssTexts.dark);
                hasContent = true;
            }
            if (hasContent) {
                var className = CSSNameHelper.getClassName(key, ruleType);
                if (parentKey) {
                    className = className + ' ' + CSSNameHelper.getClassName(parentKey, ruleType);
                }
                return className;
            }
            return void 0;
        };
        DecorationRenderHelper._CSS_MAP = {
            color: 'color:{0} !important;',
            backgroundColor: 'background-color:{0};',
            outline: 'outline:{0};',
            outlineColor: 'outline-color:{0};',
            outlineStyle: 'outline-style:{0};',
            outlineWidth: 'outline-width:{0};',
            border: 'border:{0};',
            borderColor: 'border-color:{0};',
            borderRadius: 'border-radius:{0};',
            borderSpacing: 'border-spacing:{0};',
            borderStyle: 'border-style:{0};',
            borderWidth: 'border-width:{0};',
            textDecoration: 'text-decoration:{0};',
            cursor: 'cursor:{0};',
            letterSpacing: 'letter-spacing:{0};',
            gutterIconPath: 'background:url(\'{0}\') center center no-repeat;',
            gutterIconSize: 'background-size:{0};',
            contentText: 'content:\'{0}\';',
            contentIconPath: 'content:url(\'{0}\')',
            margin: 'margin:{0};',
            width: 'width:{0};',
            height: 'height:{0};'
        };
        DecorationRenderHelper.border_rules = ['border', 'borderColor', 'borderColor', 'borderSpacing', 'borderStyle', 'borderWidth'];
        return DecorationRenderHelper;
    }());
    var ThemeType;
    (function (ThemeType) {
        ThemeType[ThemeType["Light"] = 0] = "Light";
        ThemeType[ThemeType["Dark"] = 1] = "Dark";
        ThemeType[ThemeType["HighContrastBlack"] = 2] = "HighContrastBlack";
    })(ThemeType || (ThemeType = {}));
    var ModelDecorationCSSRuleType;
    (function (ModelDecorationCSSRuleType) {
        ModelDecorationCSSRuleType[ModelDecorationCSSRuleType["ClassName"] = 0] = "ClassName";
        ModelDecorationCSSRuleType[ModelDecorationCSSRuleType["InlineClassName"] = 1] = "InlineClassName";
        ModelDecorationCSSRuleType[ModelDecorationCSSRuleType["GlyphMarginClassName"] = 2] = "GlyphMarginClassName";
        ModelDecorationCSSRuleType[ModelDecorationCSSRuleType["BeforeContentClassName"] = 3] = "BeforeContentClassName";
        ModelDecorationCSSRuleType[ModelDecorationCSSRuleType["AfterContentClassName"] = 4] = "AfterContentClassName";
    })(ModelDecorationCSSRuleType || (ModelDecorationCSSRuleType = {}));
    var CSSNameHelper = (function () {
        function CSSNameHelper() {
        }
        CSSNameHelper._getSelectorPrefixOf = function (theme) {
            if (theme === ThemeType.Light) {
                return '.monaco-editor.vs';
            }
            if (theme === ThemeType.Dark) {
                return '.monaco-editor.vs-dark';
            }
            return '.monaco-editor.hc-black';
        };
        CSSNameHelper.getClassName = function (key, type) {
            return 'ced-' + key + '-' + type;
        };
        CSSNameHelper.getSelector = function (themeType, key, parentKey, ruleType) {
            var selector = this._getSelectorPrefixOf(themeType) + ' .' + this.getClassName(key, ruleType);
            if (parentKey) {
                selector = selector + '.' + this.getClassName(parentKey, ruleType);
            }
            if (ruleType === ModelDecorationCSSRuleType.BeforeContentClassName) {
                selector += '::before';
            }
            else if (ruleType === ModelDecorationCSSRuleType.AfterContentClassName) {
                selector += '::after';
            }
            return selector;
        };
        CSSNameHelper.getDeletionSubstring = function (key) {
            return '.ced-' + key + '-';
        };
        return CSSNameHelper;
    }());
    function getThemedRenderOptions(opts) {
        var light = objects.deepClone(opts);
        objects.mixin(light, opts.light);
        var dark = objects.deepClone(opts);
        objects.mixin(dark, opts.dark);
        return {
            light: light,
            dark: dark
        };
    }
});

define(__m[113], __M([0,1,15]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ICompatWorkerService = instantiation_1.createDecorator('compatWorkerService');
    function findMember(proto, target) {
        for (var i in proto) {
            if (proto[i] === target) {
                return i;
            }
        }
        throw new Error('Member not found in prototype');
    }
    function CompatWorkerAttr(type, target) {
        var methodName = findMember(type.prototype, target);
        type.prototype[methodName] = function () {
            var param = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                param[_i - 0] = arguments[_i];
            }
            var obj = this;
            return obj.compatWorkerService.CompatWorker(obj, methodName, target, param);
        };
    }
    exports.CompatWorkerAttr = CompatWorkerAttr;
});

define(__m[52], __M([0,1,15]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ID_EDITOR_WORKER_SERVICE = 'editorWorkerService';
    exports.IEditorWorkerService = instantiation_1.createDecorator(exports.ID_EDITOR_WORKER_SERVICE);
});

define(__m[72], __M([0,1,15]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IModeService = instantiation_1.createDecorator('modeService');
});

define(__m[34], __M([0,1,15]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IModelService = instantiation_1.createDecorator('modelService');
});






var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
define(__m[133], __M([0,1,14,3,2,203,155,7,176,52,34,292,118]), function (require, exports, async_1, lifecycle_1, winjs_base_1, simpleWorker_1, defaultWorkerFactory_1, editorCommon, textModelWithTokensHelpers_1, editorWorkerService_1, modelService_1, editorSimpleWorker_1, workerClient_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Stop syncing a model to the worker if it was not needed for 1 min.
     */
    var STOP_SYNC_MODEL_DELTA_TIME_MS = 60 * 1000;
    /**
     * Stop the worker if it was not needed for 5 min.
     */
    var STOP_WORKER_DELTA_TIME_MS = 5 * 60 * 1000;
    var EditorWorkerServiceImpl = (function () {
        function EditorWorkerServiceImpl(modelService) {
            this.serviceId = editorWorkerService_1.IEditorWorkerService;
            this._workerManager = new WorkerManager(modelService);
        }
        EditorWorkerServiceImpl.prototype.computeDiff = function (original, modified, ignoreTrimWhitespace) {
            return this._workerManager.withWorker().then(function (client) { return client.computeDiff(original, modified, ignoreTrimWhitespace); });
        };
        EditorWorkerServiceImpl.prototype.computeDirtyDiff = function (original, modified, ignoreTrimWhitespace) {
            return this._workerManager.withWorker().then(function (client) { return client.computeDirtyDiff(original, modified, ignoreTrimWhitespace); });
        };
        EditorWorkerServiceImpl.prototype.computeLinks = function (resource) {
            return this._workerManager.withWorker().then(function (client) { return client.computeLinks(resource); });
        };
        EditorWorkerServiceImpl.prototype.textualSuggest = function (resource, position) {
            return this._workerManager.withWorker().then(function (client) { return client.textualSuggest(resource, position); });
        };
        EditorWorkerServiceImpl.prototype.navigateValueSet = function (resource, range, up) {
            return this._workerManager.withWorker().then(function (client) { return client.navigateValueSet(resource, range, up); });
        };
        EditorWorkerServiceImpl = __decorate([
            __param(0, modelService_1.IModelService)
        ], EditorWorkerServiceImpl);
        return EditorWorkerServiceImpl;
    }());
    exports.EditorWorkerServiceImpl = EditorWorkerServiceImpl;
    var WorkerManager = (function (_super) {
        __extends(WorkerManager, _super);
        function WorkerManager(modelService) {
            var _this = this;
            _super.call(this);
            this._modelService = modelService;
            this._editorWorkerClient = null;
            var stopWorkerInterval = this._register(new async_1.IntervalTimer());
            stopWorkerInterval.cancelAndSet(function () { return _this._checkStopWorker(); }, Math.round(STOP_WORKER_DELTA_TIME_MS / 2));
        }
        WorkerManager.prototype.dispose = function () {
            if (this._editorWorkerClient) {
                this._editorWorkerClient.dispose();
                this._editorWorkerClient = null;
            }
            _super.prototype.dispose.call(this);
        };
        WorkerManager.prototype._checkStopWorker = function () {
            if (!this._editorWorkerClient) {
                return;
            }
            var timeSinceLastWorkerUsedTime = (new Date()).getTime() - this._lastWorkerUsedTime;
            if (timeSinceLastWorkerUsedTime > STOP_WORKER_DELTA_TIME_MS) {
                this._editorWorkerClient.dispose();
                this._editorWorkerClient = null;
            }
        };
        WorkerManager.prototype.withWorker = function () {
            this._lastWorkerUsedTime = (new Date()).getTime();
            if (!this._editorWorkerClient) {
                this._editorWorkerClient = new EditorWorkerClient(this._modelService);
            }
            return winjs_base_1.TPromise.as(this._editorWorkerClient);
        };
        return WorkerManager;
    }(lifecycle_1.Disposable));
    var EditorModelManager = (function (_super) {
        __extends(EditorModelManager, _super);
        function EditorModelManager(proxy, modelService, keepIdleModels) {
            var _this = this;
            _super.call(this);
            this._syncedModels = Object.create(null);
            this._syncedModelsLastUsedTime = Object.create(null);
            this._proxy = proxy;
            this._modelService = modelService;
            if (!keepIdleModels) {
                var timer = new async_1.IntervalTimer();
                timer.cancelAndSet(function () { return _this._checkStopModelSync(); }, Math.round(STOP_SYNC_MODEL_DELTA_TIME_MS / 2));
                this._register(timer);
            }
        }
        EditorModelManager.prototype.dispose = function () {
            for (var modelUrl in this._syncedModels) {
                lifecycle_1.dispose(this._syncedModels[modelUrl]);
            }
            this._syncedModels = Object.create(null);
            this._syncedModelsLastUsedTime = Object.create(null);
            _super.prototype.dispose.call(this);
        };
        EditorModelManager.prototype.esureSyncedResources = function (resources) {
            for (var i = 0; i < resources.length; i++) {
                var resource = resources[i];
                var resourceStr = resource.toString();
                if (!this._syncedModels[resourceStr]) {
                    this._beginModelSync(resource);
                }
                if (this._syncedModels[resourceStr]) {
                    this._syncedModelsLastUsedTime[resourceStr] = (new Date()).getTime();
                }
            }
        };
        EditorModelManager.prototype._checkStopModelSync = function () {
            var currentTime = (new Date()).getTime();
            var toRemove = [];
            for (var modelUrl in this._syncedModelsLastUsedTime) {
                var elapsedTime = currentTime - this._syncedModelsLastUsedTime[modelUrl];
                if (elapsedTime > STOP_SYNC_MODEL_DELTA_TIME_MS) {
                    toRemove.push(modelUrl);
                }
            }
            for (var i = 0; i < toRemove.length; i++) {
                this._stopModelSync(toRemove[i]);
            }
        };
        EditorModelManager.prototype._beginModelSync = function (resource) {
            var _this = this;
            var modelUrl = resource.toString();
            var model = this._modelService.getModel(resource);
            if (!model) {
                return;
            }
            if (model.isTooLargeForHavingARichMode()) {
                return;
            }
            this._proxy.acceptNewModel({
                url: model.uri.toString(),
                value: model.toRawText(),
                versionId: model.getVersionId()
            });
            var toDispose = [];
            toDispose.push(model.addBulkListener(function (events) {
                var changedEvents = [];
                for (var i = 0, len = events.length; i < len; i++) {
                    var e = events[i];
                    switch (e.getType()) {
                        case editorCommon.EventType.ModelContentChanged2:
                            changedEvents.push(e.getData());
                            break;
                        case editorCommon.EventType.ModelDispose:
                            _this._stopModelSync(modelUrl);
                            return;
                    }
                }
                if (changedEvents.length > 0) {
                    _this._proxy.acceptModelChanged(modelUrl.toString(), changedEvents);
                }
            }));
            toDispose.push({
                dispose: function () {
                    _this._proxy.acceptRemovedModel(modelUrl);
                }
            });
            this._syncedModels[modelUrl] = toDispose;
        };
        EditorModelManager.prototype._stopModelSync = function (modelUrl) {
            var toDispose = this._syncedModels[modelUrl];
            delete this._syncedModels[modelUrl];
            delete this._syncedModelsLastUsedTime[modelUrl];
            lifecycle_1.dispose(toDispose);
        };
        return EditorModelManager;
    }(lifecycle_1.Disposable));
    var SynchronousWorkerClient = (function () {
        function SynchronousWorkerClient(instance) {
            this._instance = instance;
            this._proxyObj = winjs_base_1.TPromise.as(this._instance);
        }
        SynchronousWorkerClient.prototype.dispose = function () {
            this._instance.dispose();
            this._instance = null;
            this._proxyObj = null;
        };
        SynchronousWorkerClient.prototype.getProxyObject = function () {
            return new async_1.ShallowCancelThenPromise(this._proxyObj);
        };
        return SynchronousWorkerClient;
    }());
    var EditorWorkerClient = (function (_super) {
        __extends(EditorWorkerClient, _super);
        function EditorWorkerClient(modelService) {
            _super.call(this);
            this._modelService = modelService;
            this._workerFactory = new defaultWorkerFactory_1.DefaultWorkerFactory(/*do not use iframe*/ false);
            this._worker = null;
            this._modelManager = null;
        }
        EditorWorkerClient.prototype._getOrCreateWorker = function () {
            if (!this._worker) {
                try {
                    this._worker = this._register(new simpleWorker_1.SimpleWorkerClient(this._workerFactory, 'vs/editor/common/services/editorSimpleWorker'));
                }
                catch (err) {
                    workerClient_1.logOnceWebWorkerWarning(err);
                    this._worker = new SynchronousWorkerClient(new editorSimpleWorker_1.EditorSimpleWorkerImpl());
                }
            }
            return this._worker;
        };
        EditorWorkerClient.prototype._getProxy = function () {
            var _this = this;
            return new async_1.ShallowCancelThenPromise(this._getOrCreateWorker().getProxyObject().then(null, function (err) {
                workerClient_1.logOnceWebWorkerWarning(err);
                _this._worker = new SynchronousWorkerClient(new editorSimpleWorker_1.EditorSimpleWorkerImpl());
                return _this._getOrCreateWorker().getProxyObject();
            }));
        };
        EditorWorkerClient.prototype._getOrCreateModelManager = function (proxy) {
            if (!this._modelManager) {
                this._modelManager = this._register(new EditorModelManager(proxy, this._modelService, false));
            }
            return this._modelManager;
        };
        EditorWorkerClient.prototype._withSyncedResources = function (resources) {
            var _this = this;
            return this._getProxy().then(function (proxy) {
                _this._getOrCreateModelManager(proxy).esureSyncedResources(resources);
                return proxy;
            });
        };
        EditorWorkerClient.prototype.computeDiff = function (original, modified, ignoreTrimWhitespace) {
            return this._withSyncedResources([original, modified]).then(function (proxy) {
                return proxy.computeDiff(original.toString(), modified.toString(), ignoreTrimWhitespace);
            });
        };
        EditorWorkerClient.prototype.computeDirtyDiff = function (original, modified, ignoreTrimWhitespace) {
            return this._withSyncedResources([original, modified]).then(function (proxy) {
                return proxy.computeDirtyDiff(original.toString(), modified.toString(), ignoreTrimWhitespace);
            });
        };
        EditorWorkerClient.prototype.computeLinks = function (resource) {
            return this._withSyncedResources([resource]).then(function (proxy) {
                return proxy.computeLinks(resource.toString());
            });
        };
        EditorWorkerClient.prototype.textualSuggest = function (resource, position) {
            var _this = this;
            return this._withSyncedResources([resource]).then(function (proxy) {
                var model = _this._modelService.getModel(resource);
                if (!model) {
                    return null;
                }
                var wordDefRegExp = textModelWithTokensHelpers_1.WordHelper.massageWordDefinitionOf(model.getMode());
                var wordDef = wordDefRegExp.source;
                var wordDefFlags = (wordDefRegExp.global ? 'g' : '') + (wordDefRegExp.ignoreCase ? 'i' : '') + (wordDefRegExp.multiline ? 'm' : '');
                return proxy.textualSuggest(resource.toString(), position, wordDef, wordDefFlags);
            });
        };
        EditorWorkerClient.prototype.navigateValueSet = function (resource, range, up) {
            var _this = this;
            return this._withSyncedResources([resource]).then(function (proxy) {
                var model = _this._modelService.getModel(resource);
                if (!model) {
                    return null;
                }
                var wordDefRegExp = textModelWithTokensHelpers_1.WordHelper.massageWordDefinitionOf(model.getMode());
                var wordDef = wordDefRegExp.source;
                var wordDefFlags = (wordDefRegExp.global ? 'g' : '') + (wordDefRegExp.ignoreCase ? 'i' : '') + (wordDefRegExp.multiline ? 'm' : '');
                return proxy.navigateValueSet(resource.toString(), range, up, wordDef, wordDefFlags);
            });
        };
        return EditorWorkerClient;
    }(lifecycle_1.Disposable));
    exports.EditorWorkerClient = EditorWorkerClient;
});










define(__m[385], __M([0,1,2,4,34,231]), function (require, exports, winjs_base_1, range_1, modelService_1, tokenTree_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var TokenSelectionSupport = (function () {
        function TokenSelectionSupport(modelService) {
            this._modelService = modelService;
        }
        TokenSelectionSupport.prototype.getRangesToPosition = function (resource, position) {
            return winjs_base_1.TPromise.as(this.getRangesToPositionSync(resource, position));
        };
        TokenSelectionSupport.prototype.getRangesToPositionSync = function (resource, position) {
            var model = this._modelService.getModel(resource), entries = [];
            if (model) {
                this._doGetRangesToPosition(model, position).forEach(function (range) {
                    entries.push({
                        type: void 0,
                        range: range
                    });
                });
            }
            return entries;
        };
        TokenSelectionSupport.prototype._doGetRangesToPosition = function (model, position) {
            var tree = tokenTree_1.build(model), node, lastRange;
            node = tokenTree_1.find(tree, position);
            var ranges = [];
            while (node) {
                if (!lastRange || !range_1.Range.equalsRange(lastRange, node.range)) {
                    ranges.push(node.range);
                }
                lastRange = node.range;
                node = node.parent;
            }
            ranges = ranges.reverse();
            return ranges;
        };
        TokenSelectionSupport = __decorate([
            __param(0, modelService_1.IModelService)
        ], TokenSelectionSupport);
        return TokenSelectionSupport;
    }());
    exports.TokenSelectionSupport = TokenSelectionSupport;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[57], __M([0,1,15]), function (require, exports, instantiation_1) {
    "use strict";
    exports.IConfigurationService = instantiation_1.createDecorator('configurationService');
    function getConfigurationValue(config, settingPath, defaultValue) {
        function accessSetting(config, path) {
            var current = config;
            for (var i = 0; i < path.length; i++) {
                current = current[path[i]];
                if (!current) {
                    return undefined;
                }
            }
            return current;
        }
        var path = settingPath.split('.');
        var result = accessSetting(config, path);
        return typeof result === 'undefined'
            ? defaultValue
            : result;
    }
    exports.getConfigurationValue = getConfigurationValue;
});

define(__m[70], __M([0,1,15]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IContextViewService = instantiation_1.createDecorator('contextViewService');
    exports.IContextMenuService = instantiation_1.createDecorator('contextMenuService');
    var ContextSubMenu = (function () {
        function ContextSubMenu(label, entries) {
            this.label = label;
            this.entries = entries;
            // noop
        }
        return ContextSubMenu;
    }());
    exports.ContextSubMenu = ContextSubMenu;
});

define(__m[388], __M([0,1,374,70]), function (require, exports, contextMenuHandler_1, contextView_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ContextMenuService = (function () {
        function ContextMenuService(container, telemetryService, messageService, contextViewService) {
            this.serviceId = contextView_1.IContextMenuService;
            this.contextMenuHandler = new contextMenuHandler_1.ContextMenuHandler(container, contextViewService, telemetryService, messageService);
        }
        ContextMenuService.prototype.dispose = function () {
            this.contextMenuHandler.dispose();
        };
        ContextMenuService.prototype.setContainer = function (container) {
            this.contextMenuHandler.setContainer(container);
        };
        // ContextMenu
        ContextMenuService.prototype.showContextMenu = function (delegate) {
            this.contextMenuHandler.showContextMenu(delegate);
        };
        return ContextMenuService;
    }());
    exports.ContextMenuService = ContextMenuService;
});

define(__m[43], __M([0,1,15]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IEditorService = instantiation_1.createDecorator('editorService');
    /**
     * Possible locations for opening an editor.
     */
    (function (Position) {
        /** Opens the editor in the LEFT most position replacing the input currently showing */
        Position[Position["LEFT"] = 0] = "LEFT";
        /** Opens the editor in the CENTER position replacing the input currently showing */
        Position[Position["CENTER"] = 1] = "CENTER";
        /** Opens the editor in the RIGHT most position replacing the input currently showing */
        Position[Position["RIGHT"] = 2] = "RIGHT";
    })(exports.Position || (exports.Position = {}));
    var Position = exports.Position;
    exports.POSITIONS = [Position.LEFT, Position.CENTER, Position.RIGHT];
    (function (Direction) {
        Direction[Direction["LEFT"] = 0] = "LEFT";
        Direction[Direction["RIGHT"] = 1] = "RIGHT";
    })(exports.Direction || (exports.Direction = {}));
    var Direction = exports.Direction;
});

define(__m[82], __M([0,1,15]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IEventService = instantiation_1.createDecorator('eventService');
});






define(__m[391], __M([0,1,23,82]), function (require, exports, eventEmitter_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // --- implementation ------------------------------------------
    var EventService = (function (_super) {
        __extends(EventService, _super);
        function EventService() {
            _super.call(this);
            this.serviceId = event_1.IEventService;
        }
        return EventService;
    }(eventEmitter_1.EventEmitter));
    exports.EventService = EventService;
});

define(__m[84], __M([0,1,15]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IExtensionService = instantiation_1.createDecorator('extensionService');
});






define(__m[139], __M([0,1,38,60,15]), function (require, exports, paths, events, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IFileService = instantiation_1.createDecorator('fileService');
    /**
     * Possible changes that can occur to a file.
     */
    (function (FileChangeType) {
        FileChangeType[FileChangeType["UPDATED"] = 0] = "UPDATED";
        FileChangeType[FileChangeType["ADDED"] = 1] = "ADDED";
        FileChangeType[FileChangeType["DELETED"] = 2] = "DELETED";
    })(exports.FileChangeType || (exports.FileChangeType = {}));
    var FileChangeType = exports.FileChangeType;
    /**
     * Possible events to subscribe to
     */
    exports.EventType = {
        /**
        * Send on file changes.
        */
        FILE_CHANGES: 'files:fileChanges'
    };
    var FileChangesEvent = (function (_super) {
        __extends(FileChangesEvent, _super);
        function FileChangesEvent(changes) {
            _super.call(this);
            this._changes = changes;
        }
        Object.defineProperty(FileChangesEvent.prototype, "changes", {
            get: function () {
                return this._changes;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Returns true if this change event contains the provided file with the given change type. In case of
         * type DELETED, this method will also return true if a folder got deleted that is the parent of the
         * provided file path.
         */
        FileChangesEvent.prototype.contains = function (resource, type) {
            if (!resource) {
                return false;
            }
            return this.containsAny([resource], type);
        };
        /**
         * Returns true if this change event contains any of the provided files with the given change type. In case of
         * type DELETED, this method will also return true if a folder got deleted that is the parent of any of the
         * provided file paths.
         */
        FileChangesEvent.prototype.containsAny = function (resources, type) {
            if (!resources || !resources.length) {
                return false;
            }
            return this._changes.some(function (change) {
                if (change.type !== type) {
                    return false;
                }
                // For deleted also return true when deleted folder is parent of target path
                if (type === FileChangeType.DELETED) {
                    return resources.some(function (a) {
                        if (!a) {
                            return false;
                        }
                        return paths.isEqualOrParent(a.fsPath, change.resource.fsPath);
                    });
                }
                return resources.some(function (a) {
                    if (!a) {
                        return false;
                    }
                    return a.fsPath === change.resource.fsPath;
                });
            });
        };
        /**
         * Returns the changes that describe added files.
         */
        FileChangesEvent.prototype.getAdded = function () {
            return this.getOfType(FileChangeType.ADDED);
        };
        /**
         * Returns if this event contains added files.
         */
        FileChangesEvent.prototype.gotAdded = function () {
            return this.hasType(FileChangeType.ADDED);
        };
        /**
         * Returns the changes that describe deleted files.
         */
        FileChangesEvent.prototype.getDeleted = function () {
            return this.getOfType(FileChangeType.DELETED);
        };
        /**
         * Returns if this event contains deleted files.
         */
        FileChangesEvent.prototype.gotDeleted = function () {
            return this.hasType(FileChangeType.DELETED);
        };
        /**
         * Returns the changes that describe updated files.
         */
        FileChangesEvent.prototype.getUpdated = function () {
            return this.getOfType(FileChangeType.UPDATED);
        };
        /**
         * Returns if this event contains updated files.
         */
        FileChangesEvent.prototype.gotUpdated = function () {
            return this.hasType(FileChangeType.UPDATED);
        };
        FileChangesEvent.prototype.getOfType = function (type) {
            return this._changes.filter(function (change) { return change.type === type; });
        };
        FileChangesEvent.prototype.hasType = function (type) {
            return this._changes.some(function (change) {
                return change.type === type;
            });
        };
        return FileChangesEvent;
    }(events.Event));
    exports.FileChangesEvent = FileChangesEvent;
    (function (FileOperationResult) {
        FileOperationResult[FileOperationResult["FILE_IS_BINARY"] = 0] = "FILE_IS_BINARY";
        FileOperationResult[FileOperationResult["FILE_IS_DIRECTORY"] = 1] = "FILE_IS_DIRECTORY";
        FileOperationResult[FileOperationResult["FILE_NOT_FOUND"] = 2] = "FILE_NOT_FOUND";
        FileOperationResult[FileOperationResult["FILE_NOT_MODIFIED_SINCE"] = 3] = "FILE_NOT_MODIFIED_SINCE";
        FileOperationResult[FileOperationResult["FILE_MODIFIED_SINCE"] = 4] = "FILE_MODIFIED_SINCE";
        FileOperationResult[FileOperationResult["FILE_MOVE_CONFLICT"] = 5] = "FILE_MOVE_CONFLICT";
        FileOperationResult[FileOperationResult["FILE_READ_ONLY"] = 6] = "FILE_READ_ONLY";
        FileOperationResult[FileOperationResult["FILE_TOO_LARGE"] = 7] = "FILE_TOO_LARGE";
    })(exports.FileOperationResult || (exports.FileOperationResult = {}));
    var FileOperationResult = exports.FileOperationResult;
    exports.MAX_FILE_SIZE = 50 * 1024 * 1024;
    exports.AutoSaveConfiguration = {
        OFF: 'off',
        AFTER_DELAY: 'afterDelay',
        ON_FOCUS_CHANGE: 'onFocusChange'
    };
    exports.SUPPORTED_ENCODINGS = {
        utf8: {
            labelLong: 'UTF-8',
            labelShort: 'UTF-8',
            order: 1,
            alias: 'utf8bom'
        },
        utf8bom: {
            labelLong: 'UTF-8 with BOM',
            labelShort: 'UTF-8 with BOM',
            encodeOnly: true,
            order: 2,
            alias: 'utf8'
        },
        utf16le: {
            labelLong: 'UTF-16 LE',
            labelShort: 'UTF-16 LE',
            order: 3
        },
        utf16be: {
            labelLong: 'UTF-16 BE',
            labelShort: 'UTF-16 BE',
            order: 4
        },
        windows1252: {
            labelLong: 'Western (Windows 1252)',
            labelShort: 'Windows 1252',
            order: 5
        },
        iso88591: {
            labelLong: 'Western (ISO 8859-1)',
            labelShort: 'ISO 8859-1',
            order: 6
        },
        iso88593: {
            labelLong: 'Western (ISO 8859-3)',
            labelShort: 'ISO 8859-3',
            order: 7
        },
        iso885915: {
            labelLong: 'Western (ISO 8859-15)',
            labelShort: 'ISO 8859-15',
            order: 8
        },
        macroman: {
            labelLong: 'Western (Mac Roman)',
            labelShort: 'Mac Roman',
            order: 9
        },
        cp437: {
            labelLong: 'DOS (CP 437)',
            labelShort: 'CP437',
            order: 10
        },
        windows1256: {
            labelLong: 'Arabic (Windows 1256)',
            labelShort: 'Windows 1256',
            order: 11
        },
        iso88596: {
            labelLong: 'Arabic (ISO 8859-6)',
            labelShort: 'ISO 8859-6',
            order: 12
        },
        windows1257: {
            labelLong: 'Baltic (Windows 1257)',
            labelShort: 'Windows 1257',
            order: 13
        },
        iso88594: {
            labelLong: 'Baltic (ISO 8859-4)',
            labelShort: 'ISO 8859-4',
            order: 14
        },
        iso885914: {
            labelLong: 'Celtic (ISO 8859-14)',
            labelShort: 'ISO 8859-14',
            order: 15
        },
        windows1250: {
            labelLong: 'Central European (Windows 1250)',
            labelShort: 'Windows 1250',
            order: 16
        },
        iso88592: {
            labelLong: 'Central European (ISO 8859-2)',
            labelShort: 'ISO 8859-2',
            order: 17
        },
        windows1251: {
            labelLong: 'Cyrillic (Windows 1251)',
            labelShort: 'Windows 1251',
            order: 18
        },
        cp866: {
            labelLong: 'Cyrillic (CP 866)',
            labelShort: 'CP 866',
            order: 19
        },
        iso88595: {
            labelLong: 'Cyrillic (ISO 8859-5)',
            labelShort: 'ISO 8859-5',
            order: 20
        },
        koi8r: {
            labelLong: 'Cyrillic (KOI8-R)',
            labelShort: 'KOI8-R',
            order: 21
        },
        koi8u: {
            labelLong: 'Cyrillic (KOI8-U)',
            labelShort: 'KOI8-U',
            order: 22
        },
        iso885913: {
            labelLong: 'Estonian (ISO 8859-13)',
            labelShort: 'ISO 8859-13',
            order: 23
        },
        windows1253: {
            labelLong: 'Greek (Windows 1253)',
            labelShort: 'Windows 1253',
            order: 24
        },
        iso88597: {
            labelLong: 'Greek (ISO 8859-7)',
            labelShort: 'ISO 8859-7',
            order: 25
        },
        windows1255: {
            labelLong: 'Hebrew (Windows 1255)',
            labelShort: 'Windows 1255',
            order: 26
        },
        iso88598: {
            labelLong: 'Hebrew (ISO 8859-8)',
            labelShort: 'ISO 8859-8',
            order: 27
        },
        iso885910: {
            labelLong: 'Nordic (ISO 8859-10)',
            labelShort: 'ISO 8859-10',
            order: 28
        },
        iso885916: {
            labelLong: 'Romanian (ISO 8859-16)',
            labelShort: 'ISO 8859-16',
            order: 29
        },
        windows1254: {
            labelLong: 'Turkish (Windows 1254)',
            labelShort: 'Windows 1254',
            order: 30
        },
        iso88599: {
            labelLong: 'Turkish (ISO 8859-9)',
            labelShort: 'ISO 8859-9',
            order: 31
        },
        windows1258: {
            labelLong: 'Vietnamese (Windows 1258)',
            labelShort: 'Windows 1258',
            order: 32
        },
        gbk: {
            labelLong: 'Chinese (GBK)',
            labelShort: 'GBK',
            order: 33
        },
        gb18030: {
            labelLong: 'Chinese (GB18030)',
            labelShort: 'GB18030',
            order: 34
        },
        cp950: {
            labelLong: 'Traditional Chinese (Big5)',
            labelShort: 'Big5',
            order: 35
        },
        big5hkscs: {
            labelLong: 'Traditional Chinese (Big5-HKSCS)',
            labelShort: 'Big5-HKSCS',
            order: 36
        },
        shiftjis: {
            labelLong: 'Japanese (Shift JIS)',
            labelShort: 'Shift JIS',
            order: 37
        },
        eucjp: {
            labelLong: 'Japanese (EUC-JP)',
            labelShort: 'EUC-JP',
            order: 38
        },
        euckr: {
            labelLong: 'Korean (EUC-KR)',
            labelShort: 'EUC-KR',
            order: 39
        },
        windows874: {
            labelLong: 'Thai (Windows 874)',
            labelShort: 'Windows 874',
            order: 40
        },
        iso885911: {
            labelLong: 'Latin/Thai (ISO 8859-11)',
            labelShort: 'ISO 8859-11',
            order: 41
        },
        'koi8-ru': {
            labelLong: 'Cyrillic (KOI8-RU)',
            labelShort: 'KOI8-RU',
            order: 42
        },
        'koi8-t': {
            labelLong: 'Tajik (KOI8-T)',
            labelShort: 'KOI8-T',
            order: 43
        },
        GB2312: {
            labelLong: 'Simplified Chinese (GB 2312)',
            labelShort: 'GB 2312',
            order: 44
        }
    };
});






define(__m[394], __M([0,1,318,37,48,29,2,139,62,4,24]), function (require, exports, nls, arrays_1, collections_1, uri_1, winjs_base_1, files_1, editOperation_1, range_1, selection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ChangeRecorder = (function () {
        function ChangeRecorder(eventService) {
            this._eventService = eventService;
        }
        ChangeRecorder.prototype.start = function () {
            var changes = Object.create(null);
            var stop = this._eventService.addListener2(files_1.EventType.FILE_CHANGES, function (event) {
                event.changes.forEach(function (change) {
                    var key = String(change.resource), array = changes[key];
                    if (!array) {
                        changes[key] = array = [];
                    }
                    array.push(change);
                });
            });
            return {
                stop: function () { stop.dispose(); },
                hasChanged: function (resource) { return !!changes[resource.toString()]; },
                allChanges: function () { return arrays_1.merge(collections_1.values(changes)); }
            };
        };
        return ChangeRecorder;
    }());
    var EditTask = (function () {
        function EditTask(model) {
            this._endCursorSelection = null;
            this._model = model;
            this._edits = [];
        }
        EditTask.prototype.addEdit = function (edit) {
            var range;
            if (!edit.range) {
                range = this._model.getFullModelRange();
            }
            else {
                range = edit.range;
            }
            this._edits.push(editOperation_1.EditOperation.replace(range_1.Range.lift(range), edit.newText));
        };
        EditTask.prototype.apply = function () {
            var _this = this;
            if (this._edits.length === 0) {
                return;
            }
            this._edits.sort(EditTask._editCompare);
            this._initialSelections = this._getInitialSelections();
            this._model.pushEditOperations(this._initialSelections, this._edits, function (edits) { return _this._getEndCursorSelections(edits); });
        };
        EditTask.prototype._getInitialSelections = function () {
            var firstRange = this._edits[0].range;
            var initialSelection = new selection_1.Selection(firstRange.startLineNumber, firstRange.startColumn, firstRange.endLineNumber, firstRange.endColumn);
            return [initialSelection];
        };
        EditTask.prototype._getEndCursorSelections = function (inverseEditOperations) {
            var relevantEditIndex = 0;
            for (var i = 0; i < inverseEditOperations.length; i++) {
                var editRange = inverseEditOperations[i].range;
                for (var j = 0; j < this._initialSelections.length; j++) {
                    var selectionRange = this._initialSelections[j];
                    if (range_1.Range.areIntersectingOrTouching(editRange, selectionRange)) {
                        relevantEditIndex = i;
                        break;
                    }
                }
            }
            var srcRange = inverseEditOperations[relevantEditIndex].range;
            this._endCursorSelection = new selection_1.Selection(srcRange.endLineNumber, srcRange.endColumn, srcRange.endLineNumber, srcRange.endColumn);
            return [this._endCursorSelection];
        };
        EditTask.prototype.getEndCursorSelection = function () {
            return this._endCursorSelection;
        };
        EditTask._editCompare = function (a, b) {
            return range_1.Range.compareRangesUsingStarts(a.range, b.range);
        };
        return EditTask;
    }());
    var SourceModelEditTask = (function (_super) {
        __extends(SourceModelEditTask, _super);
        function SourceModelEditTask(model, initialSelections) {
            _super.call(this, model);
            this._knownInitialSelections = initialSelections;
        }
        SourceModelEditTask.prototype._getInitialSelections = function () {
            return this._knownInitialSelections;
        };
        return SourceModelEditTask;
    }(EditTask));
    var BulkEditModel = (function () {
        function BulkEditModel(editorService, sourceModel, sourceSelections, edits, progress) {
            if (progress === void 0) { progress = null; }
            this.progress = progress;
            this._numberOfResourcesToModify = 0;
            this._numberOfChanges = 0;
            this._edits = Object.create(null);
            this._editorService = editorService;
            this._sourceModel = sourceModel;
            this._sourceSelections = sourceSelections;
            this._sourceModelTask = null;
            for (var _i = 0, edits_1 = edits; _i < edits_1.length; _i++) {
                var edit = edits_1[_i];
                this._addEdit(edit);
            }
        }
        BulkEditModel.prototype.resourcesCount = function () {
            return this._numberOfResourcesToModify;
        };
        BulkEditModel.prototype.changeCount = function () {
            return this._numberOfChanges;
        };
        BulkEditModel.prototype._addEdit = function (edit) {
            var array = this._edits[edit.resource.toString()];
            if (!array) {
                this._edits[edit.resource.toString()] = array = [];
                this._numberOfResourcesToModify += 1;
            }
            this._numberOfChanges += 1;
            array.push(edit);
        };
        BulkEditModel.prototype.prepare = function () {
            var _this = this;
            if (this._tasks) {
                throw new Error('illegal state - already prepared');
            }
            this._tasks = [];
            var promises = [];
            if (this.progress) {
                this.progress.total(this._numberOfResourcesToModify * 2);
            }
            collections_1.forEach(this._edits, function (entry) {
                var promise = _this._editorService.resolveEditorModel({ resource: uri_1.default.parse(entry.key) }).then(function (model) {
                    if (!model || !model.textEditorModel) {
                        throw new Error("Cannot load file " + entry.key);
                    }
                    var textEditorModel = model.textEditorModel, task;
                    if (_this._sourceModel && textEditorModel.uri.toString() === _this._sourceModel.toString()) {
                        _this._sourceModelTask = new SourceModelEditTask(textEditorModel, _this._sourceSelections);
                        task = _this._sourceModelTask;
                    }
                    else {
                        task = new EditTask(textEditorModel);
                    }
                    entry.value.forEach(function (edit) { return task.addEdit(edit); });
                    _this._tasks.push(task);
                    if (_this.progress) {
                        _this.progress.worked(1);
                    }
                });
                promises.push(promise);
            });
            return winjs_base_1.TPromise.join(promises).then(function (_) { return _this; });
        };
        BulkEditModel.prototype.apply = function () {
            var _this = this;
            this._tasks.forEach(function (task) { return _this.applyTask(task); });
            var r = null;
            if (this._sourceModelTask) {
                r = this._sourceModelTask.getEndCursorSelection();
            }
            return r;
        };
        BulkEditModel.prototype.applyTask = function (task) {
            task.apply();
            if (this.progress) {
                this.progress.worked(1);
            }
        };
        return BulkEditModel;
    }());
    function bulkEdit(eventService, editorService, editor, edits, progress) {
        if (progress === void 0) { progress = null; }
        var bulk = createBulkEdit(eventService, editorService, editor);
        bulk.add(edits);
        bulk.progress(progress);
        return bulk.finish();
    }
    exports.bulkEdit = bulkEdit;
    function createBulkEdit(eventService, editorService, editor) {
        var all = [];
        var recording = new ChangeRecorder(eventService).start();
        var progressRunner;
        function progress(progress) {
            progressRunner = progress;
        }
        function add(edits) {
            all.push.apply(all, edits);
        }
        function getConcurrentEdits() {
            var names;
            for (var _i = 0, all_1 = all; _i < all_1.length; _i++) {
                var edit = all_1[_i];
                if (recording.hasChanged(edit.resource)) {
                    if (!names) {
                        names = [];
                    }
                    names.push(edit.resource.fsPath);
                }
            }
            if (names) {
                return nls.localize(0, null, names.join(', '));
            }
        }
        function finish() {
            if (all.length === 0) {
                return winjs_base_1.TPromise.as(undefined);
            }
            var concurrentEdits = getConcurrentEdits();
            if (concurrentEdits) {
                return winjs_base_1.TPromise.wrapError(concurrentEdits);
            }
            var uri;
            var selections;
            if (editor && editor.getModel()) {
                uri = editor.getModel().uri;
                selections = editor.getSelections();
            }
            var model = new BulkEditModel(editorService, uri, selections, all, progressRunner);
            return model.prepare().then(function (_) {
                var concurrentEdits = getConcurrentEdits();
                if (concurrentEdits) {
                    throw new Error(concurrentEdits);
                }
                recording.stop();
                return model.apply();
            });
        }
        return {
            progress: progress,
            add: add,
            finish: finish
        };
    }
    exports.createBulkEdit = createBulkEdit;
});

define(__m[67], __M([0,1,37]), function (require, exports, arrays_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ServiceCollection = (function () {
        function ServiceCollection() {
            var entries = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                entries[_i - 0] = arguments[_i];
            }
            this._entries = [];
            for (var _c = 0, entries_1 = entries; _c < entries_1.length; _c++) {
                var entry = entries_1[_c];
                this.set(entry[0], entry[1]);
            }
        }
        ServiceCollection.prototype.set = function (id, instanceOrDescriptor) {
            var entry = [id, instanceOrDescriptor];
            var idx = arrays_1.binarySearch(this._entries, entry, ServiceCollection._entryCompare);
            if (idx < 0) {
                // new element
                this._entries.splice(~idx, 0, entry);
            }
            else {
                var old = this._entries[idx];
                this._entries[idx] = entry;
                return old[1];
            }
        };
        ServiceCollection.prototype.forEach = function (callback) {
            for (var _i = 0, _c = this._entries; _i < _c.length; _i++) {
                var entry = _c[_i];
                var id = entry[0], instanceOrDescriptor = entry[1];
                callback(id, instanceOrDescriptor);
            }
        };
        ServiceCollection.prototype.has = function (id) {
            return arrays_1.binarySearch(this._entries, ServiceCollection._searchEntry(id), ServiceCollection._entryCompare) >= 0;
        };
        ServiceCollection.prototype.get = function (id) {
            var idx = arrays_1.binarySearch(this._entries, ServiceCollection._searchEntry(id), ServiceCollection._entryCompare);
            if (idx >= 0) {
                return this._entries[idx][1];
            }
        };
        ServiceCollection._searchEntry = function (id) {
            ServiceCollection._dummy[0] = id;
            return ServiceCollection._dummy;
        };
        ServiceCollection._entryCompare = function (a, b) {
            var _a = a[0].toString();
            var _b = b[0].toString();
            if (_a < _b) {
                return -1;
            }
            else if (_a > _b) {
                return 1;
            }
            else {
                return 0;
            }
        };
        ServiceCollection._dummy = [undefined, undefined];
        return ServiceCollection;
    }());
    exports.ServiceCollection = ServiceCollection;
});

define(__m[141], __M([0,1,2,8,26,47,255,68,15,67]), function (require, exports, winjs_base_1, errors_1, types_1, assert, graph_1, descriptors_1, instantiation_1, serviceCollection_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var InstantiationService = (function () {
        function InstantiationService(services, strict) {
            if (services === void 0) { services = new serviceCollection_1.ServiceCollection(); }
            if (strict === void 0) { strict = false; }
            this._services = services;
            this._strict = strict;
            this._services.set(instantiation_1.IInstantiationService, this);
        }
        InstantiationService.prototype.createChild = function (services) {
            var _this = this;
            this._services.forEach(function (id, thing) {
                if (services.has(id)) {
                    return;
                }
                // If we copy descriptors we might end up with
                // multiple instances of the same service
                if (thing instanceof descriptors_1.SyncDescriptor) {
                    thing = _this._createAndCacheServiceInstance(id, thing);
                }
                services.set(id, thing);
            });
            return new InstantiationService(services, this._strict);
        };
        InstantiationService.prototype.invokeFunction = function (signature) {
            var _this = this;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var accessor;
            try {
                accessor = {
                    get: function (id, isOptional) {
                        var result = _this._getOrCreateServiceInstance(id);
                        if (!result && isOptional !== instantiation_1.optional) {
                            throw new Error("[invokeFunction] unkown service '" + id + "'");
                        }
                        return result;
                    }
                };
                return signature.apply(undefined, [accessor].concat(args));
            }
            finally {
                accessor.get = function () {
                    throw errors_1.illegalState('service accessor is only valid during the invocation of its target method');
                };
            }
        };
        InstantiationService.prototype.createInstance = function (param) {
            var rest = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                rest[_i - 1] = arguments[_i];
            }
            if (param instanceof descriptors_1.AsyncDescriptor) {
                // async
                return this._createInstanceAsync(param, rest);
            }
            else if (param instanceof descriptors_1.SyncDescriptor) {
                // sync
                return this._createInstance(param, rest);
            }
            else {
                // sync, just ctor
                return this._createInstance(new descriptors_1.SyncDescriptor(param), rest);
            }
        };
        InstantiationService.prototype._createInstanceAsync = function (descriptor, args) {
            var _this = this;
            var canceledError;
            return new winjs_base_1.TPromise(function (c, e, p) {
                require([descriptor.moduleName], function (_module) {
                    if (canceledError) {
                        e(canceledError);
                    }
                    if (!_module) {
                        return e(errors_1.illegalArgument('module not found: ' + descriptor.moduleName));
                    }
                    var ctor;
                    if (!descriptor.ctorName) {
                        ctor = _module;
                    }
                    else {
                        ctor = _module[descriptor.ctorName];
                    }
                    if (typeof ctor !== 'function') {
                        return e(errors_1.illegalArgument('not a function: ' + descriptor.ctorName || descriptor.moduleName));
                    }
                    try {
                        args.unshift.apply(args, descriptor.staticArguments()); // instead of spread in ctor call
                        c(_this._createInstance(new descriptors_1.SyncDescriptor(ctor), args));
                    }
                    catch (error) {
                        return e(error);
                    }
                }, e);
            }, function () {
                canceledError = errors_1.canceled();
            });
        };
        InstantiationService.prototype._createInstance = function (desc, args) {
            var _this = this;
            // arguments given by createInstance-call and/or the descriptor
            var staticArgs = desc.staticArguments().concat(args);
            // arguments defined by service decorators
            var serviceDependencies = instantiation_1._util.getServiceDependencies(desc.ctor).sort(function (a, b) { return a.index - b.index; });
            var serviceArgs = serviceDependencies.map(function (dependency) {
                var service = _this._getOrCreateServiceInstance(dependency.id);
                if (!service && _this._strict && !dependency.optional) {
                    throw new Error("[createInstance] " + desc.ctor.name + " depends on UNKNOWN service " + dependency.id + ".");
                }
                return service;
            });
            var firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : staticArgs.length;
            // check for argument mismatches, adjust static args if needed
            if (staticArgs.length !== firstServiceArgPos) {
                console.warn("[createInstance] First service dependency of " + desc.ctor.name + " at position " + (firstServiceArgPos + 1) + " conflicts with " + staticArgs.length + " static arguments");
                var delta = firstServiceArgPos - staticArgs.length;
                if (delta > 0) {
                    staticArgs = staticArgs.concat(new Array(delta));
                }
                else {
                    staticArgs = staticArgs.slice(0, firstServiceArgPos);
                }
            }
            // // check for missing args
            // for (let i = 0; i < serviceArgs.length; i++) {
            // 	if (!serviceArgs[i]) {
            // 		console.warn(`${desc.ctor.name} MISSES service dependency ${serviceDependencies[i].id}`, new Error().stack);
            // 	}
            // }
            // now create the instance
            var argArray = [desc.ctor];
            argArray.push.apply(argArray, staticArgs);
            argArray.push.apply(argArray, serviceArgs);
            var instance = types_1.create.apply(null, argArray);
            desc._validate(instance);
            return instance;
        };
        InstantiationService.prototype._getOrCreateServiceInstance = function (id) {
            var thing = this._services.get(id);
            if (thing instanceof descriptors_1.SyncDescriptor) {
                return this._createAndCacheServiceInstance(id, thing);
            }
            else {
                return thing;
            }
        };
        InstantiationService.prototype._createAndCacheServiceInstance = function (id, desc) {
            assert.ok(this._services.get(id) instanceof descriptors_1.SyncDescriptor);
            var graph = new graph_1.Graph(function (data) { return data.id.toString(); });
            function throwCycleError() {
                var err = new Error('[createInstance] cyclic dependency between services');
                err.message = graph.toString();
                throw err;
            }
            var count = 0;
            var stack = [{ id: id, desc: desc }];
            while (stack.length) {
                var item = stack.pop();
                graph.lookupOrInsertNode(item);
                // TODO@joh use the graph to find a cycle
                // a weak heuristic for cycle checks
                if (count++ > 100) {
                    throwCycleError();
                }
                // check all dependencies for existence and if the need to be created first
                var dependencies = instantiation_1._util.getServiceDependencies(item.desc.ctor);
                for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {
                    var dependency = dependencies_1[_i];
                    var instanceOrDesc = this._services.get(dependency.id);
                    if (!instanceOrDesc) {
                        console.warn("[createInstance] " + id + " depends on " + dependency.id + " which is NOT registered.");
                    }
                    if (instanceOrDesc instanceof descriptors_1.SyncDescriptor) {
                        var d = { id: dependency.id, desc: instanceOrDesc };
                        graph.insertEdge(item, d);
                        stack.push(d);
                    }
                }
            }
            while (true) {
                var roots = graph.roots();
                // if there is no more roots but still
                // nodes in the graph we have a cycle
                if (roots.length === 0) {
                    if (graph.length !== 0) {
                        throwCycleError();
                    }
                    break;
                }
                for (var _a = 0, roots_1 = roots; _a < roots_1.length; _a++) {
                    var root = roots_1[_a];
                    // create instance and overwrite the service collections
                    var instance = this._createInstance(root.data.desc, []);
                    this._services.set(root.data.id, instance);
                    graph.removeNode(root.data);
                }
            }
            return this._services.get(id);
        };
        return InstantiationService;
    }());
    exports.InstantiationService = InstantiationService;
});

define(__m[19], __M([0,1,15]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    (function (KbExprType) {
        KbExprType[KbExprType["KbDefinedExpression"] = 1] = "KbDefinedExpression";
        KbExprType[KbExprType["KbNotExpression"] = 2] = "KbNotExpression";
        KbExprType[KbExprType["KbEqualsExpression"] = 3] = "KbEqualsExpression";
        KbExprType[KbExprType["KbNotEqualsExpression"] = 4] = "KbNotEqualsExpression";
        KbExprType[KbExprType["KbAndExpression"] = 5] = "KbAndExpression";
    })(exports.KbExprType || (exports.KbExprType = {}));
    var KbExprType = exports.KbExprType;
    function cmp(a, b) {
        var aType = a.getType();
        var bType = b.getType();
        if (aType !== bType) {
            return aType - bType;
        }
        switch (aType) {
            case KbExprType.KbDefinedExpression:
                return a.cmp(b);
            case KbExprType.KbNotExpression:
                return a.cmp(b);
            case KbExprType.KbEqualsExpression:
                return a.cmp(b);
            case KbExprType.KbNotEqualsExpression:
                return a.cmp(b);
            default:
                throw new Error('Unknown KbExpr!');
        }
    }
    var KbDefinedExpression = (function () {
        function KbDefinedExpression(key) {
            this.key = key;
        }
        KbDefinedExpression.prototype.getType = function () {
            return KbExprType.KbDefinedExpression;
        };
        KbDefinedExpression.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            return 0;
        };
        KbDefinedExpression.prototype.equals = function (other) {
            if (other instanceof KbDefinedExpression) {
                return (this.key === other.key);
            }
            return false;
        };
        KbDefinedExpression.prototype.evaluate = function (context) {
            return (!!context[this.key]);
        };
        KbDefinedExpression.prototype.normalize = function () {
            return this;
        };
        KbDefinedExpression.prototype.serialize = function () {
            return this.key;
        };
        return KbDefinedExpression;
    }());
    exports.KbDefinedExpression = KbDefinedExpression;
    var KbEqualsExpression = (function () {
        function KbEqualsExpression(key, value) {
            this.key = key;
            this.value = value;
        }
        KbEqualsExpression.prototype.getType = function () {
            return KbExprType.KbEqualsExpression;
        };
        KbEqualsExpression.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            if (this.value < other.value) {
                return -1;
            }
            if (this.value > other.value) {
                return 1;
            }
            return 0;
        };
        KbEqualsExpression.prototype.equals = function (other) {
            if (other instanceof KbEqualsExpression) {
                return (this.key === other.key && this.value === other.value);
            }
            return false;
        };
        KbEqualsExpression.prototype.evaluate = function (context) {
            /* tslint:disable:triple-equals */
            // Intentional ==
            return (context[this.key] == this.value);
            /* tslint:enable:triple-equals */
        };
        KbEqualsExpression.prototype.normalize = function () {
            if (typeof this.value === 'boolean') {
                if (this.value) {
                    return new KbDefinedExpression(this.key);
                }
                return new KbNotExpression(this.key);
            }
            return this;
        };
        KbEqualsExpression.prototype.serialize = function () {
            if (typeof this.value === 'boolean') {
                return this.normalize().serialize();
            }
            return this.key + ' == \'' + this.value + '\'';
        };
        return KbEqualsExpression;
    }());
    exports.KbEqualsExpression = KbEqualsExpression;
    var KbNotEqualsExpression = (function () {
        function KbNotEqualsExpression(key, value) {
            this.key = key;
            this.value = value;
        }
        KbNotEqualsExpression.prototype.getType = function () {
            return KbExprType.KbNotEqualsExpression;
        };
        KbNotEqualsExpression.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            if (this.value < other.value) {
                return -1;
            }
            if (this.value > other.value) {
                return 1;
            }
            return 0;
        };
        KbNotEqualsExpression.prototype.equals = function (other) {
            if (other instanceof KbNotEqualsExpression) {
                return (this.key === other.key && this.value === other.value);
            }
            return false;
        };
        KbNotEqualsExpression.prototype.evaluate = function (context) {
            /* tslint:disable:triple-equals */
            // Intentional !=
            return (context[this.key] != this.value);
            /* tslint:enable:triple-equals */
        };
        KbNotEqualsExpression.prototype.normalize = function () {
            if (typeof this.value === 'boolean') {
                if (this.value) {
                    return new KbNotExpression(this.key);
                }
                return new KbDefinedExpression(this.key);
            }
            return this;
        };
        KbNotEqualsExpression.prototype.serialize = function () {
            if (typeof this.value === 'boolean') {
                return this.normalize().serialize();
            }
            return this.key + ' != \'' + this.value + '\'';
        };
        return KbNotEqualsExpression;
    }());
    exports.KbNotEqualsExpression = KbNotEqualsExpression;
    var KbNotExpression = (function () {
        function KbNotExpression(key) {
            this.key = key;
        }
        KbNotExpression.prototype.getType = function () {
            return KbExprType.KbNotExpression;
        };
        KbNotExpression.prototype.cmp = function (other) {
            if (this.key < other.key) {
                return -1;
            }
            if (this.key > other.key) {
                return 1;
            }
            return 0;
        };
        KbNotExpression.prototype.equals = function (other) {
            if (other instanceof KbNotExpression) {
                return (this.key === other.key);
            }
            return false;
        };
        KbNotExpression.prototype.evaluate = function (context) {
            return (!context[this.key]);
        };
        KbNotExpression.prototype.normalize = function () {
            return this;
        };
        KbNotExpression.prototype.serialize = function () {
            return '!' + this.key;
        };
        return KbNotExpression;
    }());
    exports.KbNotExpression = KbNotExpression;
    var KbAndExpression = (function () {
        function KbAndExpression(expr) {
            this.expr = KbAndExpression._normalizeArr(expr);
        }
        KbAndExpression.prototype.getType = function () {
            return KbExprType.KbAndExpression;
        };
        KbAndExpression.prototype.equals = function (other) {
            if (other instanceof KbAndExpression) {
                if (this.expr.length !== other.expr.length) {
                    return false;
                }
                for (var i = 0, len = this.expr.length; i < len; i++) {
                    if (!this.expr[i].equals(other.expr[i])) {
                        return false;
                    }
                }
                return true;
            }
        };
        KbAndExpression.prototype.evaluate = function (context) {
            for (var i = 0, len = this.expr.length; i < len; i++) {
                if (!this.expr[i].evaluate(context)) {
                    return false;
                }
            }
            return true;
        };
        KbAndExpression._normalizeArr = function (arr) {
            var expr = [];
            if (arr) {
                for (var i = 0, len = arr.length; i < len; i++) {
                    var e = arr[i];
                    if (!e) {
                        continue;
                    }
                    e = e.normalize();
                    if (!e) {
                        continue;
                    }
                    if (e instanceof KbAndExpression) {
                        expr = expr.concat(e.expr);
                        continue;
                    }
                    expr.push(e);
                }
                expr.sort(cmp);
            }
            return expr;
        };
        KbAndExpression.prototype.normalize = function () {
            if (this.expr.length === 0) {
                return null;
            }
            if (this.expr.length === 1) {
                return this.expr[0];
            }
            return this;
        };
        KbAndExpression.prototype.serialize = function () {
            if (this.expr.length === 0) {
                return '';
            }
            if (this.expr.length === 1) {
                return this.normalize().serialize();
            }
            return this.expr.map(function (e) { return e.serialize(); }).join(' && ');
        };
        return KbAndExpression;
    }());
    exports.KbAndExpression = KbAndExpression;
    exports.KbExpr = {
        has: function (key) { return new KbDefinedExpression(key); },
        equals: function (key, value) { return new KbEqualsExpression(key, value); },
        notEquals: function (key, value) { return new KbNotEqualsExpression(key, value); },
        not: function (key) { return new KbNotExpression(key); },
        and: function () {
            var expr = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                expr[_i - 0] = arguments[_i];
            }
            return new KbAndExpression(expr);
        },
        deserialize: function (serialized) {
            if (!serialized) {
                return null;
            }
            var pieces = serialized.split('&&');
            var result = new KbAndExpression(pieces.map(function (p) { return exports.KbExpr._deserializeOne(p); }));
            return result.normalize();
        },
        _deserializeOne: function (serializedOne) {
            serializedOne = serializedOne.trim();
            if (serializedOne.indexOf('!=') >= 0) {
                var pieces = serializedOne.split('!=');
                return new KbNotEqualsExpression(pieces[0].trim(), exports.KbExpr._deserializeValue(pieces[1]));
            }
            if (serializedOne.indexOf('==') >= 0) {
                var pieces = serializedOne.split('==');
                return new KbEqualsExpression(pieces[0].trim(), exports.KbExpr._deserializeValue(pieces[1]));
            }
            if (/^\!\s*/.test(serializedOne)) {
                return new KbNotExpression(serializedOne.substr(1).trim());
            }
            return new KbDefinedExpression(serializedOne);
        },
        _deserializeValue: function (serializedValue) {
            serializedValue = serializedValue.trim();
            if (serializedValue === 'true') {
                return true;
            }
            if (serializedValue === 'false') {
                return false;
            }
            var m = /^'([^']*)'$/.exec(serializedValue);
            if (m) {
                return m[1].trim();
            }
            return serializedValue;
        }
    };
    exports.IKeybindingService = instantiation_1.createDecorator('keybindingService');
    exports.SET_CONTEXT_COMMAND_ID = 'setContext';
});






define(__m[398], __M([0,1,50,8,23,3,59,2,67,19,55,308,97,297,21,4,24,20,7,421,146,222,264]), function (require, exports, actions_1, errors_1, eventEmitter_1, lifecycle_1, timer, winjs_base_1, serviceCollection_1, keybindingService_1, defaultConfig_1, cursor_1, cursorMoveHelper_1, editorState_1, position_1, range_1, selection_1, editorAction_1, editorCommon, characterHardWrappingLineMapper_1, splitLinesCollection_1, viewModelImpl_1, hash_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EDITOR_ID = 0;
    var CommonCodeEditor = (function (_super) {
        __extends(CommonCodeEditor, _super);
        function CommonCodeEditor(domElement, options, instantiationService, codeEditorService, keybindingService, telemetryService) {
            var _this = this;
            _super.call(this);
            this.domElement = domElement;
            this.id = (++EDITOR_ID);
            this._codeEditorService = codeEditorService;
            var timerEvent = timer.start(timer.Topic.EDITOR, 'CodeEditor.ctor');
            // listeners that are kept during the whole editor lifetime
            this._lifetimeDispose = [];
            this._keybindingService = keybindingService.createScoped(domElement);
            this._editorIdContextKey = this._keybindingService.createKey('editorId', this.getId());
            this._editorFocusContextKey = this._keybindingService.createKey(editorCommon.KEYBINDING_CONTEXT_EDITOR_FOCUS, undefined);
            this._editorTabMovesFocusKey = this._keybindingService.createKey(editorCommon.KEYBINDING_CONTEXT_EDITOR_TAB_MOVES_FOCUS, false);
            this._hasMultipleSelectionsKey = this._keybindingService.createKey(editorCommon.KEYBINDING_CONTEXT_EDITOR_HAS_MULTIPLE_SELECTIONS, false);
            this._hasNonEmptySelectionKey = this._keybindingService.createKey(editorCommon.KEYBINDING_CONTEXT_EDITOR_HAS_NON_EMPTY_SELECTION, false);
            this._langIdKey = this._keybindingService.createKey(editorCommon.KEYBINDING_CONTEXT_EDITOR_LANGUAGE_ID, undefined);
            this._decorationTypeKeysToIds = {};
            this._decorationTypeSubtypes = {};
            options = options || {};
            if (typeof options.ariaLabel === 'undefined') {
                options.ariaLabel = defaultConfig_1.DefaultConfig.editor.ariaLabel;
            }
            this._configuration = this._createConfiguration(options);
            if (this._configuration.editor.tabFocusMode) {
                this._editorTabMovesFocusKey.set(true);
            }
            this._lifetimeDispose.push(this._configuration.onDidChange(function (e) { return _this.emit(editorCommon.EventType.ConfigurationChanged, e); }));
            this._telemetryService = telemetryService;
            this._instantiationService = instantiationService.createChild(new serviceCollection_1.ServiceCollection([keybindingService_1.IKeybindingService, this._keybindingService]));
            this._attachModel(null);
            // Create editor contributions
            this.contributions = {};
            timerEvent.stop();
            this._codeEditorService.addCodeEditor(this);
        }
        CommonCodeEditor.prototype.onDidChangeModelRawContent = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelRawContentChanged, listener);
        };
        CommonCodeEditor.prototype.onDidChangeModelContent = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelContentChanged2, listener);
        };
        CommonCodeEditor.prototype.onDidChangeModelMode = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelModeChanged, listener);
        };
        CommonCodeEditor.prototype.onDidChangeModelOptions = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelOptionsChanged, listener);
        };
        CommonCodeEditor.prototype.onDidChangeModelModeSupport = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelModeSupportChanged, listener);
        };
        CommonCodeEditor.prototype.onDidChangeModelDecorations = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelDecorationsChanged, listener);
        };
        CommonCodeEditor.prototype.onDidChangeConfiguration = function (listener) {
            return this.addListener2(editorCommon.EventType.ConfigurationChanged, listener);
        };
        CommonCodeEditor.prototype.onDidChangeModel = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelChanged, listener);
        };
        CommonCodeEditor.prototype.onDidChangeCursorPosition = function (listener) {
            return this.addListener2(editorCommon.EventType.CursorPositionChanged, listener);
        };
        CommonCodeEditor.prototype.onDidChangeCursorSelection = function (listener) {
            return this.addListener2(editorCommon.EventType.CursorSelectionChanged, listener);
        };
        CommonCodeEditor.prototype.onDidFocusEditorText = function (listener) {
            return this.addListener2(editorCommon.EventType.EditorTextFocus, listener);
        };
        CommonCodeEditor.prototype.onDidBlurEditorText = function (listener) {
            return this.addListener2(editorCommon.EventType.EditorTextBlur, listener);
        };
        CommonCodeEditor.prototype.onDidFocusEditor = function (listener) {
            return this.addListener2(editorCommon.EventType.EditorFocus, listener);
        };
        CommonCodeEditor.prototype.onDidBlurEditor = function (listener) {
            return this.addListener2(editorCommon.EventType.EditorBlur, listener);
        };
        CommonCodeEditor.prototype.onDidDispose = function (listener) {
            return this.addListener2(editorCommon.EventType.Disposed, listener);
        };
        CommonCodeEditor.prototype.getId = function () {
            return this.getEditorType() + ':' + this.id;
        };
        CommonCodeEditor.prototype.getEditorType = function () {
            return editorCommon.EditorType.ICodeEditor;
        };
        CommonCodeEditor.prototype.destroy = function () {
            this.dispose();
        };
        CommonCodeEditor.prototype.dispose = function () {
            this._codeEditorService.removeCodeEditor(this);
            this._lifetimeDispose = lifecycle_1.dispose(this._lifetimeDispose);
            var keys = Object.keys(this.contributions);
            for (var i = 0, len = keys.length; i < len; i++) {
                var contributionId = keys[i];
                this.contributions[contributionId].dispose();
            }
            this.contributions = {};
            this._postDetachModelCleanup(this._detachModel());
            this._configuration.dispose();
            this._keybindingService.dispose();
            this.emit(editorCommon.EventType.Disposed);
            _super.prototype.dispose.call(this);
        };
        CommonCodeEditor.prototype.captureState = function () {
            var flags = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                flags[_i - 0] = arguments[_i];
            }
            return new editorState_1.EditorState(this, flags);
        };
        CommonCodeEditor.prototype.updateOptions = function (newOptions) {
            this._configuration.updateOptions(newOptions);
            if (this._configuration.editor.tabFocusMode) {
                this._editorTabMovesFocusKey.set(true);
            }
            else {
                this._editorTabMovesFocusKey.reset();
            }
        };
        CommonCodeEditor.prototype.getConfiguration = function () {
            return this._configuration.editorClone;
        };
        CommonCodeEditor.prototype.getRawConfiguration = function () {
            return this._configuration.getRawOptions();
        };
        CommonCodeEditor.prototype.getValue = function (options) {
            if (options === void 0) { options = null; }
            if (this.model) {
                var preserveBOM = (options && options.preserveBOM) ? true : false;
                var eolPreference = editorCommon.EndOfLinePreference.TextDefined;
                if (options && options.lineEnding && options.lineEnding === '\n') {
                    eolPreference = editorCommon.EndOfLinePreference.LF;
                }
                else if (options && options.lineEnding && options.lineEnding === '\r\n') {
                    eolPreference = editorCommon.EndOfLinePreference.CRLF;
                }
                return this.model.getValue(eolPreference, preserveBOM);
            }
            return '';
        };
        CommonCodeEditor.prototype.setValue = function (newValue) {
            if (this.model) {
                this.model.setValue(newValue);
            }
        };
        CommonCodeEditor.prototype.getModel = function () {
            return this.model;
        };
        CommonCodeEditor.prototype.setModel = function (model) {
            if (model === void 0) { model = null; }
            if (this.model === model) {
                // Current model is the new model
                return;
            }
            var timerEvent = timer.start(timer.Topic.EDITOR, 'CodeEditor.setModel');
            var detachedModel = this._detachModel();
            this._attachModel(model);
            var e = {
                oldModelUrl: detachedModel ? detachedModel.uri : null,
                newModelUrl: model ? model.uri : null
            };
            timerEvent.stop();
            this.emit(editorCommon.EventType.ModelChanged, e);
            this._postDetachModelCleanup(detachedModel);
        };
        CommonCodeEditor.prototype.getVisibleColumnFromPosition = function (rawPosition) {
            if (!this.model) {
                return rawPosition.column;
            }
            var position = this.model.validatePosition(rawPosition);
            var tabSize = this.model.getOptions().tabSize;
            return cursorMoveHelper_1.CursorMoveHelper.visibleColumnFromColumn(this.model, position.lineNumber, position.column, tabSize) + 1;
        };
        CommonCodeEditor.prototype.getPosition = function () {
            if (!this.cursor) {
                return null;
            }
            return this.cursor.getPosition().clone();
        };
        CommonCodeEditor.prototype.setPosition = function (position, reveal, revealVerticalInCenter, revealHorizontal) {
            if (reveal === void 0) { reveal = false; }
            if (revealVerticalInCenter === void 0) { revealVerticalInCenter = false; }
            if (revealHorizontal === void 0) { revealHorizontal = false; }
            if (!this.cursor) {
                return;
            }
            if (!position_1.Position.isIPosition(position)) {
                throw new Error('Invalid arguments');
            }
            this.cursor.setSelections('api', [{
                    selectionStartLineNumber: position.lineNumber,
                    selectionStartColumn: position.column,
                    positionLineNumber: position.lineNumber,
                    positionColumn: position.column
                }]);
            if (reveal) {
                this.revealPosition(position, revealVerticalInCenter, revealHorizontal);
            }
        };
        CommonCodeEditor.prototype._sendRevealRange = function (range, verticalType, revealHorizontal) {
            if (!this.model || !this.cursor) {
                return;
            }
            if (!range_1.Range.isIRange(range)) {
                throw new Error('Invalid arguments');
            }
            var validatedRange = this.model.validateRange(range);
            var revealRangeEvent = {
                range: validatedRange,
                viewRange: null,
                verticalType: verticalType,
                revealHorizontal: revealHorizontal
            };
            this.cursor.emit(editorCommon.EventType.CursorRevealRange, revealRangeEvent);
        };
        CommonCodeEditor.prototype.revealLine = function (lineNumber) {
            this._sendRevealRange({
                startLineNumber: lineNumber,
                startColumn: 1,
                endLineNumber: lineNumber,
                endColumn: 1
            }, editorCommon.VerticalRevealType.Simple, false);
        };
        CommonCodeEditor.prototype.revealLineInCenter = function (lineNumber) {
            this._sendRevealRange({
                startLineNumber: lineNumber,
                startColumn: 1,
                endLineNumber: lineNumber,
                endColumn: 1
            }, editorCommon.VerticalRevealType.Center, false);
        };
        CommonCodeEditor.prototype.revealLineInCenterIfOutsideViewport = function (lineNumber) {
            this._sendRevealRange({
                startLineNumber: lineNumber,
                startColumn: 1,
                endLineNumber: lineNumber,
                endColumn: 1
            }, editorCommon.VerticalRevealType.CenterIfOutsideViewport, false);
        };
        CommonCodeEditor.prototype.revealPosition = function (position, revealVerticalInCenter, revealHorizontal) {
            if (revealVerticalInCenter === void 0) { revealVerticalInCenter = false; }
            if (revealHorizontal === void 0) { revealHorizontal = false; }
            if (!position_1.Position.isIPosition(position)) {
                throw new Error('Invalid arguments');
            }
            this._sendRevealRange({
                startLineNumber: position.lineNumber,
                startColumn: position.column,
                endLineNumber: position.lineNumber,
                endColumn: position.column
            }, revealVerticalInCenter ? editorCommon.VerticalRevealType.Center : editorCommon.VerticalRevealType.Simple, revealHorizontal);
        };
        CommonCodeEditor.prototype.revealPositionInCenter = function (position) {
            if (!position_1.Position.isIPosition(position)) {
                throw new Error('Invalid arguments');
            }
            this._sendRevealRange({
                startLineNumber: position.lineNumber,
                startColumn: position.column,
                endLineNumber: position.lineNumber,
                endColumn: position.column
            }, editorCommon.VerticalRevealType.Center, true);
        };
        CommonCodeEditor.prototype.revealPositionInCenterIfOutsideViewport = function (position) {
            if (!position_1.Position.isIPosition(position)) {
                throw new Error('Invalid arguments');
            }
            this._sendRevealRange({
                startLineNumber: position.lineNumber,
                startColumn: position.column,
                endLineNumber: position.lineNumber,
                endColumn: position.column
            }, editorCommon.VerticalRevealType.CenterIfOutsideViewport, true);
        };
        CommonCodeEditor.prototype.getSelection = function () {
            if (!this.cursor) {
                return null;
            }
            return this.cursor.getSelection().clone();
        };
        CommonCodeEditor.prototype.getSelections = function () {
            if (!this.cursor) {
                return null;
            }
            var selections = this.cursor.getSelections();
            var result = [];
            for (var i = 0, len = selections.length; i < len; i++) {
                result[i] = selections[i].clone();
            }
            return result;
        };
        CommonCodeEditor.prototype.setSelection = function (something, reveal, revealVerticalInCenter, revealHorizontal) {
            if (reveal === void 0) { reveal = false; }
            if (revealVerticalInCenter === void 0) { revealVerticalInCenter = false; }
            if (revealHorizontal === void 0) { revealHorizontal = false; }
            var isSelection = selection_1.Selection.isISelection(something);
            var isRange = range_1.Range.isIRange(something);
            if (!isSelection && !isRange) {
                throw new Error('Invalid arguments');
            }
            if (isSelection) {
                this._setSelectionImpl(something, reveal, revealVerticalInCenter, revealHorizontal);
            }
            else if (isRange) {
                // act as if it was an IRange
                var selection = {
                    selectionStartLineNumber: something.startLineNumber,
                    selectionStartColumn: something.startColumn,
                    positionLineNumber: something.endLineNumber,
                    positionColumn: something.endColumn
                };
                this._setSelectionImpl(selection, reveal, revealVerticalInCenter, revealHorizontal);
            }
        };
        CommonCodeEditor.prototype._setSelectionImpl = function (sel, reveal, revealVerticalInCenter, revealHorizontal) {
            if (!this.cursor) {
                return;
            }
            var selection = new selection_1.Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
            this.cursor.setSelections('api', [selection]);
            if (reveal) {
                this.revealRange(selection, revealVerticalInCenter, revealHorizontal);
            }
        };
        CommonCodeEditor.prototype.revealLines = function (startLineNumber, endLineNumber) {
            this._sendRevealRange({
                startLineNumber: startLineNumber,
                startColumn: 1,
                endLineNumber: endLineNumber,
                endColumn: 1
            }, editorCommon.VerticalRevealType.Simple, false);
        };
        CommonCodeEditor.prototype.revealLinesInCenter = function (startLineNumber, endLineNumber) {
            this._sendRevealRange({
                startLineNumber: startLineNumber,
                startColumn: 1,
                endLineNumber: endLineNumber,
                endColumn: 1
            }, editorCommon.VerticalRevealType.Center, false);
        };
        CommonCodeEditor.prototype.revealLinesInCenterIfOutsideViewport = function (startLineNumber, endLineNumber) {
            this._sendRevealRange({
                startLineNumber: startLineNumber,
                startColumn: 1,
                endLineNumber: endLineNumber,
                endColumn: 1
            }, editorCommon.VerticalRevealType.CenterIfOutsideViewport, false);
        };
        CommonCodeEditor.prototype.revealRange = function (range, revealVerticalInCenter, revealHorizontal) {
            if (revealVerticalInCenter === void 0) { revealVerticalInCenter = false; }
            if (revealHorizontal === void 0) { revealHorizontal = true; }
            this._sendRevealRange(range, revealVerticalInCenter ? editorCommon.VerticalRevealType.Center : editorCommon.VerticalRevealType.Simple, revealHorizontal);
        };
        CommonCodeEditor.prototype.revealRangeInCenter = function (range) {
            this._sendRevealRange(range, editorCommon.VerticalRevealType.Center, true);
        };
        CommonCodeEditor.prototype.revealRangeInCenterIfOutsideViewport = function (range) {
            this._sendRevealRange(range, editorCommon.VerticalRevealType.CenterIfOutsideViewport, true);
        };
        CommonCodeEditor.prototype.setSelections = function (ranges) {
            if (!this.cursor) {
                return;
            }
            if (!ranges || ranges.length === 0) {
                throw new Error('Invalid arguments');
            }
            for (var i = 0, len = ranges.length; i < len; i++) {
                if (!selection_1.Selection.isISelection(ranges[i])) {
                    throw new Error('Invalid arguments');
                }
            }
            this.cursor.setSelections('api', ranges);
        };
        CommonCodeEditor.prototype.onVisible = function () {
        };
        CommonCodeEditor.prototype.onHide = function () {
        };
        CommonCodeEditor.prototype.getContribution = function (id) {
            return this.contributions[id] || null;
        };
        CommonCodeEditor.prototype.addAction = function (descriptor) {
            if ((typeof descriptor.id !== 'string')
                || (typeof descriptor.label !== 'string')
                || (typeof descriptor.run !== 'function')) {
                throw new Error('Invalid action descriptor, `id`, `label` and `run` are required properties!');
            }
            var action = this._instantiationService.createInstance(editorAction_1.DynamicEditorAction, descriptor, this);
            this.contributions[action.getId()] = action;
        };
        CommonCodeEditor.prototype.getActions = function () {
            var result = [];
            var keys = Object.keys(this.contributions);
            for (var i = 0, len = keys.length; i < len; i++) {
                var id = keys[i];
                var contribution = this.contributions[id];
                // contribution instanceof IAction
                if (actions_1.isAction(contribution)) {
                    result.push(contribution);
                }
            }
            return result;
        };
        CommonCodeEditor.prototype.getAction = function (id) {
            var contribution = this.contributions[id];
            if (contribution) {
                // contribution instanceof IAction
                if (actions_1.isAction(contribution)) {
                    return contribution;
                }
            }
            return null;
        };
        CommonCodeEditor.prototype.trigger = function (source, handlerId, payload) {
            payload = payload || {};
            var candidate = this.getAction(handlerId);
            if (candidate !== null) {
                if (candidate.enabled) {
                    this._telemetryService.publicLog('editorActionInvoked', { name: candidate.label, id: candidate.id });
                    winjs_base_1.TPromise.as(candidate.run()).done(null, errors_1.onUnexpectedError);
                }
            }
            else {
                if (!this.cursor) {
                    return;
                }
                this.cursor.trigger(source, handlerId, payload);
            }
        };
        CommonCodeEditor.prototype.executeCommand = function (source, command) {
            if (!this.cursor) {
                return;
            }
            this.cursor.trigger(source, editorCommon.Handler.ExecuteCommand, command);
        };
        CommonCodeEditor.prototype.executeEdits = function (source, edits) {
            var _this = this;
            if (!this.cursor) {
                // no view, no cursor
                return false;
            }
            if (this._configuration.editor.readOnly) {
                // read only editor => sorry!
                return false;
            }
            this.model.pushStackElement();
            this.model.pushEditOperations(this.cursor.getSelections(), edits, function () {
                return _this.cursor.getSelections();
            });
            this.model.pushStackElement();
            return true;
        };
        CommonCodeEditor.prototype.executeCommands = function (source, commands) {
            if (!this.cursor) {
                return;
            }
            this.cursor.trigger(source, editorCommon.Handler.ExecuteCommands, commands);
        };
        CommonCodeEditor.prototype.changeDecorations = function (callback) {
            if (!this.model) {
                //			console.warn('Cannot change decorations on editor that is not attached to a model');
                // callback will not be called
                return null;
            }
            return this.model.changeDecorations(callback, this.id);
        };
        CommonCodeEditor.prototype.getLineDecorations = function (lineNumber) {
            if (!this.model) {
                return null;
            }
            return this.model.getLineDecorations(lineNumber, this.id, this._configuration.editor.readOnly);
        };
        CommonCodeEditor.prototype.deltaDecorations = function (oldDecorations, newDecorations) {
            if (!this.model) {
                return [];
            }
            if (oldDecorations.length === 0 && newDecorations.length === 0) {
                return oldDecorations;
            }
            return this.model.deltaDecorations(oldDecorations, newDecorations, this.id);
        };
        CommonCodeEditor.prototype.setDecorations = function (decorationTypeKey, decorationOptions) {
            var newDecorationsSubTypes = {};
            var oldDecorationsSubTypes = this._decorationTypeSubtypes[decorationTypeKey] || {};
            this._decorationTypeSubtypes[decorationTypeKey] = newDecorationsSubTypes;
            var newModelDecorations = [];
            for (var _i = 0, decorationOptions_1 = decorationOptions; _i < decorationOptions_1.length; _i++) {
                var decorationOption = decorationOptions_1[_i];
                var typeKey = decorationTypeKey;
                if (decorationOption.renderOptions) {
                    // identify custom reder options by a hash code over all keys and values
                    // For custom render options register a decoration type if necessary
                    var subType = hash_1.hash(decorationOption.renderOptions).toString(16);
                    // The fact that `decorationTypeKey` appears in the typeKey has no influence
                    // it is just a mechanism to get predictable and unique keys (repeatable for the same options and unique across clients)
                    typeKey = decorationTypeKey + '-' + subType;
                    if (!oldDecorationsSubTypes[subType] && !newDecorationsSubTypes[subType]) {
                        // decoration type did not exist before, register new one
                        this._codeEditorService.registerDecorationType(typeKey, decorationOption.renderOptions, decorationTypeKey);
                    }
                    newDecorationsSubTypes[subType] = true;
                }
                var opts = this._codeEditorService.resolveDecorationOptions(typeKey, !!decorationOption.hoverMessage);
                if (decorationOption.hoverMessage) {
                    opts.hoverMessage = decorationOption.hoverMessage;
                }
                newModelDecorations.push({ range: decorationOption.range, options: opts });
            }
            // remove decoration sub types that are no longer used, deregister decoration type if necessary
            for (var subType in oldDecorationsSubTypes) {
                if (!newDecorationsSubTypes[subType]) {
                    this._codeEditorService.removeDecorationType(decorationTypeKey + '-' + subType);
                }
            }
            // update all decorations
            var oldDecorationsIds = this._decorationTypeKeysToIds[decorationTypeKey] || [];
            this._decorationTypeKeysToIds[decorationTypeKey] = this.deltaDecorations(oldDecorationsIds, newModelDecorations);
        };
        CommonCodeEditor.prototype.removeDecorations = function (decorationTypeKey) {
            // remove decorations for type and sub type
            var oldDecorationsIds = this._decorationTypeKeysToIds[decorationTypeKey];
            if (oldDecorationsIds) {
                this.deltaDecorations(oldDecorationsIds, []);
            }
        };
        CommonCodeEditor.prototype.addTypingListener = function (character, callback) {
            var _this = this;
            if (!this.cursor) {
                return {
                    dispose: function () {
                        // no-op
                    }
                };
            }
            this.cursor.addTypingListener(character, callback);
            return {
                dispose: function () {
                    if (_this.cursor) {
                        _this.cursor.removeTypingListener(character, callback);
                    }
                }
            };
        };
        CommonCodeEditor.prototype.getLayoutInfo = function () {
            return this._configuration.editor.layoutInfo;
        };
        CommonCodeEditor.prototype._attachModel = function (model) {
            var _this = this;
            this.model = model ? model : null;
            this.listenersToRemove = [];
            this.viewModel = null;
            this.cursor = null;
            if (this.model) {
                this.domElement.setAttribute('data-mode-id', this.model.getMode().getId());
                this._langIdKey.set(this.model.getMode().getId());
                this._configuration.setIsDominatedByLongLines(this.model.isDominatedByLongLines());
                this.model.onBeforeAttached();
                var hardWrappingLineMapperFactory = new characterHardWrappingLineMapper_1.CharacterHardWrappingLineMapperFactory(this._configuration.editor.wrappingInfo.wordWrapBreakBeforeCharacters, this._configuration.editor.wrappingInfo.wordWrapBreakAfterCharacters, this._configuration.editor.wrappingInfo.wordWrapBreakObtrusiveCharacters);
                var linesCollection = new splitLinesCollection_1.SplitLinesCollection(this.model, hardWrappingLineMapperFactory, this.model.getOptions().tabSize, this._configuration.editor.wrappingInfo.wrappingColumn, this._configuration.editor.fontInfo.typicalFullwidthCharacterWidth / this._configuration.editor.fontInfo.typicalHalfwidthCharacterWidth, this._configuration.editor.wrappingInfo.wrappingIndent);
                this.viewModel = new viewModelImpl_1.ViewModel(linesCollection, this.id, this._configuration, this.model, function () { return _this.getCenteredRangeInViewport(); });
                var viewModelHelper = {
                    viewModel: this.viewModel,
                    convertModelPositionToViewPosition: function (lineNumber, column) {
                        return _this.viewModel.convertModelPositionToViewPosition(lineNumber, column);
                    },
                    convertModelRangeToViewRange: function (modelRange) {
                        return _this.viewModel.convertModelRangeToViewRange(modelRange);
                    },
                    convertViewToModelPosition: function (lineNumber, column) {
                        return _this.viewModel.convertViewPositionToModelPosition(lineNumber, column);
                    },
                    convertViewSelectionToModelSelection: function (viewSelection) {
                        return _this.viewModel.convertViewSelectionToModelSelection(viewSelection);
                    },
                    validateViewPosition: function (viewLineNumber, viewColumn, modelPosition) {
                        return _this.viewModel.validateViewPosition(viewLineNumber, viewColumn, modelPosition);
                    },
                    validateViewRange: function (viewStartLineNumber, viewStartColumn, viewEndLineNumber, viewEndColumn, modelRange) {
                        return _this.viewModel.validateViewRange(viewStartLineNumber, viewStartColumn, viewEndLineNumber, viewEndColumn, modelRange);
                    }
                };
                this.cursor = new cursor_1.Cursor(this.id, this._configuration, this.model, viewModelHelper, this._enableEmptySelectionClipboard());
                this.viewModel.addEventSource(this.cursor);
                this._createView();
                this.listenersToRemove.push(this._getViewInternalEventBus().addBulkListener2(function (events) {
                    for (var i = 0, len = events.length; i < len; i++) {
                        var eventType = events[i].getType();
                        var e = events[i].getData();
                        switch (eventType) {
                            case editorCommon.EventType.ViewFocusGained:
                                _this.emit(editorCommon.EventType.EditorTextFocus);
                                // In IE, the focus is not synchronous, so we give it a little help
                                _this.emit(editorCommon.EventType.EditorFocus, {});
                                break;
                            case 'scroll':
                                _this.emit('scroll', e);
                                break;
                            case editorCommon.EventType.ViewFocusLost:
                                _this.emit(editorCommon.EventType.EditorTextBlur);
                                break;
                            case editorCommon.EventType.ContextMenu:
                                _this.emit(editorCommon.EventType.ContextMenu, e);
                                break;
                            case editorCommon.EventType.MouseDown:
                                _this.emit(editorCommon.EventType.MouseDown, e);
                                break;
                            case editorCommon.EventType.MouseUp:
                                _this.emit(editorCommon.EventType.MouseUp, e);
                                break;
                            case editorCommon.EventType.KeyUp:
                                _this.emit(editorCommon.EventType.KeyUp, e);
                                break;
                            case editorCommon.EventType.MouseMove:
                                _this.emit(editorCommon.EventType.MouseMove, e);
                                break;
                            case editorCommon.EventType.MouseLeave:
                                _this.emit(editorCommon.EventType.MouseLeave, e);
                                break;
                            case editorCommon.EventType.KeyDown:
                                _this.emit(editorCommon.EventType.KeyDown, e);
                                break;
                            case editorCommon.EventType.ViewLayoutChanged:
                                _this.emit(editorCommon.EventType.EditorLayout, e);
                                break;
                            default:
                        }
                    }
                }));
                this.listenersToRemove.push(this.model.addBulkListener(function (events) {
                    for (var i = 0, len = events.length; i < len; i++) {
                        var eventType = events[i].getType();
                        var e = events[i].getData();
                        switch (eventType) {
                            case editorCommon.EventType.ModelDecorationsChanged:
                                _this.emit(editorCommon.EventType.ModelDecorationsChanged, e);
                                break;
                            case editorCommon.EventType.ModelModeChanged:
                                _this.domElement.setAttribute('data-mode-id', _this.model.getMode().getId());
                                _this._langIdKey.set(_this.model.getMode().getId());
                                _this.emit(editorCommon.EventType.ModelModeChanged, e);
                                break;
                            case editorCommon.EventType.ModelModeSupportChanged:
                                _this.emit(editorCommon.EventType.ModelModeSupportChanged, e);
                                break;
                            case editorCommon.EventType.ModelRawContentChanged:
                                _this.emit(editorCommon.EventType.ModelRawContentChanged, e);
                                break;
                            case editorCommon.EventType.ModelContentChanged2:
                                _this.emit(editorCommon.EventType.ModelContentChanged2, e);
                                break;
                            case editorCommon.EventType.ModelOptionsChanged:
                                _this.emit(editorCommon.EventType.ModelOptionsChanged, e);
                                break;
                            case editorCommon.EventType.ModelDispose:
                                // Someone might destroy the model from under the editor, so prevent any exceptions by setting a null model
                                _this.setModel(null);
                                break;
                            default:
                        }
                    }
                }));
                var _hasNonEmptySelection = function (e) {
                    var allSelections = [e.selection].concat(e.secondarySelections);
                    return allSelections.some(function (s) { return !s.isEmpty(); });
                };
                this.listenersToRemove.push(this.cursor.addBulkListener2(function (events) {
                    var updateHasMultipleCursors = false, hasMultipleCursors = false, updateHasNonEmptySelection = false, hasNonEmptySelection = false;
                    for (var i = 0, len = events.length; i < len; i++) {
                        var eventType = events[i].getType();
                        var e = events[i].getData();
                        switch (eventType) {
                            case editorCommon.EventType.CursorPositionChanged:
                                var cursorPositionChangedEvent = e;
                                updateHasMultipleCursors = true;
                                hasMultipleCursors = (cursorPositionChangedEvent.secondaryPositions.length > 0);
                                _this.emit(editorCommon.EventType.CursorPositionChanged, e);
                                break;
                            case editorCommon.EventType.CursorSelectionChanged:
                                var cursorSelectionChangedEvent = e;
                                updateHasMultipleCursors = true;
                                hasMultipleCursors = (cursorSelectionChangedEvent.secondarySelections.length > 0);
                                updateHasNonEmptySelection = true;
                                hasNonEmptySelection = _hasNonEmptySelection(cursorSelectionChangedEvent);
                                _this.emit(editorCommon.EventType.CursorSelectionChanged, e);
                                break;
                            default:
                        }
                    }
                    if (updateHasMultipleCursors) {
                        if (hasMultipleCursors) {
                            _this._hasMultipleSelectionsKey.set(true);
                        }
                        else {
                            _this._hasMultipleSelectionsKey.reset();
                        }
                    }
                    if (updateHasNonEmptySelection) {
                        if (hasNonEmptySelection) {
                            _this._hasNonEmptySelectionKey.set(true);
                        }
                        else {
                            _this._hasNonEmptySelectionKey.reset();
                        }
                    }
                }));
            }
            else {
                this.hasView = false;
            }
        };
        CommonCodeEditor.prototype._postDetachModelCleanup = function (detachedModel) {
            if (detachedModel) {
                this._decorationTypeKeysToIds = {};
                if (this._decorationTypeSubtypes) {
                    for (var decorationType in this._decorationTypeSubtypes) {
                        var subTypes = this._decorationTypeSubtypes[decorationType];
                        for (var subType in subTypes) {
                            this._codeEditorService.removeDecorationType(decorationType + '-' + subType);
                        }
                    }
                    this._decorationTypeSubtypes = {};
                }
                detachedModel.removeAllDecorationsWithOwnerId(this.id);
            }
        };
        CommonCodeEditor.prototype._detachModel = function () {
            if (this.model) {
                this.model.onBeforeDetached();
            }
            this.hasView = false;
            this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);
            if (this.cursor) {
                this.cursor.dispose();
                this.cursor = null;
            }
            if (this.viewModel) {
                this.viewModel.dispose();
                this.viewModel = null;
            }
            var result = this.model;
            this.model = null;
            this.domElement.removeAttribute('data-mode-id');
            return result;
        };
        return CommonCodeEditor;
    }(eventEmitter_1.EventEmitter));
    exports.CommonCodeEditor = CommonCodeEditor;
});















define(__m[79], __M([0,1,50,2,47,68,19,15]), function (require, exports, Actions, WinJS, Assert, Descriptors, keybindingService_1, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    (function (MenuId) {
        MenuId[MenuId["EditorTitle"] = 1] = "EditorTitle";
        MenuId[MenuId["EditorContext"] = 2] = "EditorContext";
        MenuId[MenuId["ExplorerContext"] = 3] = "ExplorerContext";
    })(exports.MenuId || (exports.MenuId = {}));
    var MenuId = exports.MenuId;
    exports.IMenuService = instantiation_1.createDecorator('menuService');
    var MenuItemAction = (function (_super) {
        __extends(MenuItemAction, _super);
        function MenuItemAction(_item, _resource, _keybindingService) {
            _super.call(this, MenuItemAction._getMenuItemId(_item), _item.command.title);
            this._item = _item;
            this._resource = _resource;
            this._keybindingService = _keybindingService;
            this.order = 100000; //TODO@Ben order is menu item property, not an action property
        }
        MenuItemAction._getMenuItemId = function (item) {
            var result = item.command.id;
            if (item.alt) {
                result += "||" + item.alt.id;
            }
            return result;
        };
        Object.defineProperty(MenuItemAction.prototype, "command", {
            get: function () {
                return this._item.command;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuItemAction.prototype, "altCommand", {
            get: function () {
                return this._item.alt;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MenuItemAction.prototype, "selectedCommand", {
            get: function () {
                return this.command;
            },
            enumerable: true,
            configurable: true
        });
        MenuItemAction.prototype.run = function (alt) {
            var id = (alt && this._item.alt || this._item.command).id;
            return this._keybindingService.executeCommand(id, this._resource);
        };
        MenuItemAction = __decorate([
            __param(2, keybindingService_1.IKeybindingService)
        ], MenuItemAction);
        return MenuItemAction;
    }(Actions.Action));
    exports.MenuItemAction = MenuItemAction;
    var ExecuteCommandAction = (function (_super) {
        __extends(ExecuteCommandAction, _super);
        function ExecuteCommandAction(id, label, _keybindingService) {
            _super.call(this, id, label);
            this._keybindingService = _keybindingService;
        }
        ExecuteCommandAction.prototype.run = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            return (_a = this._keybindingService).executeCommand.apply(_a, [this.id].concat(args));
            var _a;
        };
        ExecuteCommandAction = __decorate([
            __param(2, keybindingService_1.IKeybindingService)
        ], ExecuteCommandAction);
        return ExecuteCommandAction;
    }(Actions.Action));
    exports.ExecuteCommandAction = ExecuteCommandAction;
    var SyncActionDescriptor = (function () {
        function SyncActionDescriptor(ctor, id, label, keybindings, keybindingContext, keybindingWeight) {
            this._id = id;
            this._label = label;
            this._keybindings = keybindings;
            this._keybindingContext = keybindingContext;
            this._keybindingWeight = keybindingWeight;
            this._descriptor = Descriptors.createSyncDescriptor(ctor, this._id, this._label);
        }
        Object.defineProperty(SyncActionDescriptor.prototype, "syncDescriptor", {
            get: function () {
                return this._descriptor;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SyncActionDescriptor.prototype, "id", {
            get: function () {
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SyncActionDescriptor.prototype, "label", {
            get: function () {
                return this._label;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SyncActionDescriptor.prototype, "keybindings", {
            get: function () {
                return this._keybindings;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SyncActionDescriptor.prototype, "keybindingContext", {
            get: function () {
                return this._keybindingContext;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SyncActionDescriptor.prototype, "keybindingWeight", {
            get: function () {
                return this._keybindingWeight;
            },
            enumerable: true,
            configurable: true
        });
        return SyncActionDescriptor;
    }());
    exports.SyncActionDescriptor = SyncActionDescriptor;
    /**
     * A proxy for an action that needs to load code in order to confunction. Can be used from contributions to defer
     * module loading up to the point until the run method is being executed.
     */
    var DeferredAction = (function (_super) {
        __extends(DeferredAction, _super);
        function DeferredAction(_instantiationService, _descriptor, id, label, cssClass, enabled) {
            if (label === void 0) { label = ''; }
            if (cssClass === void 0) { cssClass = ''; }
            if (enabled === void 0) { enabled = true; }
            _super.call(this, id, label, cssClass, enabled);
            this._instantiationService = _instantiationService;
            this._descriptor = _descriptor;
        }
        Object.defineProperty(DeferredAction.prototype, "cachedAction", {
            get: function () {
                return this._cachedAction;
            },
            set: function (action) {
                this._cachedAction = action;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeferredAction.prototype, "id", {
            get: function () {
                if (this._cachedAction instanceof Actions.Action) {
                    return this._cachedAction.id;
                }
                return this._id;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeferredAction.prototype, "label", {
            get: function () {
                if (this._cachedAction instanceof Actions.Action) {
                    return this._cachedAction.label;
                }
                return this._label;
            },
            set: function (value) {
                if (this._cachedAction instanceof Actions.Action) {
                    this._cachedAction.label = value;
                }
                else {
                    this._setLabel(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeferredAction.prototype, "class", {
            get: function () {
                if (this._cachedAction instanceof Actions.Action) {
                    return this._cachedAction.class;
                }
                return this._cssClass;
            },
            set: function (value) {
                if (this._cachedAction instanceof Actions.Action) {
                    this._cachedAction.class = value;
                }
                else {
                    this._setClass(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeferredAction.prototype, "enabled", {
            get: function () {
                if (this._cachedAction instanceof Actions.Action) {
                    return this._cachedAction.enabled;
                }
                return this._enabled;
            },
            set: function (value) {
                if (this._cachedAction instanceof Actions.Action) {
                    this._cachedAction.enabled = value;
                }
                else {
                    this._setEnabled(value);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DeferredAction.prototype, "order", {
            get: function () {
                if (this._cachedAction instanceof Actions.Action) {
                    return this._cachedAction.order;
                }
                return this._order;
            },
            set: function (order) {
                if (this._cachedAction instanceof Actions.Action) {
                    this._cachedAction.order = order;
                }
                else {
                    this._order = order;
                }
            },
            enumerable: true,
            configurable: true
        });
        DeferredAction.prototype.run = function (event) {
            if (this._cachedAction) {
                return this._cachedAction.run(event);
            }
            return this._createAction().then(function (action) {
                return action.run(event);
            });
        };
        DeferredAction.prototype._createAction = function () {
            var _this = this;
            var promise = WinJS.TPromise.as(undefined);
            return promise.then(function () {
                return _this._instantiationService.createInstance(_this._descriptor);
            }).then(function (action) {
                Assert.ok(action instanceof Actions.Action, 'Action must be an instanceof Base Action');
                _this._cachedAction = action;
                // Pipe events from the instantated action through this deferred action
                _this._emitterUnbind = _this.addEmitter2(_this._cachedAction);
                return action;
            });
        };
        DeferredAction.prototype.dispose = function () {
            if (this._emitterUnbind) {
                this._emitterUnbind.dispose();
            }
            if (this._cachedAction) {
                this._cachedAction.dispose();
            }
            _super.prototype.dispose.call(this);
        };
        return DeferredAction;
    }(Actions.Action));
    exports.DeferredAction = DeferredAction;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[400], __M([0,1,367,19,79,3,58,137,16]), function (require, exports, nls_1, keybindingService_1, actions_1, lifecycle_1, actionbar_1, event_1, event_2) {
    'use strict';
    function fillInActions(menu, target) {
        var actions = menu.getActions();
        if (actions.length === 0) {
            return;
        }
        for (var _i = 0, actions_2 = actions; _i < actions_2.length; _i++) {
            var tuple = actions_2[_i];
            var group = tuple[0], actions_3 = tuple[1];
            if (group === 'navigation') {
                if (Array.isArray(target)) {
                    target.unshift.apply(target, actions_3);
                }
                else {
                    (_a = target.primary).unshift.apply(_a, actions_3);
                }
            }
            else {
                if (Array.isArray(target)) {
                    target.push.apply(target, [new actionbar_1.Separator()].concat(actions_3));
                }
                else {
                    (_b = target.secondary).push.apply(_b, [new actionbar_1.Separator()].concat(actions_3));
                }
            }
        }
        var _a, _b;
    }
    exports.fillInActions = fillInActions;
    function createActionItem(action, keybindingService) {
        if (action instanceof actions_1.MenuItemAction) {
            return new MenuItemActionItem(action, keybindingService);
        }
    }
    exports.createActionItem = createActionItem;
    var _altKey = new (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            var _this = this;
            _super.call(this, {
                onFirstListenerAdd: function () {
                    event_1.domEvent(document.body, 'keydown')(_this._key, _this, _this._subscriptions);
                    event_1.domEvent(document.body, 'keyup')(_this._key, _this, _this._subscriptions);
                },
                onLastListenerRemove: function () {
                    _this._subscriptions = lifecycle_1.dispose(_this._subscriptions);
                }
            });
            this._subscriptions = [];
        }
        class_1.prototype._key = function (e) {
            this.fire(e.type === 'keydown' && e.altKey);
        };
        return class_1;
    }(event_2.Emitter));
    var MenuItemActionItem = (function (_super) {
        __extends(MenuItemActionItem, _super);
        function MenuItemActionItem(action, _keybindingService) {
            _super.call(this, undefined, action, { icon: !!action.command.iconClass, label: !action.command.iconClass });
            this._keybindingService = _keybindingService;
            this._altKeyDown = false;
        }
        Object.defineProperty(MenuItemActionItem.prototype, "_command", {
            get: function () {
                var _a = this._action, command = _a.command, altCommand = _a.altCommand;
                return this._altKeyDown && altCommand || command;
            },
            enumerable: true,
            configurable: true
        });
        MenuItemActionItem.prototype.onClick = function (event) {
            event.preventDefault();
            event.stopPropagation();
            this._action.run(this._altKeyDown).done(undefined, console.error);
        };
        MenuItemActionItem.prototype.render = function (container) {
            var _this = this;
            _super.prototype.render.call(this, container);
            var altSubscription;
            var mouseOver;
            this._callOnDispose.push(event_1.domEvent(container, 'mouseleave')(function (_) {
                if (!_this._altKeyDown) {
                    lifecycle_1.dispose(altSubscription);
                }
                mouseOver = false;
            }));
            this._callOnDispose.push(event_1.domEvent(container, 'mouseenter')(function (e) {
                mouseOver = true;
                altSubscription = _altKey.event(function (value) {
                    if (!mouseOver) {
                        lifecycle_1.dispose(altSubscription);
                    }
                    _this._altKeyDown = value;
                    _this._updateLabel();
                    _this._updateTooltip();
                    _this._updateClass();
                });
            }));
        };
        MenuItemActionItem.prototype._updateLabel = function () {
            if (this.options.label) {
                this.$e.text(this._command.title);
            }
        };
        MenuItemActionItem.prototype._updateTooltip = function () {
            var element = this.$e.getHTMLElement();
            var keybinding = this._keybindingService.lookupKeybindings(this._command.id)[0];
            var keybindingLabel = keybinding && this._keybindingService.getLabelFor(keybinding);
            element.title = keybindingLabel
                ? nls_1.localize(0, null, this._command.title, keybindingLabel)
                : this._command.title;
        };
        MenuItemActionItem.prototype._updateClass = function () {
            if (this.options.icon) {
                var element = this.$e.getHTMLElement();
                var _a = this._action, command = _a.command, altCommand = _a.altCommand;
                if (this._command !== command) {
                    element.classList.remove(command.iconClass);
                }
                else if (altCommand) {
                    element.classList.remove(altCommand.iconClass);
                }
                element.classList.add('icon', this._command.iconClass);
            }
        };
        MenuItemActionItem = __decorate([
            __param(1, keybindingService_1.IKeybindingService)
        ], MenuItemActionItem);
        return MenuItemActionItem;
    }(actionbar_1.ActionItem));
});










define(__m[401], __M([0,1,19,72]), function (require, exports, keybindingService_1, modeService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ResourceContextKey = (function () {
        function ResourceContextKey(keybindingService, _modeService) {
            this._modeService = _modeService;
            this._schemeKey = keybindingService.createKey(ResourceContextKey.Scheme, undefined);
            this._langIdKey = keybindingService.createKey(ResourceContextKey.LangId, undefined);
            this._resourceKey = keybindingService.createKey(ResourceContextKey.Resource, undefined);
        }
        ResourceContextKey.prototype.set = function (value) {
            this._resourceKey.set(value);
            this._schemeKey.set(value && value.scheme);
            this._langIdKey.set(value && this._modeService.getModeIdByFilenameOrFirstLine(value.fsPath));
        };
        ResourceContextKey.prototype.reset = function () {
            this._schemeKey.reset();
            this._langIdKey.reset();
            this._resourceKey.reset();
        };
        ResourceContextKey.Scheme = 'resourceScheme';
        ResourceContextKey.LangId = 'resourceLangId';
        ResourceContextKey.Resource = 'resource';
        ResourceContextKey = __decorate([
            __param(0, keybindingService_1.IKeybindingService),
            __param(1, modeService_1.IModeService)
        ], ResourceContextKey);
        return ResourceContextKey;
    }());
    exports.ResourceContextKey = ResourceContextKey;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[402], __M([0,1,16,3,48,19,79,84,401]), function (require, exports, event_1, lifecycle_1, collections_1, keybindingService_1, actions_1, extensions_1, resourceContextKey_1) {
    'use strict';
    var _registry = new (function () {
        function class_1() {
            this.commands = Object.create(null);
            this.menuItems = Object.create(null);
        }
        class_1.prototype.registerCommand = function (command) {
            var old = this.commands[command.id];
            this.commands[command.id] = command;
            return old !== void 0;
        };
        class_1.prototype.registerMenuItems = function (loc, items) {
            var array = this.menuItems[loc];
            if (!array) {
                this.menuItems[loc] = items;
            }
            else {
                array.push.apply(array, items);
            }
        };
        class_1.prototype.getMenuItems = function (loc) {
            var result = [];
            var menuItems = this.menuItems[loc];
            if (menuItems) {
                for (var _i = 0, menuItems_1 = menuItems; _i < menuItems_1.length; _i++) {
                    var item = menuItems_1[_i];
                    var command = this.commands[item.command];
                    if (!command) {
                        // warn?
                        continue;
                    }
                    var when = keybindingService_1.KbExpr.deserialize(item.when);
                    var alt = this.commands[item.alt];
                    result.push({ when: when, command: command, alt: alt, group: item.group });
                }
            }
            return result;
        };
        return class_1;
    }());
    exports.MenuRegistry = _registry;
    var MenuService = (function () {
        function MenuService(_extensionService) {
            this._extensionService = _extensionService;
            this.serviceId = actions_1.IMenuService;
            //
        }
        MenuService.prototype.createMenu = function (id, keybindingService) {
            return new Menu(id, keybindingService, this._extensionService);
        };
        MenuService.prototype.getCommandActions = function () {
            return collections_1.values(_registry.commands);
        };
        MenuService = __decorate([
            __param(0, extensions_1.IExtensionService)
        ], MenuService);
        return MenuService;
    }());
    exports.MenuService = MenuService;
    var Menu = (function () {
        function Menu(id, _keybindingService, _extensionService) {
            var _this = this;
            this._keybindingService = _keybindingService;
            this._extensionService = _extensionService;
            this._menuGroups = [];
            this._disposables = [];
            this._onDidChange = new event_1.Emitter();
            this._extensionService.onReady().then(function (_) {
                var menuItems = _registry.getMenuItems(id);
                var keysFilter = Object.create(null);
                var group;
                menuItems.sort(Menu._compareMenuItems);
                for (var _i = 0, menuItems_2 = menuItems; _i < menuItems_2.length; _i++) {
                    var item = menuItems_2[_i];
                    // group by groupId
                    var groupName = Menu._group(item.group);
                    if (!group || group[0] !== groupName) {
                        group = [groupName, []];
                        _this._menuGroups.push(group);
                    }
                    group[1].push(item);
                    // keep keys for eventing
                    Menu._fillInKbExprKeys(item.when, keysFilter);
                }
                // subscribe to context changes
                _this._disposables.push(_this._keybindingService.onDidChangeContext(function (keys) {
                    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                        var k = keys_1[_i];
                        if (keysFilter[k]) {
                            _this._onDidChange.fire();
                            return;
                        }
                    }
                }));
                _this._onDidChange.fire(_this);
            });
        }
        Menu.prototype.dispose = function () {
            this._disposables = lifecycle_1.dispose(this._disposables);
            this._onDidChange.dispose();
        };
        Object.defineProperty(Menu.prototype, "onDidChange", {
            get: function () {
                return this._onDidChange.event;
            },
            enumerable: true,
            configurable: true
        });
        Menu.prototype.getActions = function () {
            var result = [];
            for (var _i = 0, _a = this._menuGroups; _i < _a.length; _i++) {
                var group = _a[_i];
                var id = group[0], items = group[1];
                var actions = [];
                for (var _b = 0, items_1 = items; _b < items_1.length; _b++) {
                    var item = items_1[_b];
                    if (this._keybindingService.contextMatchesRules(item.when)) {
                        actions.push(new actions_1.MenuItemAction(item, this._keybindingService.getContextValue(resourceContextKey_1.ResourceContextKey.Resource), this._keybindingService));
                    }
                }
                if (actions.length > 0) {
                    result.push([id, actions]);
                }
            }
            return result;
        };
        Menu._fillInKbExprKeys = function (exp, set) {
            if (exp) {
                var parts = exp.serialize().split(' && ');
                for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {
                    var part = parts_1[_i];
                    var m = /^\S+/.exec(part);
                    if (m) {
                        set[m[0]] = true;
                    }
                }
            }
        };
        Menu._compareMenuItems = function (a, b) {
            var ret;
            if (a.group && b.group) {
                ret = Menu._compareGroupId(a.group, b.group);
            }
            if (!ret) {
                ret = a.command.title.localeCompare(b.command.title);
            }
            return ret;
        };
        Menu._compareGroupId = function (a, b) {
            var a_boost = Number(a.substr(a.lastIndexOf('@') + 1));
            var b_boost = Number(b.substr(b.lastIndexOf('@') + 1));
            if (a_boost !== b_boost && !isNaN(a_boost) && !isNaN(b_boost)) {
                return a_boost < b_boost ? -1 : 1;
            }
            return a.localeCompare(b);
        };
        Menu._group = function (a) {
            return a && (a.substr(0, a.lastIndexOf('@')) || a);
        };
        Menu = __decorate([
            __param(1, keybindingService_1.IKeybindingService),
            __param(2, extensions_1.IExtensionService)
        ], Menu);
        return Menu;
    }());
});

define(__m[101], __M([0,1,12,18,19]), function (require, exports, keyCodes_1, platform, keybindingService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var NormalizedKeybindingItem = (function () {
        function NormalizedKeybindingItem(keybinding, command, when, isDefault) {
            this.keybinding = keybinding;
            this.command = command;
            this.actualCommand = this.command ? this.command.replace(/^\^/, '') : this.command;
            this.when = when;
            this.isDefault = isDefault;
        }
        NormalizedKeybindingItem.fromKeybindingItem = function (source, isDefault) {
            var when = null;
            if (source.when) {
                when = source.when.normalize();
            }
            return new NormalizedKeybindingItem(source.keybinding, source.command, when, isDefault);
        };
        return NormalizedKeybindingItem;
    }());
    exports.NormalizedKeybindingItem = NormalizedKeybindingItem;
    var KeybindingResolver = (function () {
        function KeybindingResolver(defaultKeybindings, overrides, shouldWarnOnConflict) {
            if (shouldWarnOnConflict === void 0) { shouldWarnOnConflict = true; }
            defaultKeybindings = defaultKeybindings.slice(0).sort(sorter);
            this._defaultKeybindings = defaultKeybindings;
            this._shouldWarnOnConflict = shouldWarnOnConflict;
            this._defaultBoundCommands = Object.create(null);
            for (var i = 0, len = defaultKeybindings.length; i < len; i++) {
                this._defaultBoundCommands[defaultKeybindings[i].command] = true;
            }
            this._map = Object.create(null);
            this._lookupMap = Object.create(null);
            this._lookupMapUnreachable = Object.create(null);
            this._chords = Object.create(null);
            var allKeybindings = KeybindingResolver.combine(defaultKeybindings, overrides);
            for (var i = 0, len = allKeybindings.length; i < len; i++) {
                var k = allKeybindings[i];
                if (k.keybinding === 0) {
                    continue;
                }
                var entry = {
                    when: k.when,
                    keybinding: k.keybinding,
                    commandId: k.command
                };
                if (keyCodes_1.BinaryKeybindings.hasChord(k.keybinding)) {
                    // This is a chord
                    var keybindingFirstPart = keyCodes_1.BinaryKeybindings.extractFirstPart(k.keybinding);
                    var keybindingChordPart = keyCodes_1.BinaryKeybindings.extractChordPart(k.keybinding);
                    this._chords[keybindingFirstPart] = this._chords[keybindingFirstPart] || Object.create(null);
                    this._chords[keybindingFirstPart][keybindingChordPart] = this._chords[keybindingFirstPart][keybindingChordPart] || [];
                    this._chords[keybindingFirstPart][keybindingChordPart].push(entry);
                    this._addKeyPress(keybindingFirstPart, entry, k);
                }
                else {
                    this._addKeyPress(k.keybinding, entry, k);
                }
            }
        }
        KeybindingResolver._isTargetedForRemoval = function (defaultKb, keybinding, command, when) {
            if (defaultKb.actualCommand !== command) {
                return false;
            }
            if (keybinding) {
                if (defaultKb.keybinding !== keybinding) {
                    return false;
                }
            }
            if (when) {
                if (!defaultKb.when) {
                    return false;
                }
                if (!when.equals(defaultKb.when)) {
                    return false;
                }
            }
            return true;
        };
        KeybindingResolver.combine = function (rawDefaults, rawOverrides) {
            var defaults = rawDefaults.map(function (kb) { return NormalizedKeybindingItem.fromKeybindingItem(kb, true); });
            var overrides = [];
            for (var i = 0, len = rawOverrides.length; i < len; i++) {
                var override = NormalizedKeybindingItem.fromKeybindingItem(rawOverrides[i], false);
                if (!override.command || override.command.length === 0 || override.command.charAt(0) !== '-') {
                    overrides.push(override);
                    continue;
                }
                var commandToRemove = override.command.substr(1);
                var keybindingToRemove = override.keybinding;
                var whenToRemove = override.when;
                for (var j = defaults.length - 1; j >= 0; j--) {
                    if (this._isTargetedForRemoval(defaults[j], keybindingToRemove, commandToRemove, whenToRemove)) {
                        defaults.splice(j, 1);
                    }
                }
            }
            return defaults.concat(overrides);
        };
        KeybindingResolver.prototype._addKeyPress = function (keypress, entry, item) {
            if (!this._map[keypress]) {
                // There is no conflict so far
                this._map[keypress] = [entry];
                this._addToLookupMap(item);
                return;
            }
            var conflicts = this._map[keypress];
            for (var i = conflicts.length - 1; i >= 0; i--) {
                var conflict = conflicts[i];
                if (conflict.commandId === item.command) {
                    continue;
                }
                if (keyCodes_1.BinaryKeybindings.hasChord(conflict.keybinding) && keyCodes_1.BinaryKeybindings.hasChord(entry.keybinding) && conflict.keybinding !== entry.keybinding) {
                    // The conflict only shares the chord start with this command
                    continue;
                }
                if (KeybindingResolver.whenIsEntirelyIncluded(true, conflict.when, item.when)) {
                    // `item` completely overwrites `conflict`
                    if (this._shouldWarnOnConflict && item.isDefault) {
                        console.warn('Conflict detected, command `' + conflict.commandId + '` cannot be triggered by ' + keyCodes_1.Keybinding.toUserSettingsLabel(keypress) + ' due to ' + item.command);
                    }
                    this._lookupMapUnreachable[conflict.commandId] = this._lookupMapUnreachable[conflict.commandId] || [];
                    this._lookupMapUnreachable[conflict.commandId].push(conflict.keybinding);
                }
            }
            conflicts.push(entry);
            this._addToLookupMap(item);
        };
        /**
         * Returns true if `a` is completely covered by `b`.
         * Returns true if `b` is a more relaxed `a`.
         * Return true if (`a` === true implies `b` === true).
         */
        KeybindingResolver.whenIsEntirelyIncluded = function (inNormalizedForm, a, b) {
            if (!inNormalizedForm) {
                a = a ? a.normalize() : null;
                b = b ? b.normalize() : null;
            }
            if (!b) {
                return true;
            }
            if (!a) {
                return false;
            }
            var aRulesArr = a.serialize().split(' && ');
            var bRulesArr = b.serialize().split(' && ');
            var aRules = Object.create(null);
            for (var i = 0, len = aRulesArr.length; i < len; i++) {
                aRules[aRulesArr[i]] = true;
            }
            for (var i = 0, len = bRulesArr.length; i < len; i++) {
                if (!aRules[bRulesArr[i]]) {
                    return false;
                }
            }
            return true;
        };
        KeybindingResolver.prototype._addToLookupMap = function (item) {
            if (!item.command) {
                return;
            }
            this._lookupMap[item.command] = this._lookupMap[item.command] || [];
            this._lookupMap[item.command].push(item);
        };
        KeybindingResolver.prototype.getDefaultBoundCommands = function () {
            return this._defaultBoundCommands;
        };
        KeybindingResolver.prototype.getDefaultKeybindings = function () {
            var out = new OutputBuilder();
            out.writeLine('[');
            var lastIndex = this._defaultKeybindings.length - 1;
            this._defaultKeybindings.forEach(function (k, index) {
                IOSupport.writeKeybindingItem(out, k);
                if (index !== lastIndex) {
                    out.writeLine(',');
                }
                else {
                    out.writeLine();
                }
            });
            out.writeLine(']');
            return out.toString();
        };
        KeybindingResolver.prototype.lookupKeybinding = function (commandId) {
            var rawPossibleTriggers = this._lookupMap[commandId];
            if (!rawPossibleTriggers) {
                return [];
            }
            var possibleTriggers = rawPossibleTriggers.map(function (possibleTrigger) { return possibleTrigger.keybinding; });
            var remove = this._lookupMapUnreachable[commandId];
            if (remove) {
                possibleTriggers = possibleTriggers.filter(function (possibleTrigger) {
                    return remove.indexOf(possibleTrigger) === -1;
                });
            }
            var seenKeys = [];
            var result = possibleTriggers.filter(function (possibleTrigger) {
                if (seenKeys.indexOf(possibleTrigger) >= 0) {
                    return false;
                }
                seenKeys.push(possibleTrigger);
                return true;
            });
            return result.map(function (trigger) {
                return new keyCodes_1.Keybinding(trigger);
            }).reverse(); // sort most specific to the top
        };
        KeybindingResolver.prototype.resolve = function (context, currentChord, keypress) {
            // console.log('resolve: ' + Keybinding.toLabel(keypress));
            var lookupMap = null;
            if (currentChord !== 0) {
                var chords = this._chords[currentChord];
                if (!chords) {
                    return null;
                }
                lookupMap = chords[keypress];
            }
            else {
                lookupMap = this._map[keypress];
            }
            var result = this._findCommand(context, lookupMap);
            if (!result) {
                return null;
            }
            if (currentChord === 0 && keyCodes_1.BinaryKeybindings.hasChord(result.keybinding)) {
                return {
                    enterChord: keypress,
                    commandId: null
                };
            }
            return {
                enterChord: 0,
                commandId: result.commandId
            };
        };
        KeybindingResolver.prototype._findCommand = function (context, matches) {
            if (!matches) {
                return null;
            }
            for (var i = matches.length - 1; i >= 0; i--) {
                var k = matches[i];
                if (!KeybindingResolver.contextMatchesRules(context, k.when)) {
                    continue;
                }
                return k;
            }
            return null;
        };
        KeybindingResolver.contextMatchesRules = function (context, rules) {
            if (!rules) {
                return true;
            }
            return rules.evaluate(context);
        };
        return KeybindingResolver;
    }());
    exports.KeybindingResolver = KeybindingResolver;
    function rightPaddedString(str, minChars) {
        if (str.length < minChars) {
            return str + (new Array(minChars - str.length).join(' '));
        }
        return str;
    }
    function sorter(a, b) {
        if (a.weight1 !== b.weight1) {
            return a.weight1 - b.weight1;
        }
        if (a.command < b.command) {
            return -1;
        }
        if (a.command > b.command) {
            return 1;
        }
        return a.weight2 - b.weight2;
    }
    var OutputBuilder = (function () {
        function OutputBuilder() {
            this._lines = [];
            this._currentLine = '';
        }
        OutputBuilder.prototype.write = function (str) {
            this._currentLine += str;
        };
        OutputBuilder.prototype.writeLine = function (str) {
            if (str === void 0) { str = ''; }
            this._lines.push(this._currentLine + str);
            this._currentLine = '';
        };
        OutputBuilder.prototype.toString = function () {
            this.writeLine();
            return this._lines.join('\n');
        };
        return OutputBuilder;
    }());
    exports.OutputBuilder = OutputBuilder;
    var IOSupport = (function () {
        function IOSupport() {
        }
        IOSupport.writeKeybindingItem = function (out, item) {
            var quotedSerializedKeybinding = JSON.stringify(IOSupport.writeKeybinding(item.keybinding));
            out.write("{ \"key\": " + rightPaddedString(quotedSerializedKeybinding + ',', 25) + " \"command\": ");
            var serializedWhen = item.when ? item.when.serialize() : '';
            var quotedSerializeCommand = JSON.stringify(item.command);
            if (serializedWhen.length > 0) {
                out.write(quotedSerializeCommand + ",");
                out.writeLine();
                out.write("                                     \"when\": \"" + serializedWhen + "\" ");
            }
            else {
                out.write(quotedSerializeCommand + " ");
            }
            //		out.write(String(item.weight));
            out.write('}');
        };
        IOSupport.readKeybindingItem = function (input, index) {
            var key = IOSupport.readKeybinding(input.key);
            var when = IOSupport.readKeybindingWhen(input.when);
            return {
                keybinding: key,
                command: input.command,
                when: when,
                weight1: 1000,
                weight2: index
            };
        };
        IOSupport.writeKeybinding = function (input, Platform) {
            if (Platform === void 0) { Platform = platform; }
            return keyCodes_1.Keybinding.toUserSettingsLabel(input, Platform);
        };
        IOSupport.readKeybinding = function (input, Platform) {
            if (Platform === void 0) { Platform = platform; }
            return keyCodes_1.Keybinding.fromUserSettingsLabel(input, Platform);
        };
        IOSupport.readKeybindingWhen = function (input) {
            return keybindingService_1.KbExpr.deserialize(input);
        };
        return IOSupport;
    }());
    exports.IOSupport = IOSupport;
});

define(__m[73], __M([0,1,15]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IMarkerService = instantiation_1.createDecorator('markerService');
    (function (MarkerType) {
        MarkerType[MarkerType["transient"] = 1] = "transient";
        MarkerType[MarkerType["permanent"] = 2] = "permanent";
    })(exports.MarkerType || (exports.MarkerType = {}));
    var MarkerType = exports.MarkerType;
});

define(__m[405], __M([0,1,37,78,10,48,29,16,32,73]), function (require, exports, arrays, network, strings, collections, uri_1, event_1, severity_1, markers_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Key;
    (function (Key) {
        function fromValue(value) {
            var regexp = /^(.*)(.*)$/.exec(value);
            return {
                owner: regexp[1],
                resource: uri_1.default.parse(regexp[2])
            };
        }
        Key.fromValue = fromValue;
        function valueOf(k) {
            return k.owner + '' + k.resource;
        }
        Key.valueOf = valueOf;
        var _selectorPattern = '^({0})({1})$';
        function selector(owner, resource) {
            return new RegExp(strings.format(_selectorPattern, owner ? strings.escapeRegExpCharacters(owner) : '.*', resource ? strings.escapeRegExpCharacters(resource.toString()) : '.*'));
        }
        Key.selector = selector;
        function raw(owner, resource) {
            return owner + '' + resource;
        }
        Key.raw = raw;
    })(Key || (Key = {}));
    var MarkerService = (function () {
        function MarkerService() {
            this.serviceId = markers_1.IMarkerService;
            this._data = Object.create(null);
            this._stats = this._emptyStats();
            this._onMarkerChanged = new event_1.Emitter();
        }
        MarkerService.prototype.getStatistics = function () {
            return this._stats;
        };
        Object.defineProperty(MarkerService.prototype, "onMarkerChanged", {
            // ---- IMarkerService ------------------------------------------
            get: function () {
                return this._onMarkerChanged ? this._onMarkerChanged.event : null;
            },
            enumerable: true,
            configurable: true
        });
        MarkerService.prototype.changeOne = function (owner, resource, markers) {
            if (this._doChangeOne(owner, resource, markers)) {
                this._onMarkerChanged.fire([resource]);
            }
        };
        MarkerService.prototype.remove = function (owner, resources) {
            if (arrays.isFalsyOrEmpty(resources)) {
                return;
            }
            var changedResources;
            for (var _i = 0, resources_1 = resources; _i < resources_1.length; _i++) {
                var resource = resources_1[_i];
                if (this._doChangeOne(owner, resource, undefined)) {
                    if (!changedResources) {
                        changedResources = [];
                    }
                    changedResources.push(resource);
                }
            }
            if (changedResources) {
                this._onMarkerChanged.fire(changedResources);
            }
        };
        MarkerService.prototype._doChangeOne = function (owner, resource, markers) {
            var key = Key.raw(owner, resource), oldMarkers = this._data[key], hasOldMarkers = !arrays.isFalsyOrEmpty(oldMarkers), getsNewMarkers = !arrays.isFalsyOrEmpty(markers), oldStats = this._computeStats(oldMarkers), newStats = this._computeStats(markers);
            if (!hasOldMarkers && !getsNewMarkers) {
                return;
            }
            if (getsNewMarkers) {
                this._data[key] = markers;
            }
            else if (hasOldMarkers) {
                delete this._data[key];
            }
            if (this._isStatRelevant(resource)) {
                this._updateStatsMinus(oldStats);
                this._updateStatsPlus(newStats);
            }
            return true;
        };
        MarkerService.prototype.changeAll = function (owner, data) {
            var _this = this;
            var changedResources = Object.create(null);
            // remove and record old markers
            var oldStats = this._emptyStats();
            this._forEach(owner, undefined, undefined, -1, function (e, r) {
                var resource = Key.fromValue(e.key).resource;
                if (_this._isStatRelevant(resource)) {
                    _this._updateStatsPlus(oldStats, _this._computeStats(e.value));
                }
                changedResources[resource.toString()] = resource;
                r();
            });
            this._updateStatsMinus(oldStats);
            // add and record new markers
            if (!arrays.isFalsyOrEmpty(data)) {
                var newStats_1 = this._emptyStats();
                data.forEach(function (d) {
                    changedResources[d.resource.toString()] = d.resource;
                    collections.lookupOrInsert(_this._data, Key.raw(owner, d.resource), []).push(d.marker);
                    if (_this._isStatRelevant(d.resource)) {
                        _this._updateStatsMarker(newStats_1, d.marker);
                    }
                });
                this._updateStatsPlus(newStats_1);
            }
            this._onMarkerChanged.fire(collections.values(changedResources));
        };
        MarkerService.prototype.read = function (filter) {
            var _this = this;
            if (filter === void 0) { filter = Object.create(null); }
            var ret = [];
            this._forEach(filter.owner, filter.resource, filter.selector, filter.take, function (entry) { return _this._fromEntry(entry, ret); });
            return ret;
        };
        MarkerService.prototype._isStatRelevant = function (resource) {
            //TODO@Dirk this is a hack
            return resource.scheme !== network.Schemas.inMemory;
        };
        MarkerService.prototype._forEach = function (owner, resource, regexp, take, callback) {
            //TODO@Joh: be smart and use an index
            var selector = regexp || Key.selector(owner, resource), took = 0;
            collections.forEach(this._data, function (entry, remove) {
                if (selector.test(entry.key)) {
                    callback(entry, remove);
                    if (take > 0 && took++ >= take) {
                        return false;
                    }
                }
            });
        };
        MarkerService.prototype._fromEntry = function (entry, bucket) {
            var key = Key.fromValue(entry.key);
            entry.value.forEach(function (data) {
                // before reading, we sanitize the data
                // skip entry if not sanitizable
                var ok = MarkerService._sanitize(data);
                if (!ok) {
                    return;
                }
                bucket.push({
                    owner: key.owner,
                    resource: key.resource,
                    code: data.code,
                    message: data.message,
                    source: data.source,
                    severity: data.severity,
                    startLineNumber: data.startLineNumber,
                    startColumn: data.startColumn,
                    endLineNumber: data.endLineNumber,
                    endColumn: data.endColumn
                });
            });
        };
        MarkerService.prototype._computeStats = function (markers) {
            var errors = 0, warnings = 0, infos = 0, unknwons = 0;
            if (markers) {
                for (var i = 0; i < markers.length; i++) {
                    var marker = markers[i];
                    if (marker.severity) {
                        switch (marker.severity) {
                            case severity_1.default.Error:
                                errors++;
                                break;
                            case severity_1.default.Warning:
                                warnings++;
                                break;
                            case severity_1.default.Info:
                                infos++;
                                break;
                            default:
                                unknwons++;
                                break;
                        }
                    }
                    else {
                        unknwons++;
                    }
                }
            }
            return {
                errors: errors,
                warnings: warnings,
                infos: infos,
                unknwons: unknwons
            };
        };
        MarkerService.prototype._emptyStats = function () {
            return { errors: 0, warnings: 0, infos: 0, unknwons: 0 };
        };
        MarkerService.prototype._updateStatsPlus = function (toUpdate, toAdd) {
            if (!toAdd) {
                toAdd = toUpdate;
                toUpdate = this._stats;
            }
            toUpdate.errors += toAdd.errors;
            toUpdate.warnings += toAdd.warnings;
            toUpdate.infos += toAdd.infos;
            toUpdate.unknwons += toAdd.unknwons;
        };
        MarkerService.prototype._updateStatsMinus = function (toUpdate, toSubtract) {
            if (!toSubtract) {
                toSubtract = toUpdate;
                toUpdate = this._stats;
            }
            toUpdate.errors -= toSubtract.errors;
            toUpdate.warnings -= toSubtract.warnings;
            toUpdate.infos -= toSubtract.infos;
            toUpdate.unknwons -= toSubtract.unknwons;
        };
        MarkerService.prototype._updateStatsMarker = function (toUpdate, marker) {
            switch (marker.severity) {
                case severity_1.default.Error:
                    toUpdate.errors++;
                    break;
                case severity_1.default.Warning:
                    toUpdate.warnings++;
                    break;
                case severity_1.default.Info:
                    toUpdate.infos++;
                    break;
                default:
                    toUpdate.unknwons++;
                    break;
            }
        };
        MarkerService._sanitize = function (data) {
            if (!data.message) {
                return false;
            }
            data.code = data.code || null;
            data.startLineNumber = data.startLineNumber > 0 ? data.startLineNumber : 1;
            data.startColumn = data.startColumn > 0 ? data.startColumn : 1;
            data.endLineNumber = data.endLineNumber >= data.startLineNumber ? data.endLineNumber : data.startLineNumber;
            data.endColumn = data.endColumn > 0 ? data.endColumn : data.startColumn;
            return true;
        };
        return MarkerService;
    }());
    exports.MarkerService = MarkerService;
});

define(__m[42], __M([0,1,373,2,32,15,50]), function (require, exports, nls, winjs_base_1, severity_1, instantiation_1, actions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.CloseAction = new actions_1.Action('close.message', nls.localize(0, null), null, true, function () { return winjs_base_1.TPromise.as(true); });
    exports.CancelAction = new actions_1.Action('close.message', nls.localize(1, null), null, true, function () { return winjs_base_1.TPromise.as(true); });
    exports.IMessageService = instantiation_1.createDecorator('messageService');
    exports.Severity = severity_1.default;
});

define(__m[147], __M([0,1,2,15]), function (require, exports, winjs_base_1, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IOpenerService = instantiation_1.createDecorator('openerService');
    exports.NullOpenerService = Object.freeze({
        serviceId: undefined,
        open: function () { return winjs_base_1.TPromise.as(undefined); }
    });
});

define(__m[33], __M([0,1,26,47]), function (require, exports, Types, Assert) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var RegistryImpl = (function () {
        function RegistryImpl() {
            this.data = {};
        }
        RegistryImpl.prototype.add = function (id, data) {
            Assert.ok(Types.isString(id));
            Assert.ok(Types.isObject(data));
            Assert.ok(!this.data.hasOwnProperty(id), 'There is already an extension with this id');
            this.data[id] = data;
        };
        RegistryImpl.prototype.knows = function (id) {
            return this.data.hasOwnProperty(id);
        };
        RegistryImpl.prototype.as = function (id) {
            return this.data[id] || null;
        };
        return RegistryImpl;
    }());
    exports.Registry = new RegistryImpl();
    /**
     * A base class for registries that leverage the instantiation service to create instances.
     */
    var BaseRegistry = (function () {
        function BaseRegistry() {
            this.toBeInstantiated = [];
            this.instances = [];
        }
        BaseRegistry.prototype.setInstantiationService = function (service) {
            this.instantiationService = service;
            while (this.toBeInstantiated.length > 0) {
                var entry = this.toBeInstantiated.shift();
                this.instantiate(entry);
            }
        };
        BaseRegistry.prototype.instantiate = function (ctor) {
            var instance = this.instantiationService.createInstance(ctor);
            this.instances.push(instance);
        };
        BaseRegistry.prototype._register = function (ctor) {
            if (this.instantiationService) {
                this.instantiate(ctor);
            }
            else {
                this.toBeInstantiated.push(ctor);
            }
        };
        BaseRegistry.prototype._getInstances = function () {
            return this.instances.slice(0);
        };
        BaseRegistry.prototype._setInstances = function (instances) {
            this.instances = instances;
        };
        return BaseRegistry;
    }());
    exports.BaseRegistry = BaseRegistry;
});

define(__m[30], __M([0,1,33]), function (require, exports, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditorBrowserRegistry;
    (function (EditorBrowserRegistry) {
        // --- Editor Contributions
        function registerEditorContribution(ctor) {
            platform_1.Registry.as(Extensions.EditorContributions).registerEditorBrowserContribution(ctor);
        }
        EditorBrowserRegistry.registerEditorContribution = registerEditorContribution;
        function getEditorContributions() {
            return platform_1.Registry.as(Extensions.EditorContributions).getEditorBrowserContributions();
        }
        EditorBrowserRegistry.getEditorContributions = getEditorContributions;
    })(EditorBrowserRegistry = exports.EditorBrowserRegistry || (exports.EditorBrowserRegistry = {}));
    var SimpleEditorContributionDescriptor = (function () {
        function SimpleEditorContributionDescriptor(ctor) {
            this._ctor = ctor;
        }
        SimpleEditorContributionDescriptor.prototype.createInstance = function (instantiationService, editor) {
            // cast added to help the compiler, can remove once IConstructorSignature1 has been removed
            return instantiationService.createInstance(this._ctor, editor);
        };
        return SimpleEditorContributionDescriptor;
    }());
    // Editor extension points
    var Extensions = {
        EditorContributions: 'editor.contributions'
    };
    var EditorContributionRegistry = (function () {
        function EditorContributionRegistry() {
            this.editorContributions = [];
        }
        EditorContributionRegistry.prototype.registerEditorBrowserContribution = function (ctor) {
            this.editorContributions.push(new SimpleEditorContributionDescriptor(ctor));
        };
        EditorContributionRegistry.prototype.getEditorBrowserContributions = function () {
            return this.editorContributions.slice(0);
        };
        return EditorContributionRegistry;
    }());
    platform_1.Registry.add(Extensions.EditorContributions, new EditorContributionRegistry());
});

define(__m[45], __M([0,1,316,16,33]), function (require, exports, nls, event_1, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // Define extension point ids
    exports.Extensions = {
        ModesRegistry: 'editor.modesRegistry'
    };
    var EditorModesRegistry = (function () {
        function EditorModesRegistry() {
            this._onDidAddCompatModes = new event_1.Emitter();
            this.onDidAddCompatModes = this._onDidAddCompatModes.event;
            this._onDidAddLanguages = new event_1.Emitter();
            this.onDidAddLanguages = this._onDidAddLanguages.event;
            this._compatModes = [];
            this._languages = [];
        }
        // --- compat modes
        EditorModesRegistry.prototype.registerCompatModes = function (def) {
            this._compatModes = this._compatModes.concat(def);
            this._onDidAddCompatModes.fire(def);
        };
        EditorModesRegistry.prototype.registerCompatMode = function (def) {
            this._compatModes.push(def);
            this._onDidAddCompatModes.fire([def]);
        };
        EditorModesRegistry.prototype.getCompatModes = function () {
            return this._compatModes.slice(0);
        };
        // --- languages
        EditorModesRegistry.prototype.registerLanguage = function (def) {
            this._languages.push(def);
            this._onDidAddLanguages.fire([def]);
        };
        EditorModesRegistry.prototype.registerLanguages = function (def) {
            this._languages = this._languages.concat(def);
            this._onDidAddLanguages.fire(def);
        };
        EditorModesRegistry.prototype.getLanguages = function () {
            return this._languages.slice(0);
        };
        return EditorModesRegistry;
    }());
    exports.EditorModesRegistry = EditorModesRegistry;
    exports.ModesRegistry = new EditorModesRegistry();
    platform_1.Registry.add(exports.Extensions.ModesRegistry, exports.ModesRegistry);
    exports.ModesRegistry.registerLanguage({
        id: 'plaintext',
        extensions: ['.txt', '.gitignore'],
        aliases: [nls.localize(0, null), 'text'],
        mimetypes: ['text/plain']
    });
});

define(__m[411], __M([0,1,8,16,144,10,45]), function (require, exports, errors_1, event_1, mime, strings, modesRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var LanguagesRegistry = (function () {
        function LanguagesRegistry(useModesRegistry) {
            var _this = this;
            if (useModesRegistry === void 0) { useModesRegistry = true; }
            this._onDidAddModes = new event_1.Emitter();
            this.onDidAddModes = this._onDidAddModes.event;
            this.knownModeIds = {};
            this.mime2LanguageId = {};
            this.name2LanguageId = {};
            this.id2Name = {};
            this.id2Extensions = {};
            this.compatModes = {};
            this.lowerName2Id = {};
            this.id2ConfigurationFiles = {};
            if (useModesRegistry) {
                this._registerCompatModes(modesRegistry_1.ModesRegistry.getCompatModes());
                modesRegistry_1.ModesRegistry.onDidAddCompatModes(function (m) { return _this._registerCompatModes(m); });
                this._registerLanguages(modesRegistry_1.ModesRegistry.getLanguages());
                modesRegistry_1.ModesRegistry.onDidAddLanguages(function (m) { return _this._registerLanguages(m); });
            }
        }
        LanguagesRegistry.prototype._registerCompatModes = function (defs) {
            var addedModes = [];
            for (var i = 0; i < defs.length; i++) {
                var def = defs[i];
                this._registerLanguage({
                    id: def.id,
                    extensions: def.extensions,
                    filenames: def.filenames,
                    firstLine: def.firstLine,
                    aliases: def.aliases,
                    mimetypes: def.mimetypes
                });
                this.compatModes[def.id] = {
                    moduleId: def.moduleId,
                    ctorName: def.ctorName,
                    deps: def.deps
                };
                addedModes.push(def.id);
            }
            this._onDidAddModes.fire(addedModes);
        };
        LanguagesRegistry.prototype._registerLanguages = function (desc) {
            var addedModes = [];
            for (var i = 0; i < desc.length; i++) {
                this._registerLanguage(desc[i]);
                addedModes.push(desc[i].id);
            }
            this._onDidAddModes.fire(addedModes);
        };
        LanguagesRegistry.prototype._setLanguageName = function (languageId, languageName, force) {
            var prevName = this.id2Name[languageId];
            if (prevName) {
                if (!force) {
                    return;
                }
                delete this.name2LanguageId[prevName];
            }
            this.name2LanguageId[languageName] = languageId;
            this.id2Name[languageId] = languageName;
        };
        LanguagesRegistry.prototype._registerLanguage = function (lang) {
            this.knownModeIds[lang.id] = true;
            var primaryMime = null;
            if (typeof lang.mimetypes !== 'undefined' && Array.isArray(lang.mimetypes)) {
                for (var i = 0; i < lang.mimetypes.length; i++) {
                    if (!primaryMime) {
                        primaryMime = lang.mimetypes[i];
                    }
                    this.mime2LanguageId[lang.mimetypes[i]] = lang.id;
                }
            }
            if (!primaryMime) {
                primaryMime = 'text/x-' + lang.id;
                this.mime2LanguageId[primaryMime] = lang.id;
            }
            if (Array.isArray(lang.extensions)) {
                this.id2Extensions[lang.id] = this.id2Extensions[lang.id] || [];
                for (var _i = 0, _a = lang.extensions; _i < _a.length; _i++) {
                    var extension = _a[_i];
                    mime.registerTextMime({ mime: primaryMime, extension: extension });
                    this.id2Extensions[lang.id].push(extension);
                }
            }
            if (Array.isArray(lang.filenames)) {
                for (var _b = 0, _c = lang.filenames; _b < _c.length; _b++) {
                    var filename = _c[_b];
                    mime.registerTextMime({ mime: primaryMime, filename: filename });
                }
            }
            if (Array.isArray(lang.filenamePatterns)) {
                for (var _d = 0, _e = lang.filenamePatterns; _d < _e.length; _d++) {
                    var filenamePattern = _e[_d];
                    mime.registerTextMime({ mime: primaryMime, filepattern: filenamePattern });
                }
            }
            if (typeof lang.firstLine === 'string' && lang.firstLine.length > 0) {
                var firstLineRegexStr = lang.firstLine;
                if (firstLineRegexStr.charAt(0) !== '^') {
                    firstLineRegexStr = '^' + firstLineRegexStr;
                }
                try {
                    var firstLineRegex = new RegExp(firstLineRegexStr);
                    if (!strings.regExpLeadsToEndlessLoop(firstLineRegex)) {
                        mime.registerTextMime({ mime: primaryMime, firstline: firstLineRegex });
                    }
                }
                catch (err) {
                    // Most likely, the regex was bad
                    errors_1.onUnexpectedError(err);
                }
            }
            this.lowerName2Id[lang.id.toLowerCase()] = lang.id;
            if (typeof lang.aliases !== 'undefined' && Array.isArray(lang.aliases)) {
                for (var i = 0; i < lang.aliases.length; i++) {
                    if (!lang.aliases[i] || lang.aliases[i].length === 0) {
                        continue;
                    }
                    this.lowerName2Id[lang.aliases[i].toLowerCase()] = lang.id;
                }
            }
            var containsAliases = (typeof lang.aliases !== 'undefined' && Array.isArray(lang.aliases) && lang.aliases.length > 0);
            if (containsAliases && lang.aliases[0] === null) {
            }
            else {
                var bestName = (containsAliases ? lang.aliases[0] : null) || lang.id;
                this._setLanguageName(lang.id, bestName, containsAliases);
            }
            if (typeof lang.configuration === 'string') {
                this.id2ConfigurationFiles[lang.id] = this.id2ConfigurationFiles[lang.id] || [];
                this.id2ConfigurationFiles[lang.id].push(lang.configuration);
            }
        };
        LanguagesRegistry.prototype.isRegisteredMode = function (mimetypeOrModeId) {
            // Is this a known mime type ?
            if (hasOwnProperty.call(this.mime2LanguageId, mimetypeOrModeId)) {
                return true;
            }
            // Is this a known mode id ?
            return hasOwnProperty.call(this.knownModeIds, mimetypeOrModeId);
        };
        LanguagesRegistry.prototype.getRegisteredModes = function () {
            return Object.keys(this.knownModeIds);
        };
        LanguagesRegistry.prototype.getRegisteredLanguageNames = function () {
            return Object.keys(this.name2LanguageId);
        };
        LanguagesRegistry.prototype.getLanguageName = function (modeId) {
            return this.id2Name[modeId] || null;
        };
        LanguagesRegistry.prototype.getModeIdForLanguageNameLowercase = function (languageNameLower) {
            return this.lowerName2Id[languageNameLower] || null;
        };
        LanguagesRegistry.prototype.getConfigurationFiles = function (modeId) {
            return this.id2ConfigurationFiles[modeId] || [];
        };
        LanguagesRegistry.prototype.getMimeForMode = function (theModeId) {
            var keys = Object.keys(this.mime2LanguageId);
            for (var i = 0, len = keys.length; i < len; i++) {
                var _mime = keys[i];
                var modeId = this.mime2LanguageId[_mime];
                if (modeId === theModeId) {
                    return _mime;
                }
            }
            return null;
        };
        LanguagesRegistry.prototype.extractModeIds = function (commaSeparatedMimetypesOrCommaSeparatedIdsOrName) {
            var _this = this;
            if (!commaSeparatedMimetypesOrCommaSeparatedIdsOrName) {
                return [];
            }
            return (commaSeparatedMimetypesOrCommaSeparatedIdsOrName.
                split(',').
                map(function (mimeTypeOrIdOrName) { return mimeTypeOrIdOrName.trim(); }).
                map(function (mimeTypeOrIdOrName) {
                return _this.mime2LanguageId[mimeTypeOrIdOrName] || mimeTypeOrIdOrName;
            }).
                filter(function (modeId) {
                return _this.knownModeIds[modeId];
            }));
        };
        LanguagesRegistry.prototype.getModeIdsFromLanguageName = function (languageName) {
            if (!languageName) {
                return [];
            }
            if (hasOwnProperty.call(this.name2LanguageId, languageName)) {
                return [this.name2LanguageId[languageName]];
            }
            return [];
        };
        LanguagesRegistry.prototype.getModeIdsFromFilenameOrFirstLine = function (filename, firstLine) {
            if (!filename && !firstLine) {
                return [];
            }
            var mimeTypes = mime.guessMimeTypes(filename, firstLine);
            return this.extractModeIds(mimeTypes.join(','));
        };
        LanguagesRegistry.prototype.getCompatMode = function (modeId) {
            return this.compatModes[modeId] || null;
        };
        LanguagesRegistry.prototype.getExtensions = function (languageName) {
            var languageId = this.name2LanguageId[languageName];
            if (!languageId) {
                return [];
            }
            return this.id2Extensions[languageId];
        };
        return LanguagesRegistry;
    }());
    exports.LanguagesRegistry = LanguagesRegistry;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[412], __M([0,1,3,28,11,22,30,221]), function (require, exports, lifecycle_1, browser, dom, editorBrowser_1, editorBrowserExtensions_1) {
    'use strict';
    var IPadShowKeyboard = (function () {
        function IPadShowKeyboard(editor) {
            var _this = this;
            this.editor = editor;
            this.toDispose = [];
            if (browser.isIPad) {
                this.toDispose.push(editor.onDidChangeConfiguration(function () { return _this.update(); }));
                this.update();
            }
        }
        IPadShowKeyboard.prototype.update = function () {
            var hasWidget = (!!this.widget);
            var shouldHaveWidget = (!this.editor.getConfiguration().readOnly);
            if (!hasWidget && shouldHaveWidget) {
                this.widget = new ShowKeyboardWidget(this.editor);
            }
            else if (hasWidget && !shouldHaveWidget) {
                this.widget.dispose();
                this.widget = null;
            }
        };
        IPadShowKeyboard.prototype.getId = function () {
            return IPadShowKeyboard.ID;
        };
        IPadShowKeyboard.prototype.dispose = function () {
            this.toDispose = lifecycle_1.dispose(this.toDispose);
            if (this.widget) {
                this.widget.dispose();
                this.widget = null;
            }
        };
        IPadShowKeyboard.ID = 'editor.contrib.iPadShowKeyboard';
        return IPadShowKeyboard;
    }());
    exports.IPadShowKeyboard = IPadShowKeyboard;
    var ShowKeyboardWidget = (function () {
        function ShowKeyboardWidget(editor) {
            var _this = this;
            this.editor = editor;
            this._domNode = document.createElement('textarea');
            this._domNode.className = 'iPadShowKeyboard';
            this._toDispose = [];
            this._toDispose.push(dom.addDisposableListener(this._domNode, 'touchstart', function (e) {
                _this.editor.focus();
            }));
            this._toDispose.push(dom.addDisposableListener(this._domNode, 'focus', function (e) {
                _this.editor.focus();
            }));
            this.editor.addOverlayWidget(this);
        }
        ShowKeyboardWidget.prototype.dispose = function () {
            this.editor.removeOverlayWidget(this);
            this._toDispose = lifecycle_1.dispose(this._toDispose);
        };
        // ----- IOverlayWidget API
        ShowKeyboardWidget.prototype.getId = function () {
            return ShowKeyboardWidget.ID;
        };
        ShowKeyboardWidget.prototype.getDomNode = function () {
            return this._domNode;
        };
        ShowKeyboardWidget.prototype.getPosition = function () {
            return {
                preference: editorBrowser_1.OverlayWidgetPositionPreference.BOTTOM_RIGHT_CORNER
            };
        };
        ShowKeyboardWidget.ID = 'editor.contrib.ShowKeyboardWidget';
        return ShowKeyboardWidget;
    }());
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(IPadShowKeyboard);
});






define(__m[107], __M([0,1,2,20,25,30,300]), function (require, exports, winjs_base_1, editorAction_1, editorActionEnablement_1, editorBrowserExtensions_1, quickOpenEditorWidget_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var QuickOpenController = (function () {
        function QuickOpenController(editor) {
            this.editor = editor;
        }
        QuickOpenController.get = function (editor) {
            return editor.getContribution(QuickOpenController.ID);
        };
        QuickOpenController.prototype.getId = function () {
            return QuickOpenController.ID;
        };
        QuickOpenController.prototype.dispose = function () {
            // Dispose widget
            if (this.widget) {
                this.widget.destroy();
                this.widget = null;
            }
        };
        QuickOpenController.prototype.run = function (opts) {
            var _this = this;
            if (this.widget) {
                this.widget.destroy();
                this.widget = null;
            }
            // Create goto line widget
            if (!this.widget) {
                this.widget = new quickOpenEditorWidget_1.QuickOpenEditorWidget(this.editor, function () { return opts.onOk(); }, function () { return opts.onCancel(); }, function (value) {
                    _this.widget.setInput(opts.getModel(value), opts.getAutoFocus(value));
                }, {
                    inputAriaLabel: opts.inputAriaLabel
                });
                // Show
                this.widget.show('');
            }
        };
        QuickOpenController.ID = 'editor.controller.quickOpenController';
        return QuickOpenController;
    }());
    exports.QuickOpenController = QuickOpenController;
    /**
     * Base class for providing quick open in the editor.
     */
    var BaseEditorQuickOpenAction = (function (_super) {
        __extends(BaseEditorQuickOpenAction, _super);
        function BaseEditorQuickOpenAction(descriptor, editor, label, condition) {
            if (condition === void 0) { condition = editorActionEnablement_1.Behaviour.WidgetFocus; }
            _super.call(this, descriptor, editor, condition);
            this.label = label;
        }
        BaseEditorQuickOpenAction.prototype.run = function () {
            var _this = this;
            QuickOpenController.get(this.editor).run({
                inputAriaLabel: this._getInputAriaLabel(),
                getModel: function (value) { return _this._getModel(value); },
                getAutoFocus: function (searchValue) { return _this._getAutoFocus(searchValue); },
                onOk: function () { return _this._onClose(false); },
                onCancel: function () { return _this._onClose(true); }
            });
            // }
            // 	()=>this._onClose(false),
            // 	()=>this._onClose(true),
            // 	(value:string)=>this.onType(value),
            // )
            // this._getInputAriaLabel()
            // this.widget = new QuickOpenEditorWidget(
            // 		this.editor,
            // 		()=>this._onClose(false),
            // 		()=>this._onClose(true),
            // 		(value:string)=>this.onType(value),
            // 		{
            // 			inputAriaLabel: this._getInputAriaLabel()
            // 		}
            // 	);
            // Remember selection to be able to restore on cancel
            if (!this.lastKnownEditorSelection) {
                this.lastKnownEditorSelection = this.editor.getSelection();
            }
            return winjs_base_1.TPromise.as(true);
        };
        /**
         * Subclasses to override to provide the quick open model for the given search value.
         */
        BaseEditorQuickOpenAction.prototype._getModel = function (value) {
            throw new Error('Subclasses to implement');
        };
        /**
         * Subclasses to override to provide the quick open auto focus mode for the given search value.
         */
        BaseEditorQuickOpenAction.prototype._getAutoFocus = function (searchValue) {
            throw new Error('Subclasses to implement');
        };
        BaseEditorQuickOpenAction.prototype._getInputAriaLabel = function () {
            throw new Error('Subclasses to implement');
        };
        BaseEditorQuickOpenAction.prototype.decorateLine = function (range, editor) {
            var _this = this;
            editor.changeDecorations(function (changeAccessor) {
                var oldDecorations = [];
                if (_this.lineHighlightDecorationId) {
                    oldDecorations.push(_this.lineHighlightDecorationId);
                    _this.lineHighlightDecorationId = null;
                }
                var newDecorations = [
                    {
                        range: range,
                        options: {
                            className: 'lineHighlight',
                            isWholeLine: true
                        }
                    }
                ];
                var decorations = changeAccessor.deltaDecorations(oldDecorations, newDecorations);
                _this.lineHighlightDecorationId = decorations[0];
            });
        };
        BaseEditorQuickOpenAction.prototype.clearDecorations = function () {
            var _this = this;
            if (this.lineHighlightDecorationId) {
                this.editor.changeDecorations(function (changeAccessor) {
                    changeAccessor.deltaDecorations([_this.lineHighlightDecorationId], []);
                    _this.lineHighlightDecorationId = null;
                });
            }
        };
        /**
         * Subclasses can override this to participate in the close of quick open.
         */
        BaseEditorQuickOpenAction.prototype._onClose = function (canceled) {
            // Clear Highlight Decorations if present
            this.clearDecorations();
            // Restore selection if canceled
            if (canceled && this.lastKnownEditorSelection) {
                this.editor.setSelection(this.lastKnownEditorSelection);
                this.editor.revealRangeInCenterIfOutsideViewport(this.lastKnownEditorSelection);
            }
            this.lastKnownEditorSelection = null;
            this.editor.focus();
        };
        BaseEditorQuickOpenAction.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        return BaseEditorQuickOpenAction;
    }(editorAction_1.EditorAction));
    exports.BaseEditorQuickOpenAction = BaseEditorQuickOpenAction;
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(QuickOpenController);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[414], __M([0,1,346,105,91,7,107,234]), function (require, exports, nls, quickOpenModel_1, quickOpen_1, editorCommon, editorQuickOpen_1) {
    'use strict';
    var GotoLineEntry = (function (_super) {
        __extends(GotoLineEntry, _super);
        function GotoLineEntry(line, editor, decorator) {
            _super.call(this);
            this.editor = editor;
            this.decorator = decorator;
            this._parseResult = this._parseInput(line);
        }
        GotoLineEntry.prototype._parseInput = function (line) {
            var numbers = line.split(',').map(function (part) { return parseInt(part, 10); }).filter(function (part) { return !isNaN(part); }), position;
            if (numbers.length === 0) {
                position = { lineNumber: -1, column: -1 };
            }
            else if (numbers.length === 1) {
                position = { lineNumber: numbers[0], column: 1 };
            }
            else {
                position = { lineNumber: numbers[0], column: numbers[1] };
            }
            var editorType = this.editor.getEditorType(), model;
            switch (editorType) {
                case editorCommon.EditorType.IDiffEditor:
                    model = this.editor.getModel().modified;
                    break;
                case editorCommon.EditorType.ICodeEditor:
                    model = this.editor.getModel();
                    break;
                default:
                    throw new Error();
            }
            var isValid = model.validatePosition(position).equals(position), label;
            if (isValid) {
                if (position.column && position.column > 1) {
                    label = nls.localize(0, null, position.lineNumber, position.column);
                }
                else {
                    label = nls.localize(1, null, position.lineNumber, position.column);
                }
            }
            else if (position.lineNumber < 1 || position.lineNumber > model.getLineCount()) {
                label = nls.localize(2, null, model.getLineCount());
            }
            else {
                label = nls.localize(3, null, model.getLineMaxColumn(position.lineNumber));
            }
            return {
                position: position,
                isValid: isValid,
                label: label
            };
        };
        GotoLineEntry.prototype.getLabel = function () {
            return this._parseResult.label;
        };
        GotoLineEntry.prototype.getAriaLabel = function () {
            return nls.localize(4, null, this._parseResult.label);
        };
        GotoLineEntry.prototype.run = function (mode, context) {
            if (mode === quickOpen_1.Mode.OPEN) {
                return this.runOpen();
            }
            return this.runPreview();
        };
        GotoLineEntry.prototype.runOpen = function () {
            // No-op if range is not valid
            if (!this._parseResult.isValid) {
                return false;
            }
            // Apply selection and focus
            var range = this.toSelection();
            this.editor.setSelection(range);
            this.editor.revealRangeInCenter(range);
            this.editor.focus();
            return true;
        };
        GotoLineEntry.prototype.runPreview = function () {
            // No-op if range is not valid
            if (!this._parseResult.isValid) {
                this.decorator.clearDecorations();
                return false;
            }
            // Select Line Position
            var range = this.toSelection();
            this.editor.revealRangeInCenter(range);
            // Decorate if possible
            this.decorator.decorateLine(range, this.editor);
            return false;
        };
        GotoLineEntry.prototype.toSelection = function () {
            return {
                startLineNumber: this._parseResult.position.lineNumber,
                startColumn: this._parseResult.position.column,
                endLineNumber: this._parseResult.position.lineNumber,
                endColumn: this._parseResult.position.column
            };
        };
        return GotoLineEntry;
    }(quickOpenModel_1.QuickOpenEntry));
    exports.GotoLineEntry = GotoLineEntry;
    var GotoLineAction = (function (_super) {
        __extends(GotoLineAction, _super);
        function GotoLineAction(descriptor, editor) {
            _super.call(this, descriptor, editor, nls.localize(5, null));
        }
        GotoLineAction.prototype._getModel = function (value) {
            return new quickOpenModel_1.QuickOpenModel([new GotoLineEntry(value, this.editor, this)]);
        };
        GotoLineAction.prototype._getAutoFocus = function (searchValue) {
            return {
                autoFocusFirstEntry: searchValue.length > 0
            };
        };
        GotoLineAction.prototype._getInputAriaLabel = function () {
            return nls.localize(6, null);
        };
        GotoLineAction.ID = 'editor.action.gotoLine';
        return GotoLineAction;
    }(editorQuickOpen_1.BaseEditorQuickOpenAction));
    exports.GotoLineAction = GotoLineAction;
});















define(__m[415], __M([0,1,348,8,65,10,2,105,91,19,25,107]), function (require, exports, nls, errors_1, filters_1, strings, winjs_base_1, quickOpenModel_1, quickOpen_1, keybindingService_1, editorActionEnablement_1, editorQuickOpen_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EditorActionCommandEntry = (function (_super) {
        __extends(EditorActionCommandEntry, _super);
        function EditorActionCommandEntry(key, highlights, action, editor) {
            _super.call(this);
            this.key = key;
            this.setHighlights(highlights);
            this.action = action;
            this.editor = editor;
        }
        EditorActionCommandEntry.prototype.getLabel = function () {
            return this.action.label;
        };
        EditorActionCommandEntry.prototype.getAriaLabel = function () {
            return nls.localize(0, null, this.getLabel());
        };
        EditorActionCommandEntry.prototype.getGroupLabel = function () {
            return this.key;
        };
        EditorActionCommandEntry.prototype.run = function (mode, context) {
            var _this = this;
            if (mode === quickOpen_1.Mode.OPEN) {
                // Use a timeout to give the quick open widget a chance to close itself first
                winjs_base_1.TPromise.timeout(50).done(function () {
                    // Some actions are enabled only when editor has focus
                    _this.editor.focus();
                    if (_this.action.enabled) {
                        try {
                            var promise = _this.action.run() || winjs_base_1.TPromise.as(null);
                            promise.done(null, errors_1.onUnexpectedError);
                        }
                        catch (error) {
                            errors_1.onUnexpectedError(error);
                        }
                    }
                }, errors_1.onUnexpectedError);
                return true;
            }
            return false;
        };
        return EditorActionCommandEntry;
    }(quickOpenModel_1.QuickOpenEntryGroup));
    exports.EditorActionCommandEntry = EditorActionCommandEntry;
    var QuickCommandAction = (function (_super) {
        __extends(QuickCommandAction, _super);
        function QuickCommandAction(descriptor, editor, keybindingService) {
            _super.call(this, descriptor, editor, nls.localize(1, null), editorActionEnablement_1.Behaviour.WidgetFocus | editorActionEnablement_1.Behaviour.ShowInContextMenu);
            this._keybindingService = keybindingService;
        }
        QuickCommandAction.prototype._getModel = function (value) {
            return new quickOpenModel_1.QuickOpenModel(this._editorActionsToEntries(this.editor.getActions(), value));
        };
        QuickCommandAction.prototype.getGroupId = function () {
            return '4_tools/1_commands';
        };
        QuickCommandAction.prototype._sort = function (elementA, elementB) {
            var elementAName = elementA.getLabel().toLowerCase();
            var elementBName = elementB.getLabel().toLowerCase();
            return strings.localeCompare(elementAName, elementBName);
        };
        QuickCommandAction.prototype._editorActionsToEntries = function (actions, searchValue) {
            var _this = this;
            var entries = [];
            for (var i = 0; i < actions.length; i++) {
                var action = actions[i];
                var editorAction = action;
                if (!editorAction.isSupported()) {
                    continue; // do not show actions that are not supported in this context
                }
                var keys = this._keybindingService.lookupKeybindings(editorAction.id).map(function (k) { return _this._keybindingService.getLabelFor(k); });
                if (action.label) {
                    var highlights = filters_1.matchesFuzzy(searchValue, action.label);
                    if (highlights) {
                        entries.push(new EditorActionCommandEntry(keys.length > 0 ? keys.join(', ') : '', highlights, action, this.editor));
                    }
                }
            }
            // Sort by name
            entries = entries.sort(this._sort);
            return entries;
        };
        QuickCommandAction.prototype._getAutoFocus = function (searchValue) {
            return {
                autoFocusFirstEntry: true,
                autoFocusPrefixMatch: searchValue
            };
        };
        QuickCommandAction.prototype._getInputAriaLabel = function () {
            return nls.localize(2, null);
        };
        QuickCommandAction.ID = 'editor.action.quickCommand';
        QuickCommandAction = __decorate([
            __param(2, keybindingService_1.IKeybindingService)
        ], QuickCommandAction);
        return QuickCommandAction;
    }(editorQuickOpen_1.BaseEditorQuickOpenAction));
    exports.QuickCommandAction = QuickCommandAction;
});

define(__m[416], __M([0,1,45]), function (require, exports, modesRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    modesRegistry_1.ModesRegistry.registerCompatMode({
        id: 'handlebars',
        extensions: ['.handlebars', '.hbs'],
        aliases: ['Handlebars', 'handlebars'],
        mimetypes: ['text/x-handlebars-template'],
        moduleId: 'vs/languages/handlebars/common/handlebars',
        ctorName: 'HandlebarsMode'
    });
});

define(__m[417], __M([0,1,45]), function (require, exports, modesRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    modesRegistry_1.ModesRegistry.registerCompatMode({
        id: 'php',
        extensions: ['.php', '.php4', '.php5', '.phtml', '.ctp'],
        aliases: ['PHP', 'php'],
        mimetypes: ['application/x-php'],
        moduleId: 'vs/languages/php/common/php',
        ctorName: 'PHPMode',
        deps: ['text/html']
    });
});

define(__m[418], __M([0,1,45]), function (require, exports, modesRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    modesRegistry_1.ModesRegistry.registerCompatMode({
        id: 'razor',
        extensions: ['.cshtml'],
        aliases: ['Razor', 'razor'],
        mimetypes: ['text/x-cshtml'],
        moduleId: 'vs/languages/razor/common/razor',
        ctorName: 'RAZORMode'
    });
});

define(__m[85], __M([0,1,371,33,23]), function (require, exports, nls, platform, eventEmitter_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.Extensions = {
        JSONContribution: 'base.contributions.json'
    };
    function normalizeId(id) {
        if (id.length > 0 && id.charAt(id.length - 1) === '#') {
            return id.substring(0, id.length - 1);
        }
        return id;
    }
    var JSONContributionRegistry = (function () {
        function JSONContributionRegistry() {
            this.schemasById = {};
            this.eventEmitter = new eventEmitter_1.EventEmitter();
        }
        JSONContributionRegistry.prototype.addRegistryChangedListener = function (callback) {
            return this.eventEmitter.addListener2('registryChanged', callback);
        };
        JSONContributionRegistry.prototype.registerSchema = function (uri, unresolvedSchemaContent) {
            this.schemasById[normalizeId(uri)] = unresolvedSchemaContent;
            this.eventEmitter.emit('registryChanged', {});
        };
        JSONContributionRegistry.prototype.getSchemaContributions = function () {
            return {
                schemas: this.schemasById,
            };
        };
        return JSONContributionRegistry;
    }());
    var jsonContributionRegistry = new JSONContributionRegistry();
    platform.Registry.add(exports.Extensions.JSONContribution, jsonContributionRegistry);
    // preload the schema-schema with a version that contains descriptions.
    jsonContributionRegistry.registerSchema('http://json-schema.org/draft-04/schema#', {
        'id': 'http://json-schema.org/draft-04/schema#',
        'title': nls.localize(0, null),
        '$schema': 'http://json-schema.org/draft-04/schema#',
        'definitions': {
            'schemaArray': {
                'type': 'array',
                'minItems': 1,
                'items': { '$ref': '#' }
            },
            'positiveInteger': {
                'type': 'integer',
                'minimum': 0
            },
            'positiveIntegerDefault0': {
                'allOf': [{ '$ref': '#/definitions/positiveInteger' }, { 'default': 0 }]
            },
            'simpleTypes': {
                'type': 'string',
                'enum': ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string']
            },
            'stringArray': {
                'type': 'array',
                'items': { 'type': 'string' },
                'minItems': 1,
                'uniqueItems': true
            }
        },
        'type': 'object',
        'properties': {
            'id': {
                'type': 'string',
                'format': 'uri',
                'description': nls.localize(1, null)
            },
            '$schema': {
                'type': 'string',
                'format': 'uri',
                'description': nls.localize(2, null)
            },
            'title': {
                'type': 'string',
                'description': nls.localize(3, null)
            },
            'description': {
                'type': 'string',
                'description': nls.localize(4, null)
            },
            'default': {
                'description': nls.localize(5, null)
            },
            'multipleOf': {
                'type': 'number',
                'minimum': 0,
                'exclusiveMinimum': true,
                'description': nls.localize(6, null)
            },
            'maximum': {
                'type': 'number',
                'description': nls.localize(7, null)
            },
            'exclusiveMaximum': {
                'type': 'boolean',
                'default': false,
                'description': nls.localize(8, null)
            },
            'minimum': {
                'type': 'number',
                'description': nls.localize(9, null)
            },
            'exclusiveMinimum': {
                'type': 'boolean',
                'default': false,
                'description': nls.localize(10, null)
            },
            'maxLength': {
                'allOf': [
                    { '$ref': '#/definitions/positiveInteger' }
                ],
                'description': nls.localize(11, null)
            },
            'minLength': {
                'allOf': [
                    { '$ref': '#/definitions/positiveIntegerDefault0' }
                ],
                'description': nls.localize(12, null)
            },
            'pattern': {
                'type': 'string',
                'format': 'regex',
                'description': nls.localize(13, null)
            },
            'additionalItems': {
                'anyOf': [
                    { 'type': 'boolean' },
                    { '$ref': '#' }
                ],
                'default': {},
                'description': nls.localize(14, null)
            },
            'items': {
                'anyOf': [
                    { '$ref': '#' },
                    { '$ref': '#/definitions/schemaArray' }
                ],
                'default': {},
                'description': nls.localize(15, null)
            },
            'maxItems': {
                'allOf': [
                    { '$ref': '#/definitions/positiveInteger' }
                ],
                'description': nls.localize(16, null)
            },
            'minItems': {
                'allOf': [
                    { '$ref': '#/definitions/positiveIntegerDefault0' }
                ],
                'description': nls.localize(17, null)
            },
            'uniqueItems': {
                'type': 'boolean',
                'default': false,
                'description': nls.localize(18, null)
            },
            'maxProperties': {
                'allOf': [
                    { '$ref': '#/definitions/positiveInteger' }
                ],
                'description': nls.localize(19, null)
            },
            'minProperties': {
                'allOf': [
                    { '$ref': '#/definitions/positiveIntegerDefault0' },
                ],
                'description': nls.localize(20, null)
            },
            'required': {
                'allOf': [
                    { '$ref': '#/definitions/stringArray' }
                ],
                'description': nls.localize(21, null)
            },
            'additionalProperties': {
                'anyOf': [
                    { 'type': 'boolean' },
                    { '$ref': '#' }
                ],
                'default': {},
                'description': nls.localize(22, null)
            },
            'definitions': {
                'type': 'object',
                'additionalProperties': { '$ref': '#' },
                'default': {},
                'description': nls.localize(23, null)
            },
            'properties': {
                'type': 'object',
                'additionalProperties': { '$ref': '#' },
                'default': {},
                'description': nls.localize(24, null)
            },
            'patternProperties': {
                'type': 'object',
                'additionalProperties': { '$ref': '#' },
                'default': {},
                'description': nls.localize(25, null)
            },
            'dependencies': {
                'type': 'object',
                'additionalProperties': {
                    'anyOf': [
                        { '$ref': '#' },
                        { '$ref': '#/definitions/stringArray' }
                    ]
                },
                'description': nls.localize(26, null)
            },
            'enum': {
                'type': 'array',
                'minItems': 1,
                'uniqueItems': true,
                'description': nls.localize(27, null)
            },
            'type': {
                'anyOf': [
                    { '$ref': '#/definitions/simpleTypes' },
                    {
                        'type': 'array',
                        'items': { '$ref': '#/definitions/simpleTypes' },
                        'minItems': 1,
                        'uniqueItems': true
                    }
                ],
                'description': nls.localize(28, null)
            },
            'format': {
                'anyOf': [
                    {
                        'type': 'string',
                        'description': nls.localize(29, null),
                        'enum': ['date-time', 'uri', 'email', 'hostname', 'ipv4', 'ipv6', 'regex']
                    }, {
                        'type': 'string'
                    }
                ]
            },
            'allOf': {
                'allOf': [
                    { '$ref': '#/definitions/schemaArray' }
                ],
                'description': nls.localize(30, null)
            },
            'anyOf': {
                'allOf': [
                    { '$ref': '#/definitions/schemaArray' }
                ],
                'description': nls.localize(31, null)
            },
            'oneOf': {
                'allOf': [
                    { '$ref': '#/definitions/schemaArray' }
                ],
                'description': nls.localize(32, null)
            },
            'not': {
                'allOf': [
                    { '$ref': '#' }
                ],
                'description': nls.localize(33, null)
            }
        },
        'dependencies': {
            'exclusiveMaximum': ['maximum'],
            'exclusiveMinimum': ['minimum']
        },
        'default': {}
    });
});

define(__m[86], __M([0,1,370,8,38,32,85,33]), function (require, exports, nls, errors_1, paths, severity_1, jsonContributionRegistry_1, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ExtensionMessageCollector = (function () {
        function ExtensionMessageCollector(messageHandler, source) {
            this._messageHandler = messageHandler;
            this._source = source;
        }
        ExtensionMessageCollector.prototype._msg = function (type, message) {
            this._messageHandler({
                type: type,
                message: message,
                source: this._source
            });
        };
        ExtensionMessageCollector.prototype.error = function (message) {
            this._msg(severity_1.default.Error, message);
        };
        ExtensionMessageCollector.prototype.warn = function (message) {
            this._msg(severity_1.default.Warning, message);
        };
        ExtensionMessageCollector.prototype.info = function (message) {
            this._msg(severity_1.default.Info, message);
        };
        return ExtensionMessageCollector;
    }());
    function isValidExtensionDescription(extensionFolderPath, extensionDescription, notices) {
        if (!extensionDescription) {
            notices.push(nls.localize(0, null));
            return false;
        }
        if (typeof extensionDescription.publisher !== 'string') {
            notices.push(nls.localize(1, null, 'publisher'));
            return false;
        }
        if (typeof extensionDescription.name !== 'string') {
            notices.push(nls.localize(2, null, 'name'));
            return false;
        }
        if (typeof extensionDescription.version !== 'string') {
            notices.push(nls.localize(3, null, 'version'));
            return false;
        }
        if (!extensionDescription.engines) {
            notices.push(nls.localize(4, null, 'engines'));
            return false;
        }
        if (typeof extensionDescription.engines.vscode !== 'string') {
            notices.push(nls.localize(5, null, 'engines.vscode'));
            return false;
        }
        if (typeof extensionDescription.extensionDependencies !== 'undefined') {
            if (!_isStringArray(extensionDescription.extensionDependencies)) {
                notices.push(nls.localize(6, null, 'extensionDependencies'));
                return false;
            }
        }
        if (typeof extensionDescription.activationEvents !== 'undefined') {
            if (!_isStringArray(extensionDescription.activationEvents)) {
                notices.push(nls.localize(7, null, 'activationEvents'));
                return false;
            }
            if (typeof extensionDescription.main === 'undefined') {
                notices.push(nls.localize(8, null, 'activationEvents', 'main'));
                return false;
            }
        }
        if (typeof extensionDescription.main !== 'undefined') {
            if (typeof extensionDescription.main !== 'string') {
                notices.push(nls.localize(9, null, 'main'));
                return false;
            }
            else {
                var normalizedAbsolutePath = paths.normalize(paths.join(extensionFolderPath, extensionDescription.main));
                if (normalizedAbsolutePath.indexOf(extensionFolderPath)) {
                    notices.push(nls.localize(10, null, normalizedAbsolutePath, extensionFolderPath));
                }
            }
            if (typeof extensionDescription.activationEvents === 'undefined') {
                notices.push(nls.localize(11, null, 'activationEvents', 'main'));
                return false;
            }
        }
        return true;
    }
    exports.isValidExtensionDescription = isValidExtensionDescription;
    var hasOwnProperty = Object.hasOwnProperty;
    var schemaRegistry = platform_1.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);
    var ExtensionPoint = (function () {
        function ExtensionPoint(name, registry) {
            this.name = name;
            this._registry = registry;
            this._handler = null;
            this._messageHandler = null;
        }
        ExtensionPoint.prototype.setHandler = function (handler) {
            if (this._handler) {
                throw new Error('Handler already set!');
            }
            this._handler = handler;
            this._handle();
        };
        ExtensionPoint.prototype.handle = function (messageHandler) {
            this._messageHandler = messageHandler;
            this._handle();
        };
        ExtensionPoint.prototype._handle = function () {
            var _this = this;
            if (!this._handler || !this._messageHandler) {
                return;
            }
            this._registry.registerPointListener(this.name, function (descriptions) {
                var users = descriptions.map(function (desc) {
                    return {
                        description: desc,
                        value: desc.contributes[_this.name],
                        collector: new ExtensionMessageCollector(_this._messageHandler, desc.extensionFolderPath)
                    };
                });
                _this._handler(users);
            });
        };
        return ExtensionPoint;
    }());
    var schemaId = 'vscode://schemas/vscode-extensions';
    var schema = {
        default: {
            'name': '{{name}}',
            'description': '{{description}}',
            'author': '{{author}}',
            'version': '{{1.0.0}}',
            'main': '{{pathToMain}}',
            'dependencies': {}
        },
        properties: {
            // engines: {
            // 	required: [ 'vscode' ],
            // 	properties: {
            // 		'vscode': {
            // 			type: 'string',
            // 			description: nls.localize('vscode.extension.engines.vscode', 'Specifies that this package only runs inside VSCode of the given version.'),
            // 		}
            // 	}
            // },
            displayName: {
                description: nls.localize(12, null),
                type: 'string'
            },
            categories: {
                description: nls.localize(13, null),
                type: 'array',
                items: {
                    type: 'string',
                    enum: ['Languages', 'Snippets', 'Linters', 'Themes', 'Debuggers', 'Productivity', 'Other']
                }
            },
            galleryBanner: {
                type: 'object',
                description: nls.localize(14, null),
                properties: {
                    color: {
                        description: nls.localize(15, null),
                        type: 'string'
                    },
                    theme: {
                        description: nls.localize(16, null),
                        type: 'string',
                        enum: ['dark', 'light']
                    }
                }
            },
            publisher: {
                description: nls.localize(17, null),
                type: 'string'
            },
            activationEvents: {
                description: nls.localize(18, null),
                type: 'array',
                items: {
                    type: 'string'
                }
            },
            extensionDependencies: {
                description: nls.localize(19, null),
                type: 'array',
                items: {
                    type: 'string'
                }
            },
            scripts: {
                type: 'object',
                properties: {
                    'vscode:prepublish': {
                        description: nls.localize(20, null),
                        type: 'string'
                    }
                }
            },
            contributes: {
                description: nls.localize(21, null),
                type: 'object',
                properties: {},
                default: {}
            }
        }
    };
    var ExtensionsRegistryImpl = (function () {
        function ExtensionsRegistryImpl() {
            this._extensionsMap = {};
            this._extensionsArr = [];
            this._activationMap = {};
            this._pointListeners = [];
            this._extensionPoints = {};
            this._oneTimeActivationEventListeners = {};
        }
        ExtensionsRegistryImpl.prototype.registerPointListener = function (point, handler) {
            var entry = {
                extensionPoint: point,
                listener: handler
            };
            this._pointListeners.push(entry);
            this._triggerPointListener(entry, ExtensionsRegistryImpl._filterWithExtPoint(this.getAllExtensionDescriptions(), point));
        };
        ExtensionsRegistryImpl.prototype.registerExtensionPoint = function (extensionPoint, jsonSchema) {
            if (hasOwnProperty.call(this._extensionPoints, extensionPoint)) {
                throw new Error('Duplicate extension point: ' + extensionPoint);
            }
            var result = new ExtensionPoint(extensionPoint, this);
            this._extensionPoints[extensionPoint] = result;
            schema.properties['contributes'].properties[extensionPoint] = jsonSchema;
            schemaRegistry.registerSchema(schemaId, schema);
            return result;
        };
        ExtensionsRegistryImpl.prototype.handleExtensionPoints = function (messageHandler) {
            var _this = this;
            Object.keys(this._extensionPoints).forEach(function (extensionPointName) {
                _this._extensionPoints[extensionPointName].handle(messageHandler);
            });
        };
        ExtensionsRegistryImpl.prototype._triggerPointListener = function (handler, desc) {
            // console.log('_triggerPointListeners: ' + desc.length + ' OF ' + handler.extensionPoint);
            if (!desc || desc.length === 0) {
                return;
            }
            try {
                handler.listener(desc);
            }
            catch (e) {
                errors_1.onUnexpectedError(e);
            }
        };
        ExtensionsRegistryImpl.prototype.registerExtensions = function (extensionDescriptions) {
            for (var i = 0, len = extensionDescriptions.length; i < len; i++) {
                var extensionDescription = extensionDescriptions[i];
                if (hasOwnProperty.call(this._extensionsMap, extensionDescription.id)) {
                    // No overwriting allowed!
                    console.error('Extension `' + extensionDescription.id + '` is already registered');
                    continue;
                }
                this._extensionsMap[extensionDescription.id] = extensionDescription;
                this._extensionsArr.push(extensionDescription);
                if (Array.isArray(extensionDescription.activationEvents)) {
                    for (var j = 0, lenJ = extensionDescription.activationEvents.length; j < lenJ; j++) {
                        var activationEvent = extensionDescription.activationEvents[j];
                        this._activationMap[activationEvent] = this._activationMap[activationEvent] || [];
                        this._activationMap[activationEvent].push(extensionDescription);
                    }
                }
            }
            for (var i = 0, len = this._pointListeners.length; i < len; i++) {
                var listenerEntry = this._pointListeners[i];
                var descriptions = ExtensionsRegistryImpl._filterWithExtPoint(extensionDescriptions, listenerEntry.extensionPoint);
                this._triggerPointListener(listenerEntry, descriptions);
            }
        };
        ExtensionsRegistryImpl._filterWithExtPoint = function (input, point) {
            return input.filter(function (desc) {
                return (desc.contributes && hasOwnProperty.call(desc.contributes, point));
            });
        };
        ExtensionsRegistryImpl.prototype.getExtensionDescriptionsForActivationEvent = function (activationEvent) {
            if (!hasOwnProperty.call(this._activationMap, activationEvent)) {
                return [];
            }
            return this._activationMap[activationEvent].slice(0);
        };
        ExtensionsRegistryImpl.prototype.getAllExtensionDescriptions = function () {
            return this._extensionsArr.slice(0);
        };
        ExtensionsRegistryImpl.prototype.getExtensionDescription = function (extensionId) {
            if (!hasOwnProperty.call(this._extensionsMap, extensionId)) {
                return null;
            }
            return this._extensionsMap[extensionId];
        };
        ExtensionsRegistryImpl.prototype.registerOneTimeActivationEventListener = function (activationEvent, listener) {
            if (!hasOwnProperty.call(this._oneTimeActivationEventListeners, activationEvent)) {
                this._oneTimeActivationEventListeners[activationEvent] = [];
            }
            this._oneTimeActivationEventListeners[activationEvent].push(listener);
        };
        ExtensionsRegistryImpl.prototype.triggerActivationEventListeners = function (activationEvent) {
            if (hasOwnProperty.call(this._oneTimeActivationEventListeners, activationEvent)) {
                var listeners = this._oneTimeActivationEventListeners[activationEvent];
                delete this._oneTimeActivationEventListeners[activationEvent];
                for (var i = 0, len = listeners.length; i < len; i++) {
                    var listener = listeners[i];
                    try {
                        listener();
                    }
                    catch (e) {
                        errors_1.onUnexpectedError(e);
                    }
                }
            }
        };
        return ExtensionsRegistryImpl;
    }());
    function _isStringArray(arr) {
        if (!Array.isArray(arr)) {
            return false;
        }
        for (var i = 0, len = arr.length; i < len; i++) {
            if (typeof arr[i] !== 'string') {
                return false;
            }
        }
        return true;
    }
    var PRExtensions = {
        ExtensionsRegistry: 'ExtensionsRegistry'
    };
    platform_1.Registry.add(PRExtensions.ExtensionsRegistry, new ExtensionsRegistryImpl());
    exports.ExtensionsRegistry = platform_1.Registry.as(PRExtensions.ExtensionsRegistry);
    schemaRegistry.registerSchema(schemaId, schema);
});

define(__m[77], __M([0,1,368,16,33,31,86,85]), function (require, exports, nls, event_1, platform, objects, extensionsRegistry_1, JSONContributionRegistry) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.Extensions = {
        Configuration: 'base.contributions.configuration'
    };
    var schemaId = 'vscode://schemas/settings';
    var contributionRegistry = platform.Registry.as(JSONContributionRegistry.Extensions.JSONContribution);
    var ConfigurationRegistry = (function () {
        function ConfigurationRegistry() {
            this.configurationContributors = [];
            this.configurationSchema = { allOf: [] };
            this._onDidRegisterConfiguration = new event_1.Emitter();
            contributionRegistry.registerSchema(schemaId, this.configurationSchema);
        }
        Object.defineProperty(ConfigurationRegistry.prototype, "onDidRegisterConfiguration", {
            get: function () {
                return this._onDidRegisterConfiguration.event;
            },
            enumerable: true,
            configurable: true
        });
        ConfigurationRegistry.prototype.registerConfiguration = function (configuration) {
            this.configurationContributors.push(configuration);
            this.registerJSONConfiguration(configuration);
            this._onDidRegisterConfiguration.fire(this);
        };
        ConfigurationRegistry.prototype.getConfigurations = function () {
            return this.configurationContributors.slice(0);
        };
        ConfigurationRegistry.prototype.registerJSONConfiguration = function (configuration) {
            var schema = objects.clone(configuration);
            this.configurationSchema.allOf.push(schema);
            contributionRegistry.registerSchema(schemaId, this.configurationSchema);
        };
        return ConfigurationRegistry;
    }());
    var configurationRegistry = new ConfigurationRegistry();
    platform.Registry.add(exports.Extensions.Configuration, configurationRegistry);
    var configurationExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint('configuration', {
        description: nls.localize(0, null),
        type: 'object',
        defaultSnippets: [{ body: { title: '', properties: {} } }],
        properties: {
            title: {
                description: nls.localize(1, null),
                type: 'string'
            },
            properties: {
                description: nls.localize(2, null),
                type: 'object',
                additionalProperties: {
                    $ref: 'http://json-schema.org/draft-04/schema#'
                }
            }
        }
    });
    configurationExtPoint.setHandler(function (extensions) {
        for (var i = 0; i < extensions.length; i++) {
            var configuration = extensions[i].value;
            var collector = extensions[i].collector;
            if (configuration.type && configuration.type !== 'object') {
                collector.warn(nls.localize(3, null));
            }
            else {
                configuration.type = 'object';
            }
            if (configuration.title && (typeof configuration.title !== 'string')) {
                collector.error(nls.localize(4, null));
            }
            if (configuration.properties && (typeof configuration.properties !== 'object')) {
                collector.error(nls.localize(5, null));
                return;
            }
            var clonedConfiguration = objects.clone(configuration);
            clonedConfiguration.id = extensions[i].description.id;
            configurationRegistry.registerConfiguration(clonedConfiguration);
        }
    });
});






define(__m[111], __M([0,1,303,16,3,31,18,77,33,55,7,403,41]), function (require, exports, nls, event_1, lifecycle_1, objects, platform, configurationRegistry_1, platform_1, defaultConfig_1, editorCommon, editorLayoutProvider_1, scrollableElementOptions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Experimental screen reader support toggle
     */
    var GlobalScreenReaderNVDA = (function () {
        function GlobalScreenReaderNVDA() {
        }
        GlobalScreenReaderNVDA.getValue = function () {
            return this._value;
        };
        GlobalScreenReaderNVDA.setValue = function (value) {
            if (this._value === value) {
                return;
            }
            this._value = value;
            this._onChange.fire(this._value);
        };
        GlobalScreenReaderNVDA._value = false;
        GlobalScreenReaderNVDA._onChange = new event_1.Emitter();
        GlobalScreenReaderNVDA.onChange = GlobalScreenReaderNVDA._onChange.event;
        return GlobalScreenReaderNVDA;
    }());
    exports.GlobalScreenReaderNVDA = GlobalScreenReaderNVDA;
    var ConfigurationWithDefaults = (function () {
        function ConfigurationWithDefaults(options) {
            this._editor = objects.clone(defaultConfig_1.DefaultConfig.editor);
            this._mergeOptionsIn(options);
        }
        ConfigurationWithDefaults.prototype.getEditorOptions = function () {
            return this._editor;
        };
        ConfigurationWithDefaults.prototype._mergeOptionsIn = function (newOptions) {
            this._editor = objects.mixin(this._editor, newOptions || {});
        };
        ConfigurationWithDefaults.prototype.updateOptions = function (newOptions) {
            // Apply new options
            this._mergeOptionsIn(newOptions);
        };
        return ConfigurationWithDefaults;
    }());
    exports.ConfigurationWithDefaults = ConfigurationWithDefaults;
    var InternalEditorOptionsHelper = (function () {
        function InternalEditorOptionsHelper() {
        }
        InternalEditorOptionsHelper.createInternalEditorOptions = function (outerWidth, outerHeight, opts, fontInfo, editorClassName, isDominatedByLongLines, lineCount, canUseTranslate3d) {
            var wrappingColumn = toInteger(opts.wrappingColumn, -1);
            var stopRenderingLineAfter;
            if (typeof opts.stopRenderingLineAfter !== 'undefined') {
                stopRenderingLineAfter = toInteger(opts.stopRenderingLineAfter, -1);
            }
            else if (wrappingColumn >= 0) {
                stopRenderingLineAfter = -1;
            }
            else {
                stopRenderingLineAfter = 10000;
            }
            var mouseWheelScrollSensitivity = toFloat(opts.mouseWheelScrollSensitivity, 1);
            var scrollbar = this._sanitizeScrollbarOpts(opts.scrollbar, mouseWheelScrollSensitivity);
            var glyphMargin = toBoolean(opts.glyphMargin);
            var lineNumbers = opts.lineNumbers;
            var lineNumbersMinChars = toInteger(opts.lineNumbersMinChars, 1);
            var lineDecorationsWidth = toInteger(opts.lineDecorationsWidth, 0);
            if (opts.folding) {
                lineDecorationsWidth += 16;
            }
            var layoutInfo = editorLayoutProvider_1.EditorLayoutProvider.compute({
                outerWidth: outerWidth,
                outerHeight: outerHeight,
                showGlyphMargin: glyphMargin,
                lineHeight: fontInfo.lineHeight,
                showLineNumbers: !!lineNumbers,
                lineNumbersMinChars: lineNumbersMinChars,
                lineDecorationsWidth: lineDecorationsWidth,
                maxDigitWidth: fontInfo.maxDigitWidth,
                lineCount: lineCount,
                verticalScrollbarWidth: scrollbar.verticalScrollbarSize,
                horizontalScrollbarHeight: scrollbar.horizontalScrollbarSize,
                scrollbarArrowSize: scrollbar.arrowSize,
                verticalScrollbarHasArrows: scrollbar.verticalHasArrows
            });
            if (isDominatedByLongLines && wrappingColumn > 0) {
                // Force viewport width wrapping if model is dominated by long lines
                wrappingColumn = 0;
            }
            var bareWrappingInfo;
            if (wrappingColumn === 0) {
                // If viewport width wrapping is enabled
                bareWrappingInfo = {
                    isViewportWrapping: true,
                    wrappingColumn: Math.max(1, Math.floor((layoutInfo.contentWidth - layoutInfo.verticalScrollbarWidth) / fontInfo.typicalHalfwidthCharacterWidth))
                };
            }
            else if (wrappingColumn > 0) {
                // Wrapping is enabled
                bareWrappingInfo = {
                    isViewportWrapping: false,
                    wrappingColumn: wrappingColumn
                };
            }
            else {
                bareWrappingInfo = {
                    isViewportWrapping: false,
                    wrappingColumn: -1
                };
            }
            var wrappingInfo = new editorCommon.EditorWrappingInfo({
                isViewportWrapping: bareWrappingInfo.isViewportWrapping,
                wrappingColumn: bareWrappingInfo.wrappingColumn,
                wrappingIndent: wrappingIndentFromString(opts.wrappingIndent),
                wordWrapBreakBeforeCharacters: String(opts.wordWrapBreakBeforeCharacters),
                wordWrapBreakAfterCharacters: String(opts.wordWrapBreakAfterCharacters),
                wordWrapBreakObtrusiveCharacters: String(opts.wordWrapBreakObtrusiveCharacters),
            });
            var readOnly = toBoolean(opts.readOnly);
            var tabFocusMode = toBoolean(opts.tabFocusMode);
            if (readOnly) {
                tabFocusMode = true;
            }
            var viewInfo = new editorCommon.InternalEditorViewOptions({
                theme: opts.theme,
                canUseTranslate3d: canUseTranslate3d,
                experimentalScreenReader: toBoolean(opts.experimentalScreenReader),
                rulers: toSortedIntegerArray(opts.rulers),
                ariaLabel: String(opts.ariaLabel),
                lineNumbers: lineNumbers,
                selectOnLineNumbers: toBoolean(opts.selectOnLineNumbers),
                glyphMargin: glyphMargin,
                revealHorizontalRightPadding: toInteger(opts.revealHorizontalRightPadding, 0),
                roundedSelection: toBoolean(opts.roundedSelection),
                overviewRulerLanes: toInteger(opts.overviewRulerLanes, 0, 3),
                cursorBlinking: opts.cursorBlinking,
                cursorStyle: cursorStyleFromString(opts.cursorStyle),
                hideCursorInOverviewRuler: toBoolean(opts.hideCursorInOverviewRuler),
                scrollBeyondLastLine: toBoolean(opts.scrollBeyondLastLine),
                editorClassName: editorClassName,
                stopRenderingLineAfter: stopRenderingLineAfter,
                renderWhitespace: toBoolean(opts.renderWhitespace),
                indentGuides: toBoolean(opts.indentGuides),
                scrollbar: scrollbar,
            });
            var contribInfo = new editorCommon.EditorContribOptions({
                selectionClipboard: toBoolean(opts.selectionClipboard),
                hover: toBoolean(opts.hover),
                contextmenu: toBoolean(opts.contextmenu),
                quickSuggestions: toBoolean(opts.quickSuggestions),
                quickSuggestionsDelay: toInteger(opts.quickSuggestionsDelay),
                parameterHints: toBoolean(opts.parameterHints),
                iconsInSuggestions: toBoolean(opts.iconsInSuggestions),
                formatOnType: toBoolean(opts.formatOnType),
                suggestOnTriggerCharacters: toBoolean(opts.suggestOnTriggerCharacters),
                acceptSuggestionOnEnter: toBoolean(opts.acceptSuggestionOnEnter),
                selectionHighlight: toBoolean(opts.selectionHighlight),
                outlineMarkers: toBoolean(opts.outlineMarkers),
                referenceInfos: toBoolean(opts.referenceInfos),
                folding: toBoolean(opts.folding),
            });
            return new editorCommon.InternalEditorOptions({
                lineHeight: fontInfo.lineHeight,
                readOnly: readOnly,
                wordSeparators: String(opts.wordSeparators),
                autoClosingBrackets: toBoolean(opts.autoClosingBrackets),
                useTabStops: toBoolean(opts.useTabStops),
                tabFocusMode: tabFocusMode,
                layoutInfo: layoutInfo,
                fontInfo: fontInfo,
                viewInfo: viewInfo,
                wrappingInfo: wrappingInfo,
                contribInfo: contribInfo,
            });
        };
        InternalEditorOptionsHelper._sanitizeScrollbarOpts = function (raw, mouseWheelScrollSensitivity) {
            var visibilityFromString = function (visibility) {
                switch (visibility) {
                    case 'hidden':
                        return scrollableElementOptions_1.ScrollbarVisibility.Hidden;
                    case 'visible':
                        return scrollableElementOptions_1.ScrollbarVisibility.Visible;
                    default:
                        return scrollableElementOptions_1.ScrollbarVisibility.Auto;
                }
            };
            var horizontalScrollbarSize = toIntegerWithDefault(raw.horizontalScrollbarSize, 10);
            var verticalScrollbarSize = toIntegerWithDefault(raw.verticalScrollbarSize, 14);
            return new editorCommon.InternalEditorScrollbarOptions({
                vertical: visibilityFromString(raw.vertical),
                horizontal: visibilityFromString(raw.horizontal),
                arrowSize: toIntegerWithDefault(raw.arrowSize, 11),
                useShadows: toBooleanWithDefault(raw.useShadows, true),
                verticalHasArrows: toBooleanWithDefault(raw.verticalHasArrows, false),
                horizontalHasArrows: toBooleanWithDefault(raw.horizontalHasArrows, false),
                horizontalScrollbarSize: horizontalScrollbarSize,
                horizontalSliderSize: toIntegerWithDefault(raw.horizontalSliderSize, horizontalScrollbarSize),
                verticalScrollbarSize: verticalScrollbarSize,
                verticalSliderSize: toIntegerWithDefault(raw.verticalSliderSize, verticalScrollbarSize),
                handleMouseWheel: toBooleanWithDefault(raw.handleMouseWheel, true),
                mouseWheelScrollSensitivity: mouseWheelScrollSensitivity
            });
        };
        return InternalEditorOptionsHelper;
    }());
    function toBoolean(value) {
        return value === 'false' ? false : Boolean(value);
    }
    function toBooleanWithDefault(value, defaultValue) {
        if (typeof value === 'undefined') {
            return defaultValue;
        }
        return toBoolean(value);
    }
    function toFloat(source, defaultValue) {
        var r = parseFloat(source);
        if (isNaN(r)) {
            r = defaultValue;
        }
        return r;
    }
    function toInteger(source, minimum, maximum) {
        var r = parseInt(source, 10);
        if (isNaN(r)) {
            r = 0;
        }
        if (typeof minimum === 'number') {
            r = Math.max(minimum, r);
        }
        if (typeof maximum === 'number') {
            r = Math.min(maximum, r);
        }
        return r;
    }
    function toSortedIntegerArray(source) {
        if (!Array.isArray(source)) {
            return [];
        }
        var arrSource = source;
        var r = arrSource.map(function (el) { return toInteger(el); });
        r.sort();
        return r;
    }
    function wrappingIndentFromString(wrappingIndent) {
        if (wrappingIndent === 'indent') {
            return editorCommon.WrappingIndent.Indent;
        }
        else if (wrappingIndent === 'same') {
            return editorCommon.WrappingIndent.Same;
        }
        else {
            return editorCommon.WrappingIndent.None;
        }
    }
    function cursorStyleFromString(cursorStyle) {
        if (cursorStyle === 'line') {
            return editorCommon.TextEditorCursorStyle.Line;
        }
        else if (cursorStyle === 'block') {
            return editorCommon.TextEditorCursorStyle.Block;
        }
        else if (cursorStyle === 'underline') {
            return editorCommon.TextEditorCursorStyle.Underline;
        }
        return editorCommon.TextEditorCursorStyle.Line;
    }
    function toIntegerWithDefault(source, defaultValue) {
        if (typeof source === 'undefined') {
            return defaultValue;
        }
        return toInteger(source);
    }
    var CommonEditorConfiguration = (function (_super) {
        __extends(CommonEditorConfiguration, _super);
        function CommonEditorConfiguration(options, elementSizeObserver) {
            if (elementSizeObserver === void 0) { elementSizeObserver = null; }
            _super.call(this);
            this._onDidChange = this._register(new event_1.Emitter());
            this.onDidChange = this._onDidChange.event;
            this._configWithDefaults = new ConfigurationWithDefaults(options);
            this._elementSizeObserver = elementSizeObserver;
            this._isDominatedByLongLines = false;
            this._lineCount = 1;
            this.editor = this._computeInternalOptions();
            this.editorClone = this.editor.clone();
        }
        CommonEditorConfiguration.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        CommonEditorConfiguration.prototype._recomputeOptions = function () {
            this._setOptions(this._computeInternalOptions());
        };
        CommonEditorConfiguration.prototype._setOptions = function (newOptions) {
            if (this.editor && this.editor.equals(newOptions)) {
                return;
            }
            var changeEvent = this.editor.createChangeEvent(newOptions);
            this.editor = newOptions;
            this.editorClone = this.editor.clone();
            this._onDidChange.fire(changeEvent);
        };
        CommonEditorConfiguration.prototype.getRawOptions = function () {
            return this._configWithDefaults.getEditorOptions();
        };
        CommonEditorConfiguration.prototype._computeInternalOptions = function () {
            var opts = this._configWithDefaults.getEditorOptions();
            var editorClassName = this._getEditorClassName(opts.theme, toBoolean(opts.fontLigatures));
            var fontFamily = String(opts.fontFamily) || defaultConfig_1.DefaultConfig.editor.fontFamily;
            var fontSize = toInteger(opts.fontSize, 0, 100) || defaultConfig_1.DefaultConfig.editor.fontSize;
            var lineHeight = toInteger(opts.lineHeight, 0, 150);
            if (lineHeight === 0) {
                lineHeight = Math.round(defaultConfig_1.GOLDEN_LINE_HEIGHT_RATIO * fontSize);
            }
            var disableTranslate3d = toBoolean(opts.disableTranslate3d);
            var canUseTranslate3d = this._getCanUseTranslate3d();
            if (disableTranslate3d) {
                canUseTranslate3d = false;
            }
            return InternalEditorOptionsHelper.createInternalEditorOptions(this.getOuterWidth(), this.getOuterHeight(), opts, this.readConfiguration(new editorCommon.BareFontInfo({
                fontFamily: fontFamily,
                fontSize: fontSize,
                lineHeight: lineHeight
            })), editorClassName, this._isDominatedByLongLines, this._lineCount, canUseTranslate3d);
        };
        CommonEditorConfiguration.prototype.updateOptions = function (newOptions) {
            this._configWithDefaults.updateOptions(newOptions);
            this._recomputeOptions();
        };
        CommonEditorConfiguration.prototype.setIsDominatedByLongLines = function (isDominatedByLongLines) {
            this._isDominatedByLongLines = isDominatedByLongLines;
            this._recomputeOptions();
        };
        CommonEditorConfiguration.prototype.setLineCount = function (lineCount) {
            this._lineCount = lineCount;
            this._recomputeOptions();
        };
        return CommonEditorConfiguration;
    }(lifecycle_1.Disposable));
    exports.CommonEditorConfiguration = CommonEditorConfiguration;
    /**
     * Helper to update Monaco Editor Settings from configurations service.
     */
    var EditorConfiguration = (function () {
        function EditorConfiguration() {
        }
        EditorConfiguration.apply = function (config, editorOrArray) {
            if (!config) {
                return;
            }
            var editors = editorOrArray;
            if (!Array.isArray(editorOrArray)) {
                editors = [editorOrArray];
            }
            for (var i = 0; i < editors.length; i++) {
                var editor = editors[i];
                // Editor Settings (Code Editor, Diff, Terminal)
                if (editor && typeof editor.updateOptions === 'function') {
                    var type = editor.getEditorType();
                    if (type !== editorCommon.EditorType.ICodeEditor && type !== editorCommon.EditorType.IDiffEditor) {
                        continue;
                    }
                    var editorConfig = config[EditorConfiguration.EDITOR_SECTION];
                    if (type === editorCommon.EditorType.IDiffEditor) {
                        var diffEditorConfig = config[EditorConfiguration.DIFF_EDITOR_SECTION];
                        if (diffEditorConfig) {
                            if (!editorConfig) {
                                editorConfig = diffEditorConfig;
                            }
                            else {
                                editorConfig = objects.mixin(editorConfig, diffEditorConfig);
                            }
                        }
                    }
                    if (editorConfig) {
                        delete editorConfig.readOnly; // Prevent someone from making editor readonly
                        editor.updateOptions(editorConfig);
                    }
                }
            }
        };
        EditorConfiguration.EDITOR_SECTION = 'editor';
        EditorConfiguration.DIFF_EDITOR_SECTION = 'diffEditor';
        return EditorConfiguration;
    }());
    exports.EditorConfiguration = EditorConfiguration;
    var configurationRegistry = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration);
    var editorConfiguration = {
        'id': 'editor',
        'order': 5,
        'type': 'object',
        'title': nls.localize(0, null),
        'properties': {
            'editor.fontFamily': {
                'type': 'string',
                'default': defaultConfig_1.DefaultConfig.editor.fontFamily,
                'description': nls.localize(1, null)
            },
            'editor.fontSize': {
                'type': 'number',
                'default': defaultConfig_1.DefaultConfig.editor.fontSize,
                'description': nls.localize(2, null)
            },
            'editor.lineHeight': {
                'type': 'number',
                'default': defaultConfig_1.DefaultConfig.editor.lineHeight,
                'description': nls.localize(3, null)
            },
            'editor.lineNumbers': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.lineNumbers,
                'description': nls.localize(4, null)
            },
            'editor.glyphMargin': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.glyphMargin,
                'description': nls.localize(5, null)
            },
            'editor.rulers': {
                'type': 'array',
                'items': {
                    'type': 'number'
                },
                'default': defaultConfig_1.DefaultConfig.editor.rulers,
                'description': nls.localize(6, null)
            },
            'editor.wordSeparators': {
                'type': 'string',
                'default': defaultConfig_1.DefaultConfig.editor.wordSeparators,
                'description': nls.localize(7, null)
            },
            'editor.tabSize': {
                'type': 'number',
                'default': defaultConfig_1.DEFAULT_INDENTATION.tabSize,
                'minimum': 1,
                'description': nls.localize(8, null),
                'errorMessage': nls.localize(9, null)
            },
            'editor.insertSpaces': {
                'type': 'boolean',
                'default': defaultConfig_1.DEFAULT_INDENTATION.insertSpaces,
                'description': nls.localize(10, null),
                'errorMessage': nls.localize(11, null)
            },
            'editor.detectIndentation': {
                'type': 'boolean',
                'default': defaultConfig_1.DEFAULT_INDENTATION.detectIndentation,
                'description': nls.localize(12, null)
            },
            'editor.roundedSelection': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.roundedSelection,
                'description': nls.localize(13, null)
            },
            'editor.scrollBeyondLastLine': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.scrollBeyondLastLine,
                'description': nls.localize(14, null)
            },
            'editor.wrappingColumn': {
                'type': 'integer',
                'default': defaultConfig_1.DefaultConfig.editor.wrappingColumn,
                'minimum': -1,
                'description': nls.localize(15, null)
            },
            'editor.wrappingIndent': {
                'type': 'string',
                'enum': ['none', 'same', 'indent'],
                'default': defaultConfig_1.DefaultConfig.editor.wrappingIndent,
                'description': nls.localize(16, null)
            },
            'editor.mouseWheelScrollSensitivity': {
                'type': 'number',
                'default': defaultConfig_1.DefaultConfig.editor.mouseWheelScrollSensitivity,
                'description': nls.localize(17, null)
            },
            'editor.quickSuggestions': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.quickSuggestions,
                'description': nls.localize(18, null)
            },
            'editor.quickSuggestionsDelay': {
                'type': 'integer',
                'default': defaultConfig_1.DefaultConfig.editor.quickSuggestionsDelay,
                'minimum': 0,
                'description': nls.localize(19, null)
            },
            'editor.parameterHints': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.parameterHints,
                'description': nls.localize(20, null)
            },
            'editor.autoClosingBrackets': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.autoClosingBrackets,
                'description': nls.localize(21, null)
            },
            'editor.formatOnType': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.formatOnType,
                'description': nls.localize(22, null)
            },
            'editor.suggestOnTriggerCharacters': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.suggestOnTriggerCharacters,
                'description': nls.localize(23, null)
            },
            'editor.acceptSuggestionOnEnter': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.acceptSuggestionOnEnter,
                'description': nls.localize(24, null)
            },
            'editor.selectionHighlight': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.selectionHighlight,
                'description': nls.localize(25, null)
            },
            //		'editor.outlineMarkers' : {
            //			'type': 'boolean',
            //			'default': DefaultConfig.editor.outlineMarkers,
            //			'description': nls.localize('outlineMarkers', "Controls whether the editor should draw horizontal lines before classes and methods")
            //		},
            'editor.overviewRulerLanes': {
                'type': 'integer',
                'default': 3,
                'description': nls.localize(26, null)
            },
            'editor.cursorBlinking': {
                'type': 'string',
                'enum': ['blink', 'visible', 'hidden'],
                'default': defaultConfig_1.DefaultConfig.editor.cursorBlinking,
                'description': nls.localize(27, null)
            },
            'editor.cursorStyle': {
                'type': 'string',
                'enum': ['block', 'line'],
                'default': defaultConfig_1.DefaultConfig.editor.cursorStyle,
                'description': nls.localize(28, null)
            },
            'editor.fontLigatures': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.fontLigatures,
                'description': nls.localize(29, null)
            },
            'editor.hideCursorInOverviewRuler': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.hideCursorInOverviewRuler,
                'description': nls.localize(30, null)
            },
            'editor.renderWhitespace': {
                'type': 'boolean',
                default: defaultConfig_1.DefaultConfig.editor.renderWhitespace,
                description: nls.localize(31, null)
            },
            // 'editor.indentGuides': {
            // 	'type': 'boolean',
            // 	default: DefaultConfig.editor.indentGuides,
            // 	description: nls.localize('indentGuides', "Controls whether the editor should render indent guides")
            // },
            'editor.referenceInfos': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.referenceInfos,
                'description': nls.localize(32, null)
            },
            'editor.folding': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.folding,
                'description': nls.localize(33, null)
            },
            'editor.useTabStops': {
                'type': 'boolean',
                'default': defaultConfig_1.DefaultConfig.editor.useTabStops,
                'description': nls.localize(34, null)
            },
            'editor.trimAutoWhitespace': {
                'type': 'boolean',
                'default': defaultConfig_1.DEFAULT_TRIM_AUTO_WHITESPACE,
                'description': nls.localize(35, null)
            },
            'editor.stablePeek': {
                'type': 'boolean',
                'default': false,
                'description': nls.localize(36, null)
            },
            'diffEditor.renderSideBySide': {
                'type': 'boolean',
                'default': true,
                'description': nls.localize(37, null)
            },
            'diffEditor.ignoreTrimWhitespace': {
                'type': 'boolean',
                'default': true,
                'description': nls.localize(38, null)
            }
        }
    };
    if (platform.isLinux) {
        editorConfiguration['properties']['editor.selectionClipboard'] = {
            'type': 'boolean',
            'default': defaultConfig_1.DefaultConfig.editor.selectionClipboard,
            'description': nls.localize(39, null)
        };
    }
    configurationRegistry.registerConfiguration(editorConfiguration);
});






define(__m[66], __M([0,1,16,3,18,28,111,7,247]), function (require, exports, event_1, lifecycle_1, platform, browser, commonEditorConfig_1, editorCommon_1, elementSizeObserver_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CSSBasedConfigurationCache = (function () {
        function CSSBasedConfigurationCache() {
            this._keys = Object.create(null);
            this._values = Object.create(null);
        }
        CSSBasedConfigurationCache.prototype.has = function (item) {
            return !!this._values[item.getId()];
        };
        CSSBasedConfigurationCache.prototype.get = function (item) {
            return this._values[item.getId()];
        };
        CSSBasedConfigurationCache.prototype.put = function (item, value) {
            this._keys[item.getId()] = item;
            this._values[item.getId()] = value;
        };
        CSSBasedConfigurationCache.prototype.getKeys = function () {
            var _this = this;
            return Object.keys(this._keys).map(function (id) { return _this._keys[id]; });
        };
        return CSSBasedConfigurationCache;
    }());
    var CharWidthReader = (function () {
        function CharWidthReader(chr) {
            this._chr = chr;
            this._width = 0;
        }
        Object.defineProperty(CharWidthReader.prototype, "width", {
            get: function () { return this._width; },
            enumerable: true,
            configurable: true
        });
        CharWidthReader.prototype.render = function (out) {
            if (this._chr === ' ') {
                var htmlString = '&nbsp;';
                // Repeat character 256 (2^8) times
                for (var i = 0; i < 8; i++) {
                    htmlString += htmlString;
                }
                out.innerHTML = htmlString;
            }
            else {
                var testString = this._chr;
                // Repeat character 256 (2^8) times
                for (var i = 0; i < 8; i++) {
                    testString += testString;
                }
                out.textContent = testString;
            }
        };
        CharWidthReader.prototype.read = function (out) {
            this._width = out.offsetWidth / 256;
        };
        return CharWidthReader;
    }());
    var CSSBasedConfiguration = (function (_super) {
        __extends(CSSBasedConfiguration, _super);
        function CSSBasedConfiguration() {
            _super.call(this);
            this._changeMonitorTimeout = -1;
            this._onDidChange = this._register(new event_1.Emitter());
            this.onDidChange = this._onDidChange.event;
            this._cache = new CSSBasedConfigurationCache();
        }
        CSSBasedConfiguration.prototype.dispose = function () {
            if (this._changeMonitorTimeout !== -1) {
                clearTimeout(this._changeMonitorTimeout);
                this._changeMonitorTimeout = -1;
            }
            _super.prototype.dispose.call(this);
        };
        CSSBasedConfiguration.prototype.readConfiguration = function (bareFontInfo) {
            if (!this._cache.has(bareFontInfo)) {
                var readConfig = CSSBasedConfiguration._actualReadConfiguration(bareFontInfo);
                if (readConfig.typicalHalfwidthCharacterWidth <= 2 || readConfig.typicalFullwidthCharacterWidth <= 2 || readConfig.spaceWidth <= 2 || readConfig.maxDigitWidth <= 2) {
                    // Hey, it's Bug 14341 ... we couldn't read
                    readConfig.typicalHalfwidthCharacterWidth = Math.max(readConfig.typicalHalfwidthCharacterWidth, 5);
                    readConfig.typicalFullwidthCharacterWidth = Math.max(readConfig.typicalFullwidthCharacterWidth, 5);
                    readConfig.spaceWidth = Math.max(readConfig.spaceWidth, 5);
                    readConfig.maxDigitWidth = Math.max(readConfig.maxDigitWidth, 5);
                    this._installChangeMonitor();
                }
                this._cache.put(bareFontInfo, readConfig);
            }
            return this._cache.get(bareFontInfo);
        };
        CSSBasedConfiguration.prototype._installChangeMonitor = function () {
            var _this = this;
            if (this._changeMonitorTimeout === -1) {
                this._changeMonitorTimeout = setTimeout(function () {
                    _this._changeMonitorTimeout = -1;
                    _this._monitorForChanges();
                }, 500);
            }
        };
        CSSBasedConfiguration.prototype._monitorForChanges = function () {
            var shouldInstallChangeMonitor = false;
            var keys = this._cache.getKeys();
            for (var i = 0; i < keys.length; i++) {
                var styling = keys[i];
                var newValue = CSSBasedConfiguration._actualReadConfiguration(styling);
                if (newValue.typicalHalfwidthCharacterWidth <= 2 || newValue.typicalFullwidthCharacterWidth <= 2 || newValue.maxDigitWidth <= 2) {
                    // We still couldn't read the CSS config
                    shouldInstallChangeMonitor = true;
                }
                else {
                    this._cache.put(styling, newValue);
                    this._onDidChange.fire();
                }
            }
            if (shouldInstallChangeMonitor) {
                this._installChangeMonitor();
            }
        };
        CSSBasedConfiguration._testElementId = function (index) {
            return 'editorSizeProvider' + index;
        };
        CSSBasedConfiguration._createTestElements = function (bareFontInfo, readers) {
            var container = document.createElement('div');
            Configuration.applyFontInfoSlow(container, bareFontInfo);
            container.style.position = 'absolute';
            container.style.top = '-50000px';
            container.style.width = '50000px';
            for (var i = 0, len = readers.length; i < len; i++) {
                container.appendChild(document.createElement('br'));
                var testElement = document.createElement('span');
                testElement.id = this._testElementId(i);
                readers[i].render(testElement);
                container.appendChild(testElement);
            }
            container.appendChild(document.createElement('br'));
            return container;
        };
        CSSBasedConfiguration._readFromTestElements = function (readers) {
            for (var i = 0, len = readers.length; i < len; i++) {
                readers[i].read(document.getElementById(this._testElementId(i)));
            }
        };
        CSSBasedConfiguration._runReaders = function (bareFontInfo, readers) {
            // Create a test container with all these test elements
            var testContainer = this._createTestElements(bareFontInfo, readers);
            // Add the container to the DOM
            document.body.appendChild(testContainer);
            // Read various properties
            this._readFromTestElements(readers);
            // Remove the container from the DOM
            document.body.removeChild(testContainer);
        };
        CSSBasedConfiguration._actualReadConfiguration = function (bareFontInfo) {
            var typicalHalfwidthCharacter = new CharWidthReader('n');
            var typicalFullwidthCharacter = new CharWidthReader('\uff4d');
            var space = new CharWidthReader(' ');
            var digits = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'].map(function (chr) { return new CharWidthReader(chr); });
            this._runReaders(bareFontInfo, digits.concat([typicalHalfwidthCharacter, typicalFullwidthCharacter, space]));
            var maxDigitWidth = 0;
            for (var i = 0, len = digits.length; i < len; i++) {
                maxDigitWidth = Math.max(maxDigitWidth, digits[i].width);
            }
            return new editorCommon_1.FontInfo({
                fontFamily: bareFontInfo.fontFamily,
                fontSize: bareFontInfo.fontSize,
                lineHeight: bareFontInfo.lineHeight,
                typicalHalfwidthCharacterWidth: typicalHalfwidthCharacter.width,
                typicalFullwidthCharacterWidth: typicalFullwidthCharacter.width,
                spaceWidth: space.width,
                maxDigitWidth: maxDigitWidth
            });
        };
        CSSBasedConfiguration.INSTANCE = new CSSBasedConfiguration();
        return CSSBasedConfiguration;
    }(lifecycle_1.Disposable));
    var Configuration = (function (_super) {
        __extends(Configuration, _super);
        function Configuration(options, referenceDomElement) {
            var _this = this;
            if (referenceDomElement === void 0) { referenceDomElement = null; }
            _super.call(this, options, new elementSizeObserver_1.ElementSizeObserver(referenceDomElement, function () { return _this._onReferenceDomElementSizeChanged(); }));
            this._register(CSSBasedConfiguration.INSTANCE.onDidChange(function () { return function () { return _this._onCSSBasedConfigurationChanged(); }; }));
            if (this._configWithDefaults.getEditorOptions().automaticLayout) {
                this._elementSizeObserver.startObserving();
            }
            this._register(browser.onDidChangeZoomLevel(function (_) { return _this._recomputeOptions(); }));
        }
        Configuration.applyFontInfoSlow = function (domNode, fontInfo) {
            domNode.style.fontFamily = fontInfo.fontFamily;
            domNode.style.fontSize = fontInfo.fontSize + 'px';
            domNode.style.lineHeight = fontInfo.lineHeight + 'px';
        };
        Configuration.applyFontInfo = function (domNode, fontInfo) {
            domNode.setFontFamily(fontInfo.fontFamily);
            domNode.setFontSize(fontInfo.fontSize);
            domNode.setLineHeight(fontInfo.lineHeight);
        };
        Configuration.prototype._onReferenceDomElementSizeChanged = function () {
            this._recomputeOptions();
        };
        Configuration.prototype._onCSSBasedConfigurationChanged = function () {
            this._recomputeOptions();
        };
        Configuration.prototype.observeReferenceElement = function (dimension) {
            this._elementSizeObserver.observe(dimension);
        };
        Configuration.prototype.dispose = function () {
            this._elementSizeObserver.dispose();
            _super.prototype.dispose.call(this);
        };
        Configuration.prototype._getEditorClassName = function (theme, fontLigatures) {
            var extra = '';
            if (browser.isIE11orEarlier) {
                extra += 'ie ';
            }
            else if (browser.isFirefox) {
                extra += 'ff ';
            }
            if (browser.isIE9) {
                extra += 'ie9 ';
            }
            if (platform.isMacintosh) {
                extra += 'mac ';
            }
            if (fontLigatures) {
                extra += 'enable-ligatures ';
            }
            return 'monaco-editor ' + extra + theme;
        };
        Configuration.prototype.getOuterWidth = function () {
            return this._elementSizeObserver.getWidth();
        };
        Configuration.prototype.getOuterHeight = function () {
            return this._elementSizeObserver.getHeight();
        };
        Configuration.prototype._getCanUseTranslate3d = function () {
            return browser.canUseTranslate3d && browser.getZoomLevel() === 0;
        };
        Configuration.prototype.readConfiguration = function (bareFontInfo) {
            return CSSBasedConfiguration.INSTANCE.readConfiguration(bareFontInfo);
        };
        return Configuration;
    }(commonEditorConfig_1.CommonEditorConfiguration));
    exports.Configuration = Configuration;
});






define(__m[424], __M([0,1,16,3,28,11,27,111,284,148,4,7,53,66]), function (require, exports, event_1, lifecycle_1, browser, dom, styleMutator_1, commonEditorConfig_1, textAreaHandler_1, textAreaState_1, range_1, editorCommon, viewEventHandler_1, configuration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ClipboardEventWrapper = (function () {
        function ClipboardEventWrapper(event) {
            this._event = event;
        }
        ClipboardEventWrapper.prototype.canUseTextData = function () {
            if (this._event.clipboardData) {
                return true;
            }
            if (window.clipboardData) {
                return true;
            }
            return false;
        };
        ClipboardEventWrapper.prototype.setTextData = function (text) {
            if (this._event.clipboardData) {
                this._event.clipboardData.setData('text/plain', text);
                this._event.preventDefault();
                return;
            }
            if (window.clipboardData) {
                window.clipboardData.setData('Text', text);
                this._event.preventDefault();
                return;
            }
            throw new Error('ClipboardEventWrapper.setTextData: Cannot use text data!');
        };
        ClipboardEventWrapper.prototype.getTextData = function () {
            if (this._event.clipboardData) {
                this._event.preventDefault();
                return this._event.clipboardData.getData('text/plain');
            }
            if (window.clipboardData) {
                this._event.preventDefault();
                return window.clipboardData.getData('Text');
            }
            throw new Error('ClipboardEventWrapper.getTextData: Cannot use text data!');
        };
        return ClipboardEventWrapper;
    }());
    var KeyboardEventWrapper = (function () {
        function KeyboardEventWrapper(actual) {
            this._actual = actual;
        }
        KeyboardEventWrapper.prototype.equals = function (keybinding) {
            return this._actual.equals(keybinding);
        };
        KeyboardEventWrapper.prototype.preventDefault = function () {
            this._actual.preventDefault();
        };
        KeyboardEventWrapper.prototype.isDefaultPrevented = function () {
            if (this._actual.browserEvent) {
                return this._actual.browserEvent.defaultPrevented;
            }
            return false;
        };
        return KeyboardEventWrapper;
    }());
    var TextAreaWrapper = (function (_super) {
        __extends(TextAreaWrapper, _super);
        function TextAreaWrapper(textArea) {
            var _this = this;
            _super.call(this);
            this._onKeyDown = this._register(new event_1.Emitter());
            this.onKeyDown = this._onKeyDown.event;
            this._onKeyUp = this._register(new event_1.Emitter());
            this.onKeyUp = this._onKeyUp.event;
            this._onKeyPress = this._register(new event_1.Emitter());
            this.onKeyPress = this._onKeyPress.event;
            this._onCompositionStart = this._register(new event_1.Emitter());
            this.onCompositionStart = this._onCompositionStart.event;
            this._onCompositionUpdate = this._register(new event_1.Emitter());
            this.onCompositionUpdate = this._onCompositionUpdate.event;
            this._onCompositionEnd = this._register(new event_1.Emitter());
            this.onCompositionEnd = this._onCompositionEnd.event;
            this._onInput = this._register(new event_1.Emitter());
            this.onInput = this._onInput.event;
            this._onCut = this._register(new event_1.Emitter());
            this.onCut = this._onCut.event;
            this._onCopy = this._register(new event_1.Emitter());
            this.onCopy = this._onCopy.event;
            this._onPaste = this._register(new event_1.Emitter());
            this.onPaste = this._onPaste.event;
            this._textArea = textArea;
            this._register(dom.addStandardDisposableListener(this._textArea, 'keydown', function (e) { return _this._onKeyDown.fire(new KeyboardEventWrapper(e)); }));
            this._register(dom.addStandardDisposableListener(this._textArea, 'keyup', function (e) { return _this._onKeyUp.fire(new KeyboardEventWrapper(e)); }));
            this._register(dom.addStandardDisposableListener(this._textArea, 'keypress', function (e) { return _this._onKeyPress.fire(new KeyboardEventWrapper(e)); }));
            this._register(dom.addDisposableListener(this._textArea, 'compositionstart', function (e) { return _this._onCompositionStart.fire(e); }));
            this._register(dom.addDisposableListener(this._textArea, 'compositionupdate', function (e) { return _this._onCompositionUpdate.fire(e); }));
            this._register(dom.addDisposableListener(this._textArea, 'compositionend', function (e) { return _this._onCompositionEnd.fire(e); }));
            this._register(dom.addDisposableListener(this._textArea, 'input', function (e) { return _this._onInput.fire(); }));
            this._register(dom.addDisposableListener(this._textArea, 'cut', function (e) { return _this._onCut.fire(new ClipboardEventWrapper(e)); }));
            this._register(dom.addDisposableListener(this._textArea, 'copy', function (e) { return _this._onCopy.fire(new ClipboardEventWrapper(e)); }));
            this._register(dom.addDisposableListener(this._textArea, 'paste', function (e) { return _this._onPaste.fire(new ClipboardEventWrapper(e)); }));
        }
        Object.defineProperty(TextAreaWrapper.prototype, "actual", {
            get: function () {
                return this._textArea;
            },
            enumerable: true,
            configurable: true
        });
        TextAreaWrapper.prototype.getValue = function () {
            // console.log('current value: ' + this._textArea.value);
            return this._textArea.value;
        };
        TextAreaWrapper.prototype.setValue = function (reason, value) {
            // console.log('reason: ' + reason + ', current value: ' + this._textArea.value + ' => new value: ' + value);
            this._textArea.value = value;
        };
        TextAreaWrapper.prototype.getSelectionStart = function () {
            return this._textArea.selectionStart;
        };
        TextAreaWrapper.prototype.getSelectionEnd = function () {
            return this._textArea.selectionEnd;
        };
        TextAreaWrapper.prototype.setSelectionRange = function (selectionStart, selectionEnd) {
            var activeElement = document.activeElement;
            if (activeElement === this._textArea) {
                this._textArea.setSelectionRange(selectionStart, selectionEnd);
            }
            else {
                this._setSelectionRangeJumpy(selectionStart, selectionEnd);
            }
        };
        TextAreaWrapper.prototype._setSelectionRangeJumpy = function (selectionStart, selectionEnd) {
            try {
                var scrollState = dom.saveParentsScrollTop(this._textArea);
                this._textArea.focus();
                this._textArea.setSelectionRange(selectionStart, selectionEnd);
                dom.restoreParentsScrollTop(this._textArea, scrollState);
            }
            catch (e) {
                // Sometimes IE throws when setting selection (e.g. textarea is off-DOM)
                console.log('an error has been thrown!');
            }
        };
        TextAreaWrapper.prototype.isInOverwriteMode = function () {
            // In IE, pressing Insert will bring the typing into overwrite mode
            if (browser.isIE11orEarlier && document.queryCommandValue('OverWrite')) {
                return true;
            }
            return false;
        };
        return TextAreaWrapper;
    }(lifecycle_1.Disposable));
    var KeyboardHandler = (function (_super) {
        __extends(KeyboardHandler, _super);
        function KeyboardHandler(context, viewController, viewHelper) {
            var _this = this;
            _super.call(this);
            this._lastCursorSelectionChanged = null;
            this._context = context;
            this.viewController = viewController;
            this.textArea = new TextAreaWrapper(viewHelper.textArea);
            configuration_1.Configuration.applyFontInfoSlow(this.textArea.actual, this._context.configuration.editor.fontInfo);
            this.viewHelper = viewHelper;
            this.contentLeft = 0;
            this.contentWidth = 0;
            this.scrollLeft = 0;
            this.textAreaHandler = new textAreaHandler_1.TextAreaHandler(browser, this._getStrategy(), this.textArea, this._context.model, function () { return _this.viewHelper.flushAnyAccumulatedEvents(); });
            this._toDispose = [];
            this._toDispose.push(this.textAreaHandler.onKeyDown(function (e) { return _this.viewController.emitKeyDown(e._actual); }));
            this._toDispose.push(this.textAreaHandler.onKeyUp(function (e) { return _this.viewController.emitKeyUp(e._actual); }));
            this._toDispose.push(this.textAreaHandler.onPaste(function (e) { return _this.viewController.paste('keyboard', e.text, e.pasteOnNewLine); }));
            this._toDispose.push(this.textAreaHandler.onCut(function (e) { return _this.viewController.cut('keyboard'); }));
            this._toDispose.push(this.textAreaHandler.onType(function (e) {
                if (e.replaceCharCnt) {
                    _this.viewController.replacePreviousChar('keyboard', e.text, e.replaceCharCnt);
                }
                else {
                    _this.viewController.type('keyboard', e.text);
                }
            }));
            this._toDispose.push(this.textAreaHandler.onCompositionStart(function (e) {
                var lineNumber = e.showAtLineNumber;
                var column = e.showAtColumn;
                var revealPositionEvent = {
                    range: new range_1.Range(lineNumber, column, lineNumber, column),
                    verticalType: editorCommon.VerticalRevealType.Simple,
                    revealHorizontal: true
                };
                _this._context.privateViewEventBus.emit(editorCommon.ViewEventNames.RevealRangeEvent, revealPositionEvent);
                // Find range pixel position
                _this.visibleRange = _this.viewHelper.visibleRangeForPositionRelativeToEditor(lineNumber, column);
                if (_this.visibleRange) {
                    styleMutator_1.StyleMutator.setTop(_this.textArea.actual, _this.visibleRange.top);
                    styleMutator_1.StyleMutator.setLeft(_this.textArea.actual, _this.contentLeft + _this.visibleRange.left - _this.scrollLeft);
                }
                if (browser.isIE11orEarlier) {
                    styleMutator_1.StyleMutator.setWidth(_this.textArea.actual, _this.contentWidth);
                }
                // Show the textarea
                styleMutator_1.StyleMutator.setHeight(_this.textArea.actual, _this._context.configuration.editor.lineHeight);
                dom.addClass(_this.viewHelper.viewDomNode, 'ime-input');
            }));
            this._toDispose.push(this.textAreaHandler.onCompositionUpdate(function (e) {
                // adjust width by its size
                var canvasElem = document.createElement('canvas');
                var context = canvasElem.getContext('2d');
                context.font = window.getComputedStyle(_this.textArea.actual).font;
                var metrics = context.measureText(e.data);
                styleMutator_1.StyleMutator.setWidth(_this.textArea.actual, metrics.width);
            }));
            this._toDispose.push(this.textAreaHandler.onCompositionEnd(function (e) {
                _this.textArea.actual.style.height = '';
                _this.textArea.actual.style.width = '';
                styleMutator_1.StyleMutator.setLeft(_this.textArea.actual, 0);
                styleMutator_1.StyleMutator.setTop(_this.textArea.actual, 0);
                dom.removeClass(_this.viewHelper.viewDomNode, 'ime-input');
                _this.visibleRange = null;
            }));
            this._toDispose.push(commonEditorConfig_1.GlobalScreenReaderNVDA.onChange(function (value) {
                _this.textAreaHandler.setStrategy(_this._getStrategy());
            }));
            this._context.addEventHandler(this);
        }
        KeyboardHandler.prototype.dispose = function () {
            this._context.removeEventHandler(this);
            this.textAreaHandler.dispose();
            this.textArea.dispose();
            this._toDispose = lifecycle_1.dispose(this._toDispose);
        };
        KeyboardHandler.prototype._getStrategy = function () {
            if (commonEditorConfig_1.GlobalScreenReaderNVDA.getValue()) {
                return textAreaState_1.TextAreaStrategy.NVDA;
            }
            if (this._context.configuration.editor.viewInfo.experimentalScreenReader) {
                return textAreaState_1.TextAreaStrategy.NVDA;
            }
            return textAreaState_1.TextAreaStrategy.IENarrator;
        };
        KeyboardHandler.prototype.focusTextArea = function () {
            this.textAreaHandler.writePlaceholderAndSelectTextAreaSync();
        };
        KeyboardHandler.prototype.onConfigurationChanged = function (e) {
            // Give textarea same font size & line height as editor, for the IME case (when the textarea is visible)
            if (e.fontInfo) {
                configuration_1.Configuration.applyFontInfoSlow(this.textArea.actual, this._context.configuration.editor.fontInfo);
            }
            if (e.viewInfo.experimentalScreenReader) {
                this.textAreaHandler.setStrategy(this._getStrategy());
            }
            return false;
        };
        KeyboardHandler.prototype.onScrollChanged = function (e) {
            this.scrollLeft = e.scrollLeft;
            if (this.visibleRange) {
                styleMutator_1.StyleMutator.setTop(this.textArea.actual, this.visibleRange.top);
                styleMutator_1.StyleMutator.setLeft(this.textArea.actual, this.contentLeft + this.visibleRange.left - this.scrollLeft);
            }
            return false;
        };
        KeyboardHandler.prototype.onViewFocusChanged = function (isFocused) {
            this.textAreaHandler.setHasFocus(isFocused);
            return false;
        };
        KeyboardHandler.prototype.onCursorSelectionChanged = function (e) {
            this._lastCursorSelectionChanged = e;
            return false;
        };
        KeyboardHandler.prototype.onCursorPositionChanged = function (e) {
            this.textAreaHandler.setCursorPosition(e.position);
            return false;
        };
        KeyboardHandler.prototype.onLayoutChanged = function (layoutInfo) {
            this.contentLeft = layoutInfo.contentLeft;
            this.contentWidth = layoutInfo.contentWidth;
            return false;
        };
        KeyboardHandler.prototype.writeToTextArea = function () {
            if (this._lastCursorSelectionChanged) {
                var e = this._lastCursorSelectionChanged;
                this._lastCursorSelectionChanged = null;
                this.textAreaHandler.setCursorSelections(e.selection, e.secondarySelections);
            }
        };
        return KeyboardHandler;
    }(viewEventHandler_1.ViewEventHandler));
    exports.KeyboardHandler = KeyboardHandler;
});






define(__m[425], __M([0,1,27,22,159,66]), function (require, exports, styleMutator_1, editorBrowser, viewLayer_1, configuration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewOverlays = (function (_super) {
        __extends(ViewOverlays, _super);
        function ViewOverlays(context, layoutProvider) {
            _super.call(this, context);
            this._dynamicOverlays = [];
            this._isFocused = false;
            this._layoutProvider = layoutProvider;
            this.domNode.setClassName('view-overlays');
        }
        ViewOverlays.prototype.shouldRender = function () {
            if (_super.prototype.shouldRender.call(this)) {
                return true;
            }
            for (var i = 0, len = this._dynamicOverlays.length; i < len; i++) {
                var dynamicOverlay = this._dynamicOverlays[i];
                if (dynamicOverlay.shouldRender()) {
                    return true;
                }
            }
            return false;
        };
        ViewOverlays.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._layoutProvider = null;
            for (var i = 0, len = this._dynamicOverlays.length; i < len; i++) {
                var dynamicOverlay = this._dynamicOverlays[i];
                dynamicOverlay.dispose();
            }
            this._dynamicOverlays = null;
        };
        ViewOverlays.prototype.getDomNode = function () {
            return this.domNode.domNode;
        };
        ViewOverlays.prototype.addDynamicOverlay = function (overlay) {
            this._dynamicOverlays.push(overlay);
        };
        // ----- event handlers
        ViewOverlays.prototype.onViewFocusChanged = function (isFocused) {
            this._isFocused = isFocused;
            return true;
        };
        // ----- end event handlers
        ViewOverlays.prototype._createLine = function () {
            var r = new ViewOverlayLine(this._context, this._dynamicOverlays);
            return r;
        };
        ViewOverlays.prototype.prepareRender = function (ctx) {
            var toRender = this._dynamicOverlays.filter(function (overlay) { return overlay.shouldRender(); });
            for (var i = 0, len = toRender.length; i < len; i++) {
                var dynamicOverlay = toRender[i];
                dynamicOverlay.prepareRender(ctx);
                dynamicOverlay.onDidRender();
            }
            return null;
        };
        ViewOverlays.prototype.render = function (ctx) {
            // Overwriting to bypass `shouldRender` flag
            this._viewOverlaysRender(ctx);
            this.domNode.toggleClassName('focused', this._isFocused);
        };
        ViewOverlays.prototype._viewOverlaysRender = function (ctx) {
            _super.prototype._renderLines.call(this, ctx.linesViewportData);
        };
        return ViewOverlays;
    }(viewLayer_1.ViewLayer));
    exports.ViewOverlays = ViewOverlays;
    var ViewOverlayLine = (function () {
        function ViewOverlayLine(context, dynamicOverlays) {
            this._context = context;
            this._lineHeight = this._context.configuration.editor.lineHeight;
            this._dynamicOverlays = dynamicOverlays;
            this._domNode = null;
            this._renderPieces = null;
        }
        ViewOverlayLine.prototype.getDomNode = function () {
            if (!this._domNode) {
                return null;
            }
            return this._domNode.domNode;
        };
        ViewOverlayLine.prototype.setDomNode = function (domNode) {
            this._domNode = styleMutator_1.createFastDomNode(domNode);
        };
        ViewOverlayLine.prototype.onContentChanged = function () {
            // Nothing
        };
        ViewOverlayLine.prototype.onLinesInsertedAbove = function () {
            // Nothing
        };
        ViewOverlayLine.prototype.onLinesDeletedAbove = function () {
            // Nothing
        };
        ViewOverlayLine.prototype.onLineChangedAbove = function () {
            // Nothing
        };
        ViewOverlayLine.prototype.onTokensChanged = function () {
            // Nothing
        };
        ViewOverlayLine.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
        };
        ViewOverlayLine.prototype.shouldUpdateHTML = function (startLineNumber, lineNumber, inlineDecorations) {
            var newPieces = '';
            for (var i = 0, len = this._dynamicOverlays.length; i < len; i++) {
                var dynamicOverlay = this._dynamicOverlays[i];
                newPieces += dynamicOverlay.render(startLineNumber, lineNumber);
            }
            var piecesEqual = (this._renderPieces === newPieces);
            if (!piecesEqual) {
                this._renderPieces = newPieces;
            }
            return !piecesEqual;
        };
        ViewOverlayLine.prototype.getLineOuterHTML = function (out, lineNumber, deltaTop) {
            out.push('<div lineNumber="');
            out.push(lineNumber.toString());
            out.push('" style="top:');
            out.push(deltaTop.toString());
            out.push('px;height:');
            out.push(this._lineHeight.toString());
            out.push('px;" class="');
            out.push(editorBrowser.ClassNames.VIEW_LINE);
            out.push('">');
            out.push(this.getLineInnerHTML(lineNumber));
            out.push('</div>');
        };
        ViewOverlayLine.prototype.getLineInnerHTML = function (lineNumber) {
            return this._renderPieces;
        };
        ViewOverlayLine.prototype.layoutLine = function (lineNumber, deltaTop) {
            this._domNode.setLineNumber(String(lineNumber));
            this._domNode.setTop(deltaTop);
            this._domNode.setHeight(this._lineHeight);
        };
        return ViewOverlayLine;
    }());
    var ContentViewOverlays = (function (_super) {
        __extends(ContentViewOverlays, _super);
        function ContentViewOverlays(context, layoutProvider) {
            _super.call(this, context, layoutProvider);
            this._scrollWidth = this._layoutProvider.getScrollWidth();
            this.domNode.setWidth(this._scrollWidth);
            this.domNode.setHeight(0);
        }
        ContentViewOverlays.prototype.onScrollChanged = function (e) {
            this._scrollWidth = e.scrollWidth;
            return _super.prototype.onScrollChanged.call(this, e) || e.scrollWidthChanged;
        };
        ContentViewOverlays.prototype._viewOverlaysRender = function (ctx) {
            _super.prototype._viewOverlaysRender.call(this, ctx);
            this.domNode.setWidth(this._scrollWidth);
        };
        return ContentViewOverlays;
    }(ViewOverlays));
    exports.ContentViewOverlays = ContentViewOverlays;
    var MarginViewOverlays = (function (_super) {
        __extends(MarginViewOverlays, _super);
        function MarginViewOverlays(context, layoutProvider) {
            _super.call(this, context, layoutProvider);
            this._glyphMarginLeft = context.configuration.editor.layoutInfo.glyphMarginLeft;
            this._glyphMarginWidth = context.configuration.editor.layoutInfo.glyphMarginWidth;
            this._scrollHeight = layoutProvider.getScrollHeight();
            this._contentLeft = context.configuration.editor.layoutInfo.contentLeft;
            this._canUseTranslate3d = context.configuration.editor.viewInfo.canUseTranslate3d;
            this.domNode.setClassName(editorBrowser.ClassNames.MARGIN_VIEW_OVERLAYS + ' monaco-editor-background');
            this.domNode.setWidth(1);
            configuration_1.Configuration.applyFontInfo(this.domNode, this._context.configuration.editor.fontInfo);
        }
        MarginViewOverlays.prototype._extraDomNodeHTML = function () {
            return [
                '<div class="',
                editorBrowser.ClassNames.GLYPH_MARGIN,
                '" style="left:',
                String(this._glyphMarginLeft),
                'px;width:',
                String(this._glyphMarginWidth),
                'px;height:',
                String(this._scrollHeight),
                'px;"></div>'
            ].join('');
        };
        MarginViewOverlays.prototype._getGlyphMarginDomNode = function () {
            return this.domNode.domNode.children[0];
        };
        MarginViewOverlays.prototype.onScrollChanged = function (e) {
            this._scrollHeight = e.scrollHeight;
            return _super.prototype.onScrollChanged.call(this, e) || e.scrollHeightChanged;
        };
        MarginViewOverlays.prototype.onLayoutChanged = function (layoutInfo) {
            this._glyphMarginLeft = layoutInfo.glyphMarginLeft;
            this._glyphMarginWidth = layoutInfo.glyphMarginWidth;
            this._scrollHeight = this._layoutProvider.getScrollHeight();
            this._contentLeft = layoutInfo.contentLeft;
            return _super.prototype.onLayoutChanged.call(this, layoutInfo) || true;
        };
        MarginViewOverlays.prototype.onConfigurationChanged = function (e) {
            if (e.fontInfo) {
                configuration_1.Configuration.applyFontInfo(this.domNode, this._context.configuration.editor.fontInfo);
            }
            if (e.viewInfo.canUseTranslate3d) {
                this._canUseTranslate3d = this._context.configuration.editor.viewInfo.canUseTranslate3d;
            }
            return _super.prototype.onConfigurationChanged.call(this, e);
        };
        MarginViewOverlays.prototype._viewOverlaysRender = function (ctx) {
            _super.prototype._viewOverlaysRender.call(this, ctx);
            if (this._canUseTranslate3d) {
                var transform = 'translate3d(0px, ' + ctx.linesViewportData.visibleRangesDeltaTop + 'px, 0px)';
                this.domNode.setTransform(transform);
                this.domNode.setTop(0);
            }
            else {
                this.domNode.setTransform('');
                this.domNode.setTop(ctx.linesViewportData.visibleRangesDeltaTop);
            }
            var height = Math.min(this._layoutProvider.getTotalHeight(), 1000000);
            this.domNode.setHeight(height);
            this.domNode.setWidth(this._contentLeft);
            var glyphMargin = this._getGlyphMarginDomNode();
            if (glyphMargin) {
                styleMutator_1.StyleMutator.setHeight(glyphMargin, this._scrollHeight);
                styleMutator_1.StyleMutator.setLeft(glyphMargin, this._glyphMarginLeft);
                styleMutator_1.StyleMutator.setWidth(glyphMargin, this._glyphMarginWidth);
            }
        };
        return MarginViewOverlays;
    }(ViewOverlays));
    exports.MarginViewOverlays = MarginViewOverlays;
});






define(__m[426], __M([0,1,14,27,4,7,22,159,277,66,102,189]), function (require, exports, async_1, styleMutator_1, range_1, editorCommon, editorBrowser_1, viewLayer_1, viewLine_1, configuration_1, renderingContext_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var LastRenderedData = (function () {
        function LastRenderedData() {
            this._currentVisibleRange = new range_1.Range(1, 1, 1, 1);
            this._bigNumbersDelta = 0;
        }
        LastRenderedData.prototype.getCurrentVisibleRange = function () {
            return this._currentVisibleRange;
        };
        LastRenderedData.prototype.setCurrentVisibleRange = function (currentVisibleRange) {
            this._currentVisibleRange = currentVisibleRange;
        };
        LastRenderedData.prototype.getBigNumbersDelta = function () {
            return this._bigNumbersDelta;
        };
        LastRenderedData.prototype.setBigNumbersDelta = function (bigNumbersDelta) {
            this._bigNumbersDelta = bigNumbersDelta;
        };
        return LastRenderedData;
    }());
    var ViewLines = (function (_super) {
        __extends(ViewLines, _super);
        function ViewLines(context, layoutProvider) {
            var _this = this;
            _super.call(this, context);
            this._lineHeight = this._context.configuration.editor.lineHeight;
            this._isViewportWrapping = this._context.configuration.editor.wrappingInfo.isViewportWrapping;
            this._revealHorizontalRightPadding = this._context.configuration.editor.viewInfo.revealHorizontalRightPadding;
            this._canUseTranslate3d = context.configuration.editor.viewInfo.canUseTranslate3d;
            this._layoutProvider = layoutProvider;
            this.domNode.setClassName(editorBrowser_1.ClassNames.VIEW_LINES);
            configuration_1.Configuration.applyFontInfo(this.domNode, this._context.configuration.editor.fontInfo);
            // --- width & height
            this._maxLineWidth = 0;
            this._asyncUpdateLineWidths = new async_1.RunOnceScheduler(function () {
                _this._updateLineWidths();
            }, 200);
            this._lastRenderedData = new LastRenderedData();
            this._lastCursorRevealRangeHorizontallyEvent = null;
            this._textRangeRestingSpot = document.createElement('div');
            this._textRangeRestingSpot.className = 'textRangeRestingSpot';
        }
        ViewLines.prototype.dispose = function () {
            this._asyncUpdateLineWidths.dispose();
            this._layoutProvider = null;
            _super.prototype.dispose.call(this);
        };
        ViewLines.prototype.getDomNode = function () {
            return this.domNode.domNode;
        };
        // ---- begin view event handlers
        ViewLines.prototype.onConfigurationChanged = function (e) {
            var shouldRender = _super.prototype.onConfigurationChanged.call(this, e);
            if (e.wrappingInfo) {
                this._maxLineWidth = 0;
            }
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            if (e.wrappingInfo) {
                this._isViewportWrapping = this._context.configuration.editor.wrappingInfo.isViewportWrapping;
            }
            if (e.viewInfo.revealHorizontalRightPadding) {
                this._revealHorizontalRightPadding = this._context.configuration.editor.viewInfo.revealHorizontalRightPadding;
            }
            if (e.viewInfo.canUseTranslate3d) {
                this._canUseTranslate3d = this._context.configuration.editor.viewInfo.canUseTranslate3d;
            }
            if (e.fontInfo) {
                configuration_1.Configuration.applyFontInfo(this.domNode, this._context.configuration.editor.fontInfo);
            }
            return shouldRender;
        };
        ViewLines.prototype.onLayoutChanged = function (layoutInfo) {
            var shouldRender = _super.prototype.onLayoutChanged.call(this, layoutInfo);
            this._maxLineWidth = 0;
            return shouldRender;
        };
        ViewLines.prototype.onModelFlushed = function () {
            var shouldRender = _super.prototype.onModelFlushed.call(this);
            this._maxLineWidth = 0;
            return shouldRender;
        };
        ViewLines.prototype.onModelDecorationsChanged = function (e) {
            var shouldRender = _super.prototype.onModelDecorationsChanged.call(this, e);
            for (var i = 0; i < this._lines.length; i++) {
                this._lines[i].onModelDecorationsChanged();
            }
            return shouldRender || true;
        };
        ViewLines.prototype.onCursorRevealRange = function (e) {
            var newScrollTop = this._computeScrollTopToRevealRange(this._layoutProvider.getCurrentViewport(), e.range, e.verticalType);
            if (e.revealHorizontal) {
                this._lastCursorRevealRangeHorizontallyEvent = e;
            }
            this._layoutProvider.setScrollPosition({
                scrollTop: newScrollTop
            });
            return true;
        };
        ViewLines.prototype.onCursorScrollRequest = function (e) {
            var currentScrollTop = this._layoutProvider.getScrollTop();
            var newScrollTop = currentScrollTop + e.deltaLines * this._lineHeight;
            this._layoutProvider.setScrollPosition({
                scrollTop: newScrollTop
            });
            return true;
        };
        ViewLines.prototype.onScrollChanged = function (e) {
            this.domNode.setWidth(e.scrollWidth);
            return _super.prototype.onScrollChanged.call(this, e) || true;
        };
        // ---- end view event handlers
        // ----------- HELPERS FOR OTHERS
        ViewLines.prototype.getPositionFromDOMInfo = function (spanNode, offset) {
            var lineNumber = this._getLineNumberFromDOMInfo(spanNode);
            if (lineNumber === -1) {
                // Couldn't find span node
                return null;
            }
            if (lineNumber < 1 || lineNumber > this._context.model.getLineCount()) {
                // lineNumber is outside range
                return null;
            }
            if (this._context.model.getLineMaxColumn(lineNumber) === 1) {
                // Line is empty
                return {
                    lineNumber: lineNumber,
                    column: 1
                };
            }
            var lineIndex = lineNumber - this._rendLineNumberStart;
            if (lineIndex < 0 || lineIndex >= this._lines.length) {
                // Couldn't find line
                return null;
            }
            var column = this._lines[lineIndex].getColumnOfNodeOffset(lineNumber, spanNode, offset);
            var minColumn = this._context.model.getLineMinColumn(lineNumber);
            if (column < minColumn) {
                column = minColumn;
            }
            return {
                lineNumber: lineNumber,
                column: column
            };
        };
        ViewLines.prototype._getLineNumberFromDOMInfo = function (spanNode) {
            while (spanNode && spanNode.nodeType === 1) {
                if (spanNode.className === editorBrowser_1.ClassNames.VIEW_LINE) {
                    return parseInt(spanNode.getAttribute('lineNumber'), 10);
                }
                spanNode = spanNode.parentElement;
            }
            return -1;
        };
        ViewLines.prototype.getLineWidth = function (lineNumber) {
            var lineIndex = lineNumber - this._rendLineNumberStart;
            if (lineIndex < 0 || lineIndex >= this._lines.length) {
                return -1;
            }
            return this._lines[lineIndex].getWidth();
        };
        ViewLines.prototype.linesVisibleRangesForRange = function (range, includeNewLines) {
            if (this.shouldRender()) {
                // Cannot read from the DOM because it is dirty
                // i.e. the model & the dom are out of sync, so I'd be reading something stale
                return null;
            }
            var originalEndLineNumber = range.endLineNumber;
            range = range_1.Range.intersectRanges(range, this._lastRenderedData.getCurrentVisibleRange());
            if (!range) {
                return null;
            }
            var visibleRanges = [];
            var clientRectDeltaLeft = this.domNode.domNode.getBoundingClientRect().left;
            var nextLineModelLineNumber;
            if (includeNewLines) {
                nextLineModelLineNumber = this._context.model.convertViewPositionToModelPosition(range.startLineNumber, 1).lineNumber;
            }
            for (var lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {
                var lineIndex = lineNumber - this._rendLineNumberStart;
                if (lineIndex < 0 || lineIndex >= this._lines.length) {
                    continue;
                }
                var startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;
                var endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);
                var visibleRangesForLine = this._lines[lineIndex].getVisibleRangesForRange(startColumn, endColumn, clientRectDeltaLeft, this._textRangeRestingSpot);
                if (!visibleRangesForLine || visibleRangesForLine.length === 0) {
                    continue;
                }
                if (includeNewLines && lineNumber < originalEndLineNumber) {
                    var currentLineModelLineNumber = nextLineModelLineNumber;
                    nextLineModelLineNumber = this._context.model.convertViewPositionToModelPosition(lineNumber + 1, 1).lineNumber;
                    if (currentLineModelLineNumber !== nextLineModelLineNumber) {
                        visibleRangesForLine[visibleRangesForLine.length - 1].width += ViewLines.LINE_FEED_WIDTH;
                    }
                }
                visibleRanges.push(new renderingContext_1.LineVisibleRanges(lineNumber, visibleRangesForLine));
            }
            if (visibleRanges.length === 0) {
                return null;
            }
            return visibleRanges;
        };
        ViewLines.prototype.visibleRangesForRange2 = function (range, deltaTop) {
            if (this.shouldRender()) {
                // Cannot read from the DOM because it is dirty
                // i.e. the model & the dom are out of sync, so I'd be reading something stale
                return null;
            }
            range = range_1.Range.intersectRanges(range, this._lastRenderedData.getCurrentVisibleRange());
            if (!range) {
                return null;
            }
            var result = [];
            var clientRectDeltaLeft = this.domNode.domNode.getBoundingClientRect().left;
            var bigNumbersDelta = this._lastRenderedData.getBigNumbersDelta();
            for (var lineNumber = range.startLineNumber; lineNumber <= range.endLineNumber; lineNumber++) {
                var lineIndex = lineNumber - this._rendLineNumberStart;
                if (lineIndex < 0 || lineIndex >= this._lines.length) {
                    continue;
                }
                var startColumn = lineNumber === range.startLineNumber ? range.startColumn : 1;
                var endColumn = lineNumber === range.endLineNumber ? range.endColumn : this._context.model.getLineMaxColumn(lineNumber);
                var visibleRangesForLine = this._lines[lineIndex].getVisibleRangesForRange(startColumn, endColumn, clientRectDeltaLeft, this._textRangeRestingSpot);
                if (!visibleRangesForLine || visibleRangesForLine.length === 0) {
                    continue;
                }
                var adjustedLineNumberVerticalOffset = this._layoutProvider.getVerticalOffsetForLineNumber(lineNumber) - bigNumbersDelta + deltaTop;
                for (var i = 0, len = visibleRangesForLine.length; i < len; i++) {
                    result.push(new renderingContext_1.VisibleRange(adjustedLineNumberVerticalOffset, visibleRangesForLine[i].left, visibleRangesForLine[i].width));
                }
            }
            if (result.length === 0) {
                return null;
            }
            return result;
        };
        // --- implementation
        ViewLines.prototype._createLine = function () {
            return viewLine_1.createLine(this._context);
        };
        ViewLines.prototype._updateLineWidths = function () {
            var i, localMaxLineWidth = 1, widthInPx;
            // Read line widths
            for (i = 0; i < this._lines.length; i++) {
                widthInPx = this._lines[i].getWidth();
                localMaxLineWidth = Math.max(localMaxLineWidth, widthInPx);
            }
            this._ensureMaxLineWidth(localMaxLineWidth);
        };
        ViewLines.prototype.prepareRender = function () {
            throw new Error('Not supported');
        };
        ViewLines.prototype.render = function () {
            throw new Error('Not supported');
        };
        ViewLines.prototype.renderText = function (linesViewportData, onAfterLinesRendered) {
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
            // (1) render lines - ensures lines are in the DOM
            _super.prototype._renderLines.call(this, linesViewportData);
            this._lastRenderedData.setBigNumbersDelta(linesViewportData.bigNumbersDelta);
            this._lastRenderedData.setCurrentVisibleRange(linesViewportData.visibleRange);
            this.domNode.setWidth(this._layoutProvider.getScrollWidth());
            this.domNode.setHeight(Math.min(this._layoutProvider.getTotalHeight(), 1000000));
            // (2) execute DOM writing that forces sync layout (e.g. textArea manipulation)
            onAfterLinesRendered();
            // (3) compute horizontal scroll position:
            //  - this must happen after the lines are in the DOM since it might need a line that rendered just now
            //  - it might change `scrollWidth` and `scrollLeft`
            if (this._lastCursorRevealRangeHorizontallyEvent) {
                var revealHorizontalRange = this._lastCursorRevealRangeHorizontallyEvent.range;
                this._lastCursorRevealRangeHorizontallyEvent = null;
                // allow `visibleRangesForRange2` to work
                this.onDidRender();
                // compute new scroll position
                var newScrollLeft = this._computeScrollLeftToRevealRange(revealHorizontalRange);
                var isViewportWrapping = this._isViewportWrapping;
                if (!isViewportWrapping) {
                    // ensure `scrollWidth` is large enough
                    this._ensureMaxLineWidth(newScrollLeft.maxHorizontalOffset);
                }
                // set `scrollLeft`
                this._layoutProvider.setScrollPosition({
                    scrollLeft: newScrollLeft.scrollLeft
                });
            }
            // (4) handle scrolling
            if (this._canUseTranslate3d) {
                var transform = 'translate3d(' + -this._layoutProvider.getScrollLeft() + 'px, ' + linesViewportData.visibleRangesDeltaTop + 'px, 0px)';
                styleMutator_1.StyleMutator.setTransform(this.domNode.domNode.parentNode, transform);
                styleMutator_1.StyleMutator.setTop(this.domNode.domNode.parentNode, 0); // TODO@Alex
                styleMutator_1.StyleMutator.setLeft(this.domNode.domNode.parentNode, 0); // TODO@Alex
            }
            else {
                styleMutator_1.StyleMutator.setTransform(this.domNode.domNode.parentNode, '');
                styleMutator_1.StyleMutator.setTop(this.domNode.domNode.parentNode, linesViewportData.visibleRangesDeltaTop); // TODO@Alex
                styleMutator_1.StyleMutator.setLeft(this.domNode.domNode.parentNode, -this._layoutProvider.getScrollLeft()); // TODO@Alex
            }
            // Update max line width (not so important, it is just so the horizontal scrollbar doesn't get too small)
            this._asyncUpdateLineWidths.schedule();
        };
        // --- width
        ViewLines.prototype._ensureMaxLineWidth = function (lineWidth) {
            var iLineWidth = Math.ceil(lineWidth);
            if (this._maxLineWidth < iLineWidth) {
                this._maxLineWidth = iLineWidth;
                this._layoutProvider.onMaxLineWidthChanged(this._maxLineWidth);
            }
        };
        ViewLines.prototype._computeScrollTopToRevealRange = function (viewport, range, verticalType) {
            var viewportStartY = viewport.top, viewportHeight = viewport.height, viewportEndY = viewportStartY + viewportHeight, boxStartY, boxEndY;
            // Have a box that includes one extra line height (for the horizontal scrollbar)
            boxStartY = this._layoutProvider.getVerticalOffsetForLineNumber(range.startLineNumber);
            boxEndY = this._layoutProvider.getVerticalOffsetForLineNumber(range.endLineNumber) + this._layoutProvider.heightInPxForLine(range.endLineNumber);
            if (verticalType === editorCommon.VerticalRevealType.Simple) {
                // Reveal one line more for the arrow down case, when the last line would be covered by the scrollbar
                boxEndY += this._lineHeight;
            }
            var newScrollTop;
            if (verticalType === editorCommon.VerticalRevealType.Center || verticalType === editorCommon.VerticalRevealType.CenterIfOutsideViewport) {
                if (verticalType === editorCommon.VerticalRevealType.CenterIfOutsideViewport && viewportStartY <= boxStartY && boxEndY <= viewportEndY) {
                    // Box is already in the viewport... do nothing
                    newScrollTop = viewportStartY;
                }
                else {
                    // Box is outside the viewport... center it
                    var boxMiddleY = (boxStartY + boxEndY) / 2;
                    newScrollTop = Math.max(0, boxMiddleY - viewportHeight / 2);
                }
            }
            else {
                newScrollTop = this._computeMinimumScrolling(viewportStartY, viewportEndY, boxStartY, boxEndY);
            }
            return newScrollTop;
        };
        ViewLines.prototype._computeScrollLeftToRevealRange = function (range) {
            var maxHorizontalOffset = 0;
            if (range.startLineNumber !== range.endLineNumber) {
                // Two or more lines? => scroll to base (That's how you see most of the two lines)
                return {
                    scrollLeft: 0,
                    maxHorizontalOffset: maxHorizontalOffset
                };
            }
            var viewport = this._layoutProvider.getCurrentViewport(), viewportStartX = viewport.left, viewportEndX = viewportStartX + viewport.width;
            var visibleRanges = this.visibleRangesForRange2(range, 0), boxStartX = Number.MAX_VALUE, boxEndX = 0;
            if (!visibleRanges) {
                // Unknown
                return {
                    scrollLeft: viewportStartX,
                    maxHorizontalOffset: maxHorizontalOffset
                };
            }
            var i, visibleRange;
            for (i = 0; i < visibleRanges.length; i++) {
                visibleRange = visibleRanges[i];
                if (visibleRange.left < boxStartX) {
                    boxStartX = visibleRange.left;
                }
                if (visibleRange.left + visibleRange.width > boxEndX) {
                    boxEndX = visibleRange.left + visibleRange.width;
                }
            }
            maxHorizontalOffset = boxEndX;
            boxStartX = Math.max(0, boxStartX - ViewLines.HORIZONTAL_EXTRA_PX);
            boxEndX += this._revealHorizontalRightPadding;
            var newScrollLeft = this._computeMinimumScrolling(viewportStartX, viewportEndX, boxStartX, boxEndX);
            return {
                scrollLeft: newScrollLeft,
                maxHorizontalOffset: maxHorizontalOffset
            };
        };
        ViewLines.prototype._computeMinimumScrolling = function (viewportStart, viewportEnd, boxStart, boxEnd) {
            viewportStart = viewportStart | 0;
            viewportEnd = viewportEnd | 0;
            boxStart = boxStart | 0;
            boxEnd = boxEnd | 0;
            var viewportLength = viewportEnd - viewportStart;
            var boxLength = boxEnd - boxStart;
            if (boxLength < viewportLength) {
                // The box would fit in the viewport
                if (boxStart < viewportStart) {
                    // The box is above the viewport
                    return boxStart;
                }
                else if (boxEnd > viewportEnd) {
                    // The box is below the viewport
                    return Math.max(0, boxEnd - viewportLength);
                }
            }
            else {
                // The box would not fit in the viewport
                // Reveal the beginning of the box
                return boxStart;
            }
            return viewportStart;
        };
        /**
         * Width to extends a line to render the line feed at the end of the line
         */
        ViewLines.LINE_FEED_WIDTH = 10;
        /**
         * Adds this ammount of pixels to the right of lines (no-one wants to type near the edge of the viewport)
         */
        ViewLines.HORIZONTAL_EXTRA_PX = 30;
        return ViewLines;
    }(viewLayer_1.ViewLayer));
    exports.ViewLines = ViewLines;
});

define(__m[427], __M([0,1,27,7,66]), function (require, exports, styleMutator_1, editorCommon_1, configuration_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ViewCursor = (function () {
        function ViewCursor(context, isSecondary) {
            this._context = context;
            this._cursorStyle = this._context.configuration.editor.viewInfo.cursorStyle;
            this._lineHeight = this._context.configuration.editor.lineHeight;
            this._lastRenderedContent = '';
            this._isInEditableRange = true;
            this._domNode = this._createCursorDomNode(isSecondary);
            configuration_1.Configuration.applyFontInfo(this._domNode, this._context.configuration.editor.fontInfo);
            this._isVisible = true;
            this._domNode.setDisplay('none');
            this.updatePosition({
                lineNumber: 1,
                column: 1
            });
        }
        ViewCursor.prototype._createCursorDomNode = function (isSecondary) {
            var domNode = styleMutator_1.createFastDomNode(document.createElement('div'));
            if (isSecondary) {
                domNode.setClassName('cursor secondary');
            }
            else {
                domNode.setClassName('cursor');
            }
            domNode.setHeight(this._lineHeight);
            domNode.setTop(0);
            domNode.setLeft(0);
            domNode.domNode.setAttribute('role', 'presentation');
            domNode.domNode.setAttribute('aria-hidden', 'true');
            return domNode;
        };
        ViewCursor.prototype.getDomNode = function () {
            return this._domNode.domNode;
        };
        ViewCursor.prototype.getIsInEditableRange = function () {
            return this._isInEditableRange;
        };
        ViewCursor.prototype.getPositionTop = function () {
            return this._positionTop;
        };
        ViewCursor.prototype.getPosition = function () {
            return this._position;
        };
        ViewCursor.prototype.show = function () {
            if (!this._isVisible) {
                this._domNode.setVisibility('inherit');
                this._isVisible = true;
            }
        };
        ViewCursor.prototype.hide = function () {
            if (this._isVisible) {
                this._domNode.setVisibility('hidden');
                this._isVisible = false;
            }
        };
        ViewCursor.prototype.onModelFlushed = function () {
            this.updatePosition({
                lineNumber: 1,
                column: 1
            });
            this._isInEditableRange = true;
            return true;
        };
        ViewCursor.prototype.onCursorPositionChanged = function (position, isInEditableRange) {
            this.updatePosition(position);
            this._isInEditableRange = isInEditableRange;
            return true;
        };
        ViewCursor.prototype.onConfigurationChanged = function (e) {
            if (e.lineHeight) {
                this._lineHeight = this._context.configuration.editor.lineHeight;
            }
            if (e.viewInfo.cursorStyle) {
                this._cursorStyle = this._context.configuration.editor.viewInfo.cursorStyle;
            }
            if (e.fontInfo) {
                configuration_1.Configuration.applyFontInfo(this._domNode, this._context.configuration.editor.fontInfo);
            }
            return true;
        };
        ViewCursor.prototype.prepareRender = function (ctx) {
            var visibleRange = ctx.visibleRangeForPosition(this._position);
            if (visibleRange) {
                this._positionTop = visibleRange.top;
                this._positionLeft = visibleRange.left;
                this._isInViewport = true;
            }
            else {
                this._isInViewport = false;
            }
        };
        ViewCursor.prototype._getRenderedContent = function () {
            if (this._cursorStyle === editorCommon_1.TextEditorCursorStyle.Block) {
                var lineContent = this._context.model.getLineContent(this._position.lineNumber);
                return lineContent.charAt(this._position.column - 1);
            }
            return '';
        };
        ViewCursor.prototype.render = function (ctx) {
            if (this._isInViewport) {
                var renderContent = this._getRenderedContent();
                if (this._lastRenderedContent !== renderContent) {
                    this._lastRenderedContent = renderContent;
                    this._domNode.domNode.textContent = this._lastRenderedContent;
                }
                this._domNode.setDisplay('block');
                this._domNode.setLeft(this._positionLeft);
                this._domNode.setTop(this._positionTop + ctx.viewportTop - ctx.bigNumbersDelta);
                this._domNode.setLineHeight(this._lineHeight);
                this._domNode.setHeight(this._lineHeight);
            }
            else {
                this._domNode.setDisplay('none');
            }
        };
        ViewCursor.prototype.updatePosition = function (newPosition) {
            this._position = newPosition;
            this._domNode.domNode.setAttribute('lineNumber', this._position.lineNumber.toString());
            this._domNode.domNode.setAttribute('column', this._position.column.toString());
            this._isInViewport = false;
        };
        return ViewCursor;
    }());
    exports.ViewCursor = ViewCursor;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[428], __M([0,1,7,22,46,427,27,196]), function (require, exports, editorCommon, editorBrowser_1, viewPart_1, viewCursor_1, styleMutator_1) {
    'use strict';
    var RenderType;
    (function (RenderType) {
        RenderType[RenderType["Hidden"] = 0] = "Hidden";
        RenderType[RenderType["Visible"] = 1] = "Visible";
        RenderType[RenderType["Blink"] = 2] = "Blink";
    })(RenderType || (RenderType = {}));
    var ViewCursors = (function (_super) {
        __extends(ViewCursors, _super);
        function ViewCursors(context) {
            _super.call(this, context);
            this._readOnly = this._context.configuration.editor.readOnly;
            this._cursorBlinking = this._context.configuration.editor.viewInfo.cursorBlinking;
            this._cursorStyle = this._context.configuration.editor.viewInfo.cursorStyle;
            this._canUseTranslate3d = context.configuration.editor.viewInfo.canUseTranslate3d;
            this._primaryCursor = new viewCursor_1.ViewCursor(this._context, false);
            this._secondaryCursors = [];
            this._domNode = styleMutator_1.createFastDomNode(document.createElement('div'));
            this._updateDomClassName();
            this._domNode.domNode.appendChild(this._primaryCursor.getDomNode());
            this._blinkTimer = -1;
            this._editorHasFocus = false;
            this._updateBlinking();
        }
        ViewCursors.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            if (this._blinkTimer !== -1) {
                window.clearInterval(this._blinkTimer);
                this._blinkTimer = -1;
            }
        };
        ViewCursors.prototype.getDomNode = function () {
            return this._domNode.domNode;
        };
        // --- begin event handlers
        ViewCursors.prototype.onModelFlushed = function () {
            this._primaryCursor.onModelFlushed();
            for (var i = 0, len = this._secondaryCursors.length; i < len; i++) {
                var domNode = this._secondaryCursors[i].getDomNode();
                domNode.parentNode.removeChild(domNode);
            }
            this._secondaryCursors = [];
            return true;
        };
        ViewCursors.prototype.onModelDecorationsChanged = function (e) {
            // true for inline decorations that can end up relayouting text
            return e.inlineDecorationsChanged;
        };
        ViewCursors.prototype.onModelLinesDeleted = function (e) {
            return true;
        };
        ViewCursors.prototype.onModelLineChanged = function (e) {
            return true;
        };
        ViewCursors.prototype.onModelLinesInserted = function (e) {
            return true;
        };
        ViewCursors.prototype.onModelTokensChanged = function (e) {
            var shouldRender = function (position) {
                return e.fromLineNumber <= position.lineNumber && position.lineNumber <= e.toLineNumber;
            };
            if (shouldRender(this._primaryCursor.getPosition())) {
                return true;
            }
            for (var i = 0; i < this._secondaryCursors.length; i++) {
                if (shouldRender(this._secondaryCursors[i].getPosition())) {
                    return true;
                }
            }
            return false;
        };
        ViewCursors.prototype.onCursorPositionChanged = function (e) {
            this._primaryCursor.onCursorPositionChanged(e.position, e.isInEditableRange);
            this._updateBlinking();
            if (this._secondaryCursors.length < e.secondaryPositions.length) {
                // Create new cursors
                var addCnt = e.secondaryPositions.length - this._secondaryCursors.length;
                for (var i = 0; i < addCnt; i++) {
                    var newCursor = new viewCursor_1.ViewCursor(this._context, true);
                    this._primaryCursor.getDomNode().parentNode.insertBefore(newCursor.getDomNode(), this._primaryCursor.getDomNode().nextSibling);
                    this._secondaryCursors.push(newCursor);
                }
            }
            else if (this._secondaryCursors.length > e.secondaryPositions.length) {
                // Remove some cursors
                var removeCnt = this._secondaryCursors.length - e.secondaryPositions.length;
                for (var i = 0; i < removeCnt; i++) {
                    this._secondaryCursors[0].getDomNode().parentNode.removeChild(this._secondaryCursors[0].getDomNode());
                    this._secondaryCursors.splice(0, 1);
                }
            }
            for (var i = 0; i < e.secondaryPositions.length; i++) {
                this._secondaryCursors[i].onCursorPositionChanged(e.secondaryPositions[i], e.isInEditableRange);
            }
            return true;
        };
        ViewCursors.prototype.onCursorSelectionChanged = function (e) {
            return false;
        };
        ViewCursors.prototype.onConfigurationChanged = function (e) {
            if (e.readOnly) {
                this._readOnly = this._context.configuration.editor.readOnly;
            }
            if (e.viewInfo.cursorBlinking) {
                this._cursorBlinking = this._context.configuration.editor.viewInfo.cursorBlinking;
            }
            if (e.viewInfo.cursorStyle) {
                this._cursorStyle = this._context.configuration.editor.viewInfo.cursorStyle;
            }
            if (e.viewInfo.canUseTranslate3d) {
                this._canUseTranslate3d = this._context.configuration.editor.viewInfo.canUseTranslate3d;
            }
            this._primaryCursor.onConfigurationChanged(e);
            this._updateBlinking();
            if (e.viewInfo.cursorStyle) {
                this._updateDomClassName();
            }
            for (var i = 0, len = this._secondaryCursors.length; i < len; i++) {
                this._secondaryCursors[i].onConfigurationChanged(e);
            }
            return true;
        };
        ViewCursors.prototype.onLayoutChanged = function (layoutInfo) {
            return true;
        };
        ViewCursors.prototype.onScrollChanged = function (e) {
            return true;
        };
        ViewCursors.prototype.onZonesChanged = function () {
            return true;
        };
        ViewCursors.prototype.onViewFocusChanged = function (isFocused) {
            this._editorHasFocus = isFocused;
            this._updateBlinking();
            return false;
        };
        // --- end event handlers
        ViewCursors.prototype.getPosition = function () {
            return this._primaryCursor.getPosition();
        };
        // ---- blinking logic
        ViewCursors.prototype._getRenderType = function () {
            if (this._editorHasFocus) {
                if (this._primaryCursor.getIsInEditableRange() && !this._readOnly) {
                    switch (this._cursorBlinking) {
                        case 'blink':
                            return RenderType.Blink;
                        case 'visible':
                            return RenderType.Visible;
                        case 'hidden':
                            return RenderType.Hidden;
                        default:
                            return RenderType.Blink;
                    }
                }
                return RenderType.Visible;
            }
            return RenderType.Hidden;
        };
        ViewCursors.prototype._updateBlinking = function () {
            var _this = this;
            if (this._blinkTimer !== -1) {
                window.clearInterval(this._blinkTimer);
                this._blinkTimer = -1;
            }
            var renderType = this._getRenderType();
            if (renderType === RenderType.Visible || renderType === RenderType.Blink) {
                this._show();
            }
            else {
                this._hide();
            }
            if (renderType === RenderType.Blink) {
                this._blinkTimer = window.setInterval(function () { return _this._blink(); }, ViewCursors.BLINK_INTERVAL);
            }
        };
        // --- end blinking logic
        ViewCursors.prototype._updateDomClassName = function () {
            this._domNode.setClassName(this._getClassName());
        };
        ViewCursors.prototype._getClassName = function () {
            var result = editorBrowser_1.ClassNames.VIEW_CURSORS_LAYER;
            var extraClassName;
            switch (this._cursorStyle) {
                case editorCommon.TextEditorCursorStyle.Line:
                    extraClassName = 'cursor-line-style';
                    break;
                case editorCommon.TextEditorCursorStyle.Block:
                    extraClassName = 'cursor-block-style';
                    break;
                case editorCommon.TextEditorCursorStyle.Underline:
                    extraClassName = 'cursor-underline-style';
                    break;
                default:
                    extraClassName = 'cursor-line-style';
            }
            return result + ' ' + extraClassName;
        };
        ViewCursors.prototype._blink = function () {
            if (this._isVisible) {
                this._hide();
            }
            else {
                this._show();
            }
        };
        ViewCursors.prototype._show = function () {
            this._primaryCursor.show();
            for (var i = 0, len = this._secondaryCursors.length; i < len; i++) {
                this._secondaryCursors[i].show();
            }
            this._isVisible = true;
        };
        ViewCursors.prototype._hide = function () {
            this._primaryCursor.hide();
            for (var i = 0, len = this._secondaryCursors.length; i < len; i++) {
                this._secondaryCursors[i].hide();
            }
            this._isVisible = false;
        };
        // ---- IViewPart implementation
        ViewCursors.prototype.prepareRender = function (ctx) {
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
            this._primaryCursor.prepareRender(ctx);
            for (var i = 0, len = this._secondaryCursors.length; i < len; i++) {
                this._secondaryCursors[i].prepareRender(ctx);
            }
        };
        ViewCursors.prototype.render = function (ctx) {
            this._primaryCursor.render(ctx);
            for (var i = 0, len = this._secondaryCursors.length; i < len; i++) {
                this._secondaryCursors[i].render(ctx);
            }
            if (this._canUseTranslate3d) {
                this._domNode.setTransform('translate3d(0px, 0px, 0px)');
            }
            else {
                this._domNode.setTransform('');
            }
        };
        ViewCursors.BLINK_INTERVAL = 500;
        return ViewCursors;
    }(viewPart_1.ViewPart));
    exports.ViewCursors = ViewCursors;
});

define(__m[157], __M([0,1,65,77,33,317,14]), function (require, exports, filters_1, configurationRegistry_1, platform_1, nls_1, async_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var TextualSuggestSupport = (function () {
        function TextualSuggestSupport(editorWorkerService, configurationService) {
            this._editorWorkerService = editorWorkerService;
            this._configurationService = configurationService;
        }
        Object.defineProperty(TextualSuggestSupport.prototype, "triggerCharacters", {
            /* tslint:enable */
            get: function () {
                return [];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextualSuggestSupport.prototype, "shouldAutotriggerSuggest", {
            get: function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TextualSuggestSupport.prototype, "filter", {
            get: function () {
                return filters_1.matchesStrictPrefix;
            },
            enumerable: true,
            configurable: true
        });
        TextualSuggestSupport.prototype.provideCompletionItems = function (model, position, token) {
            var config = this._configurationService.getConfiguration('editor');
            if (!config || config.wordBasedSuggestions) {
                return async_1.wireCancellationToken(token, this._editorWorkerService.textualSuggest(model.uri, position));
            }
            return [];
        };
        /* tslint:disable */
        TextualSuggestSupport._c = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).registerConfiguration({
            type: 'object',
            order: 5.1,
            properties: {
                'editor.wordBasedSuggestions': {
                    'type': 'boolean',
                    'description': nls_1.localize(0, null),
                    'default': true
                }
            }
        });
        return TextualSuggestSupport;
    }());
    exports.TextualSuggestSupport = TextualSuggestSupport;
    function filterSuggestions(value) {
        if (!value) {
            return;
        }
        // filter suggestions
        var accept = filters_1.fuzzyContiguousFilter, result = [];
        result.push({
            currentWord: value.currentWord,
            suggestions: value.suggestions.filter(function (element) { return !!accept(value.currentWord, element.label); }),
            incomplete: value.incomplete
        });
        return result;
    }
    exports.filterSuggestions = filterSuggestions;
});















define(__m[158], __M([0,1,23,2,68,15,57,17,157,52,76]), function (require, exports, eventEmitter_1, winjs_base_1, descriptors_1, instantiation_1, configuration_1, modes, suggestSupport_1, editorWorkerService_1, wordHelper) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function createWordRegExp(allowInWords) {
        if (allowInWords === void 0) { allowInWords = ''; }
        return wordHelper.createWordRegExp(allowInWords);
    }
    exports.createWordRegExp = createWordRegExp;
    var ModeWorkerManager = (function () {
        function ModeWorkerManager(descriptor, workerModuleId, workerClassName, superWorkerModuleId, instantiationService) {
            this._descriptor = descriptor;
            this._workerDescriptor = descriptors_1.createAsyncDescriptor1(workerModuleId, workerClassName);
            this._superWorkerModuleId = superWorkerModuleId;
            this._instantiationService = instantiationService;
            this._workerPiecePromise = null;
        }
        ModeWorkerManager.prototype.worker = function (runner) {
            return this._getOrCreateWorker().then(runner);
        };
        ModeWorkerManager.prototype._getOrCreateWorker = function () {
            var _this = this;
            if (!this._workerPiecePromise) {
                // TODO@Alex: workaround for missing `bundles` config
                // First, load the code of the worker super class
                var superWorkerCodePromise = (this._superWorkerModuleId ? ModeWorkerManager._loadModule(this._superWorkerModuleId) : winjs_base_1.TPromise.as(null));
                this._workerPiecePromise = superWorkerCodePromise.then(function () {
                    // Second, load the code of the worker (without instantiating it)
                    return ModeWorkerManager._loadModule(_this._workerDescriptor.moduleName);
                }).then(function () {
                    // Finally, create the mode worker instance
                    return _this._instantiationService.createInstance(_this._workerDescriptor, _this._descriptor.id);
                });
            }
            return this._workerPiecePromise;
        };
        ModeWorkerManager._loadModule = function (moduleName) {
            return new winjs_base_1.TPromise(function (c, e, p) {
                // Use the global require to be sure to get the global config
                self.require([moduleName], c, e);
            }, function () {
                // Cannot cancel loading code
            });
        };
        return ModeWorkerManager;
    }());
    exports.ModeWorkerManager = ModeWorkerManager;
    var AbstractMode = (function () {
        function AbstractMode(modeId) {
            this._modeId = modeId;
            this._eventEmitter = new eventEmitter_1.EventEmitter();
            this._simplifiedMode = null;
        }
        AbstractMode.prototype.getId = function () {
            return this._modeId;
        };
        AbstractMode.prototype.toSimplifiedMode = function () {
            if (!this._simplifiedMode) {
                this._simplifiedMode = new SimplifiedMode(this);
            }
            return this._simplifiedMode;
        };
        AbstractMode.prototype.addSupportChangedListener = function (callback) {
            return this._eventEmitter.addListener2('modeSupportChanged', callback);
        };
        AbstractMode.prototype.setTokenizationSupport = function (callback) {
            var _this = this;
            var supportImpl = callback(this);
            this['tokenizationSupport'] = supportImpl;
            this._eventEmitter.emit('modeSupportChanged', _createModeSupportChangedEvent());
            return {
                dispose: function () {
                    if (_this['tokenizationSupport'] === supportImpl) {
                        delete _this['tokenizationSupport'];
                        _this._eventEmitter.emit('modeSupportChanged', _createModeSupportChangedEvent());
                    }
                }
            };
        };
        return AbstractMode;
    }());
    exports.AbstractMode = AbstractMode;
    var CompatMode = (function (_super) {
        __extends(CompatMode, _super);
        function CompatMode(modeId, compatWorkerService) {
            _super.call(this, modeId);
            this.compatWorkerService = compatWorkerService;
            if (this.compatWorkerService) {
                this.compatWorkerService.registerCompatMode(this);
            }
        }
        return CompatMode;
    }(AbstractMode));
    exports.CompatMode = CompatMode;
    var SimplifiedMode = (function () {
        function SimplifiedMode(sourceMode) {
            var _this = this;
            this._sourceMode = sourceMode;
            this._eventEmitter = new eventEmitter_1.EventEmitter();
            this._id = 'vs.editor.modes.simplifiedMode:' + sourceMode.getId();
            this._assignSupports();
            if (this._sourceMode.addSupportChangedListener) {
                this._sourceMode.addSupportChangedListener(function (e) {
                    _this._assignSupports();
                    _this._eventEmitter.emit('modeSupportChanged', e);
                });
            }
        }
        SimplifiedMode.prototype.getId = function () {
            return this._id;
        };
        SimplifiedMode.prototype.toSimplifiedMode = function () {
            return this;
        };
        SimplifiedMode.prototype._assignSupports = function () {
            this.tokenizationSupport = this._sourceMode.tokenizationSupport;
        };
        return SimplifiedMode;
    }());
    exports.isDigit = (function () {
        var _0 = '0'.charCodeAt(0), _1 = '1'.charCodeAt(0), _2 = '2'.charCodeAt(0), _3 = '3'.charCodeAt(0), _4 = '4'.charCodeAt(0), _5 = '5'.charCodeAt(0), _6 = '6'.charCodeAt(0), _7 = '7'.charCodeAt(0), _8 = '8'.charCodeAt(0), _9 = '9'.charCodeAt(0), _a = 'a'.charCodeAt(0), _b = 'b'.charCodeAt(0), _c = 'c'.charCodeAt(0), _d = 'd'.charCodeAt(0), _e = 'e'.charCodeAt(0), _f = 'f'.charCodeAt(0), _A = 'A'.charCodeAt(0), _B = 'B'.charCodeAt(0), _C = 'C'.charCodeAt(0), _D = 'D'.charCodeAt(0), _E = 'E'.charCodeAt(0), _F = 'F'.charCodeAt(0);
        return function isDigit(character, base) {
            var c = character.charCodeAt(0);
            switch (base) {
                case 1:
                    return c === _0;
                case 2:
                    return c >= _0 && c <= _1;
                case 3:
                    return c >= _0 && c <= _2;
                case 4:
                    return c >= _0 && c <= _3;
                case 5:
                    return c >= _0 && c <= _4;
                case 6:
                    return c >= _0 && c <= _5;
                case 7:
                    return c >= _0 && c <= _6;
                case 8:
                    return c >= _0 && c <= _7;
                case 9:
                    return c >= _0 && c <= _8;
                case 10:
                    return c >= _0 && c <= _9;
                case 11:
                    return (c >= _0 && c <= _9) || (c === _a) || (c === _A);
                case 12:
                    return (c >= _0 && c <= _9) || (c >= _a && c <= _b) || (c >= _A && c <= _B);
                case 13:
                    return (c >= _0 && c <= _9) || (c >= _a && c <= _c) || (c >= _A && c <= _C);
                case 14:
                    return (c >= _0 && c <= _9) || (c >= _a && c <= _d) || (c >= _A && c <= _D);
                case 15:
                    return (c >= _0 && c <= _9) || (c >= _a && c <= _e) || (c >= _A && c <= _E);
                default:
                    return (c >= _0 && c <= _9) || (c >= _a && c <= _f) || (c >= _A && c <= _F);
            }
        };
    })();
    var FrankensteinMode = (function (_super) {
        __extends(FrankensteinMode, _super);
        function FrankensteinMode(descriptor, configurationService, editorWorkerService) {
            _super.call(this, descriptor.id);
            if (editorWorkerService) {
                modes.SuggestRegistry.register(this.getId(), new suggestSupport_1.TextualSuggestSupport(editorWorkerService, configurationService), true);
            }
        }
        FrankensteinMode = __decorate([
            __param(1, configuration_1.IConfigurationService),
            __param(2, instantiation_1.optional(editorWorkerService_1.IEditorWorkerService))
        ], FrankensteinMode);
        return FrankensteinMode;
    }(AbstractMode));
    exports.FrankensteinMode = FrankensteinMode;
    function _createModeSupportChangedEvent() {
        return {
            tokenizationSupport: true
        };
    }
});















define(__m[431], __M([0,1,319,8,16,3,31,38,2,144,68,84,86,15,158,45,411,72,57,114,49]), function (require, exports, nls, errors_1, event_1, lifecycle_1, objects, paths, winjs_base_1, mime, descriptors_1, extensions_1, extensionsRegistry_1, instantiation_1, abstractMode_1, modesRegistry_1, languagesRegistry_1, modeService_1, configuration_1, abstractState_1, supports_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var languagesExtPoint = extensionsRegistry_1.ExtensionsRegistry.registerExtensionPoint('languages', {
        description: nls.localize(0, null),
        type: 'array',
        defaultSnippets: [{ body: [{ id: '', aliases: [], extensions: [] }] }],
        items: {
            type: 'object',
            defaultSnippets: [{ body: { id: '', extensions: [] } }],
            properties: {
                id: {
                    description: nls.localize(1, null),
                    type: 'string'
                },
                aliases: {
                    description: nls.localize(2, null),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                extensions: {
                    description: nls.localize(3, null),
                    default: ['.foo'],
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                filenames: {
                    description: nls.localize(4, null),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                filenamePatterns: {
                    description: nls.localize(5, null),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                mimetypes: {
                    description: nls.localize(6, null),
                    type: 'array',
                    items: {
                        type: 'string'
                    }
                },
                firstLine: {
                    description: nls.localize(7, null),
                    type: 'string'
                },
                configuration: {
                    description: nls.localize(8, null),
                    type: 'string'
                }
            }
        }
    });
    function isUndefinedOrStringArray(value) {
        if (typeof value === 'undefined') {
            return true;
        }
        if (!Array.isArray(value)) {
            return false;
        }
        return value.every(function (item) { return typeof item === 'string'; });
    }
    function isValidLanguageExtensionPoint(value, collector) {
        if (!value) {
            collector.error(nls.localize(9, null, languagesExtPoint.name));
            return false;
        }
        if (typeof value.id !== 'string') {
            collector.error(nls.localize(10, null, 'id'));
            return false;
        }
        if (!isUndefinedOrStringArray(value.extensions)) {
            collector.error(nls.localize(11, null, 'extensions'));
            return false;
        }
        if (!isUndefinedOrStringArray(value.filenames)) {
            collector.error(nls.localize(12, null, 'filenames'));
            return false;
        }
        if (typeof value.firstLine !== 'undefined' && typeof value.firstLine !== 'string') {
            collector.error(nls.localize(13, null, 'firstLine'));
            return false;
        }
        if (typeof value.configuration !== 'undefined' && typeof value.configuration !== 'string') {
            collector.error(nls.localize(14, null, 'configuration'));
            return false;
        }
        if (!isUndefinedOrStringArray(value.aliases)) {
            collector.error(nls.localize(15, null, 'aliases'));
            return false;
        }
        if (!isUndefinedOrStringArray(value.mimetypes)) {
            collector.error(nls.localize(16, null, 'mimetypes'));
            return false;
        }
        return true;
    }
    var ModeServiceImpl = (function () {
        function ModeServiceImpl(instantiationService, extensionService) {
            var _this = this;
            this.serviceId = modeService_1.IModeService;
            this._onDidAddModes = new event_1.Emitter();
            this.onDidAddModes = this._onDidAddModes.event;
            this._onDidCreateMode = new event_1.Emitter();
            this.onDidCreateMode = this._onDidCreateMode.event;
            this._instantiationService = instantiationService;
            this._extensionService = extensionService;
            this._activationPromises = {};
            this._instantiatedModes = {};
            this._config = {};
            this._registry = new languagesRegistry_1.LanguagesRegistry();
            this._registry.onDidAddModes(function (modes) { return _this._onDidAddModes.fire(modes); });
        }
        ModeServiceImpl.prototype.getConfigurationForMode = function (modeId) {
            return this._config[modeId] || {};
        };
        ModeServiceImpl.prototype.configureMode = function (mimetype, options) {
            var modeId = this.getModeId(mimetype);
            if (modeId) {
                this.configureModeById(modeId, options);
            }
        };
        ModeServiceImpl.prototype.configureModeById = function (modeId, options) {
            var previousOptions = this._config[modeId] || {};
            var newOptions = objects.mixin(objects.clone(previousOptions), options);
            if (objects.equals(previousOptions, newOptions)) {
                // This configure call is a no-op
                return;
            }
            this._config[modeId] = newOptions;
            var mode = this.getMode(modeId);
            if (mode && mode.configSupport) {
                mode.configSupport.configure(this.getConfigurationForMode(modeId));
            }
        };
        ModeServiceImpl.prototype.configureAllModes = function (config) {
            var _this = this;
            if (!config) {
                return;
            }
            var modes = this._registry.getRegisteredModes();
            modes.forEach(function (modeIdentifier) {
                var configuration = config[modeIdentifier];
                _this.configureModeById(modeIdentifier, configuration);
            });
        };
        ModeServiceImpl.prototype.isRegisteredMode = function (mimetypeOrModeId) {
            return this._registry.isRegisteredMode(mimetypeOrModeId);
        };
        ModeServiceImpl.prototype.isCompatMode = function (modeId) {
            var compatModeData = this._registry.getCompatMode(modeId);
            return (compatModeData ? true : false);
        };
        ModeServiceImpl.prototype.getRegisteredModes = function () {
            return this._registry.getRegisteredModes();
        };
        ModeServiceImpl.prototype.getRegisteredLanguageNames = function () {
            return this._registry.getRegisteredLanguageNames();
        };
        ModeServiceImpl.prototype.getExtensions = function (alias) {
            return this._registry.getExtensions(alias);
        };
        ModeServiceImpl.prototype.getMimeForMode = function (modeId) {
            return this._registry.getMimeForMode(modeId);
        };
        ModeServiceImpl.prototype.getLanguageName = function (modeId) {
            return this._registry.getLanguageName(modeId);
        };
        ModeServiceImpl.prototype.getModeIdForLanguageName = function (alias) {
            return this._registry.getModeIdForLanguageNameLowercase(alias);
        };
        ModeServiceImpl.prototype.getModeId = function (commaSeparatedMimetypesOrCommaSeparatedIds) {
            var modeIds = this._registry.extractModeIds(commaSeparatedMimetypesOrCommaSeparatedIds);
            if (modeIds.length > 0) {
                return modeIds[0];
            }
            return null;
        };
        ModeServiceImpl.prototype.getConfigurationFiles = function (modeId) {
            return this._registry.getConfigurationFiles(modeId);
        };
        // --- instantiation
        ModeServiceImpl.prototype.lookup = function (commaSeparatedMimetypesOrCommaSeparatedIds) {
            var r = [];
            var modeIds = this._registry.extractModeIds(commaSeparatedMimetypesOrCommaSeparatedIds);
            for (var i = 0; i < modeIds.length; i++) {
                var modeId = modeIds[i];
                r.push({
                    modeId: modeId,
                    isInstantiated: this._instantiatedModes.hasOwnProperty(modeId)
                });
            }
            return r;
        };
        ModeServiceImpl.prototype.getMode = function (commaSeparatedMimetypesOrCommaSeparatedIds) {
            var modeIds = this._registry.extractModeIds(commaSeparatedMimetypesOrCommaSeparatedIds);
            var isPlainText = false;
            for (var i = 0; i < modeIds.length; i++) {
                if (this._instantiatedModes.hasOwnProperty(modeIds[i])) {
                    return this._instantiatedModes[modeIds[i]];
                }
                isPlainText = isPlainText || (modeIds[i] === 'plaintext');
            }
            if (isPlainText) {
                // Try to do it synchronously
                var r = null;
                this.getOrCreateMode(commaSeparatedMimetypesOrCommaSeparatedIds).then(function (mode) {
                    r = mode;
                }).done(null, errors_1.onUnexpectedError);
                return r;
            }
        };
        ModeServiceImpl.prototype.getModeIdByLanguageName = function (languageName) {
            var modeIds = this._registry.getModeIdsFromLanguageName(languageName);
            if (modeIds.length > 0) {
                return modeIds[0];
            }
            return null;
        };
        ModeServiceImpl.prototype.getModeIdByFilenameOrFirstLine = function (filename, firstLine) {
            var modeIds = this._registry.getModeIdsFromFilenameOrFirstLine(filename, firstLine);
            if (modeIds.length > 0) {
                return modeIds[0];
            }
            return null;
        };
        ModeServiceImpl.prototype.onReady = function () {
            return this._extensionService.onReady();
        };
        ModeServiceImpl.prototype.getOrCreateMode = function (commaSeparatedMimetypesOrCommaSeparatedIds) {
            var _this = this;
            return this.onReady().then(function () {
                var modeId = _this.getModeId(commaSeparatedMimetypesOrCommaSeparatedIds);
                // Fall back to plain text if no mode was found
                return _this._getOrCreateMode(modeId || 'plaintext');
            });
        };
        ModeServiceImpl.prototype.getOrCreateModeByLanguageName = function (languageName) {
            var _this = this;
            return this.onReady().then(function () {
                var modeId = _this.getModeIdByLanguageName(languageName);
                // Fall back to plain text if no mode was found
                return _this._getOrCreateMode(modeId || 'plaintext');
            });
        };
        ModeServiceImpl.prototype.getOrCreateModeByFilenameOrFirstLine = function (filename, firstLine) {
            var _this = this;
            return this.onReady().then(function () {
                var modeId = _this.getModeIdByFilenameOrFirstLine(filename, firstLine);
                // Fall back to plain text if no mode was found
                return _this._getOrCreateMode(modeId || 'plaintext');
            });
        };
        ModeServiceImpl.prototype._getOrCreateMode = function (modeId) {
            var _this = this;
            if (this._instantiatedModes.hasOwnProperty(modeId)) {
                return winjs_base_1.TPromise.as(this._instantiatedModes[modeId]);
            }
            if (this._activationPromises.hasOwnProperty(modeId)) {
                return this._activationPromises[modeId];
            }
            var c, e;
            var promise = new winjs_base_1.TPromise(function (cc, ee, pp) { c = cc; e = ee; });
            this._activationPromises[modeId] = promise;
            this._createMode(modeId).then(function (mode) {
                _this._instantiatedModes[modeId] = mode;
                delete _this._activationPromises[modeId];
                _this._onDidCreateMode.fire(mode);
                _this._extensionService.activateByEvent("onLanguage:" + modeId).done(null, errors_1.onUnexpectedError);
                return _this._instantiatedModes[modeId];
            }).then(c, e);
            return promise;
        };
        ModeServiceImpl.prototype._createMode = function (modeId) {
            var _this = this;
            var modeDescriptor = this._createModeDescriptor(modeId);
            var compatModeData = this._registry.getCompatMode(modeId);
            if (compatModeData) {
                // This is a compatibility mode
                var resolvedDeps = null;
                if (Array.isArray(compatModeData.deps)) {
                    resolvedDeps = winjs_base_1.TPromise.join(compatModeData.deps.map(function (dep) { return _this.getOrCreateMode(dep); }));
                }
                else {
                    resolvedDeps = winjs_base_1.TPromise.as(null);
                }
                return resolvedDeps.then(function (_) {
                    var compatModeAsyncDescriptor = descriptors_1.createAsyncDescriptor1(compatModeData.moduleId, compatModeData.ctorName);
                    return _this._instantiationService.createInstance(compatModeAsyncDescriptor, modeDescriptor).then(function (compatMode) {
                        if (compatMode.configSupport) {
                            compatMode.configSupport.configure(_this.getConfigurationForMode(modeId));
                        }
                        return compatMode;
                    });
                });
            }
            return winjs_base_1.TPromise.as(this._instantiationService.createInstance(abstractMode_1.FrankensteinMode, modeDescriptor));
        };
        ModeServiceImpl.prototype._createModeDescriptor = function (modeId) {
            return {
                id: modeId
            };
        };
        ModeServiceImpl.prototype._registerTokenizationSupport = function (mode, callback) {
            if (mode.setTokenizationSupport) {
                return mode.setTokenizationSupport(callback);
            }
            else {
                console.warn('Cannot register tokenizationSupport on mode ' + mode.getId() + ' because it does not support it.');
                return lifecycle_1.empty;
            }
        };
        ModeServiceImpl.prototype.registerModeSupport = function (modeId, callback) {
            var _this = this;
            if (this._instantiatedModes.hasOwnProperty(modeId)) {
                return this._registerTokenizationSupport(this._instantiatedModes[modeId], callback);
            }
            var cc;
            var promise = new winjs_base_1.TPromise(function (c, e) { cc = c; });
            var disposable = this.onDidCreateMode(function (mode) {
                if (mode.getId() !== modeId) {
                    return;
                }
                cc(_this._registerTokenizationSupport(mode, callback));
                disposable.dispose();
            });
            return {
                dispose: function () {
                    promise.done(function (disposable) { return disposable.dispose(); }, null);
                }
            };
        };
        ModeServiceImpl.prototype.registerTokenizationSupport = function (modeId, callback) {
            return this.registerModeSupport(modeId, callback);
        };
        ModeServiceImpl.prototype.registerTokenizationSupport2 = function (modeId, support) {
            return this.registerModeSupport(modeId, function (mode) {
                return new TokenizationSupport2Adapter(mode, support);
            });
        };
        return ModeServiceImpl;
    }());
    exports.ModeServiceImpl = ModeServiceImpl;
    var TokenizationState2Adapter = (function () {
        function TokenizationState2Adapter(mode, actual, stateData) {
            this._mode = mode;
            this._actual = actual;
            this._stateData = stateData;
        }
        Object.defineProperty(TokenizationState2Adapter.prototype, "actual", {
            get: function () { return this._actual; },
            enumerable: true,
            configurable: true
        });
        TokenizationState2Adapter.prototype.clone = function () {
            return new TokenizationState2Adapter(this._mode, this._actual.clone(), abstractState_1.AbstractState.safeClone(this._stateData));
        };
        TokenizationState2Adapter.prototype.equals = function (other) {
            if (other instanceof TokenizationState2Adapter) {
                if (!this._actual.equals(other._actual)) {
                    return false;
                }
                return abstractState_1.AbstractState.safeEquals(this._stateData, other._stateData);
            }
            return false;
        };
        TokenizationState2Adapter.prototype.getMode = function () {
            return this._mode;
        };
        TokenizationState2Adapter.prototype.tokenize = function (stream) {
            throw new Error('Unexpected tokenize call!');
        };
        TokenizationState2Adapter.prototype.getStateData = function () {
            return this._stateData;
        };
        TokenizationState2Adapter.prototype.setStateData = function (stateData) {
            this._stateData = stateData;
        };
        return TokenizationState2Adapter;
    }());
    exports.TokenizationState2Adapter = TokenizationState2Adapter;
    var TokenizationSupport2Adapter = (function () {
        function TokenizationSupport2Adapter(mode, actual) {
            this._mode = mode;
            this._actual = actual;
        }
        TokenizationSupport2Adapter.prototype.getInitialState = function () {
            return new TokenizationState2Adapter(this._mode, this._actual.getInitialState(), null);
        };
        TokenizationSupport2Adapter.prototype.tokenize = function (line, state, offsetDelta, stopAtOffset) {
            if (offsetDelta === void 0) { offsetDelta = 0; }
            if (state instanceof TokenizationState2Adapter) {
                var actualResult = this._actual.tokenize(line, state.actual);
                var tokens_1 = [];
                actualResult.tokens.forEach(function (t) {
                    if (typeof t.scopes === 'string') {
                        tokens_1.push(new supports_1.Token(t.startIndex + offsetDelta, t.scopes));
                    }
                    else if (Array.isArray(t.scopes) && t.scopes.length === 1) {
                        tokens_1.push(new supports_1.Token(t.startIndex + offsetDelta, t.scopes[0]));
                    }
                    else {
                        throw new Error('Only token scopes as strings or of precisely 1 length are supported at this time!');
                    }
                });
                return {
                    tokens: tokens_1,
                    actualStopOffset: offsetDelta + line.length,
                    endState: new TokenizationState2Adapter(state.getMode(), actualResult.endState, state.getStateData()),
                    modeTransitions: [{ startIndex: offsetDelta, mode: state.getMode() }],
                };
            }
            throw new Error('Unexpected state to tokenize with!');
        };
        return TokenizationSupport2Adapter;
    }());
    exports.TokenizationSupport2Adapter = TokenizationSupport2Adapter;
    var MainThreadModeServiceImpl = (function (_super) {
        __extends(MainThreadModeServiceImpl, _super);
        function MainThreadModeServiceImpl(instantiationService, extensionService, configurationService) {
            var _this = this;
            _super.call(this, instantiationService, extensionService);
            this._configurationService = configurationService;
            languagesExtPoint.setHandler(function (extensions) {
                var allValidLanguages = [];
                for (var i = 0, len = extensions.length; i < len; i++) {
                    var extension = extensions[i];
                    if (!Array.isArray(extension.value)) {
                        extension.collector.error(nls.localize(17, null, languagesExtPoint.name));
                        continue;
                    }
                    for (var j = 0, lenJ = extension.value.length; j < lenJ; j++) {
                        var ext = extension.value[j];
                        if (isValidLanguageExtensionPoint(ext, extension.collector)) {
                            var configuration = (ext.configuration ? paths.join(extension.description.extensionFolderPath, ext.configuration) : ext.configuration);
                            allValidLanguages.push({
                                id: ext.id,
                                extensions: ext.extensions,
                                filenames: ext.filenames,
                                filenamePatterns: ext.filenamePatterns,
                                firstLine: ext.firstLine,
                                aliases: ext.aliases,
                                mimetypes: ext.mimetypes,
                                configuration: configuration
                            });
                        }
                    }
                }
                modesRegistry_1.ModesRegistry.registerLanguages(allValidLanguages);
            });
            this._configurationService.onDidUpdateConfiguration(function (e) { return _this.onConfigurationChange(e.config); });
        }
        MainThreadModeServiceImpl.prototype.onReady = function () {
            var _this = this;
            if (!this._onReadyPromise) {
                var configuration_2 = this._configurationService.getConfiguration();
                this._onReadyPromise = this._extensionService.onReady().then(function () {
                    _this.onConfigurationChange(configuration_2);
                    return true;
                });
            }
            return this._onReadyPromise;
        };
        MainThreadModeServiceImpl.prototype.onConfigurationChange = function (configuration) {
            var _this = this;
            // Clear user configured mime associations
            mime.clearTextMimes(true /* user configured */);
            // Register based on settings
            if (configuration.files && configuration.files.associations) {
                Object.keys(configuration.files.associations).forEach(function (pattern) {
                    mime.registerTextMime({ mime: _this.getMimeForMode(configuration.files.associations[pattern]), filepattern: pattern, userConfigured: true });
                });
            }
        };
        MainThreadModeServiceImpl = __decorate([
            __param(0, instantiation_1.IInstantiationService),
            __param(1, extensions_1.IExtensionService),
            __param(2, configuration_1.IConfigurationService)
        ], MainThreadModeServiceImpl);
        return MainThreadModeServiceImpl;
    }(ModeServiceImpl));
    exports.MainThreadModeServiceImpl = MainThreadModeServiceImpl;
});

define(__m[432], __M([0,1,45,366,33,77]), function (require, exports, modesRegistry_1, nls, platform, ConfigurationRegistry) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    modesRegistry_1.ModesRegistry.registerCompatMode({
        id: 'html',
        extensions: ['.html', '.htm', '.shtml', '.xhtml', '.mdoc', '.jsp', '.asp', '.aspx', '.jshtm'],
        aliases: ['HTML', 'htm', 'html', 'xhtml'],
        mimetypes: ['text/html', 'text/x-jshtm', 'text/template', 'text/ng-template'],
        moduleId: 'vs/languages/html/common/html',
        ctorName: 'HTMLMode',
        deps: ['text/css', 'text/javascript']
    });
    var configurationRegistry = platform.Registry.as(ConfigurationRegistry.Extensions.Configuration);
    configurationRegistry.registerConfiguration({
        'id': 'html',
        'order': 20,
        'type': 'object',
        'title': nls.localize(0, null),
        'properties': {
            'html.format.wrapLineLength': {
                'type': 'integer',
                'default': 120,
                'description': nls.localize(1, null),
            },
            'html.format.unformatted': {
                'type': ['string', 'null'],
                'default': 'a, abbr, acronym, b, bdo, big, br, button, cite, code, dfn, em, i, img, input, kbd, label, map, object, q, samp, script, select, small, span, strong, sub, sup, textarea, tt, var',
                'description': nls.localize(2, null),
            },
            'html.format.indentInnerHtml': {
                'type': 'boolean',
                'default': false,
                'description': nls.localize(3, null),
            },
            'html.format.preserveNewLines': {
                'type': 'boolean',
                'default': true,
                'description': nls.localize(4, null),
            },
            'html.format.maxPreserveNewLines': {
                'type': ['number', 'null'],
                'default': null,
                'description': nls.localize(5, null),
            },
            'html.format.indentHandlebars': {
                'type': 'boolean',
                'default': false,
                'description': nls.localize(6, null),
            },
            'html.format.endWithNewline': {
                'type': 'boolean',
                'default': false,
                'description': nls.localize(7, null),
            },
            'html.format.extraLiners': {
                'type': ['string', 'null'],
                'default': 'head, body, /html',
                'description': nls.localize(8, null),
            },
        }
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[433], __M([0,1,416,432,418]), function (require, exports) {
    'use strict';
});

define(__m[434], __M([0,1,31,33,26,124,77]), function (require, exports, objects, platform, types, json, configurationRegistry) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.CONFIG_DEFAULT_NAME = 'settings';
    function setNode(root, key, value) {
        var segments = key.split('.');
        var last = segments.pop();
        var curr = root;
        segments.forEach(function (s) {
            var obj = curr[s];
            switch (typeof obj) {
                case 'undefined':
                    obj = curr[s] = Object.create(null);
                    break;
                case 'object':
                    break;
                default:
                    console.log('Conflicting configuration setting: ' + key + ' at ' + s + ' with ' + JSON.stringify(obj));
            }
            curr = obj;
        });
        curr[last] = value;
    }
    function newConfigFile(value) {
        try {
            var root = Object.create(null);
            var contents = json.parse(value) || {};
            for (var key in contents) {
                setNode(root, key, contents[key]);
            }
            return {
                contents: root
            };
        }
        catch (e) {
            return {
                contents: {},
                parseError: e
            };
        }
    }
    exports.newConfigFile = newConfigFile;
    function merge(base, add, overwrite) {
        Object.keys(add).forEach(function (key) {
            if (key in base) {
                if (types.isObject(base[key]) && types.isObject(add[key])) {
                    merge(base[key], add[key], overwrite);
                }
                else if (overwrite) {
                    base[key] = add[key];
                }
            }
            else {
                base[key] = add[key];
            }
        });
    }
    exports.merge = merge;
    function consolidate(configMap) {
        var finalConfig = Object.create(null);
        var parseErrors = [];
        var regexp = /\/(team\.)?([^\.]*)*\.json/;
        // For each config file in .vscode folder
        Object.keys(configMap).forEach(function (configFileName) {
            var config = objects.clone(configMap[configFileName]);
            var matches = regexp.exec(configFileName);
            if (!matches || !config) {
                return;
            }
            // If a file is team.foo.json, it indicates team settings, strip this away
            var isTeamSetting = !!matches[1];
            // Extract the config key from the file name (except for settings.json which is the default)
            var configElement = finalConfig;
            if (matches && matches[2] && matches[2] !== exports.CONFIG_DEFAULT_NAME) {
                // Use the name of the file as top level config section for all settings inside
                var configSection = matches[2];
                var element = configElement[configSection];
                if (!element) {
                    element = Object.create(null);
                    configElement[configSection] = element;
                }
                configElement = element;
            }
            merge(configElement, config.contents, !isTeamSetting /* user settings overrule team settings */);
            if (config.parseError) {
                parseErrors.push(configFileName);
            }
        });
        return {
            contents: finalConfig,
            parseErrors: parseErrors
        };
    }
    exports.consolidate = consolidate;
    // defaults...
    function processDefaultValues(withConfig) {
        var configurations = platform.Registry.as(configurationRegistry.Extensions.Configuration).getConfigurations();
        var visit = function (config, level) {
            var handled = withConfig(config, level === 0);
            if (Array.isArray(config.allOf)) {
                config.allOf.forEach(function (c) {
                    // if the config node only contains an `allOf` we treat the `allOf` children as if they were at the top level
                    visit(c, (!handled && level === 0) ? level : level + 1);
                });
            }
        };
        configurations.sort(function (c1, c2) {
            if (typeof c1.order !== 'number') {
                return 1;
            }
            if (typeof c2.order !== 'number') {
                return -1;
            }
            return c1.order - c2.order;
        }).forEach(function (config) {
            visit(config, 0);
        });
    }
    function getDefaultValues() {
        var ret = Object.create(null);
        var handleConfig = function (config, isTop) {
            if (config.properties) {
                Object.keys(config.properties).forEach(function (key) {
                    var prop = config.properties[key];
                    var value = prop.default;
                    if (types.isUndefined(prop.default)) {
                        value = getDefaultValue(prop.type);
                    }
                    setNode(ret, key, value);
                });
                return true;
            }
            return false;
        };
        processDefaultValues(handleConfig);
        return ret;
    }
    exports.getDefaultValues = getDefaultValues;
    function getDefaultValuesContent(indent) {
        var lastEntry = -1;
        var result = [];
        result.push('{');
        var handleConfig = function (config, isTop) {
            var handled = false;
            if (config.title) {
                handled = true;
                if (isTop) {
                    result.push('');
                    result.push('//-------- ' + config.title + ' --------');
                }
                else {
                    result.push(indent + '// ' + config.title);
                }
                result.push('');
            }
            if (config.properties) {
                handled = true;
                Object.keys(config.properties).forEach(function (key) {
                    var prop = config.properties[key];
                    var defaultValue = prop.default;
                    if (types.isUndefined(defaultValue)) {
                        defaultValue = getDefaultValue(prop.type);
                    }
                    if (prop.description) {
                        result.push(indent + '// ' + prop.description);
                    }
                    var valueString = JSON.stringify(defaultValue, null, indent);
                    if (valueString && (typeof defaultValue === 'object')) {
                        valueString = addIndent(valueString, indent);
                    }
                    if (lastEntry !== -1) {
                        result[lastEntry] += ',';
                    }
                    lastEntry = result.length;
                    result.push(indent + JSON.stringify(key) + ': ' + valueString);
                    result.push('');
                });
            }
            return handled;
        };
        processDefaultValues(handleConfig);
        result.push('}');
        return result.join('\n');
    }
    exports.getDefaultValuesContent = getDefaultValuesContent;
    function addIndent(str, indent) {
        return str.split('\n').join('\n' + indent);
    }
    function getDefaultValue(type) {
        var t = Array.isArray(type) ? type[0] : type;
        switch (t) {
            case 'boolean':
                return false;
            case 'integer':
                return 0;
            case 'string':
                return '';
            case 'array':
                return [];
            case 'object':
                return {};
            default:
                return null;
        }
    }
});

define(__m[435], __M([0,1,38,2,31,8,434,14,48,57,139,77,33,16]), function (require, exports, paths, winjs_base_1, objects, errors, model, async_1, collections, configuration_1, files_1, configurationRegistry_1, platform_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ConfigurationService = (function () {
        function ConfigurationService(contextService, eventService, workspaceSettingsRootFolder) {
            if (workspaceSettingsRootFolder === void 0) { workspaceSettingsRootFolder = '.vscode'; }
            this.serviceId = configuration_1.IConfigurationService;
            this._onDidUpdateConfiguration = new event_1.Emitter();
            this.contextService = contextService;
            this.eventService = eventService;
            this.workspaceSettingsRootFolder = workspaceSettingsRootFolder;
            this.workspaceFilePathToConfiguration = Object.create(null);
            this.cachedConfig = {
                config: {}
            };
            this.registerListeners();
        }
        Object.defineProperty(ConfigurationService.prototype, "onDidUpdateConfiguration", {
            get: function () {
                return this._onDidUpdateConfiguration.event;
            },
            enumerable: true,
            configurable: true
        });
        ConfigurationService.prototype.registerListeners = function () {
            var _this = this;
            var unbind = this.eventService.addListener2(files_1.EventType.FILE_CHANGES, function (events) { return _this.handleFileEvents(events); });
            var subscription = platform_1.Registry.as(configurationRegistry_1.Extensions.Configuration).onDidRegisterConfiguration(function () { return _this.onDidRegisterConfiguration(); });
            this.callOnDispose = {
                dispose: function () {
                    unbind.dispose();
                    subscription.dispose();
                }
            };
        };
        ConfigurationService.prototype.initialize = function () {
            return this.doLoadConfiguration().then(function () { return null; });
        };
        ConfigurationService.prototype.getConfiguration = function (section) {
            var result = section ? this.cachedConfig.config[section] : this.cachedConfig.config;
            var parseErrors = this.cachedConfig.parseErrors;
            if (parseErrors && parseErrors.length > 0) {
                if (!result) {
                    result = {};
                }
                result.$parseErrors = parseErrors;
            }
            return result;
        };
        ConfigurationService.prototype.loadConfiguration = function (section) {
            // Reset caches to ensure we are hitting the disk
            this.bulkFetchFromWorkspacePromise = null;
            this.workspaceFilePathToConfiguration = Object.create(null);
            // Load configuration
            return this.doLoadConfiguration(section);
        };
        ConfigurationService.prototype.doLoadConfiguration = function (section) {
            var _this = this;
            // Load globals
            var globals = this.loadGlobalConfiguration();
            // Load workspace locals
            return this.loadWorkspaceConfiguration().then(function (values) {
                // Consolidate
                var consolidated = model.consolidate(values);
                // Override with workspace locals
                var merged = objects.mixin(objects.clone(globals.contents), // target: global/default values (but dont modify!)
                consolidated.contents, // source: workspace configured values
                true // overwrite
                );
                var parseErrors = [];
                if (consolidated.parseErrors) {
                    parseErrors = consolidated.parseErrors;
                }
                if (globals.parseErrors) {
                    parseErrors.push.apply(parseErrors, globals.parseErrors);
                }
                return {
                    config: merged,
                    parseErrors: parseErrors
                };
            }).then(function (res) {
                _this.cachedConfig = res;
                return _this.getConfiguration(section);
            });
        };
        ConfigurationService.prototype.loadGlobalConfiguration = function () {
            return {
                contents: model.getDefaultValues()
            };
        };
        ConfigurationService.prototype.hasWorkspaceConfiguration = function () {
            return !!this.workspaceFilePathToConfiguration['.vscode/' + model.CONFIG_DEFAULT_NAME + '.json'];
        };
        ConfigurationService.prototype.loadWorkspaceConfiguration = function (section) {
            var _this = this;
            // once: when invoked for the first time we fetch *all* json
            // files using the bulk stats and content routes
            if (!this.bulkFetchFromWorkspacePromise) {
                this.bulkFetchFromWorkspacePromise = this.resolveStat(this.contextService.toResource(this.workspaceSettingsRootFolder)).then(function (stat) {
                    if (!stat.isDirectory) {
                        return winjs_base_1.TPromise.as([]);
                    }
                    return _this.resolveContents(stat.children.filter(function (stat) { return paths.extname(stat.resource.fsPath) === '.json'; }).map(function (stat) { return stat.resource; }));
                }, function (err) {
                    if (err) {
                        return []; // never fail this call
                    }
                }).then(function (contents) {
                    contents.forEach(function (content) { return _this.workspaceFilePathToConfiguration[_this.contextService.toWorkspaceRelativePath(content.resource)] = winjs_base_1.TPromise.as(model.newConfigFile(content.value)); });
                }, errors.onUnexpectedError);
            }
            // on change: join on *all* configuration file promises so that
            // we can merge them into a single configuration object. this
            // happens whenever a config file changes, is deleted, or added
            return this.bulkFetchFromWorkspacePromise.then(function () {
                return winjs_base_1.TPromise.join(_this.workspaceFilePathToConfiguration);
            });
        };
        ConfigurationService.prototype.onDidRegisterConfiguration = function () {
            // a new configuration was registered (e.g. from an extension) and this means we do have a new set of
            // configuration defaults. since we already loaded the merged set of configuration (defaults < global < workspace),
            // we want to update the defaults with the new values. So we take our cached config and mix it into the new
            // defaults that we got, overwriting any value present.
            this.cachedConfig.config = objects.mixin(objects.clone(model.getDefaultValues()), this.cachedConfig.config, true /* overwrite */);
            // emit this as update to listeners
            this._onDidUpdateConfiguration.fire({ config: this.cachedConfig.config });
        };
        ConfigurationService.prototype.handleConfigurationChange = function () {
            var _this = this;
            if (!this.reloadConfigurationScheduler) {
                this.reloadConfigurationScheduler = new async_1.RunOnceScheduler(function () {
                    _this.doLoadConfiguration().then(function (config) { return _this._onDidUpdateConfiguration.fire({ config: config }); }).done(null, errors.onUnexpectedError);
                }, ConfigurationService.RELOAD_CONFIGURATION_DELAY);
            }
            if (!this.reloadConfigurationScheduler.isScheduled()) {
                this.reloadConfigurationScheduler.schedule();
            }
        };
        ConfigurationService.prototype.handleFileEvents = function (event) {
            var events = event.changes;
            var affectedByChanges = false;
            for (var i = 0, len = events.length; i < len; i++) {
                var workspacePath = this.contextService.toWorkspaceRelativePath(events[i].resource);
                if (!workspacePath) {
                    continue; // event is not inside workspace
                }
                // Handle case where ".vscode" got deleted
                if (workspacePath === this.workspaceSettingsRootFolder && events[i].type === files_1.FileChangeType.DELETED) {
                    this.workspaceFilePathToConfiguration = Object.create(null);
                    affectedByChanges = true;
                }
                // outside my folder or not a *.json file
                if (paths.extname(workspacePath) !== '.json' || !paths.isEqualOrParent(workspacePath, this.workspaceSettingsRootFolder)) {
                    continue;
                }
                // insert 'fetch-promises' for add and update events and
                // remove promises for delete events
                switch (events[i].type) {
                    case files_1.FileChangeType.DELETED:
                        affectedByChanges = collections.remove(this.workspaceFilePathToConfiguration, workspacePath);
                        break;
                    case files_1.FileChangeType.UPDATED:
                    case files_1.FileChangeType.ADDED:
                        this.workspaceFilePathToConfiguration[workspacePath] = this.resolveContent(events[i].resource).then(function (content) { return model.newConfigFile(content.value); }, errors.onUnexpectedError);
                        affectedByChanges = true;
                }
            }
            if (affectedByChanges) {
                this.handleConfigurationChange();
            }
        };
        ConfigurationService.prototype.dispose = function () {
            if (this.reloadConfigurationScheduler) {
                this.reloadConfigurationScheduler.dispose();
            }
            this.callOnDispose.dispose();
            this._onDidUpdateConfiguration.dispose();
        };
        ConfigurationService.RELOAD_CONFIGURATION_DELAY = 50;
        return ConfigurationService;
    }());
    exports.ConfigurationService = ConfigurationService;
});

define(__m[436], __M([0,1,369,32,2,84,86]), function (require, exports, nls, severity_1, winjs_base_1, extensions_1, extensionsRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var hasOwnProperty = Object.hasOwnProperty;
    var ActivatedExtension = (function () {
        function ActivatedExtension(activationFailed) {
            this.activationFailed = activationFailed;
        }
        return ActivatedExtension;
    }());
    exports.ActivatedExtension = ActivatedExtension;
    var AbstractExtensionService = (function () {
        function AbstractExtensionService(isReadyByDefault) {
            var _this = this;
            this.serviceId = extensions_1.IExtensionService;
            if (isReadyByDefault) {
                this._onReady = winjs_base_1.TPromise.as(true);
                this._onReadyC = function (v) { };
            }
            else {
                this._onReady = new winjs_base_1.TPromise(function (c, e, p) {
                    _this._onReadyC = c;
                }, function () {
                    console.warn('You should really not try to cancel this ready promise!');
                });
            }
            this._activatingExtensions = {};
            this._activatedExtensions = {};
        }
        AbstractExtensionService.prototype._triggerOnReady = function () {
            this._onReadyC(true);
        };
        AbstractExtensionService.prototype.onReady = function () {
            return this._onReady;
        };
        AbstractExtensionService.prototype.getExtensionsStatus = function () {
            return null;
        };
        AbstractExtensionService.prototype.isActivated = function (extensionId) {
            return hasOwnProperty.call(this._activatedExtensions, extensionId);
        };
        AbstractExtensionService.prototype.activateByEvent = function (activationEvent) {
            var _this = this;
            return this._onReady.then(function () {
                extensionsRegistry_1.ExtensionsRegistry.triggerActivationEventListeners(activationEvent);
                var activateExtensions = extensionsRegistry_1.ExtensionsRegistry.getExtensionDescriptionsForActivationEvent(activationEvent);
                return _this._activateExtensions(activateExtensions, 0);
            });
        };
        AbstractExtensionService.prototype.activateById = function (extensionId) {
            var _this = this;
            return this._onReady.then(function () {
                var desc = extensionsRegistry_1.ExtensionsRegistry.getExtensionDescription(extensionId);
                if (!desc) {
                    throw new Error('Extension `' + extensionId + '` is not known');
                }
                return _this._activateExtensions([desc], 0);
            });
        };
        /**
         * Handle semantics related to dependencies for `currentExtension`.
         * semantics: `redExtensions` must wait for `greenExtensions`.
         */
        AbstractExtensionService.prototype._handleActivateRequest = function (currentExtension, greenExtensions, redExtensions) {
            var depIds = (typeof currentExtension.extensionDependencies === 'undefined' ? [] : currentExtension.extensionDependencies);
            var currentExtensionGetsGreenLight = true;
            for (var j = 0, lenJ = depIds.length; j < lenJ; j++) {
                var depId = depIds[j];
                var depDesc = extensionsRegistry_1.ExtensionsRegistry.getExtensionDescription(depId);
                if (!depDesc) {
                    // Error condition 1: unknown dependency
                    this._showMessage(severity_1.default.Error, nls.localize(0, null, depId, currentExtension.id));
                    this._activatedExtensions[currentExtension.id] = this._createFailedExtension();
                    return;
                }
                if (hasOwnProperty.call(this._activatedExtensions, depId)) {
                    var dep = this._activatedExtensions[depId];
                    if (dep.activationFailed) {
                        // Error condition 2: a dependency has already failed activation
                        this._showMessage(severity_1.default.Error, nls.localize(1, null, depId, currentExtension.id));
                        this._activatedExtensions[currentExtension.id] = this._createFailedExtension();
                        return;
                    }
                }
                else {
                    // must first wait for the dependency to activate
                    currentExtensionGetsGreenLight = false;
                    greenExtensions[depId] = depDesc;
                }
            }
            if (currentExtensionGetsGreenLight) {
                greenExtensions[currentExtension.id] = currentExtension;
            }
            else {
                redExtensions.push(currentExtension);
            }
        };
        AbstractExtensionService.prototype._activateExtensions = function (extensionDescriptions, recursionLevel) {
            var _this = this;
            // console.log(recursionLevel, '_activateExtensions: ', extensionDescriptions.map(p => p.id));
            if (extensionDescriptions.length === 0) {
                return winjs_base_1.TPromise.as(void 0);
            }
            extensionDescriptions = extensionDescriptions.filter(function (p) { return !hasOwnProperty.call(_this._activatedExtensions, p.id); });
            if (extensionDescriptions.length === 0) {
                return winjs_base_1.TPromise.as(void 0);
            }
            if (recursionLevel > 10) {
                // More than 10 dependencies deep => most likely a dependency loop
                for (var i = 0, len = extensionDescriptions.length; i < len; i++) {
                    // Error condition 3: dependency loop
                    this._showMessage(severity_1.default.Error, nls.localize(2, null, extensionDescriptions[i].id));
                    this._activatedExtensions[extensionDescriptions[i].id] = this._createFailedExtension();
                }
                return winjs_base_1.TPromise.as(void 0);
            }
            var greenMap = Object.create(null), red = [];
            for (var i = 0, len = extensionDescriptions.length; i < len; i++) {
                this._handleActivateRequest(extensionDescriptions[i], greenMap, red);
            }
            // Make sure no red is also green
            for (var i = 0, len = red.length; i < len; i++) {
                if (greenMap[red[i].id]) {
                    delete greenMap[red[i].id];
                }
            }
            var green = Object.keys(greenMap).map(function (id) { return greenMap[id]; });
            // console.log('greenExtensions: ', green.map(p => p.id));
            // console.log('redExtensions: ', red.map(p => p.id));
            if (red.length === 0) {
                // Finally reached only leafs!
                return winjs_base_1.TPromise.join(green.map(function (p) { return _this._activateExtension(p); })).then(function (_) { return void 0; });
            }
            return this._activateExtensions(green, recursionLevel + 1).then(function (_) {
                return _this._activateExtensions(red, recursionLevel + 1);
            });
        };
        AbstractExtensionService.prototype._activateExtension = function (extensionDescription) {
            var _this = this;
            if (hasOwnProperty.call(this._activatedExtensions, extensionDescription.id)) {
                return winjs_base_1.TPromise.as(void 0);
            }
            if (hasOwnProperty.call(this._activatingExtensions, extensionDescription.id)) {
                return this._activatingExtensions[extensionDescription.id];
            }
            this._activatingExtensions[extensionDescription.id] = this._actualActivateExtension(extensionDescription).then(null, function (err) {
                _this._showMessage(severity_1.default.Error, nls.localize(3, null, extensionDescription.id, err.message));
                console.error('Activating extension `' + extensionDescription.id + '` failed: ', err.message);
                console.log('Here is the error stack: ', err.stack);
                // Treat the extension as being empty
                return _this._createFailedExtension();
            }).then(function (x) {
                _this._activatedExtensions[extensionDescription.id] = x;
                delete _this._activatingExtensions[extensionDescription.id];
            });
            return this._activatingExtensions[extensionDescription.id];
        };
        return AbstractExtensionService;
    }());
    exports.AbstractExtensionService = AbstractExtensionService;
});

define(__m[51], __M([0,1,12,18,26,33]), function (require, exports, keyCodes_1, platform, types_1, platform_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var KeybindingsRegistryImpl = (function () {
        function KeybindingsRegistryImpl() {
            this.WEIGHT = {
                editorCore: function (importance) {
                    if (importance === void 0) { importance = 0; }
                    return 0 + importance;
                },
                editorContrib: function (importance) {
                    if (importance === void 0) { importance = 0; }
                    return 100 + importance;
                },
                workbenchContrib: function (importance) {
                    if (importance === void 0) { importance = 0; }
                    return 200 + importance;
                },
                builtinExtension: function (importance) {
                    if (importance === void 0) { importance = 0; }
                    return 300 + importance;
                },
                externalExtension: function (importance) {
                    if (importance === void 0) { importance = 0; }
                    return 400 + importance;
                }
            };
            this._keybindings = [];
            this._commands = Object.create(null);
        }
        /**
         * Take current platform into account and reduce to primary & secondary.
         */
        KeybindingsRegistryImpl.bindToCurrentPlatform = function (kb) {
            if (platform.isWindows) {
                if (kb && kb.win) {
                    return kb.win;
                }
            }
            else if (platform.isMacintosh) {
                if (kb && kb.mac) {
                    return kb.mac;
                }
            }
            else {
                if (kb && kb.linux) {
                    return kb.linux;
                }
            }
            return kb;
        };
        KeybindingsRegistryImpl.prototype.registerCommandRule = function (rule) {
            var _this = this;
            var actualKb = KeybindingsRegistryImpl.bindToCurrentPlatform(rule);
            // here
            if (actualKb && actualKb.primary) {
                this.registerDefaultKeybinding(actualKb.primary, rule.id, rule.weight, 0, rule.when);
            }
            // here
            if (actualKb && Array.isArray(actualKb.secondary)) {
                actualKb.secondary.forEach(function (k, i) { return _this.registerDefaultKeybinding(k, rule.id, rule.weight, -i - 1, rule.when); });
            }
        };
        KeybindingsRegistryImpl.prototype.registerCommandDesc = function (desc) {
            this.registerCommandRule(desc);
            // if (_commands[desc.id]) {
            // 	console.warn('Duplicate handler for command: ' + desc.id);
            // }
            // this._commands[desc.id] = desc.handler;
            var handler = desc.handler;
            var description = desc.description || handler.description;
            // add argument validation if rich command metadata is provided
            if (typeof description === 'object') {
                var constraints_1 = [];
                for (var _i = 0, _a = description.args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    constraints_1.push(arg.constraint);
                }
                handler = function (accesor) {
                    var args = [];
                    for (var _i = 1; _i < arguments.length; _i++) {
                        args[_i - 1] = arguments[_i];
                    }
                    types_1.validateConstraints(args, constraints_1);
                    return desc.handler.apply(desc, [accesor].concat(args));
                };
            }
            // make sure description is there
            handler.description = description;
            // register handler
            this._commands[desc.id] = handler;
        };
        KeybindingsRegistryImpl.prototype.getCommands = function () {
            return this._commands;
        };
        KeybindingsRegistryImpl.prototype.registerDefaultKeybinding = function (keybinding, commandId, weight1, weight2, when) {
            if (platform.isWindows) {
                if (keyCodes_1.BinaryKeybindings.hasCtrlCmd(keybinding) && !keyCodes_1.BinaryKeybindings.hasShift(keybinding) && keyCodes_1.BinaryKeybindings.hasAlt(keybinding) && !keyCodes_1.BinaryKeybindings.hasWinCtrl(keybinding)) {
                    if (/^[A-Z0-9\[\]\|\;\'\,\.\/\`]$/.test(keyCodes_1.KeyCode.toString(keyCodes_1.BinaryKeybindings.extractKeyCode(keybinding)))) {
                        console.warn('Ctrl+Alt+ keybindings should not be used by default under Windows. Offender: ', keybinding, ' for ', commandId);
                    }
                }
            }
            this._keybindings.push({
                keybinding: keybinding,
                command: commandId,
                when: when,
                weight1: weight1,
                weight2: weight2
            });
        };
        KeybindingsRegistryImpl.prototype.getDefaultKeybindings = function () {
            return this._keybindings;
        };
        return KeybindingsRegistryImpl;
    }());
    exports.KeybindingsRegistry = new KeybindingsRegistryImpl();
    // Define extension point ids
    exports.Extensions = {
        EditorModes: 'platform.keybindingsRegistry'
    };
    platform_1.Registry.add(exports.Extensions.EditorModes, exports.KeybindingsRegistry);
});

define(__m[90], __M([0,1,12,43,19,51,7,54]), function (require, exports, keyCodes_1, editor_1, keybindingService_1, keybindingsRegistry_1, editorCommon, codeEditorService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var H = editorCommon.Handler;
    function findFocusedEditor(commandId, accessor, complain) {
        var editor = accessor.get(codeEditorService_1.ICodeEditorService).getFocusedCodeEditor();
        if (!editor) {
            if (complain) {
                console.warn('Cannot execute ' + commandId + ' because no code editor is focused.');
            }
            return null;
        }
        return editor;
    }
    exports.findFocusedEditor = findFocusedEditor;
    function withCodeEditorFromCommandHandler(commandId, accessor, callback) {
        var editor = findFocusedEditor(commandId, accessor, true);
        if (editor) {
            callback(editor);
        }
    }
    exports.withCodeEditorFromCommandHandler = withCodeEditorFromCommandHandler;
    function getActiveEditor(accessor) {
        var editorService = accessor.get(editor_1.IEditorService);
        var activeEditor = editorService.getActiveEditor && editorService.getActiveEditor();
        if (activeEditor) {
            var editor = activeEditor.getControl();
            // Substitute for (editor instanceof ICodeEditor)
            if (editor && typeof editor.getEditorType === 'function') {
                var codeEditor = editor;
                return codeEditor;
            }
        }
        return null;
    }
    exports.getActiveEditor = getActiveEditor;
    function triggerEditorHandler(handlerId, accessor, args) {
        withCodeEditorFromCommandHandler(handlerId, accessor, function (editor) {
            editor.trigger('keyboard', handlerId, args);
        });
    }
    function registerCoreCommand(handlerId, kb, weight, when) {
        if (weight === void 0) { weight = keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorCore(); }
        var desc = {
            id: handlerId,
            handler: triggerEditorHandler.bind(null, handlerId),
            weight: weight,
            when: (when ? when : keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS)),
            primary: kb.primary,
            secondary: kb.secondary,
            win: kb.win,
            mac: kb.mac,
            linux: kb.linux
        };
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc(desc);
    }
    function registerCoreDispatchCommand2(handlerId) {
        var desc = {
            id: handlerId,
            handler: triggerEditorHandler.bind(null, handlerId),
            weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorCore(),
            when: null,
            primary: 0
        };
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc(desc);
        var desc2 = {
            id: 'default:' + handlerId,
            handler: function (accessor, args) {
                withCodeEditorFromCommandHandler(handlerId, accessor, function (editor) {
                    editor.trigger('keyboard', handlerId, args);
                });
            },
            weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorCore(),
            when: null,
            primary: 0
        };
        keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc(desc2);
    }
    registerCoreDispatchCommand2(H.Type);
    registerCoreDispatchCommand2(H.ReplacePreviousChar);
    registerCoreDispatchCommand2(H.Paste);
    registerCoreDispatchCommand2(H.Cut);
    function getMacWordNavigationKB(shift, key) {
        // For macs, word navigation is based on the alt modifier
        if (shift) {
            return keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | key;
        }
        else {
            return keyCodes_1.KeyMod.Alt | key;
        }
    }
    function getWordNavigationKB(shift, key) {
        // Normally word navigation is based on the ctrl modifier
        if (shift) {
            return keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | key;
        }
        else {
            return keyCodes_1.KeyMod.CtrlCmd | key;
        }
    }
    // https://support.apple.com/en-gb/HT201236
    // [ADDED] Control-H					Delete the character to the left of the insertion point. Or use Delete.
    // [ADDED] Control-D					Delete the character to the right of the insertion point. Or use Fn-Delete.
    // [ADDED] Control-K					Delete the text between the insertion point and the end of the line or paragraph.
    // [ADDED] CommandUp Arrow				Move the insertion point to the beginning of the document.
    // [ADDED] CommandDown Arrow			Move the insertion point to the end of the document.
    // [ADDED] CommandLeft Arrow			Move the insertion point to the beginning of the current line.
    // [ADDED] CommandRight Arrow			Move the insertion point to the end of the current line.
    // [ADDED] OptionLeft Arrow			Move the insertion point to the beginning of the previous word.
    // [ADDED] OptionRight Arrow			Move the insertion point to the end of the next word.
    // [ADDED] CommandShiftUp Arrow		Select the text between the insertion point and the beginning of the document.
    // [ADDED] CommandShiftDown Arrow		Select the text between the insertion point and the end of the document.
    // [ADDED] CommandShiftLeft Arrow		Select the text between the insertion point and the beginning of the current line.
    // [ADDED] CommandShiftRight Arrow	Select the text between the insertion point and the end of the current line.
    // [USED BY DUPLICATE LINES] ShiftOptionUp Arrow		Extend text selection to the beginning of the current paragraph, then to the beginning of the following paragraph if pressed again.
    // [USED BY DUPLICATE LINES] ShiftOptionDown Arrow	Extend text selection to the end of the current paragraph, then to the end of the following paragraph if pressed again.
    // [ADDED] ShiftOptionLeft Arrow		Extend text selection to the beginning of the current word, then to the beginning of the following word if pressed again.
    // [ADDED] ShiftOptionRight Arrow		Extend text selection to the end of the current word, then to the end of the following word if pressed again.
    // [ADDED] Control-A					Move to the beginning of the line or paragraph.
    // [ADDED] Control-E					Move to the end of a line or paragraph.
    // [ADDED] Control-F					Move one character forward.
    // [ADDED] Control-B					Move one character backward.
    //Control-L								Center the cursor or selection in the visible area.
    // [ADDED] Control-P					Move up one line.
    // [ADDED] Control-N					Move down one line.
    // [ADDED] Control-O					Insert a new line after the insertion point.
    //Control-T								Swap the character behind the insertion point with the character in front of the insertion point.
    // Unconfirmed????
    //	Config.addKeyBinding(editorCommon.Handler.CursorPageDown,		KeyMod.WinCtrl | KeyCode.KEY_V);
    // OS X built in commands
    // Control+y => yank
    // [ADDED] Command+backspace => Delete to Hard BOL
    // [ADDED] Command+delete => Delete to Hard EOL
    // [ADDED] Control+k => Delete to Hard EOL
    // Control+l => show_at_center
    // Control+Command+d => noop
    // Control+Command+shift+d => noop
    registerCoreCommand(H.CursorLeft, {
        primary: keyCodes_1.KeyCode.LeftArrow,
        mac: { primary: keyCodes_1.KeyCode.LeftArrow, secondary: [keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_B] }
    });
    registerCoreCommand(H.CursorLeftSelect, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.LeftArrow
    });
    registerCoreCommand(H.CursorRight, {
        primary: keyCodes_1.KeyCode.RightArrow,
        mac: { primary: keyCodes_1.KeyCode.RightArrow, secondary: [keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_F] }
    });
    registerCoreCommand(H.CursorRightSelect, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.RightArrow
    });
    registerCoreCommand(H.CursorUp, {
        primary: keyCodes_1.KeyCode.UpArrow,
        mac: { primary: keyCodes_1.KeyCode.UpArrow, secondary: [keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_P] }
    });
    registerCoreCommand(H.CursorUpSelect, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.UpArrow,
        secondary: [getWordNavigationKB(true, keyCodes_1.KeyCode.UpArrow)],
        mac: { primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.UpArrow },
        linux: { primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.UpArrow }
    });
    registerCoreCommand(H.CursorDown, {
        primary: keyCodes_1.KeyCode.DownArrow,
        mac: { primary: keyCodes_1.KeyCode.DownArrow, secondary: [keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_N] }
    });
    registerCoreCommand(H.CursorDownSelect, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.DownArrow,
        secondary: [getWordNavigationKB(true, keyCodes_1.KeyCode.DownArrow)],
        mac: { primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.DownArrow },
        linux: { primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.DownArrow }
    });
    registerCoreCommand(H.CursorPageUp, {
        primary: keyCodes_1.KeyCode.PageUp
    });
    registerCoreCommand(H.CursorPageUpSelect, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.PageUp
    });
    registerCoreCommand(H.CursorPageDown, {
        primary: keyCodes_1.KeyCode.PageDown
    });
    registerCoreCommand(H.CursorPageDownSelect, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.PageDown
    });
    registerCoreCommand(H.CursorHome, {
        primary: keyCodes_1.KeyCode.Home,
        mac: { primary: keyCodes_1.KeyCode.Home, secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.LeftArrow, keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_A] }
    });
    registerCoreCommand(H.CursorHomeSelect, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Home,
        mac: { primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Home, secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.LeftArrow] }
    });
    registerCoreCommand(H.CursorEnd, {
        primary: keyCodes_1.KeyCode.End,
        mac: { primary: keyCodes_1.KeyCode.End, secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.RightArrow, keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_E] }
    });
    registerCoreCommand(H.CursorEndSelect, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.End,
        mac: { primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.End, secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.RightArrow] }
    });
    registerCoreCommand(H.ExpandLineSelection, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_I
    });
    registerCoreCommand(H.ScrollLineUp, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.UpArrow,
        mac: { primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.PageUp }
    });
    registerCoreCommand(H.ScrollLineDown, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.DownArrow,
        mac: { primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.PageDown }
    });
    registerCoreCommand(H.ScrollPageUp, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.PageUp,
        win: { primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.PageUp },
        linux: { primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.PageUp }
    });
    registerCoreCommand(H.ScrollPageDown, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.PageDown,
        win: { primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.PageDown },
        linux: { primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.PageDown }
    });
    registerCoreCommand(H.CursorColumnSelectLeft, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.LeftArrow,
        linux: { primary: 0 }
    });
    registerCoreCommand(H.CursorColumnSelectRight, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.RightArrow,
        linux: { primary: 0 }
    });
    registerCoreCommand(H.CursorColumnSelectUp, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.UpArrow,
        linux: { primary: 0 }
    });
    registerCoreCommand(H.CursorColumnSelectPageUp, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.PageUp,
        linux: { primary: 0 }
    });
    registerCoreCommand(H.CursorColumnSelectDown, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.DownArrow,
        linux: { primary: 0 }
    });
    registerCoreCommand(H.CursorColumnSelectPageDown, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.PageDown,
        linux: { primary: 0 }
    });
    registerCoreCommand(H.Tab, {
        primary: keyCodes_1.KeyCode.Tab
    }, keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorCore(), keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.not(editorCommon.KEYBINDING_CONTEXT_EDITOR_TAB_MOVES_FOCUS)));
    registerCoreCommand(H.Outdent, {
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Tab
    }, keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorCore(), keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.not(editorCommon.KEYBINDING_CONTEXT_EDITOR_TAB_MOVES_FOCUS)));
    registerCoreCommand(H.DeleteLeft, {
        primary: keyCodes_1.KeyCode.Backspace,
        secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Backspace],
        mac: { primary: keyCodes_1.KeyCode.Backspace, secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Backspace, keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_H, keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.Backspace] }
    });
    registerCoreCommand(H.DeleteRight, {
        primary: keyCodes_1.KeyCode.Delete,
        mac: { primary: keyCodes_1.KeyCode.Delete, secondary: [keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_D, keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.Delete] }
    });
    registerCoreCommand(H.DeleteAllLeft, {
        primary: null,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.Backspace }
    });
    registerCoreCommand(H.DeleteAllRight, {
        primary: null,
        mac: { primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_K, secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.Delete] }
    });
    function registerWordCommand(handlerId, shift, key) {
        registerCoreCommand(handlerId, {
            primary: getWordNavigationKB(shift, key),
            mac: { primary: getMacWordNavigationKB(shift, key) }
        });
    }
    registerWordCommand(H.CursorWordStartLeft, false, keyCodes_1.KeyCode.LeftArrow);
    registerCoreCommand(H.CursorWordEndLeft, { primary: 0 });
    registerCoreCommand(H.CursorWordLeft, { primary: 0 });
    registerWordCommand(H.CursorWordStartLeftSelect, true, keyCodes_1.KeyCode.LeftArrow);
    registerCoreCommand(H.CursorWordEndLeftSelect, { primary: 0 });
    registerCoreCommand(H.CursorWordLeftSelect, { primary: 0 });
    registerWordCommand(H.CursorWordEndRight, false, keyCodes_1.KeyCode.RightArrow);
    registerCoreCommand(H.CursorWordStartRight, { primary: 0 });
    registerCoreCommand(H.CursorWordRight, { primary: 0 });
    registerWordCommand(H.CursorWordEndRightSelect, true, keyCodes_1.KeyCode.RightArrow);
    registerCoreCommand(H.CursorWordStartRightSelect, { primary: 0 });
    registerCoreCommand(H.CursorWordRightSelect, { primary: 0 });
    registerWordCommand(H.DeleteWordLeft, false, keyCodes_1.KeyCode.Backspace);
    registerCoreCommand(H.DeleteWordStartLeft, { primary: 0 });
    registerCoreCommand(H.DeleteWordEndLeft, { primary: 0 });
    registerWordCommand(H.DeleteWordRight, false, keyCodes_1.KeyCode.Delete);
    registerCoreCommand(H.DeleteWordStartRight, { primary: 0 });
    registerCoreCommand(H.DeleteWordEndRight, { primary: 0 });
    registerCoreCommand(H.CancelSelection, {
        primary: keyCodes_1.KeyCode.Escape,
        secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape]
    }, keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorCore(), keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_HAS_NON_EMPTY_SELECTION)));
    registerCoreCommand(H.RemoveSecondaryCursors, {
        primary: keyCodes_1.KeyCode.Escape,
        secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape]
    }, keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorCore(1), keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_HAS_MULTIPLE_SELECTIONS)));
    registerCoreCommand(H.CursorTop, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.Home,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.UpArrow }
    });
    registerCoreCommand(H.CursorTopSelect, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Home,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.UpArrow }
    });
    registerCoreCommand(H.CursorBottom, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.End,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.DownArrow }
    });
    registerCoreCommand(H.CursorBottomSelect, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.End,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.DownArrow }
    });
    registerCoreCommand(H.LineBreakInsert, {
        primary: null,
        mac: { primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_O }
    });
    registerCoreCommand(H.Undo, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_Z
    });
    registerCoreCommand(H.CursorUndo, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_U
    });
    registerCoreCommand(H.Redo, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_Y,
        secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_Z],
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_Z }
    });
    function selectAll(accessor, args) {
        var HANDLER = editorCommon.Handler.SelectAll;
        var focusedEditor = findFocusedEditor(HANDLER, accessor, false);
        // Only if editor text focus (i.e. not if editor has widget focus).
        if (focusedEditor && focusedEditor.isFocused()) {
            focusedEditor.trigger('keyboard', HANDLER, args);
            return;
        }
        // Ignore this action when user is focussed on an element that allows for entering text
        var activeElement = document.activeElement;
        if (activeElement && ['input', 'textarea'].indexOf(activeElement.tagName.toLowerCase()) >= 0) {
            activeElement.select();
            return;
        }
        // Redirecting to last active editor
        var activeEditor = getActiveEditor(accessor);
        if (activeEditor) {
            activeEditor.trigger('keyboard', HANDLER, args);
            return;
        }
    }
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: 'editor.action.selectAll',
        handler: selectAll,
        weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorCore(),
        when: null,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_A
    });
});






define(__m[161], __M([0,1,372,12,3,32,37,2,11,56,101,19,51,16,246]), function (require, exports, nls, keyCodes_1, lifecycle_1, severity_1, arrays_1, winjs_base_1, dom, keyboardEvent_1, keybindingResolver_1, keybindingService_1, keybindingsRegistry_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var KEYBINDING_CONTEXT_ATTR = 'data-keybinding-context';
    var KeybindingContext = (function () {
        function KeybindingContext(id, parent) {
            this._id = id;
            this._parent = parent;
            this._value = Object.create(null);
            this._value['_contextId'] = id;
        }
        KeybindingContext.prototype.setValue = function (key, value) {
            // console.log('SET ' + key + ' = ' + value + ' ON ' + this._id);
            if (this._value[key] !== value) {
                this._value[key] = value;
                return true;
            }
        };
        KeybindingContext.prototype.removeValue = function (key) {
            // console.log('REMOVE ' + key + ' FROM ' + this._id);
            return delete this._value[key];
        };
        KeybindingContext.prototype.getValue = function (key) {
            var ret = this._value[key];
            if (typeof ret === 'undefined' && this._parent) {
                return this._parent.getValue(key);
            }
            return ret;
        };
        KeybindingContext.prototype.fillInContext = function (bucket) {
            if (this._parent) {
                this._parent.fillInContext(bucket);
            }
            for (var key in this._value) {
                bucket[key] = this._value[key];
            }
        };
        return KeybindingContext;
    }());
    exports.KeybindingContext = KeybindingContext;
    var ConfigAwareKeybindingContext = (function (_super) {
        __extends(ConfigAwareKeybindingContext, _super);
        function ConfigAwareKeybindingContext(id, configurationService, emitter) {
            var _this = this;
            _super.call(this, id, null);
            this._emitter = emitter;
            this._subscription = configurationService.onDidUpdateConfiguration(function (e) { return _this._updateConfigurationContext(e.config); });
            this._updateConfigurationContext(configurationService.getConfiguration());
        }
        ConfigAwareKeybindingContext.prototype.dispose = function () {
            this._subscription.dispose();
        };
        ConfigAwareKeybindingContext.prototype._updateConfigurationContext = function (config) {
            var _this = this;
            // remove old config.xyz values
            for (var key in this._value) {
                if (key.indexOf('config.') === 0) {
                    delete this._value[key];
                }
            }
            // add new value from config
            var walk = function (obj, keys) {
                for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) {
                        keys.push(key);
                        var value = obj[key];
                        if (typeof value === 'boolean') {
                            var configKey = keys.join('.');
                            _this._value[configKey] = value;
                            _this._emitter.fire(configKey);
                        }
                        else if (typeof value === 'object') {
                            walk(value, keys);
                        }
                        keys.pop();
                    }
                }
            };
            walk(config, ['config']);
        };
        return ConfigAwareKeybindingContext;
    }(KeybindingContext));
    var KeybindingContextKey = (function () {
        function KeybindingContextKey(parent, key, defaultValue) {
            this._parent = parent;
            this._key = key;
            this._defaultValue = defaultValue;
            if (typeof this._defaultValue !== 'undefined') {
                this._parent.setContext(this._key, this._defaultValue);
            }
        }
        KeybindingContextKey.prototype.set = function (value) {
            this._parent.setContext(this._key, value);
        };
        KeybindingContextKey.prototype.reset = function () {
            if (typeof this._defaultValue === 'undefined') {
                this._parent.removeContext(this._key);
            }
            else {
                this._parent.setContext(this._key, this._defaultValue);
            }
        };
        return KeybindingContextKey;
    }());
    var AbstractKeybindingService = (function () {
        function AbstractKeybindingService(myContextId) {
            this.serviceId = keybindingService_1.IKeybindingService;
            this._myContextId = myContextId;
            this._onDidChangeContextKey = new event_1.Emitter();
            this._instantiationService = null;
        }
        AbstractKeybindingService.prototype.createKey = function (key, defaultValue) {
            return new KeybindingContextKey(this, key, defaultValue);
        };
        Object.defineProperty(AbstractKeybindingService.prototype, "onDidChangeContext", {
            get: function () {
                if (!this._onDidChangeContext) {
                    this._onDidChangeContext = event_1.debounceEvent(this._onDidChangeContextKey.event, function (prev, cur) {
                        if (!prev) {
                            prev = [cur];
                        }
                        else if (prev.indexOf(cur) < 0) {
                            prev.push(cur);
                        }
                        return prev;
                    }, 25);
                }
                return this._onDidChangeContext;
            },
            enumerable: true,
            configurable: true
        });
        AbstractKeybindingService.prototype.setInstantiationService = function (instantiationService) {
            this._instantiationService = instantiationService;
        };
        AbstractKeybindingService.prototype.createScoped = function (domNode) {
            return new ScopedKeybindingService(this, this._onDidChangeContextKey, domNode);
        };
        AbstractKeybindingService.prototype.contextMatchesRules = function (rules) {
            var ctx = Object.create(null);
            this.getContext(this._myContextId).fillInContext(ctx);
            // console.log(JSON.stringify(ctx, null, '\t'));
            return keybindingResolver_1.KeybindingResolver.contextMatchesRules(ctx, rules);
        };
        AbstractKeybindingService.prototype.getContextValue = function (key) {
            return this.getContext(this._myContextId).getValue(key);
        };
        AbstractKeybindingService.prototype.setContext = function (key, value) {
            if (this.getContext(this._myContextId).setValue(key, value)) {
                this._onDidChangeContextKey.fire(key);
            }
        };
        AbstractKeybindingService.prototype.removeContext = function (key) {
            if (this.getContext(this._myContextId).removeValue(key)) {
                this._onDidChangeContextKey.fire(key);
            }
        };
        AbstractKeybindingService.prototype.hasCommand = function (commandId) {
            return !!keybindingsRegistry_1.KeybindingsRegistry.getCommands()[commandId];
        };
        return AbstractKeybindingService;
    }());
    exports.AbstractKeybindingService = AbstractKeybindingService;
    var KeybindingService = (function (_super) {
        __extends(KeybindingService, _super);
        function KeybindingService(configurationService, messageService, statusService) {
            _super.call(this, 0);
            this._toDispose = [];
            this._lastContextId = 0;
            this._contexts = Object.create(null);
            var myContext = new ConfigAwareKeybindingContext(this._myContextId, configurationService, this._onDidChangeContextKey);
            this._contexts[String(this._myContextId)] = myContext;
            this._toDispose.push(myContext);
            this._cachedResolver = null;
            this._firstTimeComputingResolver = true;
            this._currentChord = 0;
            this._currentChordStatusMessage = null;
            this._statusService = statusService;
            this._messageService = messageService;
        }
        KeybindingService.prototype._beginListening = function (domNode) {
            var _this = this;
            this._toDispose.push(dom.addDisposableListener(domNode, dom.EventType.KEY_DOWN, function (e) {
                var keyEvent = new keyboardEvent_1.StandardKeyboardEvent(e);
                _this._dispatch(keyEvent);
            }));
        };
        KeybindingService.prototype._getResolver = function () {
            if (!this._cachedResolver) {
                this._cachedResolver = new keybindingResolver_1.KeybindingResolver(keybindingsRegistry_1.KeybindingsRegistry.getDefaultKeybindings(), this._getExtraKeybindings(this._firstTimeComputingResolver));
                this._firstTimeComputingResolver = false;
            }
            return this._cachedResolver;
        };
        KeybindingService.prototype.dispose = function () {
            this._toDispose = lifecycle_1.dispose(this._toDispose);
        };
        KeybindingService.prototype.getLabelFor = function (keybinding) {
            return keybinding._toUSLabel();
        };
        KeybindingService.prototype.getHTMLLabelFor = function (keybinding) {
            return keybinding._toUSHTMLLabel();
        };
        KeybindingService.prototype.getAriaLabelFor = function (keybinding) {
            return keybinding._toUSAriaLabel();
        };
        KeybindingService.prototype.getElectronAcceleratorFor = function (keybinding) {
            return keybinding._toElectronAccelerator();
        };
        KeybindingService.prototype.updateResolver = function () {
            this._cachedResolver = null;
        };
        KeybindingService.prototype._getExtraKeybindings = function (isFirstTime) {
            return [];
        };
        KeybindingService.prototype.getDefaultKeybindings = function () {
            return this._getResolver().getDefaultKeybindings() + '\n\n' + this._getAllCommandsAsComment();
        };
        KeybindingService.prototype.customKeybindingsCount = function () {
            return 0;
        };
        KeybindingService.prototype.lookupKeybindings = function (commandId) {
            return this._getResolver().lookupKeybinding(commandId);
        };
        KeybindingService.prototype._getAllCommandsAsComment = function () {
            var commands = keybindingsRegistry_1.KeybindingsRegistry.getCommands();
            var unboundCommands = [];
            var boundCommands = this._getResolver().getDefaultBoundCommands();
            for (var id in commands) {
                if (id[0] === '_' || id.indexOf('vscode.') === 0) {
                    continue;
                }
                if (typeof commands[id].description === 'object'
                    && !arrays_1.isFalsyOrEmpty(commands[id].description.args)) {
                    continue;
                }
                if (boundCommands[id]) {
                    continue;
                }
                unboundCommands.push(id);
            }
            var pretty = unboundCommands.sort().join('\n// - ');
            return '// ' + nls.localize(0, null) + '\n// - ' + pretty;
        };
        KeybindingService.prototype._getCommandHandler = function (commandId) {
            return keybindingsRegistry_1.KeybindingsRegistry.getCommands()[commandId];
        };
        KeybindingService.prototype._dispatch = function (e) {
            var _this = this;
            var isModifierKey = (e.keyCode === keyCodes_1.KeyCode.Ctrl || e.keyCode === keyCodes_1.KeyCode.Shift || e.keyCode === keyCodes_1.KeyCode.Alt || e.keyCode === keyCodes_1.KeyCode.Meta);
            if (isModifierKey) {
                return;
            }
            var contextValue = Object.create(null);
            this.getContext(this._findContextAttr(e.target)).fillInContext(contextValue);
            // console.log(JSON.stringify(contextValue, null, '\t'));
            var resolveResult = this._getResolver().resolve(contextValue, this._currentChord, e.asKeybinding());
            if (resolveResult && resolveResult.enterChord) {
                e.preventDefault();
                this._currentChord = resolveResult.enterChord;
                if (this._statusService) {
                    var firstPartLabel = this.getLabelFor(new keyCodes_1.Keybinding(this._currentChord));
                    this._currentChordStatusMessage = this._statusService.setStatusMessage(nls.localize(1, null, firstPartLabel));
                }
                return;
            }
            if (this._statusService && this._currentChord) {
                if (!resolveResult || !resolveResult.commandId) {
                    var firstPartLabel = this.getLabelFor(new keyCodes_1.Keybinding(this._currentChord));
                    var chordPartLabel = this.getLabelFor(new keyCodes_1.Keybinding(e.asKeybinding()));
                    this._statusService.setStatusMessage(nls.localize(2, null, firstPartLabel, chordPartLabel), 10 * 1000 /* 10s */);
                    e.preventDefault();
                }
            }
            if (this._currentChordStatusMessage) {
                this._currentChordStatusMessage.dispose();
                this._currentChordStatusMessage = null;
            }
            this._currentChord = 0;
            if (resolveResult && resolveResult.commandId) {
                if (!/^\^/.test(resolveResult.commandId)) {
                    e.preventDefault();
                }
                var commandId = resolveResult.commandId.replace(/^\^/, '');
                this._invokeHandler(commandId, [{}]).done(undefined, function (err) {
                    _this._messageService.show(severity_1.default.Warning, err);
                });
            }
        };
        KeybindingService.prototype._invokeHandler = function (commandId, args) {
            var handler = this._getCommandHandler(commandId);
            if (!handler) {
                return winjs_base_1.TPromise.wrapError(new Error("No handler found for the command: '" + commandId + "'. An extension might be missing an activation event."));
            }
            try {
                var result = this._instantiationService.invokeFunction.apply(this._instantiationService, [handler].concat(args));
                return winjs_base_1.TPromise.as(result);
            }
            catch (err) {
                return winjs_base_1.TPromise.wrapError(err);
            }
        };
        KeybindingService.prototype._findContextAttr = function (domNode) {
            while (domNode) {
                if (domNode.hasAttribute(KEYBINDING_CONTEXT_ATTR)) {
                    return parseInt(domNode.getAttribute(KEYBINDING_CONTEXT_ATTR), 10);
                }
                domNode = domNode.parentElement;
            }
            return this._myContextId;
        };
        KeybindingService.prototype.getContext = function (contextId) {
            return this._contexts[String(contextId)];
        };
        KeybindingService.prototype.createChildContext = function (parentContextId) {
            if (parentContextId === void 0) { parentContextId = this._myContextId; }
            var id = (++this._lastContextId);
            this._contexts[String(id)] = new KeybindingContext(id, this.getContext(parentContextId));
            return id;
        };
        KeybindingService.prototype.disposeContext = function (contextId) {
            delete this._contexts[String(contextId)];
        };
        KeybindingService.prototype.executeCommand = function (commandId) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            return this._invokeHandler(commandId, args);
        };
        return KeybindingService;
    }(AbstractKeybindingService));
    exports.KeybindingService = KeybindingService;
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: keybindingService_1.SET_CONTEXT_COMMAND_ID,
        handler: function (accessor, contextKey, contextValue) {
            accessor.get(keybindingService_1.IKeybindingService).createKey(String(contextKey), contextValue);
        },
        weight: 0,
        primary: undefined,
        when: null
    });
    var ScopedKeybindingService = (function (_super) {
        __extends(ScopedKeybindingService, _super);
        function ScopedKeybindingService(parent, emitter, domNode) {
            _super.call(this, parent.createChildContext());
            this._parent = parent;
            this._onDidChangeContextKey = emitter;
            this._domNode = domNode;
            this._domNode.setAttribute(KEYBINDING_CONTEXT_ATTR, String(this._myContextId));
        }
        ScopedKeybindingService.prototype.dispose = function () {
            this._parent.disposeContext(this._myContextId);
            this._domNode.removeAttribute(KEYBINDING_CONTEXT_ATTR);
        };
        Object.defineProperty(ScopedKeybindingService.prototype, "onDidChangeContext", {
            get: function () {
                return this._parent.onDidChangeContext;
            },
            enumerable: true,
            configurable: true
        });
        ScopedKeybindingService.prototype.getLabelFor = function (keybinding) {
            return this._parent.getLabelFor(keybinding);
        };
        ScopedKeybindingService.prototype.getHTMLLabelFor = function (keybinding) {
            return this._parent.getHTMLLabelFor(keybinding);
        };
        ScopedKeybindingService.prototype.getAriaLabelFor = function (keybinding) {
            return this._parent.getAriaLabelFor(keybinding);
        };
        ScopedKeybindingService.prototype.getElectronAcceleratorFor = function (keybinding) {
            return this._parent.getElectronAcceleratorFor(keybinding);
        };
        ScopedKeybindingService.prototype.getDefaultKeybindings = function () {
            return this._parent.getDefaultKeybindings();
        };
        ScopedKeybindingService.prototype.customKeybindingsCount = function () {
            return this._parent.customKeybindingsCount();
        };
        ScopedKeybindingService.prototype.lookupKeybindings = function (commandId) {
            return this._parent.lookupKeybindings(commandId);
        };
        ScopedKeybindingService.prototype.getContext = function (contextId) {
            return this._parent.getContext(contextId);
        };
        ScopedKeybindingService.prototype.createChildContext = function (parentContextId) {
            if (parentContextId === void 0) { parentContextId = this._myContextId; }
            return this._parent.createChildContext(parentContextId);
        };
        ScopedKeybindingService.prototype.disposeContext = function (contextId) {
            this._parent.disposeContext(contextId);
        };
        ScopedKeybindingService.prototype.executeCommand = function (commandId, args) {
            return this._parent.executeCommand(commandId, args);
        };
        return ScopedKeybindingService;
    }(AbstractKeybindingService));
});

define(__m[115], __M([0,1,15]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IRequestService = instantiation_1.createDecorator('requestService');
});

define(__m[163], __M([0,1,15]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ID = 'storageService';
    exports.IStorageService = instantiation_1.createDecorator(exports.ID);
    (function (StorageScope) {
        /**
         * The stored data will be scoped to all workspaces of this domain.
         */
        StorageScope[StorageScope["GLOBAL"] = 0] = "GLOBAL";
        /**
         * The stored data will be scoped to the current workspace.
         */
        StorageScope[StorageScope["WORKSPACE"] = 1] = "WORKSPACE";
    })(exports.StorageScope || (exports.StorageScope = {}));
    var StorageScope = exports.StorageScope;
    exports.NullStorageService = {
        serviceId: undefined,
        store: function () { return undefined; },
        swap: function () { return undefined; },
        remove: function () { return undefined; },
        get: function (a, b, defaultValue) { return defaultValue; },
        getInteger: function (a, b, defaultValue) { return defaultValue; },
        getBoolean: function (a, b, defaultValue) { return defaultValue; },
    };
});

define(__m[36], __M([0,1,2,59,15]), function (require, exports, winjs_base_1, timer_1, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ITelemetryService = instantiation_1.createDecorator('telemetryService');
    exports.NullTelemetryService = {
        serviceId: undefined,
        timedPublicLog: function (name, data) { return timer_1.nullEvent; },
        publicLog: function (eventName, data) { return winjs_base_1.TPromise.as(null); },
        isOptedIn: true,
        getTelemetryInfo: function () {
            return winjs_base_1.TPromise.as({
                instanceId: 'someValue.instanceId',
                sessionId: 'someValue.sessionId',
                machineId: 'someValue.machineId'
            });
        }
    };
    function combinedAppender() {
        var appenders = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            appenders[_i - 0] = arguments[_i];
        }
        return { log: function (e, d) { return appenders.forEach(function (a) { return a.log(e, d); }); } };
    }
    exports.combinedAppender = combinedAppender;
    exports.NullAppender = { log: function () { return null; } };
    // --- util
    function anonymize(input) {
        if (!input) {
            return input;
        }
        var r = '';
        for (var i = 0; i < input.length; i++) {
            var ch = input[i];
            if (ch >= '0' && ch <= '9') {
                r += '0';
                continue;
            }
            if (ch >= 'a' && ch <= 'z') {
                r += 'a';
                continue;
            }
            if (ch >= 'A' && ch <= 'Z') {
                r += 'A';
                continue;
            }
            r += ch;
        }
        return r;
    }
    exports.anonymize = anonymize;
});

define(__m[13], __M([0,1,8,29,68,19,51,33,36,90,21,7,34]), function (require, exports, errors_1, uri_1, descriptors_1, keybindingService_1, keybindingsRegistry_1, platform_1, telemetry_1, config_1, position_1, editorCommon, modelService_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // --- Keybinding extensions to make it more concise to express keybindings conditions
    (function (ContextKey) {
        ContextKey[ContextKey["None"] = 0] = "None";
        ContextKey[ContextKey["EditorTextFocus"] = 1] = "EditorTextFocus";
        ContextKey[ContextKey["EditorFocus"] = 2] = "EditorFocus";
    })(exports.ContextKey || (exports.ContextKey = {}));
    var ContextKey = exports.ContextKey;
    // --- Editor Actions
    var EditorActionDescriptor = (function () {
        function EditorActionDescriptor(ctor, id, label, kbOpts, alias) {
            if (kbOpts === void 0) { kbOpts = defaultEditorActionKeybindingOptions; }
            this.ctor = ctor;
            this.id = id;
            this.label = label;
            this.alias = alias;
            this.kbOpts = kbOpts;
        }
        return EditorActionDescriptor;
    }());
    exports.EditorActionDescriptor = EditorActionDescriptor;
    var CommonEditorRegistry;
    (function (CommonEditorRegistry) {
        function registerEditorAction(desc) {
            platform_1.Registry.as(Extensions.EditorCommonContributions).registerEditorAction(desc);
        }
        CommonEditorRegistry.registerEditorAction = registerEditorAction;
        // --- Editor Contributions
        function registerEditorContribution(ctor) {
            platform_1.Registry.as(Extensions.EditorCommonContributions).registerEditorContribution2(ctor);
        }
        CommonEditorRegistry.registerEditorContribution = registerEditorContribution;
        function getEditorContributions() {
            return platform_1.Registry.as(Extensions.EditorCommonContributions).getEditorContributions2();
        }
        CommonEditorRegistry.getEditorContributions = getEditorContributions;
        // --- Editor Commands
        function commandWeight(importance) {
            if (importance === void 0) { importance = 0; }
            return keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorContrib(importance);
        }
        CommonEditorRegistry.commandWeight = commandWeight;
        function registerEditorCommand(commandId, weight, keybinding, needsTextFocus, needsKey, handler) {
            var commandDesc = {
                id: commandId,
                handler: createCommandHandler(commandId, handler),
                weight: weight,
                when: whenRule(needsTextFocus, needsKey),
                primary: keybinding.primary,
                secondary: keybinding.secondary,
                win: keybinding.win,
                linux: keybinding.linux,
                mac: keybinding.mac,
            };
            keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc(commandDesc);
        }
        CommonEditorRegistry.registerEditorCommand = registerEditorCommand;
        function registerLanguageCommand(id, handler) {
            keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
                id: id,
                handler: function (accessor, args) {
                    return handler(accessor, args || {});
                },
                weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorContrib(),
                primary: undefined,
                when: undefined,
            });
        }
        CommonEditorRegistry.registerLanguageCommand = registerLanguageCommand;
        function registerDefaultLanguageCommand(id, handler) {
            registerLanguageCommand(id, function (accessor, args) {
                var resource = args.resource, position = args.position;
                if (!(resource instanceof uri_1.default) || !position_1.Position.isIPosition(position)) {
                    throw errors_1.illegalArgument();
                }
                var model = accessor.get(modelService_1.IModelService).getModel(resource);
                if (!model) {
                    throw errors_1.illegalArgument();
                }
                var editorPosition = position_1.Position.lift(position);
                return handler(model, editorPosition, args);
            });
        }
        CommonEditorRegistry.registerDefaultLanguageCommand = registerDefaultLanguageCommand;
    })(CommonEditorRegistry = exports.CommonEditorRegistry || (exports.CommonEditorRegistry = {}));
    var SimpleEditorContributionDescriptor = (function () {
        function SimpleEditorContributionDescriptor(ctor) {
            this._ctor = ctor;
        }
        SimpleEditorContributionDescriptor.prototype.createInstance = function (instantiationService, editor) {
            return instantiationService.createInstance(this._ctor, editor);
        };
        return SimpleEditorContributionDescriptor;
    }());
    var InternalEditorActionDescriptor = (function () {
        function InternalEditorActionDescriptor(ctor, id, label, alias) {
            this._descriptor = descriptors_1.createSyncDescriptor(ctor, {
                id: id,
                label: label,
                alias: alias
            });
        }
        InternalEditorActionDescriptor.prototype.createInstance = function (instService, editor) {
            return instService.createInstance(this._descriptor, editor);
        };
        return InternalEditorActionDescriptor;
    }());
    // Editor extension points
    var Extensions = {
        EditorCommonContributions: 'editor.commonContributions'
    };
    var EditorContributionRegistry = (function () {
        function EditorContributionRegistry() {
            this.editorContributions = [];
        }
        EditorContributionRegistry.prototype.registerEditorContribution2 = function (ctor) {
            this.editorContributions.push(new SimpleEditorContributionDescriptor(ctor));
        };
        EditorContributionRegistry.prototype.registerEditorAction = function (desc) {
            var handler = desc.kbOpts.handler;
            if (!handler) {
                // here
                if (desc.kbOpts.context === ContextKey.EditorTextFocus || desc.kbOpts.context === ContextKey.EditorFocus) {
                    handler = triggerEditorAction.bind(null, desc.id);
                }
                else {
                    handler = triggerEditorActionGlobal.bind(null, desc.id);
                }
            }
            var when = null;
            if (typeof desc.kbOpts.kbExpr === 'undefined') {
                // here
                if (desc.kbOpts.context === ContextKey.EditorTextFocus) {
                    when = keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS);
                }
                else if (desc.kbOpts.context === ContextKey.EditorFocus) {
                    when = keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_FOCUS);
                }
            }
            else {
                when = desc.kbOpts.kbExpr;
            }
            var commandDesc = {
                id: desc.id,
                handler: handler,
                weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.editorContrib(),
                when: when,
                primary: desc.kbOpts.primary,
                secondary: desc.kbOpts.secondary,
                win: desc.kbOpts.win,
                linux: desc.kbOpts.linux,
                mac: desc.kbOpts.mac,
            };
            keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc(commandDesc);
            this.editorContributions.push(new InternalEditorActionDescriptor(desc.ctor, desc.id, desc.label, desc.alias));
        };
        EditorContributionRegistry.prototype.getEditorContributions2 = function () {
            return this.editorContributions.slice(0);
        };
        return EditorContributionRegistry;
    }());
    platform_1.Registry.add(Extensions.EditorCommonContributions, new EditorContributionRegistry());
    function triggerEditorAction(actionId, accessor, args) {
        config_1.withCodeEditorFromCommandHandler(actionId, accessor, function (editor) {
            editor.trigger('keyboard', actionId, args);
        });
    }
    function triggerEditorActionGlobal(actionId, accessor, args) {
        // TODO: this is not necessarily keyboard
        var focusedEditor = config_1.findFocusedEditor(actionId, accessor, false);
        if (focusedEditor) {
            focusedEditor.trigger('keyboard', actionId, args);
            return;
        }
        var activeEditor = config_1.getActiveEditor(accessor);
        if (activeEditor) {
            var action = activeEditor.getAction(actionId);
            if (action) {
                accessor.get(telemetry_1.ITelemetryService).publicLog('editorActionInvoked', { name: action.label });
                action.run().done(null, errors_1.onUnexpectedError);
            }
            return;
        }
    }
    var defaultEditorActionKeybindingOptions = { primary: null, context: ContextKey.EditorTextFocus };
    function whenRule(needsTextFocus, needsKey) {
        var base = keybindingService_1.KbExpr.has(needsTextFocus ? editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS : editorCommon.KEYBINDING_CONTEXT_EDITOR_FOCUS);
        if (needsKey) {
            return keybindingService_1.KbExpr.and(base, keybindingService_1.KbExpr.has(needsKey));
        }
        return base;
    }
    function createCommandHandler(commandId, handler) {
        return function (accessor, args) {
            config_1.withCodeEditorFromCommandHandler(commandId, accessor, function (editor) {
                handler(accessor, editor, args || {});
            });
        };
    }
});










define(__m[444], __M([0,1,320,16,92,32,73,36,4,7,125,34,18,57,55,42]), function (require, exports, nls, event_1, htmlContent_1, severity_1, markers_1, telemetry_1, range_1, editorCommon, model_1, modelService_1, platform, configuration_1, defaultConfig_1, message_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function MODEL_ID(resource) {
        return resource.toString();
    }
    var ModelData = (function () {
        function ModelData(model, eventsHandler) {
            var _this = this;
            this.model = model;
            this._markerDecorations = [];
            this._modelEventsListener = model.addBulkListener(function (events) { return eventsHandler(_this, events); });
        }
        ModelData.prototype.dispose = function () {
            this._markerDecorations = this.model.deltaDecorations(this._markerDecorations, []);
            this._modelEventsListener.dispose();
            this._modelEventsListener = null;
            this.model = null;
        };
        ModelData.prototype.getModelId = function () {
            return MODEL_ID(this.model.uri);
        };
        ModelData.prototype.acceptMarkerDecorations = function (newDecorations) {
            this._markerDecorations = this.model.deltaDecorations(this._markerDecorations, newDecorations);
        };
        return ModelData;
    }());
    var ModelMarkerHandler = (function () {
        function ModelMarkerHandler() {
        }
        ModelMarkerHandler.setMarkers = function (modelData, markers) {
            var _this = this;
            // Limit to the first 500 errors/warnings
            markers = markers.slice(0, 500);
            var newModelDecorations = markers.map(function (marker) {
                return {
                    range: _this._createDecorationRange(modelData.model, marker),
                    options: _this._createDecorationOption(marker)
                };
            });
            modelData.acceptMarkerDecorations(newModelDecorations);
        };
        ModelMarkerHandler._createDecorationRange = function (model, rawMarker) {
            var marker = model.validateRange(new range_1.Range(rawMarker.startLineNumber, rawMarker.startColumn, rawMarker.endLineNumber, rawMarker.endColumn));
            var ret = new range_1.Range(marker.startLineNumber, marker.startColumn, marker.endLineNumber, marker.endColumn);
            if (ret.isEmpty()) {
                var word = model.getWordAtPosition(ret.getStartPosition());
                if (word) {
                    ret.startColumn = word.startColumn;
                    ret.endColumn = word.endColumn;
                }
                else {
                    var maxColumn = model.getLineLastNonWhitespaceColumn(marker.startLineNumber) ||
                        model.getLineMaxColumn(marker.startLineNumber);
                    if (maxColumn === 1) {
                    }
                    else if (ret.endColumn >= maxColumn) {
                        // behind eol
                        ret.endColumn = maxColumn;
                        ret.startColumn = maxColumn - 1;
                    }
                    else {
                        // extend marker to width = 1
                        ret.endColumn += 1;
                    }
                }
            }
            else if (rawMarker.endColumn === Number.MAX_VALUE && rawMarker.startColumn === 1 && ret.startLineNumber === ret.endLineNumber) {
                var minColumn = model.getLineFirstNonWhitespaceColumn(rawMarker.startLineNumber);
                if (minColumn < ret.endColumn) {
                    ret.startColumn = minColumn;
                    rawMarker.startColumn = minColumn;
                }
            }
            return ret;
        };
        ModelMarkerHandler._createDecorationOption = function (marker) {
            var className;
            var color;
            var darkColor;
            var htmlMessage = null;
            switch (marker.severity) {
                case severity_1.default.Ignore:
                    // do something
                    break;
                case severity_1.default.Warning:
                case severity_1.default.Info:
                    className = editorCommon.ClassName.EditorWarningDecoration;
                    color = 'rgba(18,136,18,0.7)';
                    darkColor = 'rgba(18,136,18,0.7)';
                    break;
                case severity_1.default.Error:
                default:
                    className = editorCommon.ClassName.EditorErrorDecoration;
                    color = 'rgba(255,18,18,0.7)';
                    darkColor = 'rgba(255,18,18,0.7)';
                    break;
            }
            if (typeof marker.message === 'string') {
                htmlMessage = [htmlContent_1.textToMarkedString(marker.message)];
            }
            else if (Array.isArray(marker.message)) {
                htmlMessage = marker.message;
            }
            else if (marker.message) {
                htmlMessage = [marker.message];
            }
            if (htmlMessage && marker.source) {
                htmlMessage.unshift("[" + marker.source + "] ");
            }
            return {
                stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                className: className,
                hoverMessage: htmlMessage,
                overviewRuler: {
                    color: color,
                    darkColor: darkColor,
                    position: editorCommon.OverviewRulerLane.Right
                }
            };
        };
        return ModelMarkerHandler;
    }());
    var ModelServiceImpl = (function () {
        function ModelServiceImpl(markerService, configurationService, messageService) {
            var _this = this;
            this.serviceId = modelService_1.IModelService;
            this._modelCreationOptions = {
                tabSize: defaultConfig_1.DEFAULT_INDENTATION.tabSize,
                insertSpaces: defaultConfig_1.DEFAULT_INDENTATION.insertSpaces,
                detectIndentation: defaultConfig_1.DEFAULT_INDENTATION.detectIndentation,
                defaultEOL: (platform.isLinux || platform.isMacintosh) ? editorCommon.DefaultEndOfLine.LF : editorCommon.DefaultEndOfLine.CRLF,
                trimAutoWhitespace: defaultConfig_1.DEFAULT_TRIM_AUTO_WHITESPACE
            };
            this._markerService = markerService;
            this._configurationService = configurationService;
            this._messageService = messageService;
            this._hasShownMigrationMessage = false;
            this._models = {};
            this._onModelAdded = new event_1.Emitter();
            this._onModelRemoved = new event_1.Emitter();
            this._onModelModeChanged = new event_1.Emitter();
            if (this._markerService) {
                this._markerServiceSubscription = this._markerService.onMarkerChanged(this._handleMarkerChange, this);
            }
            var readConfig = function (config) {
                var shouldShowMigrationMessage = false;
                var tabSize = defaultConfig_1.DEFAULT_INDENTATION.tabSize;
                if (config.editor && typeof config.editor.tabSize !== 'undefined') {
                    var parsedTabSize = parseInt(config.editor.tabSize, 10);
                    if (!isNaN(parsedTabSize)) {
                        tabSize = parsedTabSize;
                    }
                    shouldShowMigrationMessage = shouldShowMigrationMessage || (config.editor.tabSize === 'auto');
                }
                var insertSpaces = defaultConfig_1.DEFAULT_INDENTATION.insertSpaces;
                if (config.editor && typeof config.editor.insertSpaces !== 'undefined') {
                    insertSpaces = (config.editor.insertSpaces === 'false' ? false : Boolean(config.editor.insertSpaces));
                    shouldShowMigrationMessage = shouldShowMigrationMessage || (config.editor.insertSpaces === 'auto');
                }
                var newDefaultEOL = _this._modelCreationOptions.defaultEOL;
                var eol = config.files && config.files.eol;
                if (eol === '\r\n') {
                    newDefaultEOL = editorCommon.DefaultEndOfLine.CRLF;
                }
                else if (eol === '\n') {
                    newDefaultEOL = editorCommon.DefaultEndOfLine.LF;
                }
                var trimAutoWhitespace = _this._modelCreationOptions.trimAutoWhitespace;
                if (config.editor && typeof config.editor.trimAutoWhitespace !== 'undefined') {
                    trimAutoWhitespace = (config.editor.trimAutoWhitespace === 'false' ? false : Boolean(config.editor.trimAutoWhitespace));
                }
                var detectIndentation = defaultConfig_1.DEFAULT_INDENTATION.detectIndentation;
                if (config.editor && typeof config.editor.detectIndentation !== 'undefined') {
                    detectIndentation = (config.editor.detectIndentation === 'false' ? false : Boolean(config.editor.detectIndentation));
                }
                _this._setModelOptions({
                    tabSize: tabSize,
                    insertSpaces: insertSpaces,
                    detectIndentation: detectIndentation,
                    defaultEOL: newDefaultEOL,
                    trimAutoWhitespace: trimAutoWhitespace
                });
                if (shouldShowMigrationMessage && !_this._hasShownMigrationMessage) {
                    _this._hasShownMigrationMessage = true;
                    _this._messageService.show(severity_1.default.Info, nls.localize(0, null));
                }
            };
            this._configurationServiceSubscription = this._configurationService.onDidUpdateConfiguration(function (e) {
                readConfig(e.config);
            });
            readConfig(this._configurationService.getConfiguration());
        }
        ModelServiceImpl.prototype.getCreationOptions = function () {
            return this._modelCreationOptions;
        };
        ModelServiceImpl.prototype._setModelOptions = function (newOpts) {
            if ((this._modelCreationOptions.detectIndentation === newOpts.detectIndentation)
                && (this._modelCreationOptions.insertSpaces === newOpts.insertSpaces)
                && (this._modelCreationOptions.tabSize === newOpts.tabSize)
                && (this._modelCreationOptions.trimAutoWhitespace === newOpts.trimAutoWhitespace)) {
                // Same indent opts, no need to touch created models
                this._modelCreationOptions = newOpts;
                return;
            }
            this._modelCreationOptions = newOpts;
            // Update options on all models
            var keys = Object.keys(this._models);
            for (var i = 0, len = keys.length; i < len; i++) {
                var modelId = keys[i];
                var modelData = this._models[modelId];
                if (this._modelCreationOptions.detectIndentation) {
                    modelData.model.detectIndentation(this._modelCreationOptions.insertSpaces, this._modelCreationOptions.tabSize);
                    modelData.model.updateOptions({
                        trimAutoWhitespace: this._modelCreationOptions.trimAutoWhitespace
                    });
                }
                else {
                    modelData.model.updateOptions({
                        insertSpaces: this._modelCreationOptions.insertSpaces,
                        tabSize: this._modelCreationOptions.tabSize,
                        trimAutoWhitespace: this._modelCreationOptions.trimAutoWhitespace
                    });
                }
            }
        };
        ModelServiceImpl.prototype.dispose = function () {
            if (this._markerServiceSubscription) {
                this._markerServiceSubscription.dispose();
            }
            this._configurationServiceSubscription.dispose();
        };
        ModelServiceImpl.prototype._handleMarkerChange = function (changedResources) {
            var _this = this;
            changedResources.forEach(function (resource) {
                var modelId = MODEL_ID(resource);
                var modelData = _this._models[modelId];
                if (!modelData) {
                    return;
                }
                ModelMarkerHandler.setMarkers(modelData, _this._markerService.read({ resource: resource, take: 500 }));
            });
        };
        // --- begin IModelService
        ModelServiceImpl.prototype._createModelData = function (value, modeOrPromise, resource) {
            var _this = this;
            // create & save the model
            var model;
            if (typeof value === 'string') {
                model = model_1.Model.createFromString(value, this._modelCreationOptions, modeOrPromise, resource);
            }
            else {
                model = new model_1.Model(value, modeOrPromise, resource);
            }
            var modelId = MODEL_ID(model.uri);
            if (this._models[modelId]) {
                // There already exists a model with this id => this is a programmer error
                throw new Error('ModelService: Cannot add model ' + telemetry_1.anonymize(modelId) + ' because it already exists!');
            }
            var modelData = new ModelData(model, function (modelData, events) { return _this._onModelEvents(modelData, events); });
            this._models[modelId] = modelData;
            return modelData;
        };
        ModelServiceImpl.prototype.createModel = function (value, modeOrPromise, resource) {
            var modelData = this._createModelData(value, modeOrPromise, resource);
            // handle markers (marker service => model)
            if (this._markerService) {
                ModelMarkerHandler.setMarkers(modelData, this._markerService.read({ resource: modelData.model.uri }));
            }
            this._onModelAdded.fire(modelData.model);
            return modelData.model;
        };
        ModelServiceImpl.prototype.destroyModel = function (resource) {
            // We need to support that not all models get disposed through this service (i.e. model.dispose() should work!)
            var modelData = this._models[MODEL_ID(resource)];
            if (!modelData) {
                return;
            }
            modelData.model.dispose();
        };
        ModelServiceImpl.prototype.getModels = function () {
            var ret = [];
            var keys = Object.keys(this._models);
            for (var i = 0, len = keys.length; i < len; i++) {
                var modelId = keys[i];
                ret.push(this._models[modelId].model);
            }
            return ret;
        };
        ModelServiceImpl.prototype.getModel = function (resource) {
            var modelId = MODEL_ID(resource);
            var modelData = this._models[modelId];
            if (!modelData) {
                return null;
            }
            return modelData.model;
        };
        Object.defineProperty(ModelServiceImpl.prototype, "onModelAdded", {
            get: function () {
                return this._onModelAdded ? this._onModelAdded.event : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModelServiceImpl.prototype, "onModelRemoved", {
            get: function () {
                return this._onModelRemoved ? this._onModelRemoved.event : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ModelServiceImpl.prototype, "onModelModeChanged", {
            get: function () {
                return this._onModelModeChanged ? this._onModelModeChanged.event : null;
            },
            enumerable: true,
            configurable: true
        });
        // --- end IModelService
        ModelServiceImpl.prototype._onModelDisposing = function (model) {
            var modelId = MODEL_ID(model.uri);
            var modelData = this._models[modelId];
            delete this._models[modelId];
            modelData.dispose();
            this._onModelRemoved.fire(model);
        };
        ModelServiceImpl.prototype._onModelEvents = function (modelData, events) {
            // First look for dispose
            for (var i = 0, len = events.length; i < len; i++) {
                var e = events[i];
                if (e.getType() === editorCommon.EventType.ModelDispose) {
                    this._onModelDisposing(modelData.model);
                    // no more processing since model got disposed
                    return;
                }
            }
            // Second, look for mode change
            for (var i = 0, len = events.length; i < len; i++) {
                var e = events[i];
                if (e.getType() === editorCommon.EventType.ModelModeChanged) {
                    this._onModelModeChanged.fire({
                        model: modelData.model,
                        oldModeId: e.getData().oldMode.getId()
                    });
                }
            }
        };
        ModelServiceImpl = __decorate([
            __param(0, markers_1.IMarkerService),
            __param(1, configuration_1.IConfigurationService),
            __param(2, message_1.IMessageService)
        ], ModelServiceImpl);
        return ModelServiceImpl;
    }());
    exports.ModelServiceImpl = ModelServiceImpl;
});






define(__m[445], __M([0,1,322,2,20,13,473]), function (require, exports, nls, winjs_base_1, editorAction_1, editorCommonExtensions_1, moveCarretCommand_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MoveCarretAction = (function (_super) {
        __extends(MoveCarretAction, _super);
        function MoveCarretAction(descriptor, editor, left) {
            _super.call(this, descriptor, editor);
            this.left = left;
        }
        MoveCarretAction.prototype.run = function () {
            var commands = [];
            var selections = this.editor.getSelections();
            for (var i = 0; i < selections.length; i++) {
                commands.push(new moveCarretCommand_1.MoveCarretCommand(selections[i], this.left));
            }
            this.editor.executeCommands(this.id, commands);
            return winjs_base_1.TPromise.as(true);
        };
        return MoveCarretAction;
    }(editorAction_1.EditorAction));
    var MoveCarretLeftAction = (function (_super) {
        __extends(MoveCarretLeftAction, _super);
        function MoveCarretLeftAction(descriptor, editor) {
            _super.call(this, descriptor, editor, true);
        }
        MoveCarretLeftAction.ID = 'editor.action.moveCarretLeftAction';
        return MoveCarretLeftAction;
    }(MoveCarretAction));
    var MoveCarretRightAction = (function (_super) {
        __extends(MoveCarretRightAction, _super);
        function MoveCarretRightAction(descriptor, editor) {
            _super.call(this, descriptor, editor, false);
        }
        MoveCarretRightAction.ID = 'editor.action.moveCarretRightAction';
        return MoveCarretRightAction;
    }(MoveCarretAction));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(MoveCarretLeftAction, MoveCarretLeftAction.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: 0
    }, 'Move Carret Left'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(MoveCarretRightAction, MoveCarretRightAction.ID, nls.localize(1, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: 0
    }, 'Move Carret Right'));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[446], __M([0,1,323,12,3,2,28,90,20,25,13,204]), function (require, exports, nls, keyCodes_1, lifecycle_1, winjs_base_1, browser, config_1, editorAction_1, editorActionEnablement_1, editorCommonExtensions_1) {
    'use strict';
    var ClipboardWritingAction = (function (_super) {
        __extends(ClipboardWritingAction, _super);
        function ClipboardWritingAction(descriptor, editor, condition) {
            var _this = this;
            _super.call(this, descriptor, editor, condition);
            this.toUnhook = [];
            this.toUnhook.push(this.editor.onDidChangeCursorSelection(function (e) {
                _this.resetEnablementState();
            }));
        }
        ClipboardWritingAction.prototype.dispose = function () {
            this.toUnhook = lifecycle_1.dispose(this.toUnhook);
            _super.prototype.dispose.call(this);
        };
        ClipboardWritingAction.prototype.getEnablementState = function () {
            if (browser.enableEmptySelectionClipboard) {
                return true;
            }
            else {
                return !this.editor.getSelection().isEmpty();
            }
        };
        return ClipboardWritingAction;
    }(editorAction_1.EditorAction));
    function editorCursorIsInEditableRange(editor) {
        var model = editor.getModel();
        if (!model) {
            return false;
        }
        var hasEditableRange = model.hasEditableRange();
        if (!hasEditableRange) {
            return true;
        }
        var editableRange = model.getEditableRange();
        var editorPosition = editor.getPosition();
        return editableRange.containsPosition(editorPosition);
    }
    var ExecCommandCutAction = (function (_super) {
        __extends(ExecCommandCutAction, _super);
        function ExecCommandCutAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.Writeable | editorActionEnablement_1.Behaviour.WidgetFocus | editorActionEnablement_1.Behaviour.ShowInContextMenu | editorActionEnablement_1.Behaviour.UpdateOnCursorPositionChange);
        }
        ExecCommandCutAction.prototype.getGroupId = function () {
            return '3_edit/1_cut';
        };
        ExecCommandCutAction.prototype.getEnablementState = function () {
            return _super.prototype.getEnablementState.call(this) && editorCursorIsInEditableRange(this.editor);
        };
        ExecCommandCutAction.prototype.run = function () {
            this.editor.focus();
            document.execCommand('cut');
            return winjs_base_1.TPromise.as(true);
        };
        return ExecCommandCutAction;
    }(ClipboardWritingAction));
    var ExecCommandCopyAction = (function (_super) {
        __extends(ExecCommandCopyAction, _super);
        function ExecCommandCopyAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.WidgetFocus | editorActionEnablement_1.Behaviour.ShowInContextMenu);
        }
        ExecCommandCopyAction.prototype.getGroupId = function () {
            return '3_edit/2_copy';
        };
        ExecCommandCopyAction.prototype.run = function () {
            this.editor.focus();
            document.execCommand('copy');
            return winjs_base_1.TPromise.as(true);
        };
        return ExecCommandCopyAction;
    }(ClipboardWritingAction));
    var ExecCommandPasteAction = (function (_super) {
        __extends(ExecCommandPasteAction, _super);
        function ExecCommandPasteAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.Writeable | editorActionEnablement_1.Behaviour.WidgetFocus | editorActionEnablement_1.Behaviour.ShowInContextMenu | editorActionEnablement_1.Behaviour.UpdateOnCursorPositionChange);
        }
        ExecCommandPasteAction.prototype.getGroupId = function () {
            return '3_edit/3_paste';
        };
        ExecCommandPasteAction.prototype.getEnablementState = function () {
            return editorCursorIsInEditableRange(this.editor);
        };
        ExecCommandPasteAction.prototype.run = function () {
            this.editor.focus();
            document.execCommand('paste');
            return null;
        };
        return ExecCommandPasteAction;
    }(editorAction_1.EditorAction));
    function registerClipboardAction(desc, alias) {
        if (!browser.supportsExecCommand(desc.execCommand)) {
            return;
        }
        editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(desc.ctor, desc.id, desc.label, {
            handler: execCommandToHandler.bind(null, desc.id, desc.execCommand),
            context: editorCommonExtensions_1.ContextKey.None,
            primary: desc.primary,
            secondary: desc.secondary,
            win: desc.win,
            linux: desc.linux,
            mac: desc.mac
        }, alias));
    }
    registerClipboardAction({
        ctor: ExecCommandCutAction,
        id: 'editor.action.clipboardCutAction',
        label: nls.localize(0, null),
        execCommand: 'cut',
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_X,
        win: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_X, secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Delete] }
    }, 'Cut');
    registerClipboardAction({
        ctor: ExecCommandCopyAction,
        id: 'editor.action.clipboardCopyAction',
        label: nls.localize(1, null),
        execCommand: 'copy',
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_C,
        win: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_C, secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.Insert] }
    }, 'Copy');
    registerClipboardAction({
        ctor: ExecCommandPasteAction,
        id: 'editor.action.clipboardPasteAction',
        label: nls.localize(2, null),
        execCommand: 'paste',
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_V,
        win: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_V, secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Insert] }
    }, 'Paste');
    function execCommandToHandler(actionId, browserCommand, accessor, args) {
        var focusedEditor = config_1.findFocusedEditor(actionId, accessor, false);
        // Only if editor text focus (i.e. not if editor has widget focus).
        if (focusedEditor && focusedEditor.isFocused()) {
            focusedEditor.trigger('keyboard', actionId, args);
            return;
        }
        document.execCommand(browserCommand);
    }
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[447], __M([0,1,8,29,2,13,17,34,14]), function (require, exports, errors_1, uri_1, winjs_base_1, editorCommonExtensions_1, modes_1, modelService_1, async_1) {
    'use strict';
    function getCodeLensData(model) {
        var symbols = [];
        var promises = modes_1.CodeLensProviderRegistry.all(model).map(function (support) {
            return async_1.asWinJsPromise(function (token) {
                return support.provideCodeLenses(model, token);
            }).then(function (result) {
                if (!Array.isArray(result)) {
                    return;
                }
                for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
                    var symbol = result_1[_i];
                    symbols.push({ symbol: symbol, support: support });
                }
            }, function (err) {
                if (!errors_1.isPromiseCanceledError(err)) {
                    errors_1.onUnexpectedError(err);
                }
            });
        });
        return winjs_base_1.TPromise.join(promises).then(function () { return symbols; });
    }
    exports.getCodeLensData = getCodeLensData;
    editorCommonExtensions_1.CommonEditorRegistry.registerLanguageCommand('_executeCodeLensProvider', function (accessor, args) {
        var resource = args.resource;
        if (!(resource instanceof uri_1.default)) {
            throw errors_1.illegalArgument();
        }
        var model = accessor.get(modelService_1.IModelService).getModel(resource);
        if (!model) {
            throw errors_1.illegalArgument();
        }
        return getCodeLensData(model);
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[448], __M([0,1,14,8,3,32,10,2,11,19,42,4,7,17,34,22,30,447,208]), function (require, exports, async_1, errors_1, lifecycle_1, severity_1, strings_1, winjs_base_1, dom, keybindingService_1, message_1, range_1, editorCommon, modes_1, modelService_1, editorBrowser, editorBrowserExtensions_1, codelens_1) {
    'use strict';
    var CodeLensViewZone = (function () {
        function CodeLensViewZone(afterLineNumber) {
            this.afterLineNumber = afterLineNumber;
            this.heightInLines = 1;
            this.suppressMouseDown = true;
            this.domNode = document.createElement('div');
        }
        CodeLensViewZone.prototype.setAfterLineNumber = function (afterLineNumber) {
            this.afterLineNumber = afterLineNumber;
        };
        return CodeLensViewZone;
    }());
    var CodeLensContentWidget = (function () {
        function CodeLensContentWidget(editor, symbolRange, keybindingService, messageService) {
            var _this = this;
            this._commands = Object.create(null);
            this._id = 'codeLensWidget' + (++CodeLensContentWidget.ID);
            this._editor = editor;
            this.setSymbolRange(symbolRange);
            this._domNode = document.createElement('span');
            this._domNode.style.height = editor.getConfiguration().lineHeight + "px";
            this._domNode.innerHTML = '&nbsp;';
            dom.addClass(this._domNode, 'codelens-decoration');
            dom.addClass(this._domNode, 'invisible-cl');
            this._subscription = dom.addDisposableListener(this._domNode, 'click', function (e) {
                var element = e.target;
                if (element.tagName === 'A' && element.id) {
                    var command = _this._commands[element.id];
                    if (command) {
                        editor.focus();
                        keybindingService.executeCommand.apply(keybindingService, [command.id].concat(command.arguments)).done(undefined, function (err) {
                            messageService.show(severity_1.default.Error, err);
                        });
                    }
                }
            });
            this.updateVisibility();
        }
        CodeLensContentWidget.prototype.dispose = function () {
            this._subscription.dispose();
            this._symbolRange = null;
        };
        CodeLensContentWidget.prototype.updateVisibility = function () {
            if (this.isVisible()) {
                dom.removeClass(this._domNode, 'invisible-cl');
                dom.addClass(this._domNode, 'fadein');
            }
        };
        CodeLensContentWidget.prototype.withCommands = function (symbols) {
            this._commands = Object.create(null);
            if (!symbols || !symbols.length) {
                this._domNode.innerHTML = 'no commands';
                return;
            }
            var html = [];
            for (var i = 0; i < symbols.length; i++) {
                var command = symbols[i].command;
                var part = void 0;
                if (command.id) {
                    part = strings_1.format('<a id={0}>{1}</a>', i, command.title);
                    this._commands[i] = command;
                }
                else {
                    part = strings_1.format('<span>{0}</span>', command.title);
                }
                html.push(part);
            }
            this._domNode.innerHTML = html.join('<span>&nbsp;|&nbsp;</span>');
            this._editor.layoutContentWidget(this);
        };
        CodeLensContentWidget.prototype.getId = function () {
            return this._id;
        };
        CodeLensContentWidget.prototype.getDomNode = function () {
            return this._domNode;
        };
        CodeLensContentWidget.prototype.setSymbolRange = function (range) {
            this._symbolRange = range;
            var lineNumber = range.startLineNumber;
            var column = this._editor.getModel().getLineFirstNonWhitespaceColumn(lineNumber);
            this._widgetPosition = {
                position: { lineNumber: lineNumber, column: column },
                preference: [editorBrowser.ContentWidgetPositionPreference.ABOVE]
            };
        };
        CodeLensContentWidget.prototype.getPosition = function () {
            return this._widgetPosition;
        };
        CodeLensContentWidget.prototype.isVisible = function () {
            return this._domNode.hasAttribute('monaco-visible-content-widget');
        };
        CodeLensContentWidget.ID = 0;
        return CodeLensContentWidget;
    }());
    function modelsVersionId(modelService, modeId) {
        var result = 1;
        var models = modelService.getModels()
            .filter(function (model) { return model.getMode().getId() === modeId; })
            .map(function (model) {
            return {
                url: model.uri.toString(),
                versionId: model.getVersionId()
            };
        })
            .sort(function (a, b) {
            if (a.url < b.url) {
                return -1;
            }
            if (a.url > b.url) {
                return 1;
            }
            return 0;
        });
        for (var i = 0; i < models.length; i++) {
            result = (((31 * result) | 0) + models[i].versionId) | 0;
        }
        return result;
    }
    var CodeLensHelper = (function () {
        function CodeLensHelper() {
            this._removeDecorations = [];
            this._addDecorations = [];
            this._addDecorationsCallbacks = [];
        }
        CodeLensHelper.prototype.addDecoration = function (decoration, callback) {
            this._addDecorations.push(decoration);
            this._addDecorationsCallbacks.push(callback);
        };
        CodeLensHelper.prototype.removeDecoration = function (decorationId) {
            this._removeDecorations.push(decorationId);
        };
        CodeLensHelper.prototype.commit = function (changeAccessor) {
            var resultingDecorations = changeAccessor.deltaDecorations(this._removeDecorations, this._addDecorations);
            for (var i = 0, len = resultingDecorations.length; i < len; i++) {
                this._addDecorationsCallbacks[i](resultingDecorations[i]);
            }
        };
        return CodeLensHelper;
    }());
    var CodeLens = (function () {
        function CodeLens(data, editor, helper, viewZoneChangeAccessor, keybindingService, messageService) {
            var _this = this;
            this._editor = editor;
            this._data = data;
            this._decorationIds = new Array(this._data.length);
            var range;
            this._data.forEach(function (codeLensData, i) {
                helper.addDecoration({
                    range: codeLensData.symbol.range,
                    options: {}
                }, function (id) { return _this._decorationIds[i] = id; });
                // the range contain all lenses on this line
                for (var _i = 0, _a = _this._data; _i < _a.length; _i++) {
                    var lensData = _a[_i];
                    if (!range) {
                        range = lensData.symbol.range;
                    }
                    else {
                        range = range_1.Range.plusRange(range, lensData.symbol.range);
                    }
                }
            });
            this._viewZone = new CodeLensViewZone(range.startLineNumber - 1);
            this._contentWidget = new CodeLensContentWidget(editor, range_1.Range.lift(range), keybindingService, messageService);
            this._viewZoneId = viewZoneChangeAccessor.addZone(this._viewZone);
            this._editor.addContentWidget(this._contentWidget);
            this._lastUpdateModelsVersionId = -1;
        }
        CodeLens.prototype.dispose = function (helper, viewZoneChangeAccessor) {
            while (this._decorationIds.length) {
                helper.removeDecoration(this._decorationIds.pop());
            }
            if (viewZoneChangeAccessor) {
                viewZoneChangeAccessor.removeZone(this._viewZoneId);
            }
            this._editor.removeContentWidget(this._contentWidget);
            this._contentWidget.dispose();
        };
        CodeLens.prototype.isValid = function () {
            var _this = this;
            return this._decorationIds.some(function (id) {
                var range = _this._editor.getModel().getDecorationRange(id);
                return range && !range.isEmpty();
            });
        };
        CodeLens.prototype.updateCodeLensSymbols = function (data, helper) {
            var _this = this;
            while (this._decorationIds.length) {
                helper.removeDecoration(this._decorationIds.pop());
            }
            this._data = data;
            this._decorationIds = new Array(this._data.length);
            this._data.forEach(function (codeLensData, i) {
                helper.addDecoration({
                    range: codeLensData.symbol.range,
                    options: {}
                }, function (id) { return _this._decorationIds[i] = id; });
            });
        };
        CodeLens.prototype.computeIfNecessary = function (currentModelsVersionId, model) {
            this._contentWidget.updateVisibility(); // trigger the fade in
            if (!this._contentWidget.isVisible()) {
                return null;
            }
            if (this._lastUpdateModelsVersionId === currentModelsVersionId) {
                return null;
            }
            // Read editor current state
            for (var i = 0; i < this._decorationIds.length; i++) {
                this._data[i].symbol.range = model.getDecorationRange(this._decorationIds[i]);
            }
            return this._data;
        };
        CodeLens.prototype.updateCommands = function (symbols, currentModelsVersionId) {
            this._contentWidget.withCommands(symbols);
            this._lastUpdateModelsVersionId = currentModelsVersionId;
        };
        CodeLens.prototype.getLineNumber = function () {
            var range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
            if (range) {
                return range.startLineNumber;
            }
            return -1;
        };
        CodeLens.prototype.update = function (viewZoneChangeAccessor) {
            if (this.isValid()) {
                var range = this._editor.getModel().getDecorationRange(this._decorationIds[0]);
                this._viewZone.setAfterLineNumber(range.startLineNumber - 1);
                viewZoneChangeAccessor.layoutZone(this._viewZoneId);
                this._contentWidget.setSymbolRange(range);
                this._editor.layoutContentWidget(this._contentWidget);
            }
        };
        return CodeLens;
    }());
    var CodeLensContribution = (function () {
        function CodeLensContribution(_editor, _modelService, _keybindingService, _messageService) {
            var _this = this;
            this._editor = _editor;
            this._modelService = _modelService;
            this._keybindingService = _keybindingService;
            this._messageService = _messageService;
            this._isEnabled = this._editor.getConfiguration().contribInfo.referenceInfos;
            this._globalToDispose = [];
            this._localToDispose = [];
            this._lenses = [];
            this._currentFindCodeLensSymbolsPromise = null;
            this._modelChangeCounter = 0;
            this._globalToDispose.push(this._editor.onDidChangeModel(function () { return _this.onModelChange(); }));
            this._globalToDispose.push(this._editor.onDidChangeModelMode(function () { return _this.onModelChange(); }));
            this._globalToDispose.push(this._editor.onDidChangeConfiguration(function (e) {
                var prevIsEnabled = _this._isEnabled;
                _this._isEnabled = _this._editor.getConfiguration().contribInfo.referenceInfos;
                if (prevIsEnabled !== _this._isEnabled) {
                    _this.onModelChange();
                }
            }));
            this._globalToDispose.push(modes_1.CodeLensProviderRegistry.onDidChange(this.onModelChange, this));
            this.onModelChange();
        }
        CodeLensContribution.prototype.dispose = function () {
            this.localDispose();
            this._globalToDispose = lifecycle_1.dispose(this._globalToDispose);
        };
        CodeLensContribution.prototype.localDispose = function () {
            if (this._currentFindCodeLensSymbolsPromise) {
                this._currentFindCodeLensSymbolsPromise.cancel();
                this._currentFindCodeLensSymbolsPromise = null;
                this._modelChangeCounter++;
            }
            if (this._currentFindOccPromise) {
                this._currentFindOccPromise.cancel();
                this._currentFindOccPromise = null;
            }
            this._localToDispose = lifecycle_1.dispose(this._localToDispose);
        };
        CodeLensContribution.prototype.getId = function () {
            return CodeLensContribution.ID;
        };
        CodeLensContribution.prototype.onModelChange = function () {
            var _this = this;
            this.localDispose();
            var model = this._editor.getModel();
            if (!model) {
                return;
            }
            if (!this._isEnabled) {
                return;
            }
            if (!modes_1.CodeLensProviderRegistry.has(model)) {
                return;
            }
            var detectVisible = new async_1.RunOnceScheduler(function () {
                _this._onViewportChanged(model.getMode().getId());
            }, 500);
            var scheduler = new async_1.RunOnceScheduler(function () {
                if (_this._currentFindCodeLensSymbolsPromise) {
                    _this._currentFindCodeLensSymbolsPromise.cancel();
                }
                _this._currentFindCodeLensSymbolsPromise = codelens_1.getCodeLensData(model);
                var counterValue = ++_this._modelChangeCounter;
                _this._currentFindCodeLensSymbolsPromise.then(function (result) {
                    if (counterValue === _this._modelChangeCounter) {
                        _this.renderCodeLensSymbols(result);
                        detectVisible.schedule();
                    }
                }, function (error) {
                    errors_1.onUnexpectedError(error);
                });
            }, 250);
            this._localToDispose.push(scheduler);
            this._localToDispose.push(detectVisible);
            this._localToDispose.push(model.addBulkListener(function (events) {
                var hadChange = false;
                for (var i = 0; i < events.length; i++) {
                    var eventType = events[i].getType();
                    if (eventType === editorCommon.EventType.ModelRawContentChanged) {
                        hadChange = true;
                        break;
                    }
                }
                if (hadChange) {
                    _this._editor.changeDecorations(function (changeAccessor) {
                        _this._editor.changeViewZones(function (viewAccessor) {
                            var toDispose = [];
                            _this._lenses.forEach(function (lens) {
                                if (lens.isValid()) {
                                    lens.update(viewAccessor);
                                }
                                else {
                                    toDispose.push(lens);
                                }
                            });
                            var helper = new CodeLensHelper();
                            toDispose.forEach(function (l) {
                                l.dispose(helper, viewAccessor);
                                _this._lenses.splice(_this._lenses.indexOf(l), 1);
                            });
                            helper.commit(changeAccessor);
                        });
                    });
                    // Compute new `visible` code lenses
                    detectVisible.schedule();
                    // Ask for all references again
                    scheduler.schedule();
                }
            }));
            this._localToDispose.push(this._editor.onDidScrollChange(function (e) {
                if (e.scrollTopChanged) {
                    detectVisible.schedule();
                }
            }));
            this._localToDispose.push({
                dispose: function () {
                    if (_this._editor.getModel()) {
                        _this._editor.changeDecorations(function (changeAccessor) {
                            _this._editor.changeViewZones(function (accessor) {
                                _this._disposeAllLenses(changeAccessor, accessor);
                            });
                        });
                    }
                    else {
                        // No accessors available
                        _this._disposeAllLenses(null, null);
                    }
                }
            });
            scheduler.schedule();
        };
        CodeLensContribution.prototype._disposeAllLenses = function (decChangeAccessor, viewZoneChangeAccessor) {
            var helper = new CodeLensHelper();
            this._lenses.forEach(function (lens) { return lens.dispose(helper, viewZoneChangeAccessor); });
            if (decChangeAccessor) {
                helper.commit(decChangeAccessor);
            }
            this._lenses = [];
        };
        CodeLensContribution.prototype.renderCodeLensSymbols = function (symbols) {
            var _this = this;
            if (!this._editor.getModel()) {
                return;
            }
            if (!symbols) {
                symbols = [];
            }
            else {
                symbols = symbols.sort(function (a, b) { return range_1.Range.compareRangesUsingStarts(range_1.Range.lift(a.symbol.range), range_1.Range.lift(b.symbol.range)); });
            }
            var maxLineNumber = this._editor.getModel().getLineCount();
            var groups = [];
            var lastGroup;
            for (var _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {
                var symbol = symbols_1[_i];
                var line = symbol.symbol.range.startLineNumber;
                if (line < 1 || line >= maxLineNumber) {
                    // invalid code lens
                    continue;
                }
                else if (lastGroup && lastGroup[lastGroup.length - 1].symbol.range.startLineNumber === line) {
                    // on same line as previous
                    lastGroup.push(symbol);
                }
                else {
                    // on later line as previous
                    lastGroup = [symbol];
                    groups.push(lastGroup);
                }
            }
            var centeredRange = this._editor.getCenteredRangeInViewport();
            var shouldRestoreCenteredRange = (groups.length !== this._lenses.length && this._editor.getScrollTop() !== 0);
            this._editor.changeDecorations(function (changeAccessor) {
                _this._editor.changeViewZones(function (accessor) {
                    var codeLensIndex = 0, groupsIndex = 0, helper = new CodeLensHelper();
                    while (groupsIndex < groups.length && codeLensIndex < _this._lenses.length) {
                        var symbolsLineNumber = groups[groupsIndex][0].symbol.range.startLineNumber;
                        var codeLensLineNumber = _this._lenses[codeLensIndex].getLineNumber();
                        if (codeLensLineNumber < symbolsLineNumber) {
                            _this._lenses[codeLensIndex].dispose(helper, accessor);
                            _this._lenses.splice(codeLensIndex, 1);
                        }
                        else if (codeLensLineNumber === symbolsLineNumber) {
                            _this._lenses[codeLensIndex].updateCodeLensSymbols(groups[groupsIndex], helper);
                            groupsIndex++;
                            codeLensIndex++;
                        }
                        else {
                            _this._lenses.splice(codeLensIndex, 0, new CodeLens(groups[groupsIndex], _this._editor, helper, accessor, _this._keybindingService, _this._messageService));
                            codeLensIndex++;
                            groupsIndex++;
                        }
                    }
                    // Delete extra code lenses
                    while (codeLensIndex < _this._lenses.length) {
                        _this._lenses[codeLensIndex].dispose(helper, accessor);
                        _this._lenses.splice(codeLensIndex, 1);
                    }
                    // Create extra symbols
                    while (groupsIndex < groups.length) {
                        _this._lenses.push(new CodeLens(groups[groupsIndex], _this._editor, helper, accessor, _this._keybindingService, _this._messageService));
                        groupsIndex++;
                    }
                    helper.commit(changeAccessor);
                });
            });
            if (shouldRestoreCenteredRange) {
                this._editor.revealRangeInCenter(centeredRange);
            }
        };
        CodeLensContribution.prototype._onViewportChanged = function (modeId) {
            var _this = this;
            if (this._currentFindOccPromise) {
                this._currentFindOccPromise.cancel();
                this._currentFindOccPromise = null;
            }
            var model = this._editor.getModel();
            if (!model) {
                return;
            }
            var currentModelsVersionId = modelsVersionId(this._modelService, modeId);
            var toResolve = [];
            var lenses = [];
            this._lenses.forEach(function (lens) {
                var request = lens.computeIfNecessary(currentModelsVersionId, model);
                if (request) {
                    toResolve.push(request);
                    lenses.push(lens);
                }
            });
            if (toResolve.length === 0) {
                return;
            }
            var promises = toResolve.map(function (request, i) {
                var resolvedSymbols = new Array(request.length);
                var promises = request.map(function (request, i) {
                    return async_1.asWinJsPromise(function (token) {
                        return request.support.resolveCodeLens(model, request.symbol, token);
                    }).then(function (symbol) {
                        resolvedSymbols[i] = symbol;
                    });
                });
                return winjs_base_1.TPromise.join(promises).then(function () {
                    lenses[i].updateCommands(resolvedSymbols, currentModelsVersionId);
                });
            });
            this._currentFindOccPromise = winjs_base_1.TPromise.join(promises).then(function () {
                _this._currentFindOccPromise = null;
            });
        };
        CodeLensContribution.ID = 'css.editor.codeLens';
        CodeLensContribution = __decorate([
            __param(1, modelService_1.IModelService),
            __param(2, keybindingService_1.IKeybindingService),
            __param(3, message_1.IMessageService)
        ], CodeLensContribution);
        return CodeLensContribution;
    }());
    exports.CodeLensContribution = CodeLensContribution;
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(CodeLensContribution);
});






define(__m[449], __M([0,1,324,12,2,20,13,126,224]), function (require, exports, nls, keyCodes_1, winjs_base_1, editorAction_1, editorCommonExtensions_1, blockCommentCommand_1, lineCommentCommand_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CommentLineAction = (function (_super) {
        __extends(CommentLineAction, _super);
        function CommentLineAction(descriptor, editor, type) {
            _super.call(this, descriptor, editor);
            this._type = type;
        }
        CommentLineAction.prototype.run = function () {
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            var commands = [];
            var selections = this.editor.getSelections();
            var opts = model.getOptions();
            for (var i = 0; i < selections.length; i++) {
                commands.push(new lineCommentCommand_1.LineCommentCommand(selections[i], opts.tabSize, this._type));
            }
            this.editor.executeCommands(this.id, commands);
            return winjs_base_1.TPromise.as(null);
        };
        CommentLineAction.ID = 'editor.action.commentLine';
        return CommentLineAction;
    }(editorAction_1.EditorAction));
    var ToggleCommentLineAction = (function (_super) {
        __extends(ToggleCommentLineAction, _super);
        function ToggleCommentLineAction(descriptor, editor) {
            _super.call(this, descriptor, editor, lineCommentCommand_1.Type.Toggle);
        }
        ToggleCommentLineAction.ID = 'editor.action.commentLine';
        return ToggleCommentLineAction;
    }(CommentLineAction));
    var AddLineCommentAction = (function (_super) {
        __extends(AddLineCommentAction, _super);
        function AddLineCommentAction(descriptor, editor) {
            _super.call(this, descriptor, editor, lineCommentCommand_1.Type.ForceAdd);
        }
        AddLineCommentAction.ID = 'editor.action.addCommentLine';
        return AddLineCommentAction;
    }(CommentLineAction));
    var RemoveLineCommentAction = (function (_super) {
        __extends(RemoveLineCommentAction, _super);
        function RemoveLineCommentAction(descriptor, editor) {
            _super.call(this, descriptor, editor, lineCommentCommand_1.Type.ForceRemove);
        }
        RemoveLineCommentAction.ID = 'editor.action.removeCommentLine';
        return RemoveLineCommentAction;
    }(CommentLineAction));
    var BlockCommentAction = (function (_super) {
        __extends(BlockCommentAction, _super);
        function BlockCommentAction(descriptor, editor) {
            _super.call(this, descriptor, editor);
        }
        BlockCommentAction.prototype.run = function () {
            var commands = [];
            var selections = this.editor.getSelections();
            for (var i = 0; i < selections.length; i++) {
                commands.push(new blockCommentCommand_1.BlockCommentCommand(selections[i]));
            }
            this.editor.executeCommands(this.id, commands);
            return winjs_base_1.TPromise.as(null);
        };
        BlockCommentAction.ID = 'editor.action.blockComment';
        return BlockCommentAction;
    }(editorAction_1.EditorAction));
    // register actions
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(ToggleCommentLineAction, ToggleCommentLineAction.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.US_SLASH
    }, 'Toggle Line Comment'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(AddLineCommentAction, AddLineCommentAction.ID, nls.localize(1, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.chord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_C)
    }, 'Add Line Comment'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(RemoveLineCommentAction, RemoveLineCommentAction.ID, nls.localize(2, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.chord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_U)
    }, 'Remove Line Comment'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(BlockCommentAction, BlockCommentAction.ID, nls.localize(3, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_A,
        linux: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_A }
    }, 'Toggle Block Comment'));
});















define(__m[450], __M([0,1,325,12,3,2,11,58,70,19,79,20,25,7,13,30,400]), function (require, exports, nls, keyCodes_1, lifecycle_1, winjs_base_1, dom, actionbar_1, contextView_1, keybindingService_1, actions_1, editorAction_1, editorActionEnablement_1, editorCommon_1, editorCommonExtensions_1, editorBrowserExtensions_1, menuItemActionItem_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ContextMenuController = (function () {
        function ContextMenuController(editor, _contextMenuService, _contextViewService, _keybindingService, _menuService) {
            var _this = this;
            this._contextMenuService = _contextMenuService;
            this._contextViewService = _contextViewService;
            this._keybindingService = _keybindingService;
            this._menuService = _menuService;
            this._toDispose = [];
            this._contextMenuIsBeingShownCount = 0;
            this._editor = editor;
            this._contextMenu = this._menuService.createMenu(actions_1.MenuId.EditorContext, this._keybindingService);
            this._toDispose.push(this._contextMenu);
            this._toDispose.push(this._editor.onContextMenu(function (e) { return _this._onContextMenu(e); }));
            this._toDispose.push(this._editor.onKeyDown(function (e) {
                if (e.keyCode === keyCodes_1.KeyCode.ContextMenu) {
                    // Chrome is funny like that
                    e.preventDefault();
                    e.stopPropagation();
                    _this.showContextMenu();
                }
            }));
        }
        ContextMenuController.prototype._onContextMenu = function (e) {
            if (!this._editor.getConfiguration().contribInfo.contextmenu) {
                this._editor.focus();
                // Ensure the cursor is at the position of the mouse click
                if (e.target.position && !this._editor.getSelection().containsPosition(e.target.position)) {
                    this._editor.setPosition(e.target.position);
                }
                return; // Context menu is turned off through configuration
            }
            if (e.target.type === editorCommon_1.MouseTargetType.OVERLAY_WIDGET) {
                return; // allow native menu on widgets to support right click on input field for example in find
            }
            e.event.preventDefault();
            if (e.target.type !== editorCommon_1.MouseTargetType.CONTENT_TEXT && e.target.type !== editorCommon_1.MouseTargetType.CONTENT_EMPTY && e.target.type !== editorCommon_1.MouseTargetType.TEXTAREA) {
                return; // only support mouse click into text or native context menu key for now
            }
            // Ensure the editor gets focus if it hasn't, so the right events are being sent to other contributions
            this._editor.focus();
            // Ensure the cursor is at the position of the mouse click
            if (e.target.position && !this._editor.getSelection().containsPosition(e.target.position)) {
                this._editor.setPosition(e.target.position);
            }
            // Unless the user triggerd the context menu through Shift+F10, use the mouse position as menu position
            var forcedPosition;
            if (e.target.type !== editorCommon_1.MouseTargetType.TEXTAREA) {
                forcedPosition = { x: e.event.posx, y: e.event.posy + 1 };
            }
            // Show the context menu
            this.showContextMenu(forcedPosition);
        };
        ContextMenuController.prototype.showContextMenu = function (forcedPosition) {
            if (!this._editor.getConfiguration().contribInfo.contextmenu) {
                return; // Context menu is turned off through configuration
            }
            if (!this._contextMenuService) {
                this._editor.focus();
                return; // We need the context menu service to function
            }
            var position = this._editor.getPosition();
            var editorModel = this._editor.getModel();
            if (!position || !editorModel) {
                return;
            }
            // Find actions available for menu
            var menuActions = this._getMenuActions();
            // Show menu if we have actions to show
            if (menuActions.length > 0) {
                this._doShowContextMenu(menuActions, forcedPosition);
            }
        };
        ContextMenuController.prototype._getMenuActions = function () {
            var editorModel = this._editor.getModel();
            if (!editorModel) {
                return [];
            }
            var contributedActions = this._editor.getActions().filter(function (action) {
                if (action instanceof editorAction_1.EditorAction) {
                    return action.shouldShowInContextMenu() && action.isSupported();
                }
            });
            var actions = ContextMenuController._prepareActions(contributedActions);
            menuItemActionItem_1.fillInActions(this._contextMenu, actions);
            return actions;
        };
        ContextMenuController._prepareActions = function (actions) {
            var data = actions.map(function (action) {
                var groupId = action.getGroupId();
                var idx = groupId.indexOf('/');
                var group = idx > 0
                    ? groupId.substr(0, idx)
                    : groupId;
                return { action: action, group: group };
            });
            data.sort(function (a, b) {
                if (a.group < b.group) {
                    return -1;
                }
                else if (a.group > b.group) {
                    return 1;
                }
                else {
                    return 0;
                }
            });
            var result = [];
            var lastGroup;
            data.forEach(function (value, idx) {
                if (lastGroup && lastGroup !== value.group) {
                    result.push(new actionbar_1.Separator());
                }
                result.push(value.action);
                lastGroup = value.group;
            });
            return result;
        };
        ContextMenuController.prototype._doShowContextMenu = function (actions, forcedPosition) {
            var _this = this;
            if (forcedPosition === void 0) { forcedPosition = null; }
            // Make the editor believe one of its widgets is focused
            this._editor.beginForcedWidgetFocus();
            // Disable hover
            var oldHoverSetting = this._editor.getConfiguration().contribInfo.hover;
            this._editor.updateOptions({
                hover: false
            });
            var menuPosition = forcedPosition;
            if (!menuPosition) {
                // Ensure selection is visible
                this._editor.revealPosition(this._editor.getPosition());
                this._editor.render();
                var cursorCoords = this._editor.getScrolledVisiblePosition(this._editor.getPosition());
                // Translate to absolute editor position
                var editorCoords = dom.getDomNodePagePosition(this._editor.getDomNode());
                var posx = editorCoords.left + cursorCoords.left;
                var posy = editorCoords.top + cursorCoords.top + cursorCoords.height;
                menuPosition = { x: posx, y: posy };
            }
            // Show menu
            this._contextMenuService.showContextMenu({
                getAnchor: function () { return menuPosition; },
                getActions: function () {
                    return winjs_base_1.TPromise.as(actions);
                },
                getActionItem: function (action) {
                    var keybinding = _this._keybindingFor(action);
                    if (keybinding) {
                        return new actionbar_1.ActionItem(action, action, { label: true, keybinding: _this._keybindingService.getLabelFor(keybinding) });
                    }
                    var customActionItem = action;
                    if (typeof customActionItem.getActionItem === 'function') {
                        return customActionItem.getActionItem();
                    }
                    return null;
                },
                getKeyBinding: function (action) {
                    return _this._keybindingFor(action);
                },
                onHide: function (wasCancelled) {
                    _this._contextMenuIsBeingShownCount--;
                    _this._editor.focus();
                    _this._editor.endForcedWidgetFocus();
                    _this._editor.updateOptions({
                        hover: oldHoverSetting
                    });
                }
            });
        };
        ContextMenuController.prototype._keybindingFor = function (action) {
            var opts = this._keybindingService.lookupKeybindings(action.id);
            if (opts.length > 0) {
                return opts[0]; // only take the first one
            }
            return null;
        };
        ContextMenuController.prototype.getId = function () {
            return ContextMenuController.ID;
        };
        ContextMenuController.prototype.dispose = function () {
            if (this._contextMenuIsBeingShownCount > 0) {
                this._contextViewService.hideContextView();
            }
            this._toDispose = lifecycle_1.dispose(this._toDispose);
        };
        ContextMenuController.ID = 'editor.contrib.contextmenu';
        ContextMenuController = __decorate([
            __param(1, contextView_1.IContextMenuService),
            __param(2, contextView_1.IContextViewService),
            __param(3, keybindingService_1.IKeybindingService),
            __param(4, actions_1.IMenuService)
        ], ContextMenuController);
        return ContextMenuController;
    }());
    var ShowContextMenu = (function (_super) {
        __extends(ShowContextMenu, _super);
        function ShowContextMenu(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.TextFocus);
        }
        ShowContextMenu.prototype.run = function () {
            var contribution = this.editor.getContribution(ContextMenuController.ID);
            if (!contribution) {
                return winjs_base_1.TPromise.as(null);
            }
            contribution.showContextMenu();
            return winjs_base_1.TPromise.as(null);
        };
        ShowContextMenu.ID = 'editor.action.showContextMenu';
        return ShowContextMenu;
    }(editorAction_1.EditorAction));
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(ContextMenuController);
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(ShowContextMenu, ShowContextMenu.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.F10
    }, 'Show Editor Context Menu'));
});















define(__m[451], __M([0,1,329,12,3,2,19,4,24,20,25,10,7,13,128,227,17,14]), function (require, exports, nls, keyCodes_1, lifecycle_1, winjs_base_1, keybindingService_1, range_1, selection_1, editorAction_1, editorActionEnablement_1, strings, editorCommon, editorCommonExtensions_1, findModel_1, findState_1, modes_1, async_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    (function (FindStartFocusAction) {
        FindStartFocusAction[FindStartFocusAction["NoFocusChange"] = 0] = "NoFocusChange";
        FindStartFocusAction[FindStartFocusAction["FocusFindInput"] = 1] = "FocusFindInput";
        FindStartFocusAction[FindStartFocusAction["FocusReplaceInput"] = 2] = "FocusReplaceInput";
    })(exports.FindStartFocusAction || (exports.FindStartFocusAction = {}));
    var FindStartFocusAction = exports.FindStartFocusAction;
    var CONTEXT_FIND_WIDGET_VISIBLE = 'findWidgetVisible';
    var CommonFindController = (function (_super) {
        __extends(CommonFindController, _super);
        function CommonFindController(editor, keybindingService) {
            var _this = this;
            _super.call(this);
            this._editor = editor;
            this._findWidgetVisible = keybindingService.createKey(CONTEXT_FIND_WIDGET_VISIBLE, false);
            this._state = this._register(new findState_1.FindReplaceState());
            this._register(this._state.addChangeListener(function (e) { return _this._onStateChanged(e); }));
            this._model = null;
            this._register(this._editor.onDidChangeModel(function () {
                var shouldRestartFind = (_this._editor.getModel() && _this._state.isRevealed);
                _this.disposeModel();
                if (shouldRestartFind) {
                    _this._start({
                        forceRevealReplace: false,
                        seedSearchStringFromSelection: false,
                        seedSearchScopeFromSelection: false,
                        shouldFocus: FindStartFocusAction.NoFocusChange,
                        shouldAnimate: false
                    });
                }
            }));
        }
        CommonFindController.getFindController = function (editor) {
            return editor.getContribution(CommonFindController.ID);
        };
        CommonFindController.prototype.dispose = function () {
            this.disposeModel();
            _super.prototype.dispose.call(this);
        };
        CommonFindController.prototype.disposeModel = function () {
            if (this._model) {
                this._model.dispose();
                this._model = null;
            }
        };
        CommonFindController.prototype.getId = function () {
            return CommonFindController.ID;
        };
        CommonFindController.prototype._onStateChanged = function (e) {
            if (e.isRevealed) {
                if (this._state.isRevealed) {
                    this._findWidgetVisible.set(true);
                }
                else {
                    this._findWidgetVisible.reset();
                    this.disposeModel();
                }
            }
        };
        CommonFindController.prototype.getState = function () {
            return this._state;
        };
        CommonFindController.prototype.closeFindWidget = function () {
            this._state.change({ isRevealed: false }, false);
            this._editor.focus();
        };
        CommonFindController.prototype.toggleCaseSensitive = function () {
            this._state.change({ matchCase: !this._state.matchCase }, false);
        };
        CommonFindController.prototype.toggleWholeWords = function () {
            this._state.change({ wholeWord: !this._state.wholeWord }, false);
        };
        CommonFindController.prototype.toggleRegex = function () {
            this._state.change({ isRegex: !this._state.isRegex }, false);
        };
        CommonFindController.prototype.setSearchString = function (searchString) {
            this._state.change({ searchString: searchString }, false);
        };
        CommonFindController.prototype.getSelectionSearchString = function () {
            var selection = this._editor.getSelection();
            if (selection.startLineNumber === selection.endLineNumber) {
                if (selection.isEmpty()) {
                    var wordAtPosition = this._editor.getModel().getWordAtPosition(selection.getStartPosition());
                    if (wordAtPosition) {
                        return wordAtPosition.word;
                    }
                }
                else {
                    return this._editor.getModel().getValueInRange(selection);
                }
            }
            return null;
        };
        CommonFindController.prototype._start = function (opts) {
            this.disposeModel();
            if (!this._editor.getModel()) {
                // cannot do anything with an editor that doesn't have a model...
                return;
            }
            var stateChanges = {
                isRevealed: true
            };
            // Consider editor selection and overwrite the state with it
            if (opts.seedSearchStringFromSelection) {
                var selectionSearchString = this.getSelectionSearchString();
                if (selectionSearchString) {
                    if (this._state.isRegex) {
                        stateChanges.searchString = strings.escapeRegExpCharacters(selectionSearchString);
                    }
                    else {
                        stateChanges.searchString = selectionSearchString;
                    }
                }
            }
            var selection = this._editor.getSelection();
            stateChanges.searchScope = null;
            if (opts.seedSearchScopeFromSelection && selection.startLineNumber < selection.endLineNumber) {
                // Take search scope into account only if it is more than one line.
                stateChanges.searchScope = selection;
            }
            // Overwrite isReplaceRevealed
            if (opts.forceRevealReplace) {
                stateChanges.isReplaceRevealed = true;
            }
            this._state.change(stateChanges, false);
            if (!this._model) {
                this._model = new findModel_1.FindModelBoundToEditorModel(this._editor, this._state);
            }
        };
        CommonFindController.prototype.start = function (opts) {
            this._start(opts);
        };
        CommonFindController.prototype.moveToNextMatch = function () {
            if (this._model) {
                this._model.moveToNextMatch();
                return true;
            }
            return false;
        };
        CommonFindController.prototype.moveToPrevMatch = function () {
            if (this._model) {
                this._model.moveToPrevMatch();
                return true;
            }
            return false;
        };
        CommonFindController.prototype.replace = function () {
            if (this._model) {
                this._model.replace();
                return true;
            }
            return false;
        };
        CommonFindController.prototype.replaceAll = function () {
            if (this._model) {
                this._model.replaceAll();
                return true;
            }
            return false;
        };
        CommonFindController.prototype.selectAllMatches = function () {
            if (this._model) {
                this._model.selectAllMatches();
                this._editor.focus();
                return true;
            }
            return false;
        };
        CommonFindController.ID = 'editor.contrib.findController';
        CommonFindController = __decorate([
            __param(1, keybindingService_1.IKeybindingService)
        ], CommonFindController);
        return CommonFindController;
    }(lifecycle_1.Disposable));
    exports.CommonFindController = CommonFindController;
    var StartFindAction = (function (_super) {
        __extends(StartFindAction, _super);
        function StartFindAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.WidgetFocus);
        }
        StartFindAction.prototype.run = function () {
            var controller = CommonFindController.getFindController(this.editor);
            controller.start({
                forceRevealReplace: false,
                seedSearchStringFromSelection: true,
                seedSearchScopeFromSelection: true,
                shouldFocus: FindStartFocusAction.FocusFindInput,
                shouldAnimate: true
            });
            return winjs_base_1.TPromise.as(true);
        };
        return StartFindAction;
    }(editorAction_1.EditorAction));
    exports.StartFindAction = StartFindAction;
    var MatchFindAction = (function (_super) {
        __extends(MatchFindAction, _super);
        function MatchFindAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.WidgetFocus);
        }
        MatchFindAction.prototype.run = function () {
            var controller = CommonFindController.getFindController(this.editor);
            if (!this._run(controller)) {
                controller.start({
                    forceRevealReplace: false,
                    seedSearchStringFromSelection: (controller.getState().searchString.length === 0),
                    seedSearchScopeFromSelection: false,
                    shouldFocus: FindStartFocusAction.NoFocusChange,
                    shouldAnimate: true
                });
                this._run(controller);
            }
            return winjs_base_1.TPromise.as(true);
        };
        return MatchFindAction;
    }(editorAction_1.EditorAction));
    exports.MatchFindAction = MatchFindAction;
    var NextMatchFindAction = (function (_super) {
        __extends(NextMatchFindAction, _super);
        function NextMatchFindAction() {
            _super.apply(this, arguments);
        }
        NextMatchFindAction.prototype._run = function (controller) {
            return controller.moveToNextMatch();
        };
        return NextMatchFindAction;
    }(MatchFindAction));
    exports.NextMatchFindAction = NextMatchFindAction;
    var PreviousMatchFindAction = (function (_super) {
        __extends(PreviousMatchFindAction, _super);
        function PreviousMatchFindAction() {
            _super.apply(this, arguments);
        }
        PreviousMatchFindAction.prototype._run = function (controller) {
            return controller.moveToPrevMatch();
        };
        return PreviousMatchFindAction;
    }(MatchFindAction));
    exports.PreviousMatchFindAction = PreviousMatchFindAction;
    var SelectionMatchFindAction = (function (_super) {
        __extends(SelectionMatchFindAction, _super);
        function SelectionMatchFindAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.WidgetFocus);
        }
        SelectionMatchFindAction.prototype.run = function () {
            var controller = CommonFindController.getFindController(this.editor);
            var selectionSearchString = controller.getSelectionSearchString();
            if (selectionSearchString) {
                controller.setSearchString(selectionSearchString);
            }
            if (!this._run(controller)) {
                controller.start({
                    forceRevealReplace: false,
                    seedSearchStringFromSelection: false,
                    seedSearchScopeFromSelection: false,
                    shouldFocus: FindStartFocusAction.NoFocusChange,
                    shouldAnimate: true
                });
                this._run(controller);
            }
            return winjs_base_1.TPromise.as(true);
        };
        return SelectionMatchFindAction;
    }(editorAction_1.EditorAction));
    exports.SelectionMatchFindAction = SelectionMatchFindAction;
    var NextSelectionMatchFindAction = (function (_super) {
        __extends(NextSelectionMatchFindAction, _super);
        function NextSelectionMatchFindAction() {
            _super.apply(this, arguments);
        }
        NextSelectionMatchFindAction.prototype._run = function (controller) {
            return controller.moveToNextMatch();
        };
        return NextSelectionMatchFindAction;
    }(SelectionMatchFindAction));
    exports.NextSelectionMatchFindAction = NextSelectionMatchFindAction;
    var PreviousSelectionMatchFindAction = (function (_super) {
        __extends(PreviousSelectionMatchFindAction, _super);
        function PreviousSelectionMatchFindAction() {
            _super.apply(this, arguments);
        }
        PreviousSelectionMatchFindAction.prototype._run = function (controller) {
            return controller.moveToPrevMatch();
        };
        return PreviousSelectionMatchFindAction;
    }(SelectionMatchFindAction));
    exports.PreviousSelectionMatchFindAction = PreviousSelectionMatchFindAction;
    var StartFindReplaceAction = (function (_super) {
        __extends(StartFindReplaceAction, _super);
        function StartFindReplaceAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.WidgetFocus | editorActionEnablement_1.Behaviour.Writeable);
        }
        StartFindReplaceAction.prototype.run = function () {
            var controller = CommonFindController.getFindController(this.editor);
            controller.start({
                forceRevealReplace: true,
                seedSearchStringFromSelection: true,
                seedSearchScopeFromSelection: true,
                shouldFocus: FindStartFocusAction.FocusReplaceInput,
                shouldAnimate: true
            });
            return winjs_base_1.TPromise.as(true);
        };
        return StartFindReplaceAction;
    }(editorAction_1.EditorAction));
    exports.StartFindReplaceAction = StartFindReplaceAction;
    function multiCursorFind(editor, changeFindSearchString) {
        var controller = CommonFindController.getFindController(editor);
        var state = controller.getState();
        var searchText, nextMatch;
        // In any case, if the find widget was ever opened, the options are taken from it
        var wholeWord = state.wholeWord;
        var matchCase = state.matchCase;
        // Find widget owns what we search for if:
        //  - focus is not in the editor (i.e. it is in the find widget)
        //  - and the search widget is visible
        //  - and the search string is non-empty
        if (!editor.isFocused() && state.isRevealed && state.searchString.length > 0) {
            // Find widget owns what is searched for
            searchText = state.searchString;
        }
        else {
            // Selection owns what is searched for
            var s = editor.getSelection();
            if (s.startLineNumber !== s.endLineNumber) {
                // Cannot search for multiline string... yet...
                return null;
            }
            if (s.isEmpty()) {
                // selection is empty => expand to current word
                var word = editor.getModel().getWordAtPosition(s.getStartPosition());
                if (!word) {
                    return null;
                }
                searchText = word.word;
                nextMatch = new selection_1.Selection(s.startLineNumber, word.startColumn, s.startLineNumber, word.endColumn);
            }
            else {
                searchText = editor.getModel().getValueInRange(s);
            }
            if (changeFindSearchString) {
                controller.setSearchString(searchText);
            }
        }
        return {
            searchText: searchText,
            matchCase: matchCase,
            wholeWord: wholeWord,
            nextMatch: nextMatch
        };
    }
    var SelectNextFindMatchAction = (function (_super) {
        __extends(SelectNextFindMatchAction, _super);
        function SelectNextFindMatchAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.WidgetFocus);
        }
        SelectNextFindMatchAction.prototype._getNextMatch = function () {
            var r = multiCursorFind(this.editor, true);
            if (!r) {
                return null;
            }
            if (r.nextMatch) {
                return r.nextMatch;
            }
            var allSelections = this.editor.getSelections();
            var lastAddedSelection = allSelections[allSelections.length - 1];
            var nextMatch = this.editor.getModel().findNextMatch(r.searchText, lastAddedSelection.getEndPosition(), false, r.matchCase, r.wholeWord);
            if (!nextMatch) {
                return null;
            }
            return new selection_1.Selection(nextMatch.startLineNumber, nextMatch.startColumn, nextMatch.endLineNumber, nextMatch.endColumn);
        };
        return SelectNextFindMatchAction;
    }(editorAction_1.EditorAction));
    exports.SelectNextFindMatchAction = SelectNextFindMatchAction;
    var AddSelectionToNextFindMatchAction = (function (_super) {
        __extends(AddSelectionToNextFindMatchAction, _super);
        function AddSelectionToNextFindMatchAction(descriptor, editor) {
            _super.call(this, descriptor, editor);
        }
        AddSelectionToNextFindMatchAction.prototype.run = function () {
            var nextMatch = this._getNextMatch();
            if (!nextMatch) {
                return winjs_base_1.TPromise.as(false);
            }
            var allSelections = this.editor.getSelections();
            this.editor.setSelections(allSelections.concat(nextMatch));
            this.editor.revealRangeInCenterIfOutsideViewport(nextMatch);
            return winjs_base_1.TPromise.as(true);
        };
        AddSelectionToNextFindMatchAction.ID = findModel_1.FIND_IDS.AddSelectionToNextFindMatchAction;
        return AddSelectionToNextFindMatchAction;
    }(SelectNextFindMatchAction));
    exports.AddSelectionToNextFindMatchAction = AddSelectionToNextFindMatchAction;
    var MoveSelectionToNextFindMatchAction = (function (_super) {
        __extends(MoveSelectionToNextFindMatchAction, _super);
        function MoveSelectionToNextFindMatchAction(descriptor, editor) {
            _super.call(this, descriptor, editor);
        }
        MoveSelectionToNextFindMatchAction.prototype.run = function () {
            var nextMatch = this._getNextMatch();
            if (!nextMatch) {
                return winjs_base_1.TPromise.as(false);
            }
            var allSelections = this.editor.getSelections();
            this.editor.setSelections(allSelections.slice(0, allSelections.length - 1).concat(nextMatch));
            this.editor.revealRangeInCenterIfOutsideViewport(nextMatch);
            return winjs_base_1.TPromise.as(true);
        };
        MoveSelectionToNextFindMatchAction.ID = findModel_1.FIND_IDS.MoveSelectionToNextFindMatchAction;
        return MoveSelectionToNextFindMatchAction;
    }(SelectNextFindMatchAction));
    exports.MoveSelectionToNextFindMatchAction = MoveSelectionToNextFindMatchAction;
    var SelectHighlightsAction = (function (_super) {
        __extends(SelectHighlightsAction, _super);
        function SelectHighlightsAction(descriptor, editor) {
            var behaviour = editorActionEnablement_1.Behaviour.WidgetFocus | editorActionEnablement_1.Behaviour.Writeable;
            if (descriptor.id === SelectHighlightsAction.COMPAT_ID) {
                behaviour |= editorActionEnablement_1.Behaviour.ShowInContextMenu;
            }
            _super.call(this, descriptor, editor, behaviour);
        }
        SelectHighlightsAction.prototype.getGroupId = function () {
            return '2_change/1_changeAll';
        };
        SelectHighlightsAction.prototype.run = function () {
            var r = multiCursorFind(this.editor, true);
            if (!r) {
                return winjs_base_1.TPromise.as(false);
            }
            var matches = this.editor.getModel().findMatches(r.searchText, true, false, r.matchCase, r.wholeWord);
            if (matches.length > 0) {
                this.editor.setSelections(matches.map(function (m) { return new selection_1.Selection(m.startLineNumber, m.startColumn, m.endLineNumber, m.endColumn); }));
            }
            return winjs_base_1.TPromise.as(true);
        };
        SelectHighlightsAction.ID = 'editor.action.selectHighlights';
        SelectHighlightsAction.COMPAT_ID = 'editor.action.changeAll';
        return SelectHighlightsAction;
    }(editorAction_1.EditorAction));
    exports.SelectHighlightsAction = SelectHighlightsAction;
    var SelectionHighlighter = (function (_super) {
        __extends(SelectionHighlighter, _super);
        function SelectionHighlighter(editor) {
            var _this = this;
            _super.call(this);
            this.editor = editor;
            this.decorations = [];
            this.updateSoon = this._register(new async_1.RunOnceScheduler(function () { return _this._update(); }, 300));
            this.lastWordUnderCursor = null;
            this._register(editor.onDidChangeCursorSelection(function (e) {
                if (e.selection.isEmpty()) {
                    if (e.reason === editorCommon.CursorChangeReason.Explicit) {
                        if (!_this.lastWordUnderCursor || !_this.lastWordUnderCursor.containsPosition(e.selection.getStartPosition())) {
                            // no longer valid
                            _this.removeDecorations();
                        }
                        _this.updateSoon.schedule();
                    }
                    else {
                        _this.removeDecorations();
                    }
                }
                else {
                    _this._update();
                }
            }));
            this._register(editor.onDidChangeModel(function (e) {
                _this.removeDecorations();
            }));
            this._register(CommonFindController.getFindController(editor).getState().addChangeListener(function (e) {
                _this._update();
            }));
        }
        SelectionHighlighter.prototype.getId = function () {
            return SelectionHighlighter.ID;
        };
        SelectionHighlighter.prototype.removeDecorations = function () {
            this.lastWordUnderCursor = null;
            if (this.decorations.length > 0) {
                this.decorations = this.editor.deltaDecorations(this.decorations, []);
            }
        };
        SelectionHighlighter.prototype._update = function () {
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            this.lastWordUnderCursor = null;
            if (!this.editor.getConfiguration().contribInfo.selectionHighlight) {
                return;
            }
            var r = multiCursorFind(this.editor, false);
            if (!r) {
                this.removeDecorations();
                return;
            }
            var hasFindOccurences = modes_1.DocumentHighlightProviderRegistry.has(model);
            if (r.nextMatch) {
                // This is an empty selection
                if (hasFindOccurences) {
                    // Do not interfere with semantic word highlighting in the no selection case
                    this.removeDecorations();
                    return;
                }
                this.lastWordUnderCursor = r.nextMatch;
            }
            if (/^[ \t]+$/.test(r.searchText)) {
                // whitespace only selection
                this.removeDecorations();
                return;
            }
            if (r.searchText.length > 200) {
                // very long selection
                this.removeDecorations();
                return;
            }
            var selections = this.editor.getSelections();
            var firstSelectedText = model.getValueInRange(selections[0]);
            for (var i = 1; i < selections.length; i++) {
                var selectedText = model.getValueInRange(selections[i]);
                if (firstSelectedText !== selectedText) {
                    // not all selections have the same text
                    this.removeDecorations();
                    return;
                }
            }
            var allMatches = model.findMatches(r.searchText, true, false, r.matchCase, r.wholeWord);
            allMatches.sort(range_1.Range.compareRangesUsingStarts);
            selections.sort(range_1.Range.compareRangesUsingStarts);
            // do not overlap with selection (issue #64 and #512)
            var matches = [];
            for (var i = 0, j = 0, len = allMatches.length, lenJ = selections.length; i < len;) {
                var match = allMatches[i];
                if (j >= lenJ) {
                    // finished all editor selections
                    matches.push(match);
                    i++;
                }
                else {
                    var cmp = range_1.Range.compareRangesUsingStarts(match, selections[j]);
                    if (cmp < 0) {
                        // match is before sel
                        matches.push(match);
                        i++;
                    }
                    else if (cmp > 0) {
                        // sel is before match
                        j++;
                    }
                    else {
                        // sel is equal to match
                        i++;
                        j++;
                    }
                }
            }
            var decorations = matches.map(function (r) {
                return {
                    range: r,
                    options: {
                        stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                        className: 'selectionHighlight',
                        // Show in overviewRuler only if model has no semantic highlighting
                        overviewRuler: (hasFindOccurences ? undefined : {
                            color: '#A0A0A0',
                            darkColor: '#A0A0A0',
                            position: editorCommon.OverviewRulerLane.Center
                        })
                    }
                };
            });
            this.decorations = this.editor.deltaDecorations(this.decorations, decorations);
        };
        SelectionHighlighter.prototype.dispose = function () {
            this.removeDecorations();
            _super.prototype.dispose.call(this);
        };
        SelectionHighlighter.ID = 'editor.contrib.selectionHighlighter';
        return SelectionHighlighter;
    }(lifecycle_1.Disposable));
    exports.SelectionHighlighter = SelectionHighlighter;
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(SelectHighlightsAction, SelectHighlightsAction.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_L
    }, 'Select All Occurences of Find Match'));
    // register SelectHighlightsAction again to replace the now removed Change All action
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(SelectHighlightsAction, SelectHighlightsAction.COMPAT_ID, nls.localize(1, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.F2
    }, 'Change All Occurrences'));
    // register actions
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(StartFindAction, findModel_1.FIND_IDS.StartFindAction, nls.localize(2, null), {
        context: editorCommonExtensions_1.ContextKey.None,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_F
    }, 'Find'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(NextMatchFindAction, findModel_1.FIND_IDS.NextMatchFindAction, nls.localize(3, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyCode.F3,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_G, secondary: [keyCodes_1.KeyCode.F3] }
    }, 'Find Next'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(PreviousMatchFindAction, findModel_1.FIND_IDS.PreviousMatchFindAction, nls.localize(4, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.F3,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_G, secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.F3] }
    }, 'Find Previous'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(NextSelectionMatchFindAction, findModel_1.FIND_IDS.NextSelectionMatchFindAction, nls.localize(5, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.F3
    }, 'Find Next Selection'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(PreviousSelectionMatchFindAction, findModel_1.FIND_IDS.PreviousSelectionMatchFindAction, nls.localize(6, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.F3
    }, 'Find Previous Selection'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(StartFindReplaceAction, findModel_1.FIND_IDS.StartFindReplaceAction, nls.localize(7, null), {
        context: editorCommonExtensions_1.ContextKey.None,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_H,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_F }
    }, 'Replace'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(MoveSelectionToNextFindMatchAction, MoveSelectionToNextFindMatchAction.ID, nls.localize(8, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.chord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_D)
    }, 'Move Last Selection To Next Find Match'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(AddSelectionToNextFindMatchAction, AddSelectionToNextFindMatchAction.ID, nls.localize(9, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_D
    }, 'Add Selection To Next Find Match'));
    function registerFindCommand(id, callback, keybindings, needsKey) {
        if (needsKey === void 0) { needsKey = null; }
        editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand(id, editorCommonExtensions_1.CommonEditorRegistry.commandWeight(5), keybindings, false, needsKey, function (ctx, editor, args) {
            callback(CommonFindController.getFindController(editor));
        });
    }
    registerFindCommand(findModel_1.FIND_IDS.CloseFindWidgetCommand, function (x) { return x.closeFindWidget(); }, {
        primary: keyCodes_1.KeyCode.Escape,
        secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape]
    }, CONTEXT_FIND_WIDGET_VISIBLE);
    registerFindCommand(findModel_1.FIND_IDS.ToggleCaseSensitiveCommand, function (x) { return x.toggleCaseSensitive(); }, {
        primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_C,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_C }
    });
    registerFindCommand(findModel_1.FIND_IDS.ToggleWholeWordCommand, function (x) { return x.toggleWholeWords(); }, {
        primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_W,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_W }
    });
    registerFindCommand(findModel_1.FIND_IDS.ToggleRegexCommand, function (x) { return x.toggleRegex(); }, {
        primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_R,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_R }
    });
    registerFindCommand(findModel_1.FIND_IDS.ReplaceOneAction, function (x) { return x.replace(); }, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_1
    }, CONTEXT_FIND_WIDGET_VISIBLE);
    registerFindCommand(findModel_1.FIND_IDS.ReplaceAllAction, function (x) { return x.replaceAll(); }, {
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.Enter
    }, CONTEXT_FIND_WIDGET_VISIBLE);
    registerFindCommand(findModel_1.FIND_IDS.SelectAllMatchesAction, function (x) { return x.selectAllMatches(); }, {
        primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.Enter
    }, CONTEXT_FIND_WIDGET_VISIBLE);
});















define(__m[452], __M([0,1,70,19,30,328,451]), function (require, exports, contextView_1, keybindingService_1, editorBrowserExtensions_1, findWidget_1, findController_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var FindController = (function (_super) {
        __extends(FindController, _super);
        function FindController(editor, contextViewService, keybindingService) {
            _super.call(this, editor, keybindingService);
            this._widget = this._register(new findWidget_1.FindWidget(editor, this, this._state, contextViewService, keybindingService));
        }
        FindController.prototype._start = function (opts) {
            _super.prototype._start.call(this, opts);
            if (opts.shouldFocus === findController_1.FindStartFocusAction.FocusReplaceInput) {
                this._widget.focusReplaceInput();
            }
            else if (opts.shouldFocus === findController_1.FindStartFocusAction.FocusFindInput) {
                this._widget.focusFindInput();
            }
        };
        FindController = __decorate([
            __param(1, contextView_1.IContextViewService),
            __param(2, keybindingService_1.IKeybindingService)
        ], FindController);
        return FindController;
    }(findController_1.CommonFindController));
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(FindController);
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(findController_1.SelectionHighlighter);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/// <amd-dependency path="vs/css!./folding" />





define(__m[453], __M([0,1,330,14,12,3,2,20,25,7,4,13,30,488,213]), function (require, exports, nls, async_1, keyCodes_1, lifecycle_1, winjs_base_1, editorAction_1, editorActionEnablement_1, editorCommon, range_1, editorCommonExtensions_1, editorBrowserExtensions_1, indentFoldStrategy_1) {
    'use strict';
    var CollapsibleRegion = (function () {
        function CollapsibleRegion(range, model, changeAccessor) {
            this.decorationIds = [];
            this.update(range, model, changeAccessor);
        }
        Object.defineProperty(CollapsibleRegion.prototype, "isCollapsed", {
            get: function () {
                return this._isCollapsed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CollapsibleRegion.prototype, "isExpanded", {
            get: function () {
                return !this._isCollapsed;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CollapsibleRegion.prototype, "indent", {
            get: function () {
                return this._indent;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CollapsibleRegion.prototype, "startLineNumber", {
            get: function () {
                return this._lastRange ? this._lastRange.startLineNumber : void 0;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(CollapsibleRegion.prototype, "endLineNumber", {
            get: function () {
                return this._lastRange ? this._lastRange.endLineNumber : void 0;
            },
            enumerable: true,
            configurable: true
        });
        CollapsibleRegion.prototype.setCollapsed = function (isCollaped, changeAccessor) {
            this._isCollapsed = isCollaped;
            if (this.decorationIds.length > 0) {
                changeAccessor.changeDecorationOptions(this.decorationIds[0], this.getVisualDecorationOptions());
            }
        };
        CollapsibleRegion.prototype.getDecorationRange = function (model) {
            if (this.decorationIds.length > 0) {
                return model.getDecorationRange(this.decorationIds[1]);
            }
            return null;
        };
        CollapsibleRegion.prototype.getVisualDecorationOptions = function () {
            if (this._isCollapsed) {
                return {
                    stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                    inlineClassName: 'inline-folded',
                    linesDecorationsClassName: 'folding collapsed'
                };
            }
            else {
                return {
                    stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                    linesDecorationsClassName: 'folding'
                };
            }
        };
        CollapsibleRegion.prototype.getRangeDecorationOptions = function () {
            return {
                stickiness: editorCommon.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore
            };
        };
        CollapsibleRegion.prototype.update = function (newRange, model, changeAccessor) {
            this._lastRange = newRange;
            this._isCollapsed = !!newRange.isCollapsed;
            this._indent = newRange.indent;
            var newDecorations = [];
            var maxColumn = model.getLineMaxColumn(newRange.startLineNumber);
            var visualRng = {
                startLineNumber: newRange.startLineNumber,
                startColumn: maxColumn - 1,
                endLineNumber: newRange.startLineNumber,
                endColumn: maxColumn
            };
            newDecorations.push({ range: visualRng, options: this.getVisualDecorationOptions() });
            var colRng = {
                startLineNumber: newRange.startLineNumber,
                startColumn: 1,
                endLineNumber: newRange.endLineNumber,
                endColumn: model.getLineMaxColumn(newRange.endLineNumber)
            };
            newDecorations.push({ range: colRng, options: this.getRangeDecorationOptions() });
            this.decorationIds = changeAccessor.deltaDecorations(this.decorationIds, newDecorations);
        };
        CollapsibleRegion.prototype.dispose = function (changeAccessor) {
            this._lastRange = null;
            this.decorationIds = changeAccessor.deltaDecorations(this.decorationIds, []);
        };
        CollapsibleRegion.prototype.toString = function () {
            var str = this.isCollapsed ? 'collapsed ' : 'expanded ';
            if (this._lastRange) {
                str += (this._lastRange.startLineNumber + '/' + this._lastRange.endLineNumber);
            }
            else {
                str += 'no range';
            }
            return str;
        };
        return CollapsibleRegion;
    }());
    var FoldingController = (function () {
        function FoldingController(editor) {
            var _this = this;
            this.editor = editor;
            this._isEnabled = this.editor.getConfiguration().contribInfo.folding;
            this.globalToDispose = [];
            this.localToDispose = [];
            this.decorations = [];
            this.computeToken = 0;
            this.globalToDispose.push(this.editor.onDidChangeModel(function () { return _this.onModelChanged(); }));
            this.globalToDispose.push(this.editor.onDidChangeConfiguration(function (e) {
                var oldIsEnabled = _this._isEnabled;
                _this._isEnabled = _this.editor.getConfiguration().contribInfo.folding;
                if (oldIsEnabled !== _this._isEnabled) {
                    _this.onModelChanged();
                }
            }));
            this.onModelChanged();
        }
        FoldingController.getFoldingController = function (editor) {
            return editor.getContribution(FoldingController.ID);
        };
        FoldingController.prototype.getId = function () {
            return FoldingController.ID;
        };
        FoldingController.prototype.dispose = function () {
            this.cleanState();
            this.globalToDispose = lifecycle_1.dispose(this.globalToDispose);
        };
        /**
         * Store view state.
         */
        FoldingController.prototype.saveViewState = function () {
            var model = this.editor.getModel();
            if (!model) {
                return {};
            }
            var collapsedRegions = [];
            this.decorations.forEach(function (d) {
                if (d.isCollapsed) {
                    var range = d.getDecorationRange(model);
                    if (range) {
                        collapsedRegions.push({ startLineNumber: range.startLineNumber, endLineNumber: range.endLineNumber, indent: d.indent, isCollapsed: true });
                    }
                }
            });
            return { collapsedRegions: collapsedRegions, lineCount: model.getLineCount() };
        };
        /**
         * Restore view state.
         */
        FoldingController.prototype.restoreViewState = function (state) {
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            if (!this._isEnabled) {
                return;
            }
            if (!state || !Array.isArray(state.collapsedRegions) || state.collapsedRegions.length === 0 || state.lineCount !== model.getLineCount()) {
                return;
            }
            this.applyRegions(state.collapsedRegions);
        };
        FoldingController.prototype.cleanState = function () {
            this.localToDispose = lifecycle_1.dispose(this.localToDispose);
        };
        FoldingController.prototype.applyRegions = function (regions) {
            var _this = this;
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            var updateHiddenRegions = false;
            regions = indentFoldStrategy_1.limitByIndent(regions, FoldingController.MAX_FOLDING_REGIONS).sort(function (r1, r2) { return r1.startLineNumber - r2.startLineNumber; });
            this.editor.changeDecorations(function (changeAccessor) {
                var newDecorations = [];
                var k = 0, i = 0;
                while (i < _this.decorations.length && k < regions.length) {
                    var dec = _this.decorations[i];
                    var decRange = dec.getDecorationRange(model);
                    if (!decRange) {
                        updateHiddenRegions = updateHiddenRegions || dec.isCollapsed;
                        dec.dispose(changeAccessor);
                        i++;
                    }
                    else {
                        while (k < regions.length && decRange.startLineNumber > regions[k].startLineNumber) {
                            var region = regions[k];
                            updateHiddenRegions = updateHiddenRegions || region.isCollapsed;
                            newDecorations.push(new CollapsibleRegion(region, model, changeAccessor));
                            k++;
                        }
                        if (k < regions.length) {
                            var currRange = regions[k];
                            if (decRange.startLineNumber < currRange.startLineNumber) {
                                updateHiddenRegions = updateHiddenRegions || dec.isCollapsed;
                                dec.dispose(changeAccessor);
                                i++;
                            }
                            else if (decRange.startLineNumber === currRange.startLineNumber) {
                                if (dec.isCollapsed && (dec.startLineNumber !== currRange.startLineNumber || dec.endLineNumber !== currRange.endLineNumber)) {
                                    updateHiddenRegions = true;
                                }
                                currRange.isCollapsed = dec.isCollapsed; // preserve collapse state
                                dec.update(currRange, model, changeAccessor);
                                newDecorations.push(dec);
                                i++;
                                k++;
                            }
                        }
                    }
                }
                while (i < _this.decorations.length) {
                    var dec = _this.decorations[i];
                    updateHiddenRegions = updateHiddenRegions || dec.isCollapsed;
                    dec.dispose(changeAccessor);
                    i++;
                }
                while (k < regions.length) {
                    var region = regions[k];
                    updateHiddenRegions = updateHiddenRegions || region.isCollapsed;
                    newDecorations.push(new CollapsibleRegion(region, model, changeAccessor));
                    k++;
                }
                _this.decorations = newDecorations;
            });
            if (updateHiddenRegions) {
                this.updateHiddenAreas(void 0);
            }
        };
        FoldingController.prototype.onModelChanged = function () {
            var _this = this;
            this.cleanState();
            var model = this.editor.getModel();
            if (!this._isEnabled || !model) {
                return;
            }
            this.contentChangedScheduler = new async_1.RunOnceScheduler(function () {
                var myToken = (++_this.computeToken);
                _this.computeCollapsibleRegions().then(function (regions) {
                    if (myToken !== _this.computeToken) {
                        return; // A new request was made in the meantime or the model was changed
                    }
                    _this.applyRegions(regions);
                });
            }, 200);
            this.cursorChangedScheduler = new async_1.RunOnceScheduler(function () {
                _this.revealCursor();
            }, 200);
            this.localToDispose.push(this.contentChangedScheduler);
            this.localToDispose.push(this.cursorChangedScheduler);
            this.localToDispose.push(this.editor.onDidChangeModelContent(function () {
                _this.contentChangedScheduler.schedule();
            }));
            this.localToDispose.push({ dispose: function () {
                    ++_this.computeToken;
                    _this.editor.changeDecorations(function (changeAccessor) {
                        _this.decorations.forEach(function (dec) { return dec.dispose(changeAccessor); });
                    });
                    _this.decorations = [];
                    _this.editor.setHiddenAreas([]);
                } });
            this.localToDispose.push(this.editor.onMouseDown(function (e) { return _this.onEditorMouseDown(e); }));
            this.localToDispose.push(this.editor.onMouseUp(function (e) { return _this.onEditorMouseUp(e); }));
            this.localToDispose.push(this.editor.onDidChangeCursorPosition(function (e) {
                _this.cursorChangedScheduler.schedule();
            }));
            this.contentChangedScheduler.schedule();
        };
        FoldingController.prototype.computeCollapsibleRegions = function () {
            var model = this.editor.getModel();
            if (!model) {
                return winjs_base_1.TPromise.as([]);
            }
            var tabSize = model.getOptions().tabSize;
            var ranges = indentFoldStrategy_1.computeRanges(model, tabSize);
            return winjs_base_1.TPromise.as(ranges);
        };
        FoldingController.prototype.revealCursor = function () {
            var _this = this;
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            var hasChanges = false;
            var position = this.editor.getPosition();
            var lineNumber = position.lineNumber;
            this.editor.changeDecorations(function (changeAccessor) {
                return _this.decorations.forEach(function (dec) {
                    if (dec.isCollapsed) {
                        var decRange = dec.getDecorationRange(model);
                        // reveal if cursor in in one of the collapsed line (not the first)
                        if (decRange && decRange.startLineNumber < lineNumber && lineNumber <= decRange.endLineNumber) {
                            dec.setCollapsed(false, changeAccessor);
                            hasChanges = true;
                        }
                    }
                });
            });
            if (hasChanges) {
                this.updateHiddenAreas(lineNumber);
            }
        };
        FoldingController.prototype.onEditorMouseDown = function (e) {
            this.mouseDownInfo = null;
            if (this.decorations.length === 0) {
                return;
            }
            var range = e.target.range;
            if (!range || !range.isEmpty) {
                return;
            }
            if (!e.event.leftButton) {
                return;
            }
            var model = this.editor.getModel();
            var iconClicked = false;
            switch (e.target.type) {
                case editorCommon.MouseTargetType.GUTTER_LINE_DECORATIONS:
                    iconClicked = true;
                    break;
                case editorCommon.MouseTargetType.CONTENT_TEXT:
                    if (range.isEmpty && range.startColumn === model.getLineMaxColumn(range.startLineNumber)) {
                        break;
                    }
                    return;
                default:
                    return;
            }
            this.mouseDownInfo = { lineNumber: range.startLineNumber, iconClicked: iconClicked };
        };
        FoldingController.prototype.onEditorMouseUp = function (e) {
            var _this = this;
            if (!this.mouseDownInfo) {
                return;
            }
            var lineNumber = this.mouseDownInfo.lineNumber;
            var iconClicked = this.mouseDownInfo.iconClicked;
            var range = e.target.range;
            if (!range || !range.isEmpty || range.startLineNumber !== lineNumber) {
                return;
            }
            var model = this.editor.getModel();
            if (iconClicked) {
                if (e.target.type !== editorCommon.MouseTargetType.GUTTER_LINE_DECORATIONS) {
                    return;
                }
            }
            else {
                if (range.startColumn !== model.getLineMaxColumn(lineNumber)) {
                    return;
                }
            }
            this.editor.changeDecorations(function (changeAccessor) {
                for (var i = 0; i < _this.decorations.length; i++) {
                    var dec = _this.decorations[i];
                    var decRange = dec.getDecorationRange(model);
                    if (decRange.startLineNumber === lineNumber) {
                        if (iconClicked || dec.isCollapsed) {
                            dec.setCollapsed(!dec.isCollapsed, changeAccessor);
                            _this.updateHiddenAreas(lineNumber);
                        }
                        return;
                    }
                }
            });
        };
        FoldingController.prototype.updateHiddenAreas = function (focusLine) {
            var model = this.editor.getModel();
            var selections = this.editor.getSelections();
            var updateSelections = false;
            var hiddenAreas = [];
            this.decorations.filter(function (dec) { return dec.isCollapsed; }).forEach(function (dec) {
                var decRange = dec.getDecorationRange(model);
                hiddenAreas.push({
                    startLineNumber: decRange.startLineNumber + 1,
                    startColumn: 1,
                    endLineNumber: decRange.endLineNumber,
                    endColumn: 1
                });
                selections.forEach(function (selection, i) {
                    if (range_1.Range.containsPosition(decRange, selection.getStartPosition())) {
                        selections[i] = selection = selection.setStartPosition(decRange.startLineNumber, model.getLineMaxColumn(decRange.startLineNumber));
                        updateSelections = true;
                    }
                    if (range_1.Range.containsPosition(decRange, selection.getEndPosition())) {
                        selections[i] = selection.setEndPosition(decRange.startLineNumber, model.getLineMaxColumn(decRange.startLineNumber));
                        updateSelections = true;
                    }
                });
            });
            var revealPosition;
            if (focusLine) {
                revealPosition = { lineNumber: focusLine, column: 1 };
            }
            else {
                revealPosition = selections[0].getStartPosition();
            }
            if (updateSelections) {
                this.editor.setSelections(selections);
            }
            this.editor.setHiddenAreas(hiddenAreas);
            this.editor.revealPositionInCenterIfOutsideViewport(revealPosition);
        };
        FoldingController.prototype.unfold = function () {
            var _this = this;
            var model = this.editor.getModel();
            var hasChanges = false;
            var selections = this.editor.getSelections();
            var selectionsHasChanged = false;
            selections.forEach(function (selection, index) {
                var lineNumber = selection.startLineNumber;
                var surroundingUnfolded;
                var _loop_1 = function(i, len) {
                    var dec = _this.decorations[i];
                    var decRange = dec.getDecorationRange(model);
                    if (!decRange) {
                        return "continue";
                    }
                    if (decRange.startLineNumber <= lineNumber) {
                        if (lineNumber <= decRange.endLineNumber) {
                            if (dec.isCollapsed) {
                                _this.editor.changeDecorations(function (changeAccessor) {
                                    dec.setCollapsed(false, changeAccessor);
                                    hasChanges = true;
                                });
                                return { value: void 0 };
                            }
                            surroundingUnfolded = decRange;
                        }
                    }
                    else {
                        if (surroundingUnfolded && range_1.Range.containsRange(surroundingUnfolded, decRange)) {
                            if (dec.isCollapsed) {
                                _this.editor.changeDecorations(function (changeAccessor) {
                                    dec.setCollapsed(false, changeAccessor);
                                    hasChanges = true;
                                    var lineNumber = decRange.startLineNumber, column = model.getLineMaxColumn(decRange.startLineNumber);
                                    selections[index] = selection.setEndPosition(lineNumber, column).setStartPosition(lineNumber, column);
                                    selectionsHasChanged = true;
                                });
                                return { value: void 0 };
                            }
                        }
                        else {
                            return { value: void 0 };
                        }
                    }
                };
                for (var i = 0, len = _this.decorations.length; i < len; i++) {
                    var state_1 = _loop_1(i, len);
                    if (typeof state_1 === "object") return state_1.value;
                    if (state_1 === "continue") continue;
                }
            });
            if (selectionsHasChanged) {
                this.editor.setSelections(selections);
            }
            if (hasChanges) {
                this.updateHiddenAreas(selections[0].startLineNumber);
            }
        };
        FoldingController.prototype.fold = function () {
            var _this = this;
            var hasChanges = false;
            var model = this.editor.getModel();
            var selections = this.editor.getSelections();
            selections.forEach(function (selection) {
                var lineNumber = selection.startLineNumber;
                var toFold = null;
                for (var i = 0, len = _this.decorations.length; i < len; i++) {
                    var dec = _this.decorations[i];
                    var decRange = dec.getDecorationRange(model);
                    if (!decRange) {
                        continue;
                    }
                    if (decRange.startLineNumber <= lineNumber) {
                        if (lineNumber <= decRange.endLineNumber && !dec.isCollapsed) {
                            toFold = dec;
                        }
                    }
                    else {
                        break;
                    }
                }
                ;
                if (toFold) {
                    _this.editor.changeDecorations(function (changeAccessor) {
                        toFold.setCollapsed(true, changeAccessor);
                        hasChanges = true;
                    });
                }
            });
            if (hasChanges) {
                this.updateHiddenAreas(selections[0].startLineNumber);
            }
        };
        FoldingController.prototype.foldUnfoldRecursively = function (isFold) {
            var _this = this;
            var hasChanges = false;
            var model = this.editor.getModel();
            var selections = this.editor.getSelections();
            selections.forEach(function (selection) {
                var lineNumber = selection.startLineNumber;
                var endLineNumber;
                var decToFoldUnfold = [];
                for (var i = 0, len = _this.decorations.length; i < len; i++) {
                    var dec = _this.decorations[i];
                    var decRange = dec.getDecorationRange(model);
                    if (!decRange) {
                        continue;
                    }
                    if (decRange.startLineNumber >= lineNumber && (decRange.endLineNumber <= endLineNumber || typeof endLineNumber === 'undefined')) {
                        //Protect against cursor not being in decoration and lower decoration folding/unfolding
                        if (decRange.startLineNumber !== lineNumber && typeof endLineNumber === 'undefined') {
                            return;
                        }
                        endLineNumber = endLineNumber || decRange.endLineNumber;
                        decToFoldUnfold.push(dec);
                    }
                }
                ;
                if (decToFoldUnfold.length > 0) {
                    decToFoldUnfold.forEach(function (dec) {
                        _this.editor.changeDecorations(function (changeAccessor) {
                            dec.setCollapsed(isFold, changeAccessor);
                            hasChanges = true;
                        });
                    });
                }
            });
            if (hasChanges) {
                this.updateHiddenAreas(selections[0].startLineNumber);
            }
        };
        FoldingController.prototype.changeAll = function (collapse) {
            var _this = this;
            if (this.decorations.length > 0) {
                var hasChanges_1 = true;
                this.editor.changeDecorations(function (changeAccessor) {
                    _this.decorations.forEach(function (d) {
                        if (collapse !== d.isCollapsed) {
                            d.setCollapsed(collapse, changeAccessor);
                            hasChanges_1 = true;
                        }
                    });
                });
                if (hasChanges_1) {
                    this.updateHiddenAreas(void 0);
                }
            }
        };
        FoldingController.prototype.foldLevel = function (foldLevel, selectedLineNumbers) {
            var _this = this;
            var model = this.editor.getModel();
            var foldingRegionStack = [model.getFullModelRange()]; // sentinel
            var hasChanges = false;
            this.editor.changeDecorations(function (changeAccessor) {
                _this.decorations.forEach(function (dec) {
                    var decRange = dec.getDecorationRange(model);
                    if (decRange) {
                        while (!range_1.Range.containsRange(foldingRegionStack[foldingRegionStack.length - 1], decRange)) {
                            foldingRegionStack.pop();
                        }
                        foldingRegionStack.push(decRange);
                        if (foldingRegionStack.length === foldLevel + 1 && !dec.isCollapsed && !selectedLineNumbers.some(function (lineNumber) { return decRange.startLineNumber < lineNumber && lineNumber <= decRange.endLineNumber; })) {
                            dec.setCollapsed(true, changeAccessor);
                            hasChanges = true;
                        }
                    }
                });
            });
            if (hasChanges) {
                this.updateHiddenAreas(selectedLineNumbers[0]);
            }
        };
        FoldingController.ID = 'editor.contrib.folding';
        FoldingController.MAX_FOLDING_REGIONS = 5000;
        return FoldingController;
    }());
    exports.FoldingController = FoldingController;
    var FoldingAction = (function (_super) {
        __extends(FoldingAction, _super);
        function FoldingAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.TextFocus);
        }
        FoldingAction.prototype.run = function () {
            var foldingController = FoldingController.getFoldingController(this.editor);
            this.invoke(foldingController);
            return winjs_base_1.TPromise.as(true);
        };
        return FoldingAction;
    }(editorAction_1.EditorAction));
    var UnfoldAction = (function (_super) {
        __extends(UnfoldAction, _super);
        function UnfoldAction() {
            _super.apply(this, arguments);
        }
        UnfoldAction.prototype.invoke = function (foldingController) {
            foldingController.unfold();
        };
        UnfoldAction.ID = 'editor.unfold';
        return UnfoldAction;
    }(FoldingAction));
    var UnFoldRecursivelyAction = (function (_super) {
        __extends(UnFoldRecursivelyAction, _super);
        function UnFoldRecursivelyAction() {
            _super.apply(this, arguments);
        }
        UnFoldRecursivelyAction.prototype.invoke = function (foldingController) {
            foldingController.foldUnfoldRecursively(false);
        };
        UnFoldRecursivelyAction.ID = 'editor.unFoldRecursively';
        return UnFoldRecursivelyAction;
    }(FoldingAction));
    var FoldAction = (function (_super) {
        __extends(FoldAction, _super);
        function FoldAction() {
            _super.apply(this, arguments);
        }
        FoldAction.prototype.invoke = function (foldingController) {
            foldingController.fold();
        };
        FoldAction.ID = 'editor.fold';
        return FoldAction;
    }(FoldingAction));
    var FoldRecursivelyAction = (function (_super) {
        __extends(FoldRecursivelyAction, _super);
        function FoldRecursivelyAction() {
            _super.apply(this, arguments);
        }
        FoldRecursivelyAction.prototype.invoke = function (foldingController) {
            foldingController.foldUnfoldRecursively(true);
        };
        FoldRecursivelyAction.ID = 'editor.foldRecursively';
        return FoldRecursivelyAction;
    }(FoldingAction));
    var FoldAllAction = (function (_super) {
        __extends(FoldAllAction, _super);
        function FoldAllAction() {
            _super.apply(this, arguments);
        }
        FoldAllAction.prototype.invoke = function (foldingController) {
            foldingController.changeAll(true);
        };
        FoldAllAction.ID = 'editor.foldAll';
        return FoldAllAction;
    }(FoldingAction));
    var UnfoldAllAction = (function (_super) {
        __extends(UnfoldAllAction, _super);
        function UnfoldAllAction() {
            _super.apply(this, arguments);
        }
        UnfoldAllAction.prototype.invoke = function (foldingController) {
            foldingController.changeAll(false);
        };
        UnfoldAllAction.ID = 'editor.unfoldAll';
        return UnfoldAllAction;
    }(FoldingAction));
    var FoldLevelAction = (function (_super) {
        __extends(FoldLevelAction, _super);
        function FoldLevelAction() {
            _super.apply(this, arguments);
        }
        FoldLevelAction.prototype.getFoldingLevel = function () {
            return parseInt(this.id.substr(FoldLevelAction.ID_PREFIX.length));
        };
        FoldLevelAction.prototype.getSelectedLines = function () {
            return this.editor.getSelections().map(function (s) { return s.startLineNumber; });
        };
        FoldLevelAction.prototype.invoke = function (foldingController) {
            foldingController.foldLevel(this.getFoldingLevel(), this.getSelectedLines());
        };
        FoldLevelAction.ID_PREFIX = 'editor.foldLevel';
        FoldLevelAction.ID = function (level) { return FoldLevelAction.ID_PREFIX + level; };
        return FoldLevelAction;
    }(FoldingAction));
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(FoldingController);
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(UnfoldAction, UnfoldAction.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.US_CLOSE_SQUARE_BRACKET
    }, 'Unfold'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(UnFoldRecursivelyAction, UnFoldRecursivelyAction.ID, nls.localize(1, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.chord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.US_CLOSE_SQUARE_BRACKET)
    }, 'Unfold Recursively'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(FoldAction, FoldAction.ID, nls.localize(2, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.US_OPEN_SQUARE_BRACKET
    }, 'Fold'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(FoldRecursivelyAction, FoldRecursivelyAction.ID, nls.localize(3, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.chord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.US_OPEN_SQUARE_BRACKET)
    }, 'Fold Recursively'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(FoldAllAction, FoldAllAction.ID, nls.localize(4, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.chord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_0)
    }, 'Fold All'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(UnfoldAllAction, UnfoldAllAction.ID, nls.localize(5, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.chord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_J)
    }, 'Unfold All'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(FoldLevelAction, FoldLevelAction.ID(1), nls.localize(6, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.chord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_1)
    }, 'Fold Level 1'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(FoldLevelAction, FoldLevelAction.ID(2), nls.localize(7, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.chord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_2)
    }, 'Fold Level 2'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(FoldLevelAction, FoldLevelAction.ID(3), nls.localize(8, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.chord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_3)
    }, 'Fold Level 3'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(FoldLevelAction, FoldLevelAction.ID(4), nls.localize(9, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.chord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_4)
    }, 'Fold Level 4'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(FoldLevelAction, FoldLevelAction.ID(5), nls.localize(10, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.chord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_5)
    }, 'Fold Level 5'));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[454], __M([0,1,8,29,2,4,13,17,34,14]), function (require, exports, errors_1, uri_1, winjs_base_1, range_1, editorCommonExtensions_1, modes_1, modelService_1, async_1) {
    'use strict';
    function getDocumentRangeFormattingEdits(model, range, options) {
        var support = modes_1.DocumentRangeFormattingEditProviderRegistry.ordered(model)[0];
        if (!support) {
            return winjs_base_1.TPromise.as(undefined);
        }
        return async_1.asWinJsPromise(function (token) {
            return support.provideDocumentRangeFormattingEdits(model, range, options, token);
        });
    }
    exports.getDocumentRangeFormattingEdits = getDocumentRangeFormattingEdits;
    function getDocumentFormattingEdits(model, options) {
        var support = modes_1.DocumentFormattingEditProviderRegistry.ordered(model)[0];
        if (!support) {
            return getDocumentRangeFormattingEdits(model, model.getFullModelRange(), options);
        }
        return async_1.asWinJsPromise(function (token) {
            return support.provideDocumentFormattingEdits(model, options, token);
        });
    }
    exports.getDocumentFormattingEdits = getDocumentFormattingEdits;
    function getOnTypeFormattingEdits(model, position, ch, options) {
        var support = modes_1.OnTypeFormattingEditProviderRegistry.ordered(model)[0];
        if (!support) {
            return winjs_base_1.TPromise.as(undefined);
        }
        if (support.autoFormatTriggerCharacters.indexOf(ch) < 0) {
            return winjs_base_1.TPromise.as(undefined);
        }
        return async_1.asWinJsPromise(function (token) {
            return support.provideOnTypeFormattingEdits(model, position, ch, options, token);
        });
    }
    exports.getOnTypeFormattingEdits = getOnTypeFormattingEdits;
    editorCommonExtensions_1.CommonEditorRegistry.registerLanguageCommand('_executeFormatRangeProvider', function (accessor, args) {
        var resource = args.resource, range = args.range, options = args.options;
        if (!(resource instanceof uri_1.default) || !range_1.Range.isIRange(range)) {
            throw errors_1.illegalArgument();
        }
        var model = accessor.get(modelService_1.IModelService).getModel(resource);
        if (!model) {
            throw errors_1.illegalArgument('resource');
        }
        return getDocumentRangeFormattingEdits(model, range_1.Range.lift(range), options);
    });
    editorCommonExtensions_1.CommonEditorRegistry.registerLanguageCommand('_executeFormatDocumentProvider', function (accessor, args) {
        var resource = args.resource, options = args.options;
        if (!(resource instanceof uri_1.default)) {
            throw errors_1.illegalArgument('resource');
        }
        var model = accessor.get(modelService_1.IModelService).getModel(resource);
        if (!model) {
            throw errors_1.illegalArgument('resource');
        }
        return getDocumentFormattingEdits(model, options);
    });
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeFormatOnTypeProvider', function (model, position, args) {
        var ch = args.ch, options = args.options;
        if (typeof ch !== 'string') {
            throw errors_1.illegalArgument('ch');
        }
        return getOnTypeFormattingEdits(model, position, ch, options);
    });
});






define(__m[455], __M([0,1,331,37,12,3,2,20,25,7,13,17,454,494]), function (require, exports, nls, arrays, keyCodes_1, lifecycle_1, winjs_base_1, editorAction_1, editorActionEnablement_1, editorCommon, editorCommonExtensions_1, modes_1, format_1, formatCommand_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var FormatOnType = (function () {
        function FormatOnType(editor) {
            var _this = this;
            this.editor = editor;
            this.callOnDispose = [];
            this.callOnModel = [];
            this.callOnDispose.push(editor.onDidChangeConfiguration(function () { return _this.update(); }));
            this.callOnDispose.push(editor.onDidChangeModel(function () { return _this.update(); }));
            this.callOnDispose.push(editor.onDidChangeModelMode(function () { return _this.update(); }));
            this.callOnDispose.push(modes_1.OnTypeFormattingEditProviderRegistry.onDidChange(this.update, this));
        }
        FormatOnType.prototype.update = function () {
            var _this = this;
            // clean up
            this.callOnModel = lifecycle_1.dispose(this.callOnModel);
            // we are disabled
            if (!this.editor.getConfiguration().contribInfo.formatOnType) {
                return;
            }
            // no model
            if (!this.editor.getModel()) {
                return;
            }
            var model = this.editor.getModel();
            // no support
            var support = modes_1.OnTypeFormattingEditProviderRegistry.ordered(model)[0];
            if (!support || !support.autoFormatTriggerCharacters) {
                return;
            }
            // register typing listeners that will trigger the format
            support.autoFormatTriggerCharacters.forEach(function (ch) {
                _this.callOnModel.push(_this.editor.addTypingListener(ch, _this.trigger.bind(_this, ch)));
            });
        };
        FormatOnType.prototype.trigger = function (ch) {
            var _this = this;
            if (this.editor.getSelections().length > 1) {
                return;
            }
            var model = this.editor.getModel(), position = this.editor.getPosition(), canceled = false;
            // install a listener that checks if edits happens before the
            // position on which we format right now. Iff so, we won't
            // apply the format edits
            var unbind = this.editor.onDidChangeModelRawContent(function (e) {
                if (e.changeType === editorCommon.EventType.ModelRawContentChangedFlush) {
                    // a model.setValue() was called
                    canceled = true;
                }
                else if (e.changeType === editorCommon.EventType.ModelRawContentChangedLineChanged) {
                    var changedLine = e.lineNumber;
                    canceled = changedLine <= position.lineNumber;
                }
                else if (e.changeType === editorCommon.EventType.ModelRawContentChangedLinesInserted) {
                    var insertLine = e.fromLineNumber;
                    canceled = insertLine <= position.lineNumber;
                }
                else if (e.changeType === editorCommon.EventType.ModelRawContentChangedLinesDeleted) {
                    var deleteLine2 = e.toLineNumber;
                    canceled = deleteLine2 <= position.lineNumber;
                }
                if (canceled) {
                    // cancel only once
                    unbind.dispose();
                }
            });
            var modelOpts = model.getOptions();
            format_1.getOnTypeFormattingEdits(model, position, ch, {
                tabSize: modelOpts.tabSize,
                insertSpaces: modelOpts.insertSpaces
            }).then(function (edits) {
                unbind.dispose();
                if (canceled || arrays.isFalsyOrEmpty(edits)) {
                    return;
                }
                _this.editor.executeCommand(_this.getId(), new formatCommand_1.EditOperationsCommand(edits, _this.editor.getSelection()));
            }, function (err) {
                unbind.dispose();
                throw err;
            });
        };
        FormatOnType.prototype.getId = function () {
            return FormatOnType.ID;
        };
        FormatOnType.prototype.dispose = function () {
            this.callOnDispose = lifecycle_1.dispose(this.callOnDispose);
            this.callOnModel = lifecycle_1.dispose(this.callOnModel);
        };
        FormatOnType.ID = 'editor.contrib.autoFormat';
        return FormatOnType;
    }());
    var FormatAction = (function (_super) {
        __extends(FormatAction, _super);
        function FormatAction(descriptor, editor) {
            var _this = this;
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.WidgetFocus | editorActionEnablement_1.Behaviour.Writeable | editorActionEnablement_1.Behaviour.UpdateOnModelChange | editorActionEnablement_1.Behaviour.ShowInContextMenu);
            this._disposables = [
                modes_1.DocumentFormattingEditProviderRegistry.onDidChange(function () { return _this.resetEnablementState(); }),
                modes_1.DocumentRangeFormattingEditProviderRegistry.onDidChange(function () { return _this.resetEnablementState(); })
            ];
        }
        FormatAction.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._disposables = lifecycle_1.dispose(this._disposables);
        };
        FormatAction.prototype.getGroupId = function () {
            return '2_change/2_format';
        };
        FormatAction.prototype.isSupported = function () {
            return ((modes_1.DocumentFormattingEditProviderRegistry.has(this.editor.getModel())
                || modes_1.DocumentRangeFormattingEditProviderRegistry.has(this.editor.getModel()))
                && _super.prototype.isSupported.call(this));
        };
        FormatAction.prototype.run = function () {
            var _this = this;
            var model = this.editor.getModel(), editorSelection = this.editor.getSelection(), modelOpts = model.getOptions(), options = {
                tabSize: modelOpts.tabSize,
                insertSpaces: modelOpts.insertSpaces,
            };
            var formattingPromise;
            if (editorSelection.isEmpty()) {
                formattingPromise = format_1.getDocumentFormattingEdits(model, options);
            }
            else {
                formattingPromise = format_1.getDocumentRangeFormattingEdits(model, editorSelection, options);
            }
            if (!formattingPromise) {
                return winjs_base_1.TPromise.as(false);
            }
            // Capture the state of the editor
            var state = this.editor.captureState(editorCommon.CodeEditorStateFlag.Value, editorCommon.CodeEditorStateFlag.Position);
            // Receive formatted value from worker
            return formattingPromise.then(function (result) {
                if (!state.validate(_this.editor)) {
                    return false;
                }
                if (!result || result.length === 0) {
                    return false;
                }
                _this.apply(_this.editor, editorSelection, result);
                _this.editor.focus();
                return true;
            });
        };
        FormatAction.prototype.apply = function (editor, editorSelection, value) {
            var state = null;
            if (editorSelection.isEmpty()) {
                state = editor.saveViewState();
            }
            var command = new formatCommand_1.EditOperationsCommand(value, editorSelection);
            editor.executeCommand(this.id, command);
            if (state) {
                editor.restoreViewState(state);
            }
        };
        FormatAction.ID = 'editor.action.format';
        return FormatAction;
    }(editorAction_1.EditorAction));
    exports.FormatAction = FormatAction;
    // register action
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(FormatAction, FormatAction.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_F,
        linux: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_I }
    }, 'Format Code'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorContribution(FormatOnType);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[456], __M([0,1,8,2,13,17,14]), function (require, exports, errors_1, winjs_base_1, editorCommonExtensions_1, modes_1, async_1) {
    'use strict';
    function getDeclarationsAtPosition(model, position) {
        var provider = modes_1.DefinitionProviderRegistry.ordered(model);
        // get results
        var promises = provider.map(function (provider, idx) {
            return async_1.asWinJsPromise(function (token) {
                return provider.provideDefinition(model, position, token);
            }).then(function (result) {
                return result;
            }, function (err) {
                errors_1.onUnexpectedError(err);
            });
        });
        return winjs_base_1.TPromise.join(promises).then(function (allReferences) {
            var result = [];
            for (var _i = 0, allReferences_1 = allReferences; _i < allReferences_1.length; _i++) {
                var references = allReferences_1[_i];
                if (Array.isArray(references)) {
                    result.push.apply(result, references);
                }
                else if (references) {
                    result.push(references);
                }
            }
            return result;
        });
    }
    exports.getDeclarationsAtPosition = getDeclarationsAtPosition;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeDefinitionProvider', getDeclarationsAtPosition);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[457], __M([0,1,37,8,2,13,17,14]), function (require, exports, arrays_1, errors_1, winjs_base_1, editorCommonExtensions_1, modes_1, async_1) {
    'use strict';
    function getHover(model, position) {
        var supports = modes_1.HoverProviderRegistry.ordered(model);
        var values = [];
        var promises = supports.map(function (support, idx) {
            return async_1.asWinJsPromise(function (token) {
                return support.provideHover(model, position, token);
            }).then(function (result) {
                if (result) {
                    var hasRange = (typeof result.range !== 'undefined');
                    var hasHtmlContent = (typeof result.contents !== 'undefined' && result.contents && result.contents.length > 0);
                    if (hasRange && hasHtmlContent) {
                        values[idx] = result;
                    }
                }
            }, function (err) {
                errors_1.onUnexpectedError(err);
            });
        });
        return winjs_base_1.TPromise.join(promises).then(function () { return arrays_1.coalesce(values); });
    }
    exports.getHover = getHover;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeHoverProvider', getHover);
});






define(__m[458], __M([0,1,335,29,2,71,147,4,21,17,393,457,129,162,92,136]), function (require, exports, nls, uri_1, winjs_base_1, htmlContentRenderer_1, opener_1, range_1, position_1, modes_1, textToHtmlTokenizer_1, hover_1, hoverOperation_1, hoverWidgets_1, htmlContent_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ModesContentComputer = (function () {
        function ModesContentComputer(editor) {
            this._editor = editor;
            this._range = null;
        }
        ModesContentComputer.prototype.setRange = function (range) {
            this._range = range;
            this._result = [];
        };
        ModesContentComputer.prototype.clearResult = function () {
            this._result = [];
        };
        ModesContentComputer.prototype.computeAsync = function () {
            var model = this._editor.getModel();
            if (!modes_1.HoverProviderRegistry.has(model)) {
                return winjs_base_1.TPromise.as(null);
            }
            return hover_1.getHover(model, new position_1.Position(this._range.startLineNumber, this._range.startColumn));
        };
        ModesContentComputer.prototype.computeSync = function () {
            var _this = this;
            var result = [];
            var lineNumber = this._range.startLineNumber;
            if (lineNumber > this._editor.getModel().getLineCount()) {
                // Illegal line number => no results
                return result;
            }
            var hasHoverContent = function (contents) {
                return contents && (!Array.isArray(contents) || contents.length > 0);
            };
            var lineDecorations = this._editor.getLineDecorations(lineNumber);
            var maxColumn = this._editor.getModel().getLineMaxColumn(lineNumber);
            lineDecorations.forEach(function (d) {
                var startColumn = (d.range.startLineNumber === lineNumber) ? d.range.startColumn : 1;
                var endColumn = (d.range.endLineNumber === lineNumber) ? d.range.endColumn : maxColumn;
                if (startColumn <= _this._range.startColumn && _this._range.endColumn <= endColumn && hasHoverContent(d.options.hoverMessage)) {
                    var obj = {
                        contents: [],
                        range: new range_1.Range(_this._range.startLineNumber, startColumn, _this._range.startLineNumber, endColumn)
                    };
                    if (d.options.hoverMessage) {
                        if (Array.isArray(d.options.hoverMessage)) {
                            obj.contents = obj.contents.concat(d.options.hoverMessage);
                        }
                        else {
                            obj.contents.push(d.options.hoverMessage);
                        }
                    }
                    result.push(obj);
                }
            });
            return result;
        };
        ModesContentComputer.prototype.onResult = function (result, isFromSynchronousComputation) {
            // Always put synchronous messages before asynchronous ones
            if (isFromSynchronousComputation) {
                this._result = result.concat(this._result);
            }
            else {
                this._result = this._result.concat(result);
            }
        };
        ModesContentComputer.prototype.getResult = function () {
            return this._result.slice(0);
        };
        ModesContentComputer.prototype.getResultWithLoadingMessage = function () {
            return this._result.slice(0).concat([this._getLoadingMessage()]);
        };
        ModesContentComputer.prototype._getLoadingMessage = function () {
            return {
                range: this._range,
                contents: [htmlContent_1.textToMarkedString(nls.localize(0, null))]
            };
        };
        return ModesContentComputer;
    }());
    var ModesContentHoverWidget = (function (_super) {
        __extends(ModesContentHoverWidget, _super);
        function ModesContentHoverWidget(editor, openerService, modeService) {
            var _this = this;
            _super.call(this, ModesContentHoverWidget.ID, editor);
            this._computer = new ModesContentComputer(this._editor);
            this._highlightDecorations = [];
            this._isChangingDecorations = false;
            this._openerService = openerService || opener_1.NullOpenerService;
            this._modeService = modeService;
            this._hoverOperation = new hoverOperation_1.HoverOperation(this._computer, function (result) { return _this._withResult(result, true); }, null, function (result) { return _this._withResult(result, false); });
        }
        ModesContentHoverWidget.prototype.dispose = function () {
            this._hoverOperation.cancel();
            _super.prototype.dispose.call(this);
        };
        ModesContentHoverWidget.prototype.onModelDecorationsChanged = function () {
            if (this._isChangingDecorations) {
                return;
            }
            if (this._isVisible) {
                // The decorations have changed and the hover is visible,
                // we need to recompute the displayed text
                this._hoverOperation.cancel();
                this._computer.clearResult();
                this._hoverOperation.start();
            }
        };
        ModesContentHoverWidget.prototype.startShowingAt = function (range, focus) {
            if (this._lastRange) {
                if (this._lastRange.equalsRange(range)) {
                    // We have to show the widget at the exact same range as before, so no work is needed
                    return;
                }
            }
            this._hoverOperation.cancel();
            if (this._isVisible) {
                // The range might have changed, but the hover is visible
                // Instead of hiding it completely, filter out messages that are still in the new range and
                // kick off a new computation
                if (this._showAtPosition.lineNumber !== range.startLineNumber) {
                    this.hide();
                }
                else {
                    var filteredMessages = [];
                    for (var i = 0, len = this._messages.length; i < len; i++) {
                        var msg = this._messages[i];
                        var rng = msg.range;
                        if (rng.startColumn <= range.startColumn && rng.endColumn >= range.endColumn) {
                            filteredMessages.push(msg);
                        }
                    }
                    if (filteredMessages.length > 0) {
                        this._renderMessages(range, filteredMessages);
                    }
                    else {
                        this.hide();
                    }
                }
            }
            this._lastRange = range;
            this._computer.setRange(range);
            this._shouldFocus = focus;
            this._hoverOperation.start();
        };
        ModesContentHoverWidget.prototype.hide = function () {
            this._lastRange = null;
            this._hoverOperation.cancel();
            _super.prototype.hide.call(this);
            this._isChangingDecorations = true;
            this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, []);
            this._isChangingDecorations = false;
        };
        ModesContentHoverWidget.prototype._withResult = function (result, complete) {
            this._messages = result;
            if (this._lastRange && this._messages.length > 0) {
                this._renderMessages(this._lastRange, this._messages);
            }
            else if (complete) {
                this.hide();
            }
        };
        ModesContentHoverWidget.prototype._renderMessages = function (renderRange, messages) {
            var _this = this;
            // update column from which to show
            var renderColumn = Number.MAX_VALUE, highlightRange = messages[0].range, fragment = document.createDocumentFragment();
            messages.forEach(function (msg) {
                if (!msg.range) {
                    return;
                }
                renderColumn = Math.min(renderColumn, msg.range.startColumn);
                highlightRange = range_1.Range.plusRange(highlightRange, msg.range);
                var row = document.createElement('div');
                var container = row;
                if (msg.contents && msg.contents.length > 0) {
                    container.appendChild(htmlContentRenderer_1.renderMarkedString(msg.contents, {
                        actionCallback: function (content) {
                            _this._openerService.open(uri_1.default.parse(content));
                        },
                        codeBlockRenderer: function (modeId, value) {
                            var mode = _this._modeService.getMode(modeId);
                            if (mode) {
                                return textToHtmlTokenizer_1.tokenizeToString(value, mode);
                            }
                            return _this._modeService.getOrCreateMode(modeId).then(function (mode) { return textToHtmlTokenizer_1.tokenizeToString(value, mode); }, function (err) { return textToHtmlTokenizer_1.tokenizeToString(value, null); });
                        }
                    }));
                }
                fragment.appendChild(row);
            });
            this._domNode.textContent = '';
            this._domNode.appendChild(fragment);
            // show
            this.showAt({
                lineNumber: renderRange.startLineNumber,
                column: renderColumn
            }, this._shouldFocus);
            this._isChangingDecorations = true;
            this._highlightDecorations = this._editor.deltaDecorations(this._highlightDecorations, [{
                    range: highlightRange,
                    options: {
                        className: 'hoverHighlight'
                    }
                }]);
            this._isChangingDecorations = false;
        };
        ModesContentHoverWidget.ID = 'editor.contrib.modesContentHoverWidget';
        return ModesContentHoverWidget;
    }(hoverWidgets_1.ContentHoverWidget));
    exports.ModesContentHoverWidget = ModesContentHoverWidget;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[459], __M([0,1,334,12,18,2,147,72,19,4,20,25,7,13,30,458,286,3,219]), function (require, exports, nls, keyCodes_1, platform, winjs_base_1, opener_1, modeService_1, keybindingService_1, range_1, editorAction_1, editorActionEnablement_1, editorCommon, editorCommonExtensions_1, editorBrowserExtensions_1, modesContentHover_1, modesGlyphHover_1, lifecycle_1) {
    'use strict';
    var ModesHoverController = (function () {
        function ModesHoverController(editor, openerService, modeService) {
            var _this = this;
            this._editor = editor;
            this._toUnhook = [];
            if (editor.getConfiguration().contribInfo.hover) {
                this._toUnhook.push(this._editor.onMouseDown(function (e) { return _this._onEditorMouseDown(e); }));
                this._toUnhook.push(this._editor.onMouseMove(function (e) { return _this._onEditorMouseMove(e); }));
                this._toUnhook.push(this._editor.onMouseLeave(function (e) { return _this._hideWidgets(); }));
                this._toUnhook.push(this._editor.onKeyDown(function (e) { return _this._onKeyDown(e); }));
                this._toUnhook.push(this._editor.onDidChangeModel(function () { return _this._hideWidgets(); }));
                this._toUnhook.push(this._editor.onDidChangeModelDecorations(function () { return _this._onModelDecorationsChanged(); }));
                this._toUnhook.push(this._editor.onDidScrollChange(function (e) {
                    if (e.scrollTopChanged || e.scrollLeftChanged) {
                        _this._hideWidgets();
                    }
                }));
                this._contentWidget = new modesContentHover_1.ModesContentHoverWidget(editor, openerService, modeService);
                this._glyphWidget = new modesGlyphHover_1.ModesGlyphHoverWidget(editor);
            }
        }
        ModesHoverController.getModesHoverController = function (editor) {
            return editor.getContribution(ModesHoverController.ID);
        };
        ModesHoverController.prototype._onModelDecorationsChanged = function () {
            this._contentWidget.onModelDecorationsChanged();
            this._glyphWidget.onModelDecorationsChanged();
        };
        ModesHoverController.prototype._onEditorMouseDown = function (mouseEvent) {
            var targetType = mouseEvent.target.type;
            if (targetType === editorCommon.MouseTargetType.CONTENT_WIDGET && mouseEvent.target.detail === modesContentHover_1.ModesContentHoverWidget.ID) {
                // mouse down on top of content hover widget
                return;
            }
            if (targetType === editorCommon.MouseTargetType.OVERLAY_WIDGET && mouseEvent.target.detail === modesGlyphHover_1.ModesGlyphHoverWidget.ID) {
                // mouse down on top of overlay hover widget
                return;
            }
            this._hideWidgets();
        };
        ModesHoverController.prototype._onEditorMouseMove = function (mouseEvent) {
            var targetType = mouseEvent.target.type;
            var stopKey = platform.isMacintosh ? 'metaKey' : 'ctrlKey';
            if (targetType === editorCommon.MouseTargetType.CONTENT_WIDGET && mouseEvent.target.detail === modesContentHover_1.ModesContentHoverWidget.ID && !mouseEvent.event[stopKey]) {
                // mouse moved on top of content hover widget
                return;
            }
            if (targetType === editorCommon.MouseTargetType.OVERLAY_WIDGET && mouseEvent.target.detail === modesGlyphHover_1.ModesGlyphHoverWidget.ID && !mouseEvent.event[stopKey]) {
                // mouse moved on top of overlay hover widget
                return;
            }
            if (this._editor.getConfiguration().contribInfo.hover && targetType === editorCommon.MouseTargetType.CONTENT_TEXT) {
                this._glyphWidget.hide();
                this._contentWidget.startShowingAt(mouseEvent.target.range, false);
            }
            else if (targetType === editorCommon.MouseTargetType.GUTTER_GLYPH_MARGIN) {
                this._contentWidget.hide();
                this._glyphWidget.startShowingAt(mouseEvent.target.position.lineNumber);
            }
            else {
                this._hideWidgets();
            }
        };
        ModesHoverController.prototype._onKeyDown = function (e) {
            var stopKey = platform.isMacintosh ? keyCodes_1.KeyCode.Meta : keyCodes_1.KeyCode.Ctrl;
            if (e.keyCode !== stopKey) {
                // Do not hide hover when Ctrl/Meta is pressed
                this._hideWidgets();
            }
        };
        ModesHoverController.prototype._hideWidgets = function () {
            this._glyphWidget.hide();
            this._contentWidget.hide();
        };
        ModesHoverController.prototype.showContentHover = function (range, focus) {
            this._contentWidget.startShowingAt(range, focus);
        };
        ModesHoverController.prototype.getId = function () {
            return ModesHoverController.ID;
        };
        ModesHoverController.prototype.dispose = function () {
            this._toUnhook = lifecycle_1.dispose(this._toUnhook);
            if (this._glyphWidget) {
                this._glyphWidget.dispose();
                this._glyphWidget = null;
            }
            if (this._contentWidget) {
                this._contentWidget.dispose();
                this._contentWidget = null;
            }
        };
        ModesHoverController.ID = 'editor.contrib.hover';
        ModesHoverController = __decorate([
            __param(1, opener_1.IOpenerService),
            __param(2, modeService_1.IModeService)
        ], ModesHoverController);
        return ModesHoverController;
    }());
    var ShowHoverAction = (function (_super) {
        __extends(ShowHoverAction, _super);
        function ShowHoverAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.TextFocus);
        }
        ShowHoverAction.prototype.run = function () {
            var position = this.editor.getPosition();
            var range = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
            this.editor.getContribution(ModesHoverController.ID).showContentHover(range, true);
            return winjs_base_1.TPromise.as(null);
        };
        ShowHoverAction.ID = 'editor.action.showHover';
        return ShowHoverAction;
    }(editorAction_1.EditorAction));
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(ModesHoverController);
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(ShowHoverAction, ShowHoverAction.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        kbExpr: keybindingService_1.KbExpr.has(editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS),
        primary: keyCodes_1.KeyMod.chord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_I)
    }, 'Show Hover'));
});















define(__m[460], __M([0,1,336,12,2,4,20,7,13,52,498]), function (require, exports, nls, keyCodes_1, winjs_base_1, range_1, editorAction_1, editorCommon_1, editorCommonExtensions_1, editorWorkerService_1, inPlaceReplaceCommand_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var InPlaceReplace = (function (_super) {
        __extends(InPlaceReplace, _super);
        function InPlaceReplace(descriptor, editor, up, editorWorkerService) {
            _super.call(this, descriptor, editor);
            this.editorWorkerService = editorWorkerService;
            this.up = up;
            this.requestIdPool = 0;
            this.currentRequest = winjs_base_1.TPromise.as(null);
            this.decorationRemover = winjs_base_1.TPromise.as(null);
            this.decorationIds = [];
        }
        InPlaceReplace.prototype.run = function () {
            var _this = this;
            // cancel any pending request
            this.currentRequest.cancel();
            var selection = this.editor.getSelection(), model = this.editor.getModel(), support = model.getMode().inplaceReplaceSupport, modelURI = model.uri;
            if (selection.startLineNumber !== selection.endLineNumber) {
                // Can't accept multiline selection
                return null;
            }
            var state = this.editor.captureState(editorCommon_1.CodeEditorStateFlag.Value, editorCommon_1.CodeEditorStateFlag.Position);
            this.currentRequest = this.editorWorkerService.navigateValueSet(modelURI, selection, this.up);
            this.currentRequest = this.currentRequest.then(function (basicResult) {
                if (basicResult && basicResult.range && basicResult.value) {
                    return basicResult;
                }
                if (support) {
                    return support.navigateValueSet(modelURI, selection, _this.up);
                }
                return null;
            });
            return this.currentRequest.then(function (result) {
                if (!result || !result.range || !result.value) {
                    // No proper result
                    return;
                }
                if (!state.validate(_this.editor)) {
                    // state has changed
                    return;
                }
                // Selection
                var editRange = range_1.Range.lift(result.range), highlightRange = result.range, diff = result.value.length - (selection.endColumn - selection.startColumn);
                // highlight
                highlightRange.endColumn = highlightRange.startColumn + result.value.length;
                selection.endColumn += diff > 1 ? (diff - 1) : 0;
                // Insert new text
                var command = new inPlaceReplaceCommand_1.InPlaceReplaceCommand(editRange, selection, result.value);
                _this.editor.executeCommand(_this.id, command);
                // add decoration
                _this.decorationIds = _this.editor.deltaDecorations(_this.decorationIds, [{
                        range: highlightRange,
                        options: InPlaceReplace.DECORATION
                    }]);
                // remove decoration after delay
                _this.decorationRemover.cancel();
                _this.decorationRemover = winjs_base_1.TPromise.timeout(350);
                _this.decorationRemover.then(function () {
                    _this.editor.changeDecorations(function (accessor) {
                        _this.decorationIds = accessor.deltaDecorations(_this.decorationIds, []);
                    });
                });
                return true;
            });
        };
        InPlaceReplace.DECORATION = {
            className: 'valueSetReplacement'
        };
        InPlaceReplace = __decorate([
            __param(3, editorWorkerService_1.IEditorWorkerService)
        ], InPlaceReplace);
        return InPlaceReplace;
    }(editorAction_1.EditorAction));
    var InPlaceReplaceUp = (function (_super) {
        __extends(InPlaceReplaceUp, _super);
        function InPlaceReplaceUp(descriptor, editor, editorWorkerService) {
            _super.call(this, descriptor, editor, true, editorWorkerService);
        }
        InPlaceReplaceUp.ID = 'editor.action.inPlaceReplace.up';
        InPlaceReplaceUp = __decorate([
            __param(2, editorWorkerService_1.IEditorWorkerService)
        ], InPlaceReplaceUp);
        return InPlaceReplaceUp;
    }(InPlaceReplace));
    var InPlaceReplaceDown = (function (_super) {
        __extends(InPlaceReplaceDown, _super);
        function InPlaceReplaceDown(descriptor, editor, editorWorkerService) {
            _super.call(this, descriptor, editor, false, editorWorkerService);
        }
        InPlaceReplaceDown.ID = 'editor.action.inPlaceReplace.down';
        InPlaceReplaceDown = __decorate([
            __param(2, editorWorkerService_1.IEditorWorkerService)
        ], InPlaceReplaceDown);
        return InPlaceReplaceDown;
    }(InPlaceReplace));
    // register actions
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(InPlaceReplaceUp, InPlaceReplaceUp.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.US_COMMA
    }, 'Replace with Previous Value'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(InPlaceReplaceDown, InPlaceReplaceDown.ID, nls.localize(1, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.US_DOT
    }, 'Replace with Next Value'));
});






define(__m[461], __M([0,1,338,12,2,505,261,20,7,13,500,501,502]), function (require, exports, nls, keyCodes_1, winjs_base_1, sortLinesCommand_1, trimTrailingWhitespaceCommand_1, editorAction_1, editorCommon_1, editorCommonExtensions_1, copyLinesCommand_1, deleteLinesCommand_1, moveLinesCommand_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // copy lines
    var CopyLinesAction = (function (_super) {
        __extends(CopyLinesAction, _super);
        function CopyLinesAction(descriptor, editor, down) {
            _super.call(this, descriptor, editor);
            this.down = down;
        }
        CopyLinesAction.prototype.run = function () {
            var commands = [];
            var selections = this.editor.getSelections();
            for (var i = 0; i < selections.length; i++) {
                commands.push(new copyLinesCommand_1.CopyLinesCommand(selections[i], this.down));
            }
            this.editor.executeCommands(this.id, commands);
            return winjs_base_1.TPromise.as(true);
        };
        return CopyLinesAction;
    }(editorAction_1.EditorAction));
    var CopyLinesUpAction = (function (_super) {
        __extends(CopyLinesUpAction, _super);
        function CopyLinesUpAction(descriptor, editor) {
            _super.call(this, descriptor, editor, false);
        }
        CopyLinesUpAction.ID = 'editor.action.copyLinesUpAction';
        return CopyLinesUpAction;
    }(CopyLinesAction));
    var CopyLinesDownAction = (function (_super) {
        __extends(CopyLinesDownAction, _super);
        function CopyLinesDownAction(descriptor, editor) {
            _super.call(this, descriptor, editor, true);
        }
        CopyLinesDownAction.ID = 'editor.action.copyLinesDownAction';
        return CopyLinesDownAction;
    }(CopyLinesAction));
    // move lines
    var MoveLinesAction = (function (_super) {
        __extends(MoveLinesAction, _super);
        function MoveLinesAction(descriptor, editor, down) {
            _super.call(this, descriptor, editor);
            this.down = down;
        }
        MoveLinesAction.prototype.run = function () {
            var commands = [];
            var selections = this.editor.getSelections();
            for (var i = 0; i < selections.length; i++) {
                commands.push(new moveLinesCommand_1.MoveLinesCommand(selections[i], this.down));
            }
            this.editor.executeCommands(this.id, commands);
            return winjs_base_1.TPromise.as(true);
        };
        return MoveLinesAction;
    }(editorAction_1.EditorAction));
    var MoveLinesUpAction = (function (_super) {
        __extends(MoveLinesUpAction, _super);
        function MoveLinesUpAction(descriptor, editor) {
            _super.call(this, descriptor, editor, false);
        }
        MoveLinesUpAction.ID = 'editor.action.moveLinesUpAction';
        return MoveLinesUpAction;
    }(MoveLinesAction));
    var MoveLinesDownAction = (function (_super) {
        __extends(MoveLinesDownAction, _super);
        function MoveLinesDownAction(descriptor, editor) {
            _super.call(this, descriptor, editor, true);
        }
        MoveLinesDownAction.ID = 'editor.action.moveLinesDownAction';
        return MoveLinesDownAction;
    }(MoveLinesAction));
    var SortLinesAction = (function (_super) {
        __extends(SortLinesAction, _super);
        function SortLinesAction(descriptor, editor, descending) {
            _super.call(this, descriptor, editor);
            this.descending = descending;
        }
        SortLinesAction.prototype.run = function () {
            var command = new sortLinesCommand_1.SortLinesCommand(this.editor.getSelection(), this.descending);
            this.editor.executeCommands(this.id, [command]);
            return winjs_base_1.TPromise.as(true);
        };
        return SortLinesAction;
    }(editorAction_1.EditorAction));
    var SortLinesAscendingAction = (function (_super) {
        __extends(SortLinesAscendingAction, _super);
        function SortLinesAscendingAction(descriptor, editor) {
            _super.call(this, descriptor, editor, false);
        }
        SortLinesAscendingAction.ID = 'editor.action.sortLinesAscending';
        return SortLinesAscendingAction;
    }(SortLinesAction));
    var SortLinesDescendingAction = (function (_super) {
        __extends(SortLinesDescendingAction, _super);
        function SortLinesDescendingAction(descriptor, editor) {
            _super.call(this, descriptor, editor, true);
        }
        SortLinesDescendingAction.ID = 'editor.action.sortLinesDescending';
        return SortLinesDescendingAction;
    }(SortLinesAction));
    var TrimTrailingWhitespaceAction = (function (_super) {
        __extends(TrimTrailingWhitespaceAction, _super);
        function TrimTrailingWhitespaceAction(descriptor, editor) {
            _super.call(this, descriptor, editor);
        }
        TrimTrailingWhitespaceAction.prototype.run = function () {
            var command = new trimTrailingWhitespaceCommand_1.TrimTrailingWhitespaceCommand(this.editor.getSelection());
            this.editor.executeCommands(this.id, [command]);
            return winjs_base_1.TPromise.as(true);
        };
        TrimTrailingWhitespaceAction.ID = 'editor.action.trimTrailingWhitespace';
        return TrimTrailingWhitespaceAction;
    }(editorAction_1.EditorAction));
    exports.TrimTrailingWhitespaceAction = TrimTrailingWhitespaceAction;
    var AbstractRemoveLinesAction = (function (_super) {
        __extends(AbstractRemoveLinesAction, _super);
        function AbstractRemoveLinesAction(descriptor, editor) {
            _super.call(this, descriptor, editor);
        }
        AbstractRemoveLinesAction.prototype._getLinesToRemove = function () {
            // Construct delete operations
            var operations = this.editor.getSelections().map(function (s) {
                var endLineNumber = s.endLineNumber;
                if (s.startLineNumber < s.endLineNumber && s.endColumn === 1) {
                    endLineNumber -= 1;
                }
                return {
                    startLineNumber: s.startLineNumber,
                    endLineNumber: endLineNumber,
                    positionColumn: s.positionColumn
                };
            });
            // Sort delete operations
            operations.sort(function (a, b) {
                return a.startLineNumber - b.startLineNumber;
            });
            // Merge delete operations on consecutive lines
            var mergedOperations = [];
            var previousOperation = operations[0];
            for (var i = 1; i < operations.length; i++) {
                if (previousOperation.endLineNumber + 1 === operations[i].startLineNumber) {
                    // Merge current operations into the previous one
                    previousOperation.endLineNumber = operations[i].endLineNumber;
                }
                else {
                    // Push previous operation
                    mergedOperations.push(previousOperation);
                    previousOperation = operations[i];
                }
            }
            // Push the last operation
            mergedOperations.push(previousOperation);
            return mergedOperations;
        };
        return AbstractRemoveLinesAction;
    }(editorAction_1.EditorAction));
    var DeleteLinesAction = (function (_super) {
        __extends(DeleteLinesAction, _super);
        function DeleteLinesAction(descriptor, editor) {
            _super.call(this, descriptor, editor);
        }
        DeleteLinesAction.prototype.run = function () {
            var ops = this._getLinesToRemove();
            // Finally, construct the delete lines commands
            var commands = ops.map(function (op) {
                return new deleteLinesCommand_1.DeleteLinesCommand(op.startLineNumber, op.endLineNumber, op.positionColumn);
            });
            this.editor.executeCommands(this.id, commands);
            return winjs_base_1.TPromise.as(true);
        };
        DeleteLinesAction.ID = 'editor.action.deleteLines';
        return DeleteLinesAction;
    }(AbstractRemoveLinesAction));
    var IndentLinesAction = (function (_super) {
        __extends(IndentLinesAction, _super);
        function IndentLinesAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorCommon_1.Handler.Indent);
        }
        IndentLinesAction.ID = 'editor.action.indentLines';
        return IndentLinesAction;
    }(editorAction_1.HandlerEditorAction));
    var OutdentLinesAction = (function (_super) {
        __extends(OutdentLinesAction, _super);
        function OutdentLinesAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorCommon_1.Handler.Outdent);
        }
        OutdentLinesAction.ID = 'editor.action.outdentLines';
        return OutdentLinesAction;
    }(editorAction_1.HandlerEditorAction));
    var InsertLineBeforeAction = (function (_super) {
        __extends(InsertLineBeforeAction, _super);
        function InsertLineBeforeAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorCommon_1.Handler.LineInsertBefore);
        }
        InsertLineBeforeAction.ID = 'editor.action.insertLineBefore';
        return InsertLineBeforeAction;
    }(editorAction_1.HandlerEditorAction));
    var InsertLineAfterAction = (function (_super) {
        __extends(InsertLineAfterAction, _super);
        function InsertLineAfterAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorCommon_1.Handler.LineInsertAfter);
        }
        InsertLineAfterAction.ID = 'editor.action.insertLineAfter';
        return InsertLineAfterAction;
    }(editorAction_1.HandlerEditorAction));
    // register actions
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(DeleteLinesAction, DeleteLinesAction.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_K
    }, 'Delete Line'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(SortLinesAscendingAction, SortLinesAscendingAction.ID, nls.localize(1, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_2
    }, 'Sort Lines Ascending'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(SortLinesDescendingAction, SortLinesDescendingAction.ID, nls.localize(2, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_3
    }, 'Sort Lines Descending'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(TrimTrailingWhitespaceAction, TrimTrailingWhitespaceAction.ID, nls.localize(3, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.chord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_X)
    }, 'Trim Trailing Whitespace'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(MoveLinesDownAction, MoveLinesDownAction.ID, nls.localize(4, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.DownArrow,
        linux: { primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.DownArrow }
    }, 'Move Line Down'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(MoveLinesUpAction, MoveLinesUpAction.ID, nls.localize(5, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.UpArrow,
        linux: { primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.UpArrow }
    }, 'Move Line Up'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(CopyLinesDownAction, CopyLinesDownAction.ID, nls.localize(6, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.DownArrow,
        linux: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.DownArrow }
    }, 'Copy Line Down'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(CopyLinesUpAction, CopyLinesUpAction.ID, nls.localize(7, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.UpArrow,
        linux: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.UpArrow }
    }, 'Copy Line Up'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(IndentLinesAction, IndentLinesAction.ID, nls.localize(8, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.US_CLOSE_SQUARE_BRACKET
    }, 'Indent Line'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(OutdentLinesAction, OutdentLinesAction.ID, nls.localize(9, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.US_OPEN_SQUARE_BRACKET
    }, 'Outdent Line'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(InsertLineBeforeAction, InsertLineBeforeAction.ID, nls.localize(10, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Enter
    }, 'Insert Line Above'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(InsertLineAfterAction, InsertLineAfterAction.ID, nls.localize(11, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.Enter
    }, 'Insert Line Below'));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[462], __M([0,1,339,8,12,18,32,29,2,43,42,4,20,25,7,13,17,52,229,3,30,225]), function (require, exports, nls, errors_1, keyCodes_1, platform, severity_1, uri_1, winjs_base_1, editor_1, message_1, range_1, editorAction_1, editorActionEnablement_1, editorCommon, editorCommonExtensions_1, modes_1, editorWorkerService_1, links_1, lifecycle_1, editorBrowserExtensions_1) {
    'use strict';
    var LinkOccurence = (function () {
        function LinkOccurence(link, decorationId /*, changeAccessor:editorCommon.IModelDecorationsChangeAccessor*/) {
            this.link = link;
            this.decorationId = decorationId;
        }
        LinkOccurence.decoration = function (link) {
            return {
                range: {
                    startLineNumber: link.range.startLineNumber,
                    startColumn: link.range.startColumn,
                    endLineNumber: link.range.startLineNumber,
                    endColumn: link.range.endColumn
                },
                options: LinkOccurence._getOptions(link, false)
            };
        };
        LinkOccurence._getOptions = function (link, isActive) {
            var result = '';
            if (isActive) {
                result += LinkDetector.CLASS_NAME_ACTIVE;
            }
            else {
                result += LinkDetector.CLASS_NAME;
            }
            return {
                stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                inlineClassName: result,
                hoverMessage: LinkDetector.HOVER_MESSAGE_GENERAL
            };
        };
        LinkOccurence.prototype.activate = function (changeAccessor) {
            changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurence._getOptions(this.link, true));
        };
        LinkOccurence.prototype.deactivate = function (changeAccessor) {
            changeAccessor.changeDecorationOptions(this.decorationId, LinkOccurence._getOptions(this.link, false));
        };
        return LinkOccurence;
    }());
    var Link = (function () {
        function Link(source) {
            this.range = new range_1.Range(source.range.startLineNumber, source.range.startColumn, source.range.endLineNumber, source.range.endColumn);
            this.url = source.url;
        }
        return Link;
    }());
    var LinkDetector = (function () {
        function LinkDetector(editor, editorService, messageService, editorWorkerService) {
            var _this = this;
            this.editor = editor;
            this.editorService = editorService;
            this.messageService = messageService;
            this.editorWorkerService = editorWorkerService;
            this.listenersToRemove = [];
            this.listenersToRemove.push(editor.onDidChangeModelContent(function (e) { return _this.onChange(); }));
            this.listenersToRemove.push(editor.onDidChangeModel(function (e) { return _this.onModelChanged(); }));
            this.listenersToRemove.push(editor.onDidChangeModelMode(function (e) { return _this.onModelModeChanged(); }));
            this.listenersToRemove.push(this.editor.onMouseUp(function (e) { return _this.onEditorMouseUp(e); }));
            this.listenersToRemove.push(this.editor.onMouseMove(function (e) { return _this.onEditorMouseMove(e); }));
            this.listenersToRemove.push(this.editor.onKeyDown(function (e) { return _this.onEditorKeyDown(e); }));
            this.listenersToRemove.push(this.editor.onKeyUp(function (e) { return _this.onEditorKeyUp(e); }));
            this.timeoutPromise = null;
            this.computePromise = null;
            this.currentOccurences = {};
            this.activeLinkDecorationId = null;
            this.beginCompute();
        }
        LinkDetector.get = function (editor) {
            return editor.getContribution(LinkDetector.ID);
        };
        LinkDetector.prototype.getId = function () {
            return LinkDetector.ID;
        };
        LinkDetector.prototype.isComputing = function () {
            return winjs_base_1.TPromise.is(this.computePromise);
        };
        LinkDetector.prototype.onModelChanged = function () {
            this.lastMouseEvent = null;
            this.currentOccurences = {};
            this.activeLinkDecorationId = null;
            this.stop();
            this.beginCompute();
        };
        LinkDetector.prototype.onModelModeChanged = function () {
            this.stop();
            this.beginCompute();
        };
        LinkDetector.prototype.onChange = function () {
            var _this = this;
            if (!this.timeoutPromise) {
                this.timeoutPromise = winjs_base_1.TPromise.timeout(LinkDetector.RECOMPUTE_TIME);
                this.timeoutPromise.then(function () {
                    _this.timeoutPromise = null;
                    _this.beginCompute();
                });
            }
        };
        LinkDetector.prototype.beginCompute = function () {
            var _this = this;
            if (!this.editor.getModel()) {
                return;
            }
            var modePromise = winjs_base_1.TPromise.as(null);
            if (modes_1.LinkProviderRegistry.has(this.editor.getModel())) {
                modePromise = links_1.getLinks(this.editor.getModel());
            }
            var standardPromise = this.editorWorkerService.computeLinks(this.editor.getModel().uri);
            this.computePromise = winjs_base_1.TPromise.join([modePromise, standardPromise]).then(function (r) {
                var a = r[0];
                var b = r[1];
                if (!a || a.length === 0) {
                    return b || [];
                }
                if (!b || b.length === 0) {
                    return a || [];
                }
                return LinkDetector._linksUnion(a.map(function (el) { return new Link(el); }), b.map(function (el) { return new Link(el); }));
            });
            this.computePromise.then(function (links) {
                _this.updateDecorations(links);
                _this.computePromise = null;
            });
        };
        LinkDetector._linksUnion = function (oldLinks, newLinks) {
            // reunite oldLinks with newLinks and remove duplicates
            var result = [], oldIndex, oldLen, newIndex, newLen, oldLink, newLink, comparisonResult;
            for (oldIndex = 0, newIndex = 0, oldLen = oldLinks.length, newLen = newLinks.length; oldIndex < oldLen && newIndex < newLen;) {
                oldLink = oldLinks[oldIndex];
                newLink = newLinks[newIndex];
                if (range_1.Range.areIntersectingOrTouching(oldLink.range, newLink.range)) {
                    // Remove the oldLink
                    oldIndex++;
                    continue;
                }
                comparisonResult = range_1.Range.compareRangesUsingStarts(oldLink.range, newLink.range);
                if (comparisonResult < 0) {
                    // oldLink is before
                    result.push(oldLink);
                    oldIndex++;
                }
                else {
                    // newLink is before
                    result.push(newLink);
                    newIndex++;
                }
            }
            for (; oldIndex < oldLen; oldIndex++) {
                result.push(oldLinks[oldIndex]);
            }
            for (; newIndex < newLen; newIndex++) {
                result.push(newLinks[newIndex]);
            }
            return result;
        };
        LinkDetector.prototype.updateDecorations = function (links) {
            var _this = this;
            this.editor.changeDecorations(function (changeAccessor) {
                var oldDecorations = [];
                var keys = Object.keys(_this.currentOccurences);
                for (var i_1 = 0, len = keys.length; i_1 < len; i_1++) {
                    var decorationId = keys[i_1];
                    var occurance_1 = _this.currentOccurences[decorationId];
                    oldDecorations.push(occurance_1.decorationId);
                }
                var newDecorations = [];
                if (links) {
                    // Not sure why this is sometimes null
                    for (var i = 0; i < links.length; i++) {
                        newDecorations.push(LinkOccurence.decoration(links[i]));
                    }
                }
                var decorations = changeAccessor.deltaDecorations(oldDecorations, newDecorations);
                _this.currentOccurences = {};
                _this.activeLinkDecorationId = null;
                for (var i_2 = 0, len = decorations.length; i_2 < len; i_2++) {
                    var occurance = new LinkOccurence(links[i_2], decorations[i_2]);
                    _this.currentOccurences[occurance.decorationId] = occurance;
                }
            });
        };
        LinkDetector.prototype.onEditorKeyDown = function (e) {
            if (e.keyCode === LinkDetector.TRIGGER_KEY_VALUE && this.lastMouseEvent) {
                this.onEditorMouseMove(this.lastMouseEvent, e);
            }
        };
        LinkDetector.prototype.onEditorKeyUp = function (e) {
            if (e.keyCode === LinkDetector.TRIGGER_KEY_VALUE) {
                this.cleanUpActiveLinkDecoration();
            }
        };
        LinkDetector.prototype.onEditorMouseMove = function (mouseEvent, withKey) {
            var _this = this;
            this.lastMouseEvent = mouseEvent;
            if (this.isEnabled(mouseEvent, withKey)) {
                this.cleanUpActiveLinkDecoration(); // always remove previous link decoration as their can only be one
                var occurence = this.getLinkOccurence(mouseEvent.target.position);
                if (occurence) {
                    this.editor.changeDecorations(function (changeAccessor) {
                        occurence.activate(changeAccessor);
                        _this.activeLinkDecorationId = occurence.decorationId;
                    });
                }
            }
            else {
                this.cleanUpActiveLinkDecoration();
            }
        };
        LinkDetector.prototype.cleanUpActiveLinkDecoration = function () {
            if (this.activeLinkDecorationId) {
                var occurence = this.currentOccurences[this.activeLinkDecorationId];
                if (occurence) {
                    this.editor.changeDecorations(function (changeAccessor) {
                        occurence.deactivate(changeAccessor);
                    });
                }
                this.activeLinkDecorationId = null;
            }
        };
        LinkDetector.prototype.onEditorMouseUp = function (mouseEvent) {
            if (!this.isEnabled(mouseEvent)) {
                return;
            }
            var occurence = this.getLinkOccurence(mouseEvent.target.position);
            if (!occurence) {
                return;
            }
            this.openLinkOccurence(occurence, mouseEvent.event.altKey);
        };
        LinkDetector.prototype.openLinkOccurence = function (occurence, openToSide) {
            if (!this.editorService) {
                return;
            }
            var link = occurence.link;
            var absoluteUrl = link.url;
            var hashIndex = absoluteUrl.indexOf('#');
            var lineNumber = -1;
            var column = -1;
            if (hashIndex >= 0) {
                var hash = absoluteUrl.substr(hashIndex + 1);
                var selection = hash.split(',');
                if (selection.length > 0) {
                    lineNumber = Number(selection[0]);
                }
                if (selection.length > 1) {
                    column = Number(selection[1]);
                }
                if (lineNumber >= 0 || column >= 0) {
                    absoluteUrl = absoluteUrl.substr(0, hashIndex);
                }
            }
            var url;
            try {
                url = uri_1.default.parse(absoluteUrl);
            }
            catch (err) {
                // invalid url
                this.messageService.show(severity_1.default.Warning, nls.localize(2, null, absoluteUrl));
                return;
            }
            var input = {
                resource: url
            };
            if (lineNumber >= 0) {
                input.options = {
                    selection: { startLineNumber: lineNumber, startColumn: column }
                };
            }
            this.editorService.openEditor(input, openToSide).done(null, errors_1.onUnexpectedError);
        };
        LinkDetector.prototype.getLinkOccurence = function (position) {
            var decorations = this.editor.getModel().getDecorationsInRange({
                startLineNumber: position.lineNumber,
                startColumn: position.column,
                endLineNumber: position.lineNumber,
                endColumn: position.column
            }, null, true);
            for (var i = 0; i < decorations.length; i++) {
                var decoration = decorations[i];
                var currentOccurence = this.currentOccurences[decoration.id];
                if (currentOccurence) {
                    return currentOccurence;
                }
            }
            return null;
        };
        LinkDetector.prototype.isEnabled = function (mouseEvent, withKey) {
            return mouseEvent.target.type === editorCommon.MouseTargetType.CONTENT_TEXT &&
                (mouseEvent.event[LinkDetector.TRIGGER_MODIFIER] || (withKey && withKey.keyCode === LinkDetector.TRIGGER_KEY_VALUE));
        };
        LinkDetector.prototype.stop = function () {
            if (this.timeoutPromise) {
                this.timeoutPromise.cancel();
                this.timeoutPromise = null;
            }
            if (this.computePromise) {
                this.computePromise.cancel();
                this.computePromise = null;
            }
        };
        LinkDetector.prototype.dispose = function () {
            this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);
            this.stop();
        };
        LinkDetector.ID = 'editor.linkDetector';
        LinkDetector.RECOMPUTE_TIME = 1000; // ms
        LinkDetector.TRIGGER_KEY_VALUE = platform.isMacintosh ? keyCodes_1.KeyCode.Meta : keyCodes_1.KeyCode.Ctrl;
        LinkDetector.TRIGGER_MODIFIER = platform.isMacintosh ? 'metaKey' : 'ctrlKey';
        LinkDetector.HOVER_MESSAGE_GENERAL = platform.isMacintosh ? nls.localize(0, null) : nls.localize(1, null);
        LinkDetector.CLASS_NAME = 'detected-link';
        LinkDetector.CLASS_NAME_ACTIVE = 'detected-link-active';
        LinkDetector = __decorate([
            __param(1, editor_1.IEditorService),
            __param(2, message_1.IMessageService),
            __param(3, editorWorkerService_1.IEditorWorkerService)
        ], LinkDetector);
        return LinkDetector;
    }());
    var OpenLinkAction = (function (_super) {
        __extends(OpenLinkAction, _super);
        function OpenLinkAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.WidgetFocus | editorActionEnablement_1.Behaviour.UpdateOnCursorPositionChange);
        }
        OpenLinkAction.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
        };
        OpenLinkAction.prototype.getEnablementState = function () {
            if (LinkDetector.get(this.editor).isComputing()) {
                // optimistic enablement while state is being computed
                return true;
            }
            return !!LinkDetector.get(this.editor).getLinkOccurence(this.editor.getPosition());
        };
        OpenLinkAction.prototype.run = function () {
            var link = LinkDetector.get(this.editor).getLinkOccurence(this.editor.getPosition());
            if (link) {
                LinkDetector.get(this.editor).openLinkOccurence(link, false);
            }
            return winjs_base_1.TPromise.as(null);
        };
        OpenLinkAction.ID = 'editor.action.openLink';
        return OpenLinkAction;
    }(editorAction_1.EditorAction));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(OpenLinkAction, OpenLinkAction.ID, nls.localize(3, null), void 0, 'Open Link'));
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(LinkDetector);
});






define(__m[463], __M([0,1,340,12,2,20,7,13]), function (require, exports, nls, keyCodes_1, winjs_base_1, editorAction_1, editorCommon_1, editorCommonExtensions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var InsertCursorAbove = (function (_super) {
        __extends(InsertCursorAbove, _super);
        function InsertCursorAbove(descriptor, editor) {
            _super.call(this, descriptor, editor, editorCommon_1.Handler.AddCursorUp);
        }
        InsertCursorAbove.ID = 'editor.action.insertCursorAbove';
        return InsertCursorAbove;
    }(editorAction_1.HandlerEditorAction));
    var InsertCursorBelow = (function (_super) {
        __extends(InsertCursorBelow, _super);
        function InsertCursorBelow(descriptor, editor) {
            _super.call(this, descriptor, editor, editorCommon_1.Handler.AddCursorDown);
        }
        InsertCursorBelow.ID = 'editor.action.insertCursorBelow';
        return InsertCursorBelow;
    }(editorAction_1.HandlerEditorAction));
    var InsertCursorAtEndOfEachLineSelected = (function (_super) {
        __extends(InsertCursorAtEndOfEachLineSelected, _super);
        function InsertCursorAtEndOfEachLineSelected(descriptor, editor) {
            _super.call(this, descriptor, editor);
        }
        InsertCursorAtEndOfEachLineSelected.prototype.run = function () {
            var selection = this.editor.getSelection();
            if (!selection.isEmpty()) {
                var model = this.editor.getModel();
                var newSelections = new Array();
                var selectionStart = selection.getStartPosition();
                var selectionEnd = selection.getEndPosition();
                for (var i = selectionStart.lineNumber; i <= selectionEnd.lineNumber; i++) {
                    if (i !== selectionEnd.lineNumber) {
                        var currentLineMaxColumn = model.getLineMaxColumn(i);
                        newSelections.push({
                            selectionStartLineNumber: i,
                            selectionStartColumn: currentLineMaxColumn,
                            positionLineNumber: i,
                            positionColumn: currentLineMaxColumn
                        });
                    }
                    else if (selectionEnd.column > 0) {
                        newSelections.push({
                            selectionStartLineNumber: selectionEnd.lineNumber,
                            selectionStartColumn: selectionEnd.column,
                            positionLineNumber: selectionEnd.lineNumber,
                            positionColumn: selectionEnd.column
                        });
                    }
                }
                this.editor.setSelections(newSelections);
            }
            return winjs_base_1.TPromise.as(true);
        };
        InsertCursorAtEndOfEachLineSelected.ID = 'editor.action.insertCursorAtEndOfEachLineSelected';
        return InsertCursorAtEndOfEachLineSelected;
    }(editorAction_1.EditorAction));
    // register actions
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(InsertCursorAbove, InsertCursorAbove.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.UpArrow,
        linux: {
            primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.UpArrow,
            secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.UpArrow]
        }
    }, 'Add Cursor Above'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(InsertCursorBelow, InsertCursorBelow.ID, nls.localize(1, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.DownArrow,
        linux: {
            primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.DownArrow,
            secondary: [keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.DownArrow]
        }
    }, 'Add Cursor Below'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(InsertCursorAtEndOfEachLineSelected, InsertCursorAtEndOfEachLineSelected.ID, nls.localize(2, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_I
    }, 'Create Multiple Cursors from Selected Lines'));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[166], __M([0,1,2,13,17,14]), function (require, exports, winjs_base_1, editorCommonExtensions_1, modes_1, async_1) {
    'use strict';
    exports.Context = {
        Visible: 'parameterHintsVisible',
        MultipleSignatures: 'parameterHintsMultipleSignatures',
    };
    function provideSignatureHelp(model, position) {
        var support = modes_1.SignatureHelpProviderRegistry.ordered(model)[0];
        if (!support) {
            return winjs_base_1.TPromise.as(undefined);
        }
        return async_1.asWinJsPromise(function (token) { return support.provideSignatureHelp(model, position, token); });
    }
    exports.provideSignatureHelp = provideSignatureHelp;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeSignatureHelpProvider', provideSignatureHelp);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[465], __M([0,1,342,3,2,11,81,17,22,14,8,16,19,166,228]), function (require, exports, nls, lifecycle_1, winjs_base_1, dom, aria, modes_1, editorBrowser_1, async_1, errors_1, event_1, keybindingService_1, parameterHints_1) {
    'use strict';
    var $ = dom.emmet;
    var ParameterHintsModel = (function (_super) {
        __extends(ParameterHintsModel, _super);
        function ParameterHintsModel(editor) {
            var _this = this;
            _super.call(this);
            this._onHint = this._register(new event_1.Emitter());
            this.onHint = this._onHint.event;
            this._onCancel = this._register(new event_1.Emitter());
            this.onCancel = this._onCancel.event;
            this.editor = editor;
            this.enabled = false;
            this.triggerCharactersListeners = [];
            this.throttledDelayer = new async_1.RunOnceScheduler(function () { return _this.doTrigger(); }, ParameterHintsModel.DELAY);
            this.active = false;
            this._register(this.editor.onDidChangeConfiguration(function () { return _this.onEditorConfigurationChange(); }));
            this._register(this.editor.onDidChangeModel(function (e) { return _this.onModelChanged(); }));
            this._register(this.editor.onDidChangeModelMode(function (_) { return _this.onModelChanged(); }));
            this._register(this.editor.onDidChangeCursorSelection(function (e) { return _this.onCursorChange(e); }));
            this._register(modes_1.SignatureHelpProviderRegistry.onDidChange(this.onModelChanged, this));
            this.onEditorConfigurationChange();
            this.onModelChanged();
        }
        ParameterHintsModel.prototype.cancel = function (silent) {
            if (silent === void 0) { silent = false; }
            this.active = false;
            this.throttledDelayer.cancel();
            if (!silent) {
                this._onCancel.fire(void 0);
            }
        };
        ParameterHintsModel.prototype.trigger = function (delay) {
            if (delay === void 0) { delay = ParameterHintsModel.DELAY; }
            if (!this.enabled || !modes_1.SignatureHelpProviderRegistry.has(this.editor.getModel())) {
                return;
            }
            this.cancel(true);
            return this.throttledDelayer.schedule(delay);
        };
        ParameterHintsModel.prototype.doTrigger = function () {
            var _this = this;
            parameterHints_1.provideSignatureHelp(this.editor.getModel(), this.editor.getPosition())
                .then(null, errors_1.onUnexpectedError)
                .then(function (result) {
                if (!result || result.signatures.length === 0) {
                    _this.cancel();
                    _this._onCancel.fire(void 0);
                    return false;
                }
                _this.active = true;
                var event = { hints: result };
                _this._onHint.fire(event);
                return true;
            });
        };
        ParameterHintsModel.prototype.isTriggered = function () {
            return this.active || this.throttledDelayer.isScheduled();
        };
        ParameterHintsModel.prototype.onModelChanged = function () {
            var _this = this;
            if (this.active) {
                this.cancel();
            }
            this.triggerCharactersListeners = lifecycle_1.dispose(this.triggerCharactersListeners);
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            var support = modes_1.SignatureHelpProviderRegistry.ordered(model)[0];
            if (!support) {
                return;
            }
            this.triggerCharactersListeners = support.signatureHelpTriggerCharacters.map(function (ch) {
                return _this.editor.addTypingListener(ch, function () {
                    _this.trigger();
                });
            });
        };
        ParameterHintsModel.prototype.onCursorChange = function (e) {
            if (e.source === 'mouse') {
                this.cancel();
            }
            else if (this.isTriggered()) {
                this.trigger();
            }
        };
        ParameterHintsModel.prototype.onEditorConfigurationChange = function () {
            this.enabled = this.editor.getConfiguration().contribInfo.parameterHints;
            if (!this.enabled) {
                this.cancel();
            }
        };
        ParameterHintsModel.prototype.dispose = function () {
            this.cancel(true);
            this.triggerCharactersListeners = lifecycle_1.dispose(this.triggerCharactersListeners);
            _super.prototype.dispose.call(this);
        };
        ParameterHintsModel.DELAY = 120; // ms
        return ParameterHintsModel;
    }(lifecycle_1.Disposable));
    exports.ParameterHintsModel = ParameterHintsModel;
    var ParameterHintsWidget = (function () {
        function ParameterHintsWidget(editor, keybindingService) {
            var _this = this;
            this.editor = editor;
            // Editor.IContentWidget.allowEditorOverflow
            this.allowEditorOverflow = true;
            this.model = new ParameterHintsModel(editor);
            this.keyVisible = keybindingService.createKey(parameterHints_1.Context.Visible, false);
            this.keyMultipleSignatures = keybindingService.createKey(parameterHints_1.Context.MultipleSignatures, false);
            this.visible = false;
            this.disposables = [];
            this.disposables.push(this.model.onHint(function (e) {
                _this.show();
                _this.parameterHints = e.hints;
                _this.render(e.hints);
                _this.currentSignature = e.hints.activeSignature;
                _this.select(_this.currentSignature);
            }));
            this.disposables.push(this.model.onCancel(function () {
                _this.hide();
            }));
            this.element = $('.editor-widget.parameter-hints-widget');
            this.disposables.push(dom.addDisposableListener(this.element, 'click', function () {
                _this.next();
                _this.editor.focus();
            }));
            var wrapper = dom.append(this.element, $('.wrapper.monaco-editor-background'));
            var buttons = dom.append(wrapper, $('.buttons'));
            var previous = dom.append(buttons, $('.button.previous'));
            var next = dom.append(buttons, $('.button.next'));
            this.disposables.push(dom.addDisposableListener(previous, 'click', function (e) {
                e.preventDefault();
                e.stopPropagation();
                _this.previous();
            }));
            this.disposables.push(dom.addDisposableListener(next, 'click', function (e) {
                e.preventDefault();
                e.stopPropagation();
                _this.next();
            }));
            this.overloads = dom.append(wrapper, $('.overloads'));
            this.signatures = dom.append(wrapper, $('.signatures'));
            this.signatureViews = [];
            this.currentSignature = 0;
            this.editor.addContentWidget(this);
            this.hide();
            this.disposables.push(this.editor.onDidChangeCursorSelection(function (e) {
                if (_this.visible) {
                    _this.editor.layoutContentWidget(_this);
                }
            }));
        }
        ParameterHintsWidget.prototype.show = function () {
            var _this = this;
            if (!this.model || this.visible) {
                return;
            }
            this.keyVisible.set(true);
            this.visible = true;
            winjs_base_1.TPromise.timeout(100).done(function () { return dom.addClass(_this.element, 'visible'); });
            this.editor.layoutContentWidget(this);
        };
        ParameterHintsWidget.prototype.hide = function () {
            if (!this.model || !this.visible) {
                return;
            }
            this.keyVisible.reset();
            this.visible = false;
            this.parameterHints = null;
            this.announcedLabel = null;
            dom.removeClass(this.element, 'visible');
            this.editor.layoutContentWidget(this);
        };
        ParameterHintsWidget.prototype.getPosition = function () {
            if (this.visible) {
                return {
                    position: this.editor.getPosition(),
                    preference: [editorBrowser_1.ContentWidgetPositionPreference.ABOVE, editorBrowser_1.ContentWidgetPositionPreference.BELOW]
                };
            }
            return null;
        };
        ParameterHintsWidget.prototype.render = function (hints) {
            if (hints.signatures.length > 1) {
                dom.addClass(this.element, 'multiple');
            }
            else {
                dom.removeClass(this.element, 'multiple');
            }
            this.signatures.innerHTML = '';
            this.signatureViews = [];
            var height = 0;
            for (var i = 0, len = hints.signatures.length; i < len; i++) {
                var signature = hints.signatures[i];
                var signatureElement = this.renderSignature(this.signatures, signature, hints.activeParameter);
                this.renderDocumentation(signatureElement, signature, hints.activeParameter);
                var signatureHeight = dom.getContentHeight(signatureElement);
                this.signatureViews.push({
                    top: height,
                    height: signatureHeight
                });
                height += signatureHeight;
            }
            this.keyMultipleSignatures.set(this.signatureViews.length > 1);
        };
        ParameterHintsWidget.prototype.applyFont = function (element) {
            var fontInfo = this.editor.getConfiguration().fontInfo;
            element.style.fontFamily = fontInfo.fontFamily;
        };
        ParameterHintsWidget.prototype.renderSignature = function (element, signature, currentParameter) {
            var signatureElement = dom.append(element, $('.signature'));
            var code = dom.append(signatureElement, $('.code'));
            var hasParameters = signature.parameters.length > 0;
            this.applyFont(code);
            if (!hasParameters) {
                var label_1 = dom.append(code, $('span'));
                label_1.textContent = signature.label;
                return code;
            }
            var parameters = $('span.parameters');
            var offset = 0;
            var idx = 0;
            for (var i = 0, len = signature.parameters.length; i < len; i++) {
                var parameter = signature.parameters[i];
                idx = signature.label.indexOf(parameter.label, idx);
                var signatureLabelOffset = 0;
                var signatureLabelEnd = 0;
                if (idx >= 0) {
                    signatureLabelOffset = idx;
                    idx += parameter.label.length;
                    signatureLabelEnd = idx;
                }
                var element_1 = i === 0 ? code : parameters;
                var label_2 = $('span');
                label_2.textContent = signature.label.substring(offset, signatureLabelOffset);
                dom.append(element_1, label_2);
                var parameterElement = $('span.parameter');
                dom.addClass(parameterElement, i === currentParameter ? 'active' : '');
                parameterElement.textContent = signature.label.substring(signatureLabelOffset, signatureLabelEnd);
                dom.append(parameters, parameterElement);
                offset = signatureLabelEnd;
            }
            var label = $('span');
            label.textContent = signature.label.substring(offset);
            dom.append(code, parameters);
            dom.append(code, label);
            return signatureElement;
        };
        ParameterHintsWidget.prototype.renderDocumentation = function (element, signature, activeParameterIdx) {
            if (signature.documentation) {
                var documentation = $('.documentation');
                documentation.textContent = signature.documentation;
                dom.append(element, documentation);
            }
            var activeParameter = signature.parameters[activeParameterIdx];
            if (activeParameter && activeParameter.documentation) {
                var parameter = $('.documentation-parameter');
                var label = $('span.parameter');
                this.applyFont(label);
                label.textContent = activeParameter.label;
                var documentation = $('span.documentation');
                documentation.textContent = activeParameter.documentation;
                dom.append(parameter, label);
                dom.append(parameter, documentation);
                dom.append(element, parameter);
            }
        };
        ParameterHintsWidget.prototype.select = function (position) {
            var signature = this.signatureViews[position];
            if (!signature) {
                return;
            }
            this.signatures.style.height = signature.height + "px";
            this.signatures.scrollTop = signature.top;
            var overloads = '' + (position + 1);
            if (this.signatureViews.length < 10) {
                overloads += '/' + this.signatureViews.length;
            }
            this.overloads.textContent = overloads;
            if (this.parameterHints && this.parameterHints.signatures[position].parameters[this.parameterHints.activeParameter]) {
                var labelToAnnounce = this.parameterHints.signatures[position].parameters[this.parameterHints.activeParameter].label;
                // Select method gets called on every user type while parameter hints are visible.
                // We do not want to spam the user with same announcements, so we only announce if the current parameter changed.
                if (this.announcedLabel !== labelToAnnounce) {
                    aria.alert(nls.localize(0, null, labelToAnnounce));
                    this.announcedLabel = labelToAnnounce;
                }
            }
            this.editor.layoutContentWidget(this);
        };
        ParameterHintsWidget.prototype.next = function () {
            if (this.signatureViews.length < 2) {
                this.cancel();
                return false;
            }
            this.currentSignature = (this.currentSignature + 1) % this.signatureViews.length;
            this.select(this.currentSignature);
            return true;
        };
        ParameterHintsWidget.prototype.previous = function () {
            if (this.signatureViews.length < 2) {
                this.cancel();
                return false;
            }
            this.currentSignature--;
            if (this.currentSignature < 0) {
                this.currentSignature = this.signatureViews.length - 1;
            }
            this.select(this.currentSignature);
            return true;
        };
        ParameterHintsWidget.prototype.cancel = function () {
            this.model.cancel();
        };
        ParameterHintsWidget.prototype.getDomNode = function () {
            return this.element;
        };
        ParameterHintsWidget.prototype.getId = function () {
            return ParameterHintsWidget.ID;
        };
        ParameterHintsWidget.prototype.trigger = function () {
            this.model.trigger(0);
        };
        ParameterHintsWidget.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
            this.model = null;
        };
        ParameterHintsWidget.ID = 'editor.widget.parameterHintsWidget';
        ParameterHintsWidget = __decorate([
            __param(1, keybindingService_1.IKeybindingService)
        ], ParameterHintsWidget);
        return ParameterHintsWidget;
    }());
    exports.ParameterHintsWidget = ParameterHintsWidget;
});















define(__m[466], __M([0,1,341,12,2,3,15,20,7,19,51,90,13,30,17,465,166]), function (require, exports, nls, keyCodes_1, winjs_base_1, lifecycle_1, instantiation_1, editorAction_1, editorCommon_1, keybindingService_1, keybindingsRegistry_1, config_1, editorCommonExtensions_1, editorBrowserExtensions_1, modes_1, parameterHintsWidget_1, parameterHints_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ParameterHintsController = (function () {
        function ParameterHintsController(editor, instantiationService) {
            this.editor = editor;
            this.widget = instantiationService.createInstance(parameterHintsWidget_1.ParameterHintsWidget, this.editor);
        }
        ParameterHintsController.get = function (editor) {
            return editor.getContribution(ParameterHintsController.ID);
        };
        ParameterHintsController.prototype.getId = function () {
            return ParameterHintsController.ID;
        };
        ParameterHintsController.prototype.cancel = function () {
            this.widget.cancel();
        };
        ParameterHintsController.prototype.previous = function () {
            this.widget.previous();
        };
        ParameterHintsController.prototype.next = function () {
            this.widget.next();
        };
        ParameterHintsController.prototype.trigger = function () {
            this.widget.trigger();
        };
        ParameterHintsController.prototype.dispose = function () {
            this.widget = lifecycle_1.dispose(this.widget);
        };
        ParameterHintsController.ID = 'editor.controller.parameterHints';
        ParameterHintsController = __decorate([
            __param(1, instantiation_1.IInstantiationService)
        ], ParameterHintsController);
        return ParameterHintsController;
    }());
    var TriggerParameterHintsAction = (function (_super) {
        __extends(TriggerParameterHintsAction, _super);
        function TriggerParameterHintsAction(descriptor, editor) {
            _super.call(this, descriptor, editor);
        }
        TriggerParameterHintsAction.prototype.isSupported = function () {
            return modes_1.SignatureHelpProviderRegistry.has(this.editor.getModel()) && _super.prototype.isSupported.call(this);
        };
        TriggerParameterHintsAction.prototype.run = function () {
            ParameterHintsController.get(this.editor).trigger();
            return winjs_base_1.TPromise.as(true);
        };
        TriggerParameterHintsAction.ID = 'editor.action.triggerParameterHints';
        return TriggerParameterHintsAction;
    }(editorAction_1.EditorAction));
    exports.TriggerParameterHintsAction = TriggerParameterHintsAction;
    var weight = editorCommonExtensions_1.CommonEditorRegistry.commandWeight(75);
    function handler(id, fn) {
        return function (accessor) { return config_1.withCodeEditorFromCommandHandler(id, accessor, function (editor) {
            fn(ParameterHintsController.get(editor));
        }); };
    }
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(ParameterHintsController);
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(TriggerParameterHintsAction, TriggerParameterHintsAction.ID, nls.localize(0, null), { context: editorCommonExtensions_1.ContextKey.EditorTextFocus, primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Space }, 'Trigger Parameter Hints'));
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: 'closeParameterHints',
        handler: handler('closeParameterHints', function (c) { return c.cancel(); }),
        weight: weight,
        when: keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon_1.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.has(parameterHints_1.Context.Visible)),
        primary: keyCodes_1.KeyCode.Escape,
        secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape]
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: 'showPrevParameterHint',
        handler: handler('showPrevParameterHint', function (c) { return c.previous(); }),
        weight: weight,
        when: keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon_1.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.has(parameterHints_1.Context.Visible), keybindingService_1.KbExpr.has(parameterHints_1.Context.MultipleSignatures)),
        primary: keyCodes_1.KeyCode.UpArrow,
        secondary: [keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.UpArrow]
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: 'showNextParameterHint',
        handler: handler('showNextParameterHint', function (c) { return c.next(); }),
        weight: weight,
        when: keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon_1.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.has(parameterHints_1.Context.Visible), keybindingService_1.KbExpr.has(parameterHints_1.Context.MultipleSignatures)),
        primary: keyCodes_1.KeyCode.DownArrow,
        secondary: [keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.DownArrow]
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[167], __M([0,1,8,29,2,63,4,13,17,34,14]), function (require, exports, errors_1, uri_1, winjs_base_1, idGenerator_1, range_1, editorCommonExtensions_1, modes_1, modelService_1, async_1) {
    'use strict';
    function getCodeActions(model, range) {
        var quickFixes = [];
        var ids = new idGenerator_1.IdGenerator('quickfix');
        var promises = modes_1.CodeActionProviderRegistry.all(model).map(function (support) {
            return async_1.asWinJsPromise(function (token) {
                return support.provideCodeActions(model, range, token);
            }).then(function (result) {
                if (!Array.isArray(result)) {
                    return;
                }
                for (var _i = 0, result_1 = result; _i < result_1.length; _i++) {
                    var fix = result_1[_i];
                    quickFixes.push({
                        command: fix.command,
                        score: fix.score,
                        id: ids.nextId(),
                        support: support
                    });
                }
            }, function (err) {
                errors_1.onUnexpectedError(err);
            });
        });
        return winjs_base_1.TPromise.join(promises).then(function () { return quickFixes; });
    }
    exports.getCodeActions = getCodeActions;
    editorCommonExtensions_1.CommonEditorRegistry.registerLanguageCommand('_executeCodeActionProvider', function (accessor, args) {
        var resource = args.resource, range = args.range;
        if (!(resource instanceof uri_1.default) || !range_1.Range.isIRange(range)) {
            throw errors_1.illegalArgument();
        }
        var model = accessor.get(modelService_1.IModelService).getModel(resource);
        if (!model) {
            throw errors_1.illegalArgument();
        }
        var editorRange = range_1.Range.lift(range);
        return getCodeActions(model, editorRange);
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[468], __M([0,1,333,8,16,12,3,32,10,2,11,71,19,73,36,21,4,20,25,13,30,164,167,217]), function (require, exports, nls, errors_1, event_1, keyCodes_1, lifecycle_1, severity_1, strings, winjs_base_1, dom, htmlContentRenderer_1, keybindingService_1, markers_1, telemetry_1, position_1, range_1, editorAction_1, editorActionEnablement_1, editorCommonExtensions_1, editorBrowserExtensions_1, zoneWidget_1, quickFix_1) {
    'use strict';
    var MarkerModel = (function () {
        function MarkerModel(editor, markers) {
            var _this = this;
            this._editor = editor;
            this._markers = null;
            this._nextIdx = -1;
            this._toUnbind = [];
            this._ignoreSelectionChange = false;
            this._onCurrentMarkerChanged = new event_1.Emitter();
            this._onMarkerSetChanged = new event_1.Emitter();
            this.setMarkers(markers);
            // listen on editor
            this._toUnbind.push(this._editor.onDidDispose(function () { return _this.dispose(); }));
            this._toUnbind.push(this._editor.onDidChangeCursorPosition(function () {
                if (!_this._ignoreSelectionChange) {
                    _this._nextIdx = -1;
                }
            }));
        }
        Object.defineProperty(MarkerModel.prototype, "onCurrentMarkerChanged", {
            get: function () {
                return this._onCurrentMarkerChanged.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MarkerModel.prototype, "onMarkerSetChanged", {
            get: function () {
                return this._onMarkerSetChanged.event;
            },
            enumerable: true,
            configurable: true
        });
        MarkerModel.prototype.setMarkers = function (markers) {
            // assign
            this._markers = markers || [];
            // sort markers
            this._markers.sort(function (left, right) { return severity_1.default.compare(left.severity, right.severity) || range_1.Range.compareRangesUsingStarts(left, right); });
            this._nextIdx = -1;
            this._onMarkerSetChanged.fire(this);
        };
        MarkerModel.prototype.withoutWatchingEditorPosition = function (callback) {
            this._ignoreSelectionChange = true;
            try {
                callback();
            }
            finally {
                this._ignoreSelectionChange = false;
            }
        };
        MarkerModel.prototype.initIdx = function (fwd) {
            var found = false;
            var position = this._editor.getPosition();
            for (var i = 0, len = this._markers.length; i < len && !found; i++) {
                var pos = { lineNumber: this._markers[i].startLineNumber, column: this._markers[i].startColumn };
                if (position.isBeforeOrEqual(pos)) {
                    this._nextIdx = i + (fwd ? 0 : -1);
                    found = true;
                }
            }
            if (!found) {
                // after the last change
                this._nextIdx = fwd ? 0 : this._markers.length - 1;
            }
            if (this._nextIdx < 0) {
                this._nextIdx = this._markers.length - 1;
            }
        };
        MarkerModel.prototype.move = function (fwd) {
            if (!this.canNavigate()) {
                this._onCurrentMarkerChanged.fire(undefined);
                return;
            }
            if (this._nextIdx === -1) {
                this.initIdx(fwd);
            }
            else if (fwd) {
                this._nextIdx += 1;
                if (this._nextIdx >= this._markers.length) {
                    this._nextIdx = 0;
                }
            }
            else {
                this._nextIdx -= 1;
                if (this._nextIdx < 0) {
                    this._nextIdx = this._markers.length - 1;
                }
            }
            var marker = this._markers[this._nextIdx];
            this._onCurrentMarkerChanged.fire(marker);
        };
        MarkerModel.prototype.canNavigate = function () {
            return this._markers.length > 0;
        };
        MarkerModel.prototype.next = function () {
            this.move(true);
        };
        MarkerModel.prototype.previous = function () {
            this.move(false);
        };
        MarkerModel.prototype.goTo = function (pos) {
            for (var i = 0; i < this._markers.length; i++) {
                var marker = this._markers[i];
                if (marker.startLineNumber <= pos.lineNumber && marker.endLineNumber >= pos.lineNumber
                    && marker.startColumn <= pos.column && marker.endColumn >= pos.column) {
                    this._onCurrentMarkerChanged.fire(marker);
                    return;
                }
            }
            return null;
        };
        Object.defineProperty(MarkerModel.prototype, "stats", {
            get: function () {
                var errors = 0;
                var others = 0;
                for (var _i = 0, _a = this._markers; _i < _a.length; _i++) {
                    var marker = _a[_i];
                    if (marker.severity === severity_1.default.Error) {
                        errors += 1;
                    }
                    else {
                        others += 1;
                    }
                }
                return { errors: errors, others: others };
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MarkerModel.prototype, "total", {
            get: function () {
                return this._markers.length;
            },
            enumerable: true,
            configurable: true
        });
        MarkerModel.prototype.indexOf = function (marker) {
            return 1 + this._markers.indexOf(marker);
        };
        MarkerModel.prototype.reveal = function () {
            var _this = this;
            if (this._nextIdx === -1) {
                return;
            }
            this.withoutWatchingEditorPosition(function () {
                var pos = new position_1.Position(_this._markers[_this._nextIdx].startLineNumber, _this._markers[_this._nextIdx].startColumn);
                _this._editor.setPosition(pos);
                _this._editor.revealPositionInCenter(pos);
            });
        };
        MarkerModel.prototype.dispose = function () {
            this._toUnbind = lifecycle_1.dispose(this._toUnbind);
        };
        return MarkerModel;
    }());
    var FixesWidget = (function () {
        function FixesWidget(container, _keybindingService) {
            var _this = this;
            this._keybindingService = _keybindingService;
            this._disposeOnUpdate = [];
            this.domNode = document.createElement('div');
            container.appendChild(this.domNode);
            this._listener = dom.addStandardDisposableListener(container, 'keydown', function (e) {
                switch (e.asKeybinding()) {
                    case keyCodes_1.CommonKeybindings.LEFT_ARROW:
                        _this._move(true);
                        // this._goLeft();
                        e.preventDefault();
                        e.stopPropagation();
                        break;
                    case keyCodes_1.CommonKeybindings.RIGHT_ARROW:
                        _this._move(false);
                        // this._goRight();
                        e.preventDefault();
                        e.stopPropagation();
                        break;
                }
            });
        }
        FixesWidget.prototype.dispose = function () {
            this._disposeOnUpdate = lifecycle_1.dispose(this._disposeOnUpdate);
            this._listener = lifecycle_1.dispose(this._listener);
        };
        FixesWidget.prototype.update = function (fixes) {
            var _this = this;
            this._disposeOnUpdate = lifecycle_1.dispose(this._disposeOnUpdate);
            this.domNode.style.display = 'none';
            return fixes.then(function (fixes) { return _this._doUpdate(fixes); }, errors_1.onUnexpectedError);
        };
        FixesWidget.prototype._doUpdate = function (fixes) {
            var _this = this;
            dom.clearNode(this.domNode);
            if (!fixes || fixes.length === 0) {
                return;
            }
            // light bulb and label
            var quickfixhead = document.createElement('span');
            quickfixhead.className = 'quickfixhead';
            quickfixhead.appendChild(document.createTextNode(fixes.length > 1
                ? nls.localize(0, null)
                : nls.localize(1, null)));
            this.domNode.appendChild(quickfixhead);
            // each fix as entry
            var container = document.createElement('span');
            container.className = 'quickfixcontainer';
            fixes.forEach(function (fix, idx, arr) {
                if (idx > 0) {
                    var separator = document.createElement('span');
                    separator.appendChild(document.createTextNode(', '));
                    container.appendChild(separator);
                }
                var entry = document.createElement('a');
                entry.tabIndex = 0;
                entry.className = "quickfixentry";
                entry.dataset['idx'] = String(idx);
                entry.dataset['next'] = String(idx < arr.length - 1 ? idx + 1 : 0);
                entry.dataset['prev'] = String(idx > 0 ? idx - 1 : arr.length - 1);
                entry.appendChild(document.createTextNode(fix.command.title));
                _this._disposeOnUpdate.push(dom.addDisposableListener(entry, dom.EventType.CLICK, function () {
                    (_a = _this._keybindingService).executeCommand.apply(_a, [fix.command.id].concat(fix.command.arguments));
                    return true;
                    var _a;
                }));
                _this._disposeOnUpdate.push(dom.addStandardDisposableListener(entry, 'keydown', function (e) {
                    switch (e.asKeybinding()) {
                        case keyCodes_1.CommonKeybindings.ENTER:
                        case keyCodes_1.CommonKeybindings.SPACE:
                            (_a = _this._keybindingService).executeCommand.apply(_a, [fix.command.id].concat(fix.command.arguments));
                            e.preventDefault();
                            e.stopPropagation();
                    }
                    var _a;
                }));
                container.appendChild(entry);
            });
            this.domNode.appendChild(container);
            this.domNode.style.display = '';
        };
        FixesWidget.prototype._move = function (left) {
            var target;
            if (document.activeElement.classList.contains('quickfixentry')) {
                var current = document.activeElement;
                var idx = left ? current.dataset['prev'] : current.dataset['next'];
                target = this.domNode.querySelector("a[data-idx='" + idx + "']");
            }
            else {
                target = this.domNode.querySelector('.quickfixentry');
            }
            target.focus();
        };
        FixesWidget = __decorate([
            __param(1, keybindingService_1.IKeybindingService)
        ], FixesWidget);
        return FixesWidget;
    }());
    var MarkerNavigationWidget = (function (_super) {
        __extends(MarkerNavigationWidget, _super);
        function MarkerNavigationWidget(editor, _model, _keybindingService) {
            _super.call(this, editor, { showArrow: true, showFrame: true, isAccessible: true });
            this._model = _model;
            this._keybindingService = _keybindingService;
            this._callOnDispose = [];
            this.create();
            this._wireModelAndView();
        }
        MarkerNavigationWidget.prototype._fillContainer = function (container) {
            this._container = container;
            dom.addClass(this._container, 'marker-widget');
            this._container.tabIndex = 0;
            this._container.setAttribute('role', 'tooltip');
            this._title = document.createElement('div');
            this._title.className = 'block title';
            this._container.appendChild(this._title);
            this._messages = document.createElement('div');
            this.editor.applyFontInfo(this._messages);
            this._messages.className = 'block descriptioncontainer';
            this._messages.setAttribute('aria-live', 'assertive');
            this._messages.setAttribute('role', 'alert');
            this._container.appendChild(this._messages);
            this._fixesWidget = new FixesWidget(this._container, this._keybindingService);
            this._fixesWidget.domNode.classList.add('fixes');
            this._callOnDispose.push(this._fixesWidget);
        };
        MarkerNavigationWidget.prototype.show = function (where, heightInLines) {
            _super.prototype.show.call(this, where, heightInLines);
            this._container.focus();
        };
        MarkerNavigationWidget.prototype._wireModelAndView = function () {
            // listen to events
            this._model.onCurrentMarkerChanged(this.showAtMarker, this, this._callOnDispose);
        };
        MarkerNavigationWidget.prototype.showAtMarker = function (marker) {
            var _this = this;
            if (!marker) {
                return;
            }
            // update frame color
            switch (marker.severity) {
                case severity_1.default.Error:
                    this.options.frameColor = '#ff5a5a';
                    break;
                case severity_1.default.Warning:
                case severity_1.default.Info:
                    this.options.frameColor = '#5aac5a';
                    break;
            }
            // update meta title
            if (marker.source) {
                this._title.innerHTML = nls.localize(2, null, this._model.indexOf(marker), this._model.total, marker.source);
            }
            else {
                this._title.innerHTML = nls.localize(3, null, this._model.indexOf(marker), this._model.total);
            }
            // update label and show
            dom.clearNode(this._messages);
            this._messages.appendChild(htmlContentRenderer_1.renderHtml(marker.message));
            var range = range_1.Range.lift(marker);
            var lines = strings.computeLineStarts(marker.message).length;
            this._model.withoutWatchingEditorPosition(function () { return _this.show(range.getStartPosition(), lines); });
            // check for fixes and update widget
            this._fixesWidget
                .update(quickFix_1.getCodeActions(this.editor.getModel(), range))
                .then(function () { return _this.show(range.getStartPosition(), lines + 2); });
        };
        MarkerNavigationWidget.prototype.dispose = function () {
            this._callOnDispose = lifecycle_1.dispose(this._callOnDispose);
            _super.prototype.dispose.call(this);
        };
        return MarkerNavigationWidget;
    }(zoneWidget_1.ZoneWidget));
    var MarkerNavigationAction = (function (_super) {
        __extends(MarkerNavigationAction, _super);
        function MarkerNavigationAction(descriptor, editor, next, telemetryService) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.WidgetFocus | editorActionEnablement_1.Behaviour.Writeable | editorActionEnablement_1.Behaviour.UpdateOnModelChange);
            this.telemetryService = telemetryService;
            this._isNext = next;
        }
        MarkerNavigationAction.prototype.run = function () {
            var model = MarkerController.getMarkerController(this.editor).getOrCreateModel();
            this.telemetryService.publicLog('zoneWidgetShown', { mode: 'go to error' });
            if (model) {
                if (this._isNext) {
                    model.next();
                }
                else {
                    model.previous();
                }
                model.reveal();
            }
            return winjs_base_1.TPromise.as(true);
        };
        MarkerNavigationAction = __decorate([
            __param(3, telemetry_1.ITelemetryService)
        ], MarkerNavigationAction);
        return MarkerNavigationAction;
    }(editorAction_1.EditorAction));
    var MarkerController = (function () {
        function MarkerController(editor, _markerService, _keybindingService) {
            this._markerService = _markerService;
            this._keybindingService = _keybindingService;
            this._callOnClose = [];
            this._editor = editor;
            this._markersNavigationVisible = this._keybindingService.createKey(CONTEXT_MARKERS_NAVIGATION_VISIBLE, false);
        }
        MarkerController.getMarkerController = function (editor) {
            return editor.getContribution(MarkerController.ID);
        };
        MarkerController.prototype.getId = function () {
            return MarkerController.ID;
        };
        MarkerController.prototype.dispose = function () {
            this._cleanUp();
        };
        MarkerController.prototype._cleanUp = function () {
            this._markersNavigationVisible.reset();
            this._callOnClose = lifecycle_1.dispose(this._callOnClose);
            this._zone = null;
            this._model = null;
        };
        MarkerController.prototype.getOrCreateModel = function () {
            var _this = this;
            if (this._model) {
                return this._model;
            }
            var markers = this._getMarkers();
            this._model = new MarkerModel(this._editor, markers);
            this._zone = new MarkerNavigationWidget(this._editor, this._model, this._keybindingService);
            this._markersNavigationVisible.set(true);
            this._callOnClose.push(this._model);
            this._callOnClose.push(this._zone);
            this._callOnClose.push(this._editor.onDidChangeModel(function () { return _this._cleanUp(); }));
            this._model.onCurrentMarkerChanged(function (marker) { return !marker && _this._cleanUp(); }, undefined, this._callOnClose);
            this._markerService.onMarkerChanged(this._onMarkerChanged, this, this._callOnClose);
            return this._model;
        };
        MarkerController.prototype.closeMarkersNavigation = function () {
            this._cleanUp();
            this._editor.focus();
        };
        MarkerController.prototype._onMarkerChanged = function (changedResources) {
            var _this = this;
            if (!changedResources.some(function (r) { return _this._editor.getModel().uri.toString() === r.toString(); })) {
                return;
            }
            this._model.setMarkers(this._getMarkers());
        };
        MarkerController.prototype._getMarkers = function () {
            var resource = this._editor.getModel().uri, markers = this._markerService.read({ resource: resource });
            return markers;
        };
        MarkerController.ID = 'editor.contrib.markerController';
        MarkerController = __decorate([
            __param(1, markers_1.IMarkerService),
            __param(2, keybindingService_1.IKeybindingService)
        ], MarkerController);
        return MarkerController;
    }());
    var NextMarkerAction = (function (_super) {
        __extends(NextMarkerAction, _super);
        function NextMarkerAction(descriptor, editor, telemetryService) {
            _super.call(this, descriptor, editor, true, telemetryService);
        }
        NextMarkerAction.ID = 'editor.action.marker.next';
        NextMarkerAction = __decorate([
            __param(2, telemetry_1.ITelemetryService)
        ], NextMarkerAction);
        return NextMarkerAction;
    }(MarkerNavigationAction));
    var PrevMarkerAction = (function (_super) {
        __extends(PrevMarkerAction, _super);
        function PrevMarkerAction(descriptor, editor, telemetryService) {
            _super.call(this, descriptor, editor, false, telemetryService);
        }
        PrevMarkerAction.ID = 'editor.action.marker.prev';
        PrevMarkerAction = __decorate([
            __param(2, telemetry_1.ITelemetryService)
        ], PrevMarkerAction);
        return PrevMarkerAction;
    }(MarkerNavigationAction));
    var CONTEXT_MARKERS_NAVIGATION_VISIBLE = 'markersNavigationVisible';
    // register actions
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(NextMarkerAction, NextMarkerAction.ID, nls.localize(4, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyCode.F8
    }, 'Go to Next Error or Warning'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(PrevMarkerAction, PrevMarkerAction.ID, nls.localize(5, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.F8
    }, 'Go to Previous Error or Warning'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand('closeMarkersNavigation', editorCommonExtensions_1.CommonEditorRegistry.commandWeight(50), { primary: keyCodes_1.KeyCode.Escape, secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape] }, false, CONTEXT_MARKERS_NAVIGATION_VISIBLE, function (ctx, editor, args) {
        var controller = MarkerController.getMarkerController(editor);
        controller.closeMarkersNavigation();
    });
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(MarkerController);
});






define(__m[469], __M([0,1,37,14,8,23,3,59,2,4,17,167,287]), function (require, exports, arrays, async_1, errors_1, eventEmitter_1, lifecycle_1, timer, winjs_base_1, range_1, modes_1, quickFix_1, lightBulpWidget_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var QuickFixSuggestState;
    (function (QuickFixSuggestState) {
        QuickFixSuggestState[QuickFixSuggestState["NOT_ACTIVE"] = 0] = "NOT_ACTIVE";
        QuickFixSuggestState[QuickFixSuggestState["MANUAL_TRIGGER"] = 1] = "MANUAL_TRIGGER";
        QuickFixSuggestState[QuickFixSuggestState["AUTO_TRIGGER"] = 2] = "AUTO_TRIGGER";
    })(QuickFixSuggestState || (QuickFixSuggestState = {}));
    var QuickFixModel = (function (_super) {
        __extends(QuickFixModel, _super);
        function QuickFixModel(editor, markerService, onAccept) {
            var _this = this;
            _super.call(this);
            this.editor = editor;
            this.markerService = markerService;
            this.onAccept = onAccept;
            this.quickFixRequestPromise = null;
            this.lightBulpDecoration = [];
            this.toDispose = [];
            this.toLocalDispose = [];
            this.lightBulp = new lightBulpWidget_1.LightBulpWidget(editor, function (pos) { _this.onLightBulpClicked(pos); });
            this.enableAutoQuckFix = false; // turn off for now
            this.autoSuggestDelay = this.editor.getConfiguration().contribInfo.quickSuggestionsDelay;
            if (isNaN(this.autoSuggestDelay) || (!this.autoSuggestDelay && this.autoSuggestDelay !== 0) || this.autoSuggestDelay > 2000 || this.autoSuggestDelay < 0) {
                this.autoSuggestDelay = 300;
            }
            this.toDispose.push(this.editor.onDidChangeModel(function () { return _this.onModelChanged(); }));
            this.toDispose.push(this.editor.onDidChangeModelMode(function () { return _this.onModelChanged(); }));
            this.toDispose.push(modes_1.CodeActionProviderRegistry.onDidChange(this.onModelChanged, this));
        }
        QuickFixModel.prototype.onModelChanged = function () {
            var _this = this;
            this.cancelDialog();
            this.localDispose();
            this.lastMarker = null;
            this.lightBulpPosition = null;
            this.markers = null;
            this.updateScheduler = null;
            if (!modes_1.CodeActionProviderRegistry.has(this.editor.getModel()) || this.editor.getConfiguration().readOnly) {
                this.setDecoration(null);
                return;
            }
            this.markerService.onMarkerChanged(this.onMarkerChanged, this, this.toLocalDispose);
            this.toLocalDispose.push(this.editor.onDidChangeCursorPosition(function (e) {
                _this.onCursorPositionChanged();
            }));
        };
        QuickFixModel.prototype.onLightBulpClicked = function (pos) {
            this.triggerDialog(true, pos);
        };
        QuickFixModel.prototype.isSimilarMarker = function (marker1, marker2) {
            if (marker1) {
                return marker2 && marker1.owner === marker2.owner && marker1.code === marker2.code;
            }
            return !marker2;
        };
        QuickFixModel.prototype.onMarkerChanged = function (changedResources) {
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            var associatedResource = model.uri;
            if (!changedResources.some(function (r) { return associatedResource.toString() === r.toString(); })) {
                return;
            }
            var lastMarker = this.lastMarker;
            this.markers = null;
            this.lastMarker = null;
            var currentMarker = this.findMarker(this.editor.getPosition(), false);
            if (this.isSimilarMarker(currentMarker, lastMarker)) {
                this.lastMarker = currentMarker;
            }
            else {
                this.onCursorPositionChanged();
            }
        };
        QuickFixModel.prototype.setDecoration = function (pos) {
            this.lightBulpPosition = pos;
            this.updateDecoration();
        };
        QuickFixModel.prototype.updateDecoration = function () {
            if (this.lightBulpPosition && this.state === QuickFixSuggestState.NOT_ACTIVE) {
                this.lightBulp.show(this.lightBulpPosition);
            }
            else {
                this.lightBulp.hide();
            }
        };
        QuickFixModel.prototype.onCursorPositionChanged = function () {
            var _this = this;
            if (this.triggerAutoSuggestPromise) {
                this.triggerAutoSuggestPromise.cancel();
                this.triggerAutoSuggestPromise = null;
            }
            this.cancelDialog();
            if (!this.updateScheduler) {
                this.updateScheduler = new async_1.RunOnceScheduler(function () {
                    var marker = _this.lastMarker;
                    var pos = _this.editor.getPosition();
                    if (marker && range_1.Range.containsPosition(marker, pos)) {
                        // still on the same marker
                        if (_this.lightBulpPosition) {
                            _this.setDecoration(pos);
                        }
                        return;
                    }
                    _this.lastMarker = marker = _this.findMarker(pos, false);
                    if (!marker) {
                        // remove lightbulp
                        _this.setDecoration(null);
                        return;
                    }
                    var $tRequest = timer.start(timer.Topic.EDITOR, 'quickfix/lighbulp');
                    var computeFixesPromise = _this.computeFixes(marker);
                    computeFixesPromise.done(function (fixes) {
                        _this.setDecoration(!arrays.isFalsyOrEmpty(fixes) ? pos : null);
                        _this.triggerAutoSuggest(marker);
                        $tRequest.stop();
                    }, function (error) {
                        errors_1.onUnexpectedError(error);
                        _this.setDecoration(null);
                        $tRequest.stop();
                    });
                }, 250);
                this.toLocalDispose.push(this.updateScheduler);
            }
            this.updateScheduler.schedule();
        };
        QuickFixModel.prototype.computeFixes = function (range) {
            var model = this.editor.getModel();
            if (!modes_1.CodeActionProviderRegistry.has(model)) {
                return winjs_base_1.TPromise.as(null);
            }
            if (this.quickFixRequestPromise && range === this.quickFixRequestPromiseRange) {
                return this.quickFixRequestPromise;
            }
            if (this.quickFixRequestPromise) {
                this.quickFixRequestPromise.cancel();
                this.quickFixRequestPromise = null;
            }
            this.quickFixRequestPromiseRange = range;
            this.quickFixRequestPromise = quickFix_1.getCodeActions(model, range_1.Range.lift(range));
            return this.quickFixRequestPromise;
        };
        /**
         * Returns all marker sorted by startLineNumber
         */
        QuickFixModel.prototype.getMarkers = function () {
            if (this.markers !== null) {
                return this.markers;
            }
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            this.markers = this.markerService.read({ resource: model.uri })
                .sort(function (e1, e2) { return e1.startLineNumber - e2.startLineNumber; });
            return this.markers;
        };
        QuickFixModel.prototype.findMarker = function (pos, findOnSameLine) {
            if (this.lastMarker && range_1.Range.containsPosition(this.lastMarker, pos)) {
                return this.lastMarker;
            }
            var markers = this.getMarkers(); // makers sorted by line start number
            var result = null;
            var bestDistance = 0;
            var lineNumber = pos.lineNumber;
            // find first marker with a line number greater equal the current position
            var idx = arrays.findFirst(markers, function (m) { return m.startLineNumber >= lineNumber; });
            while (idx < markers.length && markers[idx].startLineNumber === lineNumber) {
                var marker = markers[idx];
                if (marker.startColumn <= pos.column && marker.endColumn >= pos.column) {
                    return marker;
                }
                if (findOnSameLine) {
                    var dist = pos.column < marker.startColumn ? marker.startColumn - pos.column : pos.column - marker.endColumn;
                    if (!result || dist < bestDistance) {
                        result = marker;
                        bestDistance = dist;
                    }
                }
                idx++;
            }
            return result;
        };
        QuickFixModel.prototype.cancelDialog = function (silent) {
            if (silent === void 0) { silent = false; }
            if (this.state !== QuickFixSuggestState.NOT_ACTIVE) {
                this.state = QuickFixSuggestState.NOT_ACTIVE;
                if (!silent) {
                    this.emit('cancel');
                }
                this.updateDecoration();
                return true;
            }
            return false;
        };
        QuickFixModel.prototype.isAutoSuggest = function () {
            return this.state === QuickFixSuggestState.AUTO_TRIGGER;
        };
        QuickFixModel.prototype.triggerAutoSuggest = function (marker) {
            var _this = this;
            if (this.enableAutoQuckFix && this.state === QuickFixSuggestState.NOT_ACTIVE) {
                this.triggerAutoSuggestPromise = winjs_base_1.TPromise.timeout(this.autoSuggestDelay);
                this.triggerAutoSuggestPromise.then(function () {
                    _this.triggerAutoSuggestPromise = null;
                    if (marker === _this.lastMarker) {
                        _this.triggerDialog(true, _this.editor.getPosition());
                    }
                });
            }
        };
        QuickFixModel.prototype.triggerDialog = function (auto, pos) {
            var _this = this;
            // Cancel previous requests, change state & update UI
            this.cancelDialog(false);
            var range;
            if (auto) {
                range = this.findMarker(pos, true);
                if (!range) {
                    return;
                }
            }
            else {
                range = this.findMarker(pos, true);
                if (!range) {
                    // no error on the same line: get code action for the current selection
                    range = this.editor.getSelection();
                }
                if (!range_1.Range.containsPosition(range, pos)) {
                    // move cursor
                    this.editor.setPosition({ lineNumber: range.startLineNumber, column: range.startColumn });
                }
            }
            var $tTrigger = timer.start(timer.Topic.EDITOR, 'quickfix/triggerdialog');
            this.state = auto ? QuickFixSuggestState.AUTO_TRIGGER : QuickFixSuggestState.MANUAL_TRIGGER;
            this.updateDecoration();
            this.emit('loading', { auto: this.isAutoSuggest() });
            this.computeFixes(range).done(function (fixes) {
                if (fixes && fixes.length > 0) {
                    fixes.sort(function (f1, f2) { return f2.score - f1.score; });
                    _this.emit('suggest', {
                        fixes: fixes,
                        range: range,
                        auto: _this.isAutoSuggest()
                    });
                }
                else {
                    _this.emit('empty', { auto: _this.isAutoSuggest() });
                }
                $tTrigger.stop();
            }, function (error) {
                errors_1.onUnexpectedError(error);
                _this.emit('empty', { auto: _this.isAutoSuggest() });
                $tTrigger.stop();
            });
        };
        QuickFixModel.prototype.accept = function (quickFix, range) {
            this.cancelDialog();
            if (!quickFix) {
                return false;
            }
            this.onAccept(quickFix, range);
            return true;
        };
        QuickFixModel.prototype.localDispose = function () {
            this.toLocalDispose = lifecycle_1.dispose(this.toLocalDispose);
            if (this.quickFixRequestPromise) {
                this.quickFixRequestPromise.cancel();
                this.quickFixRequestPromise = null;
            }
        };
        QuickFixModel.prototype.dispose = function () {
            this.localDispose();
            this.toDispose = lifecycle_1.dispose(this.toDispose);
            this.emit('destroy', null);
        };
        return QuickFixModel;
    }(eventEmitter_1.EventEmitter));
    exports.QuickFixModel = QuickFixModel;
});















define(__m[470], __M([0,1,343,8,12,2,43,82,19,73,42,36,20,13,17,30,469,345]), function (require, exports, nls, errors_1, keyCodes_1, winjs_base_1, editor_1, event_1, keybindingService_1, markers_1, message_1, telemetry_1, editorAction_1, editorCommonExtensions_1, modes_1, editorBrowserExtensions_1, quickFixModel_1, quickFixSelectionWidget_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var QuickFixController = (function () {
        function QuickFixController(editor, _markerService, _keybindingService, telemetryService, _eventService, editorService, messageService) {
            var _this = this;
            this._markerService = _markerService;
            this._keybindingService = _keybindingService;
            this._eventService = _eventService;
            this.editor = editor;
            this.model = new quickFixModel_1.QuickFixModel(this.editor, this._markerService, this.onAccept.bind(this));
            this.quickFixWidgetVisible = this._keybindingService.createKey(CONTEXT_QUICK_FIX_WIDGET_VISIBLE, false);
            this.suggestWidget = new quickFixSelectionWidget_1.QuickFixSelectionWidget(this.editor, telemetryService, function () {
                _this.quickFixWidgetVisible.set(true);
            }, function () {
                _this.quickFixWidgetVisible.reset();
            });
            this.suggestWidget.setModel(this.model);
        }
        QuickFixController.getQuickFixController = function (editor) {
            return editor.getContribution(QuickFixController.ID);
        };
        QuickFixController.prototype.getId = function () {
            return QuickFixController.ID;
        };
        QuickFixController.prototype.onAccept = function (fix, range) {
            var model = this.editor.getModel();
            if (model) {
                var command = fix.command;
                return (_a = this._keybindingService).executeCommand.apply(_a, [command.id].concat(command.arguments)).done(void 0, errors_1.onUnexpectedError);
            }
            var _a;
        };
        QuickFixController.prototype.run = function () {
            this.model.triggerDialog(false, this.editor.getPosition());
            this.editor.focus();
            return winjs_base_1.TPromise.as(false);
        };
        QuickFixController.prototype.dispose = function () {
            if (this.suggestWidget) {
                this.suggestWidget.destroy();
                this.suggestWidget = null;
            }
            if (this.model) {
                this.model.dispose();
                this.model = null;
            }
        };
        QuickFixController.prototype.acceptSelectedSuggestion = function () {
            if (this.suggestWidget) {
                this.suggestWidget.acceptSelectedSuggestion();
            }
        };
        QuickFixController.prototype.closeWidget = function () {
            if (this.model) {
                this.model.cancelDialog();
            }
        };
        QuickFixController.prototype.selectNextSuggestion = function () {
            if (this.suggestWidget) {
                this.suggestWidget.selectNext();
            }
        };
        QuickFixController.prototype.selectNextPageSuggestion = function () {
            if (this.suggestWidget) {
                this.suggestWidget.selectNextPage();
            }
        };
        QuickFixController.prototype.selectPrevSuggestion = function () {
            if (this.suggestWidget) {
                this.suggestWidget.selectPrevious();
            }
        };
        QuickFixController.prototype.selectPrevPageSuggestion = function () {
            if (this.suggestWidget) {
                this.suggestWidget.selectPreviousPage();
            }
        };
        QuickFixController.ID = 'editor.contrib.quickFixController';
        QuickFixController = __decorate([
            __param(1, markers_1.IMarkerService),
            __param(2, keybindingService_1.IKeybindingService),
            __param(3, telemetry_1.ITelemetryService),
            __param(4, event_1.IEventService),
            __param(5, editor_1.IEditorService),
            __param(6, message_1.IMessageService)
        ], QuickFixController);
        return QuickFixController;
    }());
    exports.QuickFixController = QuickFixController;
    var QuickFixAction = (function (_super) {
        __extends(QuickFixAction, _super);
        function QuickFixAction(descriptor, editor) {
            _super.call(this, descriptor, editor);
        }
        QuickFixAction.prototype.isSupported = function () {
            var model = this.editor.getModel();
            return modes_1.CodeActionProviderRegistry.has(model) && !this.editor.getConfiguration().readOnly;
        };
        QuickFixAction.prototype.run = function () {
            return QuickFixController.getQuickFixController(this.editor).run();
        };
        QuickFixAction.ID = 'editor.action.quickFix';
        return QuickFixAction;
    }(editorAction_1.EditorAction));
    exports.QuickFixAction = QuickFixAction;
    var CONTEXT_QUICK_FIX_WIDGET_VISIBLE = 'quickFixWidgetVisible';
    var weight = editorCommonExtensions_1.CommonEditorRegistry.commandWeight(80);
    // register action
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(QuickFixAction, QuickFixAction.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.US_DOT
    }, 'Quick Fix'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand('acceptQuickFixSuggestion', weight, { primary: keyCodes_1.KeyCode.Enter, secondary: [keyCodes_1.KeyCode.Tab] }, false, CONTEXT_QUICK_FIX_WIDGET_VISIBLE, function (ctx, editor, args) {
        var controller = QuickFixController.getQuickFixController(editor);
        controller.acceptSelectedSuggestion();
    });
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand('closeQuickFixWidget', weight, { primary: keyCodes_1.KeyCode.Escape, secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape] }, false, CONTEXT_QUICK_FIX_WIDGET_VISIBLE, function (ctx, editor, args) {
        var controller = QuickFixController.getQuickFixController(editor);
        controller.closeWidget();
    });
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand('selectNextQuickFix', weight, { primary: keyCodes_1.KeyCode.DownArrow }, false, CONTEXT_QUICK_FIX_WIDGET_VISIBLE, function (ctx, editor, args) {
        var controller = QuickFixController.getQuickFixController(editor);
        controller.selectNextSuggestion();
    });
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand('selectNextPageQuickFix', weight, { primary: keyCodes_1.KeyCode.PageDown }, false, CONTEXT_QUICK_FIX_WIDGET_VISIBLE, function (ctx, editor, args) {
        var controller = QuickFixController.getQuickFixController(editor);
        controller.selectNextPageSuggestion();
    });
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand('selectPrevQuickFix', weight, { primary: keyCodes_1.KeyCode.UpArrow }, false, CONTEXT_QUICK_FIX_WIDGET_VISIBLE, function (ctx, editor, args) {
        var controller = QuickFixController.getQuickFixController(editor);
        controller.selectPrevSuggestion();
    });
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand('selectPrevPageQuickFix', weight, { primary: keyCodes_1.KeyCode.PageUp }, false, CONTEXT_QUICK_FIX_WIDGET_VISIBLE, function (ctx, editor, args) {
        var controller = QuickFixController.getQuickFixController(editor);
        controller.selectPrevPageSuggestion();
    });
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(QuickFixController);
});

define(__m[471], __M([0,1,347,12,13,414]), function (require, exports, nls, keyCodes_1, editorCommonExtensions_1, gotoLine_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // Contribute Ctrl+G to "Go to line" using quick open
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(gotoLine_1.GotoLineAction, gotoLine_1.GotoLineAction.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_G,
        mac: { primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.KEY_G }
    }, 'Go to Line...'));
});

define(__m[472], __M([0,1,349,12,28,13,415]), function (require, exports, nls, keyCodes_1, browser, editorCommonExtensions_1, quickCommand_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // Contribute "Quick Command" to context menu
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(quickCommand_1.QuickCommandAction, quickCommand_1.QuickCommandAction.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: (browser.isIE11orEarlier ? keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.F1 : keyCodes_1.KeyCode.F1)
    }, 'Command Palette'));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[168], __M([0,1,8,29,2,4,13,17,34,14]), function (require, exports, errors_1, uri_1, winjs_base_1, range_1, editorCommonExtensions_1, modes_1, modelService_1, async_1) {
    'use strict';
    function getDocumentSymbols(model) {
        var entries = [];
        var promises = modes_1.DocumentSymbolProviderRegistry.all(model).map(function (support) {
            return async_1.asWinJsPromise(function (token) {
                return support.provideDocumentSymbols(model, token);
            }).then(function (result) {
                if (Array.isArray(result)) {
                    entries.push.apply(entries, result);
                }
            }, function (err) {
                errors_1.onUnexpectedError(err);
            });
        });
        return winjs_base_1.TPromise.join(promises).then(function () {
            var flatEntries = [];
            flatten(flatEntries, entries, '');
            flatEntries.sort(compareEntriesUsingStart);
            return {
                entries: flatEntries,
            };
        });
    }
    exports.getDocumentSymbols = getDocumentSymbols;
    function compareEntriesUsingStart(a, b) {
        return range_1.Range.compareRangesUsingStarts(range_1.Range.lift(a.location.range), range_1.Range.lift(b.location.range));
    }
    function flatten(bucket, entries, overrideContainerLabel) {
        for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
            var entry = entries_1[_i];
            bucket.push({
                kind: entry.kind,
                location: entry.location,
                name: entry.name,
                containerName: entry.containerName || overrideContainerLabel
            });
        }
    }
    editorCommonExtensions_1.CommonEditorRegistry.registerLanguageCommand('_executeDocumentSymbolProvider', function (accessor, args) {
        var resource = args.resource;
        if (!(resource instanceof uri_1.default)) {
            throw errors_1.illegalArgument('resource');
        }
        var model = accessor.get(modelService_1.IModelService).getModel(resource);
        if (!model) {
            throw errors_1.illegalArgument('resource');
        }
        return getDocumentSymbols(model);
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[474], __M([0,1,14,8,3,4,17,30,168,226]), function (require, exports, async_1, errors_1, lifecycle_1, range_1, modes_1, editorBrowserExtensions_1, quickOpen_1) {
    'use strict';
    var OutlineViewZone = (function () {
        function OutlineViewZone(range, outlineType) {
            this.afterLineNumber = range.startLineNumber - 1;
            this.heightInPx = 4;
            this.suppressMouseDown = true;
            this.domNode = document.createElement('div');
            var hr = document.createElement('hr');
            hr.className = 'outlineRule ' + modes_1.SymbolKind.from(outlineType);
            this.domNode.appendChild(hr);
        }
        return OutlineViewZone;
    }());
    var OutlineMarkerHelper = (function () {
        function OutlineMarkerHelper() {
            this._removeDecorations = [];
            this._addDecorations = [];
            this._addDecorationsCallbacks = [];
        }
        OutlineMarkerHelper.prototype.addDecoration = function (decoration, callback) {
            this._addDecorations.push(decoration);
            this._addDecorationsCallbacks.push(callback);
        };
        OutlineMarkerHelper.prototype.removeDecoration = function (decorationId) {
            this._removeDecorations.push(decorationId);
        };
        OutlineMarkerHelper.prototype.commit = function (changeAccessor) {
            var resultingDecorations = changeAccessor.deltaDecorations(this._removeDecorations, this._addDecorations);
            for (var i = 0, len = resultingDecorations.length; i < len; i++) {
                this._addDecorationsCallbacks[i](resultingDecorations[i]);
            }
        };
        return OutlineMarkerHelper;
    }());
    var OutlineMarker = (function () {
        function OutlineMarker(range, outlineType, _editor, helper, viewZoneChangeAccessor) {
            var _this = this;
            this._editor = _editor;
            this._viewZone = new OutlineViewZone(range, outlineType);
            this._viewZoneId = viewZoneChangeAccessor.addZone(this._viewZone);
            helper.addDecoration({
                range: range,
                options: {}
            }, function (decorationId) {
                _this._decorationId = decorationId;
            });
        }
        OutlineMarker.prototype.dispose = function (helper, viewZoneChangeAccessor) {
            helper.removeDecoration(this._decorationId);
            viewZoneChangeAccessor.removeZone(this._viewZoneId);
        };
        OutlineMarker.prototype.getLine = function () {
            return this._viewZone.afterLineNumber;
        };
        OutlineMarker.prototype.update = function (viewZoneChangeAccessor) {
            var range = this._editor.getModel().getDecorationRange(this._decorationId);
            this._viewZone.afterLineNumber = range.startLineNumber - 1;
            viewZoneChangeAccessor.layoutZone(this._viewZoneId);
        };
        return OutlineMarker;
    }());
    var OutlineMarkerContribution = (function () {
        function OutlineMarkerContribution(editor) {
            var _this = this;
            this._editor = editor;
            this._isEnabled = this._editor.getConfiguration().contribInfo.outlineMarkers;
            this._globalToDispose = [];
            this._localToDispose = [];
            this._markers = [];
            this._currentOutlinePromise = null;
            this._globalToDispose.push(this._editor.onDidChangeModel(function () { return _this.onChange(true); }));
            this._globalToDispose.push(this._editor.onDidChangeModelMode(function () { return _this.onChange(false); }));
            this._globalToDispose.push(this._editor.onDidChangeConfiguration(function (e) {
                var oldIsEnabled = _this._isEnabled;
                _this._isEnabled = _this._editor.getConfiguration().contribInfo.outlineMarkers;
                if (oldIsEnabled !== _this._isEnabled) {
                    _this.onChange(false);
                }
            }));
            this.onChange(false);
        }
        OutlineMarkerContribution.prototype.dispose = function () {
            this.localDispose();
            this._globalToDispose = lifecycle_1.dispose(this._globalToDispose);
        };
        OutlineMarkerContribution.prototype.localDispose = function () {
            if (this._currentOutlinePromise) {
                this._currentOutlinePromise.cancel();
            }
            this._localToDispose = lifecycle_1.dispose(this._localToDispose);
        };
        OutlineMarkerContribution.prototype.getId = function () {
            return OutlineMarkerContribution.ID;
        };
        OutlineMarkerContribution.prototype.onChange = function (markersAlreadyDisposed) {
            var _this = this;
            if (markersAlreadyDisposed) {
                this._markers = [];
            }
            this.localDispose();
            if (!this._isEnabled) {
                return;
            }
            var model = this._editor.getModel();
            if (!model) {
                return;
            }
            if (!modes_1.DocumentSymbolProviderRegistry.has(model)) {
                return;
            }
            var scheduler = new async_1.RunOnceScheduler(function () {
                if (_this._currentOutlinePromise) {
                    _this._currentOutlinePromise.cancel();
                }
                _this._currentOutlinePromise = quickOpen_1.getDocumentSymbols(model);
                _this._currentOutlinePromise.then(function (result) {
                    _this.renderOutlines(result.entries);
                }, function (error) {
                    errors_1.onUnexpectedError(error);
                });
            }, 250);
            this._localToDispose.push(scheduler);
            this._localToDispose.push(this._editor.onDidChangeModelContent(function () {
                // Synchronously move markers
                _this._editor.changeViewZones(function (viewAccessor) {
                    _this._markers.forEach(function (marker) {
                        marker.update(viewAccessor);
                    });
                });
                scheduler.schedule();
            }));
            this._localToDispose.push({
                dispose: function () {
                    if (_this._markers.length > 0) {
                        var helper = new OutlineMarkerHelper();
                        _this._editor.changeViewZones(function (accessor) {
                            _this._markers.forEach(function (marker) { return marker.dispose(helper, accessor); });
                            _this._markers = [];
                        });
                        _this._editor.changeDecorations(function (accessor) {
                            helper.commit(accessor);
                        });
                    }
                }
            });
            scheduler.schedule();
        };
        OutlineMarkerContribution.prototype.renderOutlines = function (entries) {
            var _this = this;
            var centeredRange = this._editor.getCenteredRangeInViewport();
            var oldMarkersCount = this._markers.length;
            this._editor.changeDecorations(function (decorationsAccessor) {
                var helper = new OutlineMarkerHelper();
                _this._editor.changeViewZones(function (viewzonesAccessor) {
                    _this._markers.forEach(function (marker) { return marker.dispose(helper, viewzonesAccessor); });
                    _this._markers = [];
                    _this.renderOutlinesRecursive(entries, helper, viewzonesAccessor);
                });
                helper.commit(decorationsAccessor);
            });
            var newMarkersCount = this._markers.length;
            if (Math.abs(oldMarkersCount - newMarkersCount) > 1) {
                // Reveal only if the delta is more than 1 marker
                this._editor.revealRangeInCenter(centeredRange);
            }
        };
        OutlineMarkerContribution.prototype.renderOutlinesRecursive = function (entries, helper, viewZoneChangeAccessor) {
            var _this = this;
            if (entries) {
                entries.forEach(function (outline) {
                    if (outline.kind === modes_1.SymbolKind.Class || outline.kind === modes_1.SymbolKind.Method || outline.kind === modes_1.SymbolKind.Function) {
                        var range = range_1.Range.lift(outline.location.range);
                        if (!_this.alreadyHasMarkerAtRange(range)) {
                            var marker = new OutlineMarker(range, outline.kind, _this._editor, helper, viewZoneChangeAccessor);
                            _this._markers.push(marker);
                        }
                    }
                });
            }
        };
        OutlineMarkerContribution.prototype.alreadyHasMarkerAtRange = function (range) {
            for (var i = 0; i < this._markers.length; ++i) {
                if (this._markers[i].getLine() === range.startLineNumber - 1) {
                    return true;
                }
            }
            return false;
        };
        OutlineMarkerContribution.ID = 'editor.outlineMarker';
        return OutlineMarkerContribution;
    }());
    exports.OutlineMarkerContribution = OutlineMarkerContribution;
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(OutlineMarkerContribution);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[475], __M([0,1,350,8,65,10,2,105,91,25,17,107,168,237]), function (require, exports, nls, errors_1, filters_1, strings, winjs_base_1, quickOpenModel_1, quickOpen_1, editorActionEnablement_1, modes_1, editorQuickOpen_1, quickOpen_2) {
    'use strict';
    var SCOPE_PREFIX = ':';
    var SymbolEntry = (function (_super) {
        __extends(SymbolEntry, _super);
        function SymbolEntry(name, type, description, range, highlights, editor, decorator) {
            _super.call(this);
            this.name = name;
            this.type = type;
            this.description = description;
            this.range = range;
            this.setHighlights(highlights);
            this.editor = editor;
            this.decorator = decorator;
        }
        SymbolEntry.prototype.getLabel = function () {
            return this.name;
        };
        SymbolEntry.prototype.getAriaLabel = function () {
            return nls.localize(0, null, this.name);
        };
        SymbolEntry.prototype.getIcon = function () {
            return this.type;
        };
        SymbolEntry.prototype.getDescription = function () {
            return this.description;
        };
        SymbolEntry.prototype.getType = function () {
            return this.type;
        };
        SymbolEntry.prototype.getRange = function () {
            return this.range;
        };
        SymbolEntry.prototype.run = function (mode, context) {
            if (mode === quickOpen_1.Mode.OPEN) {
                return this.runOpen(context);
            }
            return this.runPreview();
        };
        SymbolEntry.prototype.runOpen = function (context) {
            // Apply selection and focus
            var range = this.toSelection();
            this.editor.setSelection(range);
            this.editor.revealRangeInCenter(range);
            this.editor.focus();
            return true;
        };
        SymbolEntry.prototype.runPreview = function () {
            // Select Outline Position
            var range = this.toSelection();
            this.editor.revealRangeInCenter(range);
            // Decorate if possible
            this.decorator.decorateLine(this.range, this.editor);
            return false;
        };
        SymbolEntry.prototype.toSelection = function () {
            return {
                startLineNumber: this.range.startLineNumber,
                startColumn: this.range.startColumn || 1,
                endLineNumber: this.range.startLineNumber,
                endColumn: this.range.startColumn || 1
            };
        };
        return SymbolEntry;
    }(quickOpenModel_1.QuickOpenEntryGroup));
    var QuickOutlineAction = (function (_super) {
        __extends(QuickOutlineAction, _super);
        function QuickOutlineAction(descriptor, editor) {
            _super.call(this, descriptor, editor, nls.localize(1, null), editorActionEnablement_1.Behaviour.WidgetFocus | editorActionEnablement_1.Behaviour.ShowInContextMenu);
        }
        QuickOutlineAction.prototype.getGroupId = function () {
            return '1_goto/5_visitSymbol';
        };
        QuickOutlineAction.prototype.isSupported = function () {
            return (modes_1.DocumentSymbolProviderRegistry.has(this.editor.getModel()) && _super.prototype.isSupported.call(this));
        };
        QuickOutlineAction.prototype.run = function () {
            var _this = this;
            var model = this.editor.getModel();
            if (!modes_1.DocumentSymbolProviderRegistry.has(model)) {
                return null;
            }
            // Resolve outline
            var promise = quickOpen_2.getDocumentSymbols(model);
            return promise.then(function (result) {
                if (result.entries.length > 0) {
                    // Cache result
                    _this.cachedResult = result.entries;
                    return _super.prototype.run.call(_this);
                }
                return winjs_base_1.TPromise.as(true);
            }, function (err) {
                errors_1.onUnexpectedError(err);
                return false;
            });
        };
        QuickOutlineAction.prototype._getModel = function (value) {
            return new quickOpenModel_1.QuickOpenModel(this.toQuickOpenEntries(this.cachedResult, value));
        };
        QuickOutlineAction.prototype._getAutoFocus = function (searchValue) {
            // Remove any type pattern (:) from search value as needed
            if (searchValue.indexOf(SCOPE_PREFIX) === 0) {
                searchValue = searchValue.substr(SCOPE_PREFIX.length);
            }
            return {
                autoFocusPrefixMatch: searchValue,
                autoFocusFirstEntry: !!searchValue
            };
        };
        QuickOutlineAction.prototype._getInputAriaLabel = function () {
            return nls.localize(2, null);
        };
        QuickOutlineAction.prototype.toQuickOpenEntries = function (flattened, searchValue) {
            var results = [];
            // Convert to Entries
            var normalizedSearchValue = searchValue;
            if (searchValue.indexOf(SCOPE_PREFIX) === 0) {
                normalizedSearchValue = normalizedSearchValue.substr(SCOPE_PREFIX.length);
            }
            for (var i = 0; i < flattened.length; i++) {
                var element = flattened[i];
                var label = strings.trim(element.name);
                // Check for meatch
                var highlights = filters_1.matchesFuzzy(normalizedSearchValue, label);
                if (highlights) {
                    // Show parent scope as description
                    var description = null;
                    if (element.containerName) {
                        description = element.containerName;
                    }
                    // Add
                    results.push(new SymbolEntry(label, modes_1.SymbolKind.from(element.kind), description, element.location.range, highlights, this.editor, this));
                }
            }
            // Sort properly if actually searching
            if (searchValue) {
                if (searchValue.indexOf(SCOPE_PREFIX) === 0) {
                    results = results.sort(this.sortScoped.bind(this, searchValue.toLowerCase()));
                }
                else {
                    results = results.sort(this.sortNormal.bind(this, searchValue.toLowerCase()));
                }
            }
            // Mark all type groups
            if (results.length > 0 && searchValue.indexOf(SCOPE_PREFIX) === 0) {
                var currentType = null;
                var currentResult = null;
                var typeCounter = 0;
                for (var i = 0; i < results.length; i++) {
                    var result = results[i];
                    // Found new type
                    if (currentType !== result.getType()) {
                        // Update previous result with count
                        if (currentResult) {
                            currentResult.setGroupLabel(this.typeToLabel(currentType, typeCounter));
                        }
                        currentType = result.getType();
                        currentResult = result;
                        typeCounter = 1;
                        result.setShowBorder(i > 0);
                    }
                    else {
                        typeCounter++;
                    }
                }
                // Update previous result with count
                if (currentResult) {
                    currentResult.setGroupLabel(this.typeToLabel(currentType, typeCounter));
                }
            }
            else if (results.length > 0) {
                results[0].setGroupLabel(nls.localize(3, null, results.length));
            }
            return results;
        };
        QuickOutlineAction.prototype.typeToLabel = function (type, count) {
            switch (type) {
                case 'module': return nls.localize(4, null, count);
                case 'class': return nls.localize(5, null, count);
                case 'interface': return nls.localize(6, null, count);
                case 'method': return nls.localize(7, null, count);
                case 'function': return nls.localize(8, null, count);
                case 'property': return nls.localize(9, null, count);
                case 'variable': return nls.localize(10, null, count);
                case 'var': return nls.localize(11, null, count);
                case 'constructor': return nls.localize(12, null, count);
                case 'call': return nls.localize(13, null, count);
            }
            return type;
        };
        QuickOutlineAction.prototype.sortNormal = function (searchValue, elementA, elementB) {
            var elementAName = elementA.getLabel().toLowerCase();
            var elementBName = elementB.getLabel().toLowerCase();
            // Compare by name
            var r = strings.localeCompare(elementAName, elementBName);
            if (r !== 0) {
                return r;
            }
            // If name identical sort by range instead
            var elementARange = elementA.getRange();
            var elementBRange = elementB.getRange();
            return elementARange.startLineNumber - elementBRange.startLineNumber;
        };
        QuickOutlineAction.prototype.sortScoped = function (searchValue, elementA, elementB) {
            // Remove scope char
            searchValue = searchValue.substr(SCOPE_PREFIX.length);
            // Sort by type first if scoped search
            var elementAType = elementA.getType();
            var elementBType = elementB.getType();
            var r = strings.localeCompare(elementAType, elementBType);
            if (r !== 0) {
                return r;
            }
            // Special sort when searching in scoped mode
            if (searchValue) {
                var elementAName = elementA.getLabel().toLowerCase();
                var elementBName = elementB.getLabel().toLowerCase();
                // Compare by name
                var r_1 = strings.localeCompare(elementAName, elementBName);
                if (r_1 !== 0) {
                    return r_1;
                }
            }
            // Default to sort by range
            var elementARange = elementA.getRange();
            var elementBRange = elementB.getRange();
            return elementARange.startLineNumber - elementBRange.startLineNumber;
        };
        QuickOutlineAction.prototype._onClose = function (canceled) {
            _super.prototype._onClose.call(this, canceled);
            // Clear Cache
            this.cachedResult = null;
        };
        QuickOutlineAction.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            // Clear Cache
            this.cachedResult = null;
        };
        QuickOutlineAction.ID = 'editor.action.quickOutline';
        return QuickOutlineAction;
    }(editorQuickOpen_1.BaseEditorQuickOpenAction));
    exports.QuickOutlineAction = QuickOutlineAction;
});

define(__m[476], __M([0,1,351,12,13,475]), function (require, exports, nls, keyCodes_1, editorCommonExtensions_1, quickOutline_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // Contribute "Quick Outline" to context menu
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(quickOutline_1.QuickOutlineAction, quickOutline_1.QuickOutlineAction.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_O
    }, 'Go to Symbol...'));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[477], __M([0,1,8,2,13,17,14]), function (require, exports, errors_1, winjs_base_1, editorCommonExtensions_1, modes_1, async_1) {
    'use strict';
    function provideReferences(model, position) {
        // collect references from all providers
        var promises = modes_1.ReferenceProviderRegistry.ordered(model).map(function (provider) {
            return async_1.asWinJsPromise(function (token) {
                return provider.provideReferences(model, position, { includeDeclaration: true }, token);
            }).then(function (result) {
                if (Array.isArray(result)) {
                    return result;
                }
            }, function (err) {
                errors_1.onUnexpectedError(err);
            });
        });
        return winjs_base_1.TPromise.join(promises).then(function (references) {
            var result = [];
            for (var _i = 0, references_1 = references; _i < references_1.length; _i++) {
                var ref = references_1[_i];
                if (ref) {
                    result.push.apply(result, ref);
                }
            }
            return result;
        });
    }
    exports.provideReferences = provideReferences;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeReferenceProvider', provideReferences);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[478], __M([0,1,358,14,8,13,17]), function (require, exports, nls_1, async_1, errors_1, editorCommonExtensions_1, modes_1) {
    'use strict';
    function rename(model, position, newName) {
        var supports = modes_1.RenameProviderRegistry.ordered(model);
        var rejects = [];
        var hasResult = false;
        var factory = supports.map(function (support) {
            return function () {
                if (!hasResult) {
                    return async_1.asWinJsPromise(function (token) {
                        return support.provideRenameEdits(model, position, newName, token);
                    }).then(function (result) {
                        if (!result) {
                        }
                        else if (!result.rejectReason) {
                            hasResult = true;
                            return result;
                        }
                        else {
                            rejects.push(result.rejectReason);
                        }
                    });
                }
            };
        });
        return async_1.sequence(factory).then(function (values) {
            var result = values[0];
            if (rejects.length > 0) {
                return {
                    edits: undefined,
                    rejectReason: rejects.join('\n')
                };
            }
            else if (!result) {
                return {
                    edits: undefined,
                    rejectReason: nls_1.localize(0, null)
                };
            }
            else {
                return result;
            }
        });
    }
    exports.rename = rename;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeDocumentRenameProvider', function (model, position, args) {
        var newName = args.newName;
        if (typeof newName !== 'string') {
            throw errors_1.illegalArgument('newName');
        }
        return rename(model, position, newName);
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[479], __M([0,1,355,8,12,32,2,43,82,19,42,20,25,13,17,394,478,357]), function (require, exports, nls, errors_1, keyCodes_1, severity_1, winjs_base_1, editor_1, event_1, keybindingService_1, message_1, editorAction_1, editorActionEnablement_1, editorCommonExtensions_1, modes_1, bulkEdit_1, rename_1, renameInputField_1) {
    'use strict';
    // ---  register actions and commands
    var CONTEXT_RENAME_INPUT_VISIBLE = 'renameInputVisible';
    // ---- action implementation
    var RenameAction = (function (_super) {
        __extends(RenameAction, _super);
        function RenameAction(descriptor, editor, messageService, keybindingService, eventService, editorService) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.WidgetFocus | editorActionEnablement_1.Behaviour.Writeable | editorActionEnablement_1.Behaviour.ShowInContextMenu | editorActionEnablement_1.Behaviour.UpdateOnCursorPositionChange);
            this._messageService = messageService;
            this._eventService = eventService;
            this._editorService = editorService;
            this._renameInputField = new renameInputField_1.default(editor);
            this._renameInputVisible = keybindingService.createKey(CONTEXT_RENAME_INPUT_VISIBLE, false);
        }
        RenameAction.prototype.getGroupId = function () {
            return '2_change/1_rename2';
        };
        RenameAction.prototype.isSupported = function () {
            return modes_1.RenameProviderRegistry.has(this.editor.getModel()) && !this.editor.getModel().hasEditableRange() && _super.prototype.isSupported.call(this);
        };
        RenameAction.prototype.getEnablementState = function () {
            return modes_1.RenameProviderRegistry.has(this.editor.getModel());
        };
        RenameAction.prototype.run = function (event) {
            var _this = this;
            var selection = this.editor.getSelection(), word = this.editor.getModel().getWordAtPosition(selection.getStartPosition());
            if (!word) {
                return;
            }
            var lineNumber = selection.startLineNumber, selectionStart = 0, selectionEnd = word.word.length, wordRange;
            wordRange = {
                startLineNumber: lineNumber,
                startColumn: word.startColumn,
                endLineNumber: lineNumber,
                endColumn: word.endColumn
            };
            if (!selection.isEmpty() && selection.startLineNumber === selection.endLineNumber) {
                selectionStart = Math.max(0, selection.startColumn - word.startColumn);
                selectionEnd = Math.min(word.endColumn, selection.endColumn) - word.startColumn;
            }
            this._renameInputVisible.set(true);
            return this._renameInputField.getInput(wordRange, word.word, selectionStart, selectionEnd).then(function (newName) {
                _this._renameInputVisible.reset();
                return _this._prepareRename(newName).then(function (edit) {
                    return edit.finish().then(function (selection) {
                        _this.editor.focus();
                        if (selection) {
                            _this.editor.setSelection(selection);
                        }
                    });
                }, function (err) {
                    if (typeof err === 'string') {
                        _this._messageService.show(severity_1.default.Info, err);
                    }
                    else {
                        return winjs_base_1.TPromise.wrapError(err);
                    }
                });
            }, function (err) {
                _this._renameInputVisible.reset();
                _this.editor.focus();
                if (!errors_1.isPromiseCanceledError(err)) {
                    return winjs_base_1.TPromise.wrapError(err);
                }
            });
        };
        RenameAction.prototype.acceptRenameInput = function () {
            this._renameInputField.acceptInput();
        };
        RenameAction.prototype.cancelRenameInput = function () {
            this._renameInputField.cancelInput();
        };
        RenameAction.prototype._prepareRename = function (newName) {
            // start recording of file changes so that we can figure out if a file that
            // is to be renamed conflicts with another (concurrent) modification
            var edit = bulkEdit_1.createBulkEdit(this._eventService, this._editorService, this.editor);
            return rename_1.rename(this.editor.getModel(), this.editor.getPosition(), newName).then(function (result) {
                if (result.rejectReason) {
                    return winjs_base_1.TPromise.wrapError(result.rejectReason);
                }
                edit.add(result.edits);
                return edit;
            });
        };
        RenameAction.ID = 'editor.action.rename';
        RenameAction = __decorate([
            __param(2, message_1.IMessageService),
            __param(3, keybindingService_1.IKeybindingService),
            __param(4, event_1.IEventService),
            __param(5, editor_1.IEditorService)
        ], RenameAction);
        return RenameAction;
    }(editorAction_1.EditorAction));
    exports.RenameAction = RenameAction;
    var weight = editorCommonExtensions_1.CommonEditorRegistry.commandWeight(99);
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(RenameAction, RenameAction.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyCode.F2
    }, 'Rename Symbol'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand('acceptRenameInput', weight, { primary: keyCodes_1.KeyCode.Enter }, false, CONTEXT_RENAME_INPUT_VISIBLE, function (ctx, editor, args) {
        var action = editor.getAction(RenameAction.ID);
        action.acceptRenameInput();
    });
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand('cancelRenameInput', weight, { primary: keyCodes_1.KeyCode.Escape, secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape] }, false, CONTEXT_RENAME_INPUT_VISIBLE, function (ctx, editor, args) {
        var action = editor.getAction(RenameAction.ID);
        action.cancelRenameInput();
    });
});






define(__m[480], __M([0,1,359,12,2,20,25,7,13]), function (require, exports, nls, keyCodes_1, winjs_base_1, editorAction_1, editorActionEnablement_1, editorCommon_1, editorCommonExtensions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var SelectBracketAction = (function (_super) {
        __extends(SelectBracketAction, _super);
        function SelectBracketAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.TextFocus);
        }
        SelectBracketAction.prototype.run = function () {
            this.editor.trigger(this.id, editorCommon_1.Handler.JumpToBracket, {});
            return winjs_base_1.TPromise.as(true);
        };
        SelectBracketAction.ID = 'editor.action.jumpToBracket';
        return SelectBracketAction;
    }(editorAction_1.EditorAction));
    // register actions
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(SelectBracketAction, SelectBracketAction.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.US_BACKSLASH
    }, 'Go to Bracket'));
});















define(__m[481], __M([0,1,360,37,12,2,15,4,20,25,13,385]), function (require, exports, nls, arrays, keyCodes_1, winjs_base_1, instantiation_1, range_1, editorAction_1, editorActionEnablement_1, editorCommonExtensions_1, tokenSelectionSupport_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    // --- selection state machine
    var State = (function () {
        function State(editor) {
            this.editor = editor;
            this.next = null;
            this.previous = null;
            this.selection = editor.getSelection();
        }
        return State;
    }());
    // --- shared state between grow and shrink actions
    var state = null;
    var ignoreSelection = false;
    // -- action implementation
    var SmartSelect = (function (_super) {
        __extends(SmartSelect, _super);
        function SmartSelect(descriptor, editor, forward, instantiationService) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.TextFocus | editorActionEnablement_1.Behaviour.UpdateOnModelChange);
            this._tokenSelectionSupport = instantiationService.createInstance(tokenSelectionSupport_1.TokenSelectionSupport);
            this._forward = forward;
        }
        SmartSelect.prototype.run = function () {
            var _this = this;
            var selection = this.editor.getSelection();
            var model = this.editor.getModel();
            // forget about current state
            if (state) {
                if (state.editor !== this.editor) {
                    state = null;
                }
            }
            var promise = winjs_base_1.TPromise.as(null);
            if (!state) {
                promise = this._tokenSelectionSupport.getRangesToPosition(model.uri, selection.getStartPosition()).then(function (elements) {
                    if (arrays.isFalsyOrEmpty(elements)) {
                        return;
                    }
                    var lastState;
                    elements.filter(function (element) {
                        // filter ranges inside the selection
                        var selection = _this.editor.getSelection();
                        var range = new range_1.Range(element.range.startLineNumber, element.range.startColumn, element.range.endLineNumber, element.range.endColumn);
                        return range.containsPosition(selection.getStartPosition()) && range.containsPosition(selection.getEndPosition());
                    }).forEach(function (element) {
                        // create ranges
                        var range = element.range;
                        var state = new State(_this.editor);
                        state.selection = new range_1.Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
                        if (lastState) {
                            state.next = lastState;
                            lastState.previous = state;
                        }
                        lastState = state;
                    });
                    // insert current selection
                    var editorState = new State(_this.editor);
                    editorState.next = lastState;
                    if (lastState) {
                        lastState.previous = editorState;
                    }
                    state = editorState;
                    // listen to caret move and forget about state
                    var unhook = _this.editor.onDidChangeCursorPosition(function (e) {
                        if (ignoreSelection) {
                            return;
                        }
                        state = null;
                        unhook.dispose();
                    });
                });
            }
            return promise.then(function () {
                if (!state) {
                    return;
                }
                state = _this._forward ? state.next : state.previous;
                if (!state) {
                    return;
                }
                ignoreSelection = true;
                try {
                    _this.editor.setSelection(state.selection);
                }
                finally {
                    ignoreSelection = false;
                }
                return true;
            });
        };
        return SmartSelect;
    }(editorAction_1.EditorAction));
    var GrowSelectionAction = (function (_super) {
        __extends(GrowSelectionAction, _super);
        function GrowSelectionAction(descriptor, editor, instantiationService) {
            _super.call(this, descriptor, editor, true, instantiationService);
        }
        GrowSelectionAction.ID = 'editor.action.smartSelect.grow';
        GrowSelectionAction = __decorate([
            __param(2, instantiation_1.IInstantiationService)
        ], GrowSelectionAction);
        return GrowSelectionAction;
    }(SmartSelect));
    var ShrinkSelectionAction = (function (_super) {
        __extends(ShrinkSelectionAction, _super);
        function ShrinkSelectionAction(descriptor, editor, instantiationService) {
            _super.call(this, descriptor, editor, false, instantiationService);
        }
        ShrinkSelectionAction.ID = 'editor.action.smartSelect.shrink';
        ShrinkSelectionAction = __decorate([
            __param(2, instantiation_1.IInstantiationService)
        ], ShrinkSelectionAction);
        return ShrinkSelectionAction;
    }(SmartSelect));
    // register actions
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(GrowSelectionAction, GrowSelectionAction.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.RightArrow,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.RightArrow }
    }, 'Expand Select'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(ShrinkSelectionAction, ShrinkSelectionAction.ID, nls.localize(1, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.LeftArrow,
        mac: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.LeftArrow }
    }, 'Shrink Select'));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[93], __M([0,1,48,12,10,19,62,4,24,7,13,3]), function (require, exports, collections, keyCodes_1, strings, keybindingService_1, editOperation_1, range_1, selection_1, editorCommon, editorCommonExtensions_1, lifecycle_1) {
    'use strict';
    (function (ExternalSnippetType) {
        ExternalSnippetType[ExternalSnippetType["TextMateSnippet"] = 0] = "TextMateSnippet";
        ExternalSnippetType[ExternalSnippetType["EmmetSnippet"] = 1] = "EmmetSnippet";
    })(exports.ExternalSnippetType || (exports.ExternalSnippetType = {}));
    var ExternalSnippetType = exports.ExternalSnippetType;
    var CodeSnippet = (function () {
        function CodeSnippet(snippetTemplate) {
            this.lines = [];
            this.placeHolders = [];
            this._lastGeneratedId = 0;
            this.startPlaceHolderIndex = 0;
            this.finishPlaceHolderIndex = -1;
            this.parseTemplate(snippetTemplate);
        }
        CodeSnippet.prototype.parseTemplate = function (template) {
            var placeHoldersMap = {};
            var i, len, j, lenJ, templateLines = template.split('\n');
            for (i = 0, len = templateLines.length; i < len; i++) {
                var parsedLine = this.parseLine(templateLines[i], function (id) {
                    if (collections.contains(placeHoldersMap, id)) {
                        return placeHoldersMap[id].value;
                    }
                    return '';
                });
                for (j = 0, lenJ = parsedLine.placeHolders.length; j < lenJ; j++) {
                    var linePlaceHolder = parsedLine.placeHolders[j];
                    var occurence = new range_1.Range(i + 1, linePlaceHolder.startColumn, i + 1, linePlaceHolder.endColumn);
                    var placeHolder;
                    if (collections.contains(placeHoldersMap, linePlaceHolder.id)) {
                        placeHolder = placeHoldersMap[linePlaceHolder.id];
                    }
                    else {
                        placeHolder = {
                            id: linePlaceHolder.id,
                            value: linePlaceHolder.value,
                            occurences: []
                        };
                        this.placeHolders.push(placeHolder);
                        if (linePlaceHolder.value === '') {
                            this.finishPlaceHolderIndex = this.placeHolders.length - 1;
                        }
                        placeHoldersMap[linePlaceHolder.id] = placeHolder;
                    }
                    placeHolder.occurences.push(occurence);
                }
                this.lines.push(parsedLine.line);
            }
            if (this.placeHolders.length > this.startPlaceHolderIndex) {
                var startPlaceHolder = this.placeHolders[this.startPlaceHolderIndex];
                if (startPlaceHolder.value === '' && startPlaceHolder.id === '') {
                    // Do not start at an empty placeholder if possible
                    if (this.placeHolders.length > 1) {
                        this.startPlaceHolderIndex++;
                    }
                }
            }
        };
        CodeSnippet.prototype.parseLine = function (line, findDefaultValueForId) {
            // Placeholder 0 is the entire line
            var placeHolderStack = [{ placeHolderId: '', placeHolderText: '' }];
            var placeHolders = [];
            var i = 0;
            var len = line.length;
            var resultIndex = 0;
            while (i < len) {
                var restOfLine = line.substr(i);
                // Look for the start of a placeholder {{
                if (/^{{/.test(restOfLine)) {
                    i += 2;
                    placeHolderStack.push({ placeHolderId: '', placeHolderText: '' });
                    // Look for id
                    var matches = restOfLine.match(/^{{(\w+):/);
                    if (Array.isArray(matches) && matches.length === 2) {
                        placeHolderStack[placeHolderStack.length - 1].placeHolderId = matches[1];
                        i += matches[1].length + 1; // +1 to account for the : at the end of the id
                    }
                    continue;
                }
                // Look for the end of a placeholder. placeHolderStack[0] is the top-level line.
                if (placeHolderStack.length > 1 && /^}}/.test(restOfLine)) {
                    i += 2;
                    if (placeHolderStack[placeHolderStack.length - 1].placeHolderId.length === 0) {
                        // This placeholder did not have an explicit id
                        placeHolderStack[placeHolderStack.length - 1].placeHolderId = placeHolderStack[placeHolderStack.length - 1].placeHolderText;
                        if (placeHolderStack[placeHolderStack.length - 1].placeHolderId === '_') {
                            // This is just an empty tab stop
                            placeHolderStack[placeHolderStack.length - 1].placeHolderId = 'TAB_STOP_' + String(++this._lastGeneratedId);
                            placeHolderStack[placeHolderStack.length - 1].placeHolderText = '';
                            --resultIndex; // Roll back one iteration of the result index as we made the text empty
                        }
                    }
                    if (placeHolderStack[placeHolderStack.length - 1].placeHolderText.length === 0) {
                        // This placeholder is empty or was a mirror
                        var defaultValue = findDefaultValueForId(placeHolderStack[placeHolderStack.length - 1].placeHolderId);
                        placeHolderStack[placeHolderStack.length - 1].placeHolderText = defaultValue;
                        resultIndex += defaultValue.length;
                    }
                    placeHolders.push({
                        id: placeHolderStack[placeHolderStack.length - 1].placeHolderId,
                        value: placeHolderStack[placeHolderStack.length - 1].placeHolderText,
                        startColumn: resultIndex + 1 - placeHolderStack[placeHolderStack.length - 1].placeHolderText.length,
                        endColumn: resultIndex + 1
                    });
                    // Insert our text into the previous placeholder
                    placeHolderStack[placeHolderStack.length - 2].placeHolderText += placeHolderStack[placeHolderStack.length - 1].placeHolderText;
                    placeHolderStack.pop();
                    continue;
                }
                // Look for escapes
                if (/^\\./.test(restOfLine)) {
                    if (restOfLine.charAt(1) === '{' || restOfLine.charAt(1) === '}' || restOfLine.charAt(1) === '\\') {
                        ++i; // Skip the escape slash and take the character literally
                    }
                    else {
                        // invalid escapes
                        placeHolderStack[placeHolderStack.length - 1].placeHolderText += line.charAt(i);
                        ++resultIndex;
                        ++i;
                    }
                }
                //This is an escape sequence or not a special character, just insert it
                placeHolderStack[placeHolderStack.length - 1].placeHolderText += line.charAt(i);
                ++resultIndex;
                ++i;
            }
            // Sort the placeholder in order of apperance:
            placeHolders.sort(function (a, b) {
                if (a.startColumn < b.startColumn) {
                    return -1;
                }
                if (a.startColumn > b.startColumn) {
                    return 1;
                }
                if (a.endColumn < b.endColumn) {
                    return -1;
                }
                if (a.endColumn > b.endColumn) {
                    return 1;
                }
                return 0;
            });
            return {
                line: placeHolderStack[0].placeHolderText,
                placeHolders: placeHolders
            };
        };
        // This is used for both TextMate and Emmet
        CodeSnippet.convertExternalSnippet = function (snippet, snippetType) {
            var openBraces = 0;
            var convertedSnippet = '';
            var i = 0;
            var len = snippet.length;
            while (i < len) {
                var restOfLine = snippet.substr(i);
                // Cursor tab stop
                if (/^\$0/.test(restOfLine)) {
                    i += 2;
                    convertedSnippet += snippetType === ExternalSnippetType.EmmetSnippet ? '{{_}}' : '{{}}';
                    continue;
                }
                if (/^\$\{0\}/.test(restOfLine)) {
                    i += 4;
                    convertedSnippet += snippetType === ExternalSnippetType.EmmetSnippet ? '{{_}}' : '{{}}';
                    continue;
                }
                if (snippetType === ExternalSnippetType.EmmetSnippet && /^\|/.test(restOfLine)) {
                    ++i;
                    convertedSnippet += '{{}}';
                    continue;
                }
                // Tab stops
                var matches = restOfLine.match(/^\$(\d+)/);
                if (Array.isArray(matches) && matches.length === 2) {
                    i += 1 + matches[1].length;
                    convertedSnippet += '{{' + matches[1] + ':}}';
                    continue;
                }
                matches = restOfLine.match(/^\$\{(\d+)\}/);
                if (Array.isArray(matches) && matches.length === 2) {
                    i += 3 + matches[1].length;
                    convertedSnippet += '{{' + matches[1] + ':}}';
                    continue;
                }
                // Open brace patterns placeholder
                if (/^\${/.test(restOfLine)) {
                    i += 2;
                    ++openBraces;
                    convertedSnippet += '{{';
                    continue;
                }
                // Close brace patterns placeholder
                if (openBraces > 0 && /^}/.test(restOfLine)) {
                    i += 1;
                    --openBraces;
                    convertedSnippet += '}}';
                    continue;
                }
                // Escapes
                if (/^\\./.test(restOfLine)) {
                    i += 2;
                    if (/^\\\$/.test(restOfLine)) {
                        convertedSnippet += '$';
                    }
                    else {
                        convertedSnippet += restOfLine.substr(0, 2);
                    }
                    continue;
                }
                // Escape braces that don't belong to a placeholder
                matches = restOfLine.match(/^({|})/);
                if (Array.isArray(matches) && matches.length === 2) {
                    i += 1;
                    convertedSnippet += '\\' + matches[1];
                    continue;
                }
                i += 1;
                convertedSnippet += restOfLine.charAt(0);
            }
            return convertedSnippet;
        };
        CodeSnippet.prototype.extractLineIndentation = function (str, maxColumn) {
            if (maxColumn === void 0) { maxColumn = Number.MAX_VALUE; }
            var fullIndentation = strings.getLeadingWhitespace(str);
            if (fullIndentation.length > maxColumn - 1) {
                return fullIndentation.substring(0, maxColumn - 1);
            }
            return fullIndentation;
        };
        CodeSnippet.prototype.bind = function (referenceLine, deltaLine, firstLineDeltaColumn, config) {
            var resultLines = [];
            var resultPlaceHolders = [];
            var referenceIndentation = this.extractLineIndentation(referenceLine, firstLineDeltaColumn + 1);
            var originalLine, originalLineIndentation, remainingLine, indentation;
            var i, len, j, lenJ;
            // Compute resultLines & keep deltaColumns as a reference for adjusting placeholders
            var deltaColumns = [];
            for (i = 0, len = this.lines.length; i < len; i++) {
                originalLine = this.lines[i];
                if (i === 0) {
                    deltaColumns[i + 1] = firstLineDeltaColumn;
                    resultLines[i] = originalLine;
                }
                else {
                    originalLineIndentation = this.extractLineIndentation(originalLine);
                    remainingLine = originalLine.substr(originalLineIndentation.length);
                    indentation = config.normalizeIndentation(referenceIndentation + originalLineIndentation);
                    deltaColumns[i + 1] = indentation.length - originalLineIndentation.length;
                    resultLines[i] = indentation + remainingLine;
                }
            }
            // Compute resultPlaceHolders
            var originalPlaceHolder, originalOccurence, resultOccurences;
            for (i = 0, len = this.placeHolders.length; i < len; i++) {
                originalPlaceHolder = this.placeHolders[i];
                resultOccurences = [];
                for (j = 0, lenJ = originalPlaceHolder.occurences.length; j < lenJ; j++) {
                    originalOccurence = originalPlaceHolder.occurences[j];
                    resultOccurences.push({
                        startLineNumber: originalOccurence.startLineNumber + deltaLine,
                        startColumn: originalOccurence.startColumn + deltaColumns[originalOccurence.startLineNumber],
                        endLineNumber: originalOccurence.endLineNumber + deltaLine,
                        endColumn: originalOccurence.endColumn + deltaColumns[originalOccurence.endLineNumber]
                    });
                }
                resultPlaceHolders.push({
                    id: originalPlaceHolder.id,
                    value: originalPlaceHolder.value,
                    occurences: resultOccurences
                });
            }
            return {
                lines: resultLines,
                placeHolders: resultPlaceHolders,
                startPlaceHolderIndex: this.startPlaceHolderIndex,
                finishPlaceHolderIndex: this.finishPlaceHolderIndex
            };
        };
        return CodeSnippet;
    }());
    exports.CodeSnippet = CodeSnippet;
    var InsertSnippetController = (function () {
        function InsertSnippetController(editor, adaptedSnippet, startLineNumber, initialAlternativeVersionId, onStop) {
            this.editor = editor;
            this._onStop = onStop;
            this.model = editor.getModel();
            this.finishPlaceHolderIndex = adaptedSnippet.finishPlaceHolderIndex;
            this.trackedPlaceHolders = [];
            this.placeHolderDecorations = [];
            this.currentPlaceHolderIndex = adaptedSnippet.startPlaceHolderIndex;
            this.highlightDecorationId = null;
            this.isFinished = false;
            this._initialAlternativeVersionId = initialAlternativeVersionId;
            this.initialize(adaptedSnippet, startLineNumber);
        }
        InsertSnippetController.prototype.dispose = function () {
            this.stopAll();
        };
        InsertSnippetController.prototype.initialize = function (adaptedSnippet, startLineNumber) {
            var _this = this;
            var i, len;
            for (i = 0, len = adaptedSnippet.placeHolders.length; i < len; i++) {
                var placeHolder = adaptedSnippet.placeHolders[i];
                var trackedRanges = [];
                for (var j = 0, lenJ = placeHolder.occurences.length; j < lenJ; j++) {
                    trackedRanges.push(this.model.addTrackedRange(placeHolder.occurences[j], editorCommon.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges));
                }
                this.trackedPlaceHolders.push({
                    ranges: trackedRanges
                });
            }
            this.editor.changeDecorations(function (changeAccessor) {
                var newDecorations = [];
                var endLineNumber = startLineNumber + adaptedSnippet.lines.length - 1;
                var endLineNumberMaxColumn = _this.model.getLineMaxColumn(endLineNumber);
                newDecorations.push({
                    range: new range_1.Range(startLineNumber, 1, endLineNumber, endLineNumberMaxColumn),
                    options: {
                        className: 'new-snippet',
                        isWholeLine: true
                    }
                });
                for (var i_1 = 0, len_1 = _this.trackedPlaceHolders.length; i_1 < len_1; i_1++) {
                    var className = (i_1 === _this.finishPlaceHolderIndex) ? 'finish-snippet-placeholder' : 'snippet-placeholder';
                    newDecorations.push({
                        range: _this.model.getTrackedRange(_this.trackedPlaceHolders[i_1].ranges[0]),
                        options: {
                            className: className
                        }
                    });
                }
                var decorations = changeAccessor.deltaDecorations([], newDecorations);
                _this.highlightDecorationId = decorations[0];
                _this.placeHolderDecorations = decorations.slice(1);
            });
            this.listenersToRemove = [];
            this.listenersToRemove.push(this.editor.onDidChangeModelRawContent(function (e) {
                if (_this.isFinished) {
                    return;
                }
                if (e.changeType === editorCommon.EventType.ModelRawContentChangedFlush) {
                    // a model.setValue() was called
                    _this.stopAll();
                }
                else if (e.changeType === editorCommon.EventType.ModelRawContentChangedLineChanged) {
                    var changedLine = e.lineNumber;
                    var highlightRange = _this.model.getDecorationRange(_this.highlightDecorationId);
                    if (changedLine < highlightRange.startLineNumber || changedLine > highlightRange.endLineNumber) {
                        _this.stopAll();
                    }
                }
                else if (e.changeType === editorCommon.EventType.ModelRawContentChangedLinesInserted) {
                    var insertLine = e.fromLineNumber;
                    var highlightRange = _this.model.getDecorationRange(_this.highlightDecorationId);
                    if (insertLine < highlightRange.startLineNumber || insertLine > highlightRange.endLineNumber) {
                        _this.stopAll();
                    }
                }
                else if (e.changeType === editorCommon.EventType.ModelRawContentChangedLinesDeleted) {
                    var deleteLine1 = e.fromLineNumber;
                    var deleteLine2 = e.toLineNumber;
                    var highlightRange = _this.model.getDecorationRange(_this.highlightDecorationId);
                    var deletedLinesAbove = (deleteLine2 < highlightRange.startLineNumber);
                    var deletedLinesBelow = (deleteLine1 > highlightRange.endLineNumber);
                    if (deletedLinesAbove || deletedLinesBelow) {
                        _this.stopAll();
                    }
                }
                var newAlternateVersionId = _this.editor.getModel().getAlternativeVersionId();
                if (_this._initialAlternativeVersionId === newAlternateVersionId) {
                    // We executed undo until we reached the same version we started with
                    _this.stopAll();
                }
            }));
            this.listenersToRemove.push(this.editor.onDidChangeCursorPosition(function (e) {
                if (_this.isFinished) {
                    return;
                }
                var highlightRange = _this.model.getDecorationRange(_this.highlightDecorationId);
                var lineNumber = e.position.lineNumber;
                if (lineNumber < highlightRange.startLineNumber || lineNumber > highlightRange.endLineNumber) {
                    _this.stopAll();
                }
            }));
            this.listenersToRemove.push(this.editor.onDidChangeModel(function () {
                _this.stopAll();
            }));
            var blurTimeout = -1;
            this.listenersToRemove.push(this.editor.onDidBlurEditor(function () {
                // Blur if within 100ms we do not focus back
                blurTimeout = setTimeout(function () {
                    _this.stopAll();
                }, 100);
            }));
            this.listenersToRemove.push(this.editor.onDidFocusEditor(function () {
                // Cancel the blur timeout (if any)
                if (blurTimeout !== -1) {
                    clearTimeout(blurTimeout);
                    blurTimeout = -1;
                }
            }));
            this.listenersToRemove.push(this.model.onDidChangeDecorations(function (e) {
                if (_this.isFinished) {
                    return;
                }
                var modelEditableRange = _this.model.getEditableRange(), previousRange = null, allCollapsed = true, allEqualToEditableRange = true;
                for (var i = 0; (allCollapsed || allEqualToEditableRange) && i < _this.trackedPlaceHolders.length; i++) {
                    var ranges = _this.trackedPlaceHolders[i].ranges;
                    for (var j = 0; (allCollapsed || allEqualToEditableRange) && j < ranges.length; j++) {
                        var range = _this.model.getTrackedRange(ranges[j]);
                        if (allCollapsed) {
                            if (!range.isEmpty()) {
                                allCollapsed = false;
                            }
                            else if (previousRange === null) {
                                previousRange = range;
                            }
                            else if (!previousRange.equalsRange(range)) {
                                allCollapsed = false;
                            }
                        }
                        if (allEqualToEditableRange && !modelEditableRange.equalsRange(range)) {
                            allEqualToEditableRange = false;
                        }
                    }
                }
                if (allCollapsed || allEqualToEditableRange) {
                    _this.stopAll();
                }
                else {
                    if (_this.finishPlaceHolderIndex !== -1) {
                        var finishPlaceHolderDecorationId = _this.placeHolderDecorations[_this.finishPlaceHolderIndex];
                        var finishPlaceHolderRange = _this.model.getDecorationRange(finishPlaceHolderDecorationId);
                        var finishPlaceHolderOptions = _this.model.getDecorationOptions(finishPlaceHolderDecorationId);
                        var finishPlaceHolderRangeIsEmpty = finishPlaceHolderRange.isEmpty();
                        var finishPlaceHolderClassNameIsForEmpty = (finishPlaceHolderOptions.className === 'finish-snippet-placeholder');
                        // Remember xor? :)
                        var needsChanging = Number(finishPlaceHolderRangeIsEmpty) ^ Number(finishPlaceHolderClassNameIsForEmpty);
                        if (needsChanging) {
                            _this.editor.changeDecorations(function (changeAccessor) {
                                var className = finishPlaceHolderRangeIsEmpty ? 'finish-snippet-placeholder' : 'snippet-placeholder';
                                changeAccessor.changeDecorationOptions(finishPlaceHolderDecorationId, {
                                    className: className
                                });
                            });
                        }
                    }
                }
            }));
            this.doLinkEditing();
        };
        InsertSnippetController.prototype.onNextPlaceHolder = function () {
            return this.changePlaceHolder(true);
        };
        InsertSnippetController.prototype.onPrevPlaceHolder = function () {
            return this.changePlaceHolder(false);
        };
        InsertSnippetController.prototype.changePlaceHolder = function (goToNext) {
            if (this.isFinished) {
                return false;
            }
            var oldPlaceHolderIndex = this.currentPlaceHolderIndex;
            var oldRange = this.model.getTrackedRange(this.trackedPlaceHolders[oldPlaceHolderIndex].ranges[0]);
            var sameRange = true;
            do {
                if (goToNext) {
                    this.currentPlaceHolderIndex = (this.currentPlaceHolderIndex + 1) % this.trackedPlaceHolders.length;
                }
                else {
                    this.currentPlaceHolderIndex = (this.trackedPlaceHolders.length + this.currentPlaceHolderIndex - 1) % this.trackedPlaceHolders.length;
                }
                var newRange = this.model.getTrackedRange(this.trackedPlaceHolders[this.currentPlaceHolderIndex].ranges[0]);
                sameRange = oldRange.equalsRange(newRange);
            } while (this.currentPlaceHolderIndex !== oldPlaceHolderIndex && sameRange);
            this.doLinkEditing();
            return true;
        };
        InsertSnippetController.prototype.onAccept = function () {
            if (this.isFinished) {
                return false;
            }
            if (this.finishPlaceHolderIndex !== -1) {
                var finishRange = this.model.getTrackedRange(this.trackedPlaceHolders[this.finishPlaceHolderIndex].ranges[0]);
                // Let's just position cursor at the end of the finish range
                this.editor.setPosition({
                    lineNumber: finishRange.endLineNumber,
                    column: finishRange.endColumn
                });
            }
            this.stopAll();
            return true;
        };
        InsertSnippetController.prototype.onEscape = function () {
            if (this.isFinished) {
                return false;
            }
            this.stopAll();
            // Cancel multi-cursor
            this.editor.setSelections([this.editor.getSelections()[0]]);
            return true;
        };
        InsertSnippetController.prototype.doLinkEditing = function () {
            var selections = [];
            for (var i = 0, len = this.trackedPlaceHolders[this.currentPlaceHolderIndex].ranges.length; i < len; i++) {
                var range = this.model.getTrackedRange(this.trackedPlaceHolders[this.currentPlaceHolderIndex].ranges[i]);
                selections.push({
                    selectionStartLineNumber: range.startLineNumber,
                    selectionStartColumn: range.startColumn,
                    positionLineNumber: range.endLineNumber,
                    positionColumn: range.endColumn
                });
            }
            this.editor.setSelections(selections);
        };
        InsertSnippetController.prototype.stopAll = function () {
            var _this = this;
            if (this.isFinished) {
                return;
            }
            this._onStop();
            this.isFinished = true;
            this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);
            for (var i = 0; i < this.trackedPlaceHolders.length; i++) {
                var ranges = this.trackedPlaceHolders[i].ranges;
                for (var j = 0; j < ranges.length; j++) {
                    this.model.removeTrackedRange(ranges[j]);
                }
            }
            this.trackedPlaceHolders = [];
            this.editor.changeDecorations(function (changeAccessor) {
                var toRemove = [];
                toRemove.push(_this.highlightDecorationId);
                for (var i_2 = 0; i_2 < _this.placeHolderDecorations.length; i_2++) {
                    toRemove.push(_this.placeHolderDecorations[i_2]);
                }
                changeAccessor.deltaDecorations(toRemove, []);
                _this.placeHolderDecorations = [];
                _this.highlightDecorationId = null;
            });
        };
        return InsertSnippetController;
    }());
    function getSnippetController(editor) {
        return editor.getContribution(SnippetController.ID);
    }
    exports.getSnippetController = getSnippetController;
    var SnippetController = (function () {
        function SnippetController(editor, keybindingService) {
            this._editor = editor;
            this._currentController = null;
            this._inSnippetMode = keybindingService.createKey(exports.CONTEXT_SNIPPET_MODE, false);
        }
        SnippetController.prototype.dispose = function () {
            if (this._currentController) {
                this._currentController.dispose();
                this._currentController = null;
            }
        };
        SnippetController.prototype.getId = function () {
            return SnippetController.ID;
        };
        SnippetController.prototype.run = function (snippet, overwriteBefore, overwriteAfter, stripPrefix) {
            var prevController = this._currentController;
            this._currentController = null;
            if (snippet.placeHolders.length === 0) {
                // No placeholders => execute for all editor selections
                this._runForAllSelections(snippet, overwriteBefore, overwriteAfter);
            }
            else {
                this._runForPrimarySelection(snippet, overwriteBefore, overwriteAfter, stripPrefix);
            }
            if (!this._currentController) {
                // we didn't end up in snippet mode again => restore previous controller
                this._currentController = prevController;
            }
            else {
                // we ended up in snippet mode => dispose previous controller if necessary
                if (prevController) {
                    prevController.dispose();
                }
            }
        };
        SnippetController._getTypeRangeForSelection = function (model, selection, overwriteBefore, overwriteAfter) {
            var typeRange;
            if (overwriteBefore || overwriteAfter) {
                typeRange = model.validateRange(range_1.Range.plusRange(selection, {
                    startLineNumber: selection.positionLineNumber,
                    startColumn: selection.positionColumn - overwriteBefore,
                    endLineNumber: selection.positionLineNumber,
                    endColumn: selection.positionColumn + overwriteAfter
                }));
            }
            else {
                typeRange = selection;
            }
            return typeRange;
        };
        SnippetController._getAdaptedSnippet = function (model, snippet, typeRange) {
            return snippet.bind(model.getLineContent(typeRange.startLineNumber), typeRange.startLineNumber - 1, typeRange.startColumn - 1, model);
        };
        SnippetController._addCommandForSnippet = function (model, adaptedSnippet, typeRange, out) {
            var insertText = adaptedSnippet.lines.join('\n');
            var currentText = model.getValueInRange(typeRange, editorCommon.EndOfLinePreference.LF);
            if (insertText !== currentText) {
                out.push(editOperation_1.EditOperation.replaceMove(typeRange, insertText));
            }
        };
        SnippetController.prototype._runForPrimarySelection = function (snippet, overwriteBefore, overwriteAfter, stripPrefix) {
            var _this = this;
            var initialAlternativeVersionId = this._editor.getModel().getAlternativeVersionId();
            var edits = [];
            var prepared = SnippetController._prepareSnippet(this._editor, this._editor.getSelection(), snippet, overwriteBefore, overwriteAfter, stripPrefix);
            SnippetController._addCommandForSnippet(this._editor.getModel(), prepared.adaptedSnippet, prepared.typeRange, edits);
            if (edits.length > 0) {
                this._editor.executeEdits('editor.contrib.insertSnippetHelper', edits);
            }
            var cursorOnly = SnippetController._getSnippetCursorOnly(prepared.adaptedSnippet);
            if (cursorOnly) {
                this._editor.setSelection(new selection_1.Selection(cursorOnly.lineNumber, cursorOnly.column, cursorOnly.lineNumber, cursorOnly.column));
            }
            else if (prepared.adaptedSnippet.placeHolders.length > 0) {
                this._inSnippetMode.set(true);
                this._currentController = new InsertSnippetController(this._editor, prepared.adaptedSnippet, prepared.typeRange.startLineNumber, initialAlternativeVersionId, function () {
                    _this._inSnippetMode.reset();
                });
            }
        };
        SnippetController.prototype._runForAllSelections = function (snippet, overwriteBefore, overwriteAfter) {
            var selections = this._editor.getSelections(), edits = [];
            for (var i = 0; i < selections.length; i++) {
                var prepared = SnippetController._prepareSnippet(this._editor, selections[i], snippet, overwriteBefore, overwriteAfter);
                SnippetController._addCommandForSnippet(this._editor.getModel(), prepared.adaptedSnippet, prepared.typeRange, edits);
            }
            if (edits.length > 0) {
                this._editor.executeEdits('editor.contrib.insertSnippetHelper', edits);
            }
        };
        SnippetController._prepareSnippet = function (editor, selection, snippet, overwriteBefore, overwriteAfter, stripPrefix) {
            if (stripPrefix === void 0) { stripPrefix = true; }
            var model = editor.getModel();
            var typeRange = SnippetController._getTypeRangeForSelection(model, selection, overwriteBefore, overwriteAfter);
            if (snippet.lines.length === 1) {
                var nextTextOnLine = model.getLineContent(typeRange.endLineNumber).substr(typeRange.endColumn - 1);
                var nextInSnippet = snippet.lines[0].substr(overwriteBefore);
                var commonPrefix = strings.commonPrefixLength(nextTextOnLine, nextInSnippet);
                if (commonPrefix > 0 && stripPrefix) {
                    typeRange = typeRange.setEndPosition(typeRange.endLineNumber, typeRange.endColumn + commonPrefix);
                }
            }
            var adaptedSnippet = SnippetController._getAdaptedSnippet(model, snippet, typeRange);
            return {
                typeRange: typeRange,
                adaptedSnippet: adaptedSnippet
            };
        };
        SnippetController._getSnippetCursorOnly = function (snippet) {
            if (snippet.placeHolders.length !== 1) {
                return null;
            }
            var placeHolder = snippet.placeHolders[0];
            if (placeHolder.value !== '' || placeHolder.occurences.length !== 1) {
                return null;
            }
            var placeHolderRange = placeHolder.occurences[0];
            if (!range_1.Range.isEmpty(placeHolderRange)) {
                return null;
            }
            return {
                lineNumber: placeHolderRange.startLineNumber,
                column: placeHolderRange.startColumn
            };
        };
        SnippetController.prototype.jumpToNextPlaceholder = function () {
            if (this._currentController) {
                this._currentController.onNextPlaceHolder();
            }
        };
        SnippetController.prototype.jumpToPrevPlaceholder = function () {
            if (this._currentController) {
                this._currentController.onPrevPlaceHolder();
            }
        };
        SnippetController.prototype.acceptSnippet = function () {
            if (this._currentController) {
                this._currentController.onAccept();
            }
        };
        SnippetController.prototype.leaveSnippet = function () {
            if (this._currentController) {
                this._currentController.onEscape();
            }
        };
        SnippetController.ID = 'editor.contrib.snippetController';
        SnippetController = __decorate([
            __param(1, keybindingService_1.IKeybindingService)
        ], SnippetController);
        return SnippetController;
    }());
    exports.CONTEXT_SNIPPET_MODE = 'inSnippetMode';
    var weight = editorCommonExtensions_1.CommonEditorRegistry.commandWeight(30);
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorContribution(SnippetController);
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand('jumpToNextSnippetPlaceholder', weight, { primary: keyCodes_1.KeyCode.Tab }, true, exports.CONTEXT_SNIPPET_MODE, function (ctx, editor, args) {
        getSnippetController(editor).jumpToNextPlaceholder();
    });
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand('jumpToPrevSnippetPlaceholder', weight, { primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Tab }, true, exports.CONTEXT_SNIPPET_MODE, function (ctx, editor, args) {
        getSnippetController(editor).jumpToPrevPlaceholder();
    });
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand('acceptSnippet', weight, { primary: keyCodes_1.KeyCode.Enter }, true, exports.CONTEXT_SNIPPET_MODE, function (ctx, editor, args) {
        getSnippetController(editor).acceptSnippet();
    });
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand('leaveSnippet', weight, { primary: keyCodes_1.KeyCode.Escape, secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape] }, true, exports.CONTEXT_SNIPPET_MODE, function (ctx, editor, args) {
        getSnippetController(editor).leaveSnippet();
    });
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[483], __M([0,1,326,14,12,3,2,11,71,56,27,101,19,4,20,25,7,13,22,30,93,235,210]), function (require, exports, nls, async_1, keyCodes_1, lifecycle_1, winjs_base_1, dom, htmlContentRenderer_1, keyboardEvent_1, styleMutator_1, keybindingResolver_1, keybindingService_1, range_1, editorAction_1, editorActionEnablement_1, editorCommon, editorCommonExtensions_1, editorBrowser_1, editorBrowserExtensions_1, snippet_1, smartSnippetInserter_1) {
    'use strict';
    var NLS_LAUNCH_MESSAGE = nls.localize(0, null);
    var NLS_DEFINE_MESSAGE = nls.localize(1, null);
    var NLS_DEFINE_ACTION_LABEL = nls.localize(2, null);
    var NLS_KB_LAYOUT_INFO_MESSAGE = nls.localize(3, null);
    var NLS_KB_LAYOUT_ERROR_MESSAGE = nls.localize(4, null);
    var INTERESTING_FILE = /keybindings\.json$/;
    var DefineKeybindingController = (function () {
        function DefineKeybindingController(editor, keybindingService) {
            var _this = this;
            this._dec = [];
            this._editor = editor;
            this._keybindingService = keybindingService;
            this._toDispose = [];
            this._launchWidget = new DefineKeybindingLauncherWidget(this._editor, keybindingService, function () { return _this.launch(); });
            this._defineWidget = new DefineKeybindingWidget(this._editor, keybindingService, function (keybinding) { return _this._onAccepted(keybinding); });
            this._toDispose.push(this._editor.onDidChangeConfiguration(function (e) {
                if (isInterestingEditorModel(_this._editor)) {
                    _this._launchWidget.show();
                }
                else {
                    _this._launchWidget.hide();
                }
            }));
            this._toDispose.push(this._editor.onDidChangeModel(function (e) {
                if (isInterestingEditorModel(_this._editor)) {
                    _this._launchWidget.show();
                }
                else {
                    _this._launchWidget.hide();
                }
                _this._onModel();
            }));
            this._updateDecorations = new async_1.RunOnceScheduler(function () { return _this._updateDecorationsNow(); }, 500);
            this._toDispose.push(this._updateDecorations);
            this._modelToDispose = [];
            this._onModel();
        }
        DefineKeybindingController.get = function (editor) {
            return editor.getContribution(DefineKeybindingController.ID);
        };
        DefineKeybindingController.prototype.getId = function () {
            return DefineKeybindingController.ID;
        };
        DefineKeybindingController.prototype.dispose = function () {
            this._modelToDispose = lifecycle_1.dispose(this._modelToDispose);
            this._toDispose = lifecycle_1.dispose(this._toDispose);
            this._launchWidget.dispose();
            this._launchWidget = null;
            this._defineWidget.dispose();
            this._defineWidget = null;
        };
        DefineKeybindingController.prototype.launch = function () {
            if (isInterestingEditorModel(this._editor)) {
                this._defineWidget.start();
            }
        };
        DefineKeybindingController.prototype._onAccepted = function (keybinding) {
            var snippetText = [
                '{',
                '\t"key": "' + keybinding + '",',
                '\t"command": "{{commandId}}",',
                '\t"when": "{{editorTextFocus}}"',
                '}{{}}'
            ].join('\n');
            var smartInsertInfo = smartSnippetInserter_1.SmartSnippetInserter.insertSnippet(this._editor.getModel(), this._editor.getPosition());
            snippetText = smartInsertInfo.prepend + snippetText + smartInsertInfo.append;
            this._editor.setPosition(smartInsertInfo.position);
            snippet_1.getSnippetController(this._editor).run(new snippet_1.CodeSnippet(snippetText), 0, 0);
        };
        DefineKeybindingController.prototype._onModel = function () {
            var _this = this;
            this._modelToDispose = lifecycle_1.dispose(this._modelToDispose);
            var model = this._editor.getModel();
            if (!model) {
                return;
            }
            var url = model.uri.toString();
            if (!INTERESTING_FILE.test(url)) {
                return;
            }
            this._modelToDispose.push(model.onDidChangeContent(function (e) { return _this._updateDecorations.schedule(); }));
            this._modelToDispose.push({
                dispose: function () {
                    _this._dec = _this._editor.deltaDecorations(_this._dec, []);
                    _this._updateDecorations.cancel();
                }
            });
            this._updateDecorations.schedule();
        };
        DefineKeybindingController.prototype._updateDecorationsNow = function () {
            var _this = this;
            var model = this._editor.getModel();
            var regex = keyCodes_1.Keybinding.getUserSettingsKeybindingRegex();
            var m = model.findMatches(regex, false, true, false, false);
            var data = m.map(function (range) {
                var text = model.getValueInRange(range);
                var strKeybinding = text.substring(1, text.length - 1);
                strKeybinding = strKeybinding.replace(/\\\\/g, '\\');
                var numKeybinding = keybindingResolver_1.IOSupport.readKeybinding(strKeybinding);
                var keybinding = new keyCodes_1.Keybinding(numKeybinding);
                return {
                    strKeybinding: strKeybinding,
                    keybinding: keybinding,
                    usLabel: keybinding._toUSLabel(),
                    label: _this._keybindingService.getLabelFor(keybinding),
                    range: range
                };
            });
            data = data.filter(function (entry) {
                return (entry.usLabel !== entry.label);
            });
            var newDecorations = [];
            data.forEach(function (item) {
                var msg;
                var className;
                var inlineClassName;
                var overviewRulerColor;
                if (!item.label) {
                    // this is the error case
                    msg = [NLS_KB_LAYOUT_ERROR_MESSAGE];
                    className = 'keybindingError';
                    inlineClassName = 'inlineKeybindingError';
                    overviewRulerColor = 'rgba(250, 100, 100, 0.6)';
                }
                else {
                    // this is the info case
                    msg = [NLS_KB_LAYOUT_INFO_MESSAGE];
                    msg = msg.concat(_this._keybindingService.getLabelFor(item.keybinding));
                    className = 'keybindingInfo';
                    inlineClassName = 'inlineKeybindingInfo';
                    overviewRulerColor = 'rgba(100, 100, 250, 0.6)';
                }
                // icon decoration
                newDecorations.push({
                    range: new range_1.Range(item.range.startLineNumber, item.range.startColumn, item.range.startLineNumber, item.range.startColumn + 1),
                    options: {
                        stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                        inlineClassName: inlineClassName
                    }
                });
                // highlight + message decoration
                newDecorations.push({
                    range: item.range,
                    options: {
                        stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                        className: className,
                        hoverMessage: msg,
                        overviewRuler: {
                            color: overviewRulerColor,
                            darkColor: overviewRulerColor,
                            position: editorCommon.OverviewRulerLane.Right
                        }
                    }
                });
            });
            this._dec = this._editor.deltaDecorations(this._dec, newDecorations);
        };
        DefineKeybindingController.ID = 'editor.contrib.defineKeybinding';
        DefineKeybindingController = __decorate([
            __param(1, keybindingService_1.IKeybindingService)
        ], DefineKeybindingController);
        return DefineKeybindingController;
    }());
    exports.DefineKeybindingController = DefineKeybindingController;
    var DefineKeybindingLauncherWidget = (function () {
        function DefineKeybindingLauncherWidget(editor, keybindingService, onLaunch) {
            this._editor = editor;
            this._domNode = document.createElement('div');
            this._domNode.className = 'defineKeybindingLauncher';
            this._domNode.style.display = 'none';
            this._isVisible = false;
            var keybinding = keybindingService.lookupKeybindings(DefineKeybindingAction.ID);
            var extra = '';
            if (keybinding.length > 0) {
                extra += ' (' + keybindingService.getLabelFor(keybinding[0]) + ')';
            }
            this._domNode.appendChild(document.createTextNode(NLS_LAUNCH_MESSAGE + extra));
            this._toDispose = [];
            this._toDispose.push(dom.addDisposableListener(this._domNode, 'click', function (e) {
                onLaunch();
            }));
            this._editor.addOverlayWidget(this);
        }
        DefineKeybindingLauncherWidget.prototype.dispose = function () {
            this._editor.removeOverlayWidget(this);
            this._toDispose = lifecycle_1.dispose(this._toDispose);
        };
        DefineKeybindingLauncherWidget.prototype.show = function () {
            if (this._isVisible) {
                return;
            }
            this._domNode.style.display = 'block';
            this._isVisible = true;
            this._editor.layoutOverlayWidget(this);
        };
        DefineKeybindingLauncherWidget.prototype.hide = function () {
            if (!this._isVisible) {
                return;
            }
            this._domNode.style.display = 'none';
            this._isVisible = false;
            this._editor.layoutOverlayWidget(this);
        };
        // ----- IOverlayWidget API
        DefineKeybindingLauncherWidget.prototype.getId = function () {
            return DefineKeybindingLauncherWidget.ID;
        };
        DefineKeybindingLauncherWidget.prototype.getDomNode = function () {
            return this._domNode;
        };
        DefineKeybindingLauncherWidget.prototype.getPosition = function () {
            return {
                preference: this._isVisible ? editorBrowser_1.OverlayWidgetPositionPreference.BOTTOM_RIGHT_CORNER : null
            };
        };
        DefineKeybindingLauncherWidget.ID = 'editor.contrib.defineKeybindingLauncherWidget';
        return DefineKeybindingLauncherWidget;
    }());
    var DefineKeybindingWidget = (function () {
        function DefineKeybindingWidget(editor, keybindingService, onAccepted) {
            var _this = this;
            this._editor = editor;
            this._keybindingService = keybindingService;
            this._onAccepted = onAccepted;
            this._toDispose = [];
            this._lastKeybinding = null;
            this._domNode = document.createElement('div');
            this._domNode.className = 'defineKeybindingWidget';
            styleMutator_1.StyleMutator.setWidth(this._domNode, DefineKeybindingWidget.WIDTH);
            styleMutator_1.StyleMutator.setHeight(this._domNode, DefineKeybindingWidget.HEIGHT);
            this._domNode.style.display = 'none';
            this._isVisible = false;
            this._messageNode = document.createElement('div');
            this._messageNode.className = 'message';
            this._messageNode.innerText = NLS_DEFINE_MESSAGE;
            this._domNode.appendChild(this._messageNode);
            this._inputNode = document.createElement('input');
            this._inputNode.className = 'input';
            this._inputNode.type = 'text';
            this._domNode.appendChild(this._inputNode);
            this._outputNode = document.createElement('div');
            this._outputNode.className = 'output';
            this._domNode.appendChild(this._outputNode);
            this._toDispose.push(dom.addDisposableListener(this._inputNode, 'keydown', function (e) {
                var keyEvent = new keyboardEvent_1.StandardKeyboardEvent(e);
                keyEvent.preventDefault();
                keyEvent.stopPropagation();
                var kb = new keyCodes_1.Keybinding(keyEvent.asKeybinding());
                switch (kb.value) {
                    case keyCodes_1.CommonKeybindings.ENTER:
                        if (_this._lastKeybinding) {
                            _this._onAccepted(_this._lastKeybinding.toUserSettingsLabel());
                        }
                        _this._stop();
                        return;
                    case keyCodes_1.CommonKeybindings.ESCAPE:
                        _this._stop();
                        return;
                }
                _this._lastKeybinding = kb;
                _this._inputNode.value = _this._lastKeybinding.toUserSettingsLabel().toLowerCase();
                _this._inputNode.title = 'keyCode: ' + keyEvent.browserEvent.keyCode;
                dom.clearNode(_this._outputNode);
                var htmlkb = _this._keybindingService.getHTMLLabelFor(_this._lastKeybinding);
                htmlkb.forEach(function (item) { return _this._outputNode.appendChild(htmlContentRenderer_1.renderHtml(item)); });
            }));
            this._toDispose.push(this._editor.onDidChangeConfiguration(function (e) {
                if (_this._isVisible) {
                    _this._layout();
                }
            }));
            this._toDispose.push(dom.addDisposableListener(this._inputNode, 'blur', function (e) { return _this._stop(); }));
            this._editor.addOverlayWidget(this);
        }
        DefineKeybindingWidget.prototype.dispose = function () {
            this._editor.removeOverlayWidget(this);
            this._toDispose = lifecycle_1.dispose(this._toDispose);
        };
        DefineKeybindingWidget.prototype.getId = function () {
            return DefineKeybindingWidget.ID;
        };
        DefineKeybindingWidget.prototype.getDomNode = function () {
            return this._domNode;
        };
        DefineKeybindingWidget.prototype.getPosition = function () {
            return {
                preference: null
            };
        };
        DefineKeybindingWidget.prototype._show = function () {
            if (this._isVisible) {
                return;
            }
            this._isVisible = true;
            this._layout();
            this._domNode.style.display = 'block';
        };
        DefineKeybindingWidget.prototype._hide = function () {
            if (!this._isVisible) {
                return;
            }
            this._isVisible = false;
            this._domNode.style.display = 'none';
        };
        DefineKeybindingWidget.prototype._layout = function () {
            var editorLayout = this._editor.getLayoutInfo();
            var top = Math.round((editorLayout.height - DefineKeybindingWidget.HEIGHT) / 2);
            styleMutator_1.StyleMutator.setTop(this._domNode, top);
            var left = Math.round((editorLayout.width - DefineKeybindingWidget.WIDTH) / 2);
            styleMutator_1.StyleMutator.setLeft(this._domNode, left);
        };
        DefineKeybindingWidget.prototype.start = function () {
            this._editor.revealPositionInCenterIfOutsideViewport(this._editor.getPosition());
            this._show();
            this._lastKeybinding = null;
            this._inputNode.value = '';
            dom.clearNode(this._outputNode);
            this._inputNode.focus();
        };
        DefineKeybindingWidget.prototype._stop = function () {
            this._editor.focus();
            this._hide();
        };
        DefineKeybindingWidget.ID = 'editor.contrib.defineKeybindingWidget';
        DefineKeybindingWidget.WIDTH = 340;
        DefineKeybindingWidget.HEIGHT = 90;
        return DefineKeybindingWidget;
    }());
    var DefineKeybindingAction = (function (_super) {
        __extends(DefineKeybindingAction, _super);
        function DefineKeybindingAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.WidgetFocus | editorActionEnablement_1.Behaviour.UpdateOnModelChange | editorActionEnablement_1.Behaviour.Writeable);
        }
        DefineKeybindingAction.prototype.isSupported = function () {
            if (!_super.prototype.isSupported.call(this)) {
                return false;
            }
            return isInterestingEditorModel(this.editor);
        };
        DefineKeybindingAction.prototype.run = function () {
            var controller = DefineKeybindingController.get(this.editor);
            controller.launch();
            return winjs_base_1.TPromise.as(true);
        };
        DefineKeybindingAction.ID = 'editor.action.defineKeybinding';
        return DefineKeybindingAction;
    }(editorAction_1.EditorAction));
    exports.DefineKeybindingAction = DefineKeybindingAction;
    function isInterestingEditorModel(editor) {
        if (editor.getConfiguration().readOnly) {
            return false;
        }
        var model = editor.getModel();
        if (!model) {
            return false;
        }
        var url = model.uri.toString();
        return INTERESTING_FILE.test(url);
    }
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(DefineKeybindingController);
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(DefineKeybindingAction, DefineKeybindingAction.ID, NLS_DEFINE_ACTION_LABEL, {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.chord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K)
    }, 'Define Keybinding'));
});

define(__m[119], __M([0,1,14,37,8,2,13,17,49]), function (require, exports, async_1, arrays_1, errors_1, winjs_base_1, editorCommonExtensions_1, modes_1, supports_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.Context = {
        Visible: 'suggestWidgetVisible',
        MultipleSuggestions: 'suggestWidgetMultipleSuggestions',
        AcceptOnKey: 'suggestionSupportsAcceptOnKey'
    };
    function provideCompletionItems(model, position, groups) {
        if (!groups) {
            groups = modes_1.SuggestRegistry.orderedGroups(model);
        }
        var result = [];
        var factory = groups.map(function (supports, index) {
            return function () {
                // stop as soon as a group produced a result
                if (result.length > 0) {
                    return;
                }
                // for each support in the group ask for suggestions
                return winjs_base_1.TPromise.join(supports.map(function (support) {
                    return async_1.asWinJsPromise(function (token) {
                        return support.provideCompletionItems(model, position, token);
                    }).then(function (values) {
                        if (!values) {
                            return;
                        }
                        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                            var suggestResult = values_1[_i];
                            if (!suggestResult || arrays_1.isFalsyOrEmpty(suggestResult.suggestions)) {
                                continue;
                            }
                            result.push({
                                support: support,
                                currentWord: suggestResult.currentWord,
                                incomplete: suggestResult.incomplete,
                                suggestions: suggestResult.suggestions
                            });
                        }
                    }, errors_1.onUnexpectedError);
                }));
            };
        });
        return async_1.sequence(factory).then(function () {
            // add snippets to the first group
            var snippets = supports_1.SnippetsRegistry.getSnippets(model, position);
            result.push(snippets);
            return result;
        });
    }
    exports.provideCompletionItems = provideCompletionItems;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeCompletionItemProvider', function (model, position, args) {
        return provideCompletionItems(model, position);
    });
});

define(__m[485], __M([0,1,8,16,3,10,2,7,17,93,119,232,21]), function (require, exports, errors_1, event_1, lifecycle_1, strings_1, winjs_base_1, editorCommon_1, modes_1, snippet_1, suggest_1, completionModel_1, position_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var Context = (function () {
        function Context(editor, auto) {
            this.auto = auto;
            var model = editor.getModel();
            var position = editor.getPosition();
            var lineContent = model.getLineContent(position.lineNumber);
            var wordUnderCursor = model.getWordAtPosition(position);
            if (wordUnderCursor) {
                this.wordBefore = lineContent.substring(wordUnderCursor.startColumn - 1, position.column - 1);
                this.wordAfter = lineContent.substring(position.column - 1, wordUnderCursor.endColumn - 1);
            }
            else {
                this.wordBefore = '';
                this.wordAfter = '';
            }
            this.lineNumber = position.lineNumber;
            this.column = position.column;
            this.lineContentBefore = lineContent.substr(0, position.column - 1);
            this.lineContentAfter = lineContent.substr(position.column - 1);
            this.isInEditableRange = true;
            if (model.hasEditableRange()) {
                var editableRange = model.getEditableRange();
                if (!editableRange.containsPosition(position)) {
                    this.isInEditableRange = false;
                }
            }
            var supports = modes_1.SuggestRegistry.all(model);
            this.isAutoTriggerEnabled = supports.some(function (s) { return s.shouldAutotriggerSuggest; });
        }
        Context.prototype.shouldAutoTrigger = function () {
            if (!this.isAutoTriggerEnabled) {
                // Support disallows it
                return false;
            }
            if (this.wordBefore.length === 0) {
                // Word before position is empty
                return false;
            }
            if (!isNaN(Number(this.wordBefore))) {
                // Word before is number only
                return false;
            }
            if (this.wordAfter.length > 0) {
                // Word after position is non empty
                return false;
            }
            return true;
        };
        Context.prototype.isDifferentContext = function (context) {
            if (this.lineNumber !== context.lineNumber) {
                // Line number has changed
                return true;
            }
            if (context.column < this.column - this.wordBefore.length) {
                // column went before word start
                return true;
            }
            if (!strings_1.startsWith(context.lineContentBefore, this.lineContentBefore) || this.lineContentAfter !== context.lineContentAfter) {
                // Line has changed before position
                return true;
            }
            if (context.wordBefore === '' && context.lineContentBefore !== this.lineContentBefore) {
                // Most likely a space has been typed
                return true;
            }
            return false;
        };
        Context.prototype.shouldRetrigger = function (context) {
            if (!strings_1.startsWith(this.lineContentBefore, context.lineContentBefore) || this.lineContentAfter !== context.lineContentAfter) {
                // Doesn't look like the same line
                return false;
            }
            if (this.lineContentBefore.length > context.lineContentBefore.length && this.wordBefore.length === 0) {
                // Text was deleted and previous current word was empty
                return false;
            }
            if (this.auto && context.wordBefore.length === 0) {
                // Currently in auto mode and new current word is empty
                return false;
            }
            return true;
        };
        return Context;
    }());
    var State;
    (function (State) {
        State[State["Idle"] = 0] = "Idle";
        State[State["Manual"] = 1] = "Manual";
        State[State["Auto"] = 2] = "Auto";
    })(State || (State = {}));
    var SuggestModel = (function () {
        function SuggestModel(editor) {
            var _this = this;
            this.editor = editor;
            this._onDidCancel = new event_1.Emitter();
            this._onDidTrigger = new event_1.Emitter();
            this._onDidSuggest = new event_1.Emitter();
            this._onDidAccept = new event_1.Emitter();
            this.state = State.Idle;
            this.triggerAutoSuggestPromise = null;
            this.requestPromise = null;
            this.raw = null;
            this.completionModel = null;
            this.incomplete = false;
            this.context = null;
            this.toDispose = [];
            this.toDispose.push(this.editor.onDidChangeConfiguration(function () { return _this.onEditorConfigurationChange(); }));
            this.toDispose.push(this.editor.onDidChangeCursorSelection(function (e) { return _this.onCursorChange(e); }));
            this.toDispose.push(this.editor.onDidChangeModel(function () { return _this.cancel(); }));
            this.toDispose.push(modes_1.SuggestRegistry.onDidChange(this.onSuggestRegistryChange, this));
            this.onEditorConfigurationChange();
        }
        Object.defineProperty(SuggestModel.prototype, "onDidCancel", {
            get: function () { return this._onDidCancel.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SuggestModel.prototype, "onDidTrigger", {
            get: function () { return this._onDidTrigger.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SuggestModel.prototype, "onDidSuggest", {
            get: function () { return this._onDidSuggest.event; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SuggestModel.prototype, "onDidAccept", {
            get: function () { return this._onDidAccept.event; },
            enumerable: true,
            configurable: true
        });
        SuggestModel.prototype.cancel = function (silent, retrigger) {
            if (silent === void 0) { silent = false; }
            if (retrigger === void 0) { retrigger = false; }
            var actuallyCanceled = this.state !== State.Idle;
            if (this.triggerAutoSuggestPromise) {
                this.triggerAutoSuggestPromise.cancel();
                this.triggerAutoSuggestPromise = null;
            }
            if (this.requestPromise) {
                this.requestPromise.cancel();
                this.requestPromise = null;
            }
            this.state = State.Idle;
            this.raw = null;
            this.completionModel = null;
            this.incomplete = false;
            this.context = null;
            if (!silent) {
                this._onDidCancel.fire({ retrigger: retrigger });
            }
            return actuallyCanceled;
        };
        SuggestModel.prototype.getRequestPosition = function () {
            if (!this.context) {
                return null;
            }
            return new position_1.Position(this.context.lineNumber, this.context.column);
        };
        SuggestModel.prototype.isAutoSuggest = function () {
            return this.state === State.Auto;
        };
        SuggestModel.prototype.onCursorChange = function (e) {
            var _this = this;
            if (!e.selection.isEmpty()) {
                this.cancel();
                return;
            }
            if (e.source !== 'keyboard' || e.reason !== editorCommon_1.CursorChangeReason.NotSet) {
                this.cancel();
                return;
            }
            if (!modes_1.SuggestRegistry.has(this.editor.getModel())) {
                return;
            }
            var isInactive = this.state === State.Idle;
            if (isInactive && !this.editor.getConfiguration().contribInfo.quickSuggestions) {
                return;
            }
            var ctx = new Context(this.editor, false);
            if (isInactive) {
                // trigger was not called or it was canceled
                this.cancel();
                if (ctx.shouldAutoTrigger()) {
                    this.triggerAutoSuggestPromise = winjs_base_1.TPromise.timeout(this.autoSuggestDelay);
                    this.triggerAutoSuggestPromise.then(function () {
                        _this.triggerAutoSuggestPromise = null;
                        _this.trigger(true);
                    });
                }
            }
            else if (this.raw && this.incomplete) {
                this.trigger(this.state === State.Auto, undefined, true);
            }
            else {
                this.onNewContext(ctx);
            }
        };
        SuggestModel.prototype.onSuggestRegistryChange = function () {
            if (this.state === State.Idle) {
                return;
            }
            if (!modes_1.SuggestRegistry.has(this.editor.getModel())) {
                this.cancel();
                return;
            }
            this.trigger(this.state === State.Auto, undefined, true);
        };
        SuggestModel.prototype.trigger = function (auto, triggerCharacter, retrigger, groups) {
            var _this = this;
            if (retrigger === void 0) { retrigger = false; }
            var model = this.editor.getModel();
            var characterTriggered = !!triggerCharacter;
            groups = groups || modes_1.SuggestRegistry.orderedGroups(model);
            if (groups.length === 0) {
                return;
            }
            var ctx = new Context(this.editor, auto);
            if (!ctx.isInEditableRange) {
                return;
            }
            // Cancel previous requests, change state & update UI
            this.cancel(false, retrigger);
            this.state = (auto || characterTriggered) ? State.Auto : State.Manual;
            this._onDidTrigger.fire({ auto: this.isAutoSuggest(), characterTriggered: characterTriggered, retrigger: retrigger });
            // Capture context when request was sent
            this.context = ctx;
            var position = this.editor.getPosition();
            this.requestPromise = suggest_1.provideCompletionItems(model, position, groups).then(function (all) {
                _this.requestPromise = null;
                if (_this.state === State.Idle) {
                    return;
                }
                _this.raw = all;
                _this.incomplete = all.some(function (result) { return result.incomplete; });
                _this.onNewContext(new Context(_this.editor, auto));
            }).then(null, errors_1.onUnexpectedError);
        };
        SuggestModel.prototype.onNewContext = function (ctx) {
            if (this.context && this.context.isDifferentContext(ctx)) {
                if (this.context.shouldRetrigger(ctx)) {
                    this.trigger(this.state === State.Auto, undefined, true);
                }
                else {
                    this.cancel();
                }
                return;
            }
            if (this.raw) {
                var auto = this.isAutoSuggest();
                var isFrozen = false;
                if (this.completionModel && this.completionModel.raw === this.raw) {
                    var oldLineContext = this.completionModel.lineContext;
                    this.completionModel.lineContext = {
                        leadingLineContent: ctx.lineContentBefore,
                        characterCountDelta: this.context
                            ? ctx.column - this.context.column
                            : 0
                    };
                    if (!auto && this.completionModel.items.length === 0) {
                        this.completionModel.lineContext = oldLineContext;
                        isFrozen = true;
                    }
                }
                else {
                    this.completionModel = new completionModel_1.CompletionModel(this.raw, ctx.lineContentBefore);
                }
                this._onDidSuggest.fire({
                    completionModel: this.completionModel,
                    currentWord: ctx.wordBefore,
                    isFrozen: isFrozen,
                    auto: this.isAutoSuggest()
                });
            }
        };
        SuggestModel.prototype.accept = function (suggestion, overwriteBefore, overwriteAfter) {
            if (this.raw === null) {
                return false;
            }
            this._onDidAccept.fire({
                snippet: new snippet_1.CodeSnippet(suggestion.codeSnippet),
                overwriteBefore: overwriteBefore + (this.editor.getPosition().column - this.context.column),
                overwriteAfter: overwriteAfter
            });
            this.cancel();
            return true;
        };
        SuggestModel.prototype.onEditorConfigurationChange = function () {
            this.autoSuggestDelay = this.editor.getConfiguration().contribInfo.quickSuggestionsDelay;
            if (isNaN(this.autoSuggestDelay) || (!this.autoSuggestDelay && this.autoSuggestDelay !== 0) || this.autoSuggestDelay < 0) {
                this.autoSuggestDelay = 10;
            }
        };
        SuggestModel.prototype.dispose = function () {
            this.cancel(true);
            this.toDispose = lifecycle_1.dispose(this.toDispose);
        };
        return SuggestModel;
    }());
    exports.SuggestModel = SuggestModel;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/









define(__m[486], __M([0,1,362,10,2,8,3,11,122,266,87,15,19,36,22,119,81,241]), function (require, exports, nls, strings, winjs_base_1, errors_1, lifecycle_1, dom_1, highlightedLabel_1, listWidget_1, scrollableElement_1, instantiation_1, keybindingService_1, telemetry_1, editorBrowser_1, suggest_1, aria_1) {
    'use strict';
    var colorRegExp = /^(#([\da-f]{3}){1,2}|(rgb|hsl)a\(\s*(\d{1,3}%?\s*,\s*){3}(1|0?\.\d+)\)|(rgb|hsl)\(\s*\d{1,3}%?(\s*,\s*\d{1,3}%?){2}\s*\))$/i;
    var Renderer = (function () {
        function Renderer(widget, editor, keybindingService) {
            this.widget = widget;
            this.editor = editor;
            var keybindings = keybindingService.lookupKeybindings('editor.action.triggerSuggest');
            this.triggerKeybindingLabel = keybindings.length === 0 ? '' : " (" + keybindingService.getLabelFor(keybindings[0]) + ")";
        }
        Object.defineProperty(Renderer.prototype, "templateId", {
            get: function () {
                return 'suggestion';
            },
            enumerable: true,
            configurable: true
        });
        Renderer.prototype.renderTemplate = function (container) {
            var _this = this;
            var data = Object.create(null);
            data.disposables = [];
            data.root = container;
            data.icon = dom_1.append(container, dom_1.emmet('.icon'));
            data.colorspan = dom_1.append(data.icon, dom_1.emmet('span.colorspan'));
            var text = dom_1.append(container, dom_1.emmet('.text'));
            var main = dom_1.append(text, dom_1.emmet('.main'));
            data.highlightedLabel = new highlightedLabel_1.HighlightedLabel(main);
            data.disposables.push(data.highlightedLabel);
            data.typeLabel = dom_1.append(main, dom_1.emmet('span.type-label'));
            var docs = dom_1.append(text, dom_1.emmet('.docs'));
            data.documentation = dom_1.append(docs, dom_1.emmet('span.docs-text'));
            data.documentationDetails = dom_1.append(docs, dom_1.emmet('span.docs-details.octicon.octicon-info'));
            data.documentationDetails.title = nls.localize(0, null, this.triggerKeybindingLabel);
            var configureFont = function () {
                var fontInfo = _this.editor.getConfiguration().fontInfo;
                main.style.fontFamily = fontInfo.fontFamily;
            };
            configureFont();
            data.disposables.push(this.editor.onDidChangeConfiguration(function (e) {
                if (e.fontInfo) {
                    configureFont();
                }
            }));
            return data;
        };
        Renderer.prototype.renderElement = function (element, index, templateData) {
            var _this = this;
            var data = templateData;
            var suggestion = element.suggestion;
            if (suggestion.documentationLabel) {
                data.root.setAttribute('aria-label', nls.localize(1, null, suggestion.label));
            }
            else {
                data.root.setAttribute('aria-label', nls.localize(2, null, suggestion.label));
            }
            data.icon.className = 'icon ' + suggestion.type;
            data.colorspan.style.backgroundColor = '';
            if (suggestion.type === 'color') {
                var color = suggestion.label.match(colorRegExp) && suggestion.label || suggestion.documentationLabel.match(colorRegExp) && suggestion.documentationLabel;
                if (color) {
                    data.icon.className = 'icon customcolor';
                    data.colorspan.style.backgroundColor = color;
                }
            }
            data.highlightedLabel.set(suggestion.label, element.highlights);
            data.typeLabel.textContent = suggestion.typeLabel || '';
            data.documentation.textContent = suggestion.documentationLabel || '';
            if (suggestion.documentationLabel) {
                dom_1.show(data.documentationDetails);
                data.documentationDetails.onmousedown = function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                };
                data.documentationDetails.onclick = function (e) {
                    e.stopPropagation();
                    e.preventDefault();
                    _this.widget.toggleDetails();
                };
            }
            else {
                dom_1.hide(data.documentationDetails);
                data.documentationDetails.onmousedown = null;
                data.documentationDetails.onclick = null;
            }
        };
        Renderer.prototype.disposeTemplate = function (templateData) {
            templateData.highlightedLabel.dispose();
            templateData.disposables = lifecycle_1.dispose(templateData.disposables);
        };
        Renderer = __decorate([
            __param(2, keybindingService_1.IKeybindingService)
        ], Renderer);
        return Renderer;
    }());
    var FocusHeight = 35;
    var UnfocusedHeight = 19;
    var Delegate = (function () {
        function Delegate(listProvider) {
            this.listProvider = listProvider;
        }
        Delegate.prototype.getHeight = function (element) {
            var focus = this.listProvider().getFocusedElements()[0];
            if (element.suggestion.documentationLabel && element === focus) {
                return FocusHeight;
            }
            return UnfocusedHeight;
        };
        Delegate.prototype.getTemplateId = function (element) {
            return 'suggestion';
        };
        return Delegate;
    }());
    function computeScore(suggestion, currentWord, currentWordLowerCase) {
        var suggestionLowerCase = suggestion.toLowerCase();
        var score = 0;
        for (var i = 0; i < currentWord.length && i < suggestion.length; i++) {
            if (currentWord[i] === suggestion[i]) {
                score += 2;
            }
            else if (currentWordLowerCase[i] === suggestionLowerCase[i]) {
                score += 1;
            }
            else {
                break;
            }
        }
        return score;
    }
    var State;
    (function (State) {
        State[State["Hidden"] = 0] = "Hidden";
        State[State["Loading"] = 1] = "Loading";
        State[State["Empty"] = 2] = "Empty";
        State[State["Open"] = 3] = "Open";
        State[State["Frozen"] = 4] = "Frozen";
        State[State["Details"] = 5] = "Details";
    })(State || (State = {}));
    var SuggestionDetails = (function () {
        function SuggestionDetails(container, widget, editor) {
            var _this = this;
            this.widget = widget;
            this.editor = editor;
            this.disposables = [];
            this.el = dom_1.append(container, dom_1.emmet('.details'));
            this.disposables.push(lifecycle_1.toDisposable(function () { return container.removeChild(_this.el); }));
            var header = dom_1.append(this.el, dom_1.emmet('.header'));
            this.title = dom_1.append(header, dom_1.emmet('span.title'));
            this.back = dom_1.append(header, dom_1.emmet('span.go-back.octicon.octicon-mail-reply'));
            this.back.title = nls.localize(3, null);
            this.body = dom_1.emmet('.body');
            this.scrollbar = new scrollableElement_1.DomScrollableElement(this.body, { canUseTranslate3d: false });
            dom_1.append(this.el, this.scrollbar.getDomNode());
            this.disposables.push(this.scrollbar);
            this.type = dom_1.append(this.body, dom_1.emmet('p.type'));
            this.docs = dom_1.append(this.body, dom_1.emmet('p.docs'));
            this.ariaLabel = null;
            this.configureFont();
            this.disposables.push(this.editor.onDidChangeConfiguration(function (e) {
                if (e.fontInfo) {
                    _this.configureFont();
                }
            }));
        }
        Object.defineProperty(SuggestionDetails.prototype, "element", {
            get: function () {
                return this.el;
            },
            enumerable: true,
            configurable: true
        });
        SuggestionDetails.prototype.render = function (item) {
            var _this = this;
            if (!item) {
                this.title.textContent = '';
                this.type.textContent = '';
                this.docs.textContent = '';
                this.ariaLabel = null;
                return;
            }
            this.title.innerText = item.suggestion.label;
            this.type.innerText = item.suggestion.typeLabel || '';
            this.docs.innerText = item.suggestion.documentationLabel;
            this.back.onmousedown = function (e) {
                e.preventDefault();
                e.stopPropagation();
            };
            this.back.onclick = function (e) {
                e.preventDefault();
                e.stopPropagation();
                _this.widget.toggleDetails();
            };
            this.scrollbar.scanDomNode();
            this.ariaLabel = strings.format('{0}\n{1}\n{2}', item.suggestion.label || '', item.suggestion.typeLabel || '', item.suggestion.documentationLabel || '');
        };
        SuggestionDetails.prototype.getAriaLabel = function () {
            return this.ariaLabel;
        };
        SuggestionDetails.prototype.scrollDown = function (much) {
            if (much === void 0) { much = 8; }
            this.body.scrollTop += much;
        };
        SuggestionDetails.prototype.scrollUp = function (much) {
            if (much === void 0) { much = 8; }
            this.body.scrollTop -= much;
        };
        SuggestionDetails.prototype.pageDown = function () {
            this.scrollDown(80);
        };
        SuggestionDetails.prototype.pageUp = function () {
            this.scrollUp(80);
        };
        SuggestionDetails.prototype.configureFont = function () {
            var fontInfo = this.editor.getConfiguration().fontInfo;
            this.title.style.fontFamily = fontInfo.fontFamily;
            this.type.style.fontFamily = fontInfo.fontFamily;
        };
        SuggestionDetails.prototype.dispose = function () {
            this.disposables = lifecycle_1.dispose(this.disposables);
        };
        return SuggestionDetails;
    }());
    var SuggestWidget = (function () {
        function SuggestWidget(editor, model, keybindingService, telemetryService, instantiationService) {
            var _this = this;
            this.editor = editor;
            this.model = model;
            this.allowEditorOverflow = true; // Editor.IContentWidget.allowEditorOverflow
            this.isAuto = false;
            this.focusedItem = null;
            this.telemetryData = null;
            this.telemetryService = telemetryService;
            this.element = dom_1.emmet('.editor-widget.suggest-widget.monaco-editor-background');
            this.element.style.width = SuggestWidget.WIDTH + 'px';
            this.element.style.top = '0';
            this.element.style.left = '0';
            if (!this.editor.getConfiguration().contribInfo.iconsInSuggestions) {
                dom_1.addClass(this.element, 'no-icons');
            }
            this.messageElement = dom_1.append(this.element, dom_1.emmet('.message'));
            this.listElement = dom_1.append(this.element, dom_1.emmet('.tree'));
            this.details = new SuggestionDetails(this.element, this, this.editor);
            var renderer = instantiationService.createInstance(Renderer, this, this.editor);
            this.delegate = new Delegate(function () { return _this.list; });
            this.list = new listWidget_1.List(this.listElement, this.delegate, [renderer], {
                useShadows: false
            });
            this.toDispose = [
                editor.onDidBlurEditorText(function () { return _this.onEditorBlur(); }),
                this.list.onSelectionChange(function (e) { return _this.onListSelection(e); }),
                this.list.onFocusChange(function (e) { return _this.onListFocus(e); }),
                this.editor.onDidChangeCursorSelection(function () { return _this.onCursorSelectionChanged(); }),
                this.model.onDidTrigger(function (e) { return _this.onDidTrigger(e); }),
                this.model.onDidSuggest(function (e) { return _this.onDidSuggest(e); }),
                this.model.onDidCancel(function (e) { return _this.onDidCancel(e); })
            ];
            this.suggestWidgetVisible = keybindingService.createKey(suggest_1.Context.Visible, false);
            this.suggestWidgetMultipleSuggestions = keybindingService.createKey(suggest_1.Context.MultipleSuggestions, false);
            this.suggestionSupportsAutoAccept = keybindingService.createKey(suggest_1.Context.AcceptOnKey, true);
            this.editor.addContentWidget(this);
            this.setState(State.Hidden);
            // TODO@Alex: this is useful, but spammy
            // var isVisible = false;
            // this.onDidVisibilityChange((newIsVisible) => {
            // 	if (isVisible === newIsVisible) {
            // 		return;
            // 	}
            // 	isVisible = newIsVisible;
            // 	if (isVisible) {
            // 		alert(nls.localize('suggestWidgetAriaVisible', "Suggestions opened"));
            // 	} else {
            // 		alert(nls.localize('suggestWidgetAriaInvisible', "Suggestions closed"));
            // 	}
            // });
        }
        SuggestWidget.prototype.onCursorSelectionChanged = function () {
            if (this.state === State.Hidden) {
                return;
            }
            this.editor.layoutContentWidget(this);
        };
        SuggestWidget.prototype.onEditorBlur = function () {
            var _this = this;
            this.editorBlurTimeout = winjs_base_1.TPromise.timeout(150).then(function () {
                if (!_this.editor.isFocused()) {
                    _this.setState(State.Hidden);
                }
            });
        };
        SuggestWidget.prototype.onListSelection = function (e) {
            if (!e.elements.length) {
                return;
            }
            this.telemetryData.selectedIndex = 0;
            this.telemetryData.wasCancelled = false;
            this.telemetryData.selectedIndex = e.indexes[0];
            this.submitTelemetryData();
            var item = e.elements[0];
            var container = item.container;
            var overwriteBefore = (typeof item.suggestion.overwriteBefore === 'undefined') ? container.currentWord.length : item.suggestion.overwriteBefore;
            var overwriteAfter = (typeof item.suggestion.overwriteAfter === 'undefined') ? 0 : Math.max(0, item.suggestion.overwriteAfter);
            this.model.accept(item.suggestion, overwriteBefore, overwriteAfter);
            aria_1.alert(nls.localize(6, null, item.suggestion.label));
            this.editor.focus();
        };
        SuggestWidget.prototype._getSuggestionAriaAlertLabel = function (item) {
            if (item.suggestion.documentationLabel) {
                return nls.localize(7, null, item.suggestion.label);
            }
            else {
                return nls.localize(8, null, item.suggestion.label);
            }
        };
        SuggestWidget.prototype._ariaAlert = function (newAriaAlertLabel) {
            if (this._lastAriaAlertLabel === newAriaAlertLabel) {
                return;
            }
            this._lastAriaAlertLabel = newAriaAlertLabel;
            if (this._lastAriaAlertLabel) {
                aria_1.alert(this._lastAriaAlertLabel);
            }
        };
        SuggestWidget.prototype.onListFocus = function (e) {
            var _this = this;
            if (!e.elements.length) {
                if (this.currentSuggestionDetails) {
                    this.currentSuggestionDetails.cancel();
                    this.currentSuggestionDetails = null;
                    this.focusedItem = null;
                }
                this._ariaAlert(null);
                // TODO@Alex: Chromium bug
                // this.editor.setAriaActiveDescendant(null);
                return;
            }
            var item = e.elements[0];
            this._ariaAlert(this._getSuggestionAriaAlertLabel(item));
            // TODO@Alex: Chromium bug
            // // TODO@Alex: the list is not done rendering...
            // setTimeout(() => {
            // 	this.editor.setAriaActiveDescendant(this.list.getElementId(e.indexes[0]));
            // }, 100);
            if (item === this.focusedItem) {
                return;
            }
            if (this.currentSuggestionDetails) {
                this.currentSuggestionDetails.cancel();
                this.currentSuggestionDetails = null;
            }
            var index = e.indexes[0];
            this.suggestionSupportsAutoAccept.set(!item.suggestion.noAutoAccept);
            this.focusedItem = item;
            this.updateWidgetHeight();
            this.list.reveal(index);
            var position = this.model.getRequestPosition() || this.editor.getPosition();
            this.currentSuggestionDetails = item.resolveDetails(this.editor.getModel(), position)
                .then(function (details) {
                item.updateDetails(details);
                _this.list.setFocus(index);
                _this.updateWidgetHeight();
                _this.list.reveal(index);
                _this._ariaAlert(_this._getSuggestionAriaAlertLabel(item));
            })
                .then(null, function (err) { return !errors_1.isPromiseCanceledError(err) && errors_1.onUnexpectedError(err); })
                .then(function () { return _this.currentSuggestionDetails = null; });
        };
        SuggestWidget.prototype.setState = function (state) {
            var stateChanged = this.state !== state;
            this.state = state;
            dom_1.toggleClass(this.element, 'frozen', state === State.Frozen);
            switch (state) {
                case State.Hidden:
                    dom_1.hide(this.messageElement, this.details.element);
                    dom_1.show(this.listElement);
                    this.hide();
                    if (stateChanged) {
                        this.list.splice(0, this.list.length);
                    }
                    break;
                case State.Loading:
                    this.messageElement.innerText = SuggestWidget.LOADING_MESSAGE;
                    dom_1.hide(this.listElement, this.details.element);
                    dom_1.show(this.messageElement);
                    this.show();
                    break;
                case State.Empty:
                    this.messageElement.innerText = SuggestWidget.NO_SUGGESTIONS_MESSAGE;
                    dom_1.hide(this.listElement, this.details.element);
                    dom_1.show(this.messageElement);
                    this.show();
                    break;
                case State.Open:
                    dom_1.hide(this.messageElement, this.details.element);
                    dom_1.show(this.listElement);
                    this.show();
                    break;
                case State.Frozen:
                    dom_1.hide(this.messageElement, this.details.element);
                    dom_1.show(this.listElement);
                    this.show();
                    break;
                case State.Details:
                    dom_1.hide(this.messageElement, this.listElement);
                    dom_1.show(this.details.element);
                    this.show();
                    this._ariaAlert(this.details.getAriaLabel());
                    break;
            }
            if (stateChanged) {
                this.editor.layoutContentWidget(this);
            }
        };
        SuggestWidget.prototype.onDidTrigger = function (e) {
            var _this = this;
            if (this.state !== State.Hidden) {
                return;
            }
            this.telemetryTimer = this.telemetryService.timedPublicLog('suggestWidgetLoadingTime');
            this.isAuto = !!e.auto;
            if (!this.isAuto) {
                this.loadingTimeout = setTimeout(function () {
                    _this.loadingTimeout = null;
                    _this.setState(State.Loading);
                }, 50);
            }
            if (!e.retrigger) {
                this.telemetryData = {
                    wasAutomaticallyTriggered: e.characterTriggered
                };
            }
        };
        SuggestWidget.prototype.onDidSuggest = function (e) {
            if (this.loadingTimeout) {
                clearTimeout(this.loadingTimeout);
                this.loadingTimeout = null;
            }
            this.completionModel = e.completionModel;
            if (e.isFrozen && this.state !== State.Empty) {
                this.setState(State.Frozen);
                return;
            }
            var visibleCount = this.completionModel.items.length;
            var isEmpty = visibleCount === 0;
            this.suggestWidgetMultipleSuggestions.set(visibleCount > 1);
            if (isEmpty) {
                if (e.auto) {
                    this.setState(State.Hidden);
                }
                else {
                    this.setState(State.Empty);
                }
                this.completionModel = null;
            }
            else {
                var currentWord_1 = e.currentWord;
                var currentWordLowerCase_1 = currentWord_1.toLowerCase();
                var bestSuggestionIndex_1 = -1;
                var bestScore_1 = -1;
                this.completionModel.items.forEach(function (item, index) {
                    var score = computeScore(item.suggestion.label, currentWord_1, currentWordLowerCase_1);
                    if (score > bestScore_1) {
                        bestScore_1 = score;
                        bestSuggestionIndex_1 = index;
                    }
                });
                this.telemetryData = this.telemetryData || {};
                this.telemetryData.suggestionCount = this.completionModel.items.length;
                this.telemetryData.suggestedIndex = bestSuggestionIndex_1;
                this.telemetryData.hintLength = currentWord_1.length;
                (_a = this.list).splice.apply(_a, [0, this.list.length].concat(this.completionModel.items));
                this.list.setFocus(bestSuggestionIndex_1);
                this.list.reveal(bestSuggestionIndex_1, 0);
                this.setState(State.Open);
            }
            if (this.telemetryTimer) {
                this.telemetryTimer.data = { reason: isEmpty ? 'empty' : 'results' };
                this.telemetryTimer.stop();
                this.telemetryTimer = null;
            }
            var _a;
        };
        SuggestWidget.prototype.onDidCancel = function (e) {
            if (this.loadingTimeout) {
                clearTimeout(this.loadingTimeout);
                this.loadingTimeout = null;
            }
            if (!e.retrigger) {
                this.setState(State.Hidden);
                if (this.telemetryData) {
                    this.telemetryData.selectedIndex = -1;
                    this.telemetryData.wasCancelled = true;
                    this.submitTelemetryData();
                }
            }
            if (this.telemetryTimer) {
                this.telemetryTimer.data = { reason: 'cancel' };
                this.telemetryTimer.stop();
                this.telemetryTimer = null;
            }
        };
        SuggestWidget.prototype.selectNextPage = function () {
            switch (this.state) {
                case State.Hidden:
                    return false;
                case State.Details:
                    this.details.pageDown();
                    return true;
                case State.Loading:
                    return !this.isAuto;
                default:
                    this.list.focusNextPage();
                    return true;
            }
        };
        SuggestWidget.prototype.selectNext = function () {
            switch (this.state) {
                case State.Hidden:
                    return false;
                case State.Details:
                    this.details.scrollDown();
                    return true;
                case State.Loading:
                    return !this.isAuto;
                default:
                    this.list.focusNext(1, true);
                    return true;
            }
        };
        SuggestWidget.prototype.selectPreviousPage = function () {
            switch (this.state) {
                case State.Hidden:
                    return false;
                case State.Details:
                    this.details.pageUp();
                    return true;
                case State.Loading:
                    return !this.isAuto;
                default:
                    this.list.focusPreviousPage();
                    return true;
            }
        };
        SuggestWidget.prototype.selectPrevious = function () {
            switch (this.state) {
                case State.Hidden:
                    return false;
                case State.Details:
                    this.details.scrollUp();
                    return true;
                case State.Loading:
                    return !this.isAuto;
                default:
                    this.list.focusPrevious(1, true);
                    return false;
            }
        };
        SuggestWidget.prototype.acceptSelectedSuggestion = function () {
            switch (this.state) {
                case State.Hidden:
                    return false;
                case State.Empty:
                    return false;
                case State.Loading:
                    return !this.isAuto;
                default:
                    var focus_1 = this.list.getFocusedElements()[0];
                    if (focus_1) {
                        this.list.setSelection(this.completionModel.items.indexOf(focus_1));
                    }
                    else {
                        this.model.cancel();
                    }
                    return true;
            }
        };
        SuggestWidget.prototype.toggleDetails = function () {
            if (this.state === State.Details) {
                this.setState(State.Open);
                this.editor.focus();
                return;
            }
            if (this.state !== State.Open) {
                return;
            }
            var item = this.list.getFocusedElements()[0];
            if (!item || !item.suggestion.documentationLabel) {
                return;
            }
            this.setState(State.Details);
            this.editor.focus();
        };
        SuggestWidget.prototype.show = function () {
            var _this = this;
            this.updateWidgetHeight();
            this.suggestWidgetVisible.set(true);
            this.renderDetails();
            this.showTimeout = winjs_base_1.TPromise.timeout(100).then(function () {
                dom_1.addClass(_this.element, 'visible');
            });
        };
        SuggestWidget.prototype.hide = function () {
            this.suggestWidgetVisible.reset();
            dom_1.removeClass(this.element, 'visible');
        };
        SuggestWidget.prototype.cancel = function () {
            if (this.state === State.Details) {
                this.toggleDetails();
            }
            else {
                this.model.cancel();
            }
        };
        SuggestWidget.prototype.getPosition = function () {
            if (this.state === State.Hidden) {
                return null;
            }
            return {
                position: this.editor.getPosition(),
                preference: [editorBrowser_1.ContentWidgetPositionPreference.BELOW, editorBrowser_1.ContentWidgetPositionPreference.ABOVE]
            };
        };
        SuggestWidget.prototype.getDomNode = function () {
            return this.element;
        };
        SuggestWidget.prototype.getId = function () {
            return SuggestWidget.ID;
        };
        SuggestWidget.prototype.submitTelemetryData = function () {
            this.telemetryService.publicLog('suggestWidget', this.telemetryData);
            this.telemetryData = null;
        };
        SuggestWidget.prototype.updateWidgetHeight = function () {
            var height = 0;
            if (this.state === State.Empty || this.state === State.Loading) {
                height = UnfocusedHeight;
            }
            else if (this.state === State.Details) {
                height = 12 * UnfocusedHeight;
            }
            else {
                var focus_2 = this.list.getFocusedElements()[0];
                var focusHeight = focus_2 ? this.delegate.getHeight(focus_2) : UnfocusedHeight;
                height = focusHeight;
                var suggestionCount = (this.list.contentHeight - focusHeight) / UnfocusedHeight;
                height += Math.min(suggestionCount, 11) * UnfocusedHeight;
            }
            this.element.style.height = height + 'px';
            this.list.layout(height);
            this.editor.layoutContentWidget(this);
            return height;
        };
        SuggestWidget.prototype.renderDetails = function () {
            if (this.state !== State.Details) {
                this.details.render(null);
            }
            else {
                this.details.render(this.list.getFocusedElements()[0]);
            }
        };
        SuggestWidget.prototype.dispose = function () {
            this.state = null;
            this.suggestionSupportsAutoAccept = null;
            this.currentSuggestionDetails = null;
            this.focusedItem = null;
            this.telemetryData = null;
            this.telemetryService = null;
            this.telemetryTimer = null;
            this.element = null;
            this.messageElement = null;
            this.listElement = null;
            this.details.dispose();
            this.details = null;
            this.list.dispose();
            this.list = null;
            this.toDispose = lifecycle_1.dispose(this.toDispose);
            if (this.loadingTimeout) {
                clearTimeout(this.loadingTimeout);
                this.loadingTimeout = null;
            }
            if (this.editorBlurTimeout) {
                this.editorBlurTimeout.cancel();
                this.editorBlurTimeout = null;
            }
            if (this.showTimeout) {
                this.showTimeout.cancel();
                this.showTimeout = null;
            }
        };
        SuggestWidget.ID = 'editor.widget.suggestWidget';
        SuggestWidget.WIDTH = 438;
        SuggestWidget.LOADING_MESSAGE = nls.localize(4, null);
        SuggestWidget.NO_SUGGESTIONS_MESSAGE = nls.localize(5, null);
        SuggestWidget = __decorate([
            __param(2, keybindingService_1.IKeybindingService),
            __param(3, telemetry_1.ITelemetryService),
            __param(4, instantiation_1.IInstantiationService)
        ], SuggestWidget);
        return SuggestWidget;
    }());
    exports.SuggestWidget = SuggestWidget;
});















define(__m[487], __M([0,1,361,8,12,3,2,15,19,20,7,13,17,30,93,119,51,90,485,486]), function (require, exports, nls, errors_1, keyCodes_1, lifecycle_1, winjs_base_1, instantiation_1, keybindingService_1, editorAction_1, editorCommon_1, editorCommonExtensions_1, modes_1, editorBrowserExtensions_1, snippet_1, suggest_1, keybindingsRegistry_1, config_1, suggestModel_1, suggestWidget_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var SuggestController = (function () {
        function SuggestController(editor, instantiationService) {
            var _this = this;
            this.editor = editor;
            this.model = new suggestModel_1.SuggestModel(this.editor);
            this.widget = instantiationService.createInstance(suggestWidget_1.SuggestWidget, this.editor, this.model);
            this.triggerCharacterListeners = [];
            this.toDispose = [];
            this.toDispose.push(editor.onDidChangeConfiguration(function () { return _this.update(); }));
            this.toDispose.push(editor.onDidChangeModel(function () { return _this.update(); }));
            this.toDispose.push(editor.onDidChangeModelMode(function () { return _this.update(); }));
            this.toDispose.push(modes_1.SuggestRegistry.onDidChange(this.update, this));
            this.toDispose.push(this.model.onDidAccept(function (e) { return snippet_1.getSnippetController(_this.editor).run(e.snippet, e.overwriteBefore, e.overwriteAfter); }));
            this.update();
        }
        SuggestController.getController = function (editor) {
            return editor.getContribution(SuggestController.ID);
        };
        SuggestController.prototype.getId = function () {
            return SuggestController.ID;
        };
        SuggestController.prototype.dispose = function () {
            this.toDispose = lifecycle_1.dispose(this.toDispose);
            this.triggerCharacterListeners = lifecycle_1.dispose(this.triggerCharacterListeners);
            if (this.widget) {
                this.widget.dispose();
                this.widget = null;
            }
            if (this.model) {
                this.model.dispose();
                this.model = null;
            }
        };
        SuggestController.prototype.update = function () {
            var _this = this;
            this.triggerCharacterListeners = lifecycle_1.dispose(this.triggerCharacterListeners);
            if (this.editor.getConfiguration().readOnly
                || !this.editor.getModel()
                || !this.editor.getConfiguration().contribInfo.suggestOnTriggerCharacters) {
                return;
            }
            var groups = modes_1.SuggestRegistry.orderedGroups(this.editor.getModel());
            if (groups.length === 0) {
                return;
            }
            var triggerCharacters = Object.create(null);
            groups.forEach(function (group) {
                var groupTriggerCharacters = Object.create(null);
                group.forEach(function (support) {
                    var localTriggerCharacters = support.triggerCharacters;
                    if (localTriggerCharacters) {
                        for (var _i = 0, localTriggerCharacters_1 = localTriggerCharacters; _i < localTriggerCharacters_1.length; _i++) {
                            var ch = localTriggerCharacters_1[_i];
                            var array = groupTriggerCharacters[ch];
                            if (array) {
                                array.push(support);
                            }
                            else {
                                array = [support];
                                groupTriggerCharacters[ch] = array;
                                if (triggerCharacters[ch]) {
                                    triggerCharacters[ch].push(array);
                                }
                                else {
                                    triggerCharacters[ch] = [array];
                                }
                            }
                        }
                    }
                });
            });
            Object.keys(triggerCharacters).forEach(function (ch) {
                _this.triggerCharacterListeners.push(_this.editor.addTypingListener(ch, function () {
                    _this.triggerCharacterHandler(ch, triggerCharacters[ch]);
                }));
            });
        };
        SuggestController.prototype.triggerCharacterHandler = function (character, groups) {
            groups = groups.map(function (supports) {
                return supports.filter(function (support) { return support.shouldAutotriggerSuggest; });
            });
            if (groups.length > 0) {
                this.triggerSuggest(character, groups).done(null, errors_1.onUnexpectedError);
            }
        };
        SuggestController.prototype.triggerSuggest = function (triggerCharacter, groups) {
            this.model.trigger(false, triggerCharacter, false, groups);
            this.editor.focus();
            return winjs_base_1.TPromise.as(false);
        };
        SuggestController.prototype.acceptSelectedSuggestion = function () {
            if (this.widget) {
                this.widget.acceptSelectedSuggestion();
            }
        };
        SuggestController.prototype.cancelSuggestWidget = function () {
            if (this.widget) {
                this.widget.cancel();
            }
        };
        SuggestController.prototype.selectNextSuggestion = function () {
            if (this.widget) {
                this.widget.selectNext();
            }
        };
        SuggestController.prototype.selectNextPageSuggestion = function () {
            if (this.widget) {
                this.widget.selectNextPage();
            }
        };
        SuggestController.prototype.selectPrevSuggestion = function () {
            if (this.widget) {
                this.widget.selectPrevious();
            }
        };
        SuggestController.prototype.selectPrevPageSuggestion = function () {
            if (this.widget) {
                this.widget.selectPreviousPage();
            }
        };
        SuggestController.prototype.toggleSuggestionDetails = function () {
            if (this.widget) {
                this.widget.toggleDetails();
            }
        };
        SuggestController.ID = 'editor.contrib.suggestController';
        SuggestController = __decorate([
            __param(1, instantiation_1.IInstantiationService)
        ], SuggestController);
        return SuggestController;
    }());
    exports.SuggestController = SuggestController;
    var TriggerSuggestAction = (function (_super) {
        __extends(TriggerSuggestAction, _super);
        function TriggerSuggestAction(descriptor, editor) {
            _super.call(this, descriptor, editor);
        }
        TriggerSuggestAction.prototype.isSupported = function () {
            return modes_1.SuggestRegistry.has(this.editor.getModel()) && !this.editor.getConfiguration().readOnly;
        };
        TriggerSuggestAction.prototype.run = function () {
            return SuggestController.getController(this.editor).triggerSuggest();
        };
        TriggerSuggestAction.ID = 'editor.action.triggerSuggest';
        return TriggerSuggestAction;
    }(editorAction_1.EditorAction));
    exports.TriggerSuggestAction = TriggerSuggestAction;
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(TriggerSuggestAction, TriggerSuggestAction.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.Space,
        mac: { primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.Space }
    }, 'Trigger Suggest'));
    var weight = editorCommonExtensions_1.CommonEditorRegistry.commandWeight(90);
    function handler(id, fn) {
        return function (accessor) { return config_1.withCodeEditorFromCommandHandler(id, accessor, function (editor) {
            fn(SuggestController.getController(editor));
        }); };
    }
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: 'acceptSelectedSuggestion',
        handler: handler('acceptSelectedSuggestion', function (c) { return c.acceptSelectedSuggestion(); }),
        weight: weight,
        when: keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon_1.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.has(suggest_1.Context.Visible)),
        primary: keyCodes_1.KeyCode.Tab
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: 'acceptSelectedSuggestionOnEnter',
        handler: handler('acceptSelectedSuggestionOnEnter', function (c) { return c.acceptSelectedSuggestion(); }),
        weight: weight,
        when: keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon_1.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.has(suggest_1.Context.Visible), keybindingService_1.KbExpr.has('config.editor.acceptSuggestionOnEnter')),
        primary: keyCodes_1.KeyCode.Enter
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: 'hideSuggestWidget',
        handler: handler('hideSuggestWidget', function (c) { return c.cancelSuggestWidget(); }),
        weight: weight,
        when: keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon_1.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.has(suggest_1.Context.Visible)),
        primary: keyCodes_1.KeyCode.Escape,
        secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape]
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: 'selectNextSuggestion',
        handler: handler('selectNextSuggestion', function (c) { return c.selectNextSuggestion(); }),
        weight: weight,
        when: keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon_1.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.has(suggest_1.Context.Visible), keybindingService_1.KbExpr.has(suggest_1.Context.MultipleSuggestions)),
        primary: keyCodes_1.KeyCode.DownArrow,
        secondary: [keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.DownArrow]
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: 'selectNextPageSuggestion',
        handler: handler('selectNextPageSuggestion', function (c) { return c.selectNextPageSuggestion(); }),
        weight: weight,
        when: keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon_1.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.has(suggest_1.Context.Visible), keybindingService_1.KbExpr.has(suggest_1.Context.MultipleSuggestions)),
        primary: keyCodes_1.KeyCode.PageDown,
        secondary: [keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.PageDown]
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: 'selectPrevSuggestion',
        handler: handler('selectPrevSuggestion', function (c) { return c.selectPrevSuggestion(); }),
        weight: weight,
        when: keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon_1.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.has(suggest_1.Context.Visible), keybindingService_1.KbExpr.has(suggest_1.Context.MultipleSuggestions)),
        primary: keyCodes_1.KeyCode.UpArrow,
        secondary: [keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.UpArrow]
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: 'selectPrevPageSuggestion',
        handler: handler('selectPrevPageSuggestion', function (c) { return c.selectPrevPageSuggestion(); }),
        weight: weight,
        when: keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon_1.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.has(suggest_1.Context.Visible), keybindingService_1.KbExpr.has(suggest_1.Context.MultipleSuggestions)),
        primary: keyCodes_1.KeyCode.PageUp,
        secondary: [keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.PageUp]
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: 'toggleSuggestionDetails',
        handler: handler('toggleSuggestionDetails', function (c) { return c.toggleSuggestionDetails(); }),
        weight: weight,
        when: keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(editorCommon_1.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS), keybindingService_1.KbExpr.has(suggest_1.Context.Visible)),
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.Space,
        mac: { primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyCode.Space }
    });
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(SuggestController);
});






define(__m[171], __M([0,1,363,12,2,20,25,13]), function (require, exports, nls, keyCodes_1, winjs_base_1, editorAction_1, editorActionEnablement_1, editorCommonExtensions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ToggleTabFocusModeAction = (function (_super) {
        __extends(ToggleTabFocusModeAction, _super);
        function ToggleTabFocusModeAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.TextFocus);
        }
        ToggleTabFocusModeAction.prototype.run = function () {
            if (this.editor.getConfiguration().tabFocusMode) {
                this.editor.updateOptions({ tabFocusMode: false });
            }
            else {
                this.editor.updateOptions({ tabFocusMode: true });
            }
            return winjs_base_1.TPromise.as(true);
        };
        ToggleTabFocusModeAction.ID = 'editor.action.toggleTabFocusMode';
        return ToggleTabFocusModeAction;
    }(editorAction_1.EditorAction));
    exports.ToggleTabFocusModeAction = ToggleTabFocusModeAction;
    // register actions
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(ToggleTabFocusModeAction, ToggleTabFocusModeAction.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_M,
        mac: { primary: keyCodes_1.KeyMod.WinCtrl | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_M }
    }, 'Toggle Use of Tab Key for Setting Focus'));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[489], __M([0,1,321,12,3,10,2,11,71,27,44,19,51,111,20,25,7,13,30,171,202]), function (require, exports, nls, keyCodes_1, lifecycle_1, strings, winjs_base_1, dom_1, htmlContentRenderer_1, styleMutator_1, widget_1, keybindingService_1, keybindingsRegistry_1, commonEditorConfig_1, editorAction_1, editorActionEnablement_1, editorCommon_1, editorCommonExtensions_1, editorBrowserExtensions_1, toggleTabFocusMode_1) {
    'use strict';
    var NLS_SHOW_ACCESSIBILITY_HELP_ACTION_LABEL = nls.localize(0, null);
    var CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE = 'accessibilityHelpWidgetVisible';
    var TOGGLE_EXPERIMENTAL_SCREEN_READER_SUPPORT_COMMAND_ID = 'toggleExperimentalScreenReaderSupport';
    var AccessibilityHelpController = (function (_super) {
        __extends(AccessibilityHelpController, _super);
        function AccessibilityHelpController(editor, keybindingService) {
            _super.call(this);
            this._editor = editor;
            this._widget = this._register(new AccessibilityHelpWidget(this._editor, keybindingService));
        }
        AccessibilityHelpController.get = function (editor) {
            return editor.getContribution(AccessibilityHelpController.ID);
        };
        AccessibilityHelpController.prototype.getId = function () {
            return AccessibilityHelpController.ID;
        };
        AccessibilityHelpController.prototype.show = function () {
            this._widget.show();
        };
        AccessibilityHelpController.prototype.hide = function () {
            this._widget.hide();
        };
        AccessibilityHelpController.ID = 'editor.contrib.accessibilityHelpController';
        AccessibilityHelpController = __decorate([
            __param(1, keybindingService_1.IKeybindingService)
        ], AccessibilityHelpController);
        return AccessibilityHelpController;
    }(lifecycle_1.Disposable));
    var AccessibilityHelpWidget = (function (_super) {
        __extends(AccessibilityHelpWidget, _super);
        function AccessibilityHelpWidget(editor, keybindingService) {
            var _this = this;
            _super.call(this);
            this._editor = editor;
            this._keybindingService = keybindingService;
            this._isVisibleKey = keybindingService.createKey(CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE, false);
            this._domNode = document.createElement('div');
            this._domNode.className = 'accessibilityHelpWidget';
            styleMutator_1.StyleMutator.setWidth(this._domNode, AccessibilityHelpWidget.WIDTH);
            styleMutator_1.StyleMutator.setHeight(this._domNode, AccessibilityHelpWidget.HEIGHT);
            this._domNode.style.display = 'none';
            this._domNode.setAttribute('role', 'tooltip');
            this._domNode.setAttribute('aria-hidden', 'true');
            this._isVisible = false;
            this._register(this._editor.onDidLayoutChange(function () {
                if (_this._isVisible) {
                    _this._layout();
                }
            }));
            this.onblur(this._domNode, function () {
                _this.hide();
            });
            this._editor.addOverlayWidget(this);
        }
        AccessibilityHelpWidget.prototype.dispose = function () {
            this._editor.removeOverlayWidget(this);
            _super.prototype.dispose.call(this);
        };
        AccessibilityHelpWidget.prototype.getId = function () {
            return AccessibilityHelpWidget.ID;
        };
        AccessibilityHelpWidget.prototype.getDomNode = function () {
            return this._domNode;
        };
        AccessibilityHelpWidget.prototype.getPosition = function () {
            return {
                preference: null
            };
        };
        AccessibilityHelpWidget.prototype.show = function () {
            if (this._isVisible) {
                return;
            }
            this._isVisible = true;
            this._isVisibleKey.set(true);
            this._layout();
            this._domNode.style.display = 'block';
            this._domNode.setAttribute('aria-hidden', 'false');
            this._domNode.tabIndex = 0;
            this._buildContent();
            this._domNode.focus();
        };
        AccessibilityHelpWidget.prototype._descriptionForCommand = function (commandId, msg, noKbMsg) {
            var keybindings = this._keybindingService.lookupKeybindings(commandId);
            if (keybindings.length > 0) {
                return strings.format(msg, this._keybindingService.getAriaLabelFor(keybindings[0]));
            }
            return strings.format(noKbMsg, commandId);
        };
        AccessibilityHelpWidget.prototype._buildContent = function () {
            var opts = this._editor.getConfiguration();
            var text = nls.localize(1, null);
            text += '\n\n' + nls.localize(2, null);
            var NLS_TAB_FOCUS_MODE_ON = nls.localize(3, null);
            var NLS_TAB_FOCUS_MODE_ON_NO_KB = nls.localize(4, null);
            var NLS_TAB_FOCUS_MODE_OFF = nls.localize(5, null);
            var NLS_TAB_FOCUS_MODE_OFF_NO_KB = nls.localize(6, null);
            if (opts.tabFocusMode) {
                text += '\n\n - ' + this._descriptionForCommand(toggleTabFocusMode_1.ToggleTabFocusModeAction.ID, NLS_TAB_FOCUS_MODE_ON, NLS_TAB_FOCUS_MODE_ON_NO_KB);
            }
            else {
                text += '\n\n - ' + this._descriptionForCommand(toggleTabFocusMode_1.ToggleTabFocusModeAction.ID, NLS_TAB_FOCUS_MODE_OFF, NLS_TAB_FOCUS_MODE_OFF_NO_KB);
            }
            text += '\n\n' + nls.localize(7, null);
            this._domNode.appendChild(htmlContentRenderer_1.renderHtml({
                formattedText: text
            }));
        };
        AccessibilityHelpWidget.prototype.hide = function () {
            if (!this._isVisible) {
                return;
            }
            this._isVisible = false;
            this._isVisibleKey.reset();
            this._domNode.style.display = 'none';
            this._domNode.setAttribute('aria-hidden', 'true');
            this._domNode.tabIndex = -1;
            dom_1.clearNode(this._domNode);
            this._editor.focus();
        };
        AccessibilityHelpWidget.prototype._layout = function () {
            var editorLayout = this._editor.getLayoutInfo();
            var top = Math.round((editorLayout.height - AccessibilityHelpWidget.HEIGHT) / 2);
            styleMutator_1.StyleMutator.setTop(this._domNode, top);
            var left = Math.round((editorLayout.width - AccessibilityHelpWidget.WIDTH) / 2);
            styleMutator_1.StyleMutator.setLeft(this._domNode, left);
        };
        AccessibilityHelpWidget.ID = 'editor.contrib.accessibilityHelpWidget';
        AccessibilityHelpWidget.WIDTH = 500;
        AccessibilityHelpWidget.HEIGHT = 300;
        return AccessibilityHelpWidget;
    }(widget_1.Widget));
    var ShowAccessibilityHelpAction = (function (_super) {
        __extends(ShowAccessibilityHelpAction, _super);
        function ShowAccessibilityHelpAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.WidgetFocus);
        }
        ShowAccessibilityHelpAction.prototype.run = function () {
            var controller = AccessibilityHelpController.get(this.editor);
            controller.show();
            return winjs_base_1.TPromise.as(true);
        };
        return ShowAccessibilityHelpAction;
    }(editorAction_1.EditorAction));
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(AccessibilityHelpController);
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(ShowAccessibilityHelpAction, editorCommon_1.SHOW_ACCESSIBILITY_HELP_ACTION_ID, NLS_SHOW_ACCESSIBILITY_HELP_ACTION_LABEL, {
        context: editorCommonExtensions_1.ContextKey.EditorFocus,
        primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.F1
    }, 'Show Accessibility Help'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorCommand('closeAccessibilityHelp', editorCommonExtensions_1.CommonEditorRegistry.commandWeight(100), { primary: keyCodes_1.KeyCode.Escape, secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape] }, false, CONTEXT_ACCESSIBILITY_WIDGET_VISIBLE, function (ctx, editor, args) {
        AccessibilityHelpController.get(editor).hide();
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: TOGGLE_EXPERIMENTAL_SCREEN_READER_SUPPORT_COMMAND_ID,
        handler: function (accessor) {
            var currentValue = commonEditorConfig_1.GlobalScreenReaderNVDA.getValue();
            commonEditorConfig_1.GlobalScreenReaderNVDA.setValue(!currentValue);
        },
        weight: keybindingsRegistry_1.KeybindingsRegistry.WEIGHT.workbenchContrib(),
        when: null,
        primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.KEY_R
    });
});






define(__m[490], __M([0,1,364,12,2,20,25,13]), function (require, exports, nls, keyCodes_1, winjs_base_1, editorAction_1, editorActionEnablement_1, editorCommonExtensions_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ToggleWordWrapAction = (function (_super) {
        __extends(ToggleWordWrapAction, _super);
        function ToggleWordWrapAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.TextFocus);
        }
        ToggleWordWrapAction.prototype.run = function () {
            var wrappingInfo = this.editor.getConfiguration().wrappingInfo;
            var newWrappingColumn;
            if (!wrappingInfo.isViewportWrapping) {
                newWrappingColumn = 0;
            }
            else {
                newWrappingColumn = -1;
            }
            this.editor.updateOptions({
                wrappingColumn: newWrappingColumn
            });
            return winjs_base_1.TPromise.as(true);
        };
        ToggleWordWrapAction.ID = 'editor.action.toggleWordWrap';
        return ToggleWordWrapAction;
    }(editorAction_1.EditorAction));
    // register actions
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(ToggleWordWrapAction, ToggleWordWrapAction.ID, nls.localize(0, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_Z,
        mac: { primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_Z },
        linux: { primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.KEY_Z }
    }, 'View: Toggle Word Wrap'));
});

define(__m[491], __M([0,1,14,8,4,7,13,17,3]), function (require, exports, async_1, errors_1, range_1, editorCommon, editorCommonExtensions_1, modes_1, lifecycle_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function getOccurrencesAtPosition(model, position) {
        var orderedByScore = modes_1.DocumentHighlightProviderRegistry.ordered(model);
        var foundResult = false;
        // in order of score ask the occurrences provider
        // until someone response with a good result
        // (good = none empty array)
        return async_1.sequence(orderedByScore.map(function (provider) {
            return function () {
                if (!foundResult) {
                    return async_1.asWinJsPromise(function (token) {
                        return provider.provideDocumentHighlights(model, position, token);
                    }).then(function (data) {
                        if (Array.isArray(data) && data.length > 0) {
                            foundResult = true;
                            return data;
                        }
                    }, function (err) {
                        errors_1.onUnexpectedError(err);
                    });
                }
            };
        })).then(function (values) {
            return values[0];
        });
    }
    exports.getOccurrencesAtPosition = getOccurrencesAtPosition;
    editorCommonExtensions_1.CommonEditorRegistry.registerDefaultLanguageCommand('_executeDocumentHighlights', getOccurrencesAtPosition);
    var WordHighlighter = (function () {
        function WordHighlighter(editor) {
            var _this = this;
            this.workerRequestTokenId = 0;
            this.workerRequest = null;
            this.workerRequestCompleted = false;
            this.workerRequestValue = [];
            this.lastCursorPositionChangeTime = 0;
            this.renderDecorationsTimer = -1;
            this.editor = editor;
            this.model = this.editor.getModel();
            this.toUnhook = [];
            this.toUnhook.push(editor.onDidChangeCursorPosition(function (e) {
                _this._onPositionChanged(e);
            }));
            this.toUnhook.push(editor.onDidChangeModel(function (e) {
                _this._stopAll();
                _this.model = _this.editor.getModel();
            }));
            this.toUnhook.push(editor.onDidChangeModelContent(function (e) {
                _this._stopAll();
            }));
            this._lastWordRange = null;
            this._decorationIds = [];
            this.workerRequestTokenId = 0;
            this.workerRequest = null;
            this.workerRequestCompleted = false;
            this.lastCursorPositionChangeTime = 0;
            this.renderDecorationsTimer = -1;
        }
        WordHighlighter.prototype._removeDecorations = function () {
            if (this._decorationIds.length > 0) {
                // remove decorations
                this._decorationIds = this.editor.deltaDecorations(this._decorationIds, []);
            }
        };
        WordHighlighter.prototype._stopAll = function () {
            this._lastWordRange = null;
            // Remove any existing decorations
            this._removeDecorations();
            // Cancel any renderDecorationsTimer
            if (this.renderDecorationsTimer !== -1) {
                window.clearTimeout(this.renderDecorationsTimer);
                this.renderDecorationsTimer = -1;
            }
            // Cancel any worker request
            if (this.workerRequest !== null) {
                this.workerRequest.cancel();
                this.workerRequest = null;
            }
            // Invalidate any worker request callback
            if (!this.workerRequestCompleted) {
                this.workerRequestTokenId++;
                this.workerRequestCompleted = true;
            }
        };
        WordHighlighter.prototype._onPositionChanged = function (e) {
            var _this = this;
            // ignore typing & other
            if (e.reason !== editorCommon.CursorChangeReason.Explicit) {
                this._stopAll();
                return;
            }
            // no providers for this model
            if (!modes_1.DocumentHighlightProviderRegistry.has(this.model)) {
                this._stopAll();
                return;
            }
            var editorSelection = this.editor.getSelection();
            // ignore multiline selection
            if (editorSelection.startLineNumber !== editorSelection.endLineNumber) {
                this._stopAll();
                return;
            }
            var lineNumber = editorSelection.startLineNumber;
            var startColumn = editorSelection.startColumn;
            var endColumn = editorSelection.endColumn;
            var word = this.model.getWordAtPosition({
                lineNumber: lineNumber,
                column: startColumn
            });
            // The selection must be inside a word or surround one word at most
            if (!word || word.startColumn > startColumn || word.endColumn < endColumn) {
                this._stopAll();
                return;
            }
            // All the effort below is trying to achieve this:
            // - when cursor is moved to a word, trigger immediately a findOccurences request
            // - 250ms later after the last cursor move event, render the occurences
            // - no flickering!
            var currentWordRange = new range_1.Range(lineNumber, word.startColumn, lineNumber, word.endColumn);
            var workerRequestIsValid = this._lastWordRange && this._lastWordRange.equalsRange(currentWordRange);
            // Even if we are on a different word, if that word is in the decorations ranges, the request is still valid
            // (Same symbol)
            for (var i = 0, len = this._decorationIds.length; !workerRequestIsValid && i < len; i++) {
                var range = this.model.getDecorationRange(this._decorationIds[i]);
                if (range && range.startLineNumber === lineNumber) {
                    if (range.startColumn <= startColumn && range.endColumn >= endColumn) {
                        workerRequestIsValid = true;
                    }
                }
            }
            // There are 4 cases:
            // a) old workerRequest is valid & completed, renderDecorationsTimer fired
            // b) old workerRequest is valid & completed, renderDecorationsTimer not fired
            // c) old workerRequest is valid, but not completed
            // d) old workerRequest is not valid
            // For a) no action is needed
            // For c), member 'lastCursorPositionChangeTime' will be used when installing the timer so no action is needed
            this.lastCursorPositionChangeTime = (new Date()).getTime();
            if (workerRequestIsValid) {
                if (this.workerRequestCompleted && this.renderDecorationsTimer !== -1) {
                    // case b)
                    // Delay the firing of renderDecorationsTimer by an extra 250 ms
                    window.clearTimeout(this.renderDecorationsTimer);
                    this.renderDecorationsTimer = -1;
                    this._beginRenderDecorations();
                }
            }
            else {
                // case d)
                // Stop all previous actions and start fresh
                this._stopAll();
                var myRequestId = ++this.workerRequestTokenId;
                this.workerRequestCompleted = false;
                this.workerRequest = getOccurrencesAtPosition(this.model, this.editor.getPosition());
                this.workerRequest.then(function (data) {
                    if (myRequestId === _this.workerRequestTokenId) {
                        _this.workerRequestCompleted = true;
                        _this.workerRequestValue = data || [];
                        _this._beginRenderDecorations();
                    }
                }).done();
            }
            this._lastWordRange = currentWordRange;
        };
        WordHighlighter.prototype._beginRenderDecorations = function () {
            var _this = this;
            var currentTime = (new Date()).getTime();
            var minimumRenderTime = this.lastCursorPositionChangeTime + 250;
            if (currentTime >= minimumRenderTime) {
                // Synchronous
                this.renderDecorationsTimer = -1;
                this.renderDecorations();
            }
            else {
                // Asyncrhonous
                this.renderDecorationsTimer = window.setTimeout(function () {
                    _this.renderDecorations();
                }, (minimumRenderTime - currentTime));
            }
        };
        WordHighlighter.prototype.renderDecorations = function () {
            this.renderDecorationsTimer = -1;
            var decorations = [];
            for (var i = 0, len = this.workerRequestValue.length; i < len; i++) {
                var info = this.workerRequestValue[i];
                var color = '#A0A0A0';
                var className = void 0;
                if (info.kind === modes_1.DocumentHighlightKind.Write) {
                    className = 'wordHighlightStrong';
                }
                else if (info.kind === modes_1.DocumentHighlightKind.Text) {
                    className = 'selectionHighlight';
                }
                else {
                    className = 'wordHighlight';
                }
                decorations.push({
                    range: info.range,
                    options: {
                        stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
                        className: className,
                        overviewRuler: {
                            color: color,
                            darkColor: color,
                            position: editorCommon.OverviewRulerLane.Center
                        }
                    }
                });
            }
            this._decorationIds = this.editor.deltaDecorations(this._decorationIds, decorations);
        };
        WordHighlighter.prototype.destroy = function () {
            this._stopAll();
            this.toUnhook = lifecycle_1.dispose(this.toUnhook);
        };
        return WordHighlighter;
    }());
    var WordHighlighterContribution = (function () {
        function WordHighlighterContribution(editor) {
            this.wordHighligher = new WordHighlighter(editor);
        }
        WordHighlighterContribution.prototype.getId = function () {
            return WordHighlighterContribution.ID;
        };
        WordHighlighterContribution.prototype.dispose = function () {
            this.wordHighligher.destroy();
        };
        WordHighlighterContribution.ID = 'editor.contrib.wordHighlighter';
        return WordHighlighterContribution;
    }());
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorContribution(WordHighlighterContribution);
});










define(__m[492], __M([0,1,70,145,36,42]), function (require, exports, contextView_1, contextview_1, telemetry_1, message_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var ContextViewService = (function () {
        function ContextViewService(container, telemetryService, messageService) {
            this.serviceId = contextView_1.IContextViewService;
            this.contextView = new contextview_1.ContextView(container);
        }
        ContextViewService.prototype.dispose = function () {
            this.contextView.dispose();
        };
        // ContextView
        ContextViewService.prototype.setContainer = function (container) {
            this.contextView.setContainer(container);
        };
        ContextViewService.prototype.showContextView = function (delegate) {
            this.contextView.show(delegate);
        };
        ContextViewService.prototype.layout = function () {
            this.contextView.layout();
        };
        ContextViewService.prototype.hideContextView = function (data) {
            this.contextView.hide(data);
        };
        ContextViewService = __decorate([
            __param(1, telemetry_1.ITelemetryService),
            __param(2, message_1.IMessageService)
        ], ContextViewService);
        return ContextViewService;
    }());
    exports.ContextViewService = ContextViewService;
});

define(__m[493], __M([0,1,29,2,78,10,59,14,31,115,36]), function (require, exports, uri_1, winjs_base_1, network_1, strings, Timer, Async, objects, request_1, telemetry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Simple IRequestService implementation to allow sharing of this service implementation
     * between different layers of the platform.
     */
    var BaseRequestService = (function () {
        function BaseRequestService(contextService, telemetryService) {
            if (telemetryService === void 0) { telemetryService = telemetry_1.NullTelemetryService; }
            this.serviceId = request_1.IRequestService;
            var workspaceUri = null;
            var workspace = contextService.getWorkspace();
            this._serviceMap = workspace || Object.create(null);
            this._telemetryService = telemetryService;
            if (workspace) {
                workspaceUri = strings.rtrim(workspace.resource.toString(), '/') + '/';
            }
            this.computeOrigin(workspaceUri);
        }
        BaseRequestService.prototype.computeOrigin = function (workspaceUri) {
            if (workspaceUri) {
                // Find root server URL from configuration
                this._origin = workspaceUri;
                var urlPath = uri_1.default.parse(this._origin).path;
                if (urlPath && urlPath.length > 0) {
                    this._origin = this._origin.substring(0, this._origin.length - urlPath.length + 1);
                }
                if (!strings.endsWith(this._origin, '/')) {
                    this._origin += '/';
                }
            }
            else {
                this._origin = '/'; // Configuration not provided, fallback to default
            }
        };
        BaseRequestService.prototype.makeCrossOriginRequest = function (options) {
            return null;
        };
        BaseRequestService.prototype.makeRequest = function (options) {
            var timer = Timer.nullEvent;
            var isXhrRequestCORS = false;
            var url = options.url;
            if (!url) {
                throw new Error('IRequestService.makeRequest: Url is required');
            }
            if ((strings.startsWith(url, 'http://') || strings.startsWith(url, 'https://')) && this._origin && !strings.startsWith(url, this._origin)) {
                var coPromise = this.makeCrossOriginRequest(options);
                if (coPromise) {
                    return coPromise;
                }
                isXhrRequestCORS = true;
            }
            var xhrOptions = options;
            var xhrOptionsPromise = winjs_base_1.TPromise.as(undefined);
            if (!isXhrRequestCORS) {
                xhrOptions = this._telemetryService.getTelemetryInfo().then(function (info) {
                    var additionalHeaders = {};
                    additionalHeaders['X-TelemetrySession'] = info.sessionId;
                    additionalHeaders['X-Requested-With'] = 'XMLHttpRequest';
                    xhrOptions.headers = objects.mixin(xhrOptions.headers, additionalHeaders);
                });
            }
            if (options.timeout) {
                xhrOptions.customRequestInitializer = function (xhrRequest) {
                    xhrRequest.timeout = options.timeout;
                };
            }
            return xhrOptionsPromise.then(function () {
                return Async.always(network_1.xhr(xhrOptions), (function (xhr) {
                    if (timer.data) {
                        timer.data.status = xhr.status;
                    }
                    timer.stop();
                }));
            });
        };
        return BaseRequestService;
    }());
    exports.BaseRequestService = BaseRequestService;
});






define(__m[120], __M([0,1,8,23,78,32,2,435,43,436,161,101,42,493,7]), function (require, exports, errors_1, eventEmitter_1, network_1, severity_1, winjs_base_1, configurationService_1, editor_1, abstractExtensionService_1, keybindingServiceImpl_1, keybindingResolver_1, message_1, baseRequestService_1, editorCommon) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var SimpleEditor = (function () {
        function SimpleEditor(editor) {
            this._widget = editor;
        }
        SimpleEditor.prototype.getId = function () { return 'editor'; };
        SimpleEditor.prototype.getControl = function () { return this._widget; };
        SimpleEditor.prototype.getSelection = function () { return this._widget.getSelection(); };
        SimpleEditor.prototype.focus = function () { this._widget.focus(); };
        SimpleEditor.prototype.withTypedEditor = function (codeEditorCallback, diffEditorCallback) {
            if (this._widget.getEditorType() === editorCommon.EditorType.ICodeEditor) {
                // Single Editor
                return codeEditorCallback(this._widget);
            }
            else {
                // Diff Editor
                return diffEditorCallback(this._widget);
            }
        };
        return SimpleEditor;
    }());
    exports.SimpleEditor = SimpleEditor;
    var SimpleModel = (function (_super) {
        __extends(SimpleModel, _super);
        function SimpleModel(model) {
            _super.call(this);
            this.model = model;
        }
        Object.defineProperty(SimpleModel.prototype, "textEditorModel", {
            get: function () {
                return this.model;
            },
            enumerable: true,
            configurable: true
        });
        return SimpleModel;
    }(eventEmitter_1.EventEmitter));
    exports.SimpleModel = SimpleModel;
    var SimpleEditorService = (function () {
        function SimpleEditorService() {
            this.serviceId = editor_1.IEditorService;
            this.openEditorDelegate = null;
        }
        SimpleEditorService.prototype.setEditor = function (editor) {
            this.editor = new SimpleEditor(editor);
        };
        SimpleEditorService.prototype.setOpenEditorDelegate = function (openEditorDelegate) {
            this.openEditorDelegate = openEditorDelegate;
        };
        SimpleEditorService.prototype.openEditor = function (typedData, sideBySide) {
            var _this = this;
            return winjs_base_1.TPromise.as(this.editor.withTypedEditor(function (editor) { return _this.doOpenEditor(editor, typedData); }, function (diffEditor) { return (_this.doOpenEditor(diffEditor.getOriginalEditor(), typedData) ||
                _this.doOpenEditor(diffEditor.getModifiedEditor(), typedData)); }));
        };
        SimpleEditorService.prototype.doOpenEditor = function (editor, data) {
            var model = this.findModel(editor, data);
            if (!model) {
                if (data.resource) {
                    if (this.openEditorDelegate) {
                        this.openEditorDelegate(data.resource.toString());
                        return null;
                    }
                    else {
                        var schema = data.resource.scheme;
                        if (schema === network_1.Schemas.http || schema === network_1.Schemas.https) {
                            // This is a fully qualified http or https URL
                            window.open(data.resource.toString());
                            return this.editor;
                        }
                    }
                }
                return null;
            }
            var selection = data.options.selection;
            if (selection) {
                if (typeof selection.endLineNumber === 'number' && typeof selection.endColumn === 'number') {
                    editor.setSelection(selection);
                    editor.revealRangeInCenter(selection);
                }
                else {
                    var pos = {
                        lineNumber: selection.startLineNumber,
                        column: selection.startColumn
                    };
                    editor.setPosition(pos);
                    editor.revealPositionInCenter(pos);
                }
            }
            return this.editor;
        };
        SimpleEditorService.prototype.findModel = function (editor, data) {
            var model = editor.getModel();
            if (model.uri.toString() !== data.resource.toString()) {
                return null;
            }
            return model;
        };
        SimpleEditorService.prototype.resolveEditorModel = function (typedData, refresh) {
            var _this = this;
            var model;
            model = this.editor.withTypedEditor(function (editor) { return _this.findModel(editor, typedData); }, function (diffEditor) { return _this.findModel(diffEditor.getOriginalEditor(), typedData) || _this.findModel(diffEditor.getModifiedEditor(), typedData); });
            if (!model) {
                return winjs_base_1.TPromise.as(null);
            }
            return winjs_base_1.TPromise.as(new SimpleModel(model));
        };
        return SimpleEditorService;
    }());
    exports.SimpleEditorService = SimpleEditorService;
    var SimpleMessageService = (function () {
        function SimpleMessageService() {
            this.serviceId = message_1.IMessageService;
        }
        SimpleMessageService.prototype.show = function (sev, message) {
            switch (sev) {
                case severity_1.default.Error:
                    console.error(errors_1.toErrorMessage(message, true));
                    break;
                case severity_1.default.Warning:
                    console.warn(message);
                    break;
                default:
                    console.log(message);
                    break;
            }
            return SimpleMessageService.Empty;
        };
        SimpleMessageService.prototype.hideAll = function () {
            // No-op
        };
        SimpleMessageService.prototype.confirm = function (confirmation) {
            var messageText = confirmation.message;
            if (confirmation.detail) {
                messageText = messageText + '\n\n' + confirmation.detail;
            }
            return window.confirm(messageText);
        };
        SimpleMessageService.Empty = function () { };
        return SimpleMessageService;
    }());
    exports.SimpleMessageService = SimpleMessageService;
    var SimpleEditorRequestService = (function (_super) {
        __extends(SimpleEditorRequestService, _super);
        function SimpleEditorRequestService(contextService, telemetryService) {
            _super.call(this, contextService, telemetryService);
        }
        return SimpleEditorRequestService;
    }(baseRequestService_1.BaseRequestService));
    exports.SimpleEditorRequestService = SimpleEditorRequestService;
    var StandaloneKeybindingService = (function (_super) {
        __extends(StandaloneKeybindingService, _super);
        function StandaloneKeybindingService(configurationService, messageService, domNode) {
            _super.call(this, configurationService, messageService);
            this._dynamicKeybindings = [];
            this._dynamicCommands = Object.create(null);
            this._beginListening(domNode);
        }
        StandaloneKeybindingService.prototype.addDynamicKeybinding = function (keybinding, handler, when, commandId) {
            if (commandId === void 0) { commandId = null; }
            if (commandId === null) {
                commandId = 'DYNAMIC_' + (++StandaloneKeybindingService.LAST_GENERATED_ID);
            }
            var parsedContext = keybindingResolver_1.IOSupport.readKeybindingWhen(when);
            this._dynamicKeybindings.push({
                keybinding: keybinding,
                command: commandId,
                when: parsedContext,
                weight1: 1000,
                weight2: 0
            });
            this._dynamicCommands[commandId] = handler;
            this.updateResolver();
            return commandId;
        };
        StandaloneKeybindingService.prototype._getExtraKeybindings = function (isFirstTime) {
            return this._dynamicKeybindings;
        };
        StandaloneKeybindingService.prototype._getCommandHandler = function (commandId) {
            return _super.prototype._getCommandHandler.call(this, commandId) || this._dynamicCommands[commandId];
        };
        StandaloneKeybindingService.LAST_GENERATED_ID = 0;
        return StandaloneKeybindingService;
    }(keybindingServiceImpl_1.KeybindingService));
    exports.StandaloneKeybindingService = StandaloneKeybindingService;
    var SimpleExtensionService = (function (_super) {
        __extends(SimpleExtensionService, _super);
        function SimpleExtensionService() {
            _super.call(this, true);
        }
        SimpleExtensionService.prototype._showMessage = function (severity, msg) {
            switch (severity) {
                case severity_1.default.Error:
                    console.error(msg);
                    break;
                case severity_1.default.Warning:
                    console.warn(msg);
                    break;
                case severity_1.default.Info:
                    console.info(msg);
                    break;
                default:
                    console.log(msg);
            }
        };
        SimpleExtensionService.prototype._createFailedExtension = function () {
            throw new Error('unexpected');
        };
        SimpleExtensionService.prototype._actualActivateExtension = function (extensionDescription) {
            throw new Error('unexpected');
        };
        return SimpleExtensionService;
    }(abstractExtensionService_1.AbstractExtensionService));
    exports.SimpleExtensionService = SimpleExtensionService;
    var SimpleConfigurationService = (function (_super) {
        __extends(SimpleConfigurationService, _super);
        function SimpleConfigurationService(contextService, eventService) {
            _super.call(this, contextService, eventService);
            this.initialize();
        }
        SimpleConfigurationService.prototype.resolveContents = function (resources) {
            return winjs_base_1.TPromise.as(resources.map(function (resource) {
                return {
                    resource: resource,
                    value: ''
                };
            }));
        };
        SimpleConfigurationService.prototype.resolveContent = function (resource) {
            return winjs_base_1.TPromise.as({
                resource: resource,
                value: ''
            });
        };
        SimpleConfigurationService.prototype.resolveStat = function (resource) {
            return winjs_base_1.TPromise.as({
                resource: resource,
                isDirectory: false
            });
        };
        SimpleConfigurationService.prototype.setUserConfiguration = function (key, value) {
            return winjs_base_1.TPromise.as(null);
        };
        return SimpleConfigurationService;
    }(configurationService_1.ConfigurationService));
    exports.SimpleConfigurationService = SimpleConfigurationService;
});

define(__m[495], __M([0,1]), function (require, exports) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function isLightTheme(themeId) {
        return /vs($| )/.test(themeId);
    }
    exports.isLightTheme = isLightTheme;
    function isDarkTheme(themeId) {
        return /vs-dark($| )/.test(themeId);
    }
    exports.isDarkTheme = isDarkTheme;
    function getSyntaxThemeId(themeId) {
        return themeId.split(' ')[1];
    }
    exports.getSyntaxThemeId = getSyntaxThemeId;
    function getBaseThemeId(themeId) {
        return themeId.split(' ')[0];
    }
    exports.getBaseThemeId = getBaseThemeId;
});






define(__m[496], __M([0,1,495,7,46,160]), function (require, exports, themes, editorCommon, viewPart_1, overviewRulerImpl_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var DecorationsOverviewRuler = (function (_super) {
        __extends(DecorationsOverviewRuler, _super);
        function DecorationsOverviewRuler(context, scrollHeight, getVerticalOffsetForLine) {
            _super.call(this, context);
            this._overviewRuler = new overviewRulerImpl_1.OverviewRulerImpl(1, 'decorationsOverviewRuler', scrollHeight, this._context.configuration.editor.lineHeight, this._context.configuration.editor.viewInfo.canUseTranslate3d, DecorationsOverviewRuler.DECORATION_HEIGHT, DecorationsOverviewRuler.DECORATION_HEIGHT, getVerticalOffsetForLine);
            this._overviewRuler.setLanesCount(this._context.configuration.editor.viewInfo.overviewRulerLanes, false);
            var theme = this._context.configuration.editor.viewInfo.theme;
            this._overviewRuler.setUseDarkColor(!themes.isLightTheme(theme), false);
            this._shouldUpdateDecorations = true;
            this._zonesFromDecorations = [];
            this._shouldUpdateCursorPosition = true;
            this._hideCursor = this._context.configuration.editor.viewInfo.hideCursorInOverviewRuler;
            this._zonesFromCursors = [];
            this._cursorPositions = [];
        }
        DecorationsOverviewRuler.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._overviewRuler.dispose();
        };
        // ---- begin view event handlers
        DecorationsOverviewRuler.prototype.onCursorPositionChanged = function (e) {
            this._shouldUpdateCursorPosition = true;
            this._cursorPositions = [e.position];
            this._cursorPositions = this._cursorPositions.concat(e.secondaryPositions);
            return true;
        };
        DecorationsOverviewRuler.prototype.onConfigurationChanged = function (e) {
            var prevLanesCount = this._overviewRuler.getLanesCount();
            var newLanesCount = this._context.configuration.editor.viewInfo.overviewRulerLanes;
            var shouldRender = false;
            if (e.lineHeight) {
                this._overviewRuler.setLineHeight(this._context.configuration.editor.lineHeight, false);
                shouldRender = true;
            }
            if (e.viewInfo.canUseTranslate3d) {
                this._overviewRuler.setCanUseTranslate3d(this._context.configuration.editor.viewInfo.canUseTranslate3d, false);
                shouldRender = true;
            }
            if (prevLanesCount !== newLanesCount) {
                this._overviewRuler.setLanesCount(newLanesCount, false);
                shouldRender = true;
            }
            if (e.viewInfo.hideCursorInOverviewRuler) {
                this._hideCursor = this._context.configuration.editor.viewInfo.hideCursorInOverviewRuler;
                this._shouldUpdateCursorPosition = true;
                shouldRender = true;
            }
            if (e.viewInfo.theme) {
                var theme = this._context.configuration.editor.viewInfo.theme;
                this._overviewRuler.setUseDarkColor(!themes.isLightTheme(theme), false);
                shouldRender = true;
            }
            return shouldRender;
        };
        DecorationsOverviewRuler.prototype.onLayoutChanged = function (layoutInfo) {
            this._overviewRuler.setLayout(layoutInfo.overviewRuler, false);
            return true;
        };
        DecorationsOverviewRuler.prototype.onZonesChanged = function () {
            return true;
        };
        DecorationsOverviewRuler.prototype.onModelFlushed = function () {
            this._shouldUpdateCursorPosition = true;
            this._shouldUpdateDecorations = true;
            return true;
        };
        DecorationsOverviewRuler.prototype.onModelDecorationsChanged = function (e) {
            this._shouldUpdateDecorations = true;
            return true;
        };
        DecorationsOverviewRuler.prototype.onScrollChanged = function (e) {
            this._overviewRuler.setScrollHeight(e.scrollHeight, false);
            return _super.prototype.onScrollChanged.call(this, e) || e.scrollHeightChanged;
        };
        // ---- end view event handlers
        DecorationsOverviewRuler.prototype.getDomNode = function () {
            return this._overviewRuler.getDomNode();
        };
        DecorationsOverviewRuler.prototype._createZonesFromDecorations = function () {
            var decorations = this._context.model.getAllDecorations();
            var zones = [];
            for (var i = 0, len = decorations.length; i < len; i++) {
                var dec = decorations[i];
                if (dec.options.overviewRuler.color) {
                    zones.push(new editorCommon.OverviewRulerZone(dec.range.startLineNumber, dec.range.endLineNumber, dec.options.overviewRuler.position, 0, dec.options.overviewRuler.color, dec.options.overviewRuler.darkColor));
                }
            }
            return zones;
        };
        DecorationsOverviewRuler.prototype._createZonesFromCursors = function () {
            var zones = [];
            for (var i = 0, len = this._cursorPositions.length; i < len; i++) {
                var cursor = this._cursorPositions[i];
                zones.push(new editorCommon.OverviewRulerZone(cursor.lineNumber, cursor.lineNumber, editorCommon.OverviewRulerLane.Full, 2, DecorationsOverviewRuler._CURSOR_COLOR, DecorationsOverviewRuler._CURSOR_COLOR_DARK));
            }
            return zones;
        };
        DecorationsOverviewRuler.prototype.prepareRender = function (ctx) {
            // Nothing to read
            if (!this.shouldRender()) {
                throw new Error('I did not ask to render!');
            }
        };
        DecorationsOverviewRuler.prototype.render = function (ctx) {
            if (this._shouldUpdateDecorations || this._shouldUpdateCursorPosition) {
                if (this._shouldUpdateDecorations) {
                    this._shouldUpdateDecorations = false;
                    this._zonesFromDecorations = this._createZonesFromDecorations();
                }
                if (this._shouldUpdateCursorPosition) {
                    this._shouldUpdateCursorPosition = false;
                    if (this._hideCursor) {
                        this._zonesFromCursors = [];
                    }
                    else {
                        this._zonesFromCursors = this._createZonesFromCursors();
                    }
                }
                var allZones = [];
                allZones = allZones.concat(this._zonesFromCursors);
                allZones = allZones.concat(this._zonesFromDecorations);
                this._overviewRuler.setZones(allZones, false);
            }
            var hasRendered = this._overviewRuler.render(false);
            if (hasRendered && overviewRulerImpl_1.OverviewRulerImpl.hasCanvas && this._overviewRuler.getLanesCount() > 0 && (this._zonesFromDecorations.length > 0 || this._zonesFromCursors.length > 0)) {
                var ctx2 = this._overviewRuler.getDomNode().getContext('2d');
                ctx2.beginPath();
                ctx2.lineWidth = 1;
                ctx2.strokeStyle = 'rgba(197,197,197,0.8)';
                ctx2.moveTo(0, 0);
                ctx2.lineTo(0, this._overviewRuler.getPixelHeight());
                ctx2.stroke();
                ctx2.moveTo(0, 0);
                ctx2.lineTo(this._overviewRuler.getPixelWidth(), 0);
                ctx2.stroke();
            }
        };
        DecorationsOverviewRuler.DECORATION_HEIGHT = 6;
        DecorationsOverviewRuler._CURSOR_COLOR = 'rgba(0, 0, 102, 0.8)';
        DecorationsOverviewRuler._CURSOR_COLOR_DARK = 'rgba(152, 152, 152, 0.8)';
        return DecorationsOverviewRuler;
    }(viewPart_1.ViewPart));
    exports.DecorationsOverviewRuler = DecorationsOverviewRuler;
});






define(__m[497], __M([0,1,8,23,3,59,28,11,27,4,7,53,424,272,22,291,209,425,275,276,430,437,152,439,426,440,278,496,280,281,282,441,428,283,399]), function (require, exports, errors_1, eventEmitter_1, lifecycle_1, timer, browser, dom, styleMutator_1, range_1, editorCommon, viewEventHandler_1, keyboardHandler_1, pointerHandler_1, editorBrowser, viewController_1, viewEventDispatcher_1, viewOverlays_1, layoutProvider_1, contentWidgets_1, currentLineHighlight_1, decorations_1, glyphMargin_1, lineNumbers_1, viewLines_1, linesDecorations_1, overlayWidgets_1, decorationsOverviewRuler_1, overviewRuler_1, rulers_1, scrollDecoration_1, selections_1, viewCursors_1, viewZones_1, viewContext_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var View = (function (_super) {
        __extends(View, _super);
        function View(keybindingService, configuration, model, triggerCursorHandler) {
            var _this = this;
            _super.call(this);
            this._isDisposed = false;
            this._renderAnimationFrame = null;
            this.outgoingEventBus = new eventEmitter_1.EventEmitter();
            var viewController = new viewController_1.ViewController(model, triggerCursorHandler, this.outgoingEventBus, keybindingService);
            this.listenersToRemove = [];
            this.listenersToDispose = [];
            // The event dispatcher will always go through _renderOnce before dispatching any events
            this.eventDispatcher = new viewEventDispatcher_1.ViewEventDispatcher(function (callback) { return _this._renderOnce(callback); });
            // These two dom nodes must be constructed up front, since references are needed in the layout provider (scrolling & co.)
            this.linesContent = document.createElement('div');
            this.linesContent.className = editorBrowser.ClassNames.LINES_CONTENT + ' monaco-editor-background';
            this.domNode = document.createElement('div');
            this.domNode.className = configuration.editor.viewInfo.editorClassName;
            this.overflowGuardContainer = document.createElement('div');
            this.overflowGuardContainer.className = editorBrowser.ClassNames.OVERFLOW_GUARD;
            // The layout provider has such responsibilities as:
            // - scrolling (i.e. viewport / full size) & co.
            // - whitespaces (a.k.a. view zones) management & co.
            // - line heights updating & co.
            this.layoutProvider = new layoutProvider_1.LayoutProvider(configuration, model, this.eventDispatcher, this.linesContent, this.domNode, this.overflowGuardContainer);
            this.eventDispatcher.addEventHandler(this.layoutProvider);
            // The view context is passed on to most classes (basically to reduce param. counts in ctors)
            this._context = new viewContext_1.ViewContext(configuration, model, this.eventDispatcher, function (eventHandler) { return _this.eventDispatcher.addEventHandler(eventHandler); }, function (eventHandler) { return _this.eventDispatcher.removeEventHandler(eventHandler); });
            this.createTextArea(keybindingService);
            this.createViewParts();
            // Keyboard handler
            this.keyboardHandler = new keyboardHandler_1.KeyboardHandler(this._context, viewController, this.createKeyboardHandlerHelper());
            // Pointer handler
            this.pointerHandler = new pointerHandler_1.PointerHandler(this._context, viewController, this.createPointerHandlerHelper());
            this.hasFocus = false;
            this.codeEditorHelper = null;
            this.eventDispatcher.addEventHandler(this);
            // The view lines rendering calls model.getLineTokens() that might emit events that its tokens have changed.
            // This delayed processing of incoming model events acts as a guard against undesired/unexpected recursion.
            this.handleAccumulatedModelEventsTimeout = -1;
            this.accumulatedModelEvents = [];
            this.listenersToRemove.push(model.addBulkListener2(function (events) {
                _this.accumulatedModelEvents = _this.accumulatedModelEvents.concat(events);
                if (_this.handleAccumulatedModelEventsTimeout === -1) {
                    _this.handleAccumulatedModelEventsTimeout = setTimeout(function () {
                        _this.handleAccumulatedModelEventsTimeout = -1;
                        _this._flushAnyAccumulatedEvents();
                    });
                }
            }));
        }
        View.prototype._flushAnyAccumulatedEvents = function () {
            var toEmit = this.accumulatedModelEvents;
            this.accumulatedModelEvents = [];
            if (toEmit.length > 0) {
                this.eventDispatcher.emitMany(toEmit);
            }
        };
        View.prototype.createTextArea = function (keybindingService) {
            var _this = this;
            // Text Area (The focus will always be in the textarea when the cursor is blinking)
            this.textArea = document.createElement('textarea');
            this._keybindingService = keybindingService.createScoped(this.textArea);
            this._editorTextFocusContextKey = this._keybindingService.createKey(editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS, undefined);
            this.textArea.className = editorBrowser.ClassNames.TEXTAREA;
            this.textArea.setAttribute('wrap', 'off');
            this.textArea.setAttribute('autocorrect', 'off');
            this.textArea.setAttribute('autocapitalize', 'off');
            this.textArea.setAttribute('spellcheck', 'false');
            this.textArea.setAttribute('aria-label', this._context.configuration.editor.viewInfo.ariaLabel);
            this.textArea.setAttribute('role', 'textbox');
            this.textArea.setAttribute('aria-multiline', 'true');
            this.textArea.setAttribute('aria-haspopup', 'false');
            this.textArea.setAttribute('aria-autocomplete', 'both');
            styleMutator_1.StyleMutator.setTop(this.textArea, 0);
            styleMutator_1.StyleMutator.setLeft(this.textArea, 0);
            this.listenersToDispose.push(dom.addDisposableListener(this.textArea, 'focus', function () { return _this._setHasFocus(true); }));
            this.listenersToDispose.push(dom.addDisposableListener(this.textArea, 'blur', function () { return _this._setHasFocus(false); }));
            // On top of the text area, we position a dom node to cover it up
            // (there have been reports of tiny blinking cursors)
            // (in WebKit the textarea is 1px by 1px because it cannot handle input to a 0x0 textarea)
            this.textAreaCover = document.createElement('div');
            if (this._context.configuration.editor.viewInfo.glyphMargin) {
                this.textAreaCover.className = 'monaco-editor-background ' + editorBrowser.ClassNames.GLYPH_MARGIN + ' ' + editorBrowser.ClassNames.TEXTAREA_COVER;
            }
            else {
                if (this._context.configuration.editor.viewInfo.lineNumbers) {
                    this.textAreaCover.className = 'monaco-editor-background ' + editorBrowser.ClassNames.LINE_NUMBERS + ' ' + editorBrowser.ClassNames.TEXTAREA_COVER;
                }
                else {
                    this.textAreaCover.className = 'monaco-editor-background ' + editorBrowser.ClassNames.TEXTAREA_COVER;
                }
            }
            this.textAreaCover.style.position = 'absolute';
            styleMutator_1.StyleMutator.setWidth(this.textAreaCover, 1);
            styleMutator_1.StyleMutator.setHeight(this.textAreaCover, 1);
            styleMutator_1.StyleMutator.setTop(this.textAreaCover, 0);
            styleMutator_1.StyleMutator.setLeft(this.textAreaCover, 0);
        };
        View.prototype.createViewParts = function () {
            var _this = this;
            this.viewParts = [];
            // View Lines
            this.viewLines = new viewLines_1.ViewLines(this._context, this.layoutProvider);
            // View Zones
            this.viewZones = new viewZones_1.ViewZones(this._context, this.layoutProvider);
            this.viewParts.push(this.viewZones);
            // Decorations overview ruler
            var decorationsOverviewRuler = new decorationsOverviewRuler_1.DecorationsOverviewRuler(this._context, this.layoutProvider.getScrollHeight(), function (lineNumber) { return _this.layoutProvider.getVerticalOffsetForLineNumber(lineNumber); });
            this.viewParts.push(decorationsOverviewRuler);
            var scrollDecoration = new scrollDecoration_1.ScrollDecorationViewPart(this._context);
            this.viewParts.push(scrollDecoration);
            var contentViewOverlays = new viewOverlays_1.ContentViewOverlays(this._context, this.layoutProvider);
            this.viewParts.push(contentViewOverlays);
            contentViewOverlays.addDynamicOverlay(new currentLineHighlight_1.CurrentLineHighlightOverlay(this._context, this.layoutProvider));
            contentViewOverlays.addDynamicOverlay(new selections_1.SelectionsOverlay(this._context));
            contentViewOverlays.addDynamicOverlay(new decorations_1.DecorationsOverlay(this._context));
            var marginViewOverlays = new viewOverlays_1.MarginViewOverlays(this._context, this.layoutProvider);
            this.viewParts.push(marginViewOverlays);
            marginViewOverlays.addDynamicOverlay(new glyphMargin_1.GlyphMarginOverlay(this._context));
            marginViewOverlays.addDynamicOverlay(new linesDecorations_1.LinesDecorationsOverlay(this._context));
            marginViewOverlays.addDynamicOverlay(new lineNumbers_1.LineNumbersOverlay(this._context));
            // Content widgets
            this.contentWidgets = new contentWidgets_1.ViewContentWidgets(this._context, this.domNode);
            this.viewParts.push(this.contentWidgets);
            var viewCursors = new viewCursors_1.ViewCursors(this._context);
            this.viewParts.push(viewCursors);
            // Overlay widgets
            this.overlayWidgets = new overlayWidgets_1.ViewOverlayWidgets(this._context);
            this.viewParts.push(this.overlayWidgets);
            var rulers = new rulers_1.Rulers(this._context, this.layoutProvider);
            this.viewParts.push(rulers);
            // -------------- Wire dom nodes up
            this.linesContentContainer = this.layoutProvider.getScrollbarContainerDomNode();
            this.linesContentContainer.style.position = 'absolute';
            if (decorationsOverviewRuler) {
                var overviewRulerData = this.layoutProvider.getOverviewRulerInsertData();
                overviewRulerData.parent.insertBefore(decorationsOverviewRuler.getDomNode(), overviewRulerData.insertBefore);
            }
            this.linesContent.appendChild(contentViewOverlays.getDomNode());
            this.linesContent.appendChild(rulers.domNode);
            this.linesContent.appendChild(this.viewZones.domNode);
            this.linesContent.appendChild(this.viewLines.getDomNode());
            this.linesContent.appendChild(this.contentWidgets.domNode);
            this.linesContent.appendChild(viewCursors.getDomNode());
            this.overflowGuardContainer.appendChild(marginViewOverlays.getDomNode());
            this.overflowGuardContainer.appendChild(this.linesContentContainer);
            this.overflowGuardContainer.appendChild(scrollDecoration.getDomNode());
            this.overflowGuardContainer.appendChild(this.overlayWidgets.domNode);
            this.overflowGuardContainer.appendChild(this.textArea);
            this.overflowGuardContainer.appendChild(this.textAreaCover);
            this.domNode.appendChild(this.overflowGuardContainer);
            this.domNode.appendChild(this.contentWidgets.overflowingContentWidgetsDomNode);
        };
        View.prototype._flushAccumulatedAndRenderNow = function () {
            this._flushAnyAccumulatedEvents();
            this._renderNow();
        };
        View.prototype.createPointerHandlerHelper = function () {
            var _this = this;
            return {
                viewDomNode: this.domNode,
                linesContentDomNode: this.linesContent,
                focusTextArea: function () {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.focusTextArea: View is disposed');
                    }
                    _this.focus();
                },
                isDirty: function () {
                    return (_this.accumulatedModelEvents.length > 0);
                },
                getScrollLeft: function () {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.getScrollLeft: View is disposed');
                    }
                    return _this.layoutProvider.getScrollLeft();
                },
                getScrollTop: function () {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.getScrollTop: View is disposed');
                    }
                    return _this.layoutProvider.getScrollTop();
                },
                setScrollPosition: function (position) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.setScrollPosition: View is disposed');
                    }
                    _this.layoutProvider.setScrollPosition(position);
                },
                isAfterLines: function (verticalOffset) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.isAfterLines: View is disposed');
                    }
                    return _this.layoutProvider.isAfterLines(verticalOffset);
                },
                getLineNumberAtVerticalOffset: function (verticalOffset) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.getLineNumberAtVerticalOffset: View is disposed');
                    }
                    return _this.layoutProvider.getLineNumberAtVerticalOffset(verticalOffset);
                },
                getVerticalOffsetForLineNumber: function (lineNumber) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.getVerticalOffsetForLineNumber: View is disposed');
                    }
                    return _this.layoutProvider.getVerticalOffsetForLineNumber(lineNumber);
                },
                getWhitespaceAtVerticalOffset: function (verticalOffset) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.getWhitespaceAtVerticalOffset: View is disposed');
                    }
                    return _this.layoutProvider.getWhitespaceAtVerticalOffset(verticalOffset);
                },
                shouldSuppressMouseDownOnViewZone: function (viewZoneId) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.shouldSuppressMouseDownOnViewZone: View is disposed');
                    }
                    return _this.viewZones.shouldSuppressMouseDownOnViewZone(viewZoneId);
                },
                getPositionFromDOMInfo: function (spanNode, offset) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.getPositionFromDOMInfo: View is disposed');
                    }
                    _this._flushAccumulatedAndRenderNow();
                    return _this.viewLines.getPositionFromDOMInfo(spanNode, offset);
                },
                visibleRangeForPosition2: function (lineNumber, column) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.visibleRangeForPosition2: View is disposed');
                    }
                    _this._flushAccumulatedAndRenderNow();
                    var visibleRanges = _this.viewLines.visibleRangesForRange2(new range_1.Range(lineNumber, column, lineNumber, column), 0);
                    if (!visibleRanges) {
                        return null;
                    }
                    return visibleRanges[0];
                },
                getLineWidth: function (lineNumber) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.pointerHandler.getLineWidth: View is disposed');
                    }
                    _this._flushAccumulatedAndRenderNow();
                    return _this.viewLines.getLineWidth(lineNumber);
                }
            };
        };
        View.prototype.createKeyboardHandlerHelper = function () {
            var _this = this;
            return {
                viewDomNode: this.domNode,
                textArea: this.textArea,
                visibleRangeForPositionRelativeToEditor: function (lineNumber, column) {
                    if (_this._isDisposed) {
                        throw new Error('ViewImpl.keyboardHandler.visibleRangeForPositionRelativeToEditor: View is disposed');
                    }
                    _this._flushAccumulatedAndRenderNow();
                    var linesViewPortData = _this.layoutProvider.getLinesViewportData();
                    var visibleRanges = _this.viewLines.visibleRangesForRange2(new range_1.Range(lineNumber, column, lineNumber, column), linesViewPortData.visibleRangesDeltaTop);
                    if (!visibleRanges) {
                        return null;
                    }
                    return visibleRanges[0];
                },
                flushAnyAccumulatedEvents: function () {
                    _this._flushAnyAccumulatedEvents();
                }
            };
        };
        View.prototype.setAriaActiveDescendant = function (id) {
            if (id) {
                this.textArea.setAttribute('role', 'combobox');
                if (this.textArea.getAttribute('aria-activedescendant') !== id) {
                    this.textArea.setAttribute('aria-haspopup', 'true');
                    this.textArea.setAttribute('aria-activedescendant', id);
                }
            }
            else {
                this.textArea.setAttribute('role', 'textbox');
                this.textArea.removeAttribute('aria-activedescendant');
                this.textArea.removeAttribute('aria-haspopup');
            }
        };
        // --- begin event handlers
        View.prototype.onLayoutChanged = function (layoutInfo) {
            if (browser.isChrome) {
                /* tslint:disable:no-unused-variable */
                // Access overflowGuardContainer.clientWidth to prevent relayouting bug in Chrome
                // See Bug 19676: Editor misses a layout event
                var clientWidth = this.overflowGuardContainer.clientWidth + 'px';
            }
            styleMutator_1.StyleMutator.setWidth(this.domNode, layoutInfo.width);
            styleMutator_1.StyleMutator.setHeight(this.domNode, layoutInfo.height);
            styleMutator_1.StyleMutator.setWidth(this.overflowGuardContainer, layoutInfo.width);
            styleMutator_1.StyleMutator.setHeight(this.overflowGuardContainer, layoutInfo.height);
            styleMutator_1.StyleMutator.setWidth(this.linesContent, 1000000);
            styleMutator_1.StyleMutator.setHeight(this.linesContent, 1000000);
            styleMutator_1.StyleMutator.setLeft(this.linesContentContainer, layoutInfo.contentLeft);
            styleMutator_1.StyleMutator.setWidth(this.linesContentContainer, layoutInfo.contentWidth);
            styleMutator_1.StyleMutator.setHeight(this.linesContentContainer, layoutInfo.contentHeight);
            this.outgoingEventBus.emit(editorCommon.EventType.ViewLayoutChanged, layoutInfo);
            return false;
        };
        View.prototype.onConfigurationChanged = function (e) {
            if (e.viewInfo.editorClassName) {
                this.domNode.className = this._context.configuration.editor.viewInfo.editorClassName;
            }
            if (e.viewInfo.ariaLabel) {
                this.textArea.setAttribute('aria-label', this._context.configuration.editor.viewInfo.ariaLabel);
            }
            return false;
        };
        View.prototype.onScrollChanged = function (e) {
            this.outgoingEventBus.emit('scroll', e);
            return false;
        };
        View.prototype.onViewFocusChanged = function (isFocused) {
            dom.toggleClass(this.domNode, 'focused', isFocused);
            if (isFocused) {
                this._editorTextFocusContextKey.set(true);
                this.outgoingEventBus.emit(editorCommon.EventType.ViewFocusGained, {});
            }
            else {
                this._editorTextFocusContextKey.reset();
                this.outgoingEventBus.emit(editorCommon.EventType.ViewFocusLost, {});
            }
            return false;
        };
        // --- end event handlers
        View.prototype.dispose = function () {
            this._isDisposed = true;
            if (this.handleAccumulatedModelEventsTimeout !== -1) {
                clearTimeout(this.handleAccumulatedModelEventsTimeout);
                this.handleAccumulatedModelEventsTimeout = -1;
            }
            if (this._renderAnimationFrame !== null) {
                this._renderAnimationFrame.dispose();
                this._renderAnimationFrame = null;
            }
            this.accumulatedModelEvents = [];
            this.eventDispatcher.removeEventHandler(this);
            this.outgoingEventBus.dispose();
            this.listenersToRemove = lifecycle_1.dispose(this.listenersToRemove);
            this.listenersToDispose = lifecycle_1.dispose(this.listenersToDispose);
            this.keyboardHandler.dispose();
            this.pointerHandler.dispose();
            this.viewLines.dispose();
            // Destroy IViewPart second
            for (var i = 0, len = this.viewParts.length; i < len; i++) {
                this.viewParts[i].dispose();
            }
            this.viewParts = [];
            this.layoutProvider.dispose();
            this._keybindingService.dispose();
        };
        View.prototype.getCodeEditorHelper = function () {
            var _this = this;
            if (!this.codeEditorHelper) {
                this.codeEditorHelper = {
                    getScrollWidth: function () {
                        if (_this._isDisposed) {
                            throw new Error('ViewImpl.codeEditorHelper.getScrollWidth: View is disposed');
                        }
                        return _this.layoutProvider.getScrollWidth();
                    },
                    getScrollLeft: function () {
                        if (_this._isDisposed) {
                            throw new Error('ViewImpl.codeEditorHelper.getScrollLeft: View is disposed');
                        }
                        return _this.layoutProvider.getScrollLeft();
                    },
                    getScrollHeight: function () {
                        if (_this._isDisposed) {
                            throw new Error('ViewImpl.codeEditorHelper.getScrollHeight: View is disposed');
                        }
                        return _this.layoutProvider.getScrollHeight();
                    },
                    getScrollTop: function () {
                        if (_this._isDisposed) {
                            throw new Error('ViewImpl.codeEditorHelper.getScrollTop: View is disposed');
                        }
                        return _this.layoutProvider.getScrollTop();
                    },
                    setScrollPosition: function (position) {
                        if (_this._isDisposed) {
                            throw new Error('ViewImpl.codeEditorHelper.setScrollPosition: View is disposed');
                        }
                        _this.layoutProvider.setScrollPosition(position);
                    },
                    getVerticalOffsetForPosition: function (modelLineNumber, modelColumn) {
                        if (_this._isDisposed) {
                            throw new Error('ViewImpl.codeEditorHelper.getVerticalOffsetForPosition: View is disposed');
                        }
                        var modelPosition = _this._context.model.validateModelPosition({
                            lineNumber: modelLineNumber,
                            column: modelColumn
                        });
                        var viewPosition = _this._context.model.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);
                        return _this.layoutProvider.getVerticalOffsetForLineNumber(viewPosition.lineNumber);
                    },
                    delegateVerticalScrollbarMouseDown: function (browserEvent) {
                        if (_this._isDisposed) {
                            throw new Error('ViewImpl.codeEditorHelper.delegateVerticalScrollbarMouseDown: View is disposed');
                        }
                        _this.layoutProvider.delegateVerticalScrollbarMouseDown(browserEvent);
                    },
                    getOffsetForColumn: function (modelLineNumber, modelColumn) {
                        if (_this._isDisposed) {
                            throw new Error('ViewImpl.codeEditorHelper.getOffsetForColumn: View is disposed');
                        }
                        var modelPosition = _this._context.model.validateModelPosition({
                            lineNumber: modelLineNumber,
                            column: modelColumn
                        });
                        var viewPosition = _this._context.model.convertModelPositionToViewPosition(modelPosition.lineNumber, modelPosition.column);
                        _this._flushAccumulatedAndRenderNow();
                        var visibleRanges = _this.viewLines.visibleRangesForRange2(new range_1.Range(viewPosition.lineNumber, viewPosition.column, viewPosition.lineNumber, viewPosition.column), 0);
                        if (!visibleRanges) {
                            return -1;
                        }
                        return visibleRanges[0].left;
                    }
                };
            }
            return this.codeEditorHelper;
        };
        View.prototype.getCenteredRangeInViewport = function () {
            if (this._isDisposed) {
                throw new Error('ViewImpl.getCenteredRangeInViewport: View is disposed');
            }
            var viewLineNumber = this.layoutProvider.getCenteredViewLineNumberInViewport();
            var viewModel = this._context.model;
            var currentCenteredViewRange = new range_1.Range(viewLineNumber, 1, viewLineNumber, viewModel.getLineMaxColumn(viewLineNumber));
            return viewModel.convertViewRangeToModelRange(currentCenteredViewRange);
        };
        //	public getLineInfoProvider():view.ILineInfoProvider {
        //		return this.viewLines;
        //	}
        View.prototype.getInternalEventBus = function () {
            if (this._isDisposed) {
                throw new Error('ViewImpl.getInternalEventBus: View is disposed');
            }
            return this.outgoingEventBus;
        };
        View.prototype.saveState = function () {
            if (this._isDisposed) {
                throw new Error('ViewImpl.saveState: View is disposed');
            }
            return this.layoutProvider.saveState();
        };
        View.prototype.restoreState = function (state) {
            if (this._isDisposed) {
                throw new Error('ViewImpl.restoreState: View is disposed');
            }
            this._flushAnyAccumulatedEvents();
            return this.layoutProvider.restoreState(state);
        };
        View.prototype.focus = function () {
            if (this._isDisposed) {
                throw new Error('ViewImpl.focus: View is disposed');
            }
            this.keyboardHandler.focusTextArea();
            // IE does not trigger the focus event immediately, so we must help it a little bit
            this._setHasFocus(true);
        };
        View.prototype.isFocused = function () {
            if (this._isDisposed) {
                throw new Error('ViewImpl.isFocused: View is disposed');
            }
            return this.hasFocus;
        };
        View.prototype.createOverviewRuler = function (cssClassName, minimumHeight, maximumHeight) {
            var _this = this;
            if (this._isDisposed) {
                throw new Error('ViewImpl.createOverviewRuler: View is disposed');
            }
            return new overviewRuler_1.OverviewRuler(this._context, cssClassName, this.layoutProvider.getScrollHeight(), minimumHeight, maximumHeight, function (lineNumber) { return _this.layoutProvider.getVerticalOffsetForLineNumber(lineNumber); });
        };
        View.prototype.change = function (callback) {
            var _this = this;
            if (this._isDisposed) {
                throw new Error('ViewImpl.change: View is disposed');
            }
            var zonesHaveChanged = false;
            this._renderOnce(function () {
                // Handle events to avoid "adjusting" newly inserted view zones
                _this._flushAnyAccumulatedEvents();
                var changeAccessor = {
                    addZone: function (zone) {
                        zonesHaveChanged = true;
                        return _this.viewZones.addZone(zone);
                    },
                    removeZone: function (id) {
                        zonesHaveChanged = _this.viewZones.removeZone(id) || zonesHaveChanged;
                    },
                    layoutZone: function (id) {
                        zonesHaveChanged = _this.viewZones.layoutZone(id) || zonesHaveChanged;
                    }
                };
                var r = safeInvoke1Arg(callback, changeAccessor);
                // Invalidate changeAccessor
                changeAccessor.addZone = null;
                changeAccessor.removeZone = null;
                if (zonesHaveChanged) {
                    _this._context.privateViewEventBus.emit(editorCommon.EventType.ViewZonesChanged, null);
                }
                return r;
            });
            return zonesHaveChanged;
        };
        View.prototype.getWhitespaces = function () {
            if (this._isDisposed) {
                throw new Error('ViewImpl.getWhitespaces: View is disposed');
            }
            return this.layoutProvider.getWhitespaces();
        };
        View.prototype.addContentWidget = function (widgetData) {
            var _this = this;
            if (this._isDisposed) {
                throw new Error('ViewImpl.addContentWidget: View is disposed');
            }
            this._renderOnce(function () {
                _this.contentWidgets.addWidget(widgetData.widget);
                _this.layoutContentWidget(widgetData);
            });
        };
        View.prototype.layoutContentWidget = function (widgetData) {
            var _this = this;
            if (this._isDisposed) {
                throw new Error('ViewImpl.layoutContentWidget: View is disposed');
            }
            this._renderOnce(function () {
                var newPosition = widgetData.position ? widgetData.position.position : null;
                var newPreference = widgetData.position ? widgetData.position.preference : null;
                _this.contentWidgets.setWidgetPosition(widgetData.widget, newPosition, newPreference);
            });
        };
        View.prototype.removeContentWidget = function (widgetData) {
            var _this = this;
            if (this._isDisposed) {
                throw new Error('ViewImpl.removeContentWidget: View is disposed');
            }
            this._renderOnce(function () {
                _this.contentWidgets.removeWidget(widgetData.widget);
            });
        };
        View.prototype.addOverlayWidget = function (widgetData) {
            var _this = this;
            if (this._isDisposed) {
                throw new Error('ViewImpl.addOverlayWidget: View is disposed');
            }
            this._renderOnce(function () {
                _this.overlayWidgets.addWidget(widgetData.widget);
                _this.layoutOverlayWidget(widgetData);
            });
        };
        View.prototype.layoutOverlayWidget = function (widgetData) {
            if (this._isDisposed) {
                throw new Error('ViewImpl.layoutOverlayWidget: View is disposed');
            }
            var newPreference = widgetData.position ? widgetData.position.preference : null;
            var shouldRender = this.overlayWidgets.setWidgetPosition(widgetData.widget, newPreference);
            if (shouldRender) {
                this._scheduleRender();
            }
        };
        View.prototype.removeOverlayWidget = function (widgetData) {
            var _this = this;
            if (this._isDisposed) {
                throw new Error('ViewImpl.removeOverlayWidget: View is disposed');
            }
            this._renderOnce(function () {
                _this.overlayWidgets.removeWidget(widgetData.widget);
            });
        };
        View.prototype.render = function (now, everything) {
            if (this._isDisposed) {
                throw new Error('ViewImpl.render: View is disposed');
            }
            if (everything) {
                // Force a render with a layout event
                this.layoutProvider.emitLayoutChangedEvent();
            }
            if (now) {
                this._flushAccumulatedAndRenderNow();
            }
        };
        View.prototype.renderOnce = function (callback) {
            if (this._isDisposed) {
                throw new Error('ViewImpl.renderOnce: View is disposed');
            }
            return this._renderOnce(callback);
        };
        // --- end Code Editor APIs
        View.prototype._renderOnce = function (callback) {
            var _this = this;
            if (this._isDisposed) {
                throw new Error('ViewImpl._renderOnce: View is disposed');
            }
            return this.outgoingEventBus.deferredEmit(function () {
                var r = safeInvokeNoArg(callback);
                _this._scheduleRender();
                return r;
            });
        };
        View.prototype._scheduleRender = function () {
            if (this._isDisposed) {
                throw new Error('ViewImpl._scheduleRender: View is disposed');
            }
            if (this._renderAnimationFrame === null) {
                this._renderAnimationFrame = dom.runAtThisOrScheduleAtNextAnimationFrame(this._onRenderScheduled.bind(this), 100);
            }
        };
        View.prototype._onRenderScheduled = function () {
            this._renderAnimationFrame = null;
            this._flushAccumulatedAndRenderNow();
        };
        View.prototype._renderNow = function () {
            var _this = this;
            safeInvokeNoArg(function () { return _this._actualRender(); });
        };
        View.prototype.createRenderingContext = function (linesViewportData) {
            var _this = this;
            var vInfo = this.layoutProvider.getCurrentViewport();
            var deltaTop = linesViewportData.visibleRangesDeltaTop;
            var r = {
                linesViewportData: linesViewportData,
                scrollWidth: this.layoutProvider.getScrollWidth(),
                scrollHeight: this.layoutProvider.getScrollHeight(),
                visibleRange: linesViewportData.visibleRange,
                bigNumbersDelta: linesViewportData.bigNumbersDelta,
                viewportWidth: vInfo.width,
                viewportHeight: vInfo.height,
                viewportLeft: vInfo.left,
                viewportTop: vInfo.top,
                getScrolledTopFromAbsoluteTop: function (absoluteTop) {
                    return _this.layoutProvider.getScrolledTopFromAbsoluteTop(absoluteTop);
                },
                getViewportVerticalOffsetForLineNumber: function (lineNumber) {
                    var verticalOffset = _this.layoutProvider.getVerticalOffsetForLineNumber(lineNumber);
                    var scrolledTop = _this.layoutProvider.getScrolledTopFromAbsoluteTop(verticalOffset);
                    return scrolledTop;
                },
                getDecorationsInViewport: function () { return linesViewportData.getDecorationsInViewport(); },
                linesVisibleRangesForRange: function (range, includeNewLines) {
                    return _this.viewLines.linesVisibleRangesForRange(range, includeNewLines);
                },
                visibleRangeForPosition: function (position) {
                    var visibleRanges = _this.viewLines.visibleRangesForRange2(new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column), deltaTop);
                    if (!visibleRanges) {
                        return null;
                    }
                    return visibleRanges[0];
                },
                lineIsVisible: function (lineNumber) {
                    return linesViewportData.visibleRange.startLineNumber <= lineNumber && lineNumber <= linesViewportData.visibleRange.endLineNumber;
                }
            };
            return r;
        };
        View.prototype._getViewPartsToRender = function () {
            var result = [];
            for (var i = 0, len = this.viewParts.length; i < len; i++) {
                var viewPart = this.viewParts[i];
                if (viewPart.shouldRender()) {
                    result.push(viewPart);
                }
            }
            return result;
        };
        View.prototype._actualRender = function () {
            var _this = this;
            if (!dom.isInDOM(this.domNode)) {
                return;
            }
            var t = timer.start(timer.Topic.EDITOR, 'View.render');
            var viewPartsToRender = this._getViewPartsToRender();
            if (!this.viewLines.shouldRender() && viewPartsToRender.length === 0) {
                // Nothing to render
                this.keyboardHandler.writeToTextArea();
                t.stop();
                return;
            }
            var linesViewportData = this.layoutProvider.getLinesViewportData();
            if (this.viewLines.shouldRender()) {
                this.viewLines.renderText(linesViewportData, function () {
                    _this.keyboardHandler.writeToTextArea();
                });
                this.viewLines.onDidRender();
                // Rendering of viewLines might cause scroll events to occur, so collect view parts to render again
                viewPartsToRender = this._getViewPartsToRender();
            }
            else {
                this.keyboardHandler.writeToTextArea();
            }
            var renderingContext = this.createRenderingContext(linesViewportData);
            // Render the rest of the parts
            for (var i = 0, len = viewPartsToRender.length; i < len; i++) {
                var viewPart = viewPartsToRender[i];
                viewPart.prepareRender(renderingContext);
            }
            for (var i = 0, len = viewPartsToRender.length; i < len; i++) {
                var viewPart = viewPartsToRender[i];
                viewPart.render(renderingContext);
                viewPart.onDidRender();
            }
            // Render the scrollbar
            this.layoutProvider.renderScrollbar();
            t.stop();
        };
        View.prototype._setHasFocus = function (newHasFocus) {
            if (this.hasFocus !== newHasFocus) {
                this.hasFocus = newHasFocus;
                this._context.privateViewEventBus.emit(editorCommon.EventType.ViewFocusChanged, this.hasFocus);
            }
        };
        return View;
    }(viewEventHandler_1.ViewEventHandler));
    exports.View = View;
    function safeInvokeNoArg(func) {
        try {
            return func();
        }
        catch (e) {
            errors_1.onUnexpectedError(e);
        }
    }
    function safeInvoke1Arg(func, arg1) {
        try {
            return func(arg1);
        }
        catch (e) {
            errors_1.onUnexpectedError(e);
        }
    }
});















define(__m[94], __M([0,1,8,28,11,15,19,36,398,4,24,7,13,54,66,30,151,497,3,16,199,200]), function (require, exports, errors_1, browser, dom, instantiation_1, keybindingService_1, telemetry_1, commonCodeEditor_1, range_1, selection_1, editorCommon, editorCommonExtensions_1, codeEditorService_1, configuration_1, editorBrowserExtensions_1, colorizer_1, viewImpl_1, lifecycle_1, event_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var CodeEditorWidget = (function (_super) {
        __extends(CodeEditorWidget, _super);
        function CodeEditorWidget(domElement, options, instantiationService, codeEditorService, keybindingService, telemetryService) {
            var _this = this;
            _super.call(this, domElement, options, instantiationService, codeEditorService, keybindingService, telemetryService);
            this._focusTracker = new CodeEditorWidgetFocusTracker(domElement);
            this._focusTracker.onChage(function () {
                var hasFocus = _this._focusTracker.hasFocus();
                if (hasFocus) {
                    _this._editorFocusContextKey.set(true);
                    _this.emit(editorCommon.EventType.EditorFocus, {});
                }
                else {
                    _this._editorFocusContextKey.reset();
                    _this.emit(editorCommon.EventType.EditorBlur, {});
                }
            });
            this.contentWidgets = {};
            this.overlayWidgets = {};
            var contributionDescriptors = [].concat(editorBrowserExtensions_1.EditorBrowserRegistry.getEditorContributions()).concat(editorCommonExtensions_1.CommonEditorRegistry.getEditorContributions());
            for (var i = 0, len = contributionDescriptors.length; i < len; i++) {
                try {
                    var contribution = contributionDescriptors[i].createInstance(this._instantiationService, this);
                    this.contributions[contribution.getId()] = contribution;
                }
                catch (err) {
                    console.error('Could not instantiate contribution ' + contribution.getId());
                    errors_1.onUnexpectedError(err);
                }
            }
        }
        CodeEditorWidget.prototype.onMouseUp = function (listener) {
            return this.addListener2(editorCommon.EventType.MouseUp, listener);
        };
        CodeEditorWidget.prototype.onMouseDown = function (listener) {
            return this.addListener2(editorCommon.EventType.MouseDown, listener);
        };
        CodeEditorWidget.prototype.onContextMenu = function (listener) {
            return this.addListener2(editorCommon.EventType.ContextMenu, listener);
        };
        CodeEditorWidget.prototype.onMouseMove = function (listener) {
            return this.addListener2(editorCommon.EventType.MouseMove, listener);
        };
        CodeEditorWidget.prototype.onMouseLeave = function (listener) {
            return this.addListener2(editorCommon.EventType.MouseLeave, listener);
        };
        CodeEditorWidget.prototype.onKeyUp = function (listener) {
            return this.addListener2(editorCommon.EventType.KeyUp, listener);
        };
        CodeEditorWidget.prototype.onKeyDown = function (listener) {
            return this.addListener2(editorCommon.EventType.KeyDown, listener);
        };
        CodeEditorWidget.prototype.onDidLayoutChange = function (listener) {
            return this.addListener2(editorCommon.EventType.EditorLayout, listener);
        };
        CodeEditorWidget.prototype.onDidScrollChange = function (listener) {
            return this.addListener2('scroll', listener);
        };
        CodeEditorWidget.prototype._createConfiguration = function (options) {
            return new configuration_1.Configuration(options, this.domElement);
        };
        CodeEditorWidget.prototype.dispose = function () {
            this.contentWidgets = {};
            this.overlayWidgets = {};
            this._focusTracker.dispose();
            _super.prototype.dispose.call(this);
        };
        CodeEditorWidget.prototype.updateOptions = function (newOptions) {
            var oldTheme = this._configuration.editor.viewInfo.theme;
            _super.prototype.updateOptions.call(this, newOptions);
            var newTheme = this._configuration.editor.viewInfo.theme;
            if (oldTheme !== newTheme) {
                this.render();
            }
        };
        CodeEditorWidget.prototype.colorizeModelLine = function (lineNumber, model) {
            if (model === void 0) { model = this.model; }
            if (!model) {
                return '';
            }
            var content = model.getLineContent(lineNumber);
            var tokens = model.getLineTokens(lineNumber, false);
            var inflatedTokens = tokens.inflate();
            var tabSize = model.getOptions().tabSize;
            return colorizer_1.Colorizer.colorizeLine(content, inflatedTokens, tabSize);
        };
        CodeEditorWidget.prototype.getView = function () {
            return this._view;
        };
        CodeEditorWidget.prototype.getDomNode = function () {
            if (!this.hasView) {
                return null;
            }
            return this._view.domNode;
        };
        CodeEditorWidget.prototype.getCenteredRangeInViewport = function () {
            if (!this.hasView) {
                return null;
            }
            return this._view.getCenteredRangeInViewport();
        };
        CodeEditorWidget.prototype.getScrollWidth = function () {
            if (!this.hasView) {
                return -1;
            }
            return this._view.getCodeEditorHelper().getScrollWidth();
        };
        CodeEditorWidget.prototype.getScrollLeft = function () {
            if (!this.hasView) {
                return -1;
            }
            return this._view.getCodeEditorHelper().getScrollLeft();
        };
        CodeEditorWidget.prototype.getScrollHeight = function () {
            if (!this.hasView) {
                return -1;
            }
            return this._view.getCodeEditorHelper().getScrollHeight();
        };
        CodeEditorWidget.prototype.getScrollTop = function () {
            if (!this.hasView) {
                return -1;
            }
            return this._view.getCodeEditorHelper().getScrollTop();
        };
        CodeEditorWidget.prototype.setScrollLeft = function (newScrollLeft) {
            if (!this.hasView) {
                return;
            }
            if (typeof newScrollLeft !== 'number') {
                throw new Error('Invalid arguments');
            }
            this._view.getCodeEditorHelper().setScrollPosition({
                scrollLeft: newScrollLeft
            });
        };
        CodeEditorWidget.prototype.setScrollTop = function (newScrollTop) {
            if (!this.hasView) {
                return;
            }
            if (typeof newScrollTop !== 'number') {
                throw new Error('Invalid arguments');
            }
            this._view.getCodeEditorHelper().setScrollPosition({
                scrollTop: newScrollTop
            });
        };
        CodeEditorWidget.prototype.setScrollPosition = function (position) {
            if (!this.hasView) {
                return;
            }
            this._view.getCodeEditorHelper().setScrollPosition(position);
        };
        CodeEditorWidget.prototype.delegateVerticalScrollbarMouseDown = function (browserEvent) {
            if (!this.hasView) {
                return;
            }
            this._view.getCodeEditorHelper().delegateVerticalScrollbarMouseDown(browserEvent);
        };
        CodeEditorWidget.prototype.saveViewState = function () {
            if (!this.cursor || !this.hasView) {
                return null;
            }
            var contributionsState = {};
            for (var id in this.contributions) {
                var contribution = this.contributions[id];
                if (typeof contribution.saveViewState === 'function') {
                    contributionsState[id] = contribution.saveViewState();
                }
            }
            var cursorState = this.cursor.saveState();
            var viewState = this._view.saveState();
            return {
                cursorState: cursorState,
                viewState: viewState,
                contributionsState: contributionsState
            };
        };
        CodeEditorWidget.prototype.restoreViewState = function (state) {
            if (!this.cursor || !this.hasView) {
                return;
            }
            var s = state;
            if (s && s.cursorState && s.viewState) {
                var codeEditorState = s;
                var cursorState = codeEditorState.cursorState;
                if (Array.isArray(cursorState)) {
                    this.cursor.restoreState(cursorState);
                }
                else {
                    // Backwards compatibility
                    this.cursor.restoreState([cursorState]);
                }
                this._view.restoreState(codeEditorState.viewState);
                var contributionsState = s.contributionsState || {};
                for (var id in this.contributions) {
                    var contribution = this.contributions[id];
                    if (typeof contribution.restoreViewState === 'function') {
                        contribution.restoreViewState(contributionsState[id]);
                    }
                }
            }
        };
        CodeEditorWidget.prototype.layout = function (dimension) {
            this._configuration.observeReferenceElement(dimension);
            this.render();
        };
        CodeEditorWidget.prototype.focus = function () {
            if (!this.hasView) {
                return;
            }
            this._view.focus();
        };
        CodeEditorWidget.prototype.beginForcedWidgetFocus = function () {
            this._focusTracker.beginForcedFocus();
        };
        CodeEditorWidget.prototype.endForcedWidgetFocus = function () {
            this._focusTracker.endForcedFocus();
        };
        CodeEditorWidget.prototype.isFocused = function () {
            return this.hasView && this._view.isFocused();
        };
        CodeEditorWidget.prototype.hasWidgetFocus = function () {
            return this._focusTracker.hasFocus();
        };
        CodeEditorWidget.prototype.addContentWidget = function (widget) {
            var widgetData = {
                widget: widget,
                position: widget.getPosition()
            };
            if (this.contentWidgets.hasOwnProperty(widget.getId())) {
                console.warn('Overwriting a content widget with the same id.');
            }
            this.contentWidgets[widget.getId()] = widgetData;
            if (this.hasView) {
                this._view.addContentWidget(widgetData);
            }
        };
        CodeEditorWidget.prototype.layoutContentWidget = function (widget) {
            var widgetId = widget.getId();
            if (this.contentWidgets.hasOwnProperty(widgetId)) {
                var widgetData = this.contentWidgets[widgetId];
                widgetData.position = widget.getPosition();
                if (this.hasView) {
                    this._view.layoutContentWidget(widgetData);
                }
            }
        };
        CodeEditorWidget.prototype.removeContentWidget = function (widget) {
            var widgetId = widget.getId();
            if (this.contentWidgets.hasOwnProperty(widgetId)) {
                var widgetData = this.contentWidgets[widgetId];
                delete this.contentWidgets[widgetId];
                if (this.hasView) {
                    this._view.removeContentWidget(widgetData);
                }
            }
        };
        CodeEditorWidget.prototype.addOverlayWidget = function (widget) {
            var widgetData = {
                widget: widget,
                position: widget.getPosition()
            };
            if (this.overlayWidgets.hasOwnProperty(widget.getId())) {
                console.warn('Overwriting an overlay widget with the same id.');
            }
            this.overlayWidgets[widget.getId()] = widgetData;
            if (this.hasView) {
                this._view.addOverlayWidget(widgetData);
            }
        };
        CodeEditorWidget.prototype.layoutOverlayWidget = function (widget) {
            var widgetId = widget.getId();
            if (this.overlayWidgets.hasOwnProperty(widgetId)) {
                var widgetData = this.overlayWidgets[widgetId];
                widgetData.position = widget.getPosition();
                if (this.hasView) {
                    this._view.layoutOverlayWidget(widgetData);
                }
            }
        };
        CodeEditorWidget.prototype.removeOverlayWidget = function (widget) {
            var widgetId = widget.getId();
            if (this.overlayWidgets.hasOwnProperty(widgetId)) {
                var widgetData = this.overlayWidgets[widgetId];
                delete this.overlayWidgets[widgetId];
                if (this.hasView) {
                    this._view.removeOverlayWidget(widgetData);
                }
            }
        };
        CodeEditorWidget.prototype.changeViewZones = function (callback) {
            if (!this.hasView) {
                //			console.warn('Cannot change view zones on editor that is not attached to a model, since there is no view.');
                return;
            }
            var hasChanges = this._view.change(callback);
            if (hasChanges) {
                this.emit(editorCommon.EventType.ViewZonesChanged);
            }
        };
        CodeEditorWidget.prototype.getWhitespaces = function () {
            if (!this.hasView) {
                return [];
            }
            return this._view.getWhitespaces();
        };
        CodeEditorWidget.prototype.getTopForLineNumber = function (lineNumber) {
            if (!this.hasView) {
                return -1;
            }
            return this._view.getCodeEditorHelper().getVerticalOffsetForPosition(lineNumber, 1);
        };
        CodeEditorWidget.prototype.getTopForPosition = function (lineNumber, column) {
            if (!this.hasView) {
                return -1;
            }
            return this._view.getCodeEditorHelper().getVerticalOffsetForPosition(lineNumber, column);
        };
        CodeEditorWidget.prototype.getScrolledVisiblePosition = function (rawPosition) {
            if (!this.hasView) {
                return null;
            }
            var position = this.model.validatePosition(rawPosition);
            var helper = this._view.getCodeEditorHelper();
            var layoutInfo = this._configuration.editor.layoutInfo;
            var top = helper.getVerticalOffsetForPosition(position.lineNumber, position.column) - helper.getScrollTop();
            var left = helper.getOffsetForColumn(position.lineNumber, position.column) + layoutInfo.glyphMarginWidth + layoutInfo.lineNumbersWidth + layoutInfo.decorationsWidth - helper.getScrollLeft();
            return {
                top: top,
                left: left,
                height: this._configuration.editor.lineHeight
            };
        };
        CodeEditorWidget.prototype.getOffsetForColumn = function (lineNumber, column) {
            if (!this.hasView) {
                return -1;
            }
            return this._view.getCodeEditorHelper().getOffsetForColumn(lineNumber, column);
        };
        CodeEditorWidget.prototype.render = function () {
            if (!this.hasView) {
                return;
            }
            this._view.render(true, false);
        };
        CodeEditorWidget.prototype.setHiddenAreas = function (ranges) {
            if (this.viewModel) {
                this.viewModel.setHiddenAreas(ranges);
            }
        };
        CodeEditorWidget.prototype.setAriaActiveDescendant = function (id) {
            if (!this.hasView) {
                return;
            }
            this._view.setAriaActiveDescendant(id);
        };
        CodeEditorWidget.prototype.applyFontInfo = function (target) {
            configuration_1.Configuration.applyFontInfoSlow(target, this._configuration.editor.fontInfo);
        };
        CodeEditorWidget.prototype._attachModel = function (model) {
            var _this = this;
            this._view = null;
            _super.prototype._attachModel.call(this, model);
            if (this._view) {
                this.domElement.appendChild(this._view.domNode);
                this._view.renderOnce(function () {
                    var keys = Object.keys(_this.contentWidgets);
                    for (var i = 0, len = keys.length; i < len; i++) {
                        var widgetId = keys[i];
                        _this._view.addContentWidget(_this.contentWidgets[widgetId]);
                    }
                    keys = Object.keys(_this.overlayWidgets);
                    for (var i = 0, len = keys.length; i < len; i++) {
                        var widgetId = keys[i];
                        _this._view.addOverlayWidget(_this.overlayWidgets[widgetId]);
                    }
                    _this._view.render(false, true);
                    _this.hasView = true;
                });
            }
        };
        CodeEditorWidget.prototype._enableEmptySelectionClipboard = function () {
            return browser.enableEmptySelectionClipboard;
        };
        CodeEditorWidget.prototype._createView = function () {
            var _this = this;
            this._view = new viewImpl_1.View(this._keybindingService, this._configuration, this.viewModel, function (source, handlerId, payload) {
                if (!_this.cursor) {
                    return;
                }
                _this.cursor.trigger(source, handlerId, payload);
            });
        };
        CodeEditorWidget.prototype._getViewInternalEventBus = function () {
            return this._view.getInternalEventBus();
        };
        CodeEditorWidget.prototype._detachModel = function () {
            var removeDomNode = null;
            if (this._view) {
                this._view.dispose();
                removeDomNode = this._view.domNode;
                this._view = null;
            }
            var result = _super.prototype._detachModel.call(this);
            if (removeDomNode) {
                this.domElement.removeChild(removeDomNode);
            }
            return result;
        };
        CodeEditorWidget = __decorate([
            __param(2, instantiation_1.IInstantiationService),
            __param(3, codeEditorService_1.ICodeEditorService),
            __param(4, keybindingService_1.IKeybindingService),
            __param(5, telemetry_1.ITelemetryService)
        ], CodeEditorWidget);
        return CodeEditorWidget;
    }(commonCodeEditor_1.CommonCodeEditor));
    exports.CodeEditorWidget = CodeEditorWidget;
    var CodeEditorWidgetFocusTracker = (function (_super) {
        __extends(CodeEditorWidgetFocusTracker, _super);
        function CodeEditorWidgetFocusTracker(domElement) {
            var _this = this;
            _super.call(this);
            this._onChange = this._register(new event_1.Emitter());
            this.onChage = this._onChange.event;
            this._focusTrackerHasFocus = false;
            this._forcedWidgetFocusCount = 0;
            this._actualHasFocus = false;
            this._focusTracker = this._register(dom.trackFocus(domElement));
            this._focusTracker.addFocusListener(function () {
                _this._focusTrackerHasFocus = true;
                _this._update();
            });
            this._focusTracker.addBlurListener(function () {
                _this._focusTrackerHasFocus = false;
                _this._update();
            });
        }
        CodeEditorWidgetFocusTracker.prototype.hasFocus = function () {
            return this._actualHasFocus;
        };
        CodeEditorWidgetFocusTracker.prototype.beginForcedFocus = function () {
            this._forcedWidgetFocusCount++;
            this._update();
        };
        CodeEditorWidgetFocusTracker.prototype.endForcedFocus = function () {
            this._forcedWidgetFocusCount--;
            this._update();
        };
        CodeEditorWidgetFocusTracker.prototype._update = function () {
            var newActualHasFocus = this._focusTrackerHasFocus;
            if (this._forcedWidgetFocusCount > 0) {
                newActualHasFocus = true;
            }
            if (this._actualHasFocus === newActualHasFocus) {
                // no change
                return;
            }
            this._actualHasFocus = newActualHasFocus;
            this._onChange.fire(void 0);
        };
        return CodeEditorWidgetFocusTracker;
    }(lifecycle_1.Disposable));
    var OverlayWidget2 = (function () {
        function OverlayWidget2(id, position) {
            this._id = id;
            this._position = position;
            this._domNode = document.createElement('div');
            this._domNode.className = this._id.replace(/\./g, '-').replace(/[^a-z0-9\-]/, '');
        }
        OverlayWidget2.prototype.getId = function () {
            return this._id;
        };
        OverlayWidget2.prototype.getDomNode = function () {
            return this._domNode;
        };
        OverlayWidget2.prototype.getPosition = function () {
            return this._position;
        };
        return OverlayWidget2;
    }());
    (function (EditCursorState) {
        EditCursorState[EditCursorState["EndOfLastEditOperation"] = 0] = "EndOfLastEditOperation";
    })(exports.EditCursorState || (exports.EditCursorState = {}));
    var EditCursorState = exports.EditCursorState;
    var SingleEditOperation = (function () {
        function SingleEditOperation(source) {
            this.range = new range_1.Range(source.range.startLineNumber, source.range.startColumn, source.range.endLineNumber, source.range.endColumn);
            this.text = source.text;
            this.forceMoveMarkers = source.forceMoveMarkers || false;
        }
        return SingleEditOperation;
    }());
    var CommandRunner = (function () {
        function CommandRunner(ops, editCursorState) {
            this._ops = ops.map(function (op) { return new SingleEditOperation(op); });
            this._editCursorState = editCursorState;
        }
        CommandRunner.prototype.getEditOperations = function (model, builder) {
            if (this._ops.length === 0) {
                return;
            }
            // Sort them in ascending order by range starts
            this._ops.sort(function (o1, o2) {
                return range_1.Range.compareRangesUsingStarts(o1.range, o2.range);
            });
            // Merge operations that touch each other
            var resultOps = [];
            var previousOp = this._ops[0];
            for (var i = 1; i < this._ops.length; i++) {
                if (previousOp.range.endLineNumber === this._ops[i].range.startLineNumber && previousOp.range.endColumn === this._ops[i].range.startColumn) {
                    // These operations are one after another and can be merged
                    previousOp.range = range_1.Range.plusRange(previousOp.range, this._ops[i].range);
                    previousOp.text = previousOp.text + this._ops[i].text;
                }
                else {
                    resultOps.push(previousOp);
                    previousOp = this._ops[i];
                }
            }
            resultOps.push(previousOp);
            for (var i = 0; i < resultOps.length; i++) {
                builder.addEditOperation(range_1.Range.lift(resultOps[i].range), resultOps[i].text);
            }
        };
        CommandRunner.prototype.computeCursorState = function (model, helper) {
            var inverseEditOperations = helper.getInverseEditOperations();
            var srcRange = inverseEditOperations[inverseEditOperations.length - 1].range;
            return new selection_1.Selection(srcRange.endLineNumber, srcRange.endColumn, srcRange.endLineNumber, srcRange.endColumn);
        };
        return CommandRunner;
    }());
    exports.CommandRunner = CommandRunner;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[174], __M([0,1,14,23,3,31,11,27,123,15,55,4,7,52,172,103,94,64,66,116,197]), function (require, exports, async_1, eventEmitter_1, lifecycle_1, objects, dom, styleMutator_1, sash_1, instantiation_1, defaultConfig_1, range_1, editorCommon, editorWorkerService_1, viewLineParts_1, viewLineRenderer_1, codeEditorWidget_1, viewLineToken_1, configuration_1, viewModel_1) {
    'use strict';
    var VisualEditorState = (function () {
        function VisualEditorState() {
            this._zones = [];
            this._zonesMap = {};
            this._decorations = [];
        }
        VisualEditorState.prototype.getForeignViewZones = function (allViewZones) {
            var _this = this;
            return allViewZones.filter(function (z) { return !_this._zonesMap[String(z.id)]; });
        };
        VisualEditorState.prototype.clean = function (editor) {
            var _this = this;
            // (1) View zones
            if (this._zones.length > 0) {
                editor.changeViewZones(function (viewChangeAccessor) {
                    for (var i = 0, length = _this._zones.length; i < length; i++) {
                        viewChangeAccessor.removeZone(_this._zones[i]);
                    }
                });
            }
            this._zones = [];
            this._zonesMap = {};
            // (2) Model decorations
            if (this._decorations.length > 0) {
                editor.changeDecorations(function (changeAccessor) {
                    changeAccessor.deltaDecorations(_this._decorations, []);
                });
            }
            this._decorations = [];
        };
        VisualEditorState.prototype.apply = function (editor, overviewRuler, newDecorations) {
            var _this = this;
            var i, length;
            // view zones
            editor.changeViewZones(function (viewChangeAccessor) {
                for (i = 0, length = _this._zones.length; i < length; i++) {
                    viewChangeAccessor.removeZone(_this._zones[i]);
                }
                _this._zones = [];
                _this._zonesMap = {};
                for (i = 0, length = newDecorations.zones.length; i < length; i++) {
                    newDecorations.zones[i].suppressMouseDown = true;
                    var zoneId = viewChangeAccessor.addZone(newDecorations.zones[i]);
                    _this._zones.push(zoneId);
                    _this._zonesMap[String(zoneId)] = true;
                }
            });
            // decorations
            this._decorations = editor.deltaDecorations(this._decorations, newDecorations.decorations);
            // overview ruler
            overviewRuler.setZones(newDecorations.overviewZones);
        };
        return VisualEditorState;
    }());
    var DIFF_EDITOR_ID = 0;
    var DiffEditorWidget = (function (_super) {
        __extends(DiffEditorWidget, _super);
        function DiffEditorWidget(domElement, options, editorWorkerService, instantiationService) {
            var _this = this;
            _super.call(this);
            this._editorWorkerService = editorWorkerService;
            this.id = (++DIFF_EDITOR_ID);
            this._domElement = domElement;
            options = options || {};
            this._theme = options.theme || defaultConfig_1.DefaultConfig.editor.theme;
            // renderSideBySide
            this._renderSideBySide = true;
            if (typeof options.renderSideBySide !== 'undefined') {
                this._renderSideBySide = options.renderSideBySide;
            }
            // ignoreTrimWhitespace
            this._ignoreTrimWhitespace = true;
            if (typeof options.ignoreTrimWhitespace !== 'undefined') {
                this._ignoreTrimWhitespace = options.ignoreTrimWhitespace;
            }
            this._originalIsEditable = false;
            if (typeof options.originalEditable !== 'undefined') {
                this._originalIsEditable = Boolean(options.originalEditable);
            }
            this._updateDecorationsRunner = new async_1.RunOnceScheduler(function () { return _this._updateDecorations(); }, 0);
            this._toDispose = [];
            this._toDispose.push(this._updateDecorationsRunner);
            this._containerDomElement = document.createElement('div');
            this._containerDomElement.className = DiffEditorWidget._getClassName(this._theme, this._renderSideBySide);
            this._containerDomElement.style.position = 'relative';
            this._containerDomElement.style.height = '100%';
            this._domElement.appendChild(this._containerDomElement);
            this._overviewViewportDomElement = document.createElement('div');
            this._overviewViewportDomElement.className = 'diffViewport';
            this._overviewViewportDomElement.style.position = 'absolute';
            this._overviewDomElement = document.createElement('div');
            this._overviewDomElement.className = 'diffOverview';
            this._overviewDomElement.style.position = 'absolute';
            this._overviewDomElement.style.height = '100%';
            this._overviewDomElement.appendChild(this._overviewViewportDomElement);
            this._toDispose.push(dom.addDisposableListener(this._overviewDomElement, 'mousedown', function (e) {
                _this.modifiedEditor.delegateVerticalScrollbarMouseDown(e);
            }));
            this._containerDomElement.appendChild(this._overviewDomElement);
            this._createLeftHandSide();
            this._createRightHandSide();
            this._beginUpdateDecorationsTimeout = -1;
            this._currentlyChangingViewZones = false;
            this._diffComputationToken = 0;
            this._originalEditorState = new VisualEditorState();
            this._modifiedEditorState = new VisualEditorState();
            this._isVisible = true;
            this._isHandlingScrollEvent = false;
            this._width = 0;
            this._height = 0;
            this._lineChanges = null;
            this._createLeftHandSideEditor(options, instantiationService);
            this._createRightHandSideEditor(options, instantiationService);
            if (options.automaticLayout) {
                this._measureDomElementToken = window.setInterval(function () { return _this._measureDomElement(false); }, 100);
            }
            // enableSplitViewResizing
            this._enableSplitViewResizing = true;
            if (typeof options.enableSplitViewResizing !== 'undefined') {
                this._enableSplitViewResizing = options.enableSplitViewResizing;
            }
            if (this._renderSideBySide) {
                this._setStrategy(new DiffEdtorWidgetSideBySide(this._createDataSource(), this._enableSplitViewResizing));
            }
            else {
                this._setStrategy(new DiffEdtorWidgetInline(this._createDataSource(), this._enableSplitViewResizing));
            }
        }
        DiffEditorWidget.prototype.onDidChangeModelRawContent = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelRawContentChanged, listener);
        };
        DiffEditorWidget.prototype.onDidChangeModelContent = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelContentChanged2, listener);
        };
        DiffEditorWidget.prototype.onDidChangeModelMode = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelModeChanged, listener);
        };
        DiffEditorWidget.prototype.onDidChangeModelOptions = function (listener) {
            return this.addListener2(editorCommon.EventType.ModelOptionsChanged, listener);
        };
        DiffEditorWidget.prototype.onDidChangeConfiguration = function (listener) {
            return this.addListener2(editorCommon.EventType.ConfigurationChanged, listener);
        };
        DiffEditorWidget.prototype.onDidChangeCursorPosition = function (listener) {
            return this.addListener2(editorCommon.EventType.CursorPositionChanged, listener);
        };
        DiffEditorWidget.prototype.onDidChangeCursorSelection = function (listener) {
            return this.addListener2(editorCommon.EventType.CursorSelectionChanged, listener);
        };
        DiffEditorWidget.prototype.onDidDispose = function (listener) {
            return this.addListener2(editorCommon.EventType.Disposed, listener);
        };
        DiffEditorWidget.prototype.onDidUpdateDiff = function (listener) {
            return this.addListener2(editorCommon.EventType.DiffUpdated, listener);
        };
        Object.defineProperty(DiffEditorWidget.prototype, "ignoreTrimWhitespace", {
            get: function () {
                return this._ignoreTrimWhitespace;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DiffEditorWidget.prototype, "renderSideBySide", {
            get: function () {
                return this._renderSideBySide;
            },
            enumerable: true,
            configurable: true
        });
        DiffEditorWidget._getClassName = function (theme, renderSideBySide) {
            var result = 'monaco-diff-editor monaco-editor-background ';
            if (renderSideBySide) {
                result += 'side-by-side ';
            }
            result += theme;
            return result;
        };
        DiffEditorWidget.prototype._recreateOverviewRulers = function () {
            if (this._originalOverviewRuler) {
                this._overviewDomElement.removeChild(this._originalOverviewRuler.getDomNode());
                this._originalOverviewRuler.dispose();
            }
            this._originalOverviewRuler = this.originalEditor.getView().createOverviewRuler('original diffOverviewRuler', 4, Number.MAX_VALUE);
            this._overviewDomElement.appendChild(this._originalOverviewRuler.getDomNode());
            if (this._modifiedOverviewRuler) {
                this._overviewDomElement.removeChild(this._modifiedOverviewRuler.getDomNode());
                this._modifiedOverviewRuler.dispose();
            }
            this._modifiedOverviewRuler = this.modifiedEditor.getView().createOverviewRuler('modified diffOverviewRuler', 4, Number.MAX_VALUE);
            this._overviewDomElement.appendChild(this._modifiedOverviewRuler.getDomNode());
            this._layoutOverviewRulers();
        };
        DiffEditorWidget.prototype._createLeftHandSide = function () {
            this._originalDomNode = document.createElement('div');
            this._originalDomNode.className = 'editor original';
            this._originalDomNode.style.position = 'absolute';
            this._originalDomNode.style.height = '100%';
            this._containerDomElement.appendChild(this._originalDomNode);
        };
        DiffEditorWidget.prototype._createRightHandSide = function () {
            this._modifiedDomNode = document.createElement('div');
            this._modifiedDomNode.className = 'editor modified';
            this._modifiedDomNode.style.position = 'absolute';
            this._modifiedDomNode.style.height = '100%';
            this._containerDomElement.appendChild(this._modifiedDomNode);
        };
        DiffEditorWidget.prototype._createLeftHandSideEditor = function (options, instantiationService) {
            var _this = this;
            this.originalEditor = instantiationService.createInstance(codeEditorWidget_1.CodeEditorWidget, this._originalDomNode, this._adjustOptionsForLeftHandSide(options, this._originalIsEditable));
            this._toDispose.push(this.originalEditor.addBulkListener2(function (events) { return _this._onOriginalEditorEvents(events); }));
            this._toDispose.push(this.addEmitter2(this.originalEditor));
        };
        DiffEditorWidget.prototype._createRightHandSideEditor = function (options, instantiationService) {
            var _this = this;
            this.modifiedEditor = instantiationService.createInstance(codeEditorWidget_1.CodeEditorWidget, this._modifiedDomNode, this._adjustOptionsForRightHandSide(options));
            this._toDispose.push(this.modifiedEditor.addBulkListener2(function (events) { return _this._onModifiedEditorEvents(events); }));
            this._toDispose.push(this.addEmitter2(this.modifiedEditor));
        };
        DiffEditorWidget.prototype.destroy = function () {
            this.dispose();
        };
        DiffEditorWidget.prototype.dispose = function () {
            this._toDispose = lifecycle_1.dispose(this._toDispose);
            window.clearInterval(this._measureDomElementToken);
            this._cleanViewZonesAndDecorations();
            this._originalOverviewRuler.dispose();
            this._modifiedOverviewRuler.dispose();
            this.originalEditor.destroy();
            this.modifiedEditor.destroy();
            this._strategy.dispose();
            this.emit(editorCommon.EventType.Disposed);
            _super.prototype.dispose.call(this);
        };
        //------------ begin IDiffEditor methods
        DiffEditorWidget.prototype.getId = function () {
            return this.getEditorType() + ':' + this.id;
        };
        DiffEditorWidget.prototype.getEditorType = function () {
            return editorCommon.EditorType.IDiffEditor;
        };
        DiffEditorWidget.prototype.getLineChanges = function () {
            return this._lineChanges;
        };
        DiffEditorWidget.prototype.getOriginalEditor = function () {
            return this.originalEditor;
        };
        DiffEditorWidget.prototype.getModifiedEditor = function () {
            return this.modifiedEditor;
        };
        DiffEditorWidget.prototype.updateOptions = function (newOptions) {
            // Handle new theme
            this._theme = newOptions && newOptions.theme ? newOptions.theme : this._theme;
            // Handle side by side
            var renderSideBySideChanged = false;
            if (typeof newOptions.renderSideBySide !== 'undefined') {
                if (this._renderSideBySide !== newOptions.renderSideBySide) {
                    this._renderSideBySide = newOptions.renderSideBySide;
                    renderSideBySideChanged = true;
                }
            }
            if (typeof newOptions.ignoreTrimWhitespace !== 'undefined') {
                if (this._ignoreTrimWhitespace !== newOptions.ignoreTrimWhitespace) {
                    this._ignoreTrimWhitespace = newOptions.ignoreTrimWhitespace;
                    // Begin comparing
                    this._beginUpdateDecorations();
                }
            }
            if (typeof newOptions.originalEditable !== 'undefined') {
                this._originalIsEditable = Boolean(newOptions.originalEditable);
            }
            // Update class name
            this._containerDomElement.className = DiffEditorWidget._getClassName(this._theme, this._renderSideBySide);
            this.modifiedEditor.updateOptions(this._adjustOptionsForRightHandSide(newOptions));
            this.originalEditor.updateOptions(this._adjustOptionsForLeftHandSide(newOptions, this._originalIsEditable));
            // enableSplitViewResizing
            if (typeof newOptions.enableSplitViewResizing !== 'undefined') {
                this._enableSplitViewResizing = newOptions.enableSplitViewResizing;
            }
            this._strategy.setEnableSplitViewResizing(this._enableSplitViewResizing);
            // renderSideBySide
            if (renderSideBySideChanged) {
                if (this._renderSideBySide) {
                    this._setStrategy(new DiffEdtorWidgetSideBySide(this._createDataSource(), this._enableSplitViewResizing));
                }
                else {
                    this._setStrategy(new DiffEdtorWidgetInline(this._createDataSource(), this._enableSplitViewResizing));
                }
            }
        };
        DiffEditorWidget.prototype.getValue = function (options) {
            if (options === void 0) { options = null; }
            return this.modifiedEditor.getValue(options);
        };
        DiffEditorWidget.prototype.getModel = function () {
            return {
                original: this.originalEditor.getModel(),
                modified: this.modifiedEditor.getModel()
            };
        };
        DiffEditorWidget.prototype.setModel = function (model) {
            // Guard us against partial null model
            if (model && (!model.original || !model.modified)) {
                throw new Error(!model.original ? 'DiffEditorWidget.setModel: Original model is null' : 'DiffEditorWidget.setModel: Modified model is null');
            }
            // Remove all view zones & decorations
            this._cleanViewZonesAndDecorations();
            // Update code editor models
            this.originalEditor.setModel(model ? model.original : null);
            this.modifiedEditor.setModel(model ? model.modified : null);
            this._updateDecorationsRunner.cancel();
            if (model) {
                this.originalEditor.setScrollTop(0);
                this.modifiedEditor.setScrollTop(0);
            }
            // Disable any diff computations that will come in
            this._lineChanges = null;
            this._diffComputationToken++;
            if (model) {
                this._recreateOverviewRulers();
                // Begin comparing
                this._beginUpdateDecorations();
            }
            else {
                this._lineChanges = null;
            }
            this._layoutOverviewViewport();
        };
        DiffEditorWidget.prototype.getDomNode = function () {
            return this._domElement;
        };
        DiffEditorWidget.prototype.getVisibleColumnFromPosition = function (position) {
            return this.modifiedEditor.getVisibleColumnFromPosition(position);
        };
        DiffEditorWidget.prototype.getPosition = function () {
            return this.modifiedEditor.getPosition();
        };
        DiffEditorWidget.prototype.setPosition = function (position, reveal, revealVerticalInCenter, revealHorizontal) {
            this.modifiedEditor.setPosition(position, reveal, revealVerticalInCenter, revealHorizontal);
        };
        DiffEditorWidget.prototype.revealLine = function (lineNumber) {
            this.modifiedEditor.revealLine(lineNumber);
        };
        DiffEditorWidget.prototype.revealLineInCenter = function (lineNumber) {
            this.modifiedEditor.revealLineInCenter(lineNumber);
        };
        DiffEditorWidget.prototype.revealLineInCenterIfOutsideViewport = function (lineNumber) {
            this.modifiedEditor.revealLineInCenterIfOutsideViewport(lineNumber);
        };
        DiffEditorWidget.prototype.revealPosition = function (position, revealVerticalInCenter, revealHorizontal) {
            if (revealVerticalInCenter === void 0) { revealVerticalInCenter = false; }
            if (revealHorizontal === void 0) { revealHorizontal = false; }
            this.modifiedEditor.revealPosition(position, revealVerticalInCenter, revealHorizontal);
        };
        DiffEditorWidget.prototype.revealPositionInCenter = function (position) {
            this.modifiedEditor.revealPositionInCenter(position);
        };
        DiffEditorWidget.prototype.revealPositionInCenterIfOutsideViewport = function (position) {
            this.modifiedEditor.revealPositionInCenterIfOutsideViewport(position);
        };
        DiffEditorWidget.prototype.getSelection = function () {
            return this.modifiedEditor.getSelection();
        };
        DiffEditorWidget.prototype.getSelections = function () {
            return this.modifiedEditor.getSelections();
        };
        DiffEditorWidget.prototype.setSelection = function (something, reveal, revealVerticalInCenter, revealHorizontal) {
            this.modifiedEditor.setSelection(something, reveal, revealVerticalInCenter, revealHorizontal);
        };
        DiffEditorWidget.prototype.setSelections = function (ranges) {
            this.modifiedEditor.setSelections(ranges);
        };
        DiffEditorWidget.prototype.revealLines = function (startLineNumber, endLineNumber) {
            this.modifiedEditor.revealLines(startLineNumber, endLineNumber);
        };
        DiffEditorWidget.prototype.revealLinesInCenter = function (startLineNumber, endLineNumber) {
            this.modifiedEditor.revealLinesInCenter(startLineNumber, endLineNumber);
        };
        DiffEditorWidget.prototype.revealLinesInCenterIfOutsideViewport = function (startLineNumber, endLineNumber) {
            this.modifiedEditor.revealLinesInCenterIfOutsideViewport(startLineNumber, endLineNumber);
        };
        DiffEditorWidget.prototype.revealRange = function (range, revealVerticalInCenter, revealHorizontal) {
            if (revealVerticalInCenter === void 0) { revealVerticalInCenter = false; }
            if (revealHorizontal === void 0) { revealHorizontal = true; }
            this.modifiedEditor.revealRange(range, revealVerticalInCenter, revealHorizontal);
        };
        DiffEditorWidget.prototype.revealRangeInCenter = function (range) {
            this.modifiedEditor.revealRangeInCenter(range);
        };
        DiffEditorWidget.prototype.revealRangeInCenterIfOutsideViewport = function (range) {
            this.modifiedEditor.revealRangeInCenterIfOutsideViewport(range);
        };
        DiffEditorWidget.prototype.addAction = function (descriptor) {
            this.modifiedEditor.addAction(descriptor);
        };
        DiffEditorWidget.prototype.getActions = function () {
            return this.modifiedEditor.getActions();
        };
        DiffEditorWidget.prototype.getAction = function (id) {
            return this.modifiedEditor.getAction(id);
        };
        DiffEditorWidget.prototype.saveViewState = function () {
            var originalViewState = this.originalEditor.saveViewState();
            var modifiedViewState = this.modifiedEditor.saveViewState();
            return {
                original: originalViewState,
                modified: modifiedViewState
            };
        };
        DiffEditorWidget.prototype.restoreViewState = function (state) {
            var s = state;
            if (s.original && s.original) {
                var diffEditorState = s;
                this.originalEditor.restoreViewState(diffEditorState.original);
                this.modifiedEditor.restoreViewState(diffEditorState.modified);
            }
        };
        DiffEditorWidget.prototype.layout = function (dimension) {
            this._measureDomElement(false, dimension);
        };
        DiffEditorWidget.prototype.focus = function () {
            this.modifiedEditor.focus();
        };
        DiffEditorWidget.prototype.isFocused = function () {
            return this.originalEditor.isFocused() || this.modifiedEditor.isFocused();
        };
        DiffEditorWidget.prototype.onVisible = function () {
            this._isVisible = true;
            this.originalEditor.onVisible();
            this.modifiedEditor.onVisible();
            // Begin comparing
            this._beginUpdateDecorations();
        };
        DiffEditorWidget.prototype.onHide = function () {
            this._isVisible = false;
            this.originalEditor.onHide();
            this.modifiedEditor.onHide();
            // Remove all view zones & decorations
            this._cleanViewZonesAndDecorations();
        };
        DiffEditorWidget.prototype.trigger = function (source, handlerId, payload) {
            this.modifiedEditor.trigger(source, handlerId, payload);
        };
        DiffEditorWidget.prototype.changeDecorations = function (callback) {
            return this.modifiedEditor.changeDecorations(callback);
        };
        //------------ end IDiffEditor methods
        //------------ begin layouting methods
        DiffEditorWidget.prototype._measureDomElement = function (forceDoLayoutCall, dimensions) {
            dimensions = dimensions || {
                width: this._containerDomElement.clientWidth,
                height: this._containerDomElement.clientHeight
            };
            if (dimensions.width <= 0) {
                this._width = 0;
                this._height = 0;
                return;
            }
            if (!forceDoLayoutCall && dimensions.width === this._width && dimensions.height === this._height) {
                // Nothing has changed
                return;
            }
            this._width = dimensions.width;
            this._height = dimensions.height;
            this._doLayout();
        };
        DiffEditorWidget.prototype._layoutOverviewRulers = function () {
            var freeSpace = DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * DiffEditorWidget.ONE_OVERVIEW_WIDTH;
            var layoutInfo = this.modifiedEditor.getLayoutInfo();
            if (layoutInfo) {
                this._originalOverviewRuler.setLayout(new editorCommon.OverviewRulerPosition({
                    top: 0,
                    width: DiffEditorWidget.ONE_OVERVIEW_WIDTH,
                    right: freeSpace + DiffEditorWidget.ONE_OVERVIEW_WIDTH,
                    height: this._height
                }));
                this._modifiedOverviewRuler.setLayout(new editorCommon.OverviewRulerPosition({
                    top: 0,
                    right: 0,
                    width: DiffEditorWidget.ONE_OVERVIEW_WIDTH,
                    height: this._height
                }));
            }
        };
        //------------ end layouting methods
        DiffEditorWidget.prototype._recomputeIfNecessary = function (events) {
            var _this = this;
            var changed = false;
            for (var i = 0; !changed && i < events.length; i++) {
                var type = events[i].getType();
                changed = changed || type === editorCommon.EventType.ModelRawContentChanged || type === editorCommon.EventType.ModelModeChanged;
            }
            if (changed && this._isVisible) {
                // Clear previous timeout if necessary
                if (this._beginUpdateDecorationsTimeout !== -1) {
                    window.clearTimeout(this._beginUpdateDecorationsTimeout);
                    this._beginUpdateDecorationsTimeout = -1;
                }
                this._beginUpdateDecorationsTimeout = window.setTimeout(function () { return _this._beginUpdateDecorations(); }, DiffEditorWidget.UPDATE_DIFF_DECORATIONS_DELAY);
            }
        };
        DiffEditorWidget.prototype._onOriginalEditorEvents = function (events) {
            for (var i = 0; i < events.length; i++) {
                var type = events[i].getType();
                var data = events[i].getData();
                if (type === 'scroll') {
                    this._onOriginalEditorScroll(data);
                }
                if (type === editorCommon.EventType.ViewZonesChanged) {
                    this._onViewZonesChanged();
                }
                if (type === editorCommon.EventType.ConfigurationChanged) {
                    var isViewportWrapping = this.originalEditor.getConfiguration().wrappingInfo.isViewportWrapping;
                    if (isViewportWrapping) {
                        // oh no, you didn't!
                        this.originalEditor.updateOptions({ wrappingColumn: -1 });
                    }
                }
            }
            this._recomputeIfNecessary(events);
        };
        DiffEditorWidget.prototype._onModifiedEditorEvents = function (events) {
            for (var i = 0; i < events.length; i++) {
                var type = events[i].getType();
                var data = events[i].getData();
                if (type === 'scroll') {
                    this._onModifiedEditorScroll(data);
                    this._layoutOverviewViewport();
                }
                if (type === 'viewLayoutChanged') {
                    this._layoutOverviewViewport();
                }
                if (type === editorCommon.EventType.ViewZonesChanged) {
                    this._onViewZonesChanged();
                }
                if (type === editorCommon.EventType.ConfigurationChanged) {
                    var isViewportWrapping = this.modifiedEditor.getConfiguration().wrappingInfo.isViewportWrapping;
                    if (isViewportWrapping) {
                        // oh no, you didn't!
                        this.modifiedEditor.updateOptions({ wrappingColumn: -1 });
                    }
                }
            }
            this._recomputeIfNecessary(events);
        };
        DiffEditorWidget.prototype._onViewZonesChanged = function () {
            if (this._currentlyChangingViewZones) {
                return;
            }
            this._updateDecorationsRunner.schedule();
        };
        DiffEditorWidget.prototype._beginUpdateDecorations = function () {
            var _this = this;
            this._beginUpdateDecorationsTimeout = -1;
            if (!this.modifiedEditor.getModel()) {
                return;
            }
            // Prevent old diff requests to come if a new request has been initiated
            // The best method would be to call cancel on the Promise, but this is not
            // yet supported, so using tokens for now.
            this._diffComputationToken++;
            var currentToken = this._diffComputationToken;
            var currentOriginalModel = this.originalEditor.getModel();
            var currentModifiedModel = this.modifiedEditor.getModel();
            this._editorWorkerService.computeDiff(currentOriginalModel.uri, currentModifiedModel.uri, this._ignoreTrimWhitespace).then(function (result) {
                if (currentToken === _this._diffComputationToken
                    && currentOriginalModel === _this.originalEditor.getModel()
                    && currentModifiedModel === _this.modifiedEditor.getModel()) {
                    _this._lineChanges = result;
                    _this._updateDecorationsRunner.schedule();
                    _this.emit(editorCommon.EventType.DiffUpdated, {});
                }
            }, function (error) {
                if (currentToken === _this._diffComputationToken
                    && currentOriginalModel === _this.originalEditor.getModel()
                    && currentModifiedModel === _this.modifiedEditor.getModel()) {
                    _this._lineChanges = null;
                    _this._updateDecorationsRunner.schedule();
                }
            });
        };
        DiffEditorWidget.prototype._cleanViewZonesAndDecorations = function () {
            this._originalEditorState.clean(this.originalEditor);
            this._modifiedEditorState.clean(this.modifiedEditor);
        };
        DiffEditorWidget.prototype._updateDecorations = function () {
            var lineChanges = this._lineChanges || [];
            var foreignOriginal = this._originalEditorState.getForeignViewZones(this.originalEditor.getWhitespaces());
            var foreignModified = this._modifiedEditorState.getForeignViewZones(this.modifiedEditor.getWhitespaces());
            var diffDecorations = this._strategy.getEditorsDiffDecorations(lineChanges, this._ignoreTrimWhitespace, foreignOriginal, foreignModified, this.originalEditor, this.modifiedEditor);
            try {
                this._currentlyChangingViewZones = true;
                this._originalEditorState.apply(this.originalEditor, this._originalOverviewRuler, diffDecorations.original);
                this._modifiedEditorState.apply(this.modifiedEditor, this._modifiedOverviewRuler, diffDecorations.modified);
            }
            finally {
                this._currentlyChangingViewZones = false;
            }
        };
        DiffEditorWidget.prototype._adjustOptionsForSubEditor = function (options) {
            var clonedOptions = objects.clone(options || {});
            clonedOptions.wrappingColumn = -1;
            clonedOptions.automaticLayout = false;
            clonedOptions.scrollbar = clonedOptions.scrollbar || {};
            clonedOptions.scrollbar.vertical = 'visible';
            clonedOptions.folding = false;
            clonedOptions.referenceInfos = false;
            return clonedOptions;
        };
        DiffEditorWidget.prototype._adjustOptionsForLeftHandSide = function (options, isEditable) {
            var result = this._adjustOptionsForSubEditor(options);
            result.readOnly = !isEditable;
            result.overviewRulerLanes = 1;
            result.theme = this._theme + ' original-in-monaco-diff-editor';
            return result;
        };
        DiffEditorWidget.prototype._adjustOptionsForRightHandSide = function (options) {
            var result = this._adjustOptionsForSubEditor(options);
            result.revealHorizontalRightPadding = defaultConfig_1.DefaultConfig.editor.revealHorizontalRightPadding + DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH;
            result.scrollbar.verticalHasArrows = false;
            result.theme = this._theme + ' modified-in-monaco-diff-editor';
            return result;
        };
        DiffEditorWidget.prototype._onOriginalEditorScroll = function (e) {
            if (!e.scrollTopChanged && !e.scrollLeftChanged) {
                return;
            }
            if (this._isHandlingScrollEvent) {
                return;
            }
            this._isHandlingScrollEvent = true;
            this.modifiedEditor.setScrollPosition({
                scrollLeft: e.scrollLeft,
                scrollTop: e.scrollTop
            });
            this._isHandlingScrollEvent = false;
        };
        DiffEditorWidget.prototype._onModifiedEditorScroll = function (e) {
            if (!e.scrollTopChanged && !e.scrollLeftChanged) {
                return;
            }
            if (this._isHandlingScrollEvent) {
                return;
            }
            this._isHandlingScrollEvent = true;
            this.originalEditor.setScrollPosition({
                scrollLeft: e.scrollLeft,
                scrollTop: e.scrollTop
            });
            this._isHandlingScrollEvent = false;
        };
        DiffEditorWidget.prototype._doLayout = function () {
            var splitPoint = this._strategy.layout();
            this._originalDomNode.style.width = splitPoint + 'px';
            this._originalDomNode.style.left = '0px';
            this._modifiedDomNode.style.width = (this._width - splitPoint) + 'px';
            this._modifiedDomNode.style.left = splitPoint + 'px';
            this._overviewDomElement.style.top = '0px';
            this._overviewDomElement.style.width = DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH + 'px';
            this._overviewDomElement.style.left = (this._width - DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH) + 'px';
            this._overviewViewportDomElement.style.width = DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH + 'px';
            this._overviewViewportDomElement.style.height = '30px';
            this.originalEditor.layout({ width: splitPoint, height: this._height });
            this.modifiedEditor.layout({ width: this._width - splitPoint - DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH, height: this._height });
            if (this._originalOverviewRuler || this._modifiedOverviewRuler) {
                this._layoutOverviewRulers();
            }
            this._layoutOverviewViewport();
        };
        DiffEditorWidget.prototype._layoutOverviewViewport = function () {
            var layout = this._computeOverviewViewport();
            if (!layout) {
                styleMutator_1.StyleMutator.setTop(this._overviewViewportDomElement, 0);
                styleMutator_1.StyleMutator.setHeight(this._overviewViewportDomElement, 0);
            }
            else {
                styleMutator_1.StyleMutator.setTop(this._overviewViewportDomElement, layout.top);
                styleMutator_1.StyleMutator.setHeight(this._overviewViewportDomElement, layout.height);
            }
        };
        DiffEditorWidget.prototype._computeOverviewViewport = function () {
            var layoutInfo = this.modifiedEditor.getLayoutInfo();
            if (!layoutInfo) {
                return null;
            }
            var scrollTop = this.modifiedEditor.getScrollTop();
            var scrollHeight = this.modifiedEditor.getScrollHeight();
            var computedAvailableSize = Math.max(0, layoutInfo.contentHeight);
            var computedRepresentableSize = Math.max(0, computedAvailableSize - 2 * 0);
            var computedRatio = scrollHeight > 0 ? (computedRepresentableSize / scrollHeight) : 0;
            var computedSliderSize = Math.max(1, Math.floor(layoutInfo.contentHeight * computedRatio));
            var computedSliderPosition = Math.floor(scrollTop * computedRatio);
            return {
                height: computedSliderSize,
                top: computedSliderPosition
            };
        };
        DiffEditorWidget.prototype._createDataSource = function () {
            var _this = this;
            return {
                getWidth: function () {
                    return _this._width;
                },
                getHeight: function () {
                    return _this._height;
                },
                getContainerDomNode: function () {
                    return _this._containerDomElement;
                },
                relayoutEditors: function () {
                    _this._doLayout();
                },
                getOriginalEditor: function () {
                    return _this.originalEditor;
                },
                getModifiedEditor: function () {
                    return _this.modifiedEditor;
                }
            };
        };
        DiffEditorWidget.prototype._setStrategy = function (newStrategy) {
            if (this._strategy) {
                this._strategy.dispose();
            }
            this._strategy = newStrategy;
            if (this._lineChanges) {
                this._updateDecorations();
            }
            // Just do a layout, the strategy might need it
            this._measureDomElement(true);
        };
        DiffEditorWidget.prototype._getLineChangeAtOrBeforeLineNumber = function (lineNumber, startLineNumberExtractor) {
            if (this._lineChanges.length === 0 || lineNumber < startLineNumberExtractor(this._lineChanges[0])) {
                // There are no changes or `lineNumber` is before the first change
                return null;
            }
            var min = 0, max = this._lineChanges.length - 1;
            while (min < max) {
                var mid = Math.floor((min + max) / 2);
                var midStart = startLineNumberExtractor(this._lineChanges[mid]);
                var midEnd = (mid + 1 <= max ? startLineNumberExtractor(this._lineChanges[mid + 1]) : Number.MAX_VALUE);
                if (lineNumber < midStart) {
                    max = mid - 1;
                }
                else if (lineNumber >= midEnd) {
                    min = mid + 1;
                }
                else {
                    // HIT!
                    min = mid;
                    max = mid;
                }
            }
            return this._lineChanges[min];
        };
        DiffEditorWidget.prototype._getEquivalentLineForOriginalLineNumber = function (lineNumber) {
            var lineChange = this._getLineChangeAtOrBeforeLineNumber(lineNumber, function (lineChange) { return lineChange.originalStartLineNumber; });
            if (!lineChange) {
                return lineNumber;
            }
            var originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);
            var modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);
            var lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? (lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1) : 0);
            var lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? (lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1) : 0);
            var delta = lineNumber - originalEquivalentLineNumber;
            if (delta <= lineChangeOriginalLength) {
                return modifiedEquivalentLineNumber + Math.min(delta, lineChangeModifiedLength);
            }
            return modifiedEquivalentLineNumber + lineChangeModifiedLength - lineChangeOriginalLength + delta;
        };
        DiffEditorWidget.prototype._getEquivalentLineForModifiedLineNumber = function (lineNumber) {
            var lineChange = this._getLineChangeAtOrBeforeLineNumber(lineNumber, function (lineChange) { return lineChange.modifiedStartLineNumber; });
            if (!lineChange) {
                return lineNumber;
            }
            var originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);
            var modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);
            var lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? (lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1) : 0);
            var lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? (lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1) : 0);
            var delta = lineNumber - modifiedEquivalentLineNumber;
            if (delta <= lineChangeModifiedLength) {
                return originalEquivalentLineNumber + Math.min(delta, lineChangeOriginalLength);
            }
            return originalEquivalentLineNumber + lineChangeOriginalLength - lineChangeModifiedLength + delta;
        };
        DiffEditorWidget.prototype.getDiffLineInformationForOriginal = function (lineNumber) {
            if (!this._lineChanges) {
                // Cannot answer that which I don't know
                return null;
            }
            return {
                equivalentLineNumber: this._getEquivalentLineForOriginalLineNumber(lineNumber)
            };
        };
        DiffEditorWidget.prototype.getDiffLineInformationForModified = function (lineNumber) {
            if (!this._lineChanges) {
                // Cannot answer that which I don't know
                return null;
            }
            return {
                equivalentLineNumber: this._getEquivalentLineForModifiedLineNumber(lineNumber)
            };
        };
        DiffEditorWidget.ONE_OVERVIEW_WIDTH = 15;
        DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH = 30;
        DiffEditorWidget.UPDATE_DIFF_DECORATIONS_DELAY = 200; // ms
        DiffEditorWidget = __decorate([
            __param(2, editorWorkerService_1.IEditorWorkerService),
            __param(3, instantiation_1.IInstantiationService)
        ], DiffEditorWidget);
        return DiffEditorWidget;
    }(eventEmitter_1.EventEmitter));
    exports.DiffEditorWidget = DiffEditorWidget;
    var DiffEditorWidgetStyle = (function () {
        function DiffEditorWidgetStyle(dataSource) {
            this._dataSource = dataSource;
        }
        DiffEditorWidgetStyle.prototype.getEditorsDiffDecorations = function (lineChanges, ignoreTrimWhitespace, originalWhitespaces, modifiedWhitespaces, originalEditor, modifiedEditor) {
            // Get view zones
            modifiedWhitespaces = modifiedWhitespaces.sort(function (a, b) {
                return a.afterLineNumber - b.afterLineNumber;
            });
            originalWhitespaces = originalWhitespaces.sort(function (a, b) {
                return a.afterLineNumber - b.afterLineNumber;
            });
            var zones = this._getViewZones(lineChanges, originalWhitespaces, modifiedWhitespaces, originalEditor, modifiedEditor);
            // Get decorations & overview ruler zones
            var originalDecorations = this._getOriginalEditorDecorations(lineChanges, ignoreTrimWhitespace, originalEditor, modifiedEditor);
            var modifiedDecorations = this._getModifiedEditorDecorations(lineChanges, ignoreTrimWhitespace, originalEditor, modifiedEditor);
            return {
                original: {
                    decorations: originalDecorations.decorations,
                    overviewZones: originalDecorations.overviewZones,
                    zones: zones.original
                },
                modified: {
                    decorations: modifiedDecorations.decorations,
                    overviewZones: modifiedDecorations.overviewZones,
                    zones: zones.modified
                }
            };
        };
        DiffEditorWidgetStyle.prototype._getViewZones = function (lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor) {
            return null;
        };
        DiffEditorWidgetStyle.prototype._getOriginalEditorDecorations = function (lineChanges, ignoreTrimWhitespace, originalEditor, modifiedEditor) {
            return null;
        };
        DiffEditorWidgetStyle.prototype._getModifiedEditorDecorations = function (lineChanges, ignoreTrimWhitespace, originalEditor, modifiedEditor) {
            return null;
        };
        return DiffEditorWidgetStyle;
    }());
    var ForeignViewZonesIterator = (function () {
        function ForeignViewZonesIterator(source) {
            this._source = source;
            this._index = -1;
            this.advance();
        }
        ForeignViewZonesIterator.prototype.advance = function () {
            this._index++;
            if (this._index < this._source.length) {
                this.current = this._source[this._index];
            }
            else {
                this.current = null;
            }
        };
        return ForeignViewZonesIterator;
    }());
    var ViewZonesComputer = (function () {
        function ViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ) {
            this.lineChanges = lineChanges;
            this.originalForeignVZ = originalForeignVZ;
            this.modifiedForeignVZ = modifiedForeignVZ;
        }
        ViewZonesComputer.prototype.getViewZones = function () {
            var result = {
                original: [],
                modified: []
            };
            var i, length, lineChange;
            var stepOriginal, stepModified, stepOriginalIndex, stepModifiedIndex, lineChangeModifiedLength = 0, lineChangeOriginalLength = 0, originalEquivalentLineNumber = 0, modifiedEquivalentLineNumber = 0, originalEndEquivalentLineNumber = 0, modifiedEndEquivalentLineNumber = 0, viewZoneLineNumber = 0;
            var sortMyViewZones = function (a, b) {
                return a.afterLineNumber - b.afterLineNumber;
            };
            var addAndCombineIfPossible = function (destination, item) {
                if (item.domNode === null && destination.length > 0) {
                    var lastItem = destination[destination.length - 1];
                    if (lastItem.afterLineNumber === item.afterLineNumber && lastItem.domNode === null) {
                        lastItem.heightInLines += item.heightInLines;
                        return;
                    }
                }
                destination.push(item);
            };
            var modifiedForeignVZ = new ForeignViewZonesIterator(this.modifiedForeignVZ);
            var originalForeignVZ = new ForeignViewZonesIterator(this.originalForeignVZ);
            // In order to include foreign view zones after the last line change, the for loop will iterate once more after the end of the `lineChanges` array
            for (i = 0, length = this.lineChanges.length; i <= length; i++) {
                lineChange = (i < length ? this.lineChanges[i] : null);
                if (lineChange !== null) {
                    originalEquivalentLineNumber = lineChange.originalStartLineNumber + (lineChange.originalEndLineNumber > 0 ? -1 : 0);
                    modifiedEquivalentLineNumber = lineChange.modifiedStartLineNumber + (lineChange.modifiedEndLineNumber > 0 ? -1 : 0);
                    lineChangeOriginalLength = (lineChange.originalEndLineNumber > 0 ? (lineChange.originalEndLineNumber - lineChange.originalStartLineNumber + 1) : 0);
                    lineChangeModifiedLength = (lineChange.modifiedEndLineNumber > 0 ? (lineChange.modifiedEndLineNumber - lineChange.modifiedStartLineNumber + 1) : 0);
                    originalEndEquivalentLineNumber = Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber);
                    modifiedEndEquivalentLineNumber = Math.max(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber);
                }
                else {
                    // Increase to very large value to get the producing tests of foreign view zones running
                    originalEquivalentLineNumber += 10000000 + lineChangeOriginalLength;
                    modifiedEquivalentLineNumber += 10000000 + lineChangeModifiedLength;
                    originalEndEquivalentLineNumber = originalEquivalentLineNumber;
                    modifiedEndEquivalentLineNumber = modifiedEquivalentLineNumber;
                }
                // Each step produces view zones, and after producing them, we try to cancel them out, to avoid empty-empty view zone cases
                stepOriginal = [];
                stepModified = [];
                // ---------------------------- PRODUCE VIEW ZONES
                // [PRODUCE] View zone(s) in original-side due to foreign view zone(s) in modified-side
                while (modifiedForeignVZ.current && modifiedForeignVZ.current.afterLineNumber <= modifiedEndEquivalentLineNumber) {
                    if (modifiedForeignVZ.current.afterLineNumber <= modifiedEquivalentLineNumber) {
                        viewZoneLineNumber = originalEquivalentLineNumber - modifiedEquivalentLineNumber + modifiedForeignVZ.current.afterLineNumber;
                    }
                    else {
                        viewZoneLineNumber = originalEndEquivalentLineNumber;
                    }
                    stepOriginal.push({
                        afterLineNumber: viewZoneLineNumber,
                        heightInLines: modifiedForeignVZ.current.heightInLines,
                        domNode: null
                    });
                    modifiedForeignVZ.advance();
                }
                // [PRODUCE] View zone(s) in modified-side due to foreign view zone(s) in original-side
                while (originalForeignVZ.current && originalForeignVZ.current.afterLineNumber <= originalEndEquivalentLineNumber) {
                    if (originalForeignVZ.current.afterLineNumber <= originalEquivalentLineNumber) {
                        viewZoneLineNumber = modifiedEquivalentLineNumber - originalEquivalentLineNumber + originalForeignVZ.current.afterLineNumber;
                    }
                    else {
                        viewZoneLineNumber = modifiedEndEquivalentLineNumber;
                    }
                    stepModified.push({
                        afterLineNumber: viewZoneLineNumber,
                        heightInLines: originalForeignVZ.current.heightInLines,
                        domNode: null
                    });
                    originalForeignVZ.advance();
                }
                if (lineChange !== null && isChangeOrInsert(lineChange)) {
                    var r = this._produceOriginalFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength);
                    if (r) {
                        stepOriginal.push(r);
                    }
                }
                if (lineChange !== null && isChangeOrDelete(lineChange)) {
                    var r = this._produceModifiedFromDiff(lineChange, lineChangeOriginalLength, lineChangeModifiedLength);
                    if (r) {
                        stepModified.push(r);
                    }
                }
                // ---------------------------- END PRODUCE VIEW ZONES
                // ---------------------------- EMIT MINIMAL VIEW ZONES
                // [CANCEL & EMIT] Try to cancel view zones out
                stepOriginalIndex = 0;
                stepModifiedIndex = 0;
                stepOriginal = stepOriginal.sort(sortMyViewZones);
                stepModified = stepModified.sort(sortMyViewZones);
                while (stepOriginalIndex < stepOriginal.length && stepModifiedIndex < stepModified.length) {
                    var original = stepOriginal[stepOriginalIndex];
                    var modified = stepModified[stepModifiedIndex];
                    var originalDelta = original.afterLineNumber - originalEquivalentLineNumber;
                    var modifiedDelta = modified.afterLineNumber - modifiedEquivalentLineNumber;
                    if (originalDelta < modifiedDelta) {
                        addAndCombineIfPossible(result.original, original);
                        stepOriginalIndex++;
                    }
                    else if (modifiedDelta < originalDelta) {
                        addAndCombineIfPossible(result.modified, modified);
                        stepModifiedIndex++;
                    }
                    else if (original.shouldNotShrink) {
                        addAndCombineIfPossible(result.original, original);
                        stepOriginalIndex++;
                    }
                    else if (modified.shouldNotShrink) {
                        addAndCombineIfPossible(result.modified, modified);
                        stepModifiedIndex++;
                    }
                    else {
                        if (original.heightInLines >= modified.heightInLines) {
                            // modified view zone gets removed
                            original.heightInLines -= modified.heightInLines;
                            stepModifiedIndex++;
                        }
                        else {
                            // original view zone gets removed
                            modified.heightInLines -= original.heightInLines;
                            stepOriginalIndex++;
                        }
                    }
                }
                // [EMIT] Remaining original view zones
                while (stepOriginalIndex < stepOriginal.length) {
                    addAndCombineIfPossible(result.original, stepOriginal[stepOriginalIndex]);
                    stepOriginalIndex++;
                }
                // [EMIT] Remaining modified view zones
                while (stepModifiedIndex < stepModified.length) {
                    addAndCombineIfPossible(result.modified, stepModified[stepModifiedIndex]);
                    stepModifiedIndex++;
                }
            }
            var ensureDomNode = function (z) {
                if (!z.domNode) {
                    z.domNode = createFakeLinesDiv();
                }
            };
            result.original.forEach(ensureDomNode);
            result.modified.forEach(ensureDomNode);
            return result;
        };
        return ViewZonesComputer;
    }());
    var DiffEdtorWidgetSideBySide = (function (_super) {
        __extends(DiffEdtorWidgetSideBySide, _super);
        function DiffEdtorWidgetSideBySide(dataSource, enableSplitViewResizing) {
            var _this = this;
            _super.call(this, dataSource);
            this._disableSash = (enableSplitViewResizing === false);
            this._sashRatio = null;
            this._sashPosition = null;
            this._sash = new sash_1.Sash(this._dataSource.getContainerDomNode(), this);
            if (this._disableSash) {
                this._sash.disable();
            }
            this._sash.addListener2('start', function () { return _this.onSashDragStart(); });
            this._sash.addListener2('change', function (e) { return _this.onSashDrag(e); });
            this._sash.addListener2('end', function () { return _this.onSashDragEnd(); });
            this._sash.addListener2('reset', function () { return _this.onSashReset(); });
        }
        DiffEdtorWidgetSideBySide.prototype.dispose = function () {
            this._sash.dispose();
        };
        DiffEdtorWidgetSideBySide.prototype.setEnableSplitViewResizing = function (enableSplitViewResizing) {
            var newDisableSash = (enableSplitViewResizing === false);
            if (this._disableSash !== newDisableSash) {
                this._disableSash = newDisableSash;
                if (this._disableSash) {
                    this._sash.disable();
                }
                else {
                    this._sash.enable();
                }
            }
        };
        DiffEdtorWidgetSideBySide.prototype.layout = function (sashRatio) {
            if (sashRatio === void 0) { sashRatio = this._sashRatio; }
            var w = this._dataSource.getWidth();
            var contentWidth = w - DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH;
            var sashPosition = Math.floor((sashRatio || 0.5) * contentWidth);
            var midPoint = Math.floor(0.5 * contentWidth);
            sashPosition = this._disableSash ? midPoint : sashPosition || midPoint;
            if (contentWidth > DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH * 2) {
                if (sashPosition < DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH) {
                    sashPosition = DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH;
                }
                if (sashPosition > contentWidth - DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH) {
                    sashPosition = contentWidth - DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH;
                }
            }
            else {
                sashPosition = midPoint;
            }
            if (this._sashPosition !== sashPosition) {
                this._sashPosition = sashPosition;
                this._sash.layout();
            }
            return this._sashPosition;
        };
        DiffEdtorWidgetSideBySide.prototype.onSashDragStart = function () {
            this._startSashPosition = this._sashPosition;
        };
        DiffEdtorWidgetSideBySide.prototype.onSashDrag = function (e) {
            var w = this._dataSource.getWidth();
            var contentWidth = w - DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH;
            var sashPosition = this.layout((this._startSashPosition + (e.currentX - e.startX)) / contentWidth);
            this._sashRatio = sashPosition / contentWidth;
            this._dataSource.relayoutEditors();
        };
        DiffEdtorWidgetSideBySide.prototype.onSashDragEnd = function () {
            this._sash.layout();
        };
        DiffEdtorWidgetSideBySide.prototype.onSashReset = function () {
            this._sashRatio = 0.5;
            this._dataSource.relayoutEditors();
            this._sash.layout();
        };
        DiffEdtorWidgetSideBySide.prototype.getVerticalSashTop = function (sash) {
            return 0;
        };
        DiffEdtorWidgetSideBySide.prototype.getVerticalSashLeft = function (sash) {
            return this._sashPosition;
        };
        DiffEdtorWidgetSideBySide.prototype.getVerticalSashHeight = function (sash) {
            return this._dataSource.getHeight();
        };
        DiffEdtorWidgetSideBySide.prototype._getViewZones = function (lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor) {
            var c = new SideBySideViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ);
            return c.getViewZones();
        };
        DiffEdtorWidgetSideBySide.prototype._getOriginalEditorDecorations = function (lineChanges, ignoreTrimWhitespace, originalEditor, modifiedEditor) {
            var result = {
                decorations: [],
                overviewZones: []
            }, i, length, j, lengthJ, lineChange, charChange, lineNumber, startColumn, endColumn, originalModel = originalEditor.getModel();
            for (i = 0, length = lineChanges.length; i < length; i++) {
                lineChange = lineChanges[i];
                if (isChangeOrDelete(lineChange)) {
                    result.decorations.push(createDecoration(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, Number.MAX_VALUE, 'line-delete', true));
                    if (!isChangeOrInsert(lineChange) || !lineChange.charChanges) {
                        result.decorations.push(createDecoration(lineChange.originalStartLineNumber, 1, lineChange.originalEndLineNumber, Number.MAX_VALUE, 'char-delete', true));
                    }
                    result.overviewZones.push(new editorCommon.OverviewRulerZone(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber, editorCommon.OverviewRulerLane.Full, 0, 'rgba(255, 0, 0, 0.4)', 'rgba(255, 0, 0, 0.4)'));
                    if (lineChange.charChanges) {
                        for (j = 0, lengthJ = lineChange.charChanges.length; j < lengthJ; j++) {
                            charChange = lineChange.charChanges[j];
                            if (isChangeOrDelete(charChange)) {
                                if (ignoreTrimWhitespace) {
                                    for (lineNumber = charChange.originalStartLineNumber; lineNumber <= charChange.originalEndLineNumber; lineNumber++) {
                                        if (lineNumber === charChange.originalStartLineNumber) {
                                            startColumn = charChange.originalStartColumn;
                                        }
                                        else {
                                            startColumn = originalModel.getLineFirstNonWhitespaceColumn(lineNumber);
                                        }
                                        if (lineNumber === charChange.originalEndLineNumber) {
                                            endColumn = charChange.originalEndColumn;
                                        }
                                        else {
                                            endColumn = originalModel.getLineLastNonWhitespaceColumn(lineNumber);
                                        }
                                        result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, 'char-delete', false));
                                    }
                                }
                                else {
                                    result.decorations.push(createDecoration(charChange.originalStartLineNumber, charChange.originalStartColumn, charChange.originalEndLineNumber, charChange.originalEndColumn, 'char-delete', false));
                                }
                            }
                        }
                    }
                }
            }
            return result;
        };
        DiffEdtorWidgetSideBySide.prototype._getModifiedEditorDecorations = function (lineChanges, ignoreTrimWhitespace, originalEditor, modifiedEditor) {
            var result = {
                decorations: [],
                overviewZones: []
            }, i, length, j, lengthJ, lineChange, charChange, lineNumber, startColumn, endColumn, modifiedModel = modifiedEditor.getModel();
            for (i = 0, length = lineChanges.length; i < length; i++) {
                lineChange = lineChanges[i];
                if (isChangeOrInsert(lineChange)) {
                    result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, Number.MAX_VALUE, 'line-insert', true));
                    if (!isChangeOrDelete(lineChange) || !lineChange.charChanges) {
                        result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, Number.MAX_VALUE, 'char-insert', true));
                    }
                    result.overviewZones.push(new editorCommon.OverviewRulerZone(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber, editorCommon.OverviewRulerLane.Full, 0, 'rgba(155, 185, 85, 0.4)', 'rgba(155, 185, 85, 0.4)'));
                    if (lineChange.charChanges) {
                        for (j = 0, lengthJ = lineChange.charChanges.length; j < lengthJ; j++) {
                            charChange = lineChange.charChanges[j];
                            if (isChangeOrInsert(charChange)) {
                                if (ignoreTrimWhitespace) {
                                    for (lineNumber = charChange.modifiedStartLineNumber; lineNumber <= charChange.modifiedEndLineNumber; lineNumber++) {
                                        if (lineNumber === charChange.modifiedStartLineNumber) {
                                            startColumn = charChange.modifiedStartColumn;
                                        }
                                        else {
                                            startColumn = modifiedModel.getLineFirstNonWhitespaceColumn(lineNumber);
                                        }
                                        if (lineNumber === charChange.modifiedEndLineNumber) {
                                            endColumn = charChange.modifiedEndColumn;
                                        }
                                        else {
                                            endColumn = modifiedModel.getLineLastNonWhitespaceColumn(lineNumber);
                                        }
                                        result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, 'char-insert', false));
                                    }
                                }
                                else {
                                    result.decorations.push(createDecoration(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn, 'char-insert', false));
                                }
                            }
                        }
                    }
                }
            }
            return result;
        };
        DiffEdtorWidgetSideBySide.MINIMUM_EDITOR_WIDTH = 100;
        return DiffEdtorWidgetSideBySide;
    }(DiffEditorWidgetStyle));
    var SideBySideViewZonesComputer = (function (_super) {
        __extends(SideBySideViewZonesComputer, _super);
        function SideBySideViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ) {
            _super.call(this, lineChanges, originalForeignVZ, modifiedForeignVZ);
        }
        SideBySideViewZonesComputer.prototype._produceOriginalFromDiff = function (lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
            if (lineChangeModifiedLength > lineChangeOriginalLength) {
                return {
                    afterLineNumber: Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber),
                    heightInLines: (lineChangeModifiedLength - lineChangeOriginalLength),
                    domNode: null
                };
            }
            return null;
        };
        SideBySideViewZonesComputer.prototype._produceModifiedFromDiff = function (lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
            if (lineChangeOriginalLength > lineChangeModifiedLength) {
                return {
                    afterLineNumber: Math.max(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber),
                    heightInLines: (lineChangeOriginalLength - lineChangeModifiedLength),
                    domNode: null
                };
            }
            return null;
        };
        return SideBySideViewZonesComputer;
    }(ViewZonesComputer));
    var DiffEdtorWidgetInline = (function (_super) {
        __extends(DiffEdtorWidgetInline, _super);
        function DiffEdtorWidgetInline(dataSource, enableSplitViewResizing) {
            var _this = this;
            _super.call(this, dataSource);
            this.decorationsLeft = dataSource.getOriginalEditor().getLayoutInfo().decorationsLeft;
            this.toDispose = [];
            this.toDispose.push(dataSource.getOriginalEditor().onDidLayoutChange(function (layoutInfo) {
                if (_this.decorationsLeft !== layoutInfo.decorationsLeft) {
                    _this.decorationsLeft = layoutInfo.decorationsLeft;
                    dataSource.relayoutEditors();
                }
            }));
        }
        DiffEdtorWidgetInline.prototype.dispose = function () {
            this.toDispose = lifecycle_1.dispose(this.toDispose);
        };
        DiffEdtorWidgetInline.prototype.setEnableSplitViewResizing = function (enableSplitViewResizing) {
            // Nothing to do..
        };
        DiffEdtorWidgetInline.prototype._getViewZones = function (lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor) {
            var computer = new InlineViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor);
            return computer.getViewZones();
        };
        DiffEdtorWidgetInline.prototype._getOriginalEditorDecorations = function (lineChanges, ignoreTrimWhitespace, originalEditor, modifiedEditor) {
            var result = {
                decorations: [],
                overviewZones: []
            }, i, length, lineChange;
            for (i = 0, length = lineChanges.length; i < length; i++) {
                lineChange = lineChanges[i];
                // Add overview zones in the overview ruler
                if (isChangeOrDelete(lineChange)) {
                    result.overviewZones.push(new editorCommon.OverviewRulerZone(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber, editorCommon.OverviewRulerLane.Full, 0, 'rgba(255, 0, 0, 0.4)', 'rgba(255, 0, 0, 0.4)'));
                }
            }
            return result;
        };
        DiffEdtorWidgetInline.prototype._getModifiedEditorDecorations = function (lineChanges, ignoreTrimWhitespace, originalEditor, modifiedEditor) {
            var result = {
                decorations: [],
                overviewZones: []
            }, i, length, lineChange, j, lengthJ, charChange, lineNumber, startColumn, endColumn, modifiedModel = modifiedEditor.getModel();
            for (i = 0, length = lineChanges.length; i < length; i++) {
                lineChange = lineChanges[i];
                // Add decorations & overview zones
                if (isChangeOrInsert(lineChange)) {
                    result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, Number.MAX_VALUE, 'line-insert', true));
                    result.overviewZones.push(new editorCommon.OverviewRulerZone(lineChange.modifiedStartLineNumber, lineChange.modifiedEndLineNumber, editorCommon.OverviewRulerLane.Full, 0, 'rgba(155, 185, 85, 0.4)', 'rgba(155, 185, 85, 0.4)'));
                    if (lineChange.charChanges) {
                        for (j = 0, lengthJ = lineChange.charChanges.length; j < lengthJ; j++) {
                            charChange = lineChange.charChanges[j];
                            if (isChangeOrInsert(charChange)) {
                                if (ignoreTrimWhitespace) {
                                    for (lineNumber = charChange.modifiedStartLineNumber; lineNumber <= charChange.modifiedEndLineNumber; lineNumber++) {
                                        if (lineNumber === charChange.modifiedStartLineNumber) {
                                            startColumn = charChange.modifiedStartColumn;
                                        }
                                        else {
                                            startColumn = modifiedModel.getLineFirstNonWhitespaceColumn(lineNumber);
                                        }
                                        if (lineNumber === charChange.modifiedEndLineNumber) {
                                            endColumn = charChange.modifiedEndColumn;
                                        }
                                        else {
                                            endColumn = modifiedModel.getLineLastNonWhitespaceColumn(lineNumber);
                                        }
                                        result.decorations.push(createDecoration(lineNumber, startColumn, lineNumber, endColumn, 'char-insert', false));
                                    }
                                }
                                else {
                                    result.decorations.push(createDecoration(charChange.modifiedStartLineNumber, charChange.modifiedStartColumn, charChange.modifiedEndLineNumber, charChange.modifiedEndColumn, 'char-insert', false));
                                }
                            }
                        }
                    }
                    else {
                        result.decorations.push(createDecoration(lineChange.modifiedStartLineNumber, 1, lineChange.modifiedEndLineNumber, Number.MAX_VALUE, 'char-insert', true));
                    }
                }
            }
            return result;
        };
        DiffEdtorWidgetInline.prototype.layout = function () {
            // An editor should not be smaller than 5px
            return Math.max(5, this.decorationsLeft);
        };
        return DiffEdtorWidgetInline;
    }(DiffEditorWidgetStyle));
    var InlineViewZonesComputer = (function (_super) {
        __extends(InlineViewZonesComputer, _super);
        function InlineViewZonesComputer(lineChanges, originalForeignVZ, modifiedForeignVZ, originalEditor, modifiedEditor) {
            _super.call(this, lineChanges, originalForeignVZ, modifiedForeignVZ);
            this.originalModel = originalEditor.getModel();
            this.modifiedEditorConfiguration = modifiedEditor.getConfiguration();
            this.modifiedEditorTabSize = modifiedEditor.getModel().getOptions().tabSize;
        }
        InlineViewZonesComputer.prototype._produceOriginalFromDiff = function (lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
            return {
                afterLineNumber: Math.max(lineChange.originalStartLineNumber, lineChange.originalEndLineNumber),
                heightInLines: lineChangeModifiedLength,
                domNode: document.createElement('div')
            };
        };
        InlineViewZonesComputer.prototype._produceModifiedFromDiff = function (lineChange, lineChangeOriginalLength, lineChangeModifiedLength) {
            var decorations = [], j, lengthJ, charChange;
            if (lineChange.charChanges) {
                for (j = 0, lengthJ = lineChange.charChanges.length; j < lengthJ; j++) {
                    charChange = lineChange.charChanges[j];
                    if (isChangeOrDelete(charChange)) {
                        decorations.push(new viewModel_1.InlineDecoration(new range_1.Range(charChange.originalStartLineNumber, charChange.originalStartColumn, charChange.originalEndLineNumber, charChange.originalEndColumn), 'char-delete'));
                    }
                }
            }
            var html = [], lineNumber;
            for (lineNumber = lineChange.originalStartLineNumber; lineNumber <= lineChange.originalEndLineNumber; lineNumber++) {
                html = html.concat(this.renderOriginalLine(lineNumber - lineChange.originalStartLineNumber, this.originalModel, this.modifiedEditorConfiguration, this.modifiedEditorTabSize, lineNumber, decorations));
            }
            var domNode = document.createElement('div');
            domNode.className = 'view-lines line-delete';
            domNode.innerHTML = html.join('');
            configuration_1.Configuration.applyFontInfoSlow(domNode, this.modifiedEditorConfiguration.fontInfo);
            return {
                shouldNotShrink: true,
                afterLineNumber: (lineChange.modifiedEndLineNumber === 0 ? lineChange.modifiedStartLineNumber : lineChange.modifiedStartLineNumber - 1),
                heightInLines: lineChangeOriginalLength,
                domNode: domNode
            };
        };
        InlineViewZonesComputer.prototype.renderOriginalLine = function (count, originalModel, config, tabSize, lineNumber, decorations) {
            var lineContent = originalModel.getLineContent(lineNumber);
            var lineTokens = new viewLineToken_1.ViewLineTokens([new viewLineToken_1.ViewLineToken(0, '')], 0, lineContent.length);
            var parts = viewLineParts_1.createLineParts(lineNumber, 1, lineContent, tabSize, lineTokens, decorations, config.viewInfo.renderWhitespace, config.viewInfo.indentGuides);
            var r = viewLineRenderer_1.renderLine(new viewLineRenderer_1.RenderLineInput(lineContent, tabSize, config.fontInfo.spaceWidth, config.viewInfo.stopRenderingLineAfter, config.viewInfo.renderWhitespace, parts.getParts()));
            var myResult = [];
            myResult.push('<div class="view-line');
            if (decorations.length === 0) {
                // No char changes
                myResult.push(' char-delete');
            }
            myResult.push('" style="top:');
            myResult.push(String(count * config.lineHeight));
            myResult.push('px;width:1000000px;">');
            myResult = myResult.concat(r.output);
            myResult.push('</div>');
            return myResult;
        };
        return InlineViewZonesComputer;
    }(ViewZonesComputer));
    function isChangeOrInsert(lineChange) {
        return lineChange.modifiedEndLineNumber > 0;
    }
    function isChangeOrDelete(lineChange) {
        return lineChange.originalEndLineNumber > 0;
    }
    function createDecoration(startLineNumber, startColumn, endLineNumber, endColumn, className, isWholeLine) {
        return {
            range: new range_1.Range(startLineNumber, startColumn, endLineNumber, endColumn),
            options: {
                className: className,
                isWholeLine: isWholeLine
            }
        };
    }
    function createFakeLinesDiv() {
        var r = document.createElement('div');
        r.className = 'diagonal-fill';
        return r;
    }
});















define(__m[175], __M([0,1,31,15,19,36,54,94]), function (require, exports, objects, instantiation_1, keybindingService_1, telemetry_1, codeEditorService_1, codeEditorWidget_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var EmbeddedCodeEditorWidget = (function (_super) {
        __extends(EmbeddedCodeEditorWidget, _super);
        function EmbeddedCodeEditorWidget(domElement, options, parentEditor, instantiationService, codeEditorService, keybindingService, telemetryService) {
            var _this = this;
            _super.call(this, domElement, parentEditor.getRawConfiguration(), instantiationService, codeEditorService, keybindingService, telemetryService);
            this._parentEditor = parentEditor;
            this._overwriteOptions = options;
            // Overwrite parent's options
            _super.prototype.updateOptions.call(this, this._overwriteOptions);
            this._lifetimeDispose.push(parentEditor.onDidChangeConfiguration(function (e) { return _this._onParentConfigurationChanged(e); }));
        }
        EmbeddedCodeEditorWidget.prototype.getParentEditor = function () {
            return this._parentEditor;
        };
        EmbeddedCodeEditorWidget.prototype._onParentConfigurationChanged = function (e) {
            _super.prototype.updateOptions.call(this, this._parentEditor.getRawConfiguration());
            _super.prototype.updateOptions.call(this, this._overwriteOptions);
        };
        EmbeddedCodeEditorWidget.prototype.updateOptions = function (newOptions) {
            objects.mixin(this._overwriteOptions, newOptions, true);
            _super.prototype.updateOptions.call(this, this._overwriteOptions);
        };
        EmbeddedCodeEditorWidget = __decorate([
            __param(3, instantiation_1.IInstantiationService),
            __param(4, codeEditorService_1.ICodeEditorService),
            __param(5, keybindingService_1.IKeybindingService),
            __param(6, telemetry_1.ITelemetryService)
        ], EmbeddedCodeEditorWidget);
        return EmbeddedCodeEditorWidget;
    }(codeEditorWidget_1.CodeEditorWidget));
    exports.EmbeddedCodeEditorWidget = EmbeddedCodeEditorWidget;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





define(__m[95], __M([0,1,365,50,10,35,16,11,58,15,54,164,175,243]), function (require, exports, nls, actions_1, strings, builder_1, event_1, dom, actionbar_1, instantiation_1, codeEditorService_1, zoneWidget_1, embeddedCodeEditorWidget_1) {
    'use strict';
    exports.IPeekViewService = instantiation_1.createDecorator('peekViewService');
    function getOuterEditor(accessor, args) {
        var editor = accessor.get(codeEditorService_1.ICodeEditorService).getFocusedCodeEditor();
        if (editor instanceof embeddedCodeEditorWidget_1.EmbeddedCodeEditorWidget) {
            return editor.getParentEditor();
        }
        return editor;
    }
    exports.getOuterEditor = getOuterEditor;
    var PeekViewWidget = (function (_super) {
        __extends(PeekViewWidget, _super);
        function PeekViewWidget(editor, contextKey, options) {
            if (options === void 0) { options = {}; }
            _super.call(this, editor, options);
            this.serviceId = exports.IPeekViewService;
            this._onDidClose = new event_1.Emitter();
            this._isActive = false;
            this.contextKey = contextKey;
        }
        PeekViewWidget.prototype.dispose = function () {
            this._isActive = false;
            _super.prototype.dispose.call(this);
            this._onDidClose.fire(this);
        };
        Object.defineProperty(PeekViewWidget.prototype, "onDidClose", {
            get: function () {
                return this._onDidClose.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(PeekViewWidget.prototype, "isActive", {
            get: function () {
                return this._isActive;
            },
            enumerable: true,
            configurable: true
        });
        PeekViewWidget.prototype.show = function (where, heightInLines) {
            this._isActive = true;
            this._headElement.style.borderTopColor = this.options.frameColor;
            this._bodyElement.style.borderTopColor = this.options.frameColor;
            this._bodyElement.style.borderBottomColor = this.options.frameColor;
            _super.prototype.show.call(this, where, heightInLines);
        };
        PeekViewWidget.prototype._fillContainer = function (container) {
            builder_1.$(container).addClass('peekview-widget');
            this._headElement = builder_1.$('.head').getHTMLElement();
            this._bodyElement = builder_1.$('.body').getHTMLElement();
            this._fillHead(this._headElement);
            this._fillBody(this._bodyElement);
            container.appendChild(this._headElement);
            container.appendChild(this._bodyElement);
        };
        PeekViewWidget.prototype._fillHead = function (container) {
            var _this = this;
            var titleElement = builder_1.$('.peekview-title').
                on(dom.EventType.CLICK, function (e) { return _this._onTitleClick(e); }).
                appendTo(this._headElement).
                getHTMLElement();
            this._primaryHeading = builder_1.$('span.filename').appendTo(titleElement).getHTMLElement();
            this._secondaryHeading = builder_1.$('span.dirname').appendTo(titleElement).getHTMLElement();
            this._metaHeading = builder_1.$('span.meta').appendTo(titleElement).getHTMLElement();
            this._actionbarWidget = new actionbar_1.ActionBar(builder_1.$('.peekview-actions').
                appendTo(this._headElement));
            this._actionbarWidget.push(new actions_1.Action('peekview.close', nls.localize(0, null), 'close-peekview-action', true, function () {
                _this.dispose();
                return null;
            }), { label: false, icon: true });
        };
        PeekViewWidget.prototype._onTitleClick = function (event) {
            // implement me
        };
        PeekViewWidget.prototype.setTitle = function (primaryHeading, secondaryHeading) {
            builder_1.$(this._primaryHeading).safeInnerHtml(primaryHeading);
            if (secondaryHeading) {
                builder_1.$(this._secondaryHeading).safeInnerHtml(secondaryHeading);
            }
            else {
                dom.clearNode(this._secondaryHeading);
            }
        };
        PeekViewWidget.prototype.setMetaTitle = function (value) {
            if (value) {
                builder_1.$(this._metaHeading).safeInnerHtml(value);
            }
            else {
                dom.clearNode(this._metaHeading);
            }
        };
        PeekViewWidget.prototype._fillBody = function (container) {
            // implement me
        };
        PeekViewWidget.prototype._doLayout = function (heightInPixel, widthInPixel) {
            if (heightInPixel < 0) {
                // Looks like the view zone got folded away!
                this.dispose();
                this._onDidClose.fire(this);
                return;
            }
            var headHeight = Math.ceil(this.editor.getConfiguration().lineHeight * 1.2), bodyHeight = heightInPixel - (headHeight + 2 /* the border-top/bottom width*/);
            this._doLayoutHead(headHeight, widthInPixel);
            this._doLayoutBody(bodyHeight, widthInPixel);
        };
        PeekViewWidget.prototype._doLayoutHead = function (heightInPixel, widthInPixel) {
            this._headElement.style.height = strings.format('{0}px', heightInPixel);
            this._headElement.style.lineHeight = this._headElement.style.height;
        };
        PeekViewWidget.prototype._doLayoutBody = function (heightInPixel, widthInPixel) {
            this._bodyElement.style.height = strings.format('{0}px', heightInPixel);
        };
        return PeekViewWidget;
    }(zoneWidget_1.ZoneWidget));
    exports.PeekViewWidget = PeekViewWidget;
});

define(__m[61], __M([0,1,15]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IWorkspaceContextService = instantiation_1.createDecorator('contextService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[503], __M([0,1,47,14,134,104,48,16,60,3,38,29,33,85,115,61,36,7,17,158,114,117,140,131,40,157,138,34,72,113]), function (require, exports) {
    'use strict';
});










define(__m[504], __M([0,1,2,7,113,155,118,61,34,45]), function (require, exports, winjs_base_1, editorCommon_1, compatWorkerService_1, defaultWorkerFactory_1, workerClient_1, workspace_1, modelService_1, modesRegistry_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var MainThreadCompatWorkerService = (function () {
        function MainThreadCompatWorkerService(contextService, modelService) {
            var _this = this;
            this.serviceId = compatWorkerService_1.ICompatWorkerService;
            this.isInMainThread = true;
            this._contextService = contextService;
            this._workerFactory = new defaultWorkerFactory_1.DefaultWorkerFactory(true);
            this._worker = null;
            this._workerCreatedPromise = new winjs_base_1.TPromise(function (c, e, p) {
                _this._triggerWorkersCreatedPromise = c;
            }, function () {
                // Not cancelable
            });
            this._modelListeners = Object.create(null);
            var isInterestingModel = function (model) {
                if (model.isTooLargeForHavingARichMode()) {
                    return false;
                }
                var modeId = model.getModeId();
                var compatModes = modesRegistry_1.ModesRegistry.getCompatModes();
                for (var i = 0; i < compatModes.length; i++) {
                    if (compatModes[i].id === modeId) {
                        return true;
                    }
                }
                return false;
            };
            var onModelAdded = function (model) {
                if (!isInterestingModel(model)) {
                    return;
                }
                _this._modelListeners[model.uri.toString()] = model.addBulkListener(function (events) {
                    var contentChangedEvents = (events
                        .filter(function (e) { return e.getType() === editorCommon_1.EventType.ModelRawContentChanged; })
                        .map(function (e) { return e.getData(); }));
                    if (contentChangedEvents.length === 0) {
                        return;
                    }
                    _this._call('$', 'acceptModelEvents', [model.uri, { contentChanged: contentChangedEvents }]);
                });
                _this._call('$', 'acceptNewModel', [{
                        url: model.uri,
                        versionId: model.getVersionId(),
                        value: model.toRawText(),
                        modeId: model.getMode().getId()
                    }]);
            };
            var onModelRemoved = function (model) {
                if (_this._modelListeners[model.uri.toString()]) {
                    _this._modelListeners[model.uri.toString()].dispose();
                    delete _this._modelListeners[model.uri.toString()];
                    _this._call('$', 'acceptDidDisposeModel', [model.uri]);
                }
            };
            modelService.onModelAdded(onModelAdded);
            modelService.onModelRemoved(onModelRemoved);
            modelService.onModelModeChanged(function (event) {
                onModelRemoved(event.model);
                onModelAdded(event.model);
            });
        }
        MainThreadCompatWorkerService.prototype.registerCompatMode = function (compatMode) {
            this._call('$', 'instantiateCompatMode', [compatMode.getId()]);
        };
        MainThreadCompatWorkerService.prototype.CompatWorker = function (obj, methodName, target, param) {
            return this._call(obj.getId(), methodName, param);
        };
        MainThreadCompatWorkerService.prototype._ensureWorkers = function () {
            if (this._triggerWorkersCreatedPromise) {
                // Workers not created yet
                this._createWorker();
                var complete = this._triggerWorkersCreatedPromise;
                this._triggerWorkersCreatedPromise = null;
                complete(null);
            }
        };
        MainThreadCompatWorkerService.prototype._afterWorkers = function () {
            var _this = this;
            this._ensureWorkers();
            var shouldCancelPromise = false;
            return new winjs_base_1.TPromise(function (c, e, p) {
                // hide the initialize promise inside this
                // promise so that it won't be canceled by accident
                _this._workerCreatedPromise.then(function () {
                    if (!shouldCancelPromise) {
                        c(null);
                    }
                }, e, p);
            }, function () {
                // mark that this promise is canceled
                shouldCancelPromise = true;
            });
        };
        MainThreadCompatWorkerService.prototype._createWorker = function (isRetry) {
            var _this = this;
            if (isRetry === void 0) { isRetry = false; }
            this._worker = new workerClient_1.WorkerClient(this._workerFactory, 'vs/editor/common/worker/editorWorkerServer');
            this._worker.onModuleLoaded = this._worker.request('initialize', {
                contextService: {
                    workspace: this._contextService.getWorkspace(),
                    configuration: this._contextService.getConfiguration(),
                    options: this._contextService.getOptions()
                },
                modesRegistryData: {
                    compatModes: modesRegistry_1.ModesRegistry.getCompatModes(),
                    languages: modesRegistry_1.ModesRegistry.getLanguages()
                }
            }).then(function () {
                modesRegistry_1.ModesRegistry.onDidAddCompatModes(function (m) { return _this._call('$', 'acceptCompatModes', [m]); });
                modesRegistry_1.ModesRegistry.onDidAddLanguages(function (m) { return _this._call('$', 'acceptLanguages', [m]); });
            }, function (err) {
                _this._worker.dispose();
                _this._worker = null;
                if (isRetry) {
                    console.warn('Creating the web worker already failed twice. Giving up!');
                }
                else {
                    _this._createWorker(true);
                }
            });
        };
        MainThreadCompatWorkerService.prototype._call = function (rpcId, methodName, args) {
            var _this = this;
            return this._afterWorkers().then(function (_) {
                if (_this._worker === null) {
                    throw new Error('Cannot fulfill request...');
                }
                return _this._worker.request('request', {
                    target: rpcId,
                    methodName: methodName,
                    args: args
                });
            });
        };
        MainThreadCompatWorkerService = __decorate([
            __param(0, workspace_1.IWorkspaceContextService),
            __param(1, modelService_1.IModelService)
        ], MainThreadCompatWorkerService);
        return MainThreadCompatWorkerService;
    }());
    exports.MainThreadCompatWorkerService = MainThreadCompatWorkerService;
});















define(__m[178], __M([0,1,354,48,8,142,16,3,78,10,2,35,11,123,248,250,251,75,106,43,67,61,55,4,7,125,175,95,96,238]), function (require, exports, nls, collections, errors_1, labels_1, event_1, lifecycle_1, network_1, strings, winjs_base_1, builder_1, dom, sash_1, countBadge_1, fileLabel_1, leftRightWidget_1, treeDefaults_1, treeImpl_1, editor_1, serviceCollection_1, workspace_1, defaultConfig_1, range_1, editorCommon, model_1, embeddedCodeEditorWidget_1, peekViewWidget_1, referencesModel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var DecorationsManager = (function () {
        function DecorationsManager(editor, model) {
            var _this = this;
            this.editor = editor;
            this.model = model;
            this._decorationSet = collections.createStringDictionary();
            this._decorationIgnoreSet = collections.createStringDictionary();
            this._callOnDispose = [];
            this._callOnModelChange = [];
            this._callOnDispose.push(this.editor.onDidChangeModel(function () { return _this._onModelChanged(); }));
            this._onModelChanged();
        }
        DecorationsManager.prototype.dispose = function () {
            this._callOnModelChange = lifecycle_1.dispose(this._callOnModelChange);
            this._callOnDispose = lifecycle_1.dispose(this._callOnDispose);
            this.removeDecorations();
        };
        DecorationsManager.prototype._onModelChanged = function () {
            this.removeDecorations();
            this._callOnModelChange = lifecycle_1.dispose(this._callOnModelChange);
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            for (var i = 0, len = this.model.groups.length; i < len; i++) {
                if (this.model.groups[i].uri.toString() === model.uri.toString()) {
                    this._addDecorations(this.model.groups[i]);
                    return;
                }
            }
        };
        DecorationsManager.prototype._addDecorations = function (reference) {
            var _this = this;
            this._callOnModelChange.push(this.editor.getModel().onDidChangeDecorations(function (event) { return _this._onDecorationChanged(event); }));
            this.editor.getModel().changeDecorations(function (accessor) {
                var newDecorations = [];
                var newDecorationsActualIndex = [];
                for (var i_1 = 0, len = reference.children.length; i_1 < len; i_1++) {
                    var oneReference = reference.children[i_1];
                    if (_this._decorationIgnoreSet[oneReference.id]) {
                        continue;
                    }
                    newDecorations.push({
                        range: oneReference.range,
                        options: DecorationsManager.DecorationOptions
                    });
                    newDecorationsActualIndex.push(i_1);
                }
                var decorations = accessor.deltaDecorations([], newDecorations);
                for (var i = 0; i < decorations.length; i++) {
                    _this._decorationSet[decorations[i]] = reference.children[newDecorationsActualIndex[i]];
                }
            });
        };
        DecorationsManager.prototype._onDecorationChanged = function (event) {
            var _this = this;
            var addedOrChangedDecorations = event.addedOrChangedDecorations, toRemove = [];
            for (var i = 0, len = addedOrChangedDecorations.length; i < len; i++) {
                var reference = collections.lookup(this._decorationSet, addedOrChangedDecorations[i].id);
                if (!reference) {
                    continue;
                }
                var newRange = addedOrChangedDecorations[i].range, ignore = false;
                if (range_1.Range.equalsRange(newRange, reference.range)) {
                    continue;
                }
                else if (range_1.Range.spansMultipleLines(newRange)) {
                    ignore = true;
                }
                else {
                    var lineLength = reference.range.endColumn - reference.range.startColumn, newLineLength = newRange.endColumn - newRange.startColumn;
                    if (lineLength !== newLineLength) {
                        ignore = true;
                    }
                }
                if (ignore) {
                    this._decorationIgnoreSet[reference.id] = reference;
                    toRemove.push(addedOrChangedDecorations[i].id);
                }
                else {
                    reference.range = newRange;
                }
            }
            this.editor.changeDecorations(function (accessor) {
                for (var i_2 = 0, len_1 = toRemove.length; i_2 < len_1; i_2++) {
                    delete _this._decorationSet[toRemove[i_2]];
                }
                accessor.deltaDecorations(toRemove, []);
            });
        };
        DecorationsManager.prototype.removeDecorations = function () {
            var keys = Object.keys(this._decorationSet);
            if (keys.length > 0) {
                this.editor.changeDecorations(function (accessor) {
                    accessor.deltaDecorations(keys, []);
                });
            }
            this._decorationSet = {};
        };
        DecorationsManager.DecorationOptions = {
            stickiness: editorCommon.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
            className: 'reference-decoration'
        };
        return DecorationsManager;
    }());
    var DataSource = (function () {
        function DataSource(_editorService) {
            this._editorService = _editorService;
            //
        }
        DataSource.prototype.getId = function (tree, element) {
            if (element instanceof referencesModel_1.ReferencesModel) {
                return 'root';
            }
            else if (element instanceof referencesModel_1.FileReferences) {
                return element.id;
            }
            else if (element instanceof referencesModel_1.OneReference) {
                return element.id;
            }
        };
        DataSource.prototype.hasChildren = function (tree, element) {
            if (element instanceof referencesModel_1.ReferencesModel) {
                return true;
            }
            if (element instanceof referencesModel_1.FileReferences && !element.failure) {
                return true;
            }
        };
        DataSource.prototype.getChildren = function (tree, element) {
            if (element instanceof referencesModel_1.ReferencesModel) {
                return winjs_base_1.TPromise.as(element.groups);
            }
            else if (element instanceof referencesModel_1.FileReferences) {
                return element.resolve(this._editorService).then(function (val) {
                    if (element.failure) {
                        // refresh the element on failure so that
                        // we can update its rendering
                        return tree.refresh(element).then(function () { return val.children; });
                    }
                    return val.children;
                });
            }
            else {
                return winjs_base_1.TPromise.as([]);
            }
        };
        DataSource.prototype.getParent = function (tree, element) {
            var result = null;
            if (element instanceof referencesModel_1.FileReferences) {
                result = element.parent;
            }
            else if (element instanceof referencesModel_1.OneReference) {
                result = element.parent;
            }
            return winjs_base_1.TPromise.as(result);
        };
        DataSource = __decorate([
            __param(0, editor_1.IEditorService)
        ], DataSource);
        return DataSource;
    }());
    var Controller = (function (_super) {
        __extends(Controller, _super);
        function Controller() {
            _super.apply(this, arguments);
        }
        Controller.prototype.onTap = function (tree, element, event) {
            if (element instanceof referencesModel_1.FileReferences) {
                event.preventDefault();
                event.stopPropagation();
                return this._expandCollapse(tree, element);
            }
            var result = _super.prototype.onTap.call(this, tree, element, event);
            tree.emit(Controller.Events.FOCUSED, element);
            return result;
        };
        Controller.prototype.onMouseDown = function (tree, element, event) {
            if (event.leftButton) {
                if (element instanceof referencesModel_1.FileReferences) {
                    event.preventDefault();
                    event.stopPropagation();
                    return this._expandCollapse(tree, element);
                }
                var result = _super.prototype.onClick.call(this, tree, element, event);
                if (event.ctrlKey || event.metaKey) {
                    tree.emit(Controller.Events.OPEN_TO_SIDE, element);
                }
                else if (event.detail === 2) {
                    tree.emit(Controller.Events.SELECTED, element);
                }
                else {
                    tree.emit(Controller.Events.FOCUSED, element);
                }
                return result;
            }
            return false;
        };
        Controller.prototype.onClick = function (tree, element, event) {
            if (event.leftButton) {
                return false; // Already handled by onMouseDown
            }
            return _super.prototype.onClick.call(this, tree, element, event);
        };
        Controller.prototype._expandCollapse = function (tree, element) {
            if (tree.isExpanded(element)) {
                tree.collapse(element).done(null, errors_1.onUnexpectedError);
            }
            else {
                tree.expand(element).done(null, errors_1.onUnexpectedError);
            }
            return true;
        };
        Controller.prototype.onEscape = function (tree, event) {
            return false;
        };
        Controller.prototype.onEnter = function (tree, event) {
            var element = tree.getFocus();
            if (element instanceof referencesModel_1.FileReferences) {
                return this._expandCollapse(tree, element);
            }
            var result = _super.prototype.onEnter.call(this, tree, event);
            if (event.ctrlKey || event.metaKey) {
                tree.emit(Controller.Events.OPEN_TO_SIDE, element);
            }
            else {
                tree.emit(Controller.Events.SELECTED, element);
            }
            return result;
        };
        Controller.prototype.onUp = function (tree, event) {
            _super.prototype.onUp.call(this, tree, event);
            this._fakeFocus(tree, event);
            return true;
        };
        Controller.prototype.onPageUp = function (tree, event) {
            _super.prototype.onPageUp.call(this, tree, event);
            this._fakeFocus(tree, event);
            return true;
        };
        Controller.prototype.onLeft = function (tree, event) {
            _super.prototype.onLeft.call(this, tree, event);
            this._fakeFocus(tree, event);
            return true;
        };
        Controller.prototype.onDown = function (tree, event) {
            _super.prototype.onDown.call(this, tree, event);
            this._fakeFocus(tree, event);
            return true;
        };
        Controller.prototype.onPageDown = function (tree, event) {
            _super.prototype.onPageDown.call(this, tree, event);
            this._fakeFocus(tree, event);
            return true;
        };
        Controller.prototype.onRight = function (tree, event) {
            _super.prototype.onRight.call(this, tree, event);
            this._fakeFocus(tree, event);
            return true;
        };
        Controller.prototype._fakeFocus = function (tree, event) {
            // focus next item
            var focus = tree.getFocus();
            tree.setSelection([focus]);
            // send out event
            tree.emit(Controller.Events.FOCUSED, focus);
        };
        Controller.Events = {
            FOCUSED: 'events/custom/focused',
            SELECTED: 'events/custom/selected',
            OPEN_TO_SIDE: 'events/custom/opentoside'
        };
        return Controller;
    }(treeDefaults_1.DefaultController));
    var Renderer = (function (_super) {
        __extends(Renderer, _super);
        function Renderer(contextService) {
            _super.call(this);
            this._contextService = contextService;
        }
        Renderer.prototype.getHeight = function (tree, element) {
            return 22;
        };
        Renderer.prototype.render = function (tree, element, container) {
            var _this = this;
            dom.clearNode(container);
            if (element instanceof referencesModel_1.FileReferences) {
                var fileReferencesContainer = builder_1.$('.reference-file');
                /* tslint:disable:no-unused-expression */
                new leftRightWidget_1.LeftRightWidget(fileReferencesContainer, function (left) {
                    new fileLabel_1.FileLabel(left, element.uri, _this._contextService);
                    return null;
                }, function (right) {
                    var len = element.children.length;
                    var badge = new countBadge_1.CountBadge(right, len);
                    if (element.failure) {
                        badge.setTitleFormat(nls.localize(0, null));
                    }
                    else if (len > 1) {
                        badge.setTitleFormat(nls.localize(1, null, len));
                    }
                    else {
                        badge.setTitleFormat(nls.localize(2, null, len));
                    }
                    return badge;
                });
                /* tslint:enable:no-unused-expression */
                fileReferencesContainer.appendTo(container);
            }
            else if (element instanceof referencesModel_1.OneReference) {
                var preview = element.parent.preview.preview(element.range);
                builder_1.$('.reference').innerHtml(strings.format('<span>{0}</span><span class="referenceMatch">{1}</span><span>{2}</span>', strings.escape(preview.before), strings.escape(preview.inside), strings.escape(preview.after))).appendTo(container);
            }
            return null;
        };
        Renderer = __decorate([
            __param(0, workspace_1.IWorkspaceContextService)
        ], Renderer);
        return Renderer;
    }(treeDefaults_1.LegacyRenderer));
    var VSash = (function () {
        function VSash(container, ratio) {
            var _this = this;
            this._disposables = new lifecycle_1.Disposables();
            this._onDidChangePercentages = new event_1.Emitter();
            this._ratio = ratio;
            this._sash = new sash_1.Sash(container, {
                getVerticalSashLeft: function () { return _this._width * _this._ratio; },
                getVerticalSashHeight: function () { return _this._height; }
            });
            // compute the current widget clientX postion since
            // the sash works with clientX when dragging
            var clientX;
            this._disposables.add(this._sash.addListener2('start', function (e) {
                clientX = e.startX - (_this._width * _this.ratio);
            }));
            this._disposables.add(this._sash.addListener2('change', function (e) {
                // compute the new position of the sash and from that
                // compute the new ratio that we are using
                var newLeft = e.currentX - clientX;
                if (newLeft > 20 && newLeft + 20 < _this._width) {
                    _this._ratio = newLeft / _this._width;
                    _this._sash.layout();
                    _this._onDidChangePercentages.fire(_this);
                }
            }));
        }
        VSash.prototype.dispose = function () {
            this._sash.dispose();
            this._onDidChangePercentages.dispose();
            this._disposables.dispose();
        };
        Object.defineProperty(VSash.prototype, "onDidChangePercentages", {
            get: function () {
                return this._onDidChangePercentages.event;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VSash.prototype, "width", {
            set: function (value) {
                this._width = value;
                this._sash.layout();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VSash.prototype, "height", {
            set: function (value) {
                this._height = value;
                this._sash.layout();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VSash.prototype, "percentages", {
            get: function () {
                var left = 100 * this._ratio;
                var right = 100 - left;
                return [(left + "%"), (right + "%")];
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(VSash.prototype, "ratio", {
            get: function () {
                return this._ratio;
            },
            enumerable: true,
            configurable: true
        });
        return VSash;
    }());
    /**
     * ZoneWidget that is shown inside the editor
     */
    var ReferenceWidget = (function (_super) {
        __extends(ReferenceWidget, _super);
        function ReferenceWidget(editor, layoutData, _editorService, _contextService, _instantiationService) {
            _super.call(this, editor, ReferenceWidget.INNER_EDITOR_CONTEXT_KEY, { frameColor: '#007ACC', showFrame: false, showArrow: true, isResizeable: true });
            this.layoutData = layoutData;
            this._editorService = _editorService;
            this._contextService = _contextService;
            this._instantiationService = _instantiationService;
            this._disposeOnNewModel = [];
            this._onDidSelectReference = new event_1.Emitter();
            this._instantiationService = this._instantiationService.createChild(new serviceCollection_1.ServiceCollection([peekViewWidget_1.IPeekViewService, this]));
            this.create();
        }
        ReferenceWidget.prototype.dispose = function () {
            this.setModel(null);
            lifecycle_1.dispose(this._preview, this._previewNotAvailableMessage, this._tree, this._sash);
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(ReferenceWidget.prototype, "onDidSelectReference", {
            get: function () {
                return this._onDidSelectReference.event;
            },
            enumerable: true,
            configurable: true
        });
        ReferenceWidget.prototype.show = function (where) {
            this.editor.revealRangeInCenterIfOutsideViewport(where);
            _super.prototype.show.call(this, where, this.layoutData.heightInLines || 18);
        };
        ReferenceWidget.prototype.focus = function () {
            this._tree.DOMFocus();
        };
        ReferenceWidget.prototype._onTitleClick = function (e) {
            if (this._preview && this._preview.getModel()) {
                this._onDidSelectReference.fire({
                    element: this._getFocusedReference(),
                    kind: e.ctrlKey || e.metaKey ? 'side' : 'open',
                    source: 'title'
                });
            }
        };
        ReferenceWidget.prototype._fillBody = function (containerElement) {
            var _this = this;
            var container = builder_1.$(containerElement);
            container.addClass('reference-zone-widget');
            // message pane
            container.div({ 'class': 'messages' }, function (div) {
                _this._messageContainer = div.hide();
            });
            // editor
            container.div({ 'class': 'preview inline' }, function (div) {
                var options = {
                    scrollBeyondLastLine: false,
                    scrollbar: defaultConfig_1.DefaultConfig.editor.scrollbar,
                    overviewRulerLanes: 2
                };
                _this._preview = _this._instantiationService.createInstance(embeddedCodeEditorWidget_1.EmbeddedCodeEditorWidget, div.getHTMLElement(), options, _this.editor);
                _this._previewContainer = div.hide();
                _this._previewNotAvailableMessage = model_1.Model.createFromString(nls.localize(3, null));
            });
            // sash
            this._sash = new VSash(containerElement, this.layoutData.ratio || .8);
            this._sash.onDidChangePercentages(function () {
                var _a = _this._sash.percentages, left = _a[0], right = _a[1];
                _this._previewContainer.style({ width: left });
                _this._treeContainer.style({ width: right });
                _this._preview.layout();
                _this._tree.layout();
                _this.layoutData.ratio = _this._sash.ratio;
            });
            // tree
            container.div({ 'class': 'ref-tree inline' }, function (div) {
                var config = {
                    dataSource: _this._instantiationService.createInstance(DataSource),
                    renderer: _this._instantiationService.createInstance(Renderer),
                    //sorter: new Sorter(),
                    controller: new Controller()
                };
                var options = {
                    allowHorizontalScroll: false,
                    twistiePixels: 20,
                    ariaLabel: nls.localize(4, null)
                };
                _this._tree = new treeImpl_1.Tree(div.getHTMLElement(), config, options);
                _this._treeContainer = div.hide();
            });
        };
        ReferenceWidget.prototype._doLayoutBody = function (heightInPixel, widthInPixel) {
            _super.prototype._doLayoutBody.call(this, heightInPixel, widthInPixel);
            var height = heightInPixel + 'px';
            this._sash.height = heightInPixel;
            this._sash.width = widthInPixel;
            // set height/width
            var _a = this._sash.percentages, left = _a[0], right = _a[1];
            this._previewContainer.style({ height: height, width: left });
            this._treeContainer.style({ height: height, width: right });
            // forward
            this._tree.layout(heightInPixel);
            this._preview.layout();
            // store layout data
            this.layoutData = {
                heightInLines: this._viewZone.heightInLines,
                ratio: this._sash.ratio
            };
        };
        ReferenceWidget.prototype._onWidth = function (widthInPixel) {
            this._sash.width = widthInPixel;
            this._preview.layout();
        };
        ReferenceWidget.prototype.setSelection = function (selection) {
            return this._revealReference(selection);
        };
        ReferenceWidget.prototype.setModel = function (newModel) {
            // clean up
            this._disposeOnNewModel = lifecycle_1.dispose(this._disposeOnNewModel);
            this._model = newModel;
            if (this._model) {
                return this._onNewModel();
            }
        };
        ReferenceWidget.prototype._onNewModel = function () {
            var _this = this;
            if (this._model.empty) {
                this.setTitle('');
                this._messageContainer.innerHtml(nls.localize(5, null)).show();
                return winjs_base_1.TPromise.as(void 0);
            }
            this._messageContainer.hide();
            this._decorationsManager = new DecorationsManager(this._preview, this._model);
            this._disposeOnNewModel.push(this._decorationsManager);
            // listen on model changes
            this._disposeOnNewModel.push(this._model.onDidChangeReferenceRange(function (reference) { return _this._tree.refresh(reference); }));
            // listen on selection and focus
            this._disposeOnNewModel.push(this._tree.addListener2(Controller.Events.FOCUSED, function (element) {
                if (element instanceof referencesModel_1.OneReference) {
                    _this._revealReference(element);
                    _this._onDidSelectReference.fire({ element: element, kind: 'show', source: 'tree' });
                }
            }));
            this._disposeOnNewModel.push(this._tree.addListener2(Controller.Events.SELECTED, function (element) {
                if (element instanceof referencesModel_1.OneReference) {
                    _this._revealReference(element);
                    _this._onDidSelectReference.fire({ element: element, kind: 'goto', source: 'tree' });
                }
            }));
            this._disposeOnNewModel.push(this._tree.addListener2(Controller.Events.OPEN_TO_SIDE, function (element) {
                if (element instanceof referencesModel_1.OneReference) {
                    _this._onDidSelectReference.fire({ element: element, kind: 'side', source: 'tree' });
                }
            }));
            // listen on editor
            this._disposeOnNewModel.push(this._preview.onMouseDown(function (e) {
                if (e.event.detail === 2) {
                    _this._onDidSelectReference.fire({
                        element: _this._getFocusedReference(),
                        kind: (e.event.ctrlKey || e.event.metaKey) ? 'side' : 'open',
                        source: 'editor'
                    });
                }
            }));
            // make sure things are rendered
            dom.addClass(this.container, 'results-loaded');
            this._treeContainer.show();
            this._previewContainer.show();
            this._preview.layout();
            this._tree.layout();
            this.focus();
            // pick input and a reference to begin with
            var input = this._model.groups.length === 1 ? this._model.groups[0] : this._model;
            return this._tree.setInput(input);
        };
        ReferenceWidget.prototype._getFocusedReference = function () {
            var element = this._tree.getFocus();
            if (element instanceof referencesModel_1.OneReference) {
                return element;
            }
            else if (element instanceof referencesModel_1.FileReferences) {
                if (element.children.length > 0) {
                    return element.children[0];
                }
            }
        };
        ReferenceWidget.prototype._revealReference = function (reference) {
            var _this = this;
            // Update widget header
            if (reference.uri.scheme !== network_1.Schemas.inMemory) {
                this.setTitle(reference.name, labels_1.getPathLabel(reference.directory, this._contextService));
            }
            else {
                this.setTitle(nls.localize(6, null));
            }
            return winjs_base_1.TPromise.join([
                this._editorService.resolveEditorModel({ resource: reference.uri }),
                this._tree.reveal(reference)
            ]).then(function (values) {
                if (!_this._model) {
                    // disposed
                    return;
                }
                // show in editor
                var model = values[0];
                if (model) {
                    _this._preview.setModel(model.textEditorModel);
                    var sel = range_1.Range.lift(reference.range).collapseToStart();
                    _this._preview.setSelection(sel);
                    _this._preview.revealRangeInCenter(sel);
                }
                else {
                    _this._preview.setModel(_this._previewNotAvailableMessage);
                }
                // show in tree
                _this._tree.setSelection([reference]);
                _this._tree.setFocus(reference);
            }, errors_1.onUnexpectedError);
        };
        ReferenceWidget.INNER_EDITOR_CONTEXT_KEY = 'inReferenceSearchEditor';
        return ReferenceWidget;
    }(peekViewWidget_1.PeekViewWidget));
    exports.ReferenceWidget = ReferenceWidget;
});










define(__m[179], __M([0,1,353,8,3,32,43,15,19,42,36,57,61,163,30,95,178]), function (require, exports, nls, errors_1, lifecycle_1, severity_1, editor_1, instantiation_1, keybindingService_1, message_1, telemetry_1, configuration_1, workspace_1, storage_1, editorBrowserExtensions_1, peekViewWidget_1, referencesWidget_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.ctxReferenceSearchVisible = 'referenceSearchVisible';
    var ReferencesController = (function () {
        function ReferencesController(editor, keybindingService, _editorService, _telemetryService, _messageService, _instantiationService, _contextService, _storageService, _configurationService, _peekViewService) {
            this._editorService = _editorService;
            this._telemetryService = _telemetryService;
            this._messageService = _messageService;
            this._instantiationService = _instantiationService;
            this._contextService = _contextService;
            this._storageService = _storageService;
            this._configurationService = _configurationService;
            this._peekViewService = _peekViewService;
            this._requestIdPool = 0;
            this._disposables = [];
            this._ignoreModelChangeEvent = false;
            this._editor = editor;
            this._referenceSearchVisible = keybindingService.createKey(exports.ctxReferenceSearchVisible, false);
        }
        ReferencesController.getController = function (editor) {
            return editor.getContribution(ReferencesController.ID);
        };
        ReferencesController.prototype.getId = function () {
            return ReferencesController.ID;
        };
        ReferencesController.prototype.dispose = function () {
            if (this._widget) {
                this._widget.dispose();
                this._widget = null;
            }
            this._editor = null;
        };
        ReferencesController.prototype.toggleWidget = function (range, modelPromise, options) {
            var _this = this;
            // close current widget and return early is position didn't change
            var widgetPosition;
            if (this._widget) {
                widgetPosition = this._widget.position;
            }
            this.closeWidget();
            if (!!widgetPosition && range.containsPosition(widgetPosition)) {
                return null;
            }
            this._referenceSearchVisible.set(true);
            // close the widget on model/mode changes
            this._disposables.push(this._editor.onDidChangeModelMode(function () { _this.closeWidget(); }));
            this._disposables.push(this._editor.onDidChangeModel(function () {
                if (!_this._ignoreModelChangeEvent) {
                    _this.closeWidget();
                }
            }));
            var storageKey = 'peekViewLayout';
            var data = JSON.parse(this._storageService.get(storageKey, undefined, '{}'));
            this._widget = new referencesWidget_1.ReferenceWidget(this._editor, data, this._editorService, this._contextService, this._instantiationService);
            this._widget.setTitle(nls.localize(0, null));
            this._widget.show(range);
            this._disposables.push(this._widget.onDidClose(function () {
                modelPromise.cancel();
                _this._storageService.store(storageKey, JSON.stringify(_this._widget.layoutData));
                _this._widget = null;
                _this.closeWidget();
            }));
            this._disposables.push(this._widget.onDidSelectReference(function (event) {
                var element = event.element, kind = event.kind;
                switch (kind) {
                    case 'open':
                        if (event.source === 'editor'
                            && configuration_1.getConfigurationValue(_this._configurationService.getConfiguration(), 'editor.stablePeek', false)) {
                            // when stable peek is configured we don't close
                            // the peek window on selecting the editor
                            break;
                        }
                    case 'side':
                        _this._openReference(element, kind === 'side');
                        break;
                    case 'goto':
                        if (options.onGoto) {
                            options.onGoto(element);
                        }
                        else {
                            _this._gotoReference(element);
                        }
                        break;
                }
            }));
            var requestId = ++this._requestIdPool;
            var timer = this._telemetryService.timedPublicLog('findReferences', {
                mode: this._editor.getModel().getMode().getId()
            });
            modelPromise.then(function (model) {
                // still current request? widget still open?
                if (requestId !== _this._requestIdPool || !_this._widget) {
                    return;
                }
                _this._model = model;
                // measure time it stays open
                var startTime = Date.now();
                _this._disposables.push({
                    dispose: function () {
                        _this._telemetryService.publicLog('zoneWidgetShown', {
                            mode: 'reference search',
                            elapsedTime: Date.now() - startTime
                        });
                    }
                });
                // show widget
                return _this._widget.setModel(_this._model).then(function () {
                    // set title
                    _this._widget.setMetaTitle(options.getMetaTitle(_this._model));
                    // set 'best' selection
                    var uri = _this._editor.getModel().uri;
                    var pos = { lineNumber: range.startLineNumber, column: range.startColumn };
                    var selection = _this._model.nearestReference(uri, pos);
                    if (selection) {
                        return _this._widget.setSelection(selection);
                    }
                });
            }, function (error) {
                _this._messageService.show(severity_1.default.Error, error);
            }).done(function () {
                timer.stop();
            });
        };
        ReferencesController.prototype.closeWidget = function () {
            if (this._widget) {
                this._widget.dispose();
                this._widget = null;
            }
            this._referenceSearchVisible.reset();
            this._disposables = lifecycle_1.dispose(this._disposables);
            this._model = null;
            this._editor.focus();
            this._requestIdPool += 1; // Cancel pending requests
        };
        ReferencesController.prototype._gotoReference = function (ref) {
            var _this = this;
            this._ignoreModelChangeEvent = true;
            var uri = ref.uri, range = ref.range;
            this._editorService.openEditor({
                resource: uri,
                options: { selection: range }
            }).done(function (openedEditor) {
                _this._ignoreModelChangeEvent = false;
                if (!openedEditor || openedEditor.getControl() !== _this._editor) {
                    // TODO@Alex TODO@Joh
                    // when opening the current reference we might end up
                    // in a different editor instance. that means we also have
                    // a different instance of this reference search controller
                    // and cannot hold onto the widget (which likely doesn't
                    // exist). Instead of bailing out we should find the
                    // 'sister' action and pass our current model on to it.
                    _this.closeWidget();
                    return;
                }
                _this._widget.show(range);
                _this._widget.focus();
            }, function (err) {
                _this._ignoreModelChangeEvent = false;
                errors_1.onUnexpectedError(err);
            });
        };
        ReferencesController.prototype._openReference = function (ref, sideBySide) {
            var uri = ref.uri, range = ref.range;
            this._editorService.openEditor({
                resource: uri,
                options: { selection: range }
            }, sideBySide);
            // clear stage
            if (!sideBySide) {
                this.closeWidget();
            }
        };
        ReferencesController.ID = 'editor.contrib.referencesController';
        ReferencesController = __decorate([
            __param(1, keybindingService_1.IKeybindingService),
            __param(2, editor_1.IEditorService),
            __param(3, telemetry_1.ITelemetryService),
            __param(4, message_1.IMessageService),
            __param(5, instantiation_1.IInstantiationService),
            __param(6, workspace_1.IWorkspaceContextService),
            __param(7, storage_1.IStorageService),
            __param(8, configuration_1.IConfigurationService),
            __param(9, instantiation_1.optional(peekViewWidget_1.IPeekViewService))
        ], ReferencesController);
        return ReferencesController;
    }());
    exports.ReferencesController = ReferencesController;
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(ReferencesController);
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[507], __M([0,1,332,14,8,92,12,18,32,10,2,28,43,42,4,20,25,7,13,17,30,456,179,96,3,95,15,215]), function (require, exports, nls, async_1, errors_1, htmlContent_1, keyCodes_1, platform, severity_1, strings, winjs_base_1, browser, editor_1, message_1, range_1, editorAction_1, editorActionEnablement_1, editorCommon, editorCommonExtensions_1, modes_1, editorBrowserExtensions_1, goToDeclaration_1, referencesController_1, referencesModel_1, lifecycle_1, peekViewWidget_1, instantiation_1) {
    'use strict';
    var DefinitionActionConfig = (function () {
        function DefinitionActionConfig(condition, openToSide, openInPeek, filterCurrent) {
            if (condition === void 0) { condition = editorActionEnablement_1.Behaviour.WidgetFocus | editorActionEnablement_1.Behaviour.ShowInContextMenu | editorActionEnablement_1.Behaviour.UpdateOnCursorPositionChange; }
            if (openToSide === void 0) { openToSide = false; }
            if (openInPeek === void 0) { openInPeek = false; }
            if (filterCurrent === void 0) { filterCurrent = true; }
            this.condition = condition;
            this.openToSide = openToSide;
            this.openInPeek = openInPeek;
            this.filterCurrent = filterCurrent;
            //
        }
        return DefinitionActionConfig;
    }());
    exports.DefinitionActionConfig = DefinitionActionConfig;
    var DefinitionAction = (function (_super) {
        __extends(DefinitionAction, _super);
        function DefinitionAction(descriptor, editor, _messageService, _editorService, _configuration) {
            _super.call(this, descriptor, editor, _configuration.condition);
            this._messageService = _messageService;
            this._editorService = _editorService;
            this._configuration = _configuration;
        }
        DefinitionAction.prototype.getGroupId = function () {
            return '1_goto/2_visitDefinition';
        };
        DefinitionAction.prototype.isSupported = function () {
            return modes_1.DefinitionProviderRegistry.has(this.editor.getModel()) && _super.prototype.isSupported.call(this);
        };
        DefinitionAction.prototype.getEnablementState = function () {
            if (!_super.prototype.getEnablementState.call(this)) {
                return false;
            }
            return modes_1.DefinitionProviderRegistry.has(this.editor.getModel());
        };
        DefinitionAction.prototype.run = function () {
            var _this = this;
            var model = this.editor.getModel();
            var pos = this.editor.getPosition();
            return goToDeclaration_1.getDeclarationsAtPosition(model, pos).then(function (references) {
                if (!references) {
                    return;
                }
                // * remove falsy references
                // * remove reference at the current pos
                // * collapse ranges to start pos
                var result = [];
                for (var i = 0; i < references.length; i++) {
                    var reference = references[i];
                    if (!reference) {
                        continue;
                    }
                    var uri = reference.uri, range = reference.range;
                    if (!_this._configuration.filterCurrent
                        || uri.toString() !== model.uri.toString()
                        || !range_1.Range.containsPosition(range, pos)) {
                        result.push({
                            uri: uri,
                            range: range_1.Range.collapseToStart(range)
                        });
                    }
                }
                if (result.length === 0) {
                    return;
                }
                return _this._onResult(new referencesModel_1.ReferencesModel(result));
            }, function (err) {
                // report an error
                _this._messageService.show(severity_1.default.Error, err);
                return false;
            });
        };
        DefinitionAction.prototype._onResult = function (model) {
            var _this = this;
            if (this._configuration.openInPeek) {
                this._openInPeek(this.editor, model);
            }
            else {
                var next = model.nearestReference(this.editor.getModel().uri, this.editor.getPosition());
                this._openReference(next, this._configuration.openToSide).then(function (editor) {
                    if (model.references.length > 1) {
                        _this._openInPeek(editor, model);
                    }
                });
            }
        };
        DefinitionAction.prototype._openReference = function (reference, sideBySide) {
            var uri = reference.uri, range = reference.range;
            return this._editorService.openEditor({ resource: uri, options: { selection: range } }, sideBySide).then(function (editor) {
                return editor.getControl();
            });
        };
        DefinitionAction.prototype._openInPeek = function (target, model) {
            var _this = this;
            var controller = referencesController_1.ReferencesController.getController(target);
            controller.toggleWidget(target.getSelection(), winjs_base_1.TPromise.as(model), {
                getMetaTitle: function (model) {
                    return model.references.length > 1 && nls.localize(0, null, model.references.length);
                },
                onGoto: function (reference) {
                    controller.closeWidget();
                    return _this._openReference(reference, false);
                }
            });
        };
        return DefinitionAction;
    }(editorAction_1.EditorAction));
    exports.DefinitionAction = DefinitionAction;
    var GoToDefinitionAction = (function (_super) {
        __extends(GoToDefinitionAction, _super);
        function GoToDefinitionAction(descriptor, editor, messageService, editorService) {
            _super.call(this, descriptor, editor, messageService, editorService, new DefinitionActionConfig());
        }
        GoToDefinitionAction.ID = 'editor.action.goToDeclaration';
        GoToDefinitionAction = __decorate([
            __param(2, message_1.IMessageService),
            __param(3, editor_1.IEditorService)
        ], GoToDefinitionAction);
        return GoToDefinitionAction;
    }(DefinitionAction));
    exports.GoToDefinitionAction = GoToDefinitionAction;
    var OpenDefinitionToSideAction = (function (_super) {
        __extends(OpenDefinitionToSideAction, _super);
        function OpenDefinitionToSideAction(descriptor, editor, messageService, editorService) {
            _super.call(this, descriptor, editor, messageService, editorService, new DefinitionActionConfig(editorActionEnablement_1.Behaviour.WidgetFocus | editorActionEnablement_1.Behaviour.UpdateOnCursorPositionChange, true));
        }
        OpenDefinitionToSideAction.ID = 'editor.action.openDeclarationToTheSide';
        OpenDefinitionToSideAction = __decorate([
            __param(2, message_1.IMessageService),
            __param(3, editor_1.IEditorService)
        ], OpenDefinitionToSideAction);
        return OpenDefinitionToSideAction;
    }(DefinitionAction));
    exports.OpenDefinitionToSideAction = OpenDefinitionToSideAction;
    var PeekDefinitionAction = (function (_super) {
        __extends(PeekDefinitionAction, _super);
        function PeekDefinitionAction(descriptor, editor, messageService, editorService, _peekViewService) {
            _super.call(this, descriptor, editor, messageService, editorService, new DefinitionActionConfig(void 0, void 0, true, false));
            this._peekViewService = _peekViewService;
        }
        PeekDefinitionAction.prototype.getEnablementState = function () {
            return (!this._peekViewService || !this._peekViewService.isActive)
                && _super.prototype.getEnablementState.call(this);
        };
        PeekDefinitionAction.ID = 'editor.action.previewDeclaration';
        PeekDefinitionAction = __decorate([
            __param(2, message_1.IMessageService),
            __param(3, editor_1.IEditorService),
            __param(4, instantiation_1.optional(peekViewWidget_1.IPeekViewService))
        ], PeekDefinitionAction);
        return PeekDefinitionAction;
    }(DefinitionAction));
    exports.PeekDefinitionAction = PeekDefinitionAction;
    // --- Editor Contribution to goto definition using the mouse and a modifier key
    var GotoDefinitionWithMouseEditorContribution = (function () {
        function GotoDefinitionWithMouseEditorContribution(editor, editorService) {
            var _this = this;
            this.editorService = editorService;
            this.toUnhook = [];
            this.decorations = [];
            this.editor = editor;
            this.throttler = new async_1.Throttler();
            this.toUnhook.push(this.editor.onMouseDown(function (e) { return _this.onEditorMouseDown(e); }));
            this.toUnhook.push(this.editor.onMouseUp(function (e) { return _this.onEditorMouseUp(e); }));
            this.toUnhook.push(this.editor.onMouseMove(function (e) { return _this.onEditorMouseMove(e); }));
            this.toUnhook.push(this.editor.onKeyDown(function (e) { return _this.onEditorKeyDown(e); }));
            this.toUnhook.push(this.editor.onKeyUp(function (e) { return _this.onEditorKeyUp(e); }));
            this.toUnhook.push(this.editor.onDidChangeModel(function (e) { return _this.resetHandler(); }));
            this.toUnhook.push(this.editor.onDidChangeModelContent(function () { return _this.resetHandler(); }));
            this.toUnhook.push(this.editor.onDidScrollChange(function (e) {
                if (e.scrollTopChanged || e.scrollLeftChanged) {
                    _this.resetHandler();
                }
            }));
        }
        GotoDefinitionWithMouseEditorContribution.prototype.onEditorMouseMove = function (mouseEvent, withKey) {
            this.lastMouseMoveEvent = mouseEvent;
            this.startFindDefinition(mouseEvent, withKey);
        };
        GotoDefinitionWithMouseEditorContribution.prototype.startFindDefinition = function (mouseEvent, withKey) {
            var _this = this;
            if (!this.isEnabled(mouseEvent, withKey)) {
                this.currentWordUnderMouse = null;
                this.removeDecorations();
                return;
            }
            // Find word at mouse position
            var position = mouseEvent.target.position;
            var word = position ? this.editor.getModel().getWordAtPosition(position) : null;
            if (!word) {
                this.currentWordUnderMouse = null;
                this.removeDecorations();
                return;
            }
            // Return early if word at position is still the same
            if (this.currentWordUnderMouse && this.currentWordUnderMouse.startColumn === word.startColumn && this.currentWordUnderMouse.endColumn === word.endColumn && this.currentWordUnderMouse.word === word.word) {
                return;
            }
            this.currentWordUnderMouse = word;
            // Find definition and decorate word if found
            var state = this.editor.captureState(editorCommon.CodeEditorStateFlag.Position, editorCommon.CodeEditorStateFlag.Value, editorCommon.CodeEditorStateFlag.Selection, editorCommon.CodeEditorStateFlag.Scroll);
            this.throttler.queue(function () {
                return state.validate(_this.editor)
                    ? _this.findDefinition(mouseEvent.target)
                    : winjs_base_1.TPromise.as(null);
            }).then(function (results) {
                if (!results || !results.length || !state.validate(_this.editor)) {
                    _this.removeDecorations();
                    return;
                }
                // Multiple results
                if (results.length > 1) {
                    _this.addDecoration({
                        startLineNumber: position.lineNumber,
                        startColumn: word.startColumn,
                        endLineNumber: position.lineNumber,
                        endColumn: word.endColumn
                    }, nls.localize(1, null, results.length), false);
                }
                else {
                    var result_1 = results[0];
                    _this.editorService.resolveEditorModel({ resource: result_1.uri }).then(function (model) {
                        var source;
                        if (model && model.textEditorModel) {
                            var from = Math.max(1, result_1.range.startLineNumber), to = void 0, editorModel = void 0;
                            editorModel = model.textEditorModel;
                            // if we have a range, take that into consideration for the "to" position, otherwise fallback to MAX_SOURCE_PREVIEW_LINES
                            if (result_1.range.startLineNumber !== result_1.range.endLineNumber || result_1.range.startColumn !== result_1.range.endColumn) {
                                to = Math.min(result_1.range.endLineNumber, result_1.range.startLineNumber + GotoDefinitionWithMouseEditorContribution.MAX_SOURCE_PREVIEW_LINES, editorModel.getLineCount());
                            }
                            else {
                                to = Math.min(from + GotoDefinitionWithMouseEditorContribution.MAX_SOURCE_PREVIEW_LINES, editorModel.getLineCount());
                            }
                            source = editorModel.getValueInRange({
                                startLineNumber: from,
                                startColumn: 1,
                                endLineNumber: to,
                                endColumn: editorModel.getLineMaxColumn(to)
                            }).trim();
                            // remove common leading whitespace
                            var min = Number.MAX_VALUE, regexp = /^[ \t]*/, match = void 0, contents = void 0;
                            while (from <= to && min > 0) {
                                contents = editorModel.getLineContent(from++);
                                if (contents.trim().length === 0) {
                                    // empty or whitespace only
                                    continue;
                                }
                                match = regexp.exec(contents);
                                min = Math.min(min, match[0].length);
                            }
                            source = source.replace(new RegExp("^([ \\t]{" + min + "})", 'gm'), strings.empty);
                            if (result_1.range.endLineNumber - result_1.range.startLineNumber > GotoDefinitionWithMouseEditorContribution.MAX_SOURCE_PREVIEW_LINES) {
                                source += '\n\u2026';
                            }
                        }
                        _this.addDecoration({
                            startLineNumber: position.lineNumber,
                            startColumn: word.startColumn,
                            endLineNumber: position.lineNumber,
                            endColumn: word.endColumn
                        }, source, true);
                    });
                }
            }).done(undefined, errors_1.onUnexpectedError);
        };
        GotoDefinitionWithMouseEditorContribution.prototype.addDecoration = function (range, text, isCode) {
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            var htmlMessage = void 0;
            ;
            if (text && text.trim().length > 0) {
                if (isCode) {
                    htmlMessage = {
                        language: model.getMode().getId(),
                        value: text
                    };
                }
                else {
                    htmlMessage = htmlContent_1.textToMarkedString(text);
                }
            }
            var newDecorations = {
                range: range,
                options: {
                    inlineClassName: 'goto-definition-link',
                    htmlMessage: [htmlMessage]
                }
            };
            this.decorations = this.editor.deltaDecorations(this.decorations, [newDecorations]);
        };
        GotoDefinitionWithMouseEditorContribution.prototype.removeDecorations = function () {
            if (this.decorations.length > 0) {
                this.decorations = this.editor.deltaDecorations(this.decorations, []);
            }
        };
        GotoDefinitionWithMouseEditorContribution.prototype.onEditorKeyDown = function (e) {
            if (this.lastMouseMoveEvent && (e.keyCode === GotoDefinitionWithMouseEditorContribution.TRIGGER_KEY_VALUE ||
                e.keyCode === GotoDefinitionWithMouseEditorContribution.TRIGGER_SIDEBYSIDE_KEY_VALUE && e[GotoDefinitionWithMouseEditorContribution.TRIGGER_MODIFIER] // User pressed Ctrl/Cmd+Alt (goto definition to the side)
            )) {
                this.startFindDefinition(this.lastMouseMoveEvent, e);
            }
            else if (e[GotoDefinitionWithMouseEditorContribution.TRIGGER_MODIFIER]) {
                this.removeDecorations(); // remove decorations if user holds another key with ctrl/cmd to prevent accident goto declaration
            }
        };
        GotoDefinitionWithMouseEditorContribution.prototype.resetHandler = function () {
            this.lastMouseMoveEvent = null;
            this.removeDecorations();
        };
        GotoDefinitionWithMouseEditorContribution.prototype.onEditorMouseDown = function (mouseEvent) {
            // We need to record if we had the trigger key on mouse down because someone might select something in the editor
            // holding the mouse down and then while mouse is down start to press Ctrl/Cmd to start a copy operation and then
            // release the mouse button without wanting to do the navigation.
            // With this flag we prevent goto definition if the mouse was down before the trigger key was pressed.
            this.hasTriggerKeyOnMouseDown = !!mouseEvent.event[GotoDefinitionWithMouseEditorContribution.TRIGGER_MODIFIER];
        };
        GotoDefinitionWithMouseEditorContribution.prototype.onEditorMouseUp = function (mouseEvent) {
            var _this = this;
            if (this.isEnabled(mouseEvent) && this.hasTriggerKeyOnMouseDown) {
                this.gotoDefinition(mouseEvent.target, mouseEvent.event.altKey).done(function () {
                    _this.removeDecorations();
                }, function (error) {
                    _this.removeDecorations();
                    errors_1.onUnexpectedError(error);
                });
            }
        };
        GotoDefinitionWithMouseEditorContribution.prototype.onEditorKeyUp = function (e) {
            if (e.keyCode === GotoDefinitionWithMouseEditorContribution.TRIGGER_KEY_VALUE) {
                this.removeDecorations();
                this.currentWordUnderMouse = null;
            }
        };
        GotoDefinitionWithMouseEditorContribution.prototype.isEnabled = function (mouseEvent, withKey) {
            return this.editor.getModel() &&
                (browser.isIE11orEarlier || mouseEvent.event.detail <= 1) &&
                mouseEvent.target.type === editorCommon.MouseTargetType.CONTENT_TEXT &&
                (mouseEvent.event[GotoDefinitionWithMouseEditorContribution.TRIGGER_MODIFIER] || (withKey && withKey.keyCode === GotoDefinitionWithMouseEditorContribution.TRIGGER_KEY_VALUE)) &&
                modes_1.DefinitionProviderRegistry.has(this.editor.getModel());
        };
        GotoDefinitionWithMouseEditorContribution.prototype.findDefinition = function (target) {
            var model = this.editor.getModel();
            if (!model) {
                return winjs_base_1.TPromise.as(null);
            }
            return goToDeclaration_1.getDeclarationsAtPosition(this.editor.getModel(), target.position);
        };
        GotoDefinitionWithMouseEditorContribution.prototype.gotoDefinition = function (target, sideBySide) {
            var targetAction = sideBySide
                ? OpenDefinitionToSideAction.ID
                : GoToDefinitionAction.ID;
            // just run the corresponding action
            this.editor.setPosition(target.position);
            return this.editor.getAction(targetAction).run();
        };
        GotoDefinitionWithMouseEditorContribution.prototype.getId = function () {
            return GotoDefinitionWithMouseEditorContribution.ID;
        };
        GotoDefinitionWithMouseEditorContribution.prototype.dispose = function () {
            this.toUnhook = lifecycle_1.dispose(this.toUnhook);
        };
        GotoDefinitionWithMouseEditorContribution.ID = 'editor.contrib.gotodefinitionwithmouse';
        GotoDefinitionWithMouseEditorContribution.TRIGGER_MODIFIER = platform.isMacintosh ? 'metaKey' : 'ctrlKey';
        GotoDefinitionWithMouseEditorContribution.TRIGGER_SIDEBYSIDE_KEY_VALUE = keyCodes_1.KeyCode.Alt;
        GotoDefinitionWithMouseEditorContribution.TRIGGER_KEY_VALUE = platform.isMacintosh ? keyCodes_1.KeyCode.Meta : keyCodes_1.KeyCode.Ctrl;
        GotoDefinitionWithMouseEditorContribution.MAX_SOURCE_PREVIEW_LINES = 7;
        GotoDefinitionWithMouseEditorContribution = __decorate([
            __param(1, editor_1.IEditorService)
        ], GotoDefinitionWithMouseEditorContribution);
        return GotoDefinitionWithMouseEditorContribution;
    }());
    // register actions
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(PeekDefinitionAction, PeekDefinitionAction.ID, nls.localize(2, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.Alt | keyCodes_1.KeyCode.F12,
        linux: { primary: keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.F10 },
    }, 'Peek Definition'));
    var goToDeclarationKb;
    if (platform.isWeb) {
        goToDeclarationKb = keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.F12;
    }
    else {
        goToDeclarationKb = keyCodes_1.KeyCode.F12;
    }
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(GoToDefinitionAction, GoToDefinitionAction.ID, nls.localize(3, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: goToDeclarationKb
    }, 'Go to Definition'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(OpenDefinitionToSideAction, OpenDefinitionToSideAction.ID, nls.localize(4, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.chord(keyCodes_1.KeyMod.CtrlCmd | keyCodes_1.KeyCode.KEY_K, goToDeclarationKb)
    }, 'Open Definition to the Side'));
    editorBrowserExtensions_1.EditorBrowserRegistry.registerEditorContribution(GotoDefinitionWithMouseEditorContribution);
});















define(__m[508], __M([0,1,352,12,29,2,43,15,19,51,21,4,20,25,13,17,95,477,178,179,96]), function (require, exports, nls, keyCodes_1, uri_1, winjs_base_1, editor_1, instantiation_1, keybindingService_1, keybindingsRegistry_1, position_1, range_1, editorAction_1, editorActionEnablement_1, editorCommonExtensions_1, modes_1, peekViewWidget_1, referenceSearch_1, referencesWidget_1, referencesController_1, referencesModel_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    var defaultReferenceSearchOptions = {
        getMetaTitle: function (model) {
            return model.references.length > 1 && nls.localize(0, null, model.references.length);
        }
    };
    var ReferenceAction = (function (_super) {
        __extends(ReferenceAction, _super);
        // state - changes with every invocation
        function ReferenceAction(descriptor, editor, keybindingService, peekViewService) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.WidgetFocus | editorActionEnablement_1.Behaviour.ShowInContextMenu | editorActionEnablement_1.Behaviour.UpdateOnCursorPositionChange);
            this.label = nls.localize(1, null);
            this.peekViewService = peekViewService;
            if (this.peekViewService) {
                keybindingService.createKey(this.peekViewService.contextKey, true);
            }
        }
        ReferenceAction.prototype.getGroupId = function () {
            return '1_goto/4_references';
        };
        ReferenceAction.prototype.isSupported = function () {
            return modes_1.ReferenceProviderRegistry.has(this.editor.getModel()) && _super.prototype.isSupported.call(this);
        };
        ReferenceAction.prototype.getEnablementState = function () {
            if (this.peekViewService && this.peekViewService.isActive) {
                return false;
            }
            return modes_1.ReferenceProviderRegistry.has(this.editor.getModel());
        };
        ReferenceAction.prototype.run = function () {
            var range = this.editor.getSelection();
            var model = this.editor.getModel();
            var references = referenceSearch_1.provideReferences(model, range.getStartPosition()).then(function (references) { return new referencesModel_1.ReferencesModel(references); });
            var controller = referencesController_1.ReferencesController.getController(this.editor);
            return winjs_base_1.TPromise.as(controller.toggleWidget(range, references, defaultReferenceSearchOptions)).then(function () { return true; });
        };
        ReferenceAction.ID = 'editor.action.referenceSearch.trigger';
        ReferenceAction = __decorate([
            __param(2, keybindingService_1.IKeybindingService),
            __param(3, instantiation_1.optional(peekViewWidget_1.IPeekViewService))
        ], ReferenceAction);
        return ReferenceAction;
    }(editorAction_1.EditorAction));
    exports.ReferenceAction = ReferenceAction;
    var findReferencesCommand = function (accessor, resource, position) {
        if (!(resource instanceof uri_1.default)) {
            throw new Error('illegal argument, uri');
        }
        if (!position) {
            throw new Error('illega argument, position');
        }
        return accessor.get(editor_1.IEditorService).openEditor({ resource: resource }).then(function (editor) {
            var control = editor.getControl();
            if (!control || typeof control.getEditorType !== 'function') {
                return;
            }
            var references = referenceSearch_1.provideReferences(control.getModel(), position_1.Position.lift(position)).then(function (references) { return new referencesModel_1.ReferencesModel(references); });
            var controller = referencesController_1.ReferencesController.getController(control);
            var range = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
            return winjs_base_1.TPromise.as(controller.toggleWidget(range, references, defaultReferenceSearchOptions));
        });
    };
    var showReferencesCommand = function (accessor, resource, position, references) {
        if (!(resource instanceof uri_1.default)) {
            throw new Error('illegal argument, uri expected');
        }
        return accessor.get(editor_1.IEditorService).openEditor({ resource: resource }).then(function (editor) {
            var control = editor.getControl();
            if (!control || typeof control.getEditorType !== 'function') {
                return;
            }
            var controller = referencesController_1.ReferencesController.getController(control);
            return winjs_base_1.TPromise.as(controller.toggleWidget(new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column), winjs_base_1.TPromise.as(new referencesModel_1.ReferencesModel(references)), defaultReferenceSearchOptions)).then(function () { return true; });
        });
    };
    // register action
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(ReferenceAction, ReferenceAction.ID, nls.localize(2, null), {
        context: editorCommonExtensions_1.ContextKey.EditorTextFocus,
        primary: keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.F12
    }, 'Find All References'));
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: 'editor.action.findReferences',
        handler: findReferencesCommand,
        weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(50),
        when: null,
        primary: undefined
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: 'editor.action.showReferences',
        handler: showReferencesCommand,
        weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(50),
        when: null,
        primary: undefined,
        description: {
            description: 'Show references at a position in a file',
            args: [
                { name: 'uri', description: 'The text document in which to show references', constraint: uri_1.default },
                { name: 'position', description: 'The position at which to show', constraint: position_1.Position.isIPosition },
                { name: 'locations', description: 'An array of locations.', constraint: Array },
            ]
        }
    });
    function closeActiveReferenceSearch(accessor, args) {
        var outerEditor = peekViewWidget_1.getOuterEditor(accessor, args);
        if (outerEditor) {
            var controller = referencesController_1.ReferencesController.getController(outerEditor);
            controller.closeWidget();
        }
    }
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: 'closeReferenceSearch',
        weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(50),
        primary: keyCodes_1.KeyCode.Escape,
        secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape],
        when: keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(referencesController_1.ctxReferenceSearchVisible), keybindingService_1.KbExpr.not('config.editor.stablePeek')),
        handler: closeActiveReferenceSearch
    });
    keybindingsRegistry_1.KeybindingsRegistry.registerCommandDesc({
        id: 'closeReferenceSearchEditor',
        weight: editorCommonExtensions_1.CommonEditorRegistry.commandWeight(-101),
        primary: keyCodes_1.KeyCode.Escape,
        secondary: [keyCodes_1.KeyMod.Shift | keyCodes_1.KeyCode.Escape],
        when: keybindingService_1.KbExpr.and(keybindingService_1.KbExpr.has(referencesWidget_1.ReferenceWidget.INNER_EDITOR_CONTEXT_KEY), keybindingService_1.KbExpr.not('config.editor.stablePeek')),
        handler: closeActiveReferenceSearch
    });
});

define(__m[509], __M([0,1,29,38,61]), function (require, exports, uri_1, paths, workspace_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    /**
     * Simple IWorkspaceContextService implementation to allow sharing of this service implementation
     * between different layers of the platform.
     */
    var BaseWorkspaceContextService = (function () {
        function BaseWorkspaceContextService(workspace, configuration, options) {
            if (options === void 0) { options = {}; }
            this.serviceId = workspace_1.IWorkspaceContextService;
            this.workspace = workspace;
            this.configuration = configuration;
            this.options = options;
        }
        BaseWorkspaceContextService.prototype.getWorkspace = function () {
            return this.workspace;
        };
        BaseWorkspaceContextService.prototype.getConfiguration = function () {
            return this.configuration;
        };
        BaseWorkspaceContextService.prototype.getOptions = function () {
            return this.options;
        };
        BaseWorkspaceContextService.prototype.isInsideWorkspace = function (resource) {
            if (resource && this.workspace) {
                return paths.isEqualOrParent(resource.fsPath, this.workspace.resource.fsPath);
            }
            return false;
        };
        BaseWorkspaceContextService.prototype.toWorkspaceRelativePath = function (resource) {
            if (this.isInsideWorkspace(resource)) {
                return paths.normalize(paths.relative(this.workspace.resource.fsPath, resource.fsPath));
            }
            return null;
        };
        BaseWorkspaceContextService.prototype.toResource = function (workspaceRelativePath) {
            if (typeof workspaceRelativePath === 'string' && this.workspace) {
                return uri_1.default.file(paths.join(this.workspace.resource.fsPath, workspaceRelativePath));
            }
            return null;
        };
        return BaseWorkspaceContextService;
    }());
    exports.BaseWorkspaceContextService = BaseWorkspaceContextService;
});

define(__m[108], __M([0,1,29,57,388,492,82,391,84,141,67,405,73,42,115,163,36,509,61,54,52,133,72,431,34,444,379,120,79,402,113,504]), function (require, exports, uri_1, configuration_1, contextMenuService_1, contextViewService_1, event_1, eventService_1, extensions_1, instantiationService_1, serviceCollection_1, markerService_1, markers_1, message_1, request_1, storage_1, telemetry_1, baseWorkspaceContextService_1, workspace_1, codeEditorService_1, editorWorkerService_1, editorWorkerServiceImpl_1, modeService_1, modeServiceImpl_1, modelService_1, modelServiceImpl_1, codeEditorServiceImpl_1, simpleServices_1, actions_1, menuService_1, compatWorkerService_1, compatWorkerServiceMain_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function shallowClone(obj) {
        var r = {};
        if (obj) {
            var keys = Object.keys(obj);
            for (var i = 0, len = keys.length; i < len; i++) {
                var key = keys[i];
                r[key] = obj[key];
            }
        }
        return r;
    }
    function ensureStaticPlatformServices(services) {
        services = shallowClone(services);
        var statics = getOrCreateStaticServices(services);
        var keys = Object.keys(statics);
        for (var i = 0, len = keys.length; i < len; i++) {
            var serviceId = keys[i];
            if (!services.hasOwnProperty(serviceId)) {
                services[serviceId] = statics[serviceId];
            }
        }
        return services;
    }
    exports.ensureStaticPlatformServices = ensureStaticPlatformServices;
    function ensureDynamicPlatformServices(domElement, services) {
        var r = [];
        if (typeof services.keybindingService === 'undefined') {
            var keybindingService = new simpleServices_1.StandaloneKeybindingService(services.configurationService, services.messageService, domElement);
            r.push(keybindingService);
            services.keybindingService = keybindingService;
        }
        if (typeof services.contextViewService === 'undefined') {
            var contextViewService = new contextViewService_1.ContextViewService(domElement, services.telemetryService, services.messageService);
            r.push(contextViewService);
            services.contextViewService = contextViewService;
        }
        if (typeof services.contextMenuService === 'undefined') {
            var contextMenuService = new contextMenuService_1.ContextMenuService(domElement, services.telemetryService, services.messageService, contextViewService);
            r.push(contextMenuService);
            services.contextMenuService = contextMenuService;
        }
        return r;
    }
    exports.ensureDynamicPlatformServices = ensureDynamicPlatformServices;
    // The static services represents a map of services that once 1 editor has been created must be used for all subsequent editors
    var staticServices = null;
    function getOrCreateStaticServices(services) {
        if (staticServices) {
            return staticServices;
        }
        services = services || {};
        var serviceCollection = new serviceCollection_1.ServiceCollection();
        var instantiationService = new instantiationService_1.InstantiationService(serviceCollection, true);
        var contextService = services.contextService || new baseWorkspaceContextService_1.BaseWorkspaceContextService({
            resource: uri_1.default.from({ scheme: 'inmemory', authority: 'model', path: '/' }),
            id: null,
            name: null,
            uid: null,
            mtime: null
        }, {});
        serviceCollection.set(workspace_1.IWorkspaceContextService, contextService);
        var telemetryService = services.telemetryService || telemetry_1.NullTelemetryService;
        serviceCollection.set(telemetry_1.ITelemetryService, telemetryService);
        var eventService = services.eventService || new eventService_1.EventService();
        serviceCollection.set(event_1.IEventService, eventService);
        var configurationService = services.configurationService || new simpleServices_1.SimpleConfigurationService(contextService, eventService);
        serviceCollection.set(configuration_1.IConfigurationService, configurationService);
        var messageService = services.messageService || new simpleServices_1.SimpleMessageService();
        serviceCollection.set(message_1.IMessageService, messageService);
        var extensionService = services.extensionService || new simpleServices_1.SimpleExtensionService();
        serviceCollection.set(extensions_1.IExtensionService, extensionService);
        var markerService = services.markerService || new markerService_1.MarkerService();
        serviceCollection.set(markers_1.IMarkerService, markerService);
        var requestService = services.requestService || new simpleServices_1.SimpleEditorRequestService(contextService, telemetryService);
        serviceCollection.set(request_1.IRequestService, requestService);
        var modeService = services.modeService || new modeServiceImpl_1.MainThreadModeServiceImpl(instantiationService, extensionService, configurationService);
        serviceCollection.set(modeService_1.IModeService, modeService);
        var modelService = services.modelService || new modelServiceImpl_1.ModelServiceImpl(markerService, configurationService, messageService);
        serviceCollection.set(modelService_1.IModelService, modelService);
        var compatWorkerService = services.compatWorkerService || new compatWorkerServiceMain_1.MainThreadCompatWorkerService(contextService, modelService);
        serviceCollection.set(compatWorkerService_1.ICompatWorkerService, compatWorkerService);
        var editorWorkerService = services.editorWorkerService || new editorWorkerServiceImpl_1.EditorWorkerServiceImpl(modelService);
        serviceCollection.set(editorWorkerService_1.IEditorWorkerService, editorWorkerService);
        var codeEditorService = services.codeEditorService || new codeEditorServiceImpl_1.CodeEditorServiceImpl();
        serviceCollection.set(codeEditorService_1.ICodeEditorService, codeEditorService);
        var menuService = services.menuService || new menuService_1.MenuService(extensionService);
        serviceCollection.set(actions_1.IMenuService, menuService);
        staticServices = {
            configurationService: configurationService,
            extensionService: extensionService,
            compatWorkerService: compatWorkerService,
            modeService: modeService,
            markerService: markerService,
            menuService: menuService,
            contextService: contextService,
            telemetryService: telemetryService,
            requestService: requestService,
            messageService: messageService,
            modelService: modelService,
            codeEditorService: codeEditorService,
            editorWorkerService: editorWorkerService,
            eventService: eventService,
            storageService: services.storageService || storage_1.NullStorageService,
            instantiationService: instantiationService
        };
        return staticServices;
    }
    exports.getOrCreateStaticServices = getOrCreateStaticServices;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[181], __M([0,1,3,70,15,161,19,36,7,54,52,120,108,94,174]), function (require, exports, lifecycle_1, contextView_1, instantiation_1, keybindingServiceImpl_1, keybindingService_1, telemetry_1, editorCommon_1, codeEditorService_1, editorWorkerService_1, simpleServices_1, standaloneServices_1, codeEditorWidget_1, diffEditorWidget_1) {
    'use strict';
    var StandaloneEditor = (function (_super) {
        __extends(StandaloneEditor, _super);
        function StandaloneEditor(domElement, options, toDispose, instantiationService, codeEditorService, keybindingService, telemetryService, contextViewService) {
            if (keybindingService instanceof keybindingServiceImpl_1.AbstractKeybindingService) {
                keybindingService.setInstantiationService(instantiationService);
            }
            options = options || {};
            _super.call(this, domElement, options, instantiationService, codeEditorService, keybindingService, telemetryService);
            if (keybindingService instanceof simpleServices_1.StandaloneKeybindingService) {
                this._standaloneKeybindingService = keybindingService;
            }
            this._contextViewService = contextViewService;
            this._toDispose2 = toDispose;
            var model = null;
            if (typeof options.model === 'undefined') {
                model = self.monaco.editor.createModel(options.value || '', options.language || 'text/plain');
                this._ownsModel = true;
            }
            else {
                model = options.model;
                delete options.model;
                this._ownsModel = false;
            }
            this._attachModel(model);
            if (model) {
                var e = {
                    oldModelUrl: null,
                    newModelUrl: model.uri
                };
                this.emit(editorCommon_1.EventType.ModelChanged, e);
            }
        }
        StandaloneEditor.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._toDispose2 = lifecycle_1.dispose(this._toDispose2);
        };
        StandaloneEditor.prototype.destroy = function () {
            this.dispose();
        };
        StandaloneEditor.prototype.addCommand = function (keybinding, handler, context) {
            if (!this._standaloneKeybindingService) {
                console.warn('Cannot add command because the editor is configured with an unrecognized KeybindingService');
                return null;
            }
            return this._standaloneKeybindingService.addDynamicKeybinding(keybinding, handler, context);
        };
        StandaloneEditor.prototype.createContextKey = function (key, defaultValue) {
            if (!this._standaloneKeybindingService) {
                console.warn('Cannot create context key because the editor is configured with an unrecognized KeybindingService');
                return null;
            }
            return this._standaloneKeybindingService.createKey(key, defaultValue);
        };
        StandaloneEditor.prototype.addAction = function (descriptor) {
            var _this = this;
            _super.prototype.addAction.call(this, descriptor);
            if (!this._standaloneKeybindingService) {
                console.warn('Cannot add keybinding because the editor is configured with an unrecognized KeybindingService');
                return null;
            }
            if (Array.isArray(descriptor.keybindings)) {
                var handler = function (accessor) {
                    return _this.trigger('keyboard', descriptor.id, null);
                };
                descriptor.keybindings.forEach(function (kb) {
                    _this._standaloneKeybindingService.addDynamicKeybinding(kb, handler, descriptor.keybindingContext, descriptor.id);
                });
            }
        };
        StandaloneEditor.prototype._attachModel = function (model) {
            _super.prototype._attachModel.call(this, model);
            if (this._view) {
                this._contextViewService.setContainer(this._view.domNode);
            }
        };
        StandaloneEditor.prototype._postDetachModelCleanup = function (detachedModel) {
            _super.prototype._postDetachModelCleanup.call(this, detachedModel);
            if (detachedModel && this._ownsModel) {
                detachedModel.destroy();
                this._ownsModel = false;
            }
        };
        StandaloneEditor = __decorate([
            __param(3, instantiation_1.IInstantiationService),
            __param(4, codeEditorService_1.ICodeEditorService),
            __param(5, keybindingService_1.IKeybindingService),
            __param(6, telemetry_1.ITelemetryService),
            __param(7, contextView_1.IContextViewService)
        ], StandaloneEditor);
        return StandaloneEditor;
    }(codeEditorWidget_1.CodeEditorWidget));
    exports.StandaloneEditor = StandaloneEditor;
    var StandaloneDiffEditor = (function (_super) {
        __extends(StandaloneDiffEditor, _super);
        function StandaloneDiffEditor(domElement, options, toDispose, instantiationService, keybindingService, contextViewService, editorWorkerService) {
            if (keybindingService instanceof keybindingServiceImpl_1.AbstractKeybindingService) {
                keybindingService.setInstantiationService(instantiationService);
            }
            _super.call(this, domElement, options, editorWorkerService, instantiationService);
            if (keybindingService instanceof simpleServices_1.StandaloneKeybindingService) {
                this._standaloneKeybindingService = keybindingService;
            }
            this._contextViewService = contextViewService;
            this._toDispose2 = toDispose;
            this._contextViewService.setContainer(this._containerDomElement);
        }
        StandaloneDiffEditor.prototype.dispose = function () {
            _super.prototype.dispose.call(this);
            this._toDispose2 = lifecycle_1.dispose(this._toDispose2);
        };
        StandaloneDiffEditor.prototype.destroy = function () {
            this.dispose();
        };
        StandaloneDiffEditor.prototype.addCommand = function (keybinding, handler, context) {
            if (!this._standaloneKeybindingService) {
                console.warn('Cannot add command because the editor is configured with an unrecognized KeybindingService');
                return null;
            }
            return this._standaloneKeybindingService.addDynamicKeybinding(keybinding, handler, context);
        };
        StandaloneDiffEditor.prototype.createContextKey = function (key, defaultValue) {
            if (!this._standaloneKeybindingService) {
                console.warn('Cannot create context key because the editor is configured with an unrecognized KeybindingService');
                return null;
            }
            return this._standaloneKeybindingService.createKey(key, defaultValue);
        };
        StandaloneDiffEditor.prototype.addAction = function (descriptor) {
            var _this = this;
            _super.prototype.addAction.call(this, descriptor);
            if (!this._standaloneKeybindingService) {
                console.warn('Cannot add keybinding because the editor is configured with an unrecognized KeybindingService');
                return null;
            }
            if (Array.isArray(descriptor.keybindings)) {
                var handler = function (ctx) {
                    return _this.trigger('keyboard', descriptor.id, null);
                };
                descriptor.keybindings.forEach(function (kb) {
                    _this._standaloneKeybindingService.addDynamicKeybinding(kb, handler, descriptor.keybindingContext, descriptor.id);
                });
            }
        };
        StandaloneDiffEditor = __decorate([
            __param(3, instantiation_1.IInstantiationService),
            __param(4, keybindingService_1.IKeybindingService),
            __param(5, contextView_1.IContextViewService),
            __param(6, editorWorkerService_1.IEditorWorkerService)
        ], StandaloneDiffEditor);
        return StandaloneDiffEditor;
    }(diffEditorWidget_1.DiffEditorWidget));
    exports.StandaloneDiffEditor = StandaloneDiffEditor;
    exports.startup = (function () {
        var modesRegistryInitialized = false;
        var setupServicesCalled = false;
        return {
            initStaticServicesIfNecessary: function () {
                if (modesRegistryInitialized) {
                    return;
                }
                modesRegistryInitialized = true;
                standaloneServices_1.getOrCreateStaticServices();
            },
            setupServices: function (services) {
                if (setupServicesCalled) {
                    console.error('Call to monaco.editor.setupServices is ignored because it was called before');
                    return;
                }
                setupServicesCalled = true;
                if (modesRegistryInitialized) {
                    console.error('Call to monaco.editor.setupServices is ignored because other API was called before');
                    return;
                }
                return standaloneServices_1.ensureStaticPlatformServices(services);
            }
        };
    })();
});






define(__m[512], __M([0,1,7,22,14,181,41,108,15,67,141,151,120,133,127,302,442]), function (require, exports, editorCommon, editorBrowser_1, async_1, standaloneCodeEditor_1, scrollableElementOptions_1, standaloneServices_1, instantiation_1, serviceCollection_1, instantiationService_1, colorizer_1, simpleServices_1, editorWorkerServiceImpl_1, diffNavigator_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    function shallowClone(obj) {
        var r = {};
        if (obj) {
            var keys = Object.keys(obj);
            for (var i = 0, len = keys.length; i < len; i++) {
                var key = keys[i];
                r[key] = obj[key];
            }
        }
        return r;
    }
    /**
     * @internal
     */
    function setupServices(services) {
        return standaloneCodeEditor_1.startup.setupServices(services);
    }
    exports.setupServices = setupServices;
    /**
     * Create a new editor under `domElement`.
     * `domElement` should be empty (not contain other dom nodes).
     * The editor will read the size of `domElement`.
     */
    function create(domElement, options, services) {
        standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
        services = shallowClone(services);
        var editorService = null;
        if (!services || !services.editorService) {
            editorService = new simpleServices_1.SimpleEditorService();
            services.editorService = editorService;
        }
        var t = prepareServices(domElement, services);
        var result = t.ctx.instantiationService.createInstance(standaloneCodeEditor_1.StandaloneEditor, domElement, options, t.toDispose);
        if (editorService) {
            editorService.setEditor(result);
        }
        return result;
    }
    exports.create = create;
    /**
     * Create a new diff editor under `domElement`.
     * `domElement` should be empty (not contain other dom nodes).
     * The editor will read the size of `domElement`.
     */
    function createDiffEditor(domElement, options, services) {
        standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
        services = shallowClone(services);
        var editorService = null;
        if (!services || !services.editorService) {
            editorService = new simpleServices_1.SimpleEditorService();
            services.editorService = editorService;
        }
        var t = prepareServices(domElement, services);
        var result = t.ctx.instantiationService.createInstance(standaloneCodeEditor_1.StandaloneDiffEditor, domElement, options, t.toDispose);
        if (editorService) {
            editorService.setEditor(result);
        }
        return result;
    }
    exports.createDiffEditor = createDiffEditor;
    function createDiffNavigator(diffEditor, opts) {
        return new diffNavigator_1.DiffNavigator(diffEditor, opts);
    }
    exports.createDiffNavigator = createDiffNavigator;
    function prepareServices(domElement, services) {
        services = standaloneServices_1.ensureStaticPlatformServices(services);
        var toDispose = standaloneServices_1.ensureDynamicPlatformServices(domElement, services);
        var collection = new serviceCollection_1.ServiceCollection();
        for (var legacyServiceId in services) {
            if (services.hasOwnProperty(legacyServiceId)) {
                var id = instantiation_1.createDecorator(legacyServiceId);
                var service = services[legacyServiceId];
                collection.set(id, service);
            }
        }
        services.instantiationService = new instantiationService_1.InstantiationService(collection);
        return {
            ctx: services,
            toDispose: toDispose
        };
    }
    function doCreateModel(value, mode, uri) {
        var modelService = standaloneServices_1.ensureStaticPlatformServices(null).modelService;
        return modelService.createModel(value, mode, uri);
    }
    /**
     * Create a new editor model.
     * You can specify the language that should be set for this model or let the language be inferred from the `uri`.
     */
    function createModel(value, language, uri) {
        standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
        value = value || '';
        var modeService = standaloneServices_1.ensureStaticPlatformServices(null).modeService;
        if (!language) {
            var path = uri ? uri.path : null;
            var firstLF = value.indexOf('\n');
            var firstLine = value;
            if (firstLF !== -1) {
                firstLine = value.substring(0, firstLF);
            }
            return doCreateModel(value, modeService.getOrCreateModeByFilenameOrFirstLine(path, firstLine), uri);
        }
        return doCreateModel(value, modeService.getOrCreateMode(language), uri);
    }
    exports.createModel = createModel;
    /**
     * Change the language for a model.
     */
    function setModelLanguage(model, language) {
        standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
        var modeService = standaloneServices_1.ensureStaticPlatformServices(null).modeService;
        model.setMode(modeService.getOrCreateMode(language));
    }
    exports.setModelLanguage = setModelLanguage;
    /**
     * Set the markers for a model.
     */
    function setModelMarkers(model, owner, markers) {
        standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
        var markerService = standaloneServices_1.ensureStaticPlatformServices(null).markerService;
        markerService.changeOne(owner, model.uri, markers);
    }
    exports.setModelMarkers = setModelMarkers;
    /**
     * Get the model that has `uri` if it exists.
     */
    function getModel(uri) {
        standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
        var modelService = standaloneServices_1.ensureStaticPlatformServices(null).modelService;
        return modelService.getModel(uri);
    }
    exports.getModel = getModel;
    /**
     * Get all the created models.
     */
    function getModels() {
        standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
        var modelService = standaloneServices_1.ensureStaticPlatformServices(null).modelService;
        return modelService.getModels();
    }
    exports.getModels = getModels;
    /**
     * Emitted when a model is created.
     */
    function onDidCreateModel(listener) {
        standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
        var modelService = standaloneServices_1.ensureStaticPlatformServices(null).modelService;
        return modelService.onModelAdded(listener);
    }
    exports.onDidCreateModel = onDidCreateModel;
    /**
     * Emitted right before a model is disposed.
     */
    function onWillDisposeModel(listener) {
        standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
        var modelService = standaloneServices_1.ensureStaticPlatformServices(null).modelService;
        return modelService.onModelRemoved(listener);
    }
    exports.onWillDisposeModel = onWillDisposeModel;
    /**
     * Emitted when a different language is set to a model.
     */
    function onDidChangeModelLanguage(listener) {
        standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
        var modelService = standaloneServices_1.ensureStaticPlatformServices(null).modelService;
        return modelService.onModelModeChanged(function (e) {
            listener({
                model: e.model,
                oldLanguage: e.oldModeId
            });
        });
    }
    exports.onDidChangeModelLanguage = onDidChangeModelLanguage;
    /**
     * @internal
     */
    function getOrCreateMode(modeId) {
        standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
        var modeService = standaloneServices_1.ensureStaticPlatformServices(null).modeService;
        return modeService.getOrCreateMode(modeId);
    }
    exports.getOrCreateMode = getOrCreateMode;
    /**
     * @internal
     */
    function configureMode(modeId, options) {
        standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
        var modeService = standaloneServices_1.ensureStaticPlatformServices(null).modeService;
        modeService.configureModeById(modeId, options);
    }
    exports.configureMode = configureMode;
    /**
     * @internal
     */
    var MonacoWebWorkerImpl = (function (_super) {
        __extends(MonacoWebWorkerImpl, _super);
        /**
         * @internal
         */
        function MonacoWebWorkerImpl(modelService, opts) {
            _super.call(this, modelService);
            this._foreignModuleId = opts.moduleId;
            this._foreignModuleCreateData = opts.createData || null;
            this._foreignProxy = null;
        }
        MonacoWebWorkerImpl.prototype._getForeignProxy = function () {
            var _this = this;
            if (!this._foreignProxy) {
                this._foreignProxy = new async_1.ShallowCancelThenPromise(this._getProxy().then(function (proxy) {
                    return proxy.loadForeignModule(_this._foreignModuleId, _this._foreignModuleCreateData).then(function (foreignMethods) {
                        _this._foreignModuleId = null;
                        _this._foreignModuleCreateData = null;
                        var proxyMethodRequest = function (method, args) {
                            return proxy.fmr(method, args);
                        };
                        var createProxyMethod = function (method, proxyMethodRequest) {
                            return function () {
                                var args = Array.prototype.slice.call(arguments, 0);
                                return proxyMethodRequest(method, args);
                            };
                        };
                        var foreignProxy = {};
                        for (var i = 0; i < foreignMethods.length; i++) {
                            foreignProxy[foreignMethods[i]] = createProxyMethod(foreignMethods[i], proxyMethodRequest);
                        }
                        return foreignProxy;
                    });
                }));
            }
            return this._foreignProxy;
        };
        MonacoWebWorkerImpl.prototype.getProxy = function () {
            return this._getForeignProxy();
        };
        MonacoWebWorkerImpl.prototype.withSyncedResources = function (resources) {
            var _this = this;
            return this._withSyncedResources(resources).then(function (_) { return _this.getProxy(); });
        };
        return MonacoWebWorkerImpl;
    }(editorWorkerServiceImpl_1.EditorWorkerClient));
    exports.MonacoWebWorkerImpl = MonacoWebWorkerImpl;
    /**
     * Create a new web worker that has model syncing capabilities built in.
     * Specify an AMD module to load that will `create` an object that will be proxied.
     */
    function createWebWorker(opts) {
        standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
        var staticPlatformServices = standaloneServices_1.ensureStaticPlatformServices(null);
        var modelService = staticPlatformServices.modelService;
        return new MonacoWebWorkerImpl(modelService, opts);
    }
    exports.createWebWorker = createWebWorker;
    /**
     * Colorize the contents of `domNode` using attribute `data-lang`.
     */
    function colorizeElement(domNode, options) {
        standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
        var modeService = standaloneServices_1.ensureStaticPlatformServices(null).modeService;
        return colorizer_1.Colorizer.colorizeElement(modeService, domNode, options);
    }
    exports.colorizeElement = colorizeElement;
    /**
     * Colorize `text` using language `languageId`.
     */
    function colorize(text, languageId, options) {
        standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
        var modeService = standaloneServices_1.ensureStaticPlatformServices(null).modeService;
        return colorizer_1.Colorizer.colorize(modeService, text, languageId, options);
    }
    exports.colorize = colorize;
    /**
     * Colorize a line in a model.
     */
    function colorizeModelLine(model, lineNumber, tabSize) {
        if (tabSize === void 0) { tabSize = 4; }
        return colorizer_1.Colorizer.colorizeModelLine(model, lineNumber, tabSize);
    }
    exports.colorizeModelLine = colorizeModelLine;
    /**
     * @internal
     */
    function createMonacoEditorAPI() {
        return {
            // methods
            create: create,
            createDiffEditor: createDiffEditor,
            createDiffNavigator: createDiffNavigator,
            createModel: createModel,
            setModelLanguage: setModelLanguage,
            setModelMarkers: setModelMarkers,
            getModels: getModels,
            getModel: getModel,
            onDidCreateModel: onDidCreateModel,
            onWillDisposeModel: onWillDisposeModel,
            onDidChangeModelLanguage: onDidChangeModelLanguage,
            createWebWorker: createWebWorker,
            colorizeElement: colorizeElement,
            colorize: colorize,
            colorizeModelLine: colorizeModelLine,
            // enums
            ScrollbarVisibility: scrollableElementOptions_1.ScrollbarVisibility,
            WrappingIndent: editorCommon.WrappingIndent,
            OverviewRulerLane: editorCommon.OverviewRulerLane,
            EndOfLinePreference: editorCommon.EndOfLinePreference,
            DefaultEndOfLine: editorCommon.DefaultEndOfLine,
            EndOfLineSequence: editorCommon.EndOfLineSequence,
            TrackedRangeStickiness: editorCommon.TrackedRangeStickiness,
            CursorChangeReason: editorCommon.CursorChangeReason,
            MouseTargetType: editorCommon.MouseTargetType,
            TextEditorCursorStyle: editorCommon.TextEditorCursorStyle,
            ContentWidgetPositionPreference: editorBrowser_1.ContentWidgetPositionPreference,
            OverlayWidgetPositionPreference: editorBrowser_1.OverlayWidgetPositionPreference,
            // classes
            InternalEditorScrollbarOptions: editorCommon.InternalEditorScrollbarOptions,
            EditorWrappingInfo: editorCommon.EditorWrappingInfo,
            InternalEditorViewOptions: editorCommon.InternalEditorViewOptions,
            EditorContribOptions: editorCommon.EditorContribOptions,
            InternalEditorOptions: editorCommon.InternalEditorOptions,
            OverviewRulerPosition: editorCommon.OverviewRulerPosition,
            EditorLayoutInfo: editorCommon.EditorLayoutInfo,
            BareFontInfo: editorCommon.BareFontInfo,
            FontInfo: editorCommon.FontInfo,
            // vars
            EditorType: editorCommon.EditorType,
            Handler: editorCommon.Handler,
            // consts
            KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS: editorCommon.KEYBINDING_CONTEXT_EDITOR_TEXT_FOCUS,
            KEYBINDING_CONTEXT_EDITOR_FOCUS: editorCommon.KEYBINDING_CONTEXT_EDITOR_FOCUS,
            KEYBINDING_CONTEXT_EDITOR_HAS_MULTIPLE_SELECTIONS: editorCommon.KEYBINDING_CONTEXT_EDITOR_HAS_MULTIPLE_SELECTIONS,
            KEYBINDING_CONTEXT_EDITOR_HAS_NON_EMPTY_SELECTION: editorCommon.KEYBINDING_CONTEXT_EDITOR_HAS_NON_EMPTY_SELECTION,
            KEYBINDING_CONTEXT_EDITOR_LANGUAGE_ID: editorCommon.KEYBINDING_CONTEXT_EDITOR_LANGUAGE_ID,
        };
    }
    exports.createMonacoEditorAPI = createMonacoEditorAPI;
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[513], __M([0,1,2,86,85,33,45,108,17,181,4,14,131,140,40]), function (require, exports, winjs_base_1, extensionsRegistry_1, jsonContributionRegistry_1, platform_1, modesRegistry_1, standaloneServices_1, modes, standaloneCodeEditor_1, range_1, async_1, monarchCompile_1, monarchLexer_1, languageConfigurationRegistry_1) {
    'use strict';
    /**
     * Register information about a new language.
     */
    function register(language) {
        modesRegistry_1.ModesRegistry.registerLanguage(language);
    }
    exports.register = register;
    /**
     * Get the information of all the registered languages.
     */
    function getLanguages() {
        var result = [];
        result = result.concat(modesRegistry_1.ModesRegistry.getLanguages());
        result = result.concat(modesRegistry_1.ModesRegistry.getCompatModes());
        return result;
    }
    exports.getLanguages = getLanguages;
    /**
     * An event emitted when a language is first time needed (e.g. a model has it set).
     */
    function onLanguage(languageId, callback) {
        var isDisposed = false;
        extensionsRegistry_1.ExtensionsRegistry.registerOneTimeActivationEventListener('onLanguage:' + languageId, function () {
            if (!isDisposed) {
                callback();
            }
        });
        return {
            dispose: function () { isDisposed = true; }
        };
    }
    exports.onLanguage = onLanguage;
    /**
     * Set the editing configuration for a language.
     */
    function setLanguageConfiguration(languageId, configuration) {
        return languageConfigurationRegistry_1.LanguageConfigurationRegistry.register(languageId, configuration);
    }
    exports.setLanguageConfiguration = setLanguageConfiguration;
    /**
     * Set the tokens provider for a language (manual implementation).
     */
    function setTokensProvider(languageId, provider) {
        standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
        var staticPlatformServices = standaloneServices_1.ensureStaticPlatformServices(null);
        return staticPlatformServices.modeService.registerTokenizationSupport2(languageId, provider);
    }
    exports.setTokensProvider = setTokensProvider;
    /**
     * Set the tokens provider for a language (monarch implementation).
     */
    function setMonarchTokensProvider(languageId, languageDef) {
        standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
        var staticPlatformServices = standaloneServices_1.ensureStaticPlatformServices(null);
        var lexer = monarchCompile_1.compile(languageId, languageDef);
        var modeService = staticPlatformServices.modeService;
        return modeService.registerTokenizationSupport(languageId, function (mode) {
            return monarchLexer_1.createTokenizationSupport(modeService, mode, lexer);
        });
    }
    exports.setMonarchTokensProvider = setMonarchTokensProvider;
    /**
     * Register a reference provider (used by e.g. reference search).
     */
    function registerReferenceProvider(languageId, provider) {
        return modes.ReferenceProviderRegistry.register(languageId, provider);
    }
    exports.registerReferenceProvider = registerReferenceProvider;
    /**
     * Register a rename provider (used by e.g. rename symbol).
     */
    function registerRenameProvider(languageId, provider) {
        return modes.RenameProviderRegistry.register(languageId, provider);
    }
    exports.registerRenameProvider = registerRenameProvider;
    /**
     * Register a signature help provider (used by e.g. paremeter hints).
     */
    function registerSignatureHelpProvider(languageId, provider) {
        return modes.SignatureHelpProviderRegistry.register(languageId, provider);
    }
    exports.registerSignatureHelpProvider = registerSignatureHelpProvider;
    /**
     * Register a hover provider (used by e.g. editor hover).
     */
    function registerHoverProvider(languageId, provider) {
        return modes.HoverProviderRegistry.register(languageId, provider);
    }
    exports.registerHoverProvider = registerHoverProvider;
    /**
     * Register a document symbol provider (used by e.g. outline).
     */
    function registerDocumentSymbolProvider(languageId, provider) {
        return modes.DocumentSymbolProviderRegistry.register(languageId, provider);
    }
    exports.registerDocumentSymbolProvider = registerDocumentSymbolProvider;
    /**
     * Register a document highlight provider (used by e.g. highlight occurences).
     */
    function registerDocumentHighlightProvider(languageId, provider) {
        return modes.DocumentHighlightProviderRegistry.register(languageId, provider);
    }
    exports.registerDocumentHighlightProvider = registerDocumentHighlightProvider;
    /**
     * Register a definition provider (used by e.g. go to definition).
     */
    function registerDefinitionProvider(languageId, provider) {
        return modes.DefinitionProviderRegistry.register(languageId, provider);
    }
    exports.registerDefinitionProvider = registerDefinitionProvider;
    /**
     * Register a code lens provider (used by e.g. inline code lenses).
     */
    function registerCodeLensProvider(languageId, provider) {
        return modes.CodeLensProviderRegistry.register(languageId, provider);
    }
    exports.registerCodeLensProvider = registerCodeLensProvider;
    /**
     * Register a code action provider (used by e.g. quick fix).
     */
    function registerCodeActionProvider(languageId, provider) {
        return modes.CodeActionProviderRegistry.register(languageId, {
            provideCodeActions: function (model, range, token) {
                standaloneCodeEditor_1.startup.initStaticServicesIfNecessary();
                var markerService = standaloneServices_1.ensureStaticPlatformServices(null).markerService;
                var markers = markerService.read({ resource: model.uri }).filter(function (m) {
                    return range_1.Range.areIntersectingOrTouching(m, range);
                });
                return provider.provideCodeActions(model, range, { markers: markers }, token);
            }
        });
    }
    exports.registerCodeActionProvider = registerCodeActionProvider;
    /**
     * Register a formatter that can handle only entire models.
     */
    function registerDocumentFormattingEditProvider(languageId, provider) {
        return modes.DocumentFormattingEditProviderRegistry.register(languageId, provider);
    }
    exports.registerDocumentFormattingEditProvider = registerDocumentFormattingEditProvider;
    /**
     * Register a formatter that can handle a range inside a model.
     */
    function registerDocumentRangeFormattingEditProvider(languageId, provider) {
        return modes.DocumentRangeFormattingEditProviderRegistry.register(languageId, provider);
    }
    exports.registerDocumentRangeFormattingEditProvider = registerDocumentRangeFormattingEditProvider;
    /**
     * Register a formatter than can do formatting as the user types.
     */
    function registerOnTypeFormattingEditProvider(languageId, provider) {
        return modes.OnTypeFormattingEditProviderRegistry.register(languageId, provider);
    }
    exports.registerOnTypeFormattingEditProvider = registerOnTypeFormattingEditProvider;
    /**
     * Register a link provider that can find links in text.
     */
    function registerLinkProvider(languageId, provider) {
        return modes.LinkProviderRegistry.register(languageId, provider);
    }
    exports.registerLinkProvider = registerLinkProvider;
    /**
     * Register a completion item provider (use by e.g. suggestions).
     */
    function registerCompletionItemProvider(languageId, provider) {
        var adapter = new SuggestAdapter(provider);
        return modes.SuggestRegistry.register(languageId, {
            triggerCharacters: provider.triggerCharacters,
            shouldAutotriggerSuggest: true,
            provideCompletionItems: function (model, position, token) {
                return adapter.provideCompletionItems(model, position, token);
            },
            resolveCompletionItem: function (model, position, suggestion, token) {
                return adapter.resolveCompletionItem(model, position, suggestion, token);
            }
        });
    }
    exports.registerCompletionItemProvider = registerCompletionItemProvider;
    /**
     * Completion item kinds.
     */
    (function (CompletionItemKind) {
        CompletionItemKind[CompletionItemKind["Text"] = 0] = "Text";
        CompletionItemKind[CompletionItemKind["Method"] = 1] = "Method";
        CompletionItemKind[CompletionItemKind["Function"] = 2] = "Function";
        CompletionItemKind[CompletionItemKind["Constructor"] = 3] = "Constructor";
        CompletionItemKind[CompletionItemKind["Field"] = 4] = "Field";
        CompletionItemKind[CompletionItemKind["Variable"] = 5] = "Variable";
        CompletionItemKind[CompletionItemKind["Class"] = 6] = "Class";
        CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
        CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
        CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
        CompletionItemKind[CompletionItemKind["Unit"] = 10] = "Unit";
        CompletionItemKind[CompletionItemKind["Value"] = 11] = "Value";
        CompletionItemKind[CompletionItemKind["Enum"] = 12] = "Enum";
        CompletionItemKind[CompletionItemKind["Keyword"] = 13] = "Keyword";
        CompletionItemKind[CompletionItemKind["Snippet"] = 14] = "Snippet";
        CompletionItemKind[CompletionItemKind["Color"] = 15] = "Color";
        CompletionItemKind[CompletionItemKind["File"] = 16] = "File";
        CompletionItemKind[CompletionItemKind["Reference"] = 17] = "Reference";
    })(exports.CompletionItemKind || (exports.CompletionItemKind = {}));
    var CompletionItemKind = exports.CompletionItemKind;
    function convertKind(kind) {
        switch (kind) {
            case CompletionItemKind.Function: return 'function';
            case CompletionItemKind.Constructor: return 'constructor';
            case CompletionItemKind.Field: return 'field';
            case CompletionItemKind.Variable: return 'variable';
            case CompletionItemKind.Class: return 'class';
            case CompletionItemKind.Interface: return 'interface';
            case CompletionItemKind.Module: return 'module';
            case CompletionItemKind.Property: return 'property';
            case CompletionItemKind.Unit: return 'unit';
            case CompletionItemKind.Value: return 'value';
            case CompletionItemKind.Enum: return 'enum';
            case CompletionItemKind.Keyword: return 'keyword';
            case CompletionItemKind.Snippet: return 'snippet';
            case CompletionItemKind.Text: return 'text';
            case CompletionItemKind.Color: return 'color';
            case CompletionItemKind.File: return 'file';
            case CompletionItemKind.Reference: return 'reference';
        }
        return 'property';
    }
    var SuggestAdapter = (function () {
        function SuggestAdapter(provider) {
            this._provider = provider;
        }
        SuggestAdapter.from = function (item) {
            return {
                _actual: item,
                label: item.label,
                codeSnippet: item.insertText || item.label,
                type: convertKind(item.kind),
                typeLabel: item.detail,
                documentationLabel: item.documentation,
                sortText: item.sortText,
                filterText: item.filterText
            };
        };
        SuggestAdapter.prototype.provideCompletionItems = function (model, position, token) {
            var ran = model.getWordAtPosition(position);
            return async_1.toThenable(this._provider.provideCompletionItems(model, position, token)).then(function (value) {
                var list;
                if (Array.isArray(value)) {
                    list = {
                        items: value,
                        isIncomplete: false
                    };
                }
                else if (typeof value === 'object' && Array.isArray(value.items)) {
                    list = value;
                }
                else if (!value) {
                    // undefined and null are valid results
                    return;
                }
                else {
                    // warn about everything else
                    console.warn('INVALID result from completion provider. expected CompletionItem-array or CompletionList but got:', value);
                }
                var defaultSuggestions = {
                    suggestions: [],
                    currentWord: ran ? model.getValueInRange(new range_1.Range(position.lineNumber, ran.startColumn, position.lineNumber, ran.endColumn)) : '',
                };
                var allSuggestions = [defaultSuggestions];
                for (var i = 0; i < list.items.length; i++) {
                    var item = list.items[i];
                    var suggestion = SuggestAdapter.from(item);
                    if (item.textEdit) {
                        var editRange = item.textEdit.range;
                        var isSingleLine = (editRange.startLineNumber === editRange.endLineNumber);
                        // invalid text edit
                        if (!isSingleLine || editRange.startLineNumber !== position.lineNumber) {
                            console.warn('INVALID text edit, must be single line and on the same line');
                            continue;
                        }
                        // insert the text of the edit and create a dedicated
                        // suggestion-container with overwrite[Before|After]
                        suggestion.codeSnippet = item.textEdit.text;
                        suggestion.overwriteBefore = position.column - editRange.startColumn;
                        suggestion.overwriteAfter = editRange.endColumn - position.column;
                        allSuggestions.push({
                            currentWord: model.getValueInRange(editRange),
                            suggestions: [suggestion],
                            incomplete: list.isIncomplete
                        });
                    }
                    else {
                        defaultSuggestions.suggestions.push(suggestion);
                    }
                }
                return allSuggestions;
            });
        };
        SuggestAdapter.prototype.resolveCompletionItem = function (model, position, suggestion, token) {
            if (typeof this._provider.resolveCompletionItem !== 'function') {
                return winjs_base_1.TPromise.as(suggestion);
            }
            var item = suggestion._actual;
            if (!item) {
                return winjs_base_1.TPromise.as(suggestion);
            }
            return async_1.toThenable(this._provider.resolveCompletionItem(item, token)).then(function (resolvedItem) {
                return SuggestAdapter.from(resolvedItem);
            });
        };
        return SuggestAdapter;
    }());
    /**
     * @internal
     */
    function registerStandaloneSchema(uri, schema) {
        var schemaRegistry = platform_1.Registry.as(jsonContributionRegistry_1.Extensions.JSONContribution);
        schemaRegistry.registerSchema(uri, schema);
    }
    exports.registerStandaloneSchema = registerStandaloneSchema;
    /**
     * @internal
     */
    function createMonacoLanguagesAPI() {
        return {
            register: register,
            getLanguages: getLanguages,
            onLanguage: onLanguage,
            // provider methods
            setLanguageConfiguration: setLanguageConfiguration,
            setTokensProvider: setTokensProvider,
            setMonarchTokensProvider: setMonarchTokensProvider,
            registerReferenceProvider: registerReferenceProvider,
            registerRenameProvider: registerRenameProvider,
            registerCompletionItemProvider: registerCompletionItemProvider,
            registerSignatureHelpProvider: registerSignatureHelpProvider,
            registerHoverProvider: registerHoverProvider,
            registerDocumentSymbolProvider: registerDocumentSymbolProvider,
            registerDocumentHighlightProvider: registerDocumentHighlightProvider,
            registerDefinitionProvider: registerDefinitionProvider,
            registerCodeLensProvider: registerCodeLensProvider,
            registerCodeActionProvider: registerCodeActionProvider,
            registerDocumentFormattingEditProvider: registerDocumentFormattingEditProvider,
            registerDocumentRangeFormattingEditProvider: registerDocumentRangeFormattingEditProvider,
            registerOnTypeFormattingEditProvider: registerOnTypeFormattingEditProvider,
            registerLinkProvider: registerLinkProvider,
            // enums
            DocumentHighlightKind: modes.DocumentHighlightKind,
            CompletionItemKind: CompletionItemKind,
            SymbolKind: modes.SymbolKind,
            IndentAction: modes.IndentAction
        };
    }
    exports.createMonacoLanguagesAPI = createMonacoLanguagesAPI;
});

define(__m[514], __M([0,1,15]), function (require, exports, instantiation_1) {
    /*---------------------------------------------------------------------------------------------
     *  Copyright (c) Microsoft Corporation. All rights reserved.
     *  Licensed under the MIT License. See License.txt in the project root for license information.
     *--------------------------------------------------------------------------------------------*/
    'use strict';
    exports.IQuickOpenService = instantiation_1.createDecorator('quickOpenService');
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/














define(__m[198], __M([0,1,337,2,20,13,499,514,34,25]), function (require, exports, nls, winjs_base_1, editorAction_1, editorCommonExtensions_1, indentationCommands_1, quickOpenService_1, modelService_1, editorActionEnablement_1) {
    "use strict";
    var IndentationToSpacesAction = (function (_super) {
        __extends(IndentationToSpacesAction, _super);
        function IndentationToSpacesAction(descriptor, editor) {
            _super.call(this, descriptor, editor);
        }
        IndentationToSpacesAction.prototype.run = function () {
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            var modelOpts = model.getOptions();
            var command = new indentationCommands_1.IndentationToSpacesCommand(this.editor.getSelection(), modelOpts.tabSize);
            this.editor.executeCommands(this.id, [command]);
            model.updateOptions({
                insertSpaces: true
            });
            return winjs_base_1.TPromise.as(true);
        };
        IndentationToSpacesAction.ID = 'editor.action.indentationToSpaces';
        return IndentationToSpacesAction;
    }(editorAction_1.EditorAction));
    exports.IndentationToSpacesAction = IndentationToSpacesAction;
    var IndentationToTabsAction = (function (_super) {
        __extends(IndentationToTabsAction, _super);
        function IndentationToTabsAction(descriptor, editor) {
            _super.call(this, descriptor, editor);
        }
        IndentationToTabsAction.prototype.run = function () {
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            var modelOpts = model.getOptions();
            var command = new indentationCommands_1.IndentationToTabsCommand(this.editor.getSelection(), modelOpts.tabSize);
            this.editor.executeCommands(this.id, [command]);
            model.updateOptions({
                insertSpaces: false
            });
            return winjs_base_1.TPromise.as(true);
        };
        IndentationToTabsAction.ID = 'editor.action.indentationToTabs';
        return IndentationToTabsAction;
    }(editorAction_1.EditorAction));
    exports.IndentationToTabsAction = IndentationToTabsAction;
    var ChangeIndentationSizeAction = (function (_super) {
        __extends(ChangeIndentationSizeAction, _super);
        function ChangeIndentationSizeAction(descriptor, editor, insertSpaces, quickOpenService, modelService) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.Writeable);
            this.insertSpaces = insertSpaces;
            this.quickOpenService = quickOpenService;
            this.modelService = modelService;
        }
        ChangeIndentationSizeAction.prototype.run = function () {
            var _this = this;
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            var creationOpts = this.modelService.getCreationOptions();
            var picks = [1, 2, 3, 4, 5, 6, 7, 8].map(function (n) { return ({
                id: n.toString(),
                label: n.toString(),
                // add description for tabSize value set in the configuration
                description: n === creationOpts.tabSize ? nls.localize(0, null) : null
            }); });
            // auto focus the tabSize set for the current editor
            var autoFocusIndex = Math.min(model.getOptions().tabSize - 1, 7);
            return winjs_base_1.TPromise.timeout(50 /* quick open is sensitive to being opened so soon after another */).then(function () {
                return _this.quickOpenService.pick(picks, { placeHolder: nls.localize(1, null), autoFocus: { autoFocusIndex: autoFocusIndex } }).then(function (pick) {
                    if (pick) {
                        model.updateOptions({
                            tabSize: parseInt(pick.label, 10),
                            insertSpaces: _this.insertSpaces
                        });
                    }
                    return true;
                });
            });
        };
        return ChangeIndentationSizeAction;
    }(editorAction_1.EditorAction));
    exports.ChangeIndentationSizeAction = ChangeIndentationSizeAction;
    var IndentUsingTabs = (function (_super) {
        __extends(IndentUsingTabs, _super);
        function IndentUsingTabs(descriptor, editor, quickOpenService, modelService) {
            _super.call(this, descriptor, editor, false, quickOpenService, modelService);
        }
        IndentUsingTabs.ID = 'editor.action.indentUsingTabs';
        IndentUsingTabs = __decorate([
            __param(2, quickOpenService_1.IQuickOpenService),
            __param(3, modelService_1.IModelService)
        ], IndentUsingTabs);
        return IndentUsingTabs;
    }(ChangeIndentationSizeAction));
    exports.IndentUsingTabs = IndentUsingTabs;
    var IndentUsingSpaces = (function (_super) {
        __extends(IndentUsingSpaces, _super);
        function IndentUsingSpaces(descriptor, editor, quickOpenService, modelService) {
            _super.call(this, descriptor, editor, true, quickOpenService, modelService);
        }
        IndentUsingSpaces.ID = 'editor.action.indentUsingSpaces';
        IndentUsingSpaces = __decorate([
            __param(2, quickOpenService_1.IQuickOpenService),
            __param(3, modelService_1.IModelService)
        ], IndentUsingSpaces);
        return IndentUsingSpaces;
    }(ChangeIndentationSizeAction));
    exports.IndentUsingSpaces = IndentUsingSpaces;
    var DetectIndentation = (function (_super) {
        __extends(DetectIndentation, _super);
        function DetectIndentation(descriptor, editor, modelService) {
            _super.call(this, descriptor, editor);
            this.modelService = modelService;
        }
        DetectIndentation.prototype.run = function () {
            var model = this.editor.getModel();
            if (!model) {
                return;
            }
            var creationOpts = this.modelService.getCreationOptions();
            model.detectIndentation(creationOpts.insertSpaces, creationOpts.tabSize);
        };
        DetectIndentation.ID = 'editor.action.detectIndentation';
        DetectIndentation = __decorate([
            __param(2, modelService_1.IModelService)
        ], DetectIndentation);
        return DetectIndentation;
    }(editorAction_1.EditorAction));
    exports.DetectIndentation = DetectIndentation;
    var ToggleRenderWhitespaceAction = (function (_super) {
        __extends(ToggleRenderWhitespaceAction, _super);
        function ToggleRenderWhitespaceAction(descriptor, editor) {
            _super.call(this, descriptor, editor, editorActionEnablement_1.Behaviour.TextFocus);
        }
        ToggleRenderWhitespaceAction.prototype.run = function () {
            this.editor.updateOptions({
                renderWhitespace: !this.editor.getConfiguration().viewInfo.renderWhitespace
            });
            return winjs_base_1.TPromise.as(true);
        };
        ToggleRenderWhitespaceAction.ID = 'editor.action.toggleRenderWhitespace';
        return ToggleRenderWhitespaceAction;
    }(editorAction_1.EditorAction));
    exports.ToggleRenderWhitespaceAction = ToggleRenderWhitespaceAction;
    // register actions
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(IndentationToSpacesAction, IndentationToSpacesAction.ID, nls.localize(2, null), void 0, 'Convert Indentation to Spaces'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(IndentationToTabsAction, IndentationToTabsAction.ID, nls.localize(3, null), void 0, 'Convert Indentation to Tabs'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(IndentUsingSpaces, IndentUsingSpaces.ID, nls.localize(4, null), void 0, 'Indent Using Spaces'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(IndentUsingTabs, IndentUsingTabs.ID, nls.localize(5, null), void 0, 'Indent Using Tabs'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(DetectIndentation, DetectIndentation.ID, nls.localize(6, null), void 0, 'Detect Indentation from Content'));
    editorCommonExtensions_1.CommonEditorRegistry.registerEditorAction(new editorCommonExtensions_1.EditorActionDescriptor(ToggleRenderWhitespaceAction, ToggleRenderWhitespaceAction.ID, nls.localize(7, null), void 0, 'Toggle Render Whitespace'));
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[420], __M([0,1,94,174,489,446,448,449,450,127,452,455,507,468,459,223,460,412,461,445,462,463,474,466,470,508,479,481,480,93,506,487,171,490,242,491,483,453,198,503]), function (require, exports) {
    'use strict';
});

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
define(__m[517], __M([0,1,169,512,513,55,420,476,471,472,433,417]), function (require, exports, standaloneBase_1, standaloneEditor_1, standaloneLanguages_1, defaultConfig_1) {
    'use strict';
    // Set defaults for standalone editor
    defaultConfig_1.DefaultConfig.editor.wrappingIndent = 'none';
    defaultConfig_1.DefaultConfig.editor.folding = false;
    var global = self;
    global.monaco = standaloneBase_1.createMonacoBaseAPI();
    global.monaco.editor = standaloneEditor_1.createMonacoEditorAPI();
    global.monaco.languages = standaloneLanguages_1.createMonacoLanguagesAPI();
    // Register all built-in standalone JSON schemas
    var MonacoEditorSchemas = global.MonacoEditorSchemas || {};
    for (var uri in MonacoEditorSchemas) {
        standaloneLanguages_1.registerStandaloneSchema(uri, MonacoEditorSchemas[uri]);
    }
});

}).call(this);

/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * monaco-typescript version: 0.5.0(1ea9e2f88b719775dbe4715d1411bcd025dbdc43)
 * Released under the MIT license
 * https://github.com/Microsoft/monaco-typescript/blob/master/LICENSE.md
 *-----------------------------------------------------------------------------*/
define("vs/language/typescript/src/monaco.contribution",["require","exports","vs/editor/edcore.main"],function(e,t){function n(){return{ModuleKind:s,JsxEmit:r,NewLineKind:c,ScriptTarget:p,ModuleResolutionKind:u,typescriptDefaults:l,javascriptDefaults:g}}function i(t){e(["vs/language/typescript/src/mode"],t)}var o=monaco.Emitter,a=function(){function e(e,t){this._onDidChange=new o,this._extraLibs=Object.create(null),this.setCompilerOptions(e),this.setDiagnosticsOptions(t)}return Object.defineProperty(e.prototype,"onDidChange",{get:function(){return this._onDidChange.event},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"extraLibs",{get:function(){return Object.freeze(this._extraLibs)},enumerable:!0,configurable:!0}),e.prototype.addExtraLib=function(e,t){var n=this;if("undefined"==typeof t&&(t="ts:extralib-"+Date.now()),this._extraLibs[t])throw new Error(t+" already a extra lib");return this._extraLibs[t]=e,this._onDidChange.fire(this),{dispose:function(){delete n._extraLibs[t]&&n._onDidChange.fire(n)}}},Object.defineProperty(e.prototype,"compilerOptions",{get:function(){return this._compilerOptions},enumerable:!0,configurable:!0}),e.prototype.setCompilerOptions=function(e){this._compilerOptions=e||Object.create(null),this._onDidChange.fire(this)},Object.defineProperty(e.prototype,"diagnosticsOptions",{get:function(){return this._diagnosticsOptions},enumerable:!0,configurable:!0}),e.prototype.setDiagnosticsOptions=function(e){this._diagnosticsOptions=e||Object.create(null),this._onDidChange.fire(this)},e}();t.LanguageServiceDefaultsImpl=a;var s;!function(e){e[e.None=0]="None",e[e.CommonJS=1]="CommonJS",e[e.AMD=2]="AMD",e[e.UMD=3]="UMD",e[e.System=4]="System",e[e.ES6=5]="ES6",e[e.ES2015=5]="ES2015"}(s||(s={}));var r;!function(e){e[e.None=0]="None",e[e.Preserve=1]="Preserve",e[e.React=2]="React"}(r||(r={}));var c;!function(e){e[e.CarriageReturnLineFeed=0]="CarriageReturnLineFeed",e[e.LineFeed=1]="LineFeed"}(c||(c={}));var p;!function(e){e[e.ES3=0]="ES3",e[e.ES5=1]="ES5",e[e.ES6=2]="ES6",e[e.ES2015=2]="ES2015",e[e.Latest=2]="Latest"}(p||(p={}));var u;!function(e){e[e.Classic=1]="Classic",e[e.NodeJs=2]="NodeJs"}(u||(u={}));var l=new a({allowNonTsExtensions:!0,target:p.Latest},{noSemanticValidation:!1,noSyntaxValidation:!1}),g=new a({allowNonTsExtensions:!0,allowJs:!0,target:p.Latest},{noSemanticValidation:!0,noSyntaxValidation:!1});monaco.languages.typescript=n(),monaco.languages.register({id:"typescript",extensions:[".ts"],aliases:["TypeScript","ts","typescript"],mimetypes:["text/typescript"]}),monaco.languages.onLanguage("typescript",function(){i(function(e){return e.setupTypeScript(l)})}),monaco.languages.register({id:"javascript",extensions:[".js",".es6"],firstLine:"^#!.*\\bnode",filenames:["jakefile"],aliases:["JavaScript","javascript","js"],mimetypes:["text/javascript"]}),monaco.languages.onLanguage("javascript",function(){i(function(e){return e.setupJavaScript(g)})})});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * monaco-css version: 1.1.1(a95094a5990b443cead16f31c374a3c8c2966bfe)
 * Released under the MIT license
 * https://github.com/Microsoft/monaco-css/blob/master/LICENSE.md
 *-----------------------------------------------------------------------------*/
!function(e){if("object"==typeof module&&"object"==typeof module.exports){var n=e(require,exports);void 0!==n&&(module.exports=n)}else"function"==typeof define&&define.amd&&define("vs/language/css/monaco.contribution",["require","exports","vs/editor/edcore.main"],e)}(function(e,n){function o(){return{cssDefaults:a,lessDefaults:g,scssDefaults:u}}function t(n){e(["vs/language/css/cssMode"],n)}var i=monaco.Emitter,r=function(){function e(e,n){this._onDidChange=new i,this._languageId=e,this.setDiagnosticsOptions(n)}return Object.defineProperty(e.prototype,"onDidChange",{get:function(){return this._onDidChange.event},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"languageId",{get:function(){return this._languageId},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"diagnosticsOptions",{get:function(){return this._diagnosticsOptions},enumerable:!0,configurable:!0}),e.prototype.setDiagnosticsOptions=function(e){this._diagnosticsOptions=e||Object.create(null),this._onDidChange.fire(this)},e}();n.LanguageServiceDefaultsImpl=r;var s={validate:!0,lint:{compatibleVendorPrefixes:"ignore",vendorPrefix:"warning",duplicateProperties:"warning",emptyRules:"warning",importStatement:"ignore",boxModel:"ignore",universalSelector:"ignore",zeroUnits:"ignore",fontFaceProperties:"warning",hexColorLength:"error",argumentsInColorFunction:"error",unknownProperties:"warning",ieHack:"ignore",unknownVendorSpecificProperties:"ignore",propertyIgnoredDueToDisplay:"warning",important:"ignore","float":"ignore",idSelector:"ignore"}},a=new r("css",s),u=new r("scss",s),g=new r("less",s);monaco.languages.css=o(),monaco.languages.onLanguage("less",function(){t(function(e){return e.setupMode(g)})}),monaco.languages.onLanguage("scss",function(){t(function(e){return e.setupMode(u)})}),monaco.languages.onLanguage("css",function(){t(function(e){return e.setupMode(a)})})});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * monaco-json version: 1.0.2(7e50cccbb2e8248ffbdbae54ca440f2714dbc945)
 * Released under the MIT license
 * https://github.com/Microsoft/monaco-json/blob/master/LICENSE.md
 *-----------------------------------------------------------------------------*/
!function(e){if("object"==typeof module&&"object"==typeof module.exports){var n=e(require,exports);void 0!==n&&(module.exports=n)}else"function"==typeof define&&define.amd&&define("vs/language/json/monaco.contribution",["require","exports","vs/editor/edcore.main"],e)}(function(e,n){function o(){return{jsonDefaults:r}}function t(n){e(["vs/language/json/jsonMode"],n)}var i=monaco.Emitter,s=function(){function e(e,n){this._onDidChange=new i,this._languageId=e,this.setDiagnosticsOptions(n)}return Object.defineProperty(e.prototype,"onDidChange",{get:function(){return this._onDidChange.event},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"languageId",{get:function(){return this._languageId},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"diagnosticsOptions",{get:function(){return this._diagnosticsOptions},enumerable:!0,configurable:!0}),e.prototype.setDiagnosticsOptions=function(e){this._diagnosticsOptions=e||Object.create(null),this._onDidChange.fire(this)},e}();n.LanguageServiceDefaultsImpl=s;var a={validate:!0,allowComments:!0,schemas:[]},r=new s("json",a);monaco.languages.json=o(),monaco.languages.register({id:"json",extensions:[".json",".bowerrc",".jshintrc",".jscsrc",".eslintrc",".babelrc"],aliases:["JSON","json"],mimetypes:["application/json"]}),monaco.languages.onLanguage("json",function(){t(function(e){return e.setupMode(r)})})});
/*!-----------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * monaco-languages version: 0.3.1(584d8ebb961d96d42dd7ae89ff3803c825b8862d)
 * Released under the MIT license
 * https://github.com/Microsoft/monaco-languages/blob/master/LICENSE.md
 *-----------------------------------------------------------------------------*/
define("vs/basic-languages/src/monaco.contribution",["require","exports","vs/editor/edcore.main"],function(e,s){function i(s){var i=n[s].module;return new o.Promise(function(a,n,t){e([i],function(e){o.languages.setMonarchTokensProvider(s,e.language),o.languages.setLanguageConfiguration(s,e.conf),a(void 0)},n)})}function a(e){var s=e.id;n[s]=e,o.languages.register(e),o.languages.onLanguage(s,function(){i(s)})}var o="undefined"==typeof monaco?self.monaco:monaco,n={};s.loadLanguage=i,a({id:"bat",extensions:[".bat",".cmd"],aliases:["Batch","bat"],module:"./bat"}),a({id:"coffeescript",extensions:[".coffee"],aliases:["CoffeeScript","coffeescript","coffee"],mimetypes:["text/x-coffeescript","text/coffeescript"],module:"./coffee"}),a({id:"c",extensions:[".c",".h"],aliases:["C","c"],module:"./cpp"}),a({id:"cpp",extensions:[".cpp",".cc",".cxx",".hpp",".hh",".hxx"],aliases:["C++","Cpp","cpp"],module:"./cpp"}),a({id:"csharp",extensions:[".cs",".csx"],aliases:["C#","csharp"],module:"./csharp"}),a({id:"dockerfile",extensions:[".dockerfile"],filenames:["Dockerfile"],aliases:["Dockerfile"],module:"./dockerfile"}),a({id:"fsharp",extensions:[".fs",".fsi",".ml",".mli",".fsx",".fsscript"],aliases:["F#","FSharp","fsharp"],module:"./fsharp"}),a({id:"go",extensions:[".go"],aliases:["Go"],module:"./go"}),a({id:"ini",extensions:[".ini",".properties",".gitconfig"],filenames:["config",".gitattributes",".gitconfig",".editorconfig"],aliases:["Ini","ini"],module:"./ini"}),a({id:"jade",extensions:[".jade",".pug"],aliases:["Jade","jade"],module:"./jade"}),a({id:"java",extensions:[".java",".jav"],aliases:["Java","java"],mimetypes:["text/x-java-source","text/x-java"],module:"./java"}),a({id:"lua",extensions:[".lua"],aliases:["Lua","lua"],module:"./lua"}),a({id:"markdown",extensions:[".md",".markdown",".mdown",".mkdn",".mkd",".mdwn",".mdtxt",".mdtext"],aliases:["Markdown","markdown"],module:"./markdown"}),a({id:"objective-c",extensions:[".m"],aliases:["Objective-C"],module:"./objective-c"}),a({id:"powershell",extensions:[".ps1",".psm1",".psd1"],aliases:["PowerShell","powershell","ps","ps1"],module:"./powershell"}),a({id:"python",extensions:[".py",".rpy",".pyw",".cpy",".gyp",".gypi"],aliases:["Python","py"],firstLine:"^#!/.*\\bpython[0-9.-]*\\b",module:"./python"}),a({id:"r",extensions:[".r",".rhistory",".rprofile",".rt"],aliases:["R","r"],module:"./r"}),a({id:"ruby",extensions:[".rb",".rbx",".rjs",".gemspec",".pp"],filenames:["rakefile"],aliases:["Ruby","rb"],module:"./ruby"}),a({id:"swift",aliases:["Swift","swift"],extensions:[".swift"],mimetypes:["text/swift"],module:"./swift"}),a({id:"sql",extensions:[".sql"],aliases:["SQL"],module:"./sql"}),a({id:"vb",extensions:[".vb"],aliases:["Visual Basic","vb"],module:"./vb"}),a({id:"xml",extensions:[".xml",".dtd",".ascx",".csproj",".config",".wxi",".wxl",".wxs",".xaml",".svg",".svgz"],firstLine:"(\\<\\?xml.*)|(\\<svg)|(\\<\\!doctype\\s+svg)",aliases:["XML","xml"],mimetypes:["text/xml","application/xml","application/xaml+xml","application/xml-dtd"],module:"./xml"}),a({id:"less",extensions:[".less"],aliases:["Less","less"],mimetypes:["text/x-less","text/less"],module:"./less"}),a({id:"scss",extensions:[".scss"],aliases:["Sass","sass","scss"],mimetypes:["text/x-scss","text/scss"],module:"./scss"}),a({id:"css",extensions:[".css"],aliases:["CSS","css"],mimetypes:["text/css"],module:"./css"})});
define("vs/editor/editor.main", ["vs/editor/edcore.main","vs/language/typescript/src/monaco.contribution","vs/language/css/monaco.contribution","vs/language/json/monaco.contribution","vs/basic-languages/src/monaco.contribution"], function() {});
//# sourceMappingURL=editor.main.js.map
