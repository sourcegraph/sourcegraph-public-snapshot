{"version":3,"file":"install.js","sourceRoot":"","sources":["../src/install.ts"],"names":[],"mappings":"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","sourcesContent":["import extend = require('xtend')\nimport Promise = require('any-promise')\nimport { dirname, join } from 'path'\nimport { EventEmitter } from 'events'\nimport { resolveDependency, resolveTypeDependencies, DEFAULT_DEPENDENCY } from './lib/dependencies'\nimport { compile, CompileResult } from './lib/compile'\nimport { findConfigFile, findUp } from './utils/find'\nimport {\n  transformConfig,\n  mkdirp,\n  touch,\n  transformDtsFile,\n  writeJson,\n  writeFile,\n  readJson,\n  readConfig,\n  treeToJson\n} from './utils/fs'\nimport { resolveFrom, normalizeResolutions, getDependencyPath, getDefinitionPath } from './utils/path'\nimport { parseDependency, parseDependencyExpression, buildDependencyExpression } from './utils/parse'\nimport { DependencyTree, Dependency, DependencyBranch, Emitter, ResolutionMap } from './interfaces'\nimport { CONFIG_FILE } from './utils/config'\n\n// Re-export useful expression building functions.\nexport { parseDependencyExpression, buildDependencyExpression }\n\n/**\n * Options for installing a new dependency.\n */\nexport interface InstallDependencyOptions {\n  save?: boolean\n  saveDev?: boolean\n  savePeer?: boolean\n  global?: boolean\n  cwd: string\n  name?: string\n  source?: string\n  emitter?: Emitter\n}\n\n/**\n * Only options required for a full install.\n */\nexport interface InstallOptions {\n  cwd: string\n  production?: boolean\n  emitter?: Emitter\n}\n\n/**\n * Consistent installation result.\n */\nexport interface InstallResult {\n  tree: DependencyTree\n  name?: string\n}\n\n/**\n * Options for compiling.\n */\nexport interface InstallDependencyNestedOptions extends InstallDependencyOptions {\n  resolutions: ResolutionMap\n}\n\n/**\n * Install all dependencies on the current project.\n */\nexport function install (options: InstallOptions): Promise<InstallResult> {\n  const { cwd, production } = options\n  const emitter = options.emitter || new EventEmitter()\n\n  return findConfigFile(cwd)\n    .then(\n      (configFile) => {\n        const cwd = dirname(configFile)\n\n        return readConfig(configFile)\n          .then(config => {\n            const resolutions = normalizeResolutions(config.resolution, options)\n\n            return resolveTypeDependencies({\n              cwd,\n              emitter,\n              global: true,\n              peer: true,\n              dev: !production\n            })\n              .then(tree => {\n                const cwd = dirname(tree.src)\n                const queue: Array<Promise<CompileResult>> = []\n\n                function addToQueue (deps: DependencyBranch, global: boolean) {\n                  for (const name of Object.keys(deps)) {\n                    const tree = deps[name]\n\n                    queue.push(compile(tree, Object.keys(resolutions), {\n                      cwd,\n                      name,\n                      global,\n                      emitter,\n                      meta: true\n                    }))\n                  }\n                }\n\n                addToQueue(tree.dependencies, false)\n                addToQueue(tree.devDependencies, false)\n                addToQueue(tree.peerDependencies, false)\n                addToQueue(tree.globalDependencies, true)\n                addToQueue(tree.globalDevDependencies, true)\n\n                return Promise.all(queue)\n                  .then(results => {\n                    return Promise.all(results.map(x => writeResult(x, { resolutions })))\n                      .then(() => writeBundle(results, { resolutions }))\n                      .then(() => ({ tree }))\n                  })\n              })\n          })\n      },\n      () => {\n        emitter.emit('enoent', { path: join(cwd, CONFIG_FILE) })\n\n        return { tree: extend(DEFAULT_DEPENDENCY) }\n      }\n    )\n\n}\n\n/**\n * Multiple installation expressions.\n */\nexport interface InstallExpression {\n  name: string\n  location: string\n}\n\n/**\n * Backward compat with single dependency install.\n */\nexport function installDependencyRaw (raw: string, options: InstallDependencyOptions) {\n  return installDependenciesRaw([raw], options).then(x => x[0])\n}\n\n/**\n * Install raw dependency strings.\n */\nexport function installDependenciesRaw (raw: string[], options: InstallDependencyOptions): Promise<InstallResult[]> {\n  return new Promise(resolve => {\n    const expressions = raw.map(x => parseDependencyExpression(x, options))\n\n    return resolve(installDependencies(expressions, options))\n  })\n}\n\n/**\n * Single wrapper to install a single dependency.\n */\nexport function installDependency (\n  expression: InstallExpression,\n  options: InstallDependencyOptions\n): Promise<InstallResult> {\n  return installDependencies([expression], options).then(x => x[0])\n}\n\n/**\n * Install a list of dependencies into the current project.\n */\nexport function installDependencies (\n  expressions: InstallExpression[],\n  options: InstallDependencyOptions\n): Promise<InstallResult[]> {\n  const emitter = options.emitter || new EventEmitter()\n\n  return findConfigFile(options.cwd)\n    .then(\n      (configFile) => {\n        const cwd = dirname(configFile)\n\n        return readConfig(configFile)\n          .then(config => {\n            const resolutions = normalizeResolutions(config.resolution, options)\n\n            return extend(options, { resolutions, cwd, emitter })\n          })\n      },\n      () => {\n        const resolutions = normalizeResolutions(undefined, options)\n\n        return extend(options, { emitter, resolutions })\n      }\n    )\n    .then(options => {\n      return Promise.all(expressions.map(x => compileDependency(x, options)))\n        .then(results => {\n          return Promise.all(results.map(x => writeResult(x, options)))\n            .then(() => writeBundle(results, options))\n            .then(() => writeToConfig(results, options))\n            .then(() => results.map(({ name, tree }) => ({ name, tree })))\n        })\n    })\n}\n\n/**\n * Install from a dependency string.\n */\nfunction compileDependency (\n  expression: InstallExpression,\n  options: InstallDependencyNestedOptions\n): Promise<CompileResult> {\n  const dependency = parseDependency(expression.location)\n  const { cwd, global, resolutions } = options\n  const emitter = options.emitter || new EventEmitter()\n  const expName = expression.name || dependency.meta.name\n\n  return checkTypings(dependency, options)\n    .then(() => {\n      return resolveDependency(dependency, { cwd, emitter, name: expName, dev: false, peer: false, global: false })\n    })\n    .then(tree => {\n      const name = expName || tree.name\n\n      if (!name) {\n        return Promise.reject(new TypeError(`Unable to install dependency from \"${tree.raw}\" without a name`))\n      }\n\n      if (tree.postmessage) {\n        emitter.emit('postmessage', { name, message: tree.postmessage })\n      }\n\n      return compile(tree, Object.keys(resolutions), {\n        cwd,\n        name,\n        global,\n        emitter,\n        meta: true\n      })\n    })\n}\n\n/**\n * Write a dependency to the configuration file.\n */\nfunction writeToConfig (results: CompileResult[], options: InstallDependencyOptions) {\n  if (options.save || options.saveDev || options.savePeer) {\n    return transformConfig(options.cwd, config => {\n      for (const { name, tree } of results) {\n        const { raw } = tree\n\n        // Extend different fields depending on the option passed in.\n        if (options.save) {\n          if (options.global) {\n            config.globalDependencies = extend(config.globalDependencies, { [name]: raw })\n          } else {\n            config.dependencies = extend(config.dependencies, { [name]: raw })\n          }\n        } else if (options.saveDev) {\n          if (options.global) {\n            config.globalDevDependencies = extend(config.globalDevDependencies, { [name]: raw })\n          } else {\n            config.devDependencies = extend(config.devDependencies, { [name]: raw })\n          }\n        } else if (options.savePeer) {\n          if (options.global) {\n            throw new TypeError('Unable to use `savePeer` with the `global` flag')\n          } else {\n            config.peerDependencies = extend(config.peerDependencies, { [name]: raw })\n          }\n        }\n      }\n\n      return config\n    })\n  }\n\n  return Promise.resolve()\n}\n\n/**\n * Write a dependency to the filesytem.\n */\nfunction writeBundle (results: CompileResult[], options: { resolutions: ResolutionMap }): Promise<any> {\n  const { resolutions } = options\n\n  return Promise.all(Object.keys(resolutions).map(resolution => {\n    const path = resolutions[resolution]\n    const paths = results.map(({ name, global }) => getDependencyPath({ path, name, global }).definition)\n\n    return mkdirp(path)\n      .then(() => {\n        const bundle = getDefinitionPath(path)\n\n        if (paths.length === 0) {\n          return touch(bundle)\n        }\n\n        return transformDtsFile(bundle, x => x.concat(paths))\n      })\n  }))\n}\n\n/**\n * Write a compilation result.\n */\nfunction writeResult (result: CompileResult, options: { resolutions: ResolutionMap }): Promise<any> {\n  const { name, global, tree, results } = result\n  const { resolutions } = options\n\n  return Promise.all(Object.keys(resolutions).map(resolution => {\n    const path = resolutions[resolution]\n    const contents = results[resolution]\n    const { directory, config, definition } = getDependencyPath({ name, global, path })\n\n    return mkdirp(directory)\n      .then(() => {\n        return Promise.all([\n          writeJson(config, { resolution, tree: treeToJson(tree) }),\n          writeFile(definition, contents)\n        ])\n      })\n  }))\n}\n\n/**\n * Find existing `typings` that TypeScript supports.\n */\nfunction checkTypings (dependency: Dependency, options: InstallDependencyOptions) {\n  const { type, meta } = dependency\n\n  // TypeScript only support NPM, as of today.\n  if (type === 'registry' && meta.source === 'npm') {\n    return findUp(options.cwd, join('node_modules', meta.name, 'package.json'))\n      .then(path => {\n        return readJson(path)\n          .then(packageJson => {\n            if (packageJson && typeof packageJson.typings === 'string') {\n              options.emitter.emit('hastypings', {\n                name: meta.name,\n                source: meta.source,\n                path: path,\n                typings: resolveFrom(path, packageJson.typings)\n              })\n            }\n          })\n      })\n      .catch(err => undefined)\n  }\n\n  return Promise.resolve()\n}\n"]}