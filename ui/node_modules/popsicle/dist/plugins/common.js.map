{"version":3,"file":"common.js","sourceRoot":"","sources":["../../lib/plugins/common.ts"],"names":[],"mappings":"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","sourcesContent":["import Promise = require('any-promise')\nimport FormData = require('form-data')\nimport arrify = require('arrify')\nimport { stringify as stringifyQuery, parse as parseQuery } from 'querystring'\nimport isHostObject from './is-host/index'\nimport Request from '../request'\nimport Response from '../response'\nimport form from '../form'\n\nconst JSON_MIME_REGEXP = /^application\\/(?:[\\w!#\\$%&\\*`\\-\\.\\^~]*\\+)?json$/i\nconst URL_ENCODED_MIME_REGEXP = /^application\\/x-www-form-urlencoded$/i\nconst FORM_MIME_REGEXP = /^multipart\\/form-data$/i\n\nconst JSON_PROTECTION_PREFIX = /^\\)\\]\\}',?\\n/\n\n/**\n * Simply wrap a value and return it.\n */\nexport function wrap <T> (value: T): () => T {\n  return () => value\n}\n\n/**\n * Remove default headers.\n */\nexport const headers = wrap(function (request: Request, next: () => Promise<Response>) {\n  // If we have no accept header set already, default to accepting\n  // everything. This is needed because otherwise Firefox defaults to\n  // an accept header of `html/xml`.\n  if (!request.get('Accept')) {\n    request.set('Accept', '*/*')\n  }\n\n  // Remove headers that should never be set by the user.\n  request.remove('Host')\n\n  return next()\n})\n\n/**\n * Stringify the request body.\n */\nexport const stringify = wrap(function (request: Request, next: () => Promise<Response>) {\n  const { body } = request\n\n  // Convert primitives types into strings.\n  if (Object(body) !== body) {\n    request.body = body == null ? null : String(body)\n\n    return next()\n  }\n\n  if (isHostObject(body)) {\n    return next()\n  }\n\n  let type = request.type()\n\n  // Set the default mime type to be JSON if none exists.\n  if (!type) {\n    type = 'application/json'\n\n    request.type(type)\n  }\n\n  // Automatically stringify expected MIME types.\n  try {\n    if (JSON_MIME_REGEXP.test(type)) {\n      request.body = JSON.stringify(body)\n    } else if (FORM_MIME_REGEXP.test(type)) {\n      request.body = form(body)\n    } else if (URL_ENCODED_MIME_REGEXP.test(type)) {\n      request.body = stringifyQuery(body)\n    }\n  } catch (err) {\n    return Promise.reject(request.error('Unable to stringify request body: ' + err.message, 'ESTRINGIFY', err))\n  }\n\n  // Remove the `Content-Type` header from form data requests. Browsers\n  // will only fill it automatically with the boundary when it isn't set.\n  if (request.body instanceof FormData) {\n    request.remove('Content-Type')\n  }\n\n  return next()\n})\n\nexport type ParseType = 'json' | 'urlencoded'\n\n/**\n * Parse the response body.\n */\nexport function parse (type: ParseType | ParseType[], strict?: boolean) {\n  const types = arrify(type)\n\n  for (const type of types) {\n    if (type !== 'json' && type !== 'urlencoded') {\n      throw new TypeError(`Unexpected parse type: ${type}`)\n    }\n  }\n\n  return function (request: Request, next: () => Promise<Response>) {\n    return next()\n      .then(function (response) {\n        const { body } = response\n        const responseType = response.type()\n\n        // Error on non-string bodies.\n        if (typeof body !== 'string') {\n          throw request.error(`Unable to parse non-string response body`, 'EPARSE')\n        }\n\n        // Throw on invalid response type.\n        if (responseType == null) {\n          throw request.error(`Unable to parse invalid response content type`, 'EPARSE')\n        }\n\n        // Empty bodies are _always_ `null`.\n        if (body === '') {\n          response.body = null\n          return response\n        }\n\n        // Attempt to parse as each type.\n        for (const type of types) {\n          if (type === 'json' && JSON_MIME_REGEXP.test(responseType)) {\n            try {\n              response.body = JSON.parse(body.replace(JSON_PROTECTION_PREFIX, ''))\n            } catch (err) {\n              throw request.error(`Unable to parse response body: ${err.message}`, 'EPARSE', err)\n            }\n\n            return response\n          }\n\n          if (type === 'urlencoded' && URL_ENCODED_MIME_REGEXP.test(responseType)) {\n            response.body = parseQuery(body)\n            return response\n          }\n        }\n\n        if (strict !== false) {\n          throw request.error(`Unhandled response type: ${responseType}`, 'EPARSE')\n        }\n\n        return response\n      })\n  }\n}\n"]}