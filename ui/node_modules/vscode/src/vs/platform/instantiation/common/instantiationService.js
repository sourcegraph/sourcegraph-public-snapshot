/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var winjs_base_1 = require("vs/base/common/winjs.base");
var errors_1 = require("vs/base/common/errors");
var types_1 = require("vs/base/common/types");
var assert = require("vs/base/common/assert");
var graph_1 = require("vs/base/common/graph");
var descriptors_1 = require("vs/platform/instantiation/common/descriptors");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var serviceCollection_1 = require("vs/platform/instantiation/common/serviceCollection");
var InstantiationService = (function () {
    function InstantiationService(services, strict) {
        if (services === void 0) { services = new serviceCollection_1.ServiceCollection(); }
        if (strict === void 0) { strict = false; }
        this._services = services;
        this._strict = strict;
        this._services.set(instantiation_1.IInstantiationService, this);
    }
    InstantiationService.prototype.createChild = function (services) {
        var _this = this;
        this._services.forEach(function (id, thing) {
            if (services.has(id)) {
                return;
            }
            // If we copy descriptors we might end up with
            // multiple instances of the same service
            if (thing instanceof descriptors_1.SyncDescriptor) {
                thing = _this._createAndCacheServiceInstance(id, thing);
            }
            services.set(id, thing);
        });
        return new InstantiationService(services, this._strict);
    };
    InstantiationService.prototype.invokeFunction = function (signature) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var accessor;
        try {
            accessor = {
                get: function (id, isOptional) {
                    var result = _this._getOrCreateServiceInstance(id);
                    if (!result && isOptional !== instantiation_1.optional) {
                        throw new Error("[invokeFunction] unkown service '" + id + "'");
                    }
                    return result;
                }
            };
            return signature.apply(undefined, [accessor].concat(args));
        }
        finally {
            accessor.get = function () {
                throw errors_1.illegalState('service accessor is only valid during the invocation of its target method');
            };
        }
    };
    InstantiationService.prototype.createInstance = function (param) {
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        if (param instanceof descriptors_1.AsyncDescriptor) {
            // async
            return this._createInstanceAsync(param, rest);
        }
        else if (param instanceof descriptors_1.SyncDescriptor) {
            // sync
            return this._createInstance(param, rest);
        }
        else {
            // sync, just ctor
            return this._createInstance(new descriptors_1.SyncDescriptor(param), rest);
        }
    };
    InstantiationService.prototype._createInstanceAsync = function (descriptor, args) {
        var _this = this;
        var canceledError;
        return new winjs_base_1.TPromise(function (c, e, p) {
            require([descriptor.moduleName], function (_module) {
                if (canceledError) {
                    e(canceledError);
                }
                if (!_module) {
                    return e(errors_1.illegalArgument('module not found: ' + descriptor.moduleName));
                }
                var ctor;
                if (!descriptor.ctorName) {
                    ctor = _module;
                }
                else {
                    ctor = _module[descriptor.ctorName];
                }
                if (typeof ctor !== 'function') {
                    return e(errors_1.illegalArgument('not a function: ' + descriptor.ctorName || descriptor.moduleName));
                }
                try {
                    args.unshift.apply(args, descriptor.staticArguments()); // instead of spread in ctor call
                    c(_this._createInstance(new descriptors_1.SyncDescriptor(ctor), args));
                }
                catch (error) {
                    return e(error);
                }
            }, e);
        }, function () {
            canceledError = errors_1.canceled();
        });
    };
    InstantiationService.prototype._createInstance = function (desc, args) {
        var _this = this;
        // arguments given by createInstance-call and/or the descriptor
        var staticArgs = desc.staticArguments().concat(args);
        // arguments defined by service decorators
        var serviceDependencies = instantiation_1._util.getServiceDependencies(desc.ctor).sort(function (a, b) { return a.index - b.index; });
        var serviceArgs = serviceDependencies.map(function (dependency) {
            var service = _this._getOrCreateServiceInstance(dependency.id);
            if (!service && _this._strict && !dependency.optional) {
                console.warn("[createInstance] " + desc.ctor.name + " depends on UNKNOWN service " + dependency.id + ".");
            }
            return service;
        });
        var firstServiceArgPos = serviceDependencies.length > 0 ? serviceDependencies[0].index : staticArgs.length;
        // check for argument mismatches, adjust static args if needed
        if (staticArgs.length !== firstServiceArgPos) {
            console.warn("[createInstance] First service dependency of " + desc.ctor.name + " at position " + (firstServiceArgPos + 1) + " conflicts with " + staticArgs.length + " static arguments");
            var delta = firstServiceArgPos - staticArgs.length;
            if (delta > 0) {
                staticArgs = staticArgs.concat(new Array(delta));
            }
            else {
                staticArgs = staticArgs.slice(0, firstServiceArgPos);
            }
        }
        // // check for missing args
        // for (let i = 0; i < serviceArgs.length; i++) {
        // 	if (!serviceArgs[i]) {
        // 		console.warn(`${desc.ctor.name} MISSES service dependency ${serviceDependencies[i].id}`, new Error().stack);
        // 	}
        // }
        // now create the instance
        var argArray = [desc.ctor];
        argArray.push.apply(argArray, staticArgs);
        argArray.push.apply(argArray, serviceArgs);
        var instance = types_1.create.apply(null, argArray);
        desc._validate(instance);
        return instance;
    };
    InstantiationService.prototype._getOrCreateServiceInstance = function (id) {
        var thing = this._services.get(id);
        if (thing instanceof descriptors_1.SyncDescriptor) {
            return this._createAndCacheServiceInstance(id, thing);
        }
        else {
            return thing;
        }
    };
    InstantiationService.prototype._createAndCacheServiceInstance = function (id, desc) {
        assert.ok(this._services.get(id) instanceof descriptors_1.SyncDescriptor);
        var graph = new graph_1.Graph(function (data) { return data.id.toString(); });
        function throwCycleError() {
            var err = new Error('[createInstance] cyclic dependency between services');
            err.message = graph.toString();
            throw err;
        }
        var count = 0;
        var stack = [{ id: id, desc: desc }];
        while (stack.length) {
            var item = stack.pop();
            graph.lookupOrInsertNode(item);
            // TODO@joh use the graph to find a cycle
            // a weak heuristic for cycle checks
            if (count++ > 100) {
                throwCycleError();
            }
            // check all dependencies for existence and if the need to be created first
            var dependencies = instantiation_1._util.getServiceDependencies(item.desc.ctor);
            for (var _i = 0, dependencies_1 = dependencies; _i < dependencies_1.length; _i++) {
                var dependency = dependencies_1[_i];
                var instanceOrDesc = this._services.get(dependency.id);
                if (!instanceOrDesc) {
                    console.warn("[createInstance] " + id + " depends on " + dependency.id + " which is NOT registered.");
                }
                if (instanceOrDesc instanceof descriptors_1.SyncDescriptor) {
                    var d = { id: dependency.id, desc: instanceOrDesc };
                    graph.insertEdge(item, d);
                    stack.push(d);
                }
            }
        }
        while (true) {
            var roots = graph.roots();
            // if there is no more roots but still
            // nodes in the graph we have a cycle
            if (roots.length === 0) {
                if (graph.length !== 0) {
                    throwCycleError();
                }
                break;
            }
            for (var _a = 0, roots_1 = roots; _a < roots_1.length; _a++) {
                var root = roots_1[_a];
                // create instance and overwrite the service collections
                var instance = this._createInstance(root.data.desc, []);
                this._services.set(root.data.id, instance);
                graph.removeNode(root.data);
            }
        }
        return this._services.get(id);
    };
    return InstantiationService;
}());
exports.InstantiationService = InstantiationService;
