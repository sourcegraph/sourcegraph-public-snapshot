/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var winjs_base_1 = require("vs/base/common/winjs.base");
var event_1 = require("vs/base/common/event");
var objects = require("vs/base/common/objects");
var types = require("vs/base/common/types");
var uri_1 = require("vs/base/common/uri");
var lifecycle_1 = require("vs/base/common/lifecycle");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var ConfirmResult;
(function (ConfirmResult) {
    ConfirmResult[ConfirmResult["SAVE"] = 0] = "SAVE";
    ConfirmResult[ConfirmResult["DONT_SAVE"] = 1] = "DONT_SAVE";
    ConfirmResult[ConfirmResult["CANCEL"] = 2] = "CANCEL";
})(ConfirmResult = exports.ConfirmResult || (exports.ConfirmResult = {}));
exports.Extensions = {
    Editors: 'workbench.contributions.editors'
};
/**
 * Text diff editor id.
 */
exports.TEXT_DIFF_EDITOR_ID = 'workbench.editors.textDiffEditor';
/**
 * Binary diff editor id.
 */
exports.BINARY_DIFF_EDITOR_ID = 'workbench.editors.binaryResourceDiffEditor';
/**
 * Editor inputs are lightweight objects that can be passed to the workbench API to open inside the editor part.
 * Each editor input is mapped to an editor that is capable of opening it through the Platform facade.
 */
var EditorInput = (function () {
    function EditorInput() {
        this._onDidChangeDirty = new event_1.Emitter();
        this._onDidChangeLabel = new event_1.Emitter();
        this._onDispose = new event_1.Emitter();
        this.disposed = false;
    }
    Object.defineProperty(EditorInput.prototype, "onDidChangeDirty", {
        /**
         * Fired when the dirty state of this input changes.
         */
        get: function () {
            return this._onDidChangeDirty.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EditorInput.prototype, "onDidChangeLabel", {
        /**
         * Fired when the label this input changes.
         */
        get: function () {
            return this._onDidChangeLabel.event;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EditorInput.prototype, "onDispose", {
        /**
         * Fired when the model gets disposed.
         */
        get: function () {
            return this._onDispose.event;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the name of this input that can be shown to the user. Examples include showing the name of the input
     * above the editor area when the input is shown.
     */
    EditorInput.prototype.getName = function () {
        return null;
    };
    /**
     * Returns the description of this input that can be shown to the user. Examples include showing the description of
     * the input above the editor area to the side of the name of the input.
     *
     * @param verbose controls if the description should be short or can contain additional details.
     */
    EditorInput.prototype.getDescription = function (verbose) {
        return null;
    };
    /**
     * Returns the preferred editor for this input. A list of candidate editors is passed in that whee registered
     * for the input. This allows subclasses to decide late which editor to use for the input on a case by case basis.
     */
    EditorInput.prototype.getPreferredEditorId = function (candidates) {
        if (candidates && candidates.length > 0) {
            return candidates[0];
        }
        return null;
    };
    /**
     * Returns a descriptor suitable for telemetry events or null if none is available.
     *
     * Subclasses should extend if they can contribute.
     */
    EditorInput.prototype.getTelemetryDescriptor = function () {
        return { typeId: this.getTypeId() };
    };
    /**
     * An editor that is dirty will be asked to be saved once it closes.
     */
    EditorInput.prototype.isDirty = function () {
        return false;
    };
    /**
     * Subclasses should bring up a proper dialog for the user if the editor is dirty and return the result.
     */
    EditorInput.prototype.confirmSave = function () {
        return ConfirmResult.DONT_SAVE;
    };
    /**
     * Saves the editor if it is dirty. Subclasses return a promise with a boolean indicating the success of the operation.
     */
    EditorInput.prototype.save = function () {
        return winjs_base_1.TPromise.as(true);
    };
    /**
     * Reverts the editor if it is dirty. Subclasses return a promise with a boolean indicating the success of the operation.
     */
    EditorInput.prototype.revert = function () {
        return winjs_base_1.TPromise.as(true);
    };
    /**
     * Called when this input is no longer opened in any editor. Subclasses can free resources as needed.
     */
    EditorInput.prototype.close = function () {
        this.dispose();
    };
    /**
     * Subclasses can set this to false if it does not make sense to split the editor input.
     */
    EditorInput.prototype.supportsSplitEditor = function () {
        return true;
    };
    /**
     * Returns true if this input is identical to the otherInput.
     */
    EditorInput.prototype.matches = function (otherInput) {
        return this === otherInput;
    };
    /**
     * Called when an editor input is no longer needed. Allows to free up any resources taken by
     * resolving the editor input.
     */
    EditorInput.prototype.dispose = function () {
        this.disposed = true;
        this._onDispose.fire();
        this._onDidChangeDirty.dispose();
        this._onDidChangeLabel.dispose();
        this._onDispose.dispose();
    };
    /**
     * Returns whether this input was disposed or not.
     */
    EditorInput.prototype.isDisposed = function () {
        return this.disposed;
    };
    return EditorInput;
}());
exports.EditorInput = EditorInput;
var EncodingMode;
(function (EncodingMode) {
    /**
     * Instructs the encoding support to encode the current input with the provided encoding
     */
    EncodingMode[EncodingMode["Encode"] = 0] = "Encode";
    /**
     * Instructs the encoding support to decode the current input with the provided encoding
     */
    EncodingMode[EncodingMode["Decode"] = 1] = "Decode";
})(EncodingMode = exports.EncodingMode || (exports.EncodingMode = {}));
/**
 * The base class of untitled editor inputs in the workbench.
 */
var UntitledEditorInput = (function (_super) {
    __extends(UntitledEditorInput, _super);
    function UntitledEditorInput() {
        return _super.apply(this, arguments) || this;
    }
    UntitledEditorInput.prototype.getTelemetryDescriptor = function () {
        var descriptor = _super.prototype.getTelemetryDescriptor.call(this);
        descriptor['resource'] = telemetry_1.telemetryURIDescriptor(this.getResource());
        return descriptor;
    };
    return UntitledEditorInput;
}(EditorInput));
exports.UntitledEditorInput = UntitledEditorInput;
/**
 * Side by side editor inputs that have a master and details side.
 */
var SideBySideEditorInput = (function (_super) {
    __extends(SideBySideEditorInput, _super);
    function SideBySideEditorInput(name, description, _details, _master) {
        var _this = _super.call(this) || this;
        _this.name = name;
        _this.description = description;
        _this._details = _details;
        _this._master = _master;
        _this._toUnbind = [];
        _this.registerListeners();
        return _this;
    }
    Object.defineProperty(SideBySideEditorInput.prototype, "master", {
        get: function () {
            return this._master;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SideBySideEditorInput.prototype, "details", {
        get: function () {
            return this._details;
        },
        enumerable: true,
        configurable: true
    });
    SideBySideEditorInput.prototype.isDirty = function () {
        return this.master.isDirty();
    };
    SideBySideEditorInput.prototype.confirmSave = function () {
        return this.master.confirmSave();
    };
    SideBySideEditorInput.prototype.save = function () {
        return this.master.save();
    };
    SideBySideEditorInput.prototype.revert = function () {
        return this.master.revert();
    };
    SideBySideEditorInput.prototype.getTelemetryDescriptor = function () {
        var descriptor = this.master.getTelemetryDescriptor();
        return objects.assign(descriptor, _super.prototype.getTelemetryDescriptor.call(this));
    };
    SideBySideEditorInput.prototype.registerListeners = function () {
        var _this = this;
        // When the details or master input gets disposed, dispose this diff editor input
        var onceDetailsDisposed = event_1.once(this.details.onDispose);
        this._toUnbind.push(onceDetailsDisposed(function () {
            if (!_this.isDisposed()) {
                _this.dispose();
            }
        }));
        var onceMasterDisposed = event_1.once(this.master.onDispose);
        this._toUnbind.push(onceMasterDisposed(function () {
            if (!_this.isDisposed()) {
                _this.dispose();
            }
        }));
        // Reemit some events from the master side to the outside
        this._toUnbind.push(this.master.onDidChangeDirty(function () { return _this._onDidChangeDirty.fire(); }));
        this._toUnbind.push(this.master.onDidChangeLabel(function () { return _this._onDidChangeLabel.fire(); }));
    };
    Object.defineProperty(SideBySideEditorInput.prototype, "toUnbind", {
        get: function () {
            return this._toUnbind;
        },
        enumerable: true,
        configurable: true
    });
    SideBySideEditorInput.prototype.resolve = function (refresh) {
        return winjs_base_1.TPromise.as(null);
    };
    SideBySideEditorInput.prototype.getTypeId = function () {
        return SideBySideEditorInput.ID;
    };
    SideBySideEditorInput.prototype.getName = function () {
        return this.name;
    };
    SideBySideEditorInput.prototype.getDescription = function () {
        return this.description;
    };
    SideBySideEditorInput.prototype.supportsSplitEditor = function () {
        return false;
    };
    SideBySideEditorInput.prototype.matches = function (otherInput) {
        if (_super.prototype.matches.call(this, otherInput) === true) {
            return true;
        }
        if (otherInput) {
            if (!(otherInput instanceof SideBySideEditorInput)) {
                return false;
            }
            var otherDiffInput = otherInput;
            return this.details.matches(otherDiffInput.details) && this.master.matches(otherDiffInput.master);
        }
        return false;
    };
    SideBySideEditorInput.prototype.dispose = function () {
        this._toUnbind = lifecycle_1.dispose(this._toUnbind);
        _super.prototype.dispose.call(this);
    };
    return SideBySideEditorInput;
}(EditorInput));
SideBySideEditorInput.ID = 'workbench.editorinputs.sidebysideEditorInput';
exports.SideBySideEditorInput = SideBySideEditorInput;
/**
 * The editor model is the heavyweight counterpart of editor input. Depending on the editor input, it
 * connects to the disk to retrieve content and may allow for saving it back or reverting it. Editor models
 * are typically cached for some while because they are expensive to construct.
 */
var EditorModel = (function () {
    function EditorModel() {
        this._onDispose = new event_1.Emitter();
    }
    Object.defineProperty(EditorModel.prototype, "onDispose", {
        /**
         * Fired when the model gets disposed.
         */
        get: function () {
            return this._onDispose.event;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Causes this model to load returning a promise when loading is completed.
     */
    EditorModel.prototype.load = function () {
        return winjs_base_1.TPromise.as(this);
    };
    /**
     * Returns whether this model was loaded or not.
     */
    EditorModel.prototype.isResolved = function () {
        return true;
    };
    /**
     * Subclasses should implement to free resources that have been claimed through loading.
     */
    EditorModel.prototype.dispose = function () {
        this._onDispose.fire();
        this._onDispose.dispose();
    };
    return EditorModel;
}());
exports.EditorModel = EditorModel;
/**
 * The editor options is the base class of options that can be passed in when opening an editor.
 */
var EditorOptions = (function () {
    function EditorOptions() {
    }
    /**
     * Helper to create EditorOptions inline.
     */
    EditorOptions.create = function (settings) {
        var options = new EditorOptions();
        options.preserveFocus = settings.preserveFocus;
        options.forceOpen = settings.forceOpen;
        options.revealIfVisible = settings.revealIfVisible;
        options.pinned = settings.pinned;
        options.index = settings.index;
        options.inactive = settings.inactive;
        return options;
    };
    /**
     * Inherit all options from other EditorOptions instance.
     */
    EditorOptions.prototype.mixin = function (other) {
        if (other) {
            this.preserveFocus = other.preserveFocus;
            this.forceOpen = other.forceOpen;
            this.revealIfVisible = other.revealIfVisible;
            this.pinned = other.pinned;
            this.index = other.index;
            this.inactive = other.inactive;
        }
    };
    return EditorOptions;
}());
exports.EditorOptions = EditorOptions;
/**
 * Base Text Editor Options.
 */
var TextEditorOptions = (function (_super) {
    __extends(TextEditorOptions, _super);
    function TextEditorOptions() {
        return _super.apply(this, arguments) || this;
    }
    TextEditorOptions.from = function (input) {
        var options = null;
        if (input && input.options) {
            if (input.options.selection || input.options.forceOpen || input.options.revealIfVisible || input.options.preserveFocus || input.options.pinned || input.options.inactive || typeof input.options.index === 'number') {
                options = new TextEditorOptions();
            }
            if (input.options.selection) {
                var selection = input.options.selection;
                options.selection(selection.startLineNumber, selection.startColumn, selection.endLineNumber, selection.endColumn);
            }
            if (input.options.forceOpen) {
                options.forceOpen = true;
            }
            if (input.options.revealIfVisible) {
                options.revealIfVisible = true;
            }
            if (input.options.preserveFocus) {
                options.preserveFocus = true;
            }
            if (input.options.pinned) {
                options.pinned = true;
            }
            if (input.options.inactive) {
                options.inactive = true;
            }
            if (typeof input.options.index === 'number') {
                options.index = input.options.index;
            }
        }
        return options;
    };
    /**
     * Helper to create TextEditorOptions inline.
     */
    TextEditorOptions.create = function (settings) {
        var options = new TextEditorOptions();
        options.preserveFocus = settings.preserveFocus;
        options.forceOpen = settings.forceOpen;
        options.revealIfVisible = settings.revealIfVisible;
        options.pinned = settings.pinned;
        options.index = settings.index;
        if (settings.selection) {
            options.startLineNumber = settings.selection.startLineNumber;
            options.startColumn = settings.selection.startColumn;
            options.endLineNumber = settings.selection.endLineNumber || settings.selection.startLineNumber;
            options.endColumn = settings.selection.endColumn || settings.selection.startColumn;
        }
        return options;
    };
    /**
     * Returns if this options object has objects defined for the editor.
     */
    TextEditorOptions.prototype.hasOptionsDefined = function () {
        return !!this.editorViewState || (!types.isUndefinedOrNull(this.startLineNumber) && !types.isUndefinedOrNull(this.startColumn));
    };
    /**
     * Tells the editor to set show the given selection when the editor is being opened.
     */
    TextEditorOptions.prototype.selection = function (startLineNumber, startColumn, endLineNumber, endColumn) {
        if (endLineNumber === void 0) { endLineNumber = startLineNumber; }
        if (endColumn === void 0) { endColumn = startColumn; }
        this.startLineNumber = startLineNumber;
        this.startColumn = startColumn;
        this.endLineNumber = endLineNumber;
        this.endColumn = endColumn;
        return this;
    };
    /**
     * Sets the view state to be used when the editor is opening.
     */
    TextEditorOptions.prototype.fromEditor = function (editor) {
        // View state
        this.editorViewState = editor.saveViewState();
        // Selected editor options
        var codeEditor = editor;
        if (typeof codeEditor.getConfiguration === 'function') {
            var config = codeEditor.getConfiguration();
            if (config && config.viewInfo && config.wrappingInfo) {
                this.editorOptions = Object.create(null);
                this.editorOptions.renderWhitespace = config.viewInfo.renderWhitespace;
                this.editorOptions.renderControlCharacters = config.viewInfo.renderControlCharacters;
                this.editorOptions.wrappingColumn = config.wrappingInfo.isViewportWrapping ? 0 : -1;
            }
        }
    };
    /**
     * Apply the view state or selection to the given editor.
     *
     * @return if something was applied
     */
    TextEditorOptions.prototype.apply = function (editor) {
        // Editor options
        if (this.editorOptions) {
            editor.updateOptions(this.editorOptions);
        }
        // View state
        return this.applyViewState(editor);
    };
    TextEditorOptions.prototype.applyViewState = function (editor) {
        var gotApplied = false;
        // First try viewstate
        if (this.editorViewState) {
            editor.restoreViewState(this.editorViewState);
            gotApplied = true;
        }
        else if (!types.isUndefinedOrNull(this.startLineNumber) && !types.isUndefinedOrNull(this.startColumn)) {
            // Select
            if (!types.isUndefinedOrNull(this.endLineNumber) && !types.isUndefinedOrNull(this.endColumn)) {
                var range = {
                    startLineNumber: this.startLineNumber,
                    startColumn: this.startColumn,
                    endLineNumber: this.endLineNumber,
                    endColumn: this.endColumn
                };
                editor.setSelection(range);
                editor.revealRangeInCenter(range);
            }
            else {
                var pos = {
                    lineNumber: this.startLineNumber,
                    column: this.startColumn
                };
                editor.setPosition(pos);
                editor.revealPositionInCenter(pos);
            }
            gotApplied = true;
        }
        return gotApplied;
    };
    return TextEditorOptions;
}(EditorOptions));
exports.TextEditorOptions = TextEditorOptions;
/**
 * Base Text Diff Editor Options.
 */
var TextDiffEditorOptions = (function (_super) {
    __extends(TextDiffEditorOptions, _super);
    function TextDiffEditorOptions() {
        return _super.apply(this, arguments) || this;
    }
    /**
     * Helper to create TextDiffEditorOptions inline.
     */
    TextDiffEditorOptions.create = function (settings) {
        var options = new TextDiffEditorOptions();
        options.autoRevealFirstChange = settings.autoRevealFirstChange;
        options.preserveFocus = settings.preserveFocus;
        options.forceOpen = settings.forceOpen;
        options.revealIfVisible = settings.revealIfVisible;
        options.pinned = settings.pinned;
        options.index = settings.index;
        if (settings.selection) {
            options.startLineNumber = settings.selection.startLineNumber;
            options.startColumn = settings.selection.startColumn;
            options.endLineNumber = settings.selection.endLineNumber || settings.selection.startLineNumber;
            options.endColumn = settings.selection.endColumn || settings.selection.startColumn;
        }
        return options;
    };
    return TextDiffEditorOptions;
}(TextEditorOptions));
exports.TextDiffEditorOptions = TextDiffEditorOptions;
/**
 * Given an input, tries to get the associated URI for it (either file or untitled scheme).
 */
function getUntitledOrFileResource(input, supportDiff) {
    if (!input) {
        return null;
    }
    // Untitled
    if (input instanceof UntitledEditorInput) {
        return input.getResource();
    }
    // File
    var fileInput = asFileEditorInput(input, supportDiff);
    return fileInput && fileInput.getResource();
}
exports.getUntitledOrFileResource = getUntitledOrFileResource;
// TODO@Ben every editor should have an associated resource
function getResource(input) {
    if (input instanceof EditorInput && typeof input.getResource === 'function') {
        var candidate = input.getResource();
        if (candidate instanceof uri_1.default) {
            return candidate;
        }
    }
    return getUntitledOrFileResource(input, true);
}
exports.getResource = getResource;
/**
 * Helper to return all opened editors with resources not belonging to the currently opened workspace.
 */
function getOutOfWorkspaceEditorResources(editorGroupService, contextService) {
    var resources = [];
    editorGroupService.getStacksModel().groups.forEach(function (group) {
        var editors = group.getEditors();
        editors.forEach(function (editor) {
            var fileInput = asFileEditorInput(editor, true);
            if (fileInput && !contextService.isInsideWorkspace(fileInput.getResource())) {
                resources.push(fileInput.getResource());
            }
        });
    });
    return resources;
}
exports.getOutOfWorkspaceEditorResources = getOutOfWorkspaceEditorResources;
/**
 * Returns the object as IFileEditorInput only if it matches the signature.
 */
function asFileEditorInput(obj, supportSideBySide) {
    if (!obj) {
        return null;
    }
    // Check for side by side if we are asked to
    if (supportSideBySide && obj instanceof SideBySideEditorInput) {
        obj = obj.master;
    }
    var i = obj;
    return i instanceof EditorInput && types.areFunctions(i.setResource, i.setEncoding, i.getEncoding, i.getResource, i.setPreferredEncoding) ? i : null;
}
exports.asFileEditorInput = asFileEditorInput;
exports.EditorOpenPositioning = {
    LEFT: 'left',
    RIGHT: 'right',
    FIRST: 'first',
    LAST: 'last'
};
exports.ActiveEditorMovePositioning = {
    FIRST: 'first',
    LAST: 'last',
    LEFT: 'left',
    RIGHT: 'right',
    CENTER: 'center',
    POSITION: 'position',
};
exports.ActiveEditorMovePositioningBy = {
    TAB: 'tab',
    GROUP: 'group'
};
exports.EditorCommands = {
    MoveActiveEditor: 'moveActiveEditor'
};
