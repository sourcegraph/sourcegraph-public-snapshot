/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var fs = require("fs");
var gracefulFs = require("graceful-fs");
gracefulFs.gracefulify(fs);
var errors_1 = require("vs/base/common/errors");
var strings = require("vs/base/common/strings");
var winjs_base_1 = require("vs/base/common/winjs.base");
var baseMime = require("vs/base/common/mime");
var encoding_1 = require("vs/base/node/encoding");
var mime_1 = require("vs/base/node/mime");
var MAX_FILE_ERRORS = 5; // Don't report more than this number of errors, 1 per file, to avoid flooding the log when there's a general issue
var numErrorsLogged = 0;
function onError(error) {
    if (numErrorsLogged++ < MAX_FILE_ERRORS) {
        errors_1.onUnexpectedError(error);
    }
}
var SearchWorkerManager = (function () {
    function SearchWorkerManager() {
    }
    SearchWorkerManager.prototype.initialize = function () {
        this.currentSearchEngine = new SearchWorkerEngine();
        return winjs_base_1.TPromise.wrap(undefined);
    };
    SearchWorkerManager.prototype.cancel = function () {
        // Cancel the current search. It will stop searching and close its open files.
        if (this.currentSearchEngine) {
            this.currentSearchEngine.cancel();
        }
        return winjs_base_1.TPromise.wrap(null);
    };
    SearchWorkerManager.prototype.search = function (args) {
        if (!this.currentSearchEngine) {
            // Worker timed out during search
            this.initialize();
        }
        return this.currentSearchEngine.searchBatch(args);
    };
    return SearchWorkerManager;
}());
exports.SearchWorkerManager = SearchWorkerManager;
var SearchWorkerEngine = (function () {
    function SearchWorkerEngine() {
        this.nextSearch = winjs_base_1.TPromise.wrap(null);
        this.isCanceled = false;
    }
    /**
     * Searches some number of the given paths concurrently, and starts searches in other paths when those complete.
     */
    SearchWorkerEngine.prototype.searchBatch = function (args) {
        var _this = this;
        var contentPattern = strings.createRegExp(args.pattern.pattern, args.pattern.isRegExp, { matchCase: args.pattern.isCaseSensitive, wholeWord: args.pattern.isWordMatch, multiline: false, global: true });
        var fileEncoding = encoding_1.encodingExists(args.fileEncoding) ? args.fileEncoding : encoding_1.UTF8;
        return this.nextSearch =
            this.nextSearch.then(function () { return _this._searchBatch(args, contentPattern, fileEncoding); });
    };
    SearchWorkerEngine.prototype._searchBatch = function (args, contentPattern, fileEncoding) {
        var _this = this;
        if (this.isCanceled) {
            return winjs_base_1.TPromise.wrap(null);
        }
        return new winjs_base_1.TPromise(function (batchDone) {
            var result = {
                matches: [],
                numMatches: 0,
                limitReached: false
            };
            // Search in the given path, and when it's finished, search in the next path in absolutePaths
            var startSearchInFile = function (absolutePath) {
                return _this.searchInFile(absolutePath, contentPattern, fileEncoding, args.maxResults && (args.maxResults - result.numMatches)).then(function (fileResult) {
                    // Finish early if search is canceled
                    if (_this.isCanceled) {
                        return;
                    }
                    if (fileResult) {
                        result.numMatches += fileResult.numMatches;
                        result.matches.push(fileResult.match.serialize());
                        if (fileResult.limitReached) {
                            // If the limit was reached, terminate early with the results so far and cancel in-progress searches.
                            _this.cancel();
                            result.limitReached = true;
                            return batchDone(result);
                        }
                    }
                }, onError);
            };
            winjs_base_1.TPromise.join(args.absolutePaths.map(startSearchInFile)).then(function () {
                batchDone(result);
            });
        });
    };
    SearchWorkerEngine.prototype.cancel = function () {
        this.isCanceled = true;
    };
    SearchWorkerEngine.prototype.searchInFile = function (absolutePath, contentPattern, fileEncoding, maxResults) {
        var _this = this;
        var fileMatch = null;
        var limitReached = false;
        var numMatches = 0;
        var perLineCallback = function (line, lineNumber) {
            var lineMatch = null;
            var match = contentPattern.exec(line);
            // Record all matches into file result
            while (match !== null && match[0].length > 0 && !_this.isCanceled && !limitReached) {
                if (fileMatch === null) {
                    fileMatch = new FileMatch(absolutePath);
                }
                if (lineMatch === null) {
                    lineMatch = new LineMatch(line, lineNumber);
                    fileMatch.addMatch(lineMatch);
                }
                lineMatch.addMatch(match.index, match[0].length);
                numMatches++;
                if (maxResults && numMatches >= maxResults) {
                    limitReached = true;
                }
                match = contentPattern.exec(line);
            }
        };
        // Read lines buffered to support large files
        return this.readlinesAsync(absolutePath, perLineCallback, { bufferLength: 8096, encoding: fileEncoding }).then(function () { return fileMatch ? { match: fileMatch, limitReached: limitReached, numMatches: numMatches } : null; });
    };
    SearchWorkerEngine.prototype.readlinesAsync = function (filename, perLineCallback, options) {
        var _this = this;
        return new winjs_base_1.TPromise(function (resolve, reject) {
            fs.open(filename, 'r', null, function (error, fd) {
                if (error) {
                    return reject(error);
                }
                var buffer = new Buffer(options.bufferLength);
                var pos;
                var i;
                var line = '';
                var lineNumber = 0;
                var lastBufferHadTraillingCR = false;
                var decodeBuffer = function (buffer, start, end) {
                    if (options.encoding === encoding_1.UTF8 || options.encoding === encoding_1.UTF8_with_bom) {
                        return buffer.toString(undefined, start, end); // much faster to use built in toString() when encoding is default
                    }
                    return encoding_1.decode(buffer.slice(start, end), options.encoding);
                };
                var lineFinished = function (offset) {
                    line += decodeBuffer(buffer, pos, i + offset);
                    perLineCallback(line, lineNumber);
                    line = '';
                    lineNumber++;
                    pos = i + offset;
                };
                var readFile = function (isFirstRead, clb) {
                    if (_this.isCanceled) {
                        return clb(null); // return early if canceled or limit reached
                    }
                    fs.read(fd, buffer, 0, buffer.length, null, function (error, bytesRead, buffer) {
                        if (error || bytesRead === 0 || _this.isCanceled) {
                            return clb(error); // return early if canceled or limit reached or no more bytes to read
                        }
                        pos = 0;
                        i = 0;
                        // Detect encoding and mime when this is the beginning of the file
                        if (isFirstRead) {
                            var mimeAndEncoding = mime_1.detectMimeAndEncodingFromBuffer(buffer, bytesRead);
                            if (mimeAndEncoding.mimes[mimeAndEncoding.mimes.length - 1] !== baseMime.MIME_TEXT) {
                                return clb(null); // skip files that seem binary
                            }
                            // Check for BOM offset
                            switch (mimeAndEncoding.encoding) {
                                case encoding_1.UTF8:
                                    pos = i = 3;
                                    options.encoding = encoding_1.UTF8;
                                    break;
                                case encoding_1.UTF16be:
                                    pos = i = 2;
                                    options.encoding = encoding_1.UTF16be;
                                    break;
                                case encoding_1.UTF16le:
                                    pos = i = 2;
                                    options.encoding = encoding_1.UTF16le;
                                    break;
                            }
                        }
                        if (lastBufferHadTraillingCR) {
                            if (buffer[i] === 0x0a) {
                                lineFinished(1);
                                i++;
                            }
                            else {
                                lineFinished(0);
                            }
                            lastBufferHadTraillingCR = false;
                        }
                        for (; i < bytesRead; ++i) {
                            if (buffer[i] === 0x0a) {
                                lineFinished(1);
                            }
                            else if (buffer[i] === 0x0d) {
                                if (i + 1 === bytesRead) {
                                    lastBufferHadTraillingCR = true;
                                }
                                else if (buffer[i + 1] === 0x0a) {
                                    lineFinished(2);
                                    i++;
                                }
                                else {
                                    lineFinished(1);
                                }
                            }
                        }
                        line += decodeBuffer(buffer, pos, bytesRead);
                        readFile(/*isFirstRead=*/ false, clb); // Continue reading
                    });
                };
                readFile(/*isFirstRead=*/ true, function (error) {
                    if (error) {
                        return reject(error);
                    }
                    if (line.length) {
                        perLineCallback(line, lineNumber); // handle last line
                    }
                    fs.close(fd, function (error) {
                        if (error) {
                            reject(error);
                        }
                        else {
                            resolve(null);
                        }
                    });
                });
            });
        });
    };
    return SearchWorkerEngine;
}());
exports.SearchWorkerEngine = SearchWorkerEngine;
var FileMatch = (function () {
    function FileMatch(path) {
        this.path = path;
        this.lineMatches = [];
    }
    FileMatch.prototype.addMatch = function (lineMatch) {
        this.lineMatches.push(lineMatch);
    };
    FileMatch.prototype.isEmpty = function () {
        return this.lineMatches.length === 0;
    };
    FileMatch.prototype.serialize = function () {
        var lineMatches = [];
        var numMatches = 0;
        for (var i = 0; i < this.lineMatches.length; i++) {
            numMatches += this.lineMatches[i].offsetAndLengths.length;
            lineMatches.push(this.lineMatches[i].serialize());
        }
        return {
            path: this.path,
            lineMatches: lineMatches,
            numMatches: numMatches
        };
    };
    return FileMatch;
}());
exports.FileMatch = FileMatch;
var LineMatch = (function () {
    function LineMatch(preview, lineNumber) {
        this.preview = preview.replace(/(\r|\n)*$/, '');
        this.lineNumber = lineNumber;
        this.offsetAndLengths = [];
    }
    LineMatch.prototype.getText = function () {
        return this.preview;
    };
    LineMatch.prototype.getLineNumber = function () {
        return this.lineNumber;
    };
    LineMatch.prototype.addMatch = function (offset, length) {
        this.offsetAndLengths.push([offset, length]);
    };
    LineMatch.prototype.serialize = function () {
        var result = {
            preview: this.preview,
            lineNumber: this.lineNumber,
            offsetAndLengths: this.offsetAndLengths
        };
        return result;
    };
    return LineMatch;
}());
exports.LineMatch = LineMatch;
