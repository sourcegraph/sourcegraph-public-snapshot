/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var winjs_base_1 = require('vs/base/common/winjs.base');
var lifecycle_1 = require('vs/base/common/lifecycle');
var TypeConverters = require('vs/workbench/api/node/extHostTypeConverters');
var extHostTypes_1 = require('vs/workbench/api/node/extHostTypes');
var async_1 = require('vs/base/common/async');
var extHost_protocol_1 = require('./extHost.protocol');
var strings_1 = require('vs/base/common/strings');
// --- adapter
var OutlineAdapter = (function () {
    function OutlineAdapter(documents, provider) {
        this._documents = documents;
        this._provider = provider;
    }
    OutlineAdapter.prototype.provideDocumentSymbols = function (resource) {
        var _this = this;
        var doc = this._documents.getDocumentData(resource).document;
        return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentSymbols(doc, token); }).then(function (value) {
            if (Array.isArray(value)) {
                return value.map(TypeConverters.SymbolInformation.toOutlineEntry);
            }
        });
    };
    return OutlineAdapter;
}());
var CodeLensAdapter = (function () {
    function CodeLensAdapter(documents, commands, provider) {
        this._cache = Object.create(null);
        this._documents = documents;
        this._commands = commands;
        this._provider = provider;
    }
    CodeLensAdapter.prototype.provideCodeLenses = function (resource) {
        var _this = this;
        var doc = this._documents.getDocumentData(resource).document;
        var version = doc.version;
        var key = resource.toString();
        // from cache
        var entry = this._cache[key];
        if (entry && entry.version === version) {
            return new async_1.ShallowCancelThenPromise(entry.data.then(function (cached) { return cached.symbols; }));
        }
        var newCodeLensData = async_1.asWinJsPromise(function (token) { return _this._provider.provideCodeLenses(doc, token); }).then(function (lenses) {
            if (!Array.isArray(lenses)) {
                return;
            }
            var data = {
                lenses: lenses,
                symbols: [],
                disposables: [],
            };
            lenses.forEach(function (lens, i) {
                data.symbols.push({
                    id: String(i),
                    range: TypeConverters.fromRange(lens.range),
                    command: TypeConverters.Command.from(lens.command, data.disposables)
                });
            });
            return data;
        });
        this._cache[key] = {
            version: version,
            data: newCodeLensData
        };
        return new async_1.ShallowCancelThenPromise(newCodeLensData.then(function (newCached) {
            if (entry) {
                // only now dispose old commands et al
                entry.data.then(function (oldCached) { return lifecycle_1.dispose(oldCached.disposables); });
            }
            return newCached && newCached.symbols;
        }));
    };
    CodeLensAdapter.prototype.resolveCodeLens = function (resource, symbol) {
        var _this = this;
        var entry = this._cache[resource.toString()];
        if (!entry) {
            return;
        }
        return entry.data.then(function (cachedData) {
            if (!cachedData) {
                return;
            }
            var lens = cachedData.lenses[Number(symbol.id)];
            if (!lens) {
                return;
            }
            var resolve;
            if (typeof _this._provider.resolveCodeLens !== 'function' || lens.isResolved) {
                resolve = winjs_base_1.TPromise.as(lens);
            }
            else {
                resolve = async_1.asWinJsPromise(function (token) { return _this._provider.resolveCodeLens(lens, token); });
            }
            return resolve.then(function (newLens) {
                lens = newLens || lens;
                var command = lens.command;
                if (!command) {
                    command = {
                        title: '<<MISSING COMMAND>>',
                        command: 'missing',
                    };
                }
                symbol.command = TypeConverters.Command.from(command, cachedData.disposables);
                return symbol;
            });
        });
    };
    return CodeLensAdapter;
}());
var DefinitionAdapter = (function () {
    function DefinitionAdapter(documents, provider) {
        this._documents = documents;
        this._provider = provider;
    }
    DefinitionAdapter.prototype.provideDefinition = function (resource, position) {
        var _this = this;
        var doc = this._documents.getDocumentData(resource).document;
        var pos = TypeConverters.toPosition(position);
        return async_1.asWinJsPromise(function (token) { return _this._provider.provideDefinition(doc, pos, token); }).then(function (value) {
            if (Array.isArray(value)) {
                return value.map(DefinitionAdapter._convertLocation);
            }
            else if (value) {
                return DefinitionAdapter._convertLocation(value);
            }
        });
    };
    DefinitionAdapter._convertLocation = function (location) {
        if (!location) {
            return;
        }
        return {
            uri: location.uri,
            range: TypeConverters.fromRange(location.range)
        };
    };
    return DefinitionAdapter;
}());
var HoverAdapter = (function () {
    function HoverAdapter(documents, provider) {
        this._documents = documents;
        this._provider = provider;
    }
    HoverAdapter.prototype.provideHover = function (resource, position) {
        var _this = this;
        var doc = this._documents.getDocumentData(resource).document;
        var pos = TypeConverters.toPosition(position);
        return async_1.asWinJsPromise(function (token) { return _this._provider.provideHover(doc, pos, token); }).then(function (value) {
            if (!value) {
                return;
            }
            if (!value.range) {
                value.range = doc.getWordRangeAtPosition(pos);
            }
            if (!value.range) {
                value.range = new extHostTypes_1.Range(pos, pos);
            }
            return TypeConverters.fromHover(value);
        });
    };
    return HoverAdapter;
}());
var DocumentHighlightAdapter = (function () {
    function DocumentHighlightAdapter(documents, provider) {
        this._documents = documents;
        this._provider = provider;
    }
    DocumentHighlightAdapter.prototype.provideDocumentHighlights = function (resource, position) {
        var _this = this;
        var doc = this._documents.getDocumentData(resource).document;
        var pos = TypeConverters.toPosition(position);
        return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentHighlights(doc, pos, token); }).then(function (value) {
            if (Array.isArray(value)) {
                return value.map(DocumentHighlightAdapter._convertDocumentHighlight);
            }
        });
    };
    DocumentHighlightAdapter._convertDocumentHighlight = function (documentHighlight) {
        return {
            range: TypeConverters.fromRange(documentHighlight.range),
            kind: documentHighlight.kind
        };
    };
    return DocumentHighlightAdapter;
}());
var ReferenceAdapter = (function () {
    function ReferenceAdapter(documents, provider) {
        this._documents = documents;
        this._provider = provider;
    }
    ReferenceAdapter.prototype.provideReferences = function (resource, position, context) {
        var _this = this;
        var doc = this._documents.getDocumentData(resource).document;
        var pos = TypeConverters.toPosition(position);
        return async_1.asWinJsPromise(function (token) { return _this._provider.provideReferences(doc, pos, context, token); }).then(function (value) {
            if (Array.isArray(value)) {
                return value.map(ReferenceAdapter._convertLocation);
            }
        });
    };
    ReferenceAdapter._convertLocation = function (location) {
        return {
            uri: location.uri,
            range: TypeConverters.fromRange(location.range)
        };
    };
    return ReferenceAdapter;
}());
var QuickFixAdapter = (function () {
    function QuickFixAdapter(documents, commands, diagnostics, provider) {
        this._cachedCommands = [];
        this._documents = documents;
        this._commands = commands;
        this._diagnostics = diagnostics;
        this._provider = provider;
    }
    QuickFixAdapter.prototype.provideCodeActions = function (resource, range) {
        var _this = this;
        var doc = this._documents.getDocumentData(resource).document;
        var ran = TypeConverters.toRange(range);
        var allDiagnostics = [];
        this._diagnostics.forEach(function (collection) {
            if (collection.has(resource)) {
                for (var _i = 0, _a = collection.get(resource); _i < _a.length; _i++) {
                    var diagnostic = _a[_i];
                    if (diagnostic.range.intersection(ran)) {
                        allDiagnostics.push(diagnostic);
                    }
                }
            }
        });
        // we cache the last 10 commands that might have been
        // created during type conversion. when as have more
        // than 10 we drop the first three
        var cachedCommands = [];
        if (this._cachedCommands.push(cachedCommands) > 10) {
            lifecycle_1.dispose.apply(void 0, this._cachedCommands.shift());
            lifecycle_1.dispose.apply(void 0, this._cachedCommands.shift());
            lifecycle_1.dispose.apply(void 0, this._cachedCommands.shift());
        }
        return async_1.asWinJsPromise(function (token) { return _this._provider.provideCodeActions(doc, ran, { diagnostics: allDiagnostics }, token); }).then(function (commands) {
            if (!Array.isArray(commands)) {
                return;
            }
            return commands.map(function (command, i) {
                return {
                    command: TypeConverters.Command.from(command, cachedCommands),
                    score: i
                };
            });
        });
    };
    return QuickFixAdapter;
}());
var DocumentFormattingAdapter = (function () {
    function DocumentFormattingAdapter(documents, provider) {
        this._documents = documents;
        this._provider = provider;
    }
    DocumentFormattingAdapter.prototype.provideDocumentFormattingEdits = function (resource, options) {
        var _this = this;
        var _a = this._documents.getDocumentData(resource), document = _a.document, version = _a.version;
        return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentFormattingEdits(document, options, token); }).then(function (value) {
            if (Array.isArray(value)) {
                return TypeConverters.TextEdit.minimalEditOperations(value, document, version);
            }
        });
    };
    return DocumentFormattingAdapter;
}());
var RangeFormattingAdapter = (function () {
    function RangeFormattingAdapter(documents, provider) {
        this._documents = documents;
        this._provider = provider;
    }
    RangeFormattingAdapter.prototype.provideDocumentRangeFormattingEdits = function (resource, range, options) {
        var _this = this;
        var _a = this._documents.getDocumentData(resource), document = _a.document, version = _a.version;
        var ran = TypeConverters.toRange(range);
        return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentRangeFormattingEdits(document, ran, options, token); }).then(function (value) {
            if (Array.isArray(value)) {
                return TypeConverters.TextEdit.minimalEditOperations(value, document, version);
            }
        });
    };
    return RangeFormattingAdapter;
}());
var OnTypeFormattingAdapter = (function () {
    function OnTypeFormattingAdapter(documents, provider) {
        this.autoFormatTriggerCharacters = []; // not here
        this._documents = documents;
        this._provider = provider;
    }
    OnTypeFormattingAdapter.prototype.provideOnTypeFormattingEdits = function (resource, position, ch, options) {
        var _this = this;
        var _a = this._documents.getDocumentData(resource), document = _a.document, version = _a.version;
        var pos = TypeConverters.toPosition(position);
        return async_1.asWinJsPromise(function (token) { return _this._provider.provideOnTypeFormattingEdits(document, pos, ch, options, token); }).then(function (value) {
            if (Array.isArray(value)) {
                return TypeConverters.TextEdit.minimalEditOperations(value, document, version);
            }
        });
    };
    return OnTypeFormattingAdapter;
}());
var NavigateTypeAdapter = (function () {
    function NavigateTypeAdapter(provider, heapService) {
        this._provider = provider;
        this._heapService = heapService;
    }
    NavigateTypeAdapter.prototype.provideWorkspaceSymbols = function (search) {
        var _this = this;
        return async_1.asWinJsPromise(function (token) { return _this._provider.provideWorkspaceSymbols(search, token); }).then(function (value) {
            if (Array.isArray(value)) {
                return value.map(function (item) {
                    var id = _this._heapService.keep(item);
                    var result = TypeConverters.fromSymbolInformation(item);
                    return extHost_protocol_1.ObjectIdentifier.mixin(result, id);
                });
            }
        });
    };
    NavigateTypeAdapter.prototype.resolveWorkspaceSymbol = function (item) {
        var _this = this;
        if (typeof this._provider.resolveWorkspaceSymbol !== 'function') {
            return winjs_base_1.TPromise.as(item);
        }
        var symbolInfo = this._heapService.get(extHost_protocol_1.ObjectIdentifier.get(item));
        if (symbolInfo) {
            return async_1.asWinJsPromise(function (token) { return _this._provider.resolveWorkspaceSymbol(symbolInfo, token); }).then(function (value) {
                return value && TypeConverters.fromSymbolInformation(value);
            });
        }
    };
    return NavigateTypeAdapter;
}());
var RenameAdapter = (function () {
    function RenameAdapter(documents, provider) {
        this._documents = documents;
        this._provider = provider;
    }
    RenameAdapter.prototype.provideRenameEdits = function (resource, position, newName) {
        var _this = this;
        var doc = this._documents.getDocumentData(resource).document;
        var pos = TypeConverters.toPosition(position);
        return async_1.asWinJsPromise(function (token) { return _this._provider.provideRenameEdits(doc, pos, newName, token); }).then(function (value) {
            if (!value) {
                return;
            }
            var result = {
                edits: []
            };
            for (var _i = 0, _a = value.entries(); _i < _a.length; _i++) {
                var entry = _a[_i];
                var uri = entry[0], textEdits = entry[1];
                for (var _b = 0, textEdits_1 = textEdits; _b < textEdits_1.length; _b++) {
                    var textEdit = textEdits_1[_b];
                    result.edits.push({
                        resource: uri,
                        newText: textEdit.newText,
                        range: TypeConverters.fromRange(textEdit.range)
                    });
                }
            }
            return result;
        }, function (err) {
            if (typeof err === 'string') {
                return {
                    edits: undefined,
                    rejectReason: err
                };
            }
            return winjs_base_1.TPromise.wrapError(err);
        });
    };
    return RenameAdapter;
}());
var SuggestAdapter = (function () {
    function SuggestAdapter(documents, heapService, provider) {
        this._disposables = [];
        this._documents = documents;
        this._heapService = heapService;
        this._provider = provider;
    }
    SuggestAdapter.prototype.provideCompletionItems = function (resource, position) {
        var _this = this;
        var doc = this._documents.getDocumentData(resource).document;
        var pos = TypeConverters.toPosition(position);
        return async_1.asWinJsPromise(function (token) { return _this._provider.provideCompletionItems(doc, pos, token); }).then(function (value) {
            var result = {
                suggestions: [],
                currentWord: ''
            };
            // the default text edit range
            var wordRangeBeforePos = (doc.getWordRangeAtPosition(pos) || new extHostTypes_1.Range(pos, pos))
                .with({ end: pos });
            var list;
            if (!value) {
                // undefined and null are valid results
                return;
            }
            else if (Array.isArray(value)) {
                list = new extHostTypes_1.CompletionList(value);
            }
            else {
                list = value;
                result.incomplete = list.isIncomplete;
            }
            var _loop_1 = function(i) {
                var item = list.items[i];
                var disposables = [];
                var suggestion = TypeConverters.Suggest.from(item, disposables);
                var id = _this._heapService.keep(item, function () { return lifecycle_1.dispose(_this._disposables[id]); });
                _this._disposables[id] = disposables;
                extHost_protocol_1.ObjectIdentifier.mixin(suggestion, id);
                if (item.textEdit) {
                    var editRange = item.textEdit.range;
                    // invalid text edit
                    if (!editRange.isSingleLine || editRange.start.line !== pos.line) {
                        console.warn('INVALID text edit, must be single line and on the same line');
                        return "continue";
                    }
                    // insert the text of the edit and create a dedicated
                    // suggestion-container with overwrite[Before|After]
                    suggestion.insertText = item.textEdit.newText;
                    suggestion.overwriteBefore = pos.character - editRange.start.character;
                    suggestion.overwriteAfter = editRange.end.character - pos.character;
                }
                else {
                    // default text edit
                    suggestion.overwriteBefore = pos.character - wordRangeBeforePos.start.character;
                    suggestion.overwriteAfter = 0;
                }
                // store suggestion
                result.suggestions.push(suggestion);
            };
            for (var i = 0; i < list.items.length; i++) {
                _loop_1(i);
            }
            return result;
        });
    };
    SuggestAdapter.prototype.resolveCompletionItem = function (resource, position, suggestion) {
        var _this = this;
        if (typeof this._provider.resolveCompletionItem !== 'function') {
            return winjs_base_1.TPromise.as(suggestion);
        }
        var id = extHost_protocol_1.ObjectIdentifier.get(suggestion);
        var item = this._heapService.get(id);
        if (!item) {
            return winjs_base_1.TPromise.as(suggestion);
        }
        return async_1.asWinJsPromise(function (token) { return _this._provider.resolveCompletionItem(item, token); }).then(function (resolvedItem) {
            return TypeConverters.Suggest.from(resolvedItem || item, _this._disposables[id]);
        });
    };
    return SuggestAdapter;
}());
var SignatureHelpAdapter = (function () {
    function SignatureHelpAdapter(documents, provider) {
        this._documents = documents;
        this._provider = provider;
    }
    SignatureHelpAdapter.prototype.provideSignatureHelp = function (resource, position) {
        var _this = this;
        var doc = this._documents.getDocumentData(resource).document;
        var pos = TypeConverters.toPosition(position);
        return async_1.asWinJsPromise(function (token) { return _this._provider.provideSignatureHelp(doc, pos, token); }).then(function (value) {
            if (value) {
                return TypeConverters.SignatureHelp.from(value);
            }
        });
    };
    return SignatureHelpAdapter;
}());
var LinkProviderAdapter = (function () {
    function LinkProviderAdapter(documents, provider) {
        this._documents = documents;
        this._provider = provider;
    }
    LinkProviderAdapter.prototype.provideLinks = function (resource) {
        var _this = this;
        var doc = this._documents.getDocumentData(resource).document;
        return async_1.asWinJsPromise(function (token) { return _this._provider.provideDocumentLinks(doc, token); }).then(function (links) {
            if (Array.isArray(links)) {
                return links.map(TypeConverters.DocumentLink.from);
            }
        });
    };
    LinkProviderAdapter.prototype.resolveLink = function (link) {
        var _this = this;
        if (typeof this._provider.resolveDocumentLink === 'function') {
            return async_1.asWinJsPromise(function (token) { return _this._provider.resolveDocumentLink(TypeConverters.DocumentLink.to(link), token); }).then(function (value) {
                if (value) {
                    return TypeConverters.DocumentLink.from(value);
                }
            });
        }
    };
    return LinkProviderAdapter;
}());
var ExtHostLanguageFeatures = (function (_super) {
    __extends(ExtHostLanguageFeatures, _super);
    function ExtHostLanguageFeatures(threadService, documents, commands, heapMonitor, diagnostics) {
        _super.call(this);
        this._adapter = Object.create(null);
        this._proxy = threadService.get(extHost_protocol_1.MainContext.MainThreadLanguageFeatures);
        this._documents = documents;
        this._commands = commands;
        this._heapService = heapMonitor;
        this._diagnostics = diagnostics;
    }
    ExtHostLanguageFeatures.prototype._createDisposable = function (handle) {
        var _this = this;
        return new extHostTypes_1.Disposable(function () {
            delete _this._adapter[handle];
            _this._proxy.$unregister(handle);
        });
    };
    ExtHostLanguageFeatures.prototype._nextHandle = function () {
        return ExtHostLanguageFeatures._handlePool++;
    };
    ExtHostLanguageFeatures.prototype._withAdapter = function (handle, ctor, callback) {
        var adapter = this._adapter[handle];
        if (!(adapter instanceof ctor)) {
            return winjs_base_1.TPromise.wrapError(new Error('no adapter found'));
        }
        return callback(adapter);
    };
    // --- outline
    ExtHostLanguageFeatures.prototype.registerDocumentSymbolProvider = function (selector, provider) {
        var handle = this._nextHandle();
        this._adapter[handle] = new OutlineAdapter(this._documents, provider);
        this._proxy.$registerOutlineSupport(handle, selector);
        return this._createDisposable(handle);
    };
    ExtHostLanguageFeatures.prototype.$provideDocumentSymbols = function (handle, resource) {
        return this._withAdapter(handle, OutlineAdapter, function (adapter) { return adapter.provideDocumentSymbols(resource); });
    };
    // --- code lens
    ExtHostLanguageFeatures.prototype.registerCodeLensProvider = function (selector, provider) {
        var handle = this._nextHandle();
        this._adapter[handle] = new CodeLensAdapter(this._documents, this._commands, provider);
        this._proxy.$registerCodeLensSupport(handle, selector);
        return this._createDisposable(handle);
    };
    ExtHostLanguageFeatures.prototype.$provideCodeLenses = function (handle, resource) {
        return this._withAdapter(handle, CodeLensAdapter, function (adapter) { return adapter.provideCodeLenses(resource); });
    };
    ExtHostLanguageFeatures.prototype.$resolveCodeLens = function (handle, resource, symbol) {
        return this._withAdapter(handle, CodeLensAdapter, function (adapter) { return adapter.resolveCodeLens(resource, symbol); });
    };
    // --- declaration
    ExtHostLanguageFeatures.prototype.registerDefinitionProvider = function (selector, provider) {
        var handle = this._nextHandle();
        this._adapter[handle] = new DefinitionAdapter(this._documents, provider);
        this._proxy.$registerDeclaractionSupport(handle, selector);
        return this._createDisposable(handle);
    };
    ExtHostLanguageFeatures.prototype.$provideDefinition = function (handle, resource, position) {
        return this._withAdapter(handle, DefinitionAdapter, function (adapter) { return adapter.provideDefinition(resource, position); });
    };
    // --- extra info
    ExtHostLanguageFeatures.prototype.registerHoverProvider = function (selector, provider) {
        var handle = this._nextHandle();
        this._adapter[handle] = new HoverAdapter(this._documents, provider);
        this._proxy.$registerHoverProvider(handle, selector);
        return this._createDisposable(handle);
    };
    ExtHostLanguageFeatures.prototype.$provideHover = function (handle, resource, position) {
        return this._withAdapter(handle, HoverAdapter, function (adpater) { return adpater.provideHover(resource, position); });
    };
    // --- occurrences
    ExtHostLanguageFeatures.prototype.registerDocumentHighlightProvider = function (selector, provider) {
        var handle = this._nextHandle();
        this._adapter[handle] = new DocumentHighlightAdapter(this._documents, provider);
        this._proxy.$registerDocumentHighlightProvider(handle, selector);
        return this._createDisposable(handle);
    };
    ExtHostLanguageFeatures.prototype.$provideDocumentHighlights = function (handle, resource, position) {
        return this._withAdapter(handle, DocumentHighlightAdapter, function (adapter) { return adapter.provideDocumentHighlights(resource, position); });
    };
    // --- references
    ExtHostLanguageFeatures.prototype.registerReferenceProvider = function (selector, provider) {
        var handle = this._nextHandle();
        this._adapter[handle] = new ReferenceAdapter(this._documents, provider);
        this._proxy.$registerReferenceSupport(handle, selector);
        return this._createDisposable(handle);
    };
    ExtHostLanguageFeatures.prototype.$provideReferences = function (handle, resource, position, context) {
        return this._withAdapter(handle, ReferenceAdapter, function (adapter) { return adapter.provideReferences(resource, position, context); });
    };
    // --- quick fix
    ExtHostLanguageFeatures.prototype.registerCodeActionProvider = function (selector, provider) {
        var handle = this._nextHandle();
        this._adapter[handle] = new QuickFixAdapter(this._documents, this._commands, this._diagnostics, provider);
        this._proxy.$registerQuickFixSupport(handle, selector);
        return this._createDisposable(handle);
    };
    ExtHostLanguageFeatures.prototype.$provideCodeActions = function (handle, resource, range) {
        return this._withAdapter(handle, QuickFixAdapter, function (adapter) { return adapter.provideCodeActions(resource, range); });
    };
    // --- formatting
    ExtHostLanguageFeatures.prototype.registerDocumentFormattingEditProvider = function (selector, provider) {
        var handle = this._nextHandle();
        this._adapter[handle] = new DocumentFormattingAdapter(this._documents, provider);
        this._proxy.$registerDocumentFormattingSupport(handle, selector);
        return this._createDisposable(handle);
    };
    ExtHostLanguageFeatures.prototype.$provideDocumentFormattingEdits = function (handle, resource, options) {
        return this._withAdapter(handle, DocumentFormattingAdapter, function (adapter) { return adapter.provideDocumentFormattingEdits(resource, options); });
    };
    ExtHostLanguageFeatures.prototype.registerDocumentRangeFormattingEditProvider = function (selector, provider) {
        var handle = this._nextHandle();
        this._adapter[handle] = new RangeFormattingAdapter(this._documents, provider);
        this._proxy.$registerRangeFormattingSupport(handle, selector);
        return this._createDisposable(handle);
    };
    ExtHostLanguageFeatures.prototype.$provideDocumentRangeFormattingEdits = function (handle, resource, range, options) {
        return this._withAdapter(handle, RangeFormattingAdapter, function (adapter) { return adapter.provideDocumentRangeFormattingEdits(resource, range, options); });
    };
    ExtHostLanguageFeatures.prototype.registerOnTypeFormattingEditProvider = function (selector, provider, triggerCharacters) {
        var handle = this._nextHandle();
        this._adapter[handle] = new OnTypeFormattingAdapter(this._documents, provider);
        this._proxy.$registerOnTypeFormattingSupport(handle, selector, triggerCharacters);
        return this._createDisposable(handle);
    };
    ExtHostLanguageFeatures.prototype.$provideOnTypeFormattingEdits = function (handle, resource, position, ch, options) {
        return this._withAdapter(handle, OnTypeFormattingAdapter, function (adapter) { return adapter.provideOnTypeFormattingEdits(resource, position, ch, options); });
    };
    // --- navigate types
    ExtHostLanguageFeatures.prototype.registerWorkspaceSymbolProvider = function (provider) {
        var handle = this._nextHandle();
        this._adapter[handle] = new NavigateTypeAdapter(provider, this._heapService);
        this._proxy.$registerNavigateTypeSupport(handle);
        return this._createDisposable(handle);
    };
    ExtHostLanguageFeatures.prototype.$provideWorkspaceSymbols = function (handle, search) {
        return this._withAdapter(handle, NavigateTypeAdapter, function (adapter) { return adapter.provideWorkspaceSymbols(search); });
    };
    ExtHostLanguageFeatures.prototype.$resolveWorkspaceSymbol = function (handle, symbol) {
        return this._withAdapter(handle, NavigateTypeAdapter, function (adapter) { return adapter.resolveWorkspaceSymbol(symbol); });
    };
    // --- rename
    ExtHostLanguageFeatures.prototype.registerRenameProvider = function (selector, provider) {
        var handle = this._nextHandle();
        this._adapter[handle] = new RenameAdapter(this._documents, provider);
        this._proxy.$registerRenameSupport(handle, selector);
        return this._createDisposable(handle);
    };
    ExtHostLanguageFeatures.prototype.$provideRenameEdits = function (handle, resource, position, newName) {
        return this._withAdapter(handle, RenameAdapter, function (adapter) { return adapter.provideRenameEdits(resource, position, newName); });
    };
    // --- suggestion
    ExtHostLanguageFeatures.prototype.registerCompletionItemProvider = function (selector, provider, triggerCharacters) {
        var handle = this._nextHandle();
        this._adapter[handle] = new SuggestAdapter(this._documents, this._heapService, provider);
        this._proxy.$registerSuggestSupport(handle, selector, triggerCharacters);
        return this._createDisposable(handle);
    };
    ExtHostLanguageFeatures.prototype.$provideCompletionItems = function (handle, resource, position) {
        return this._withAdapter(handle, SuggestAdapter, function (adapter) { return adapter.provideCompletionItems(resource, position); });
    };
    ExtHostLanguageFeatures.prototype.$resolveCompletionItem = function (handle, resource, position, suggestion) {
        return this._withAdapter(handle, SuggestAdapter, function (adapter) { return adapter.resolveCompletionItem(resource, position, suggestion); });
    };
    // --- parameter hints
    ExtHostLanguageFeatures.prototype.registerSignatureHelpProvider = function (selector, provider, triggerCharacters) {
        var handle = this._nextHandle();
        this._adapter[handle] = new SignatureHelpAdapter(this._documents, provider);
        this._proxy.$registerSignatureHelpProvider(handle, selector, triggerCharacters);
        return this._createDisposable(handle);
    };
    ExtHostLanguageFeatures.prototype.$provideSignatureHelp = function (handle, resource, position) {
        return this._withAdapter(handle, SignatureHelpAdapter, function (adapter) { return adapter.provideSignatureHelp(resource, position); });
    };
    // --- links
    ExtHostLanguageFeatures.prototype.registerDocumentLinkProvider = function (selector, provider) {
        var handle = this._nextHandle();
        this._adapter[handle] = new LinkProviderAdapter(this._documents, provider);
        this._proxy.$registerDocumentLinkProvider(handle, selector);
        return this._createDisposable(handle);
    };
    ExtHostLanguageFeatures.prototype.$provideDocumentLinks = function (handle, resource) {
        return this._withAdapter(handle, LinkProviderAdapter, function (adapter) { return adapter.provideLinks(resource); });
    };
    ExtHostLanguageFeatures.prototype.$resolveDocumentLink = function (handle, link) {
        return this._withAdapter(handle, LinkProviderAdapter, function (adapter) { return adapter.resolveLink(link); });
    };
    // --- configuration
    ExtHostLanguageFeatures.prototype.setLanguageConfiguration = function (languageId, configuration) {
        var wordPattern = configuration.wordPattern;
        // check for a valid word pattern
        if (wordPattern && strings_1.regExpLeadsToEndlessLoop(wordPattern)) {
            throw new Error("Invalid language configuration: wordPattern '" + wordPattern + "' is not allowed to match the empty string.");
        }
        // word definition
        if (wordPattern) {
            this._documents.setWordDefinitionFor(languageId, wordPattern);
        }
        else {
            this._documents.setWordDefinitionFor(languageId, null);
        }
        var handle = this._nextHandle();
        this._proxy.$setLanguageConfiguration(handle, languageId, configuration);
        return this._createDisposable(handle);
    };
    ExtHostLanguageFeatures._handlePool = 0;
    return ExtHostLanguageFeatures;
}(extHost_protocol_1.ExtHostLanguageFeaturesShape));
exports.ExtHostLanguageFeatures = ExtHostLanguageFeatures;
