/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var nls_1 = require("vs/nls");
var uri_1 = require("vs/base/common/uri");
var severity_1 = require("vs/base/common/severity");
var extHost_protocol_1 = require("./extHost.protocol");
var extHostTypes_1 = require("./extHostTypes");
var DiagnosticCollection = (function () {
    function DiagnosticCollection(name, proxy) {
        this._isDisposed = false;
        this._data = Object.create(null);
        this._name = name;
        this._proxy = proxy;
    }
    DiagnosticCollection.prototype.dispose = function () {
        if (!this._isDisposed) {
            this._proxy.$clear(this.name);
            this._proxy = undefined;
            this._data = undefined;
            this._isDisposed = true;
        }
    };
    Object.defineProperty(DiagnosticCollection.prototype, "name", {
        get: function () {
            this._checkDisposed();
            return this._name;
        },
        enumerable: true,
        configurable: true
    });
    DiagnosticCollection.prototype.set = function (first, diagnostics) {
        if (!first) {
            // this set-call is a clear-call
            this.clear();
            return;
        }
        // the actual implementation for #set
        this._checkDisposed();
        var toSync;
        if (first instanceof uri_1.default) {
            if (!diagnostics) {
                // remove this entry
                this.delete(first);
                return;
            }
            // update single row
            this._data[first.toString()] = diagnostics;
            toSync = [first];
        }
        else if (Array.isArray(first)) {
            // update many rows
            toSync = [];
            var lastUri = void 0;
            // ensure stable-sort: keep the original
            // index for otherwise equal items
            var sortedTuples = first
                .map(function (tuple, idx) { return ({ tuple: tuple, idx: idx }); })
                .sort(DiagnosticCollection._compareIndexedTuplesByUri);
            for (var _i = 0, sortedTuples_1 = sortedTuples; _i < sortedTuples_1.length; _i++) {
                var tuple = sortedTuples_1[_i].tuple;
                var uri = tuple[0], diagnostics_1 = tuple[1];
                if (!lastUri || uri.toString() !== lastUri.toString()) {
                    if (lastUri && this._data[lastUri.toString()].length === 0) {
                        delete this._data[lastUri.toString()];
                    }
                    lastUri = uri;
                    toSync.push(uri);
                    this._data[uri.toString()] = [];
                }
                if (!diagnostics_1) {
                    // [Uri, undefined] means clear this
                    this._data[uri.toString()].length = 0;
                }
                else {
                    (_a = this._data[uri.toString()]).push.apply(_a, diagnostics_1);
                }
            }
        }
        // compute change and send to main side
        var entries = [];
        for (var _b = 0, toSync_1 = toSync; _b < toSync_1.length; _b++) {
            var uri = toSync_1[_b];
            var marker = void 0;
            var diagnostics_2 = this._data[uri.toString()];
            if (diagnostics_2) {
                // no more than 250 diagnostics per file
                if (diagnostics_2.length > DiagnosticCollection._maxDiagnosticsPerFile) {
                    marker = [];
                    var order = [extHostTypes_1.DiagnosticSeverity.Error, extHostTypes_1.DiagnosticSeverity.Warning, extHostTypes_1.DiagnosticSeverity.Information, extHostTypes_1.DiagnosticSeverity.Hint];
                    orderLoop: for (var i = 0; i < 4; i++) {
                        for (var _c = 0, diagnostics_3 = diagnostics_2; _c < diagnostics_3.length; _c++) {
                            var diagnostic = diagnostics_3[_c];
                            if (diagnostic.severity === order[i]) {
                                var len = marker.push(DiagnosticCollection._toMarkerData(diagnostic));
                                if (len === DiagnosticCollection._maxDiagnosticsPerFile) {
                                    break orderLoop;
                                }
                            }
                        }
                    }
                    // add 'signal' marker for showing omitted errors/warnings
                    marker.push({
                        severity: severity_1.default.Error,
                        message: nls_1.localize({ key: 'limitHit', comment: ['amount of errors/warning skipped due to limits'] }, "Not showing {0} further errors and warnings.", diagnostics_2.length - DiagnosticCollection._maxDiagnosticsPerFile),
                        startLineNumber: marker[marker.length - 1].startLineNumber,
                        startColumn: marker[marker.length - 1].startColumn,
                        endLineNumber: marker[marker.length - 1].endLineNumber,
                        endColumn: marker[marker.length - 1].endColumn
                    });
                }
                else {
                    marker = diagnostics_2.map(DiagnosticCollection._toMarkerData);
                }
            }
            entries.push([uri, marker]);
        }
        this._proxy.$changeMany(this.name, entries);
        var _a;
    };
    DiagnosticCollection.prototype.delete = function (uri) {
        this._checkDisposed();
        delete this._data[uri.toString()];
        this._proxy.$changeMany(this.name, [[uri, undefined]]);
    };
    DiagnosticCollection.prototype.clear = function () {
        this._checkDisposed();
        this._data = Object.create(null);
        this._proxy.$clear(this.name);
    };
    DiagnosticCollection.prototype.forEach = function (callback, thisArg) {
        this._checkDisposed();
        for (var key in this._data) {
            var uri = uri_1.default.parse(key);
            callback.apply(thisArg, [uri, this.get(uri), this]);
        }
    };
    DiagnosticCollection.prototype.get = function (uri) {
        this._checkDisposed();
        var result = this._data[uri.toString()];
        if (Array.isArray(result)) {
            return Object.freeze(result.slice(0));
        }
    };
    DiagnosticCollection.prototype.has = function (uri) {
        this._checkDisposed();
        return Array.isArray(this._data[uri.toString()]);
    };
    DiagnosticCollection.prototype._checkDisposed = function () {
        if (this._isDisposed) {
            throw new Error('illegal state - object is disposed');
        }
    };
    DiagnosticCollection._toMarkerData = function (diagnostic) {
        var range = diagnostic.range;
        return {
            startLineNumber: range.start.line + 1,
            startColumn: range.start.character + 1,
            endLineNumber: range.end.line + 1,
            endColumn: range.end.character + 1,
            message: diagnostic.message,
            source: diagnostic.source,
            severity: DiagnosticCollection._convertDiagnosticsSeverity(diagnostic.severity),
            code: String(diagnostic.code)
        };
    };
    DiagnosticCollection._convertDiagnosticsSeverity = function (severity) {
        switch (severity) {
            case 0: return severity_1.default.Error;
            case 1: return severity_1.default.Warning;
            case 2: return severity_1.default.Info;
            case 3: return severity_1.default.Ignore;
            default: return severity_1.default.Error;
        }
    };
    DiagnosticCollection._compareIndexedTuplesByUri = function (a, b) {
        if (a.tuple[0].toString() < b.tuple[0].toString()) {
            return -1;
        }
        else if (a.tuple[0].toString() > b.tuple[0].toString()) {
            return 1;
        }
        else if (a.idx < b.idx) {
            return -1;
        }
        else if (a.idx > b.idx) {
            return 1;
        }
        else {
            return 0;
        }
    };
    return DiagnosticCollection;
}());
DiagnosticCollection._maxDiagnosticsPerFile = 250;
exports.DiagnosticCollection = DiagnosticCollection;
var ExtHostDiagnostics = (function (_super) {
    __extends(ExtHostDiagnostics, _super);
    function ExtHostDiagnostics(threadService) {
        var _this = _super.call(this) || this;
        _this._proxy = threadService.get(extHost_protocol_1.MainContext.MainThreadDiagnostics);
        _this._collections = [];
        return _this;
    }
    ExtHostDiagnostics.prototype.createDiagnosticCollection = function (name) {
        if (!name) {
            name = '_generated_diagnostic_collection_name_#' + ExtHostDiagnostics._idPool++;
        }
        var _a = this, _collections = _a._collections, _proxy = _a._proxy;
        var result = new (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                var _this = _super.call(this, name, _proxy) || this;
                _collections.push(_this);
                return _this;
            }
            class_1.prototype.dispose = function () {
                _super.prototype.dispose.call(this);
                var idx = _collections.indexOf(this);
                if (idx !== -1) {
                    _collections.splice(idx, 1);
                }
            };
            return class_1;
        }(DiagnosticCollection));
        return result;
    };
    ExtHostDiagnostics.prototype.forEach = function (callback) {
        this._collections.forEach(callback);
    };
    return ExtHostDiagnostics;
}(extHost_protocol_1.ExtHostDiagnosticsShape));
ExtHostDiagnostics._idPool = 0;
exports.ExtHostDiagnostics = ExtHostDiagnostics;
