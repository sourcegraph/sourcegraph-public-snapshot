/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
require("./media/activityaction.css");
var nls = require("vs/nls");
var DOM = require("vs/base/browser/dom");
var errors = require("vs/base/common/errors");
var winjs_base_1 = require("vs/base/common/winjs.base");
var builder_1 = require("vs/base/browser/builder");
var dnd_1 = require("vs/base/browser/dnd");
var actions_1 = require("vs/base/common/actions");
var actionbar_1 = require("vs/base/browser/ui/actionbar/actionbar");
var activityBarService_1 = require("vs/workbench/services/activity/common/activityBarService");
var event_1 = require("vs/base/common/event");
var contextView_1 = require("vs/platform/contextview/browser/contextView");
var commands_1 = require("vs/platform/commands/common/commands");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var keybinding_1 = require("vs/platform/keybinding/common/keybinding");
var lifecycle_1 = require("vs/base/common/lifecycle");
var viewlet_1 = require("vs/workbench/services/viewlet/browser/viewlet");
var partService_1 = require("vs/workbench/services/part/common/partService");
var ActivityAction = (function (_super) {
    __extends(ActivityAction, _super);
    function ActivityAction(id, name, clazz) {
        var _this = _super.call(this, id, name, clazz) || this;
        _this._onDidChangeBadge = new event_1.Emitter();
        _this.badge = null;
        return _this;
    }
    Object.defineProperty(ActivityAction.prototype, "onDidChangeBadge", {
        get: function () {
            return this._onDidChangeBadge.event;
        },
        enumerable: true,
        configurable: true
    });
    ActivityAction.prototype.activate = function () {
        if (!this.checked) {
            this._setChecked(true);
        }
    };
    ActivityAction.prototype.deactivate = function () {
        if (this.checked) {
            this._setChecked(false);
        }
    };
    ActivityAction.prototype.getBadge = function () {
        return this.badge;
    };
    ActivityAction.prototype.setBadge = function (badge) {
        this.badge = badge;
        this._onDidChangeBadge.fire(this);
    };
    return ActivityAction;
}(actions_1.Action));
exports.ActivityAction = ActivityAction;
var ViewletActivityAction = (function (_super) {
    __extends(ViewletActivityAction, _super);
    function ViewletActivityAction(viewlet, viewletService, partService) {
        var _this = _super.call(this, viewlet.id, viewlet.name, viewlet.cssClass) || this;
        _this.viewlet = viewlet;
        _this.viewletService = viewletService;
        _this.partService = partService;
        _this.lastRun = 0;
        return _this;
    }
    ViewletActivityAction.prototype.run = function (event) {
        if (event instanceof MouseEvent && event.button === 2) {
            return winjs_base_1.TPromise.as(false); // do not run on right click
        }
        // prevent accident trigger on a doubleclick (to help nervous people)
        var now = Date.now();
        if (now - this.lastRun < ViewletActivityAction.preventDoubleClickDelay) {
            return winjs_base_1.TPromise.as(true);
        }
        this.lastRun = now;
        var sideBarVisible = this.partService.isVisible(partService_1.Parts.SIDEBAR_PART);
        var activeViewlet = this.viewletService.getActiveViewlet();
        // Hide sidebar if selected viewlet already visible
        if (sideBarVisible && activeViewlet && activeViewlet.getId() === this.viewlet.id) {
            this.partService.setSideBarHidden(true);
        }
        else {
            this.viewletService.openViewlet(this.viewlet.id, true).done(null, errors.onUnexpectedError);
            this.activate();
        }
        return winjs_base_1.TPromise.as(true);
    };
    return ViewletActivityAction;
}(ActivityAction));
ViewletActivityAction.preventDoubleClickDelay = 300;
ViewletActivityAction = __decorate([
    __param(1, viewlet_1.IViewletService),
    __param(2, partService_1.IPartService)
], ViewletActivityAction);
exports.ViewletActivityAction = ViewletActivityAction;
var ActivityActionItem = (function (_super) {
    __extends(ActivityActionItem, _super);
    function ActivityActionItem(action, viewlet, contextMenuService, activityBarService, keybindingService, instantiationService) {
        var _this = _super.call(this, null, action, { draggable: true }) || this;
        _this.viewlet = viewlet;
        _this.contextMenuService = contextMenuService;
        _this.activityBarService = activityBarService;
        _this.keybindingService = keybindingService;
        _this.cssClass = action.class;
        _this.name = viewlet.name;
        _this._keybinding = _this.getKeybindingLabel(viewlet.id);
        if (!ActivityActionItem.manageExtensionAction) {
            ActivityActionItem.manageExtensionAction = instantiationService.createInstance(ManageExtensionAction);
        }
        if (!ActivityActionItem.toggleViewletPinnedAction) {
            ActivityActionItem.toggleViewletPinnedAction = instantiationService.createInstance(ToggleViewletPinnedAction, void 0);
        }
        action.onDidChangeBadge(_this.handleBadgeChangeEvenet, _this, _this._callOnDispose);
        return _this;
    }
    ActivityActionItem.prototype.getKeybindingLabel = function (id) {
        var _this = this;
        var keys = this.keybindingService.lookupKeybindings(id).map(function (k) { return _this.keybindingService.getLabelFor(k); });
        if (keys && keys.length) {
            return keys[0];
        }
        return null;
    };
    ActivityActionItem.prototype.render = function (container) {
        var _this = this;
        _super.prototype.render.call(this, container);
        this.$e = builder_1.$('a.action-label').attr({
            tabIndex: '0',
            role: 'button'
        }).appendTo(this.builder);
        // Try hard to prevent keyboard only focus feedback when using mouse
        this.$e.on(DOM.EventType.MOUSE_DOWN, function () {
            _this.$e.addClass('clicked');
        });
        this.$e.on(DOM.EventType.MOUSE_UP, function () {
            if (_this.mouseUpTimeout) {
                clearTimeout(_this.mouseUpTimeout);
            }
            _this.mouseUpTimeout = setTimeout(function () {
                _this.$e.removeClass('clicked');
            }, 800); // delayed to prevent focus feedback from showing on mouse up
        });
        builder_1.$(container).on('contextmenu', function (e) {
            DOM.EventHelper.stop(e, true);
            _this.showContextMenu(container);
        });
        if (this.cssClass) {
            this.$e.addClass(this.cssClass);
        }
        this.$badge = this.builder.div({ 'class': 'badge' }, function (badge) {
            _this.$badgeContent = badge.div({ 'class': 'badge-content' });
        });
        this.$badge.hide();
        this.keybinding = this._keybinding; // force update
        // Activate on drag over to reveal targets
        [this.$badge, this.$e].forEach(function (b) { return new dnd_1.DelayedDragHandler(b.getHTMLElement(), function () {
            if (!ActivityActionItem.getDraggedViewlet() && !_this.getAction().checked) {
                _this.getAction().run();
            }
        }); });
        // Allow to drag
        builder_1.$(container).on(DOM.EventType.DRAG_START, function (e) {
            e.dataTransfer.effectAllowed = 'move';
            _this.setDraggedViewlet(_this.viewlet);
            // Trigger the action even on drag start to prevent clicks from failing that started a drag
            if (!_this.getAction().checked) {
                _this.getAction().run();
            }
        });
        // Drag enter
        var counter = 0; // see https://github.com/Microsoft/vscode/issues/14470
        builder_1.$(container).on(DOM.EventType.DRAG_ENTER, function (e) {
            var draggedViewlet = ActivityActionItem.getDraggedViewlet();
            if (draggedViewlet && draggedViewlet.id !== _this.viewlet.id) {
                counter++;
                DOM.addClass(container, 'dropfeedback');
            }
        });
        // Drag leave
        builder_1.$(container).on(DOM.EventType.DRAG_LEAVE, function (e) {
            var draggedViewlet = ActivityActionItem.getDraggedViewlet();
            if (draggedViewlet) {
                counter--;
                if (counter === 0) {
                    DOM.removeClass(container, 'dropfeedback');
                }
            }
        });
        // Drag end
        builder_1.$(container).on(DOM.EventType.DRAG_END, function (e) {
            var draggedViewlet = ActivityActionItem.getDraggedViewlet();
            if (draggedViewlet) {
                counter = 0;
                DOM.removeClass(container, 'dropfeedback');
                ActivityActionItem.clearDraggedViewlet();
            }
        });
        // Drop
        builder_1.$(container).on(DOM.EventType.DROP, function (e) {
            DOM.EventHelper.stop(e, true);
            var draggedViewlet = ActivityActionItem.getDraggedViewlet();
            if (draggedViewlet && draggedViewlet.id !== _this.viewlet.id) {
                DOM.removeClass(container, 'dropfeedback');
                ActivityActionItem.clearDraggedViewlet();
                _this.activityBarService.move(draggedViewlet.id, _this.viewlet.id);
            }
        });
    };
    ActivityActionItem.getDraggedViewlet = function () {
        return ActivityActionItem.draggedViewlet;
    };
    ActivityActionItem.prototype.setDraggedViewlet = function (viewlet) {
        ActivityActionItem.draggedViewlet = viewlet;
    };
    ActivityActionItem.clearDraggedViewlet = function () {
        ActivityActionItem.draggedViewlet = void 0;
    };
    ActivityActionItem.prototype.showContextMenu = function (container) {
        var _this = this;
        var actions = [ActivityActionItem.toggleViewletPinnedAction];
        if (this.viewlet.extensionId) {
            actions.push(new actionbar_1.Separator());
            actions.push(ActivityActionItem.manageExtensionAction);
        }
        var isPinned = this.activityBarService.isPinned(this.viewlet.id);
        if (isPinned) {
            ActivityActionItem.toggleViewletPinnedAction.label = nls.localize('removeFromActivityBar', "Remove from Activity Bar");
        }
        else {
            ActivityActionItem.toggleViewletPinnedAction.label = nls.localize('keepInActivityBar', "Keep in Activity Bar");
        }
        this.contextMenuService.showContextMenu({
            getAnchor: function () { return container; },
            getActionsContext: function () { return _this.viewlet; },
            getActions: function () { return winjs_base_1.TPromise.as(actions); }
        });
    };
    ActivityActionItem.prototype.focus = function () {
        this.$e.domFocus();
    };
    ActivityActionItem.prototype.setBadge = function (badge) {
        this.updateBadge(badge);
    };
    Object.defineProperty(ActivityActionItem.prototype, "keybinding", {
        set: function (keybinding) {
            this._keybinding = keybinding;
            if (!this.$e) {
                return;
            }
            var title;
            if (keybinding) {
                title = nls.localize('titleKeybinding', "{0} ({1})", this.name, keybinding);
            }
            else {
                title = this.name;
            }
            this.$e.title(title);
            this.$badge.title(title);
        },
        enumerable: true,
        configurable: true
    });
    ActivityActionItem.prototype.updateBadge = function (badge) {
        this.$badgeContent.empty();
        this.$badge.hide();
        if (badge) {
            // Number
            if (badge instanceof activityBarService_1.NumberBadge) {
                if (badge.number) {
                    this.$badgeContent.text(badge.number > 99 ? '99+' : badge.number.toString());
                    this.$badge.show();
                }
            }
            else if (badge instanceof activityBarService_1.TextBadge) {
                this.$badgeContent.text(badge.text);
                this.$badge.show();
            }
            else if (badge instanceof activityBarService_1.IconBadge) {
                this.$badge.show();
            }
            else if (badge instanceof activityBarService_1.ProgressBadge) {
                this.$badge.show();
            }
            this.$e.attr('aria-label', this.name + " - " + badge.getDescription());
        }
    };
    ActivityActionItem.prototype._updateClass = function () {
        if (this.cssClass) {
            this.$badge.removeClass(this.cssClass);
        }
        this.cssClass = this.getAction().class;
        this.$badge.addClass(this.cssClass);
    };
    ActivityActionItem.prototype._updateChecked = function () {
        if (this.getAction().checked) {
            this.$e.addClass('active');
        }
        else {
            this.$e.removeClass('active');
        }
    };
    ActivityActionItem.prototype.handleBadgeChangeEvenet = function () {
        var action = this.getAction();
        if (action instanceof ActivityAction) {
            this.updateBadge(action.getBadge());
        }
    };
    ActivityActionItem.prototype._updateEnabled = function () {
        if (this.getAction().enabled) {
            this.builder.removeClass('disabled');
        }
        else {
            this.builder.addClass('disabled');
        }
    };
    ActivityActionItem.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        ActivityActionItem.clearDraggedViewlet();
        if (this.mouseUpTimeout) {
            clearTimeout(this.mouseUpTimeout);
        }
        this.$badge.destroy();
        this.$e.destroy();
    };
    return ActivityActionItem;
}(actionbar_1.BaseActionItem));
ActivityActionItem = __decorate([
    __param(2, contextView_1.IContextMenuService),
    __param(3, activityBarService_1.IActivityBarService),
    __param(4, keybinding_1.IKeybindingService),
    __param(5, instantiation_1.IInstantiationService)
], ActivityActionItem);
exports.ActivityActionItem = ActivityActionItem;
var ViewletOverflowActivityAction = (function (_super) {
    __extends(ViewletOverflowActivityAction, _super);
    function ViewletOverflowActivityAction(showMenu) {
        var _this = _super.call(this, 'activitybar.additionalViewlets.action', nls.localize('additionalViews', "Additional Views"), 'toggle-more') || this;
        _this.showMenu = showMenu;
        return _this;
    }
    ViewletOverflowActivityAction.prototype.run = function (event) {
        this.showMenu();
        return winjs_base_1.TPromise.as(true);
    };
    return ViewletOverflowActivityAction;
}(ActivityAction));
exports.ViewletOverflowActivityAction = ViewletOverflowActivityAction;
var ViewletOverflowActivityActionItem = (function (_super) {
    __extends(ViewletOverflowActivityActionItem, _super);
    function ViewletOverflowActivityActionItem(action, getOverflowingViewlets, getBadge, instantiationService, viewletService, keybindingService, contextMenuService) {
        var _this = _super.call(this, null, action) || this;
        _this.getOverflowingViewlets = getOverflowingViewlets;
        _this.getBadge = getBadge;
        _this.instantiationService = instantiationService;
        _this.viewletService = viewletService;
        _this.keybindingService = keybindingService;
        _this.contextMenuService = contextMenuService;
        _this.cssClass = action.class;
        _this.name = action.label;
        return _this;
    }
    ViewletOverflowActivityActionItem.prototype.render = function (container) {
        _super.prototype.render.call(this, container);
        this.$e = builder_1.$('a.action-label').attr({
            tabIndex: '0',
            role: 'button',
            title: this.name,
            class: this.cssClass
        }).appendTo(this.builder);
    };
    ViewletOverflowActivityActionItem.prototype.showMenu = function () {
        var _this = this;
        if (this.actions) {
            lifecycle_1.dispose(this.actions);
        }
        this.actions = this.getActions();
        this.contextMenuService.showContextMenu({
            getAnchor: function () { return _this.builder.getHTMLElement(); },
            getActions: function () { return winjs_base_1.TPromise.as(_this.actions); },
            getKeyBinding: function (action) { return _this.getKeybinding(action); },
            onHide: function () { return lifecycle_1.dispose(_this.actions); }
        });
    };
    ViewletOverflowActivityActionItem.prototype.getKeybinding = function (action) {
        var opts = this.keybindingService.lookupKeybindings(action.id);
        if (opts.length > 0) {
            return opts[0]; // only take the first one
        }
        return null;
    };
    ViewletOverflowActivityActionItem.prototype.getActions = function () {
        var _this = this;
        var activeViewlet = this.viewletService.getActiveViewlet();
        return this.getOverflowingViewlets().map(function (viewlet) {
            var action = _this.instantiationService.createInstance(OpenViewletAction, viewlet);
            action.radio = activeViewlet && activeViewlet.getId() === action.id;
            var badge = _this.getBadge(action.viewlet);
            var suffix;
            if (badge instanceof activityBarService_1.NumberBadge) {
                suffix = badge.number;
            }
            else if (badge instanceof activityBarService_1.TextBadge) {
                suffix = badge.text;
            }
            if (suffix) {
                action.label = nls.localize('numberBadge', "{0} ({1})", action.viewlet.name, suffix);
            }
            else {
                action.label = action.viewlet.name;
            }
            return action;
        });
    };
    ViewletOverflowActivityActionItem.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.actions = lifecycle_1.dispose(this.actions);
    };
    return ViewletOverflowActivityActionItem;
}(actionbar_1.BaseActionItem));
ViewletOverflowActivityActionItem = __decorate([
    __param(3, instantiation_1.IInstantiationService),
    __param(4, viewlet_1.IViewletService),
    __param(5, keybinding_1.IKeybindingService),
    __param(6, contextView_1.IContextMenuService)
], ViewletOverflowActivityActionItem);
exports.ViewletOverflowActivityActionItem = ViewletOverflowActivityActionItem;
var ManageExtensionAction = (function (_super) {
    __extends(ManageExtensionAction, _super);
    function ManageExtensionAction(commandService) {
        var _this = _super.call(this, 'activitybar.manage.extension', nls.localize('manageExtension', "Manage Extension")) || this;
        _this.commandService = commandService;
        return _this;
    }
    ManageExtensionAction.prototype.run = function (viewlet) {
        return this.commandService.executeCommand('_extensions.manage', viewlet.extensionId);
    };
    return ManageExtensionAction;
}(actions_1.Action));
ManageExtensionAction = __decorate([
    __param(0, commands_1.ICommandService)
], ManageExtensionAction);
var OpenViewletAction = (function (_super) {
    __extends(OpenViewletAction, _super);
    function OpenViewletAction(_viewlet, partService, viewletService) {
        var _this = _super.call(this, _viewlet.id, _viewlet.name) || this;
        _this._viewlet = _viewlet;
        _this.partService = partService;
        _this.viewletService = viewletService;
        return _this;
    }
    Object.defineProperty(OpenViewletAction.prototype, "viewlet", {
        get: function () {
            return this._viewlet;
        },
        enumerable: true,
        configurable: true
    });
    OpenViewletAction.prototype.run = function () {
        var sideBarVisible = this.partService.isVisible(partService_1.Parts.SIDEBAR_PART);
        var activeViewlet = this.viewletService.getActiveViewlet();
        // Hide sidebar if selected viewlet already visible
        if (sideBarVisible && activeViewlet && activeViewlet.getId() === this.viewlet.id) {
            this.partService.setSideBarHidden(true);
        }
        else {
            this.viewletService.openViewlet(this.viewlet.id, true).done(null, errors.onUnexpectedError);
        }
        return winjs_base_1.TPromise.as(true);
    };
    return OpenViewletAction;
}(actions_1.Action));
OpenViewletAction = __decorate([
    __param(1, partService_1.IPartService),
    __param(2, viewlet_1.IViewletService)
], OpenViewletAction);
var ToggleViewletPinnedAction = (function (_super) {
    __extends(ToggleViewletPinnedAction, _super);
    function ToggleViewletPinnedAction(viewlet, activityBarService) {
        var _this = _super.call(this, 'activitybar.show.toggleViewletPinned', viewlet ? viewlet.name : nls.localize('toggle', "Toggle View Pinned")) || this;
        _this.viewlet = viewlet;
        _this.activityBarService = activityBarService;
        _this.checked = _this.viewlet && _this.activityBarService.isPinned(_this.viewlet.id);
        return _this;
    }
    ToggleViewletPinnedAction.prototype.run = function (context) {
        var viewlet = this.viewlet || context;
        if (this.activityBarService.isPinned(viewlet.id)) {
            this.activityBarService.unpin(viewlet.id);
        }
        else {
            this.activityBarService.pin(viewlet.id);
        }
        return winjs_base_1.TPromise.as(true);
    };
    return ToggleViewletPinnedAction;
}(actions_1.Action));
ToggleViewletPinnedAction = __decorate([
    __param(1, activityBarService_1.IActivityBarService)
], ToggleViewletPinnedAction);
exports.ToggleViewletPinnedAction = ToggleViewletPinnedAction;
