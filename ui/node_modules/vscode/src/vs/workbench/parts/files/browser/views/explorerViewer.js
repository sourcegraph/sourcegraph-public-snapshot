/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var winjs_base_1 = require('vs/base/common/winjs.base');
var nls = require('vs/nls');
var lifecycle = require('vs/base/common/lifecycle');
var objects = require('vs/base/common/objects');
var DOM = require('vs/base/browser/dom');
var uri_1 = require('vs/base/common/uri');
var mime_1 = require('vs/base/common/mime');
var async = require('vs/base/common/async');
var paths = require('vs/base/common/paths');
var errors = require('vs/base/common/errors');
var types_1 = require('vs/base/common/types');
var actions_1 = require('vs/base/common/actions');
var comparers = require('vs/base/common/comparers');
var inputBox_1 = require('vs/base/browser/ui/inputbox/inputBox');
var builder_1 = require('vs/base/browser/builder');
var platform = require('vs/base/common/platform');
var glob = require('vs/base/common/glob');
var labels_1 = require('vs/workbench/browser/labels');
var actionBarRegistry_1 = require('vs/workbench/browser/actionBarRegistry');
var textfiles_1 = require('vs/workbench/services/textfile/common/textfiles');
var files_1 = require('vs/platform/files/common/files');
var fileActions_1 = require('vs/workbench/parts/files/browser/fileActions');
var tree_1 = require('vs/base/parts/tree/browser/tree');
var treeDnd_1 = require('vs/base/parts/tree/browser/treeDnd');
var treeDefaults_1 = require('vs/base/parts/tree/browser/treeDefaults');
var actionsRenderer_1 = require('vs/base/parts/tree/browser/actionsRenderer');
var explorerViewModel_1 = require('vs/workbench/parts/files/common/explorerViewModel');
var editorService_1 = require('vs/workbench/services/editor/common/editorService');
var partService_1 = require('vs/workbench/services/part/common/partService');
var workspace_1 = require('vs/platform/workspace/common/workspace');
var configuration_1 = require('vs/platform/configuration/common/configuration');
var contextkey_1 = require('vs/platform/contextkey/common/contextkey');
var contextView_1 = require('vs/platform/contextview/browser/contextView');
var event_1 = require('vs/platform/event/common/event');
var instantiation_1 = require('vs/platform/instantiation/common/instantiation');
var message_1 = require('vs/platform/message/common/message');
var progress_1 = require('vs/platform/progress/common/progress');
var telemetry_1 = require('vs/platform/telemetry/common/telemetry');
var actions_2 = require('vs/platform/actions/common/actions');
var menuItemActionItem_1 = require('vs/platform/actions/browser/menuItemActionItem');
var FileDataSource = (function () {
    function FileDataSource(progressService, messageService, fileService, partService, contextService) {
        this.progressService = progressService;
        this.messageService = messageService;
        this.fileService = fileService;
        this.partService = partService;
        this.workspace = contextService.getWorkspace();
    }
    FileDataSource.prototype.getId = function (tree, stat) {
        return stat.getId();
    };
    FileDataSource.prototype.hasChildren = function (tree, stat) {
        return stat.isDirectory;
    };
    FileDataSource.prototype.getChildren = function (tree, stat) {
        var _this = this;
        // Return early if stat is already resolved
        if (stat.isDirectoryResolved) {
            return winjs_base_1.TPromise.as(stat.children);
        }
        else {
            // Resolve
            var promise = this.fileService.resolveFile(stat.resource, { resolveSingleChildDescendants: true }).then(function (dirStat) {
                // Convert to view model
                var modelDirStat = explorerViewModel_1.FileStat.create(dirStat);
                // Add children to folder
                for (var i = 0; i < modelDirStat.children.length; i++) {
                    stat.addChild(modelDirStat.children[i]);
                }
                stat.isDirectoryResolved = true;
                return stat.children;
            }, function (e) {
                _this.messageService.show(message_1.Severity.Error, e);
                return []; // we could not resolve any children because of an error
            });
            this.progressService.showWhile(promise, this.partService.isCreated() ? 800 : 3200 /* less ugly initial startup */);
            return promise;
        }
    };
    FileDataSource.prototype.getParent = function (tree, stat) {
        if (!stat) {
            return winjs_base_1.TPromise.as(null); // can be null if nothing selected in the tree
        }
        // Return if root reached
        if (this.workspace && stat.resource.toString() === this.workspace.resource.toString()) {
            return winjs_base_1.TPromise.as(null);
        }
        // Return if parent already resolved
        if (stat.parent) {
            return winjs_base_1.TPromise.as(stat.parent);
        }
        // We never actually resolve the parent from the disk for performance reasons. It wouldnt make
        // any sense to resolve parent by parent with requests to walk up the chain. Instead, the explorer
        // makes sure to properly resolve a deep path to a specific file and merges the result with the model.
        return winjs_base_1.TPromise.as(null);
    };
    FileDataSource = __decorate([
        __param(0, progress_1.IProgressService),
        __param(1, message_1.IMessageService),
        __param(2, files_1.IFileService),
        __param(3, partService_1.IPartService),
        __param(4, workspace_1.IWorkspaceContextService)
    ], FileDataSource);
    return FileDataSource;
}());
exports.FileDataSource = FileDataSource;
var FileActionProvider = (function (_super) {
    __extends(FileActionProvider, _super);
    function FileActionProvider(state) {
        _super.call(this);
        this.state = state;
    }
    FileActionProvider.prototype.hasActions = function (tree, stat) {
        if (stat instanceof explorerViewModel_1.NewStatPlaceholder) {
            return false;
        }
        return _super.prototype.hasActions.call(this, tree, stat);
    };
    FileActionProvider.prototype.getActions = function (tree, stat) {
        if (stat instanceof explorerViewModel_1.NewStatPlaceholder) {
            return winjs_base_1.TPromise.as([]);
        }
        return _super.prototype.getActions.call(this, tree, stat);
    };
    FileActionProvider.prototype.hasSecondaryActions = function (tree, stat) {
        if (stat instanceof explorerViewModel_1.NewStatPlaceholder) {
            return false;
        }
        return _super.prototype.hasSecondaryActions.call(this, tree, stat);
    };
    FileActionProvider.prototype.getSecondaryActions = function (tree, stat) {
        if (stat instanceof explorerViewModel_1.NewStatPlaceholder) {
            return winjs_base_1.TPromise.as([]);
        }
        return _super.prototype.getSecondaryActions.call(this, tree, stat);
    };
    FileActionProvider.prototype.runAction = function (tree, stat, arg, context) {
        var _this = this;
        if (context === void 0) { context = {}; }
        context = objects.mixin({
            viewletState: this.state,
            stat: stat
        }, context);
        if (!types_1.isString(arg)) {
            var action = arg;
            if (action.enabled) {
                return action.run(context);
            }
            return null;
        }
        var id = arg;
        var promise = this.hasActions(tree, stat) ? this.getActions(tree, stat) : winjs_base_1.TPromise.as([]);
        return promise.then(function (actions) {
            for (var i = 0, len = actions.length; i < len; i++) {
                if (actions[i].id === id && actions[i].enabled) {
                    return actions[i].run(context);
                }
            }
            promise = _this.hasSecondaryActions(tree, stat) ? _this.getSecondaryActions(tree, stat) : winjs_base_1.TPromise.as([]);
            return promise.then(function (actions) {
                for (var i = 0, len = actions.length; i < len; i++) {
                    if (actions[i].id === id && actions[i].enabled) {
                        return actions[i].run(context);
                    }
                }
                return null;
            });
        });
    };
    return FileActionProvider;
}(actionBarRegistry_1.ContributableActionProvider));
exports.FileActionProvider = FileActionProvider;
var FileViewletState = (function () {
    function FileViewletState() {
        this._actionProvider = new FileActionProvider(this);
        this.editableStats = Object.create(null);
    }
    Object.defineProperty(FileViewletState.prototype, "actionProvider", {
        get: function () {
            return this._actionProvider;
        },
        enumerable: true,
        configurable: true
    });
    FileViewletState.prototype.getEditableData = function (stat) {
        return this.editableStats[stat.resource && stat.resource.toString()];
    };
    FileViewletState.prototype.setEditable = function (stat, editableData) {
        if (editableData) {
            this.editableStats[stat.resource && stat.resource.toString()] = editableData;
        }
    };
    FileViewletState.prototype.clearEditable = function (stat) {
        delete this.editableStats[stat.resource && stat.resource.toString()];
    };
    return FileViewletState;
}());
exports.FileViewletState = FileViewletState;
var ActionRunner = (function (_super) {
    __extends(ActionRunner, _super);
    function ActionRunner(state) {
        _super.call(this);
        this.viewletState = state;
    }
    ActionRunner.prototype.run = function (action, context) {
        return _super.prototype.run.call(this, action, { viewletState: this.viewletState });
    };
    return ActionRunner;
}(actions_1.ActionRunner));
exports.ActionRunner = ActionRunner;
// Explorer Renderer
var FileRenderer = (function (_super) {
    __extends(FileRenderer, _super);
    function FileRenderer(state, actionRunner, contextViewService, instantiationService) {
        _super.call(this, {
            actionProvider: state.actionProvider,
            actionRunner: actionRunner
        });
        this.contextViewService = contextViewService;
        this.instantiationService = instantiationService;
        this.state = state;
    }
    FileRenderer.prototype.getContentHeight = function (tree, element) {
        return 22;
    };
    FileRenderer.prototype.renderContents = function (tree, stat, domElement, previousCleanupFn) {
        var el = builder_1.$(domElement).clearChildren();
        // File Rename/Add Input Field
        var editableData = this.state.getEditableData(stat);
        if (editableData) {
            return this.renderInputBox(el, tree, stat, editableData);
        }
        // Label
        return this.renderLabel(el, stat);
    };
    FileRenderer.prototype.renderLabel = function (container, stat) {
        var label = this.instantiationService.createInstance(labels_1.FileLabel, container.getHTMLElement(), void 0);
        var extraClasses = ['explorer-item'];
        label.setFile(stat.resource, { hidePath: true, isFolder: stat.isDirectory, extraClasses: extraClasses });
        return function () { return label.dispose(); };
    };
    FileRenderer.prototype.renderInputBox = function (container, tree, stat, editableData) {
        var _this = this;
        var label = this.instantiationService.createInstance(labels_1.FileLabel, container.getHTMLElement(), void 0);
        var extraClasses = ['explorer-item'];
        var isFolder = stat.isDirectory || (stat instanceof explorerViewModel_1.NewStatPlaceholder && stat.isDirectoryPlaceholder());
        var labelOptions = { hidePath: true, hideLabel: true, isFolder: isFolder, extraClasses: extraClasses };
        label.setFile(stat.resource, labelOptions);
        // Input field (when creating a new file or folder or renaming)
        var inputBox = new inputBox_1.InputBox(label.element, this.contextViewService, {
            validationOptions: {
                validation: editableData.validator,
                showMessage: true
            },
            ariaLabel: nls.localize('fileInputAriaLabel', "Type file name. Press Enter to confirm or Escape to cancel.")
        });
        var parent = paths.dirname(stat.resource.fsPath);
        inputBox.onDidChange(function (value) {
            label.setFile(uri_1.default.file(paths.join(parent, value)), labelOptions); // update label icon while typing!
        });
        var value = stat.name || '';
        var lastDot = value.lastIndexOf('.');
        inputBox.value = value;
        inputBox.select({ start: 0, end: lastDot > 0 && !stat.isDirectory ? lastDot : value.length });
        inputBox.focus();
        var done = async.once(function (commit) {
            tree.clearHighlight();
            if (commit && inputBox.value) {
                _this.state.actionProvider.runAction(tree, stat, editableData.action, { value: inputBox.value });
            }
            setTimeout(function () {
                tree.DOMFocus();
                lifecycle.dispose(toDispose);
            }, 0);
        });
        var toDispose = [
            inputBox,
            DOM.addStandardDisposableListener(inputBox.inputElement, DOM.EventType.KEY_DOWN, function (e) {
                if (e.equals(3 /* Enter */)) {
                    if (inputBox.validate()) {
                        done(true);
                    }
                }
                else if (e.equals(9 /* Escape */)) {
                    done(false);
                }
            }),
            DOM.addDisposableListener(inputBox.inputElement, 'blur', function () {
                done(inputBox.isInputValid());
            }),
            label
        ];
        return function () { return done(true); };
    };
    FileRenderer = __decorate([
        __param(2, contextView_1.IContextViewService),
        __param(3, instantiation_1.IInstantiationService)
    ], FileRenderer);
    return FileRenderer;
}(actionsRenderer_1.ActionsRenderer));
exports.FileRenderer = FileRenderer;
// Explorer Accessibility Provider
var FileAccessibilityProvider = (function () {
    function FileAccessibilityProvider() {
    }
    FileAccessibilityProvider.prototype.getAriaLabel = function (tree, stat) {
        return nls.localize('filesExplorerViewerAriaLabel', "{0}, Files Explorer", stat.name);
    };
    return FileAccessibilityProvider;
}());
exports.FileAccessibilityProvider = FileAccessibilityProvider;
// Explorer Controller
var FileController = (function (_super) {
    __extends(FileController, _super);
    function FileController(state, editorService, contextMenuService, instantiationService, telemetryService, contextService, menuService, contextKeyService) {
        _super.call(this, { clickBehavior: treeDefaults_1.ClickBehavior.ON_MOUSE_UP /* do not change to not break DND */ });
        this.editorService = editorService;
        this.contextMenuService = contextMenuService;
        this.instantiationService = instantiationService;
        this.telemetryService = telemetryService;
        this.contributedContextMenu = menuService.createMenu(actions_2.MenuId.ExplorerContext, contextKeyService);
        this.workspace = contextService.getWorkspace();
        this.didCatchEnterDown = false;
        this.downKeyBindingDispatcher.set(platform.isMacintosh ? 32768 /* CtrlCmd */ | 18 /* DownArrow */ : 3 /* Enter */, this.onEnterDown.bind(this));
        this.upKeyBindingDispatcher.set(platform.isMacintosh ? 32768 /* CtrlCmd */ | 18 /* DownArrow */ : 3 /* Enter */, this.onEnterUp.bind(this));
        if (platform.isMacintosh) {
            this.upKeyBindingDispatcher.set(4096 /* WinCtrl */ | 3 /* Enter */, this.onModifierEnterUp.bind(this)); // Mac: somehow Cmd+Enter does not work
        }
        else {
            this.upKeyBindingDispatcher.set(32768 /* CtrlCmd */ | 3 /* Enter */, this.onModifierEnterUp.bind(this)); // Mac: somehow Cmd+Enter does not work
        }
        this.downKeyBindingDispatcher.set(platform.isMacintosh ? 3 /* Enter */ : 60 /* F2 */, this.onF2.bind(this));
        this.downKeyBindingDispatcher.set(32768 /* CtrlCmd */ | 33 /* KEY_C */, this.onCopy.bind(this));
        this.downKeyBindingDispatcher.set(32768 /* CtrlCmd */ | 52 /* KEY_V */, this.onPaste.bind(this));
        if (platform.isMacintosh) {
            this.downKeyBindingDispatcher.set(32768 /* CtrlCmd */ | 16 /* UpArrow */, this.onLeft.bind(this));
            this.downKeyBindingDispatcher.set(32768 /* CtrlCmd */ | 1 /* Backspace */, this.onDelete.bind(this));
            this.downKeyBindingDispatcher.set(32768 /* CtrlCmd */ | 8192 /* Alt */ | 1 /* Backspace */, this.onDelete.bind(this));
        }
        else {
            this.downKeyBindingDispatcher.set(20 /* Delete */, this.onDelete.bind(this));
            this.downKeyBindingDispatcher.set(16384 /* Shift */ | 20 /* Delete */, this.onDelete.bind(this));
        }
        this.state = state;
    }
    /* protected */ FileController.prototype.onLeftClick = function (tree, stat, event, origin) {
        if (origin === void 0) { origin = 'mouse'; }
        var payload = { origin: origin };
        var isDoubleClick = (origin === 'mouse' && event.detail === 2);
        // Handle Highlight Mode
        if (tree.getHighlight()) {
            // Cancel Event
            event.preventDefault();
            event.stopPropagation();
            tree.clearHighlight(payload);
            return false;
        }
        // Handle root
        if (this.workspace && stat.resource.toString() === this.workspace.resource.toString()) {
            tree.clearFocus(payload);
            tree.clearSelection(payload);
            return false;
        }
        // Cancel Event
        var isMouseDown = event && event.browserEvent && event.browserEvent.type === 'mousedown';
        if (!isMouseDown) {
            event.preventDefault(); // we cannot preventDefault onMouseDown because this would break DND otherwise
        }
        event.stopPropagation();
        // Set DOM focus
        tree.DOMFocus();
        // Expand / Collapse
        tree.toggleExpansion(stat);
        // Allow to unselect
        if (event.shiftKey && !(stat instanceof explorerViewModel_1.NewStatPlaceholder)) {
            var selection = tree.getSelection();
            if (selection && selection.length > 0 && selection[0] === stat) {
                tree.clearSelection(payload);
            }
        }
        else if (!(stat instanceof explorerViewModel_1.NewStatPlaceholder)) {
            var preserveFocus = !isDoubleClick;
            tree.setFocus(stat, payload);
            if (isDoubleClick) {
                event.preventDefault(); // focus moves to editor, we need to prevent default
            }
            tree.setSelection([stat], payload);
            if (!stat.isDirectory) {
                this.openEditor(stat, preserveFocus, event && (event.ctrlKey || event.metaKey), isDoubleClick);
            }
        }
        return true;
    };
    FileController.prototype.onContextMenu = function (tree, stat, event) {
        var _this = this;
        if (event.target && event.target.tagName && event.target.tagName.toLowerCase() === 'input') {
            return false;
        }
        event.preventDefault();
        event.stopPropagation();
        tree.setFocus(stat);
        if (!this.state.actionProvider.hasSecondaryActions(tree, stat)) {
            return true;
        }
        var anchor = { x: event.posx + 1, y: event.posy };
        this.contextMenuService.showContextMenu({
            getAnchor: function () { return anchor; },
            getActions: function () {
                return _this.state.actionProvider.getSecondaryActions(tree, stat).then(function (actions) {
                    menuItemActionItem_1.fillInActions(_this.contributedContextMenu, actions);
                    return actions;
                });
            },
            getActionItem: this.state.actionProvider.getActionItem.bind(this.state.actionProvider, tree, stat),
            getKeyBinding: function (a) { return fileActions_1.keybindingForAction(a.id); },
            getActionsContext: function (event) {
                return {
                    viewletState: _this.state,
                    stat: stat,
                    event: event
                };
            },
            onHide: function (wasCancelled) {
                if (wasCancelled) {
                    tree.DOMFocus();
                }
            }
        });
        return true;
    };
    FileController.prototype.onEnterDown = function (tree, event) {
        if (tree.getHighlight()) {
            return false;
        }
        var payload = { origin: 'keyboard' };
        var stat = tree.getFocus();
        if (stat) {
            // Directory: Toggle expansion
            if (stat.isDirectory) {
                tree.toggleExpansion(stat);
            }
            else {
                tree.setFocus(stat, payload);
                this.openEditor(stat, false, false);
            }
        }
        this.didCatchEnterDown = true;
        return true;
    };
    FileController.prototype.onEnterUp = function (tree, event) {
        if (!this.didCatchEnterDown || tree.getHighlight()) {
            return false;
        }
        var stat = tree.getFocus();
        if (stat && !stat.isDirectory) {
            this.openEditor(stat, false, false);
        }
        this.didCatchEnterDown = false;
        return true;
    };
    FileController.prototype.onModifierEnterUp = function (tree, event) {
        if (tree.getHighlight()) {
            return false;
        }
        var stat = tree.getFocus();
        if (stat && !stat.isDirectory) {
            this.openEditor(stat, false, true);
        }
        this.didCatchEnterDown = false;
        return true;
    };
    FileController.prototype.onCopy = function (tree, event) {
        var stat = tree.getFocus();
        if (stat) {
            this.runAction(tree, stat, 'workbench.files.action.copyFile').done();
            return true;
        }
        return false;
    };
    FileController.prototype.onPaste = function (tree, event) {
        var stat = tree.getFocus() || tree.getInput();
        if (stat) {
            var pasteAction = this.instantiationService.createInstance(fileActions_1.PasteFileAction, tree, stat);
            if (pasteAction._isEnabled()) {
                pasteAction.run().done(null, errors.onUnexpectedError);
                return true;
            }
        }
        return false;
    };
    FileController.prototype.openEditor = function (stat, preserveFocus, sideBySide, pinned) {
        if (pinned === void 0) { pinned = false; }
        if (stat && !stat.isDirectory) {
            this.telemetryService.publicLog('workbenchActionExecuted', { id: 'workbench.files.openFile', from: 'explorer' });
            this.editorService.openEditor({ resource: stat.resource, options: { preserveFocus: preserveFocus, pinned: pinned } }, sideBySide).done(null, errors.onUnexpectedError);
        }
    };
    FileController.prototype.onF2 = function (tree, event) {
        var stat = tree.getFocus();
        if (stat) {
            this.runAction(tree, stat, 'workbench.files.action.triggerRename').done();
            return true;
        }
        return false;
    };
    FileController.prototype.onDelete = function (tree, event) {
        var stat = tree.getFocus();
        if (stat) {
            this.runAction(tree, stat, 'workbench.files.action.moveFileToTrash', event).done();
            return true;
        }
        return false;
    };
    FileController.prototype.runAction = function (tree, stat, id, event) {
        return this.state.actionProvider.runAction(tree, stat, id, { event: event });
    };
    FileController = __decorate([
        __param(1, editorService_1.IWorkbenchEditorService),
        __param(2, contextView_1.IContextMenuService),
        __param(3, instantiation_1.IInstantiationService),
        __param(4, telemetry_1.ITelemetryService),
        __param(5, workspace_1.IWorkspaceContextService),
        __param(6, actions_2.IMenuService),
        __param(7, contextkey_1.IContextKeyService)
    ], FileController);
    return FileController;
}(treeDefaults_1.DefaultController));
exports.FileController = FileController;
// Explorer Sorter
var FileSorter = (function () {
    function FileSorter() {
    }
    FileSorter.prototype.compare = function (tree, statA, statB) {
        if (statA.isDirectory && !statB.isDirectory) {
            return -1;
        }
        if (statB.isDirectory && !statA.isDirectory) {
            return 1;
        }
        if (statA.isDirectory && statB.isDirectory) {
            return statA.name.toLowerCase().localeCompare(statB.name.toLowerCase());
        }
        if (statA instanceof explorerViewModel_1.NewStatPlaceholder) {
            return -1;
        }
        if (statB instanceof explorerViewModel_1.NewStatPlaceholder) {
            return 1;
        }
        return comparers.compareFileNames(statA.name, statB.name);
    };
    return FileSorter;
}());
exports.FileSorter = FileSorter;
// Explorer Filter
var FileFilter = (function () {
    function FileFilter(contextService) {
        this.contextService = contextService;
        this.hiddenExpression = Object.create(null);
    }
    FileFilter.prototype.updateConfiguration = function (configuration) {
        var excludesConfig = (configuration && configuration.files && configuration.files.exclude) || Object.create(null);
        var needsRefresh = !objects.equals(this.hiddenExpression, excludesConfig);
        this.hiddenExpression = objects.clone(excludesConfig); // do not keep the config, as it gets mutated under our hoods
        return needsRefresh;
    };
    FileFilter.prototype.isVisible = function (tree, stat) {
        return this.doIsVisible(stat);
    };
    FileFilter.prototype.doIsVisible = function (stat) {
        if (stat instanceof explorerViewModel_1.NewStatPlaceholder) {
            return true; // always visible
        }
        // Workaround for O(N^2) complexity (https://github.com/Microsoft/vscode/issues/9962)
        var siblings = stat.parent && stat.parent.children && stat.parent.children;
        if (siblings && siblings.length > FileFilter.MAX_SIBLINGS_FILTER_THRESHOLD) {
            siblings = void 0;
        }
        // Hide those that match Hidden Patterns
        var siblingsFn = function () { return siblings && siblings.map(function (c) { return c.name; }); };
        if (glob.match(this.hiddenExpression, this.contextService.toWorkspaceRelativePath(stat.resource), siblingsFn)) {
            return false; // hidden through pattern
        }
        return true;
    };
    FileFilter.MAX_SIBLINGS_FILTER_THRESHOLD = 2000;
    FileFilter = __decorate([
        __param(0, workspace_1.IWorkspaceContextService)
    ], FileFilter);
    return FileFilter;
}());
exports.FileFilter = FileFilter;
// Explorer Drag And Drop Controller
var FileDragAndDrop = (function () {
    function FileDragAndDrop(messageService, contextService, eventService, progressService, fileService, configurationService, instantiationService, textFileService) {
        this.messageService = messageService;
        this.contextService = contextService;
        this.eventService = eventService;
        this.progressService = progressService;
        this.fileService = fileService;
        this.configurationService = configurationService;
        this.instantiationService = instantiationService;
        this.textFileService = textFileService;
        this.toDispose = [];
        this.onConfigurationUpdated(configurationService.getConfiguration());
        this.registerListeners();
    }
    FileDragAndDrop.prototype.registerListeners = function () {
        var _this = this;
        this.toDispose.push(this.configurationService.onDidUpdateConfiguration(function (e) { return _this.onConfigurationUpdated(e.config); }));
    };
    FileDragAndDrop.prototype.onConfigurationUpdated = function (config) {
        this.dropEnabled = config && config.explorer && config.explorer.enableDragAndDrop;
    };
    FileDragAndDrop.prototype.getDragURI = function (tree, stat) {
        if (stat.isDirectory) {
            return uri_1.default.from({ scheme: 'folder', path: stat.resource.fsPath }).toString(); // indicates that we are dragging a folder
        }
        return stat.resource.toString();
    };
    FileDragAndDrop.prototype.getDragLabel = function (tree, elements) {
        if (elements.length > 1) {
            return String(elements.length);
        }
        var stat = elements[0];
        return paths.basename(stat.resource.fsPath);
    };
    FileDragAndDrop.prototype.onDragStart = function (tree, data, originalEvent) {
        var sources = data.getData();
        var source = null;
        if (sources.length > 0) {
            source = sources[0];
        }
        // When dragging folders, make sure to collapse them to free up some space
        if (source && source.isDirectory && tree.isExpanded(source)) {
            tree.collapse(source, false);
        }
        // Native only: when a DownloadURL attribute is defined on the data transfer it is possible to
        // drag a file from the browser to the desktop and have it downloaded there.
        if (!(data instanceof treeDnd_1.DesktopDragAndDropData)) {
            if (source && !source.isDirectory) {
                originalEvent.dataTransfer.setData('DownloadURL', [mime_1.MIME_BINARY, source.name, source.resource.toString()].join(':'));
            }
        }
    };
    FileDragAndDrop.prototype.onDragOver = function (tree, data, target, originalEvent) {
        if (!this.dropEnabled) {
            return tree_1.DRAG_OVER_REJECT;
        }
        var isCopy = originalEvent && ((originalEvent.ctrlKey && !platform.isMacintosh) || (originalEvent.altKey && platform.isMacintosh));
        var fromDesktop = data instanceof treeDnd_1.DesktopDragAndDropData;
        // Desktop DND
        if (fromDesktop) {
            var dragData = data.getData();
            var types = dragData.types;
            var typesArray = [];
            for (var i = 0; i < types.length; i++) {
                typesArray.push(types[i]);
            }
            if (typesArray.length === 0 || !typesArray.some(function (type) { return type === 'Files'; })) {
                return tree_1.DRAG_OVER_REJECT;
            }
        }
        else if (data instanceof treeDnd_1.ExternalElementsDragAndDropData) {
            return tree_1.DRAG_OVER_REJECT;
        }
        else {
            var sources = data.getData();
            if (!Array.isArray(sources)) {
                return tree_1.DRAG_OVER_REJECT;
            }
            if (sources.some(function (source) {
                if (source instanceof explorerViewModel_1.NewStatPlaceholder) {
                    return true; // NewStatPlaceholders can not be moved
                }
                if (source.resource.toString() === target.resource.toString()) {
                    return true; // Can not move anything onto itself
                }
                if (!isCopy && paths.dirname(source.resource.fsPath) === target.resource.fsPath) {
                    return true; // Can not move a file to the same parent unless we copy
                }
                if (paths.isEqualOrParent(target.resource.fsPath, source.resource.fsPath)) {
                    return true; // Can not move a parent folder into one of its children
                }
                return false;
            })) {
                return tree_1.DRAG_OVER_REJECT;
            }
        }
        // All
        if (target.isDirectory) {
            return fromDesktop || isCopy ? tree_1.DRAG_OVER_ACCEPT_BUBBLE_DOWN_COPY : tree_1.DRAG_OVER_ACCEPT_BUBBLE_DOWN;
        }
        if (target.resource.toString() !== this.contextService.getWorkspace().resource.toString()) {
            return fromDesktop || isCopy ? tree_1.DRAG_OVER_ACCEPT_BUBBLE_UP_COPY : tree_1.DRAG_OVER_ACCEPT_BUBBLE_UP;
        }
        return tree_1.DRAG_OVER_REJECT;
    };
    FileDragAndDrop.prototype.drop = function (tree, data, target, originalEvent) {
        var _this = this;
        var promise = winjs_base_1.TPromise.as(null);
        // Desktop DND (Import file)
        if (data instanceof treeDnd_1.DesktopDragAndDropData) {
            var importAction = this.instantiationService.createInstance(fileActions_1.ImportFileAction, tree, target, null);
            promise = importAction.run({
                input: {
                    files: data.getData().files
                }
            });
        }
        else {
            var source_1 = data.getData()[0];
            var isCopy_1 = (originalEvent.ctrlKey && !platform.isMacintosh) || (originalEvent.altKey && platform.isMacintosh);
            promise = tree.expand(target).then(function () {
                // Reuse action if user copies
                if (isCopy_1) {
                    var copyAction = _this.instantiationService.createInstance(fileActions_1.DuplicateFileAction, tree, source_1, target);
                    return copyAction.run();
                }
                // Handle dirty (in file or inside the folder if any)
                var revertPromise = winjs_base_1.TPromise.as(null);
                var dirty = _this.textFileService.getDirty().filter(function (d) { return paths.isEqualOrParent(d.fsPath, source_1.resource.fsPath); });
                if (dirty.length) {
                    var message = void 0;
                    if (source_1.isDirectory) {
                        if (dirty.length === 1) {
                            message = nls.localize('dirtyMessageFolderOne', "You are moving a folder with unsaved changes in 1 file. Do you want to continue?");
                        }
                        else {
                            message = nls.localize('dirtyMessageFolder', "You are moving a folder with unsaved changes in {0} files. Do you want to continue?", dirty.length);
                        }
                    }
                    else {
                        message = nls.localize('dirtyMessageFile', "You are moving a file with unsaved changes. Do you want to continue?");
                    }
                    var res = _this.messageService.confirm({
                        message: message,
                        type: 'warning',
                        detail: nls.localize('dirtyWarning', "Your changes will be lost if you don't save them."),
                        primaryButton: nls.localize({ key: 'moveLabel', comment: ['&& denotes a mnemonic'] }, "&&Move")
                    });
                    if (!res) {
                        return winjs_base_1.TPromise.as(null);
                    }
                    revertPromise = _this.textFileService.revertAll(dirty);
                }
                return revertPromise.then(function () {
                    var targetResource = uri_1.default.file(paths.join(target.resource.fsPath, source_1.name));
                    var didHandleConflict = false;
                    var onMove = function (result) {
                        _this.eventService.emit('files.internal:fileChanged', new textfiles_1.LocalFileChangeEvent(source_1.clone(), result));
                    };
                    // Move File/Folder and emit event
                    return _this.fileService.moveFile(source_1.resource, targetResource).then(onMove, function (error) {
                        // Conflict
                        if (error.fileOperationResult === files_1.FileOperationResult.FILE_MOVE_CONFLICT) {
                            didHandleConflict = true;
                            var confirm_1 = {
                                message: nls.localize('confirmOverwriteMessage', "'{0}' already exists in the destination folder. Do you want to replace it?", source_1.name),
                                detail: nls.localize('irreversible', "This action is irreversible!"),
                                primaryButton: nls.localize({ key: 'replaceButtonLabel', comment: ['&& denotes a mnemonic'] }, "&&Replace")
                            };
                            if (_this.messageService.confirm(confirm_1)) {
                                return _this.fileService.moveFile(source_1.resource, targetResource, true).then(function (result) {
                                    var fakeTargetState = new explorerViewModel_1.FileStat(targetResource);
                                    _this.eventService.emit('files.internal:fileChanged', new textfiles_1.LocalFileChangeEvent(fakeTargetState, null));
                                    onMove(result);
                                }, function (error) {
                                    _this.messageService.show(message_1.Severity.Error, error);
                                });
                            }
                            return;
                        }
                        _this.messageService.show(message_1.Severity.Error, error);
                    });
                });
            }, errors.onUnexpectedError);
        }
        this.progressService.showWhile(promise, 800);
        promise.done(null, errors.onUnexpectedError);
    };
    FileDragAndDrop = __decorate([
        __param(0, message_1.IMessageService),
        __param(1, workspace_1.IWorkspaceContextService),
        __param(2, event_1.IEventService),
        __param(3, progress_1.IProgressService),
        __param(4, files_1.IFileService),
        __param(5, configuration_1.IConfigurationService),
        __param(6, instantiation_1.IInstantiationService),
        __param(7, textfiles_1.ITextFileService)
    ], FileDragAndDrop);
    return FileDragAndDrop;
}());
exports.FileDragAndDrop = FileDragAndDrop;
