/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var winjs_base_1 = require('vs/base/common/winjs.base');
var nls = require('vs/nls');
var errors = require('vs/base/common/errors');
var errorMessage_1 = require('vs/base/common/errorMessage');
var paths = require('vs/base/common/paths');
var actions_1 = require('vs/base/common/actions');
var uri_1 = require('vs/base/common/uri');
var product_1 = require('vs/platform/product');
var baseEditor_1 = require('vs/workbench/browser/parts/editor/baseEditor');
var resourceEditorInput_1 = require('vs/workbench/common/editor/resourceEditorInput');
var diffEditorInput_1 = require('vs/workbench/common/editor/diffEditorInput');
var fileEditorInput_1 = require('vs/workbench/parts/files/common/editors/fileEditorInput');
var fileActions_1 = require('vs/workbench/parts/files/browser/fileActions');
var files_1 = require('vs/platform/files/common/files');
var editorService_1 = require('vs/workbench/services/editor/common/editorService');
var textfiles_1 = require('vs/workbench/services/textfile/common/textfiles');
var instantiation_1 = require('vs/platform/instantiation/common/instantiation');
var message_1 = require('vs/platform/message/common/message');
var modeService_1 = require('vs/editor/common/services/modeService');
var modelService_1 = require('vs/editor/common/services/modelService');
var lifecycle_1 = require('vs/base/common/lifecycle');
var textFileEditorModel_1 = require('vs/workbench/services/textfile/common/textFileEditorModel');
// A handler for save error happening with conflict resolution actions
var SaveErrorHandler = (function () {
    function SaveErrorHandler(messageService, textFileService, instantiationService) {
        this.messageService = messageService;
        this.textFileService = textFileService;
        this.instantiationService = instantiationService;
        this.messages = Object.create(null);
        this.toUnbind = [];
        this.registerListeners();
        // Hook into model
        textFileEditorModel_1.TextFileEditorModel.setSaveErrorHandler(this);
    }
    SaveErrorHandler.prototype.getId = function () {
        return 'vs.files.saveerrorhandler';
    };
    SaveErrorHandler.prototype.registerListeners = function () {
        var _this = this;
        this.toUnbind.push(this.textFileService.models.onModelSaved(function (e) { return _this.onFileSavedOrReverted(e.resource); }));
        this.toUnbind.push(this.textFileService.models.onModelReverted(function (e) { return _this.onFileSavedOrReverted(e.resource); }));
    };
    SaveErrorHandler.prototype.onFileSavedOrReverted = function (resource) {
        var hideMessage = this.messages[resource.toString()];
        if (hideMessage) {
            hideMessage();
            this.messages[resource.toString()] = void 0;
        }
    };
    SaveErrorHandler.prototype.onSaveError = function (error, model) {
        var _this = this;
        var message;
        var resource = model.getResource();
        // Dirty write prevention
        if (error.fileOperationResult === files_1.FileOperationResult.FILE_MODIFIED_SINCE) {
            message = this.instantiationService.createInstance(ResolveSaveConflictMessage, model, null);
        }
        else {
            var isReadonly = error.fileOperationResult === files_1.FileOperationResult.FILE_READ_ONLY;
            var actions = [];
            // Save As
            actions.push(new actions_1.Action('workbench.files.action.saveAs', fileActions_1.SaveFileAsAction.LABEL, null, true, function () {
                var saveAsAction = _this.instantiationService.createInstance(fileActions_1.SaveFileAsAction, fileActions_1.SaveFileAsAction.ID, fileActions_1.SaveFileAsAction.LABEL);
                saveAsAction.setResource(resource);
                saveAsAction.run().done(function () { return saveAsAction.dispose(); }, errors.onUnexpectedError);
                return winjs_base_1.TPromise.as(true);
            }));
            // Discard
            actions.push(new actions_1.Action('workbench.files.action.discard', nls.localize('discard', "Discard"), null, true, function () {
                var revertFileAction = _this.instantiationService.createInstance(fileActions_1.RevertFileAction, fileActions_1.RevertFileAction.ID, fileActions_1.RevertFileAction.LABEL);
                revertFileAction.setResource(resource);
                revertFileAction.run().done(function () { return revertFileAction.dispose(); }, errors.onUnexpectedError);
                return winjs_base_1.TPromise.as(true);
            }));
            // Retry
            if (isReadonly) {
                actions.push(new actions_1.Action('workbench.files.action.overwrite', nls.localize('overwrite', "Overwrite"), null, true, function () {
                    if (!model.isDisposed()) {
                        model.save({ overwriteReadonly: true }).done(null, errors.onUnexpectedError);
                    }
                    return winjs_base_1.TPromise.as(true);
                }));
            }
            else {
                actions.push(new actions_1.Action('workbench.files.action.retry', nls.localize('retry', "Retry"), null, true, function () {
                    var saveFileAction = _this.instantiationService.createInstance(fileActions_1.SaveFileAction, fileActions_1.SaveFileAction.ID, fileActions_1.SaveFileAction.LABEL);
                    saveFileAction.setResource(resource);
                    saveFileAction.run().done(function () { return saveFileAction.dispose(); }, errors.onUnexpectedError);
                    return winjs_base_1.TPromise.as(true);
                }));
            }
            // Cancel
            actions.push(message_1.CancelAction);
            var errorMessage = void 0;
            if (isReadonly) {
                errorMessage = nls.localize('readonlySaveError', "Failed to save '{0}': File is write protected. Select 'Overwrite' to remove protection.", paths.basename(resource.fsPath));
            }
            else {
                errorMessage = nls.localize('genericSaveError', "Failed to save '{0}': {1}", paths.basename(resource.fsPath), errorMessage_1.toErrorMessage(error, false));
            }
            message = {
                message: errorMessage,
                actions: actions
            };
        }
        // Show message and keep function to hide in case the file gets saved/reverted
        this.messages[model.getResource().toString()] = this.messageService.show(message_1.Severity.Error, message);
    };
    SaveErrorHandler.prototype.dispose = function () {
        this.toUnbind = lifecycle_1.dispose(this.toUnbind);
    };
    SaveErrorHandler = __decorate([
        __param(0, message_1.IMessageService),
        __param(1, textfiles_1.ITextFileService),
        __param(2, instantiation_1.IInstantiationService)
    ], SaveErrorHandler);
    return SaveErrorHandler;
}());
exports.SaveErrorHandler = SaveErrorHandler;
// Save conflict resolution editor input
var ConflictResolutionDiffEditorInput = (function (_super) {
    __extends(ConflictResolutionDiffEditorInput, _super);
    function ConflictResolutionDiffEditorInput(model, name, description, originalInput, modifiedInput) {
        _super.call(this, name, description, originalInput, modifiedInput);
        this.model = model;
    }
    ConflictResolutionDiffEditorInput.prototype.getModel = function () {
        return this.model;
    };
    ConflictResolutionDiffEditorInput.prototype.getTypeId = function () {
        return ConflictResolutionDiffEditorInput.ID;
    };
    ConflictResolutionDiffEditorInput.ID = 'workbench.editors.files.conflictResolutionDiffEditorInput';
    return ConflictResolutionDiffEditorInput;
}(diffEditorInput_1.DiffEditorInput));
exports.ConflictResolutionDiffEditorInput = ConflictResolutionDiffEditorInput;
var FileOnDiskEditorInput = (function (_super) {
    __extends(FileOnDiskEditorInput, _super);
    function FileOnDiskEditorInput(fileResource, name, description, modelService, modeService, instantiationService, textFileService) {
        // We create a new resource URI here that is different from the file resource because we represent the state of
        // the file as it is on disk and not as it is (potentially cached) in Code. That allows us to have a different
        // model for the left-hand comparision compared to the conflicting one in Code to the right.
        _super.call(this, name, description, uri_1.default.from({ scheme: 'disk', path: fileResource.fsPath }), modelService, instantiationService);
        this.modeService = modeService;
        this.textFileService = textFileService;
        this.fileResource = fileResource;
    }
    FileOnDiskEditorInput.prototype.getLastModified = function () {
        return this.lastModified;
    };
    FileOnDiskEditorInput.prototype.resolve = function (refresh) {
        var _this = this;
        // Make sure our file from disk is resolved up to date
        return this.textFileService.resolveTextContent(this.fileResource).then(function (content) {
            _this.lastModified = content.mtime;
            var codeEditorModel = _this.modelService.getModel(_this.resource);
            if (!codeEditorModel) {
                _this.modelService.createModel(content.value, _this.modeService.getOrCreateModeByFilenameOrFirstLine(_this.resource.fsPath), _this.resource);
                _this.createdEditorModel = true;
            }
            else {
                codeEditorModel.setValueFromRawText(content.value);
            }
            return _super.prototype.resolve.call(_this, refresh);
        });
    };
    FileOnDiskEditorInput.prototype.dispose = function () {
        if (this.createdEditorModel) {
            this.modelService.destroyModel(this.resource);
            this.createdEditorModel = false;
        }
        _super.prototype.dispose.call(this);
    };
    FileOnDiskEditorInput = __decorate([
        __param(3, modelService_1.IModelService),
        __param(4, modeService_1.IModeService),
        __param(5, instantiation_1.IInstantiationService),
        __param(6, textfiles_1.ITextFileService)
    ], FileOnDiskEditorInput);
    return FileOnDiskEditorInput;
}(resourceEditorInput_1.ResourceEditorInput));
exports.FileOnDiskEditorInput = FileOnDiskEditorInput;
var pendingResolveSaveConflictMessages = [];
function clearPendingResolveSaveConflictMessages() {
    while (pendingResolveSaveConflictMessages.length > 0) {
        pendingResolveSaveConflictMessages.pop()();
    }
}
// A message with action to resolve a save conflict
var ResolveSaveConflictMessage = (function () {
    function ResolveSaveConflictMessage(model, message, messageService, instantiationService, editorService) {
        var _this = this;
        this.messageService = messageService;
        this.instantiationService = instantiationService;
        this.editorService = editorService;
        this.model = model;
        var resource = model.getResource();
        if (message) {
            this.message = message;
        }
        else {
            this.message = nls.localize('staleSaveError', "Failed to save '{0}': The content on disk is newer. Click on **Compare** to compare your version with the one on disk.", paths.basename(resource.fsPath));
        }
        this.actions = [
            new actions_1.Action('workbench.files.action.resolveConflict', nls.localize('compareChanges', "Compare"), null, true, function () {
                if (!_this.model.isDisposed()) {
                    var originalInput = _this.instantiationService.createInstance(FileOnDiskEditorInput, resource, paths.basename(resource.fsPath), resource.fsPath);
                    var modifiedInput = _this.instantiationService.createInstance(fileEditorInput_1.FileEditorInput, resource, void 0);
                    var conflictInput = _this.instantiationService.createInstance(ConflictResolutionDiffEditorInput, _this.model, nls.localize('saveConflictDiffLabel', "{0} (on disk) â†” {1} (in {2})", modifiedInput.getName(), modifiedInput.getName(), product_1.default.nameLong), nls.localize('resolveSaveConflict', "Resolve save conflict"), originalInput, modifiedInput);
                    return _this.editorService.openEditor(conflictInput).then(function () {
                        // We have to bring the model into conflict resolution mode to prevent subsequent save erros when the user makes edits
                        _this.model.setConflictResolutionMode();
                        // Inform user
                        pendingResolveSaveConflictMessages.push(_this.messageService.show(message_1.Severity.Info, nls.localize('userGuide', "Use the actions in the editor tool bar to either **undo** your changes or **overwrite** the content on disk with your changes")));
                    });
                }
                return winjs_base_1.TPromise.as(true);
            })
        ];
    }
    ResolveSaveConflictMessage = __decorate([
        __param(2, message_1.IMessageService),
        __param(3, instantiation_1.IInstantiationService),
        __param(4, editorService_1.IWorkbenchEditorService)
    ], ResolveSaveConflictMessage);
    return ResolveSaveConflictMessage;
}());
// Accept changes to resolve a conflicting edit
var AcceptLocalChangesAction = (function (_super) {
    __extends(AcceptLocalChangesAction, _super);
    function AcceptLocalChangesAction(messageService, editorService) {
        _super.call(this, 'workbench.files.action.acceptLocalChanges', nls.localize('acceptLocalChanges', "Use local changes and overwrite disk contents"), 'conflict-editor-action accept-changes');
        this.messageService = messageService;
        this.editorService = editorService;
        this.messagesToHide = [];
    }
    AcceptLocalChangesAction.prototype.run = function () {
        var _this = this;
        var conflictInput = this.input;
        var model = conflictInput.getModel();
        var localModelValue = model.getValue();
        clearPendingResolveSaveConflictMessages(); // hide any previously shown message about how to use these actions
        // 1.) Get the diff editor model from cache (resolve(false)) to have access to the mtime of the file we currently show to the left
        return conflictInput.resolve(false).then(function (diffModel) {
            var knownLastModified = conflictInput.originalInput.getLastModified();
            // 2.) Revert the model to get the latest copy from disk and to have access to the mtime of the file now
            return model.revert().then(function () {
                var diskLastModified = model.getLastModifiedTime();
                // 3. a) If we know that the file on the left hand side was not modified meanwhile, restore the user value and trigger a save
                if (diskLastModified <= knownLastModified) {
                    // Restore user value
                    model.textEditorModel.setValue(localModelValue);
                    // Trigger save
                    return model.save().then(function () {
                        // Hide any previously shown messages
                        while (_this.messagesToHide.length) {
                            _this.messagesToHide.pop()();
                        }
                        // Reopen file input
                        return _this.editorService.openEditor({ resource: model.getResource() }, _this.position).then(function () {
                            // Dispose conflict input
                            conflictInput.dispose();
                        });
                    });
                }
                else {
                    // Again, we have to bring the model into conflict resolution because revert() would have cleared it
                    model.setConflictResolutionMode();
                    // Restore user value
                    model.textEditorModel.setValue(localModelValue);
                    // Reload the left hand side of the diff editor to show the up to date version and inform the user that he has to redo the action
                    return conflictInput.originalInput.resolve(true).then(function () {
                        _this.messagesToHide.push(_this.messageService.show(message_1.Severity.Info, nls.localize('conflictingFileHasChanged', "The content of the file on disk has changed and the left hand side of the compare editor was refreshed. Please review and resolve again.")));
                    });
                }
            });
        });
    };
    AcceptLocalChangesAction = __decorate([
        __param(0, message_1.IMessageService),
        __param(1, editorService_1.IWorkbenchEditorService)
    ], AcceptLocalChangesAction);
    return AcceptLocalChangesAction;
}(baseEditor_1.EditorInputAction));
exports.AcceptLocalChangesAction = AcceptLocalChangesAction;
// Revert changes to resolve a conflicting edit
var RevertLocalChangesAction = (function (_super) {
    __extends(RevertLocalChangesAction, _super);
    function RevertLocalChangesAction(editorService) {
        _super.call(this, 'workbench.action.files.revert', nls.localize('revertLocalChanges', "Discard local changes and revert to content on disk"), 'conflict-editor-action revert-changes');
        this.editorService = editorService;
    }
    RevertLocalChangesAction.prototype.run = function () {
        var _this = this;
        var conflictInput = this.input;
        var model = conflictInput.getModel();
        clearPendingResolveSaveConflictMessages(); // hide any previously shown message about how to use these actions
        // Revert on model
        return model.revert().then(function () {
            // Reopen file input
            return _this.editorService.openEditor({ resource: model.getResource() }, _this.position).then(function () {
                // Dispose conflict input
                conflictInput.dispose();
            });
        });
    };
    RevertLocalChangesAction = __decorate([
        __param(0, editorService_1.IWorkbenchEditorService)
    ], RevertLocalChangesAction);
    return RevertLocalChangesAction;
}(baseEditor_1.EditorInputAction));
exports.RevertLocalChangesAction = RevertLocalChangesAction;
