/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var lifecycle_1 = require("vs/base/common/lifecycle");
var strings_1 = require("vs/base/common/strings");
var eventEmitter_1 = require("vs/base/common/eventEmitter");
var git_1 = require("vs/workbench/parts/git/common/git");
var FileStatus = (function () {
    function FileStatus(path, mimetype, status, rename, isModifiedInIndex) {
        this.path = path;
        this.mimetype = mimetype;
        this.status = status;
        this.rename = rename;
        this.id = FileStatus.typeOf(status) + ':' + path + (rename ? ':' + rename : '') + (isModifiedInIndex ? '$' : '');
        this.pathComponents = path.split('/');
    }
    FileStatus.prototype.getPath = function () {
        return this.path;
    };
    FileStatus.prototype.getPathComponents = function () {
        return this.pathComponents.slice(0);
    };
    FileStatus.prototype.getMimetype = function () {
        return this.mimetype;
    };
    FileStatus.prototype.getStatus = function () {
        return this.status;
    };
    FileStatus.prototype.getRename = function () {
        return this.rename;
    };
    FileStatus.prototype.getId = function () {
        return this.id;
    };
    FileStatus.prototype.getType = function () {
        switch (FileStatus.typeOf(this.status)) {
            case 'index': return git_1.StatusType.INDEX;
            case 'workingTree': return git_1.StatusType.WORKING_TREE;
            default: return git_1.StatusType.MERGE;
        }
    };
    FileStatus.prototype.clone = function () {
        return new FileStatus(this.path, this.mimetype, this.status, this.rename);
    };
    FileStatus.prototype.update = function (other) {
        this.status = other.getStatus();
        this.rename = other.getRename();
    };
    FileStatus.typeOf = function (s) {
        switch (s) {
            case git_1.Status.INDEX_MODIFIED:
            case git_1.Status.INDEX_ADDED:
            case git_1.Status.INDEX_DELETED:
            case git_1.Status.INDEX_RENAMED:
            case git_1.Status.INDEX_COPIED:
                return 'index';
            case git_1.Status.MODIFIED:
            case git_1.Status.DELETED:
            case git_1.Status.UNTRACKED:
            case git_1.Status.IGNORED:
                return 'workingTree';
            default:
                return 'merge';
        }
    };
    return FileStatus;
}());
exports.FileStatus = FileStatus;
var StatusGroup = (function (_super) {
    __extends(StatusGroup, _super);
    function StatusGroup(type) {
        var _this = _super.call(this) || this;
        _this.type = type;
        _this.statusSet = Object.create(null);
        _this.statusList = [];
        _this.statusByName = Object.create(null);
        _this.statusByRename = Object.create(null);
        return _this;
    }
    StatusGroup.prototype.getType = function () {
        return this.type;
    };
    StatusGroup.prototype.update = function (statusList) {
        var toDelete = Object.create(null);
        var id, path, rename;
        var status;
        for (id in this.statusSet) {
            toDelete[id] = this.statusSet[id];
        }
        for (var i = 0; i < statusList.length; i++) {
            status = statusList[i];
            id = status.getId();
            path = status.getPath();
            rename = status.getRename();
            if (toDelete[id]) {
                this.statusSet[id].update(status);
                toDelete[id] = null;
            }
            else {
                this.statusSet[id] = status;
            }
        }
        for (id in toDelete) {
            if (status = toDelete[id]) {
                this.emit('fileStatus:dispose', status);
                delete this.statusSet[id];
            }
        }
        this.statusList = [];
        this.statusByName = Object.create(null);
        this.statusByRename = Object.create(null);
        for (id in this.statusSet) {
            status = this.statusSet[id];
            this.statusList.push(status);
            if (status.getRename()) {
                this.statusByRename[status.getPath()] = status;
            }
            else {
                this.statusByName[status.getPath()] = status;
            }
        }
    };
    StatusGroup.prototype.all = function () {
        return this.statusList;
    };
    StatusGroup.prototype.find = function (path) {
        return this.statusByName[path] || this.statusByRename[path] || null;
    };
    StatusGroup.prototype.dispose = function () {
        this.type = null;
        this.statusSet = null;
        this.statusList = null;
        this.statusByName = null;
        this.statusByRename = null;
        _super.prototype.dispose.call(this);
    };
    return StatusGroup;
}(eventEmitter_1.EventEmitter));
exports.StatusGroup = StatusGroup;
var StatusModel = (function (_super) {
    __extends(StatusModel, _super);
    function StatusModel() {
        var _this = _super.call(this) || this;
        _this.indexStatus = new StatusGroup(git_1.StatusType.INDEX);
        _this.workingTreeStatus = new StatusGroup(git_1.StatusType.WORKING_TREE);
        _this.mergeStatus = new StatusGroup(git_1.StatusType.MERGE);
        _this.toDispose = [
            _this.addEmitter2(_this.indexStatus),
            _this.addEmitter2(_this.workingTreeStatus),
            _this.addEmitter2(_this.mergeStatus)
        ];
        return _this;
    }
    StatusModel.prototype.getSummary = function () {
        return {
            hasWorkingTreeChanges: this.getWorkingTreeStatus().all().length > 0,
            hasIndexChanges: this.getIndexStatus().all().length > 0,
            hasMergeChanges: this.getMergeStatus().all().length > 0
        };
    };
    StatusModel.prototype.update = function (status) {
        var index = [];
        var workingTree = [];
        var merge = [];
        status.forEach(function (raw) {
            switch (raw.x + raw.y) {
                case '??': return workingTree.push(new FileStatus(raw.path, raw.mimetype, git_1.Status.UNTRACKED));
                case '!!': return workingTree.push(new FileStatus(raw.path, raw.mimetype, git_1.Status.IGNORED));
                case 'DD': return merge.push(new FileStatus(raw.path, raw.mimetype, git_1.Status.BOTH_DELETED));
                case 'AU': return merge.push(new FileStatus(raw.path, raw.mimetype, git_1.Status.ADDED_BY_US));
                case 'UD': return merge.push(new FileStatus(raw.path, raw.mimetype, git_1.Status.DELETED_BY_THEM));
                case 'UA': return merge.push(new FileStatus(raw.path, raw.mimetype, git_1.Status.ADDED_BY_THEM));
                case 'DU': return merge.push(new FileStatus(raw.path, raw.mimetype, git_1.Status.DELETED_BY_US));
                case 'AA': return merge.push(new FileStatus(raw.path, raw.mimetype, git_1.Status.BOTH_ADDED));
                case 'UU': return merge.push(new FileStatus(raw.path, raw.mimetype, git_1.Status.BOTH_MODIFIED));
            }
            var isModifiedInIndex = false;
            switch (raw.x) {
                case 'M':
                    index.push(new FileStatus(raw.path, raw.mimetype, git_1.Status.INDEX_MODIFIED));
                    isModifiedInIndex = true;
                    break;
                case 'A':
                    index.push(new FileStatus(raw.path, raw.mimetype, git_1.Status.INDEX_ADDED));
                    break;
                case 'D':
                    index.push(new FileStatus(raw.path, raw.mimetype, git_1.Status.INDEX_DELETED));
                    break;
                case 'R':
                    index.push(new FileStatus(raw.path, raw.mimetype, git_1.Status.INDEX_RENAMED, raw.rename));
                    break;
                case 'C':
                    index.push(new FileStatus(raw.path, raw.mimetype, git_1.Status.INDEX_COPIED));
                    break;
            }
            switch (raw.y) {
                case 'M':
                    workingTree.push(new FileStatus(raw.path, raw.mimetype, git_1.Status.MODIFIED, raw.rename, isModifiedInIndex));
                    break;
                case 'D':
                    workingTree.push(new FileStatus(raw.path, raw.mimetype, git_1.Status.DELETED, raw.rename));
                    break;
            }
        });
        this.indexStatus.update(index);
        this.workingTreeStatus.update(workingTree);
        this.mergeStatus.update(merge);
        this.emit(git_1.ModelEvents.STATUS_MODEL_UPDATED);
    };
    StatusModel.prototype.getIndexStatus = function () {
        return this.indexStatus;
    };
    StatusModel.prototype.getWorkingTreeStatus = function () {
        return this.workingTreeStatus;
    };
    StatusModel.prototype.getMergeStatus = function () {
        return this.mergeStatus;
    };
    StatusModel.prototype.getGroups = function () {
        return [this.mergeStatus, this.indexStatus, this.workingTreeStatus];
    };
    StatusModel.prototype.find = function (path, type) {
        switch (type) {
            case git_1.StatusType.INDEX:
                return this.indexStatus.find(path);
            case git_1.StatusType.WORKING_TREE:
                return this.workingTreeStatus.find(path);
            case git_1.StatusType.MERGE:
                return this.mergeStatus.find(path);
            default:
                return null;
        }
    };
    StatusModel.prototype.dispose = function () {
        this.toDispose = lifecycle_1.dispose(this.toDispose);
        if (this.indexStatus) {
            this.indexStatus.dispose();
            this.indexStatus = null;
        }
        if (this.workingTreeStatus) {
            this.workingTreeStatus.dispose();
            this.workingTreeStatus = null;
        }
        if (this.mergeStatus) {
            this.mergeStatus.dispose();
            this.mergeStatus = null;
        }
        _super.prototype.dispose.call(this);
    };
    return StatusModel;
}(eventEmitter_1.EventEmitter));
exports.StatusModel = StatusModel;
var Model = (function (_super) {
    __extends(Model, _super);
    function Model() {
        var _this = _super.call(this) || this;
        _this.toDispose = [];
        _this.repositoryRoot = null;
        _this.status = new StatusModel();
        _this.toDispose.push(_this.addEmitter2(_this.status));
        _this.HEAD = null;
        _this.refs = [];
        _this.remotes = [];
        return _this;
    }
    Model.prototype.getRepositoryRoot = function () {
        return this.repositoryRoot;
    };
    Model.prototype.getStatus = function () {
        return this.status;
    };
    Model.prototype.getHEAD = function () {
        return this.HEAD;
    };
    Model.prototype.getRefs = function () {
        return this.refs;
    };
    Model.prototype.getRemotes = function () {
        return this.remotes;
    };
    Model.prototype.update = function (status) {
        if (!status) {
            status = {
                repositoryRoot: null,
                status: [],
                HEAD: null,
                refs: [],
                remotes: []
            };
        }
        this.repositoryRoot = status.repositoryRoot;
        this.status.update(status.status);
        this.HEAD = status.HEAD;
        this.emit(git_1.ModelEvents.HEAD_UPDATED);
        this.refs = status.refs;
        this.emit(git_1.ModelEvents.REFS_UPDATED);
        this.remotes = status.remotes;
        this.emit(git_1.ModelEvents.REMOTES_UPDATED);
        this.emit(git_1.ModelEvents.MODEL_UPDATED);
    };
    Model.prototype.getStatusSummary = function () {
        var status = this.getStatus();
        return {
            hasWorkingTreeChanges: status.getWorkingTreeStatus().all().length > 0,
            hasIndexChanges: status.getIndexStatus().all().length > 0,
            hasMergeChanges: status.getMergeStatus().all().length > 0
        };
    };
    Model.prototype.getPS1 = function () {
        var _this = this;
        if (!this.HEAD) {
            return '';
        }
        var tag = this.getRefs().filter(function (iref) { return iref.type === git_1.RefType.Tag && iref.commit === _this.HEAD.commit; })[0];
        var tagName = tag && tag.name;
        var head = this.HEAD.name || tagName || this.HEAD.commit.substr(0, 8);
        var statusSummary = this.getStatus().getSummary();
        return strings_1.format('{0}{1}{2}{3}', head, statusSummary.hasWorkingTreeChanges ? '*' : '', statusSummary.hasIndexChanges ? '+' : '', statusSummary.hasMergeChanges ? '!' : '');
    };
    Model.prototype.dispose = function () {
        this.toDispose = lifecycle_1.dispose(this.toDispose);
        _super.prototype.dispose.call(this);
    };
    return Model;
}(eventEmitter_1.EventEmitter));
exports.Model = Model;
