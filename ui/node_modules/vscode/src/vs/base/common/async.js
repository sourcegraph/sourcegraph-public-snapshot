/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var errors = require('vs/base/common/errors');
var platform = require('vs/base/common/platform');
var winjs_base_1 = require('vs/base/common/winjs.base');
var cancellation_1 = require('vs/base/common/cancellation');
var lifecycle_1 = require('vs/base/common/lifecycle');
function isThenable(obj) {
    return obj && typeof obj.then === 'function';
}
function toThenable(arg) {
    if (isThenable(arg)) {
        return arg;
    }
    else {
        return winjs_base_1.TPromise.as(arg);
    }
}
exports.toThenable = toThenable;
function asWinJsPromise(callback) {
    var source = new cancellation_1.CancellationTokenSource();
    return new winjs_base_1.TPromise(function (resolve, reject, progress) {
        var item = callback(source.token);
        if (item instanceof winjs_base_1.TPromise) {
            item.then(resolve, reject, progress);
        }
        else if (isThenable(item)) {
            item.then(resolve, reject);
        }
        else {
            resolve(item);
        }
    }, function () {
        source.cancel();
    });
}
exports.asWinJsPromise = asWinJsPromise;
/**
 * Hook a cancellation token to a WinJS Promise
 */
function wireCancellationToken(token, promise, resolveAsUndefinedWhenCancelled) {
    var subscription = token.onCancellationRequested(function () { return promise.cancel(); });
    if (resolveAsUndefinedWhenCancelled) {
        promise = promise.then(undefined, function (err) {
            if (!errors.isPromiseCanceledError(err)) {
                return winjs_base_1.TPromise.wrapError(err);
            }
        });
    }
    return always(promise, function () { return subscription.dispose(); });
}
exports.wireCancellationToken = wireCancellationToken;
/**
 * A helper to prevent accumulation of sequential async tasks.
 *
 * Imagine a mail man with the sole task of delivering letters. As soon as
 * a letter submitted for delivery, he drives to the destination, delivers it
 * and returns to his base. Imagine that during the trip, N more letters were submitted.
 * When the mail man returns, he picks those N letters and delivers them all in a
 * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.
 *
 * The throttler implements this via the queue() method, by providing it a task
 * factory. Following the example:
 *
 * 		var throttler = new Throttler();
 * 		var letters = [];
 *
 * 		function deliver() {
 * 			const lettersToDeliver = letters;
 * 			letters = [];
 * 			return makeTheTrip(lettersToDeliver);
 * 		}
 *
 * 		function onLetterReceived(l) {
 * 			letters.push(l);
 * 			throttler.queue(deliver);
 * 		}
 */
var Throttler = (function () {
    function Throttler() {
        this.activePromise = null;
        this.queuedPromise = null;
        this.queuedPromiseFactory = null;
    }
    Throttler.prototype.queue = function (promiseFactory) {
        var _this = this;
        if (this.activePromise) {
            this.queuedPromiseFactory = promiseFactory;
            if (!this.queuedPromise) {
                var onComplete_1 = function () {
                    _this.queuedPromise = null;
                    var result = _this.queue(_this.queuedPromiseFactory);
                    _this.queuedPromiseFactory = null;
                    return result;
                };
                this.queuedPromise = new winjs_base_1.Promise(function (c, e, p) {
                    _this.activePromise.then(onComplete_1, onComplete_1, p).done(c);
                }, function () {
                    _this.activePromise.cancel();
                });
            }
            return new winjs_base_1.Promise(function (c, e, p) {
                _this.queuedPromise.then(c, e, p);
            }, function () {
                // no-op
            });
        }
        this.activePromise = promiseFactory();
        return new winjs_base_1.Promise(function (c, e, p) {
            _this.activePromise.done(function (result) {
                _this.activePromise = null;
                c(result);
            }, function (err) {
                _this.activePromise = null;
                e(err);
            }, p);
        }, function () {
            _this.activePromise.cancel();
        });
    };
    return Throttler;
}());
exports.Throttler = Throttler;
// TODO@Joao: can the previous throttler be replaced with this?
var SimpleThrottler = (function () {
    function SimpleThrottler() {
        this.current = winjs_base_1.TPromise.as(null);
    }
    SimpleThrottler.prototype.queue = function (promiseTask) {
        return this.current = this.current.then(function () { return promiseTask(); });
    };
    return SimpleThrottler;
}());
exports.SimpleThrottler = SimpleThrottler;
/**
 * A helper to delay execution of a task that is being requested often.
 *
 * Following the throttler, now imagine the mail man wants to optimize the number of
 * trips proactively. The trip itself can be long, so the he decides not to make the trip
 * as soon as a letter is submitted. Instead he waits a while, in case more
 * letters are submitted. After said waiting period, if no letters were submitted, he
 * decides to make the trip. Imagine that N more letters were submitted after the first
 * one, all within a short period of time between each other. Even though N+1
 * submissions occurred, only 1 delivery was made.
 *
 * The delayer offers this behavior via the trigger() method, into which both the task
 * to be executed and the waiting period (delay) must be passed in as arguments. Following
 * the example:
 *
 * 		var delayer = new Delayer(WAITING_PERIOD);
 * 		var letters = [];
 *
 * 		function letterReceived(l) {
 * 			letters.push(l);
 * 			delayer.trigger(() => { return makeTheTrip(); });
 * 		}
 */
var Delayer = (function () {
    function Delayer(defaultDelay) {
        this.defaultDelay = defaultDelay;
        this.timeout = null;
        this.completionPromise = null;
        this.onSuccess = null;
        this.task = null;
    }
    Delayer.prototype.trigger = function (task, delay) {
        var _this = this;
        if (delay === void 0) { delay = this.defaultDelay; }
        this.task = task;
        this.cancelTimeout();
        if (!this.completionPromise) {
            this.completionPromise = new winjs_base_1.Promise(function (c) {
                _this.onSuccess = c;
            }, function () {
                // no-op
            }).then(function () {
                _this.completionPromise = null;
                _this.onSuccess = null;
                var task = _this.task;
                _this.task = null;
                return task();
            });
        }
        this.timeout = setTimeout(function () {
            _this.timeout = null;
            _this.onSuccess(null);
        }, delay);
        return this.completionPromise;
    };
    Delayer.prototype.isTriggered = function () {
        return this.timeout !== null;
    };
    Delayer.prototype.cancel = function () {
        this.cancelTimeout();
        if (this.completionPromise) {
            this.completionPromise.cancel();
            this.completionPromise = null;
        }
    };
    Delayer.prototype.cancelTimeout = function () {
        if (this.timeout !== null) {
            clearTimeout(this.timeout);
            this.timeout = null;
        }
    };
    return Delayer;
}());
exports.Delayer = Delayer;
/**
 * A helper to delay execution of a task that is being requested often, while
 * preventing accumulation of consecutive executions, while the task runs.
 *
 * Simply combine the two mail man strategies from the Throttler and Delayer
 * helpers, for an analogy.
 */
var ThrottledDelayer = (function (_super) {
    __extends(ThrottledDelayer, _super);
    function ThrottledDelayer(defaultDelay) {
        _super.call(this, defaultDelay);
        this.throttler = new Throttler();
    }
    ThrottledDelayer.prototype.trigger = function (promiseFactory, delay) {
        var _this = this;
        return _super.prototype.trigger.call(this, function () { return _this.throttler.queue(promiseFactory); }, delay);
    };
    return ThrottledDelayer;
}(Delayer));
exports.ThrottledDelayer = ThrottledDelayer;
/**
 * Similar to the ThrottledDelayer, except it also guarantees that the promise
 * factory doesn't get called more often than every `minimumPeriod` milliseconds.
 */
var PeriodThrottledDelayer = (function (_super) {
    __extends(PeriodThrottledDelayer, _super);
    function PeriodThrottledDelayer(defaultDelay, minimumPeriod) {
        if (minimumPeriod === void 0) { minimumPeriod = 0; }
        _super.call(this, defaultDelay);
        this.minimumPeriod = minimumPeriod;
        this.periodThrottler = new Throttler();
    }
    PeriodThrottledDelayer.prototype.trigger = function (promiseFactory, delay) {
        var _this = this;
        return _super.prototype.trigger.call(this, function () {
            return _this.periodThrottler.queue(function () {
                return winjs_base_1.Promise.join([
                    winjs_base_1.TPromise.timeout(_this.minimumPeriod),
                    promiseFactory()
                ]).then(function (r) { return r[1]; });
            });
        }, delay);
    };
    return PeriodThrottledDelayer;
}(ThrottledDelayer));
exports.PeriodThrottledDelayer = PeriodThrottledDelayer;
var PromiseSource = (function () {
    function PromiseSource() {
        var _this = this;
        this._value = new winjs_base_1.TPromise(function (c, e) {
            _this._completeCallback = c;
            _this._errorCallback = e;
        });
    }
    Object.defineProperty(PromiseSource.prototype, "value", {
        get: function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    PromiseSource.prototype.complete = function (value) {
        this._completeCallback(value);
    };
    PromiseSource.prototype.error = function (err) {
        this._errorCallback(err);
    };
    return PromiseSource;
}());
exports.PromiseSource = PromiseSource;
var ShallowCancelThenPromise = (function (_super) {
    __extends(ShallowCancelThenPromise, _super);
    function ShallowCancelThenPromise(outer) {
        var completeCallback, errorCallback, progressCallback;
        _super.call(this, function (c, e, p) {
            completeCallback = c;
            errorCallback = e;
            progressCallback = p;
        }, function () {
            // cancel this promise but not the
            // outer promise
            errorCallback(errors.canceled());
        });
        outer.then(completeCallback, errorCallback, progressCallback);
    }
    return ShallowCancelThenPromise;
}(winjs_base_1.TPromise));
exports.ShallowCancelThenPromise = ShallowCancelThenPromise;
/**
 * Returns a new promise that joins the provided promise. Upon completion of
 * the provided promise the provided function will always be called. This
 * method is comparable to a try-finally code block.
 * @param promise a promise
 * @param f a function that will be call in the success and error case.
 */
function always(promise, f) {
    return new winjs_base_1.TPromise(function (c, e, p) {
        promise.done(function (result) {
            try {
                f(result);
            }
            catch (e1) {
                errors.onUnexpectedError(e1);
            }
            c(result);
        }, function (err) {
            try {
                f(err);
            }
            catch (e1) {
                errors.onUnexpectedError(e1);
            }
            e(err);
        }, function (progress) {
            p(progress);
        });
    }, function () {
        promise.cancel();
    });
}
exports.always = always;
/**
 * Runs the provided list of promise factories in sequential order. The returned
 * promise will complete to an array of results from each promise.
 */
function sequence(promiseFactory) {
    var results = [];
    // reverse since we start with last element using pop()
    promiseFactory = promiseFactory.reverse();
    function next() {
        if (promiseFactory.length) {
            return promiseFactory.pop()();
        }
        return null;
    }
    function thenHandler(result) {
        if (result !== undefined && result !== null) {
            results.push(result);
        }
        var n = next();
        if (n) {
            return n.then(thenHandler);
        }
        return winjs_base_1.TPromise.as(results);
    }
    return winjs_base_1.TPromise.as(null).then(thenHandler);
}
exports.sequence = sequence;
function once(fn) {
    var _this = this;
    var didCall = false;
    var result;
    return function () {
        if (didCall) {
            return result;
        }
        didCall = true;
        result = fn.apply(_this, arguments);
        return result;
    };
}
exports.once = once;
/**
 * A helper to queue N promises and run them all with a max degree of parallelism. The helper
 * ensures that at any time no more than M promises are running at the same time.
 */
var Limiter = (function () {
    function Limiter(maxDegreeOfParalellism) {
        this.maxDegreeOfParalellism = maxDegreeOfParalellism;
        this.outstandingPromises = [];
        this.runningPromises = 0;
    }
    Limiter.prototype.queue = function (promiseFactory) {
        var _this = this;
        return new winjs_base_1.TPromise(function (c, e, p) {
            _this.outstandingPromises.push({
                factory: promiseFactory,
                c: c,
                e: e,
                p: p
            });
            _this.consume();
        });
    };
    Limiter.prototype.consume = function () {
        var _this = this;
        while (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {
            var iLimitedTask = this.outstandingPromises.shift();
            this.runningPromises++;
            var promise = iLimitedTask.factory();
            promise.done(iLimitedTask.c, iLimitedTask.e, iLimitedTask.p);
            promise.done(function () { return _this.consumed(); }, function () { return _this.consumed(); });
        }
    };
    Limiter.prototype.consumed = function () {
        this.runningPromises--;
        this.consume();
    };
    return Limiter;
}());
exports.Limiter = Limiter;
var TimeoutTimer = (function (_super) {
    __extends(TimeoutTimer, _super);
    function TimeoutTimer() {
        _super.call(this);
        this._token = -1;
    }
    TimeoutTimer.prototype.dispose = function () {
        this.cancel();
        _super.prototype.dispose.call(this);
    };
    TimeoutTimer.prototype.cancel = function () {
        if (this._token !== -1) {
            platform.clearTimeout(this._token);
            this._token = -1;
        }
    };
    TimeoutTimer.prototype.cancelAndSet = function (runner, timeout) {
        var _this = this;
        this.cancel();
        this._token = platform.setTimeout(function () {
            _this._token = -1;
            runner();
        }, timeout);
    };
    TimeoutTimer.prototype.setIfNotSet = function (runner, timeout) {
        var _this = this;
        if (this._token !== -1) {
            // timer is already set
            return;
        }
        this._token = platform.setTimeout(function () {
            _this._token = -1;
            runner();
        }, timeout);
    };
    return TimeoutTimer;
}(lifecycle_1.Disposable));
exports.TimeoutTimer = TimeoutTimer;
var IntervalTimer = (function (_super) {
    __extends(IntervalTimer, _super);
    function IntervalTimer() {
        _super.call(this);
        this._token = -1;
    }
    IntervalTimer.prototype.dispose = function () {
        this.cancel();
        _super.prototype.dispose.call(this);
    };
    IntervalTimer.prototype.cancel = function () {
        if (this._token !== -1) {
            platform.clearInterval(this._token);
            this._token = -1;
        }
    };
    IntervalTimer.prototype.cancelAndSet = function (runner, interval) {
        this.cancel();
        this._token = platform.setInterval(function () {
            runner();
        }, interval);
    };
    return IntervalTimer;
}(lifecycle_1.Disposable));
exports.IntervalTimer = IntervalTimer;
var RunOnceScheduler = (function () {
    function RunOnceScheduler(runner, timeout) {
        this.timeoutToken = -1;
        this.runner = runner;
        this.timeout = timeout;
        this.timeoutHandler = this.onTimeout.bind(this);
    }
    /**
     * Dispose RunOnceScheduler
     */
    RunOnceScheduler.prototype.dispose = function () {
        this.cancel();
        this.runner = null;
    };
    /**
     * Cancel current scheduled runner (if any).
     */
    RunOnceScheduler.prototype.cancel = function () {
        if (this.isScheduled()) {
            platform.clearTimeout(this.timeoutToken);
            this.timeoutToken = -1;
        }
    };
    /**
     * Replace runner. If there is a runner already scheduled, the new runner will be called.
     */
    RunOnceScheduler.prototype.setRunner = function (runner) {
        this.runner = runner;
    };
    /**
     * Cancel previous runner (if any) & schedule a new runner.
     */
    RunOnceScheduler.prototype.schedule = function (delay) {
        if (delay === void 0) { delay = this.timeout; }
        this.cancel();
        this.timeoutToken = platform.setTimeout(this.timeoutHandler, delay);
    };
    /**
     * Returns true if scheduled.
     */
    RunOnceScheduler.prototype.isScheduled = function () {
        return this.timeoutToken !== -1;
    };
    RunOnceScheduler.prototype.onTimeout = function () {
        this.timeoutToken = -1;
        if (this.runner) {
            this.runner();
        }
    };
    return RunOnceScheduler;
}());
exports.RunOnceScheduler = RunOnceScheduler;
function nfcall(fn) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return new winjs_base_1.Promise(function (c, e) { return fn.apply(void 0, args.concat([function (err, result) { return err ? e(err) : c(result); }])); });
}
exports.nfcall = nfcall;
function ninvoke(thisArg, fn) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    return new winjs_base_1.Promise(function (c, e) { return fn.call.apply(fn, [thisArg].concat(args, [function (err, result) { return err ? e(err) : c(result); }])); });
}
exports.ninvoke = ninvoke;
