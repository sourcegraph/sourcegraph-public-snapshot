/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var Platform = require('vs/base/common/platform');
var DomUtils = require('vs/base/browser/dom');
var mouseEvent_1 = require('vs/base/browser/mouseEvent');
var globalMouseMoveMonitor_1 = require('vs/base/browser/globalMouseMoveMonitor');
var widget_1 = require('vs/base/browser/ui/widget');
var styleMutator_1 = require('vs/base/browser/styleMutator');
var scrollbarArrow_1 = require('vs/base/browser/ui/scrollbar/scrollbarArrow');
var scrollbarVisibilityController_1 = require('vs/base/browser/ui/scrollbar/scrollbarVisibilityController');
/**
 * The orthogonal distance to the slider at which dragging "resets". This implements "snapping"
 */
var MOUSE_DRAG_RESET_DISTANCE = 140;
var AbstractScrollbar = (function (_super) {
    __extends(AbstractScrollbar, _super);
    function AbstractScrollbar(opts) {
        var _this = this;
        _super.call(this);
        this._canUseTranslate3d = opts.canUseTranslate3d;
        this._lazyRender = opts.lazyRender;
        this._host = opts.host;
        this._scrollable = opts.scrollable;
        this._scrollbarState = opts.scrollbarState;
        this._visibilityController = this._register(new scrollbarVisibilityController_1.ScrollbarVisibilityController(opts.visibility, 'visible scrollbar ' + opts.extraScrollbarClassName, 'invisible scrollbar ' + opts.extraScrollbarClassName));
        this._mouseMoveMonitor = this._register(new globalMouseMoveMonitor_1.GlobalMouseMoveMonitor());
        this._shouldRender = true;
        this.domNode = styleMutator_1.createFastDomNode(document.createElement('div'));
        this._visibilityController.setDomNode(this.domNode);
        this.domNode.setPosition('absolute');
        this.onmousedown(this.domNode.domNode, function (e) { return _this._domNodeMouseDown(e); });
    }
    // ----------------- creation
    /**
     * Creates the dom node for an arrow & adds it to the container
     */
    AbstractScrollbar.prototype._createArrow = function (opts) {
        var arrow = this._register(new scrollbarArrow_1.ScrollbarArrow(opts));
        this.domNode.domNode.appendChild(arrow.bgDomNode);
        this.domNode.domNode.appendChild(arrow.domNode);
    };
    /**
     * Creates the slider dom node, adds it to the container & hooks up the events
     */
    AbstractScrollbar.prototype._createSlider = function (top, left, width, height) {
        var _this = this;
        this.slider = styleMutator_1.createFastDomNode(document.createElement('div'));
        this.slider.setClassName('slider');
        this.slider.setPosition('absolute');
        this.slider.setTop(top);
        this.slider.setLeft(left);
        this.slider.setWidth(width);
        this.slider.setHeight(height);
        this.domNode.domNode.appendChild(this.slider.domNode);
        this.onmousedown(this.slider.domNode, function (e) { return _this._sliderMouseDown(e); });
    };
    // ----------------- Update state
    AbstractScrollbar.prototype.setCanUseTranslate3d = function (canUseTranslate3d) {
        this._canUseTranslate3d = canUseTranslate3d;
        return true;
    };
    AbstractScrollbar.prototype._onElementSize = function (visibleSize) {
        if (this._scrollbarState.setVisibleSize(visibleSize)) {
            this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
            this._shouldRender = true;
            if (!this._lazyRender) {
                this.render();
            }
        }
        return this._shouldRender;
    };
    AbstractScrollbar.prototype._onElementScrollSize = function (elementScrollSize) {
        if (this._scrollbarState.setScrollSize(elementScrollSize)) {
            this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
            this._shouldRender = true;
            if (!this._lazyRender) {
                this.render();
            }
        }
        return this._shouldRender;
    };
    AbstractScrollbar.prototype._onElementScrollPosition = function (elementScrollPosition) {
        if (this._scrollbarState.setScrollPosition(elementScrollPosition)) {
            this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded());
            this._shouldRender = true;
            if (!this._lazyRender) {
                this.render();
            }
        }
        return this._shouldRender;
    };
    // ----------------- rendering
    AbstractScrollbar.prototype.beginReveal = function () {
        this._visibilityController.setShouldBeVisible(true);
    };
    AbstractScrollbar.prototype.beginHide = function () {
        this._visibilityController.setShouldBeVisible(false);
    };
    AbstractScrollbar.prototype.render = function () {
        if (!this._shouldRender) {
            return;
        }
        this._shouldRender = false;
        if (this._canUseTranslate3d) {
            // Put the scrollbar in its own layer
            this.domNode.setTransform('translate3d(0px, 0px, 0px)');
        }
        else {
            this.domNode.setTransform('');
        }
        this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize());
        this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition());
    };
    // ----------------- DOM events
    AbstractScrollbar.prototype._domNodeMouseDown = function (e) {
        if (e.target !== this.domNode.domNode) {
            return;
        }
        this._onMouseDown(e);
    };
    AbstractScrollbar.prototype.delegateMouseDown = function (browserEvent) {
        var e = new mouseEvent_1.StandardMouseEvent(browserEvent);
        var domTop = this.domNode.domNode.getClientRects()[0].top;
        var sliderStart = domTop + this._scrollbarState.getSliderPosition();
        var sliderStop = domTop + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize();
        var mousePos = this._sliderMousePosition(e);
        if (sliderStart <= mousePos && mousePos <= sliderStop) {
            // Act as if it was a mouse down on the slider
            this._sliderMouseDown(e);
        }
        else {
            // Act as if it was a mouse down on the scrollbar
            this._onMouseDown(e);
        }
    };
    AbstractScrollbar.prototype._onMouseDown = function (e) {
        var domNodePosition = DomUtils.getDomNodePagePosition(this.domNode.domNode);
        var desiredSliderPosition = this._mouseDownRelativePosition(e, domNodePosition) - this._scrollbarState.getArrowSize() - this._scrollbarState.getSliderSize() / 2;
        this.setDesiredScrollPosition(this._scrollbarState.convertSliderPositionToScrollPosition(desiredSliderPosition));
        this._sliderMouseDown(e);
    };
    AbstractScrollbar.prototype._sliderMouseDown = function (e) {
        var _this = this;
        if (e.leftButton) {
            var initialMouseOrthogonalPosition_1 = this._sliderOrthogonalMousePosition(e);
            var initialScrollPosition_1 = this._getScrollPosition();
            var draggingDelta_1 = this._sliderMousePosition(e) - this._scrollbarState.getSliderPosition();
            this.slider.toggleClassName('active', true);
            this._mouseMoveMonitor.startMonitoring(globalMouseMoveMonitor_1.standardMouseMoveMerger, function (mouseMoveData) {
                var mouseOrthogonalPosition = _this._sliderOrthogonalMousePosition(mouseMoveData);
                var mouseOrthogonalDelta = Math.abs(mouseOrthogonalPosition - initialMouseOrthogonalPosition_1);
                // console.log(initialMouseOrthogonalPosition + ' -> ' + mouseOrthogonalPosition + ': ' + mouseOrthogonalDelta);
                if (Platform.isWindows && mouseOrthogonalDelta > MOUSE_DRAG_RESET_DISTANCE) {
                    // The mouse has wondered away from the scrollbar => reset dragging
                    _this.setDesiredScrollPosition(initialScrollPosition_1);
                }
                else {
                    var desiredSliderPosition = _this._sliderMousePosition(mouseMoveData) - draggingDelta_1;
                    _this.setDesiredScrollPosition(_this._scrollbarState.convertSliderPositionToScrollPosition(desiredSliderPosition));
                }
            }, function () {
                _this.slider.toggleClassName('active', false);
                _this._host.onDragEnd();
            });
            e.preventDefault();
            this._host.onDragStart();
        }
    };
    AbstractScrollbar.prototype.validateScrollPosition = function (desiredScrollPosition) {
        return this._scrollbarState.validateScrollPosition(desiredScrollPosition);
    };
    AbstractScrollbar.prototype.setDesiredScrollPosition = function (desiredScrollPosition) {
        desiredScrollPosition = this.validateScrollPosition(desiredScrollPosition);
        var oldScrollPosition = this._getScrollPosition();
        this._setScrollPosition(desiredScrollPosition);
        var newScrollPosition = this._getScrollPosition();
        if (oldScrollPosition !== newScrollPosition) {
            this._onElementScrollPosition(this._getScrollPosition());
            return true;
        }
        return false;
    };
    return AbstractScrollbar;
}(widget_1.Widget));
exports.AbstractScrollbar = AbstractScrollbar;
