/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var browser = require("vs/base/browser/browser");
var styleMutator_1 = require("vs/base/browser/styleMutator");
var viewLineParts_1 = require("vs/editor/common/viewLayout/viewLineParts");
var viewLineRenderer_1 = require("vs/editor/common/viewLayout/viewLineRenderer");
var editorBrowser_1 = require("vs/editor/browser/editorBrowser");
var rangeUtil_1 = require("vs/editor/browser/viewParts/lines/rangeUtil");
var renderingContext_1 = require("vs/editor/common/view/renderingContext");
var ViewLine = (function () {
    function ViewLine(context) {
        this._context = context;
        this._renderWhitespace = this._context.configuration.editor.viewInfo.renderWhitespace;
        this._renderControlCharacters = this._context.configuration.editor.viewInfo.renderControlCharacters;
        this._spaceWidth = this._context.configuration.editor.fontInfo.spaceWidth;
        this._lineHeight = this._context.configuration.editor.lineHeight;
        this._stopRenderingLineAfter = this._context.configuration.editor.viewInfo.stopRenderingLineAfter;
        this._isMaybeInvalid = true;
        this._renderedViewLine = null;
    }
    // --- begin IVisibleLineData
    ViewLine.prototype.getDomNode = function () {
        if (this._renderedViewLine && this._renderedViewLine.domNode) {
            return this._renderedViewLine.domNode.domNode;
        }
        return null;
    };
    ViewLine.prototype.setDomNode = function (domNode) {
        if (this._renderedViewLine) {
            this._renderedViewLine.domNode = styleMutator_1.createFastDomNode(domNode);
        }
        else {
            throw new Error('I have no rendered view line to set the dom node to...');
        }
    };
    ViewLine.prototype.onContentChanged = function () {
        this._isMaybeInvalid = true;
    };
    ViewLine.prototype.onTokensChanged = function () {
        this._isMaybeInvalid = true;
    };
    ViewLine.prototype.onModelDecorationsChanged = function () {
        this._isMaybeInvalid = true;
    };
    ViewLine.prototype.onConfigurationChanged = function (e) {
        if (e.viewInfo.renderWhitespace) {
            this._isMaybeInvalid = true;
            this._renderWhitespace = this._context.configuration.editor.viewInfo.renderWhitespace;
        }
        if (e.viewInfo.renderControlCharacters) {
            this._isMaybeInvalid = true;
            this._renderControlCharacters = this._context.configuration.editor.viewInfo.renderControlCharacters;
        }
        if (e.fontInfo) {
            this._isMaybeInvalid = true;
            this._spaceWidth = this._context.configuration.editor.fontInfo.spaceWidth;
        }
        if (e.lineHeight) {
            this._isMaybeInvalid = true;
            this._lineHeight = this._context.configuration.editor.lineHeight;
        }
        if (e.viewInfo.stopRenderingLineAfter) {
            this._isMaybeInvalid = true;
            this._stopRenderingLineAfter = this._context.configuration.editor.viewInfo.stopRenderingLineAfter;
        }
    };
    ViewLine.prototype.shouldUpdateHTML = function (startLineNumber, lineNumber, inlineDecorations) {
        if (this._isMaybeInvalid === false) {
            // it appears that nothing relevant has changed
            return false;
        }
        this._isMaybeInvalid = false;
        var newLineParts = viewLineParts_1.createLineParts(lineNumber, this._context.model.getLineMinColumn(lineNumber), this._context.model.getLineContent(lineNumber), this._context.model.getTabSize(), this._context.model.getLineTokens(lineNumber), inlineDecorations, this._renderWhitespace);
        var renderLineInput = new viewLineRenderer_1.RenderLineInput(this._context.model.getLineContent(lineNumber), this._context.model.getTabSize(), this._spaceWidth, this._stopRenderingLineAfter, this._renderWhitespace, this._renderControlCharacters, newLineParts);
        if (this._renderedViewLine && this._renderedViewLine.input.equals(renderLineInput)) {
            // no need to do anything, we have the same render input
            return false;
        }
        this._renderedViewLine = createRenderedLine(this._renderedViewLine ? this._renderedViewLine.domNode : null, renderLineInput, this._context.model.mightContainRTL(), viewLineRenderer_1.renderLine(renderLineInput));
        return true;
    };
    ViewLine.prototype.getLineOuterHTML = function (out, lineNumber, deltaTop) {
        out.push('<div lineNumber="');
        out.push(lineNumber.toString());
        out.push('" style="top:');
        out.push(deltaTop.toString());
        out.push('px;height:');
        out.push(this._lineHeight.toString());
        out.push('px;" class="');
        out.push(editorBrowser_1.ClassNames.VIEW_LINE);
        out.push('">');
        out.push(this.getLineInnerHTML(lineNumber));
        out.push('</div>');
    };
    ViewLine.prototype.getLineInnerHTML = function (lineNumber) {
        return this._renderedViewLine.html;
    };
    ViewLine.prototype.layoutLine = function (lineNumber, deltaTop) {
        this._renderedViewLine.domNode.setLineNumber(String(lineNumber));
        this._renderedViewLine.domNode.setTop(deltaTop);
        this._renderedViewLine.domNode.setHeight(this._lineHeight);
    };
    // --- end IVisibleLineData
    ViewLine.prototype.getWidth = function () {
        if (!this._renderedViewLine) {
            return 0;
        }
        return this._renderedViewLine.getWidth();
    };
    ViewLine.prototype.getVisibleRangesForRange = function (startColumn, endColumn, clientRectDeltaLeft, endNode) {
        return this._renderedViewLine.getVisibleRangesForRange(startColumn, endColumn, clientRectDeltaLeft, endNode);
    };
    ViewLine.prototype.getColumnOfNodeOffset = function (lineNumber, spanNode, offset) {
        return this._renderedViewLine.getColumnOfNodeOffset(lineNumber, spanNode, offset);
    };
    return ViewLine;
}());
exports.ViewLine = ViewLine;
/**
 * Every time we render a line, we save what we have rendered in an instance of this class.
 */
var RenderedViewLine = (function () {
    function RenderedViewLine(domNode, renderLineInput, modelContainsRTL, renderLineOutput) {
        this.domNode = domNode;
        this.input = renderLineInput;
        this.html = renderLineOutput.output;
        this._charOffsetInPart = renderLineOutput.charOffsetInPart;
        this._lastRenderedPartIndex = renderLineOutput.lastRenderedPartIndex;
        this._isWhitespaceOnly = renderLineOutput.isWhitespaceOnly;
        this._cachedWidth = -1;
        this._pixelOffsetCache = null;
        if (!modelContainsRTL) {
            this._pixelOffsetCache = [];
            for (var column = 0, maxLineColumn = this.input.lineParts.maxLineColumn; column <= maxLineColumn; column++) {
                this._pixelOffsetCache[column] = -1;
            }
        }
    }
    // --- Reading from the DOM methods
    RenderedViewLine.prototype._getReadingTarget = function () {
        return this.domNode.domNode.firstChild;
    };
    /**
     * Width of the line in pixels
     */
    RenderedViewLine.prototype.getWidth = function () {
        if (this._cachedWidth === -1) {
            this._cachedWidth = this._getReadingTarget().offsetWidth;
        }
        return this._cachedWidth;
    };
    /**
     * Visible ranges for a model range
     */
    RenderedViewLine.prototype.getVisibleRangesForRange = function (startColumn, endColumn, clientRectDeltaLeft, endNode) {
        startColumn = startColumn | 0; // @perf
        endColumn = endColumn | 0; // @perf
        clientRectDeltaLeft = clientRectDeltaLeft | 0; // @perf
        var stopRenderingLineAfter = this.input.stopRenderingLineAfter | 0; // @perf
        if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter && endColumn > stopRenderingLineAfter) {
            // This range is obviously not visible
            return null;
        }
        if (stopRenderingLineAfter !== -1 && startColumn > stopRenderingLineAfter) {
            startColumn = stopRenderingLineAfter;
        }
        if (stopRenderingLineAfter !== -1 && endColumn > stopRenderingLineAfter) {
            endColumn = stopRenderingLineAfter;
        }
        if (this._pixelOffsetCache !== null) {
            // the text is LTR
            var startOffset = this._readPixelOffset(startColumn, clientRectDeltaLeft, endNode);
            if (startOffset === -1) {
                return null;
            }
            var endOffset = this._readPixelOffset(endColumn, clientRectDeltaLeft, endNode);
            if (endOffset === -1) {
                return null;
            }
            return [new renderingContext_1.HorizontalRange(startOffset, endOffset - startOffset)];
        }
        return this._readVisibleRangesForRange(startColumn, endColumn, clientRectDeltaLeft, endNode);
    };
    RenderedViewLine.prototype._readVisibleRangesForRange = function (startColumn, endColumn, clientRectDeltaLeft, endNode) {
        if (startColumn === endColumn) {
            var pixelOffset = this._readPixelOffset(startColumn, clientRectDeltaLeft, endNode);
            if (pixelOffset === -1) {
                return null;
            }
            else {
                return [new renderingContext_1.HorizontalRange(pixelOffset, 0)];
            }
        }
        else {
            return this._readRawVisibleRangesForRange(startColumn, endColumn, clientRectDeltaLeft, endNode);
        }
    };
    RenderedViewLine.prototype._readPixelOffset = function (column, clientRectDeltaLeft, endNode) {
        if (this._pixelOffsetCache !== null) {
            // the text is LTR
            var cachedPixelOffset = this._pixelOffsetCache[column];
            if (cachedPixelOffset !== -1) {
                return cachedPixelOffset;
            }
            var result = this._actualReadPixelOffset(column, clientRectDeltaLeft, endNode);
            this._pixelOffsetCache[column] = result;
            return result;
        }
        return this._actualReadPixelOffset(column, clientRectDeltaLeft, endNode);
    };
    RenderedViewLine.prototype._actualReadPixelOffset = function (column, clientRectDeltaLeft, endNode) {
        if (this._charOffsetInPart.length === 0) {
            // This line is empty
            return 0;
        }
        if (column === this._charOffsetInPart.length && this._isWhitespaceOnly) {
            // This branch helps in the case of whitespace only lines which have a width set
            return this.getWidth();
        }
        var partIndex = findIndexInArrayWithMax(this.input.lineParts, column - 1, this._lastRenderedPartIndex);
        var charOffsetInPart = this._charOffsetInPart[column - 1];
        var r = rangeUtil_1.RangeUtil.readHorizontalRanges(this._getReadingTarget(), partIndex, charOffsetInPart, partIndex, charOffsetInPart, clientRectDeltaLeft, this._getScaleRatio(), endNode);
        if (!r || r.length === 0) {
            return -1;
        }
        return r[0].left;
    };
    RenderedViewLine.prototype._readRawVisibleRangesForRange = function (startColumn, endColumn, clientRectDeltaLeft, endNode) {
        if (startColumn === 1 && endColumn === this._charOffsetInPart.length) {
            // This branch helps IE with bidi text & gives a performance boost to other browsers when reading visible ranges for an entire line
            return [new renderingContext_1.HorizontalRange(0, this.getWidth())];
        }
        var startPartIndex = findIndexInArrayWithMax(this.input.lineParts, startColumn - 1, this._lastRenderedPartIndex);
        var startCharOffsetInPart = this._charOffsetInPart[startColumn - 1];
        var endPartIndex = findIndexInArrayWithMax(this.input.lineParts, endColumn - 1, this._lastRenderedPartIndex);
        var endCharOffsetInPart = this._charOffsetInPart[endColumn - 1];
        return rangeUtil_1.RangeUtil.readHorizontalRanges(this._getReadingTarget(), startPartIndex, startCharOffsetInPart, endPartIndex, endCharOffsetInPart, clientRectDeltaLeft, this._getScaleRatio(), endNode);
    };
    RenderedViewLine.prototype._getScaleRatio = function () {
        return 1;
    };
    /**
     * Returns the column for the text found at a specific offset inside a rendered dom node
     */
    RenderedViewLine.prototype.getColumnOfNodeOffset = function (lineNumber, spanNode, offset) {
        var spanNodeTextContentLength = spanNode.textContent.length;
        var spanIndex = -1;
        while (spanNode) {
            spanNode = spanNode.previousSibling;
            spanIndex++;
        }
        var lineParts = this.input.lineParts.parts;
        return viewLineParts_1.getColumnOfLinePartOffset(this.input.stopRenderingLineAfter, lineParts, this.input.lineParts.maxLineColumn, this._charOffsetInPart, spanIndex, spanNodeTextContentLength, offset);
    };
    return RenderedViewLine;
}());
var IERenderedViewLine = (function (_super) {
    __extends(IERenderedViewLine, _super);
    function IERenderedViewLine() {
        return _super.apply(this, arguments) || this;
    }
    IERenderedViewLine.prototype._getScaleRatio = function () {
        return screen.logicalXDPI / screen.deviceXDPI;
    };
    return IERenderedViewLine;
}(RenderedViewLine));
var WebKitRenderedViewLine = (function (_super) {
    __extends(WebKitRenderedViewLine, _super);
    function WebKitRenderedViewLine() {
        return _super.apply(this, arguments) || this;
    }
    WebKitRenderedViewLine.prototype._readVisibleRangesForRange = function (startColumn, endColumn, clientRectDeltaLeft, endNode) {
        var output = _super.prototype._readVisibleRangesForRange.call(this, startColumn, endColumn, clientRectDeltaLeft, endNode);
        if (!output || output.length === 0 || startColumn === endColumn || (startColumn === 1 && endColumn === this._charOffsetInPart.length)) {
            return output;
        }
        // WebKit is buggy and returns an expanded range (to contain words in some cases)
        // The last client rect is enlarged (I think)
        // This is an attempt to patch things up
        // Find position of previous column
        var beforeEndPixelOffset = this._readPixelOffset(endColumn - 1, clientRectDeltaLeft, endNode);
        // Find position of last column
        var endPixelOffset = this._readPixelOffset(endColumn, clientRectDeltaLeft, endNode);
        if (beforeEndPixelOffset !== -1 && endPixelOffset !== -1) {
            var isLTR = (beforeEndPixelOffset <= endPixelOffset);
            var lastRange = output[output.length - 1];
            if (isLTR && lastRange.left < endPixelOffset) {
                // Trim down the width of the last visible range to not go after the last column's position
                lastRange.width = endPixelOffset - lastRange.left;
            }
        }
        return output;
    };
    return WebKitRenderedViewLine;
}(RenderedViewLine));
function findIndexInArrayWithMax(lineParts, desiredIndex, maxResult) {
    var r = lineParts.findIndexOfOffset(desiredIndex);
    return r <= maxResult ? r : maxResult;
}
var createRenderedLine = (function () {
    if (window.screen && window.screen.deviceXDPI && (navigator.userAgent.indexOf('Trident/6.0') >= 0 || navigator.userAgent.indexOf('Trident/5.0') >= 0)) {
        // IE11 doesn't need the screen.logicalXDPI / screen.deviceXDPI ratio multiplication
        // for TextRange.getClientRects() anymore
        return createIERenderedLine;
    }
    else if (browser.isWebKit) {
        return createWebKitRenderedLine;
    }
    return createNormalRenderedLine;
})();
function createIERenderedLine(domNode, renderLineInput, modelContainsRTL, renderLineOutput) {
    return new IERenderedViewLine(domNode, renderLineInput, modelContainsRTL, renderLineOutput);
}
function createWebKitRenderedLine(domNode, renderLineInput, modelContainsRTL, renderLineOutput) {
    return new WebKitRenderedViewLine(domNode, renderLineInput, modelContainsRTL, renderLineOutput);
}
function createNormalRenderedLine(domNode, renderLineInput, modelContainsRTL, renderLineOutput) {
    return new RenderedViewLine(domNode, renderLineInput, modelContainsRTL, renderLineOutput);
}
