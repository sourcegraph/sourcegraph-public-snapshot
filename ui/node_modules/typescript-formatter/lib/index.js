"use strict";
var formatter_1 = require("./formatter");
var utils_1 = require("./utils");
exports.parseJSON = utils_1.parseJSON;
var fs = require("fs");
var base_1 = require("./provider/base");
var tsconfigjson_1 = require("./provider/tsconfigjson");
var editorconfig_1 = require("./provider/editorconfig");
var tslintjson_1 = require("./provider/tslintjson");
var Processor = (function () {
    function Processor() {
        this.optionModifiers = [];
        this.postProcessors = [];
    }
    Processor.prototype.addOptionModify = function (modifier) {
        this.optionModifiers.push(modifier);
    };
    Processor.prototype.processFormatCodeOptions = function (fileName, opts, formatSettings) {
        var optionModifiers = this.optionModifiers.slice();
        var next = function (formatSettings) {
            if (optionModifiers.length === 0) {
                return Promise.resolve(formatSettings);
            }
            var modifier = optionModifiers.shift();
            var ret = modifier(fileName, opts, formatSettings);
            return Promise.resolve(ret).then(function (formatSettings) { return next(formatSettings); });
        };
        return next(formatSettings);
    };
    Processor.prototype.addPostProcess = function (postProcessor) {
        this.postProcessors.push(postProcessor);
    };
    Processor.prototype.postProcess = function (fileName, formattedCode, opts, formatSettings) {
        var postProcessors = this.postProcessors.slice();
        var next = function (formattedCode) {
            if (postProcessors.length === 0) {
                return Promise.resolve(formattedCode);
            }
            var processor = postProcessors.shift();
            var ret = processor(fileName, formattedCode, opts, formatSettings);
            return Promise.resolve(ret).then(function (formattedCode) { return next(formattedCode); });
        };
        return next(formattedCode);
    };
    return Processor;
}());
function processFiles(files, opts) {
    var resultMap = {};
    var promises = files.map(function (fileName) {
        if (!fs.existsSync(fileName)) {
            var result = {
                fileName: fileName,
                settings: null,
                message: fileName + " does not exist. process abort.\n",
                error: true,
                src: "",
                dest: "",
            };
            return Promise.resolve(result);
        }
        var content = fs.readFileSync(fileName).toString();
        return processString(fileName, content, opts);
    });
    return Promise.all(promises).then(function (resultList) {
        resultList.forEach(function (result) {
            resultMap[result.fileName] = result;
        });
        return resultMap;
    });
}
exports.processFiles = processFiles;
function processStream(fileName, input, opts) {
    input.setEncoding("utf8");
    var promise = new Promise(function (resolve, _reject) {
        var fragment = "";
        input.on("data", function (chunk) {
            fragment += chunk;
        });
        input.on("end", function () {
            resolve(fragment);
        });
    });
    return promise.then(function (content) { return processString(fileName, content, opts); });
}
exports.processStream = processStream;
function processString(fileName, content, opts) {
    var processor = new Processor();
    if (opts.tsfmt) {
        processor.addOptionModify(base_1.default);
    }
    if (opts.tsconfig) {
        processor.addOptionModify(tsconfigjson_1.default);
    }
    if (opts.editorconfig) {
        processor.addOptionModify(editorconfig_1.default);
        processor.addPostProcess(editorconfig_1.postProcess);
    }
    if (opts.tslint) {
        processor.addOptionModify(tslintjson_1.default);
        processor.addPostProcess(tslintjson_1.postProcess);
    }
    processor.addPostProcess(function (_fileName, formattedCode, _opts, formatSettings) {
        // replace newline code. maybe NewLineCharacter params affect to only "new" newline by language service.
        formattedCode = formattedCode.replace(/\r?\n/g, formatSettings.newLineCharacter || "\n");
        return Promise.resolve(formattedCode);
    });
    var formatSettings = utils_1.createDefaultFormatCodeSettings();
    return processor.processFormatCodeOptions(fileName, opts, formatSettings)
        .then(function (formatSettings) {
        var formattedCode = formatter_1.default(fileName, content, formatSettings);
        // apply post process logic
        return processor.postProcess(fileName, formattedCode, opts, formatSettings);
    }).then(function (formattedCode) {
        var message = "";
        var error = false;
        if (opts && opts.verify) {
            if (content !== formattedCode) {
                message = fileName + " is not formatted\n";
                error = true;
            }
        }
        else if (opts && opts.replace) {
            if (content !== formattedCode) {
                fs.writeFileSync(fileName, formattedCode);
                message = "replaced " + fileName + "\n";
            }
        }
        else if (opts && !opts.dryRun) {
            message = formattedCode;
        }
        var result = {
            fileName: fileName,
            settings: formatSettings,
            message: message,
            error: error,
            src: content,
            dest: formattedCode,
        };
        return Promise.resolve(result);
    });
}
exports.processString = processString;
//# sourceMappingURL=index.js.map