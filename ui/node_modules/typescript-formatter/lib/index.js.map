{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from \"typescript\";\nimport formatter from \"./formatter\";\nimport { createDefaultFormatCodeSettings, parseJSON } from \"./utils\";\n\nexport { parseJSON };\n\nimport * as fs from \"fs\";\n\nimport base from \"./provider/base\";\nimport tsconfigjson from \"./provider/tsconfigjson\";\nimport editorconfig, { postProcess as editorconfigPostProcess } from \"./provider/editorconfig\";\nimport tslintjson, { postProcess as tslintPostProcess } from \"./provider/tslintjson\";\n\nexport interface Options {\n    dryRun?: boolean;\n    verbose?: boolean;\n    baseDir?: string;\n    replace: boolean;\n    verify: boolean;\n    tsconfig: boolean;\n    tslint: boolean;\n    editorconfig: boolean;\n    tsfmt: boolean;\n}\n\nexport interface OptionModifier {\n    (fileName: string, opts: Options, formatSettings: ts.FormatCodeSettings): ts.FormatCodeSettings | Promise<ts.FormatCodeSettings>;\n}\n\nexport interface PostProcessor {\n    (fileName: string, formattedCode: string, opts: Options, formatSettings: ts.FormatCodeSettings): string | Promise<string>;\n}\n\nclass Processor {\n    optionModifiers: OptionModifier[] = [];\n    postProcessors: PostProcessor[] = [];\n\n    addOptionModify(modifier: OptionModifier) {\n        this.optionModifiers.push(modifier);\n    }\n\n    processFormatCodeOptions(fileName: string, opts: Options, formatSettings: ts.FormatCodeSettings): Promise<ts.FormatCodeSettings> {\n        let optionModifiers = [...this.optionModifiers];\n\n        let next = (formatSettings: ts.FormatCodeSettings): Promise<ts.FormatCodeSettings> => {\n            if (optionModifiers.length === 0) {\n                return Promise.resolve(formatSettings);\n            }\n            let modifier = optionModifiers.shift() !;\n            let ret = modifier(fileName, opts, formatSettings);\n            return Promise.resolve(ret).then(formatSettings => next(formatSettings));\n        };\n\n        return next(formatSettings);\n    }\n\n    addPostProcess(postProcessor: PostProcessor) {\n        this.postProcessors.push(postProcessor);\n    }\n\n    postProcess(fileName: string, formattedCode: string, opts: Options, formatSettings: ts.FormatCodeSettings): Promise<string> {\n        let postProcessors = [...this.postProcessors];\n\n        let next = (formattedCode: string): Promise<string> => {\n            if (postProcessors.length === 0) {\n                return Promise.resolve(formattedCode);\n            }\n            let processor = postProcessors.shift() !;\n            let ret = processor(fileName, formattedCode, opts, formatSettings);\n            return Promise.resolve(ret).then(formattedCode => next(formattedCode));\n        };\n\n        return next(formattedCode);\n    }\n}\n\nexport interface ResultMap {\n    [fileName: string]: Result;\n}\n\nexport interface Result {\n    fileName: string;\n    settings: ts.FormatCodeSettings | null;\n    message: string;\n    error: boolean;\n    src: string;\n    dest: string;\n}\n\nexport function processFiles(files: string[], opts: Options): Promise<ResultMap> {\n\n    let resultMap: ResultMap = {};\n    let promises = files.map(fileName => {\n        if (!fs.existsSync(fileName)) {\n            let result: Result = {\n                fileName: fileName,\n                settings: null,\n                message: `${fileName} does not exist. process abort.\\n`,\n                error: true,\n                src: \"\",\n                dest: \"\",\n            };\n            return Promise.resolve(result);\n        }\n\n        let content = fs.readFileSync(fileName).toString();\n        return processString(fileName, content, opts);\n    });\n    return Promise.all<Result>(promises).then(resultList => {\n        resultList.forEach(result => {\n            resultMap[result.fileName] = result;\n        });\n        return resultMap;\n    });\n}\n\nexport function processStream(fileName: string, input: NodeJS.ReadableStream, opts: Options): Promise<Result> {\n\n    input.setEncoding(\"utf8\");\n\n    let promise = new Promise<string>((resolve, _reject) => {\n        let fragment = \"\";\n        input.on(\"data\", (chunk: string) => {\n            fragment += chunk;\n        });\n\n        input.on(\"end\", () => {\n            resolve(fragment);\n        });\n    });\n    return promise.then(content => processString(fileName, content, opts));\n}\n\nexport function processString(fileName: string, content: string, opts: Options): Promise<Result> {\n\n    let processor = new Processor();\n    if (opts.tsfmt) {\n        processor.addOptionModify(base);\n    }\n    if (opts.tsconfig) {\n        processor.addOptionModify(tsconfigjson);\n    }\n    if (opts.editorconfig) {\n        processor.addOptionModify(editorconfig);\n        processor.addPostProcess(editorconfigPostProcess);\n    }\n    if (opts.tslint) {\n        processor.addOptionModify(tslintjson);\n        processor.addPostProcess(tslintPostProcess);\n    }\n    processor.addPostProcess((_fileName: string, formattedCode: string, _opts: Options, formatSettings: ts.FormatCodeSettings) => {\n        // replace newline code. maybe NewLineCharacter params affect to only \"new\" newline by language service.\n        formattedCode = formattedCode.replace(/\\r?\\n/g, formatSettings.newLineCharacter || \"\\n\");\n        return Promise.resolve(formattedCode);\n    });\n\n    let formatSettings = createDefaultFormatCodeSettings();\n    return processor.processFormatCodeOptions(fileName, opts, formatSettings)\n        .then(formatSettings => {\n            let formattedCode = formatter(fileName, content, formatSettings);\n\n            // apply post process logic\n            return processor.postProcess(fileName, formattedCode, opts, formatSettings);\n\n        }).then(formattedCode => {\n            let message = \"\";\n            let error = false;\n            if (opts && opts.verify) {\n                if (content !== formattedCode) {\n                    message = `${fileName} is not formatted\\n`;\n                    error = true;\n                }\n            } else if (opts && opts.replace) {\n                if (content !== formattedCode) {\n                    fs.writeFileSync(fileName, formattedCode);\n                    message = `replaced ${fileName}\\n`;\n                }\n            } else if (opts && !opts.dryRun) {\n                message = formattedCode;\n            }\n\n            let result: Result = {\n                fileName: fileName,\n                settings: formatSettings,\n                message: message,\n                error: error,\n                src: content,\n                dest: formattedCode,\n            };\n            return Promise.resolve(result);\n        });\n}\n"]}