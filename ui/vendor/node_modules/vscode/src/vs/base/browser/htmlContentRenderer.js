/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var DOM = require("vs/base/browser/dom");
var idGenerator_1 = require("vs/base/common/idGenerator");
var strings_1 = require("vs/base/common/strings");
var winjs_base_1 = require("vs/base/common/winjs.base");
var htmlContent_1 = require("vs/base/common/htmlContent");
var marked_1 = require("vs/base/common/marked/marked");
function renderMarkedString(markedString, options) {
    if (options === void 0) { options = {}; }
    var htmlContentElement = typeof markedString === 'string' ? { markdown: markedString } : { code: markedString };
    return renderHtml(htmlContentElement, options);
}
exports.renderMarkedString = renderMarkedString;
/**
 * Create html nodes for the given content element.
 *
 * @param content a html element description
 * @param actionCallback a callback function for any action links in the string. Argument is the zero-based index of the clicked action.
 */
function renderHtml(content, options) {
    if (options === void 0) { options = {}; }
    if (typeof content === 'string') {
        return _renderHtml({ isText: true, text: content }, options);
    }
    else if (Array.isArray(content)) {
        return _renderHtml({ children: content }, options);
    }
    else if (content) {
        return _renderHtml(content, options);
    }
}
exports.renderHtml = renderHtml;
function _renderHtml(content, options) {
    if (options === void 0) { options = {}; }
    var codeBlockRenderer = options.codeBlockRenderer, actionCallback = options.actionCallback;
    if (content.isText) {
        return document.createTextNode(content.text);
    }
    var tagName = getSafeTagName(content.tagName) || 'div';
    var element = document.createElement(tagName);
    if (content.className) {
        element.className = content.className;
    }
    if (content.text) {
        element.textContent = content.text;
    }
    if (content.style) {
        element.setAttribute('style', content.style);
    }
    if (content.customStyle) {
        Object.keys(content.customStyle).forEach(function (key) {
            element.style[key] = content.customStyle[key];
        });
    }
    if (content.children) {
        content.children.forEach(function (child) {
            element.appendChild(renderHtml(child, options));
        });
    }
    if (content.formattedText) {
        renderFormattedText(element, parseFormattedText(content.formattedText), actionCallback);
    }
    if (content.code && codeBlockRenderer) {
        // this is sort of legacy given that we have full
        // support for markdown. Turn this into markdown
        // and continue
        var _a = content.code, language = _a.language, value = _a.value;
        content.markdown = '```' + language + '\n' + value + '\n```';
    }
    if (content.markdown) {
        // signal to code-block render that the
        // element has been created
        var signalInnerHTML_1;
        var withInnerHTML_1 = new winjs_base_1.TPromise(function (c) { return signalInnerHTML_1 = c; });
        var renderer = new marked_1.marked.Renderer();
        renderer.image = function (href, title, text) {
            var dimensions = [];
            if (href) {
                var splitted = href.split('|').map(function (s) { return s.trim(); });
                href = splitted[0];
                var parameters = splitted[1];
                if (parameters) {
                    var heightFromParams = /height=(\d+)/.exec(parameters);
                    var widthFromParams = /width=(\d+)/.exec(parameters);
                    var height = (heightFromParams && heightFromParams[1]);
                    var width = (widthFromParams && widthFromParams[1]);
                    var widthIsFinite = isFinite(parseInt(width));
                    var heightIsFinite = isFinite(parseInt(height));
                    if (widthIsFinite) {
                        dimensions.push("width=\"" + width + "\"");
                    }
                    if (heightIsFinite) {
                        dimensions.push("height=\"" + height + "\"");
                    }
                }
            }
            var attributes = [];
            if (href) {
                attributes.push("src=\"" + href + "\"");
            }
            if (text) {
                attributes.push("alt=\"" + text + "\"");
            }
            if (title) {
                attributes.push("title=\"" + title + "\"");
            }
            if (dimensions.length) {
                attributes = attributes.concat(dimensions);
            }
            return '<img ' + attributes.join(' ') + '>';
        };
        renderer.link = function (href, title, text) {
            // Remove markdown escapes. Workaround for https://github.com/chjj/marked/issues/829
            if (href === text) {
                text = htmlContent_1.removeMarkdownEscapes(text);
            }
            title = htmlContent_1.removeMarkdownEscapes(title);
            href = htmlContent_1.removeMarkdownEscapes(href);
            return "<a href=\"#\" data-href=\"" + href + "\" title=\"" + (title || text) + "\">" + text + "</a>";
        };
        renderer.paragraph = function (text) {
            return "<p>" + text + "</p>";
        };
        if (options.codeBlockRenderer) {
            renderer.code = function (code, lang) {
                var value = options.codeBlockRenderer(lang, code);
                if (typeof value === 'string') {
                    return value;
                }
                if (winjs_base_1.TPromise.is(value)) {
                    // when code-block rendering is async we return sync
                    // but update the node with the real result later.
                    var id_1 = idGenerator_1.defaultGenerator.nextId();
                    winjs_base_1.TPromise.join([value, withInnerHTML_1]).done(function (values) {
                        var strValue = values[0];
                        var span = element.querySelector("span[data-code=\"" + id_1 + "\"]");
                        if (span) {
                            span.innerHTML = strValue;
                        }
                    }, function (err) {
                        // ignore
                    });
                    return "<span data-code=\"" + id_1 + "\">" + strings_1.escape(code) + "</span>";
                }
                return code;
            };
        }
        if (options.actionCallback) {
            DOM.addStandardDisposableListener(element, 'click', function (event) {
                if (event.target.tagName === 'A') {
                    var href = event.target.dataset['href'];
                    if (href) {
                        options.actionCallback(href, event);
                    }
                }
            });
        }
        element.innerHTML = marked_1.marked(content.markdown, {
            sanitize: true,
            renderer: renderer
        });
        signalInnerHTML_1();
    }
    return element;
}
var SAFE_TAG_NAMES = {
    a: true,
    b: true,
    blockquote: true,
    code: true,
    del: true,
    dd: true,
    div: true,
    dl: true,
    dt: true,
    em: true,
    h1h2h3i: true,
    img: true,
    kbd: true,
    li: true,
    ol: true,
    p: true,
    pre: true,
    s: true,
    span: true,
    sup: true,
    sub: true,
    strong: true,
    strike: true,
    ul: true,
    br: true,
    hr: true,
};
function getSafeTagName(tagName) {
    if (!tagName) {
        return null;
    }
    if (SAFE_TAG_NAMES.hasOwnProperty(tagName)) {
        return tagName;
    }
    return null;
}
// --- formatted string parsing
var StringStream = (function () {
    function StringStream(source) {
        this.source = source;
        this.index = 0;
    }
    StringStream.prototype.eos = function () {
        return this.index >= this.source.length;
    };
    StringStream.prototype.next = function () {
        var next = this.peek();
        this.advance();
        return next;
    };
    StringStream.prototype.peek = function () {
        return this.source[this.index];
    };
    StringStream.prototype.advance = function () {
        this.index++;
    };
    return StringStream;
}());
var FormatType;
(function (FormatType) {
    FormatType[FormatType["Invalid"] = 0] = "Invalid";
    FormatType[FormatType["Root"] = 1] = "Root";
    FormatType[FormatType["Text"] = 2] = "Text";
    FormatType[FormatType["Bold"] = 3] = "Bold";
    FormatType[FormatType["Italics"] = 4] = "Italics";
    FormatType[FormatType["Action"] = 5] = "Action";
    FormatType[FormatType["ActionClose"] = 6] = "ActionClose";
    FormatType[FormatType["NewLine"] = 7] = "NewLine";
})(FormatType || (FormatType = {}));
function renderFormattedText(element, treeNode, actionCallback) {
    var child;
    if (treeNode.type === 2 /* Text */) {
        child = document.createTextNode(treeNode.content);
    }
    else if (treeNode.type === 3 /* Bold */) {
        child = document.createElement('b');
    }
    else if (treeNode.type === 4 /* Italics */) {
        child = document.createElement('i');
    }
    else if (treeNode.type === 5 /* Action */) {
        var a = document.createElement('a');
        a.href = '#';
        DOM.addStandardDisposableListener(a, 'click', function (event) {
            actionCallback(String(treeNode.index), event);
        });
        child = a;
    }
    else if (treeNode.type === 7 /* NewLine */) {
        child = document.createElement('br');
    }
    else if (treeNode.type === 1 /* Root */) {
        child = element;
    }
    if (element !== child) {
        element.appendChild(child);
    }
    if (Array.isArray(treeNode.children)) {
        treeNode.children.forEach(function (nodeChild) {
            renderFormattedText(child, nodeChild, actionCallback);
        });
    }
}
function parseFormattedText(content) {
    var root = {
        type: 1 /* Root */,
        children: []
    };
    var actionItemIndex = 0;
    var current = root;
    var stack = [];
    var stream = new StringStream(content);
    while (!stream.eos()) {
        var next = stream.next();
        var isEscapedFormatType = (next === '\\' && formatTagType(stream.peek()) !== 0 /* Invalid */);
        if (isEscapedFormatType) {
            next = stream.next(); // unread the backslash if it escapes a format tag type
        }
        if (!isEscapedFormatType && isFormatTag(next) && next === stream.peek()) {
            stream.advance();
            if (current.type === 2 /* Text */) {
                current = stack.pop();
            }
            var type = formatTagType(next);
            if (current.type === type || (current.type === 5 /* Action */ && type === 6 /* ActionClose */)) {
                current = stack.pop();
            }
            else {
                var newCurrent = {
                    type: type,
                    children: []
                };
                if (type === 5 /* Action */) {
                    newCurrent.index = actionItemIndex;
                    actionItemIndex++;
                }
                current.children.push(newCurrent);
                stack.push(current);
                current = newCurrent;
            }
        }
        else if (next === '\n') {
            if (current.type === 2 /* Text */) {
                current = stack.pop();
            }
            current.children.push({
                type: 7 /* NewLine */
            });
        }
        else {
            if (current.type !== 2 /* Text */) {
                var textCurrent = {
                    type: 2 /* Text */,
                    content: next
                };
                current.children.push(textCurrent);
                stack.push(current);
                current = textCurrent;
            }
            else {
                current.content += next;
            }
        }
    }
    if (current.type === 2 /* Text */) {
        current = stack.pop();
    }
    if (stack.length) {
    }
    return root;
}
function isFormatTag(char) {
    return formatTagType(char) !== 0 /* Invalid */;
}
function formatTagType(char) {
    switch (char) {
        case '*':
            return 3 /* Bold */;
        case '_':
            return 4 /* Italics */;
        case '[':
            return 5 /* Action */;
        case ']':
            return 6 /* ActionClose */;
        default:
            return 0 /* Invalid */;
    }
}
