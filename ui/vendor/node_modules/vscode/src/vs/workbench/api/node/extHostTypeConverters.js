/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var severity_1 = require("vs/base/common/severity");
var types = require("./extHostTypes");
var editor_1 = require("vs/platform/editor/common/editor");
var uri_1 = require("vs/base/common/uri");
var textfiles_1 = require("vs/workbench/services/textfile/common/textfiles");
function toSelection(selection) {
    var selectionStartLineNumber = selection.selectionStartLineNumber, selectionStartColumn = selection.selectionStartColumn, positionLineNumber = selection.positionLineNumber, positionColumn = selection.positionColumn;
    var start = new types.Position(selectionStartLineNumber - 1, selectionStartColumn - 1);
    var end = new types.Position(positionLineNumber - 1, positionColumn - 1);
    return new types.Selection(start, end);
}
exports.toSelection = toSelection;
function fromSelection(selection) {
    var anchor = selection.anchor, active = selection.active;
    return {
        selectionStartLineNumber: anchor.line + 1,
        selectionStartColumn: anchor.character + 1,
        positionLineNumber: active.line + 1,
        positionColumn: active.character + 1
    };
}
exports.fromSelection = fromSelection;
function fromRange(range) {
    var start = range.start, end = range.end;
    return {
        startLineNumber: start.line + 1,
        startColumn: start.character + 1,
        endLineNumber: end.line + 1,
        endColumn: end.character + 1
    };
}
exports.fromRange = fromRange;
function toRange(range) {
    var startLineNumber = range.startLineNumber, startColumn = range.startColumn, endLineNumber = range.endLineNumber, endColumn = range.endColumn;
    return new types.Range(startLineNumber - 1, startColumn - 1, endLineNumber - 1, endColumn - 1);
}
exports.toRange = toRange;
function toPosition(position) {
    return new types.Position(position.lineNumber - 1, position.column - 1);
}
exports.toPosition = toPosition;
function fromPosition(position) {
    return { lineNumber: position.line + 1, column: position.character + 1 };
}
exports.fromPosition = fromPosition;
function fromDiagnosticSeverity(value) {
    switch (value) {
        case types.DiagnosticSeverity.Error:
            return severity_1.default.Error;
        case types.DiagnosticSeverity.Warning:
            return severity_1.default.Warning;
        case types.DiagnosticSeverity.Information:
            return severity_1.default.Info;
        case types.DiagnosticSeverity.Hint:
            return severity_1.default.Ignore;
    }
    return severity_1.default.Error;
}
exports.fromDiagnosticSeverity = fromDiagnosticSeverity;
function toDiagnosticSeverty(value) {
    switch (value) {
        case severity_1.default.Info:
            return types.DiagnosticSeverity.Information;
        case severity_1.default.Warning:
            return types.DiagnosticSeverity.Warning;
        case severity_1.default.Error:
            return types.DiagnosticSeverity.Error;
        case severity_1.default.Ignore:
            return types.DiagnosticSeverity.Hint;
    }
    return types.DiagnosticSeverity.Error;
}
exports.toDiagnosticSeverty = toDiagnosticSeverty;
function fromViewColumn(column) {
    var editorColumn = editor_1.Position.ONE;
    if (typeof column !== 'number') {
    }
    else if (column === types.ViewColumn.Two) {
        editorColumn = editor_1.Position.TWO;
    }
    else if (column === types.ViewColumn.Three) {
        editorColumn = editor_1.Position.THREE;
    }
    return editorColumn;
}
exports.fromViewColumn = fromViewColumn;
function toViewColumn(position) {
    if (typeof position !== 'number') {
        return;
    }
    if (position === editor_1.Position.ONE) {
        return types.ViewColumn.One;
    }
    else if (position === editor_1.Position.TWO) {
        return types.ViewColumn.Two;
    }
    else if (position === editor_1.Position.THREE) {
        return types.ViewColumn.Three;
    }
}
exports.toViewColumn = toViewColumn;
function isDecorationOptions(something) {
    return (typeof something.range !== 'undefined');
}
function isDecorationOptionsArr(something) {
    if (something.length === 0) {
        return true;
    }
    return isDecorationOptions(something[0]) ? true : false;
}
function fromRangeOrRangeWithMessage(ranges) {
    if (isDecorationOptionsArr(ranges)) {
        return ranges.map(function (r) {
            return {
                range: fromRange(r.range),
                hoverMessage: r.hoverMessage,
                renderOptions: r.renderOptions
            };
        });
    }
    else {
        return ranges.map(function (r) {
            return {
                range: fromRange(r)
            };
        });
    }
}
exports.fromRangeOrRangeWithMessage = fromRangeOrRangeWithMessage;
exports.TextEdit = {
    from: function (edit) {
        return {
            text: edit.newText,
            range: fromRange(edit.range)
        };
    },
    to: function (edit) {
        return new types.TextEdit(toRange(edit.range), edit.text);
    }
};
var SymbolInformation;
(function (SymbolInformation) {
    function fromOutlineEntry(entry) {
        return new types.SymbolInformation(entry.name, entry.kind, toRange(entry.location.range), entry.location.uri, entry.containerName);
    }
    SymbolInformation.fromOutlineEntry = fromOutlineEntry;
    function toOutlineEntry(symbol) {
        return {
            name: symbol.name,
            kind: symbol.kind,
            containerName: symbol.containerName,
            location: {
                uri: symbol.location.uri,
                range: fromRange(symbol.location.range)
            }
        };
    }
    SymbolInformation.toOutlineEntry = toOutlineEntry;
})(SymbolInformation = exports.SymbolInformation || (exports.SymbolInformation = {}));
function fromSymbolInformation(info) {
    return {
        name: info.name,
        type: types.SymbolKind[info.kind || types.SymbolKind.Property].toLowerCase(),
        containerName: info.containerName,
        range: info.location && fromRange(info.location.range),
        resource: info.location && info.location.uri,
    };
}
exports.fromSymbolInformation = fromSymbolInformation;
function toSymbolInformation(bearing) {
    return new types.SymbolInformation(bearing.name, types.SymbolKind[bearing.type.charAt(0).toUpperCase() + bearing.type.substr(1)], bearing.containerName, new types.Location(bearing.resource, toRange(bearing.range)));
}
exports.toSymbolInformation = toSymbolInformation;
exports.location = {
    from: function (value) {
        return {
            range: value.range && fromRange(value.range),
            uri: value.uri
        };
    },
    to: function (value) {
        return new types.Location(value.uri, toRange(value.range));
    }
};
function fromHover(hover) {
    return {
        range: fromRange(hover.range),
        contents: hover.contents
    };
}
exports.fromHover = fromHover;
function toHover(info) {
    return new types.Hover(info.contents, toRange(info.range));
}
exports.toHover = toHover;
function toDocumentHighlight(occurrence) {
    return new types.DocumentHighlight(toRange(occurrence.range), occurrence.kind);
}
exports.toDocumentHighlight = toDocumentHighlight;
exports.CompletionItemKind = {
    from: function (kind) {
        switch (kind) {
            case types.CompletionItemKind.Method: return 'method';
            case types.CompletionItemKind.Function: return 'function';
            case types.CompletionItemKind.Constructor: return 'constructor';
            case types.CompletionItemKind.Field: return 'field';
            case types.CompletionItemKind.Variable: return 'variable';
            case types.CompletionItemKind.Class: return 'class';
            case types.CompletionItemKind.Interface: return 'interface';
            case types.CompletionItemKind.Module: return 'module';
            case types.CompletionItemKind.Property: return 'property';
            case types.CompletionItemKind.Unit: return 'unit';
            case types.CompletionItemKind.Value: return 'value';
            case types.CompletionItemKind.Enum: return 'enum';
            case types.CompletionItemKind.Keyword: return 'keyword';
            case types.CompletionItemKind.Snippet: return 'snippet';
            case types.CompletionItemKind.Text: return 'text';
            case types.CompletionItemKind.Color: return 'color';
            case types.CompletionItemKind.File: return 'file';
            case types.CompletionItemKind.Reference: return 'reference';
        }
        return 'property';
    },
    to: function (type) {
        if (!type) {
            return types.CompletionItemKind.Property;
        }
        else {
            return types.CompletionItemKind[type.charAt(0).toUpperCase() + type.substr(1)];
        }
    }
};
var Suggest;
(function (Suggest) {
    function to(position, suggestion) {
        var result = new types.CompletionItem(suggestion.label);
        result.insertText = suggestion.insertText;
        result.kind = exports.CompletionItemKind.to(suggestion.type);
        result.detail = suggestion.detail;
        result.documentation = suggestion.documentation;
        result.sortText = suggestion.sortText;
        result.filterText = suggestion.filterText;
        // 'overwrite[Before|After]'-logic
        var overwriteBefore = (typeof suggestion.overwriteBefore === 'number') ? suggestion.overwriteBefore : 0;
        var startPosition = new types.Position(position.line, Math.max(0, position.character - overwriteBefore));
        var endPosition = position;
        if (typeof suggestion.overwriteAfter === 'number') {
            endPosition = new types.Position(position.line, position.character + suggestion.overwriteAfter);
        }
        result.range = new types.Range(startPosition, endPosition);
        // 'inserText'-logic
        if (suggestion.snippetType === 'textmate') {
            result.insertText = new types.SnippetString(suggestion.insertText);
        }
        else {
            result.insertText = suggestion.insertText;
            result.textEdit = new types.TextEdit(result.range, result.insertText);
        }
        // TODO additionalEdits, command
        return result;
    }
    Suggest.to = to;
})(Suggest = exports.Suggest || (exports.Suggest = {}));
;
var SignatureHelp;
(function (SignatureHelp) {
    function from(signatureHelp) {
        return signatureHelp;
    }
    SignatureHelp.from = from;
    function to(hints) {
        return hints;
    }
    SignatureHelp.to = to;
})(SignatureHelp = exports.SignatureHelp || (exports.SignatureHelp = {}));
var DocumentLink;
(function (DocumentLink) {
    function from(link) {
        return {
            range: fromRange(link.range),
            url: link.target && link.target.toString()
        };
    }
    DocumentLink.from = from;
    function to(link) {
        return new types.DocumentLink(toRange(link.range), link.url && uri_1.default.parse(link.url));
    }
    DocumentLink.to = to;
})(DocumentLink = exports.DocumentLink || (exports.DocumentLink = {}));
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    function to(reason) {
        switch (reason) {
            case textfiles_1.SaveReason.AUTO:
                return types.TextDocumentSaveReason.AfterDelay;
            case textfiles_1.SaveReason.EXPLICIT:
                return types.TextDocumentSaveReason.Manual;
            case textfiles_1.SaveReason.FOCUS_CHANGE:
            case textfiles_1.SaveReason.WINDOW_CHANGE:
                return types.TextDocumentSaveReason.FocusOut;
        }
    }
    TextDocumentSaveReason.to = to;
})(TextDocumentSaveReason = exports.TextDocumentSaveReason || (exports.TextDocumentSaveReason = {}));
