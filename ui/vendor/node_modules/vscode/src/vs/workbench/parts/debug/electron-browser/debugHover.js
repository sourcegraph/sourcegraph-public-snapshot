/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var nls = require("vs/nls");
var lifecycle = require("vs/base/common/lifecycle");
var winjs_base_1 = require("vs/base/common/winjs.base");
var dom = require("vs/base/browser/dom");
var treeImpl_1 = require("vs/base/parts/tree/browser/treeImpl");
var treeDefaults_1 = require("vs/base/parts/tree/browser/treeDefaults");
var range_1 = require("vs/editor/common/core/range");
var editorBrowser_1 = require("vs/editor/browser/editorBrowser");
var debugModel_1 = require("vs/workbench/parts/debug/common/debugModel");
var debugViewer_1 = require("vs/workbench/parts/debug/electron-browser/debugViewer");
var $ = dom.$;
var MAX_ELEMENTS_SHOWN = 18;
var MAX_VALUE_RENDER_LENGTH_IN_HOVER = 4096;
var DebugHoverWidget = (function () {
    function DebugHoverWidget(editor, debugService, instantiationService) {
        this.editor = editor;
        this.debugService = debugService;
        // editor.IContentWidget.allowEditorOverflow
        this.allowEditorOverflow = true;
        this.toDispose = [];
        this.create(instantiationService);
        this.registerListeners();
        this.valueContainer = dom.append(this.domNode, $('.value'));
        this.valueContainer.tabIndex = 0;
        this.valueContainer.setAttribute('role', 'tooltip');
        this._isVisible = false;
        this.showAtPosition = null;
        this.highlightDecorations = [];
        this.editor.addContentWidget(this);
        this.editor.applyFontInfo(this.domNode);
    }
    DebugHoverWidget.prototype.create = function (instantiationService) {
        this.domNode = $('.debug-hover-widget');
        this.complexValueContainer = dom.append(this.domNode, $('.complex-value'));
        this.complexValueTitle = dom.append(this.complexValueContainer, $('.title'));
        this.treeContainer = dom.append(this.complexValueContainer, $('.debug-hover-tree'));
        this.treeContainer.setAttribute('role', 'tree');
        this.tree = new treeImpl_1.Tree(this.treeContainer, {
            dataSource: new debugViewer_1.VariablesDataSource(),
            renderer: instantiationService.createInstance(VariablesHoverRenderer),
            controller: new DebugHoverController(this.editor)
        }, {
            indentPixels: 6,
            twistiePixels: 15,
            ariaLabel: nls.localize('treeAriaLabel', "Debug Hover")
        });
    };
    DebugHoverWidget.prototype.registerListeners = function () {
        var _this = this;
        this.toDispose.push(this.tree.addListener2('item:expanded', function () {
            _this.layoutTree();
        }));
        this.toDispose.push(this.tree.addListener2('item:collapsed', function () {
            _this.layoutTree();
        }));
        this.toDispose.push(dom.addStandardDisposableListener(this.domNode, 'keydown', function (e) {
            if (e.equals(9 /* Escape */)) {
                _this.hide();
            }
        }));
        this.toDispose.push(this.editor.onDidChangeConfiguration(function (e) {
            if (e.fontInfo) {
                _this.editor.applyFontInfo(_this.domNode);
            }
        }));
    };
    DebugHoverWidget.prototype.isVisible = function () {
        return this._isVisible;
    };
    DebugHoverWidget.prototype.getId = function () {
        return DebugHoverWidget.ID;
    };
    DebugHoverWidget.prototype.getDomNode = function () {
        return this.domNode;
    };
    DebugHoverWidget.prototype.getExactExpressionRange = function (lineContent, range) {
        var matchingExpression = undefined;
        var startOffset = 0;
        // Some example supported expressions: myVar.prop, a.b.c.d, myVar?.prop, myVar->prop, MyClass::StaticProp, *myVar
        // Match any character except a set of characters which often break interesting sub-expressions
        var expression = /([^()\[\]{}<>\s+\-/%~#^;=|,`!]|\->)+/g;
        var result = undefined;
        // First find the full expression under the cursor
        while (result = expression.exec(lineContent)) {
            var start = result.index + 1;
            var end = start + result[0].length;
            if (start <= range.startColumn && end >= range.endColumn) {
                matchingExpression = result[0];
                startOffset = start;
                break;
            }
        }
        // If there are non-word characters after the cursor, we want to truncate the expression then.
        // For example in expression 'a.b.c.d', if the focus was under 'b', 'a.b' would be evaluated.
        if (matchingExpression) {
            var subExpression = /\w+/g;
            var subExpressionResult = undefined;
            while (subExpressionResult = subExpression.exec(matchingExpression)) {
                var subEnd = subExpressionResult.index + 1 + startOffset + subExpressionResult[0].length;
                if (subEnd >= range.endColumn) {
                    break;
                }
            }
            if (subExpressionResult) {
                matchingExpression = matchingExpression.substring(0, subExpression.lastIndex);
            }
        }
        return matchingExpression ?
            new range_1.Range(range.startLineNumber, startOffset, range.endLineNumber, startOffset + matchingExpression.length - 1) :
            new range_1.Range(range.startLineNumber, 0, range.endLineNumber, 0);
    };
    DebugHoverWidget.prototype.showAt = function (range, hoveringOver, focus) {
        var _this = this;
        var pos = range.getStartPosition();
        var focusedStackFrame = this.debugService.getViewModel().focusedStackFrame;
        if (!hoveringOver || !focusedStackFrame || (focusedStackFrame.source.uri.toString() !== this.editor.getModel().uri.toString())) {
            return;
        }
        var process = this.debugService.getViewModel().focusedProcess;
        var lineContent = this.editor.getModel().getLineContent(pos.lineNumber);
        var expressionRange = this.getExactExpressionRange(lineContent, range);
        // use regex to extract the sub-expression #9821
        var matchingExpression = lineContent.substring(expressionRange.startColumn - 1, expressionRange.endColumn);
        var promise;
        if (process.session.configuration.capabilities.supportsEvaluateForHovers) {
            var result_1 = new debugModel_1.Expression(matchingExpression);
            promise = result_1.evaluate(process, focusedStackFrame, 'hover').then(function () { return result_1; });
        }
        else {
            promise = this.findExpressionInStackFrame(matchingExpression.split('.').map(function (word) { return word.trim(); }).filter(function (word) { return !!word; }), expressionRange);
        }
        return promise.then(function (expression) {
            if (!expression || (expression instanceof debugModel_1.Expression && !expression.available)) {
                _this.hide();
                return;
            }
            _this.highlightDecorations = _this.editor.deltaDecorations(_this.highlightDecorations, [{
                    range: new range_1.Range(pos.lineNumber, expressionRange.startColumn, pos.lineNumber, expressionRange.startColumn + matchingExpression.length),
                    options: {
                        className: 'hoverHighlight'
                    }
                }]);
            return _this.doShow(pos, expression, focus);
        });
    };
    DebugHoverWidget.prototype.doFindExpression = function (container, namesToFind) {
        var _this = this;
        return container.getChildren().then(function (children) {
            // look for our variable in the list. First find the parents of the hovered variable if there are any.
            // some languages pass the type as part of the name, so need to check if the last word of the name matches.
            var filtered = children.filter(function (v) { return typeof v.name === 'string' && (namesToFind[0] === v.name || namesToFind[0] === v.name.substr(v.name.lastIndexOf(' ') + 1)); });
            if (filtered.length !== 1) {
                return null;
            }
            if (namesToFind.length === 1) {
                return filtered[0];
            }
            else {
                return _this.doFindExpression(filtered[0], namesToFind.slice(1));
            }
        });
    };
    DebugHoverWidget.prototype.findExpressionInStackFrame = function (namesToFind, expressionRange) {
        var _this = this;
        return this.debugService.getViewModel().focusedStackFrame.getScopes()
            .then(function (scopes) { return scopes.filter(function (scope) { return !scope.expensive && (!scope.range || range_1.Range.containsRange(scope.range, expressionRange)); }); })
            .then(function (scopes) { return winjs_base_1.TPromise.join(scopes.map(function (scope) { return _this.doFindExpression(scope, namesToFind); })); })
            .then(function (expressions) { return expressions.filter(function (exp) { return !!exp; }); })
            .then(function (expressions) { return (expressions.length > 0 && expressions.every(function (e) { return e.value === expressions[0].value; })) ? expressions[0] : null; });
    };
    DebugHoverWidget.prototype.doShow = function (position, expression, focus, forceValueHover) {
        var _this = this;
        if (forceValueHover === void 0) { forceValueHover = false; }
        this.showAtPosition = position;
        this._isVisible = true;
        this.stoleFocus = focus;
        if (!expression.hasChildren || forceValueHover) {
            this.complexValueContainer.hidden = true;
            this.valueContainer.hidden = false;
            debugViewer_1.renderExpressionValue(expression, this.valueContainer, {
                showChanged: false,
                maxValueLength: MAX_VALUE_RENDER_LENGTH_IN_HOVER,
                preserveWhitespace: true
            });
            this.valueContainer.title = '';
            this.editor.layoutContentWidget(this);
            if (focus) {
                this.editor.render();
                this.valueContainer.focus();
            }
            return winjs_base_1.TPromise.as(null);
        }
        this.valueContainer.hidden = true;
        this.complexValueContainer.hidden = false;
        return this.tree.setInput(expression).then(function () {
            _this.complexValueTitle.textContent = expression.value;
            _this.complexValueTitle.title = expression.value;
            _this.layoutTree();
            _this.editor.layoutContentWidget(_this);
            if (focus) {
                _this.editor.render();
                _this.tree.DOMFocus();
            }
        });
    };
    DebugHoverWidget.prototype.layoutTree = function () {
        var navigator = this.tree.getNavigator();
        var visibleElementsCount = 0;
        while (navigator.next()) {
            visibleElementsCount++;
        }
        if (visibleElementsCount === 0) {
            this.doShow(this.showAtPosition, this.tree.getInput(), false, true);
        }
        else {
            var height = Math.min(visibleElementsCount, MAX_ELEMENTS_SHOWN) * 18;
            if (this.treeContainer.clientHeight !== height) {
                this.treeContainer.style.height = height + "px";
                this.tree.layout();
            }
        }
    };
    DebugHoverWidget.prototype.hide = function () {
        if (!this._isVisible) {
            return;
        }
        this._isVisible = false;
        this.editor.deltaDecorations(this.highlightDecorations, []);
        this.highlightDecorations = [];
        this.editor.layoutContentWidget(this);
        if (this.stoleFocus) {
            this.editor.focus();
        }
    };
    DebugHoverWidget.prototype.getPosition = function () {
        return this._isVisible ? {
            position: this.showAtPosition,
            preference: [
                editorBrowser_1.ContentWidgetPositionPreference.ABOVE,
                editorBrowser_1.ContentWidgetPositionPreference.BELOW
            ]
        } : null;
    };
    DebugHoverWidget.prototype.dispose = function () {
        this.toDispose = lifecycle.dispose(this.toDispose);
    };
    return DebugHoverWidget;
}());
DebugHoverWidget.ID = 'debug.hoverWidget';
exports.DebugHoverWidget = DebugHoverWidget;
var DebugHoverController = (function (_super) {
    __extends(DebugHoverController, _super);
    function DebugHoverController(editor) {
        var _this = _super.call(this) || this;
        _this.editor = editor;
        return _this;
    }
    DebugHoverController.prototype.onLeftClick = function (tree, element, eventish, origin) {
        if (origin === void 0) { origin = 'mouse'; }
        if (element.reference > 0) {
            _super.prototype.onLeftClick.call(this, tree, element, eventish, origin);
            tree.clearFocus();
            tree.deselect(element);
            this.editor.focus();
        }
        return true;
    };
    return DebugHoverController;
}(treeDefaults_1.DefaultController));
var VariablesHoverRenderer = (function (_super) {
    __extends(VariablesHoverRenderer, _super);
    function VariablesHoverRenderer() {
        return _super.apply(this, arguments) || this;
    }
    VariablesHoverRenderer.prototype.getHeight = function (tree, element) {
        return 18;
    };
    return VariablesHoverRenderer;
}(debugViewer_1.VariablesRenderer));
