/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var nls = require("vs/nls");
var paths = require("vs/base/common/paths");
var async_1 = require("vs/base/common/async");
var dom = require("vs/base/browser/dom");
var builder = require("vs/base/browser/builder");
var winjs_base_1 = require("vs/base/common/winjs.base");
var errors = require("vs/base/common/errors");
var events_1 = require("vs/base/common/events");
var actionBarRegistry_1 = require("vs/workbench/browser/actionBarRegistry");
var treeImpl_1 = require("vs/base/parts/tree/browser/treeImpl");
var splitview_1 = require("vs/base/browser/ui/splitview/splitview");
var viewlet_1 = require("vs/workbench/browser/viewlet");
var debug_1 = require("vs/workbench/parts/debug/common/debug");
var debugModel_1 = require("vs/workbench/parts/debug/common/debugModel");
var viewer = require("vs/workbench/parts/debug/electron-browser/debugViewer");
var debugActions_1 = require("vs/workbench/parts/debug/browser/debugActions");
var contextView_1 = require("vs/platform/contextview/browser/contextView");
var instantiation_1 = require("vs/platform/instantiation/common/instantiation");
var actions_1 = require("vs/platform/actions/common/actions");
var telemetry_1 = require("vs/platform/telemetry/common/telemetry");
var message_1 = require("vs/platform/message/common/message");
var keybinding_1 = require("vs/platform/keybinding/common/keybinding");
function renderViewTree(container) {
    var treeContainer = document.createElement('div');
    dom.addClass(treeContainer, 'debug-view-content');
    container.appendChild(treeContainer);
    return treeContainer;
}
var $ = builder.$;
var twistiePixels = 20;
var VariablesView = (function (_super) {
    __extends(VariablesView, _super);
    function VariablesView(actionRunner, settings, messageService, contextMenuService, telemetryService, debugService, keybindingService, instantiationService) {
        var _this = _super.call(this, actionRunner, !!settings[VariablesView.MEMENTO], nls.localize('variablesSection', "Variables Section"), messageService, keybindingService, contextMenuService) || this;
        _this.settings = settings;
        _this.telemetryService = telemetryService;
        _this.debugService = debugService;
        _this.instantiationService = instantiationService;
        // Use schedulre to prevent unnecessary flashing
        _this.onFocusStackFrameScheduler = new async_1.RunOnceScheduler(function () {
            // Always clear tree highlight to avoid ending up in a broken state #12203
            _this.tree.clearHighlight();
            _this.tree.refresh().then(function () {
                var stackFrame = _this.debugService.getViewModel().focusedStackFrame;
                if (stackFrame) {
                    return stackFrame.getScopes().then(function (scopes) {
                        if (scopes.length > 0 && !scopes[0].expensive) {
                            return _this.tree.expand(scopes[0]);
                        }
                    });
                }
            }).done(null, errors.onUnexpectedError);
        }, 700);
        return _this;
    }
    VariablesView.prototype.renderHeader = function (container) {
        var titleDiv = $('div.title').appendTo(container);
        $('span').text(nls.localize('variables', "Variables")).appendTo(titleDiv);
        _super.prototype.renderHeader.call(this, container);
    };
    VariablesView.prototype.renderBody = function (container) {
        var _this = this;
        dom.addClass(container, 'debug-variables');
        this.treeContainer = renderViewTree(container);
        this.tree = new treeImpl_1.Tree(this.treeContainer, {
            dataSource: new viewer.VariablesDataSource(),
            renderer: this.instantiationService.createInstance(viewer.VariablesRenderer),
            accessibilityProvider: new viewer.VariablesAccessibilityProvider(),
            controller: this.instantiationService.createInstance(viewer.VariablesController, new viewer.VariablesActionProvider(this.instantiationService), actions_1.MenuId.DebugVariablesContext)
        }, {
            ariaLabel: nls.localize('variablesAriaTreeLabel', "Debug Variables"),
            twistiePixels: twistiePixels
        });
        var viewModel = this.debugService.getViewModel();
        this.tree.setInput(viewModel);
        var collapseAction = this.instantiationService.createInstance(viewlet_1.CollapseAction, this.tree, false, 'explorer-action collapse-explorer');
        this.toolBar.setActions(actionBarRegistry_1.prepareActions([collapseAction]))();
        this.toDispose.push(viewModel.onDidFocusStackFrame(function (sf) {
            // Only delay if the stack frames got cleared and there is no active stack frame
            // Otherwise just update immediately
            if (sf) {
                _this.onFocusStackFrameScheduler.schedule(0);
            }
            else if (!_this.onFocusStackFrameScheduler.isScheduled()) {
                _this.onFocusStackFrameScheduler.schedule();
            }
        }));
        this.toDispose.push(this.debugService.onDidChangeState(function () {
            var state = _this.debugService.state;
            collapseAction.enabled = state === debug_1.State.Running || state === debug_1.State.Stopped;
        }));
        this.toDispose.push(this.debugService.getViewModel().onDidSelectExpression(function (expression) {
            if (!expression || !(expression instanceof debugModel_1.Variable)) {
                return;
            }
            _this.tree.refresh(expression, false).then(function () {
                _this.tree.setHighlight(expression);
                _this.tree.addOneTimeDisposableListener(events_1.EventType.HIGHLIGHT, function (e) {
                    if (!e.highlight) {
                        _this.debugService.getViewModel().setSelectedExpression(null);
                    }
                });
            }).done(null, errors.onUnexpectedError);
        }));
    };
    VariablesView.prototype.shutdown = function () {
        this.settings[VariablesView.MEMENTO] = (this.state === splitview_1.CollapsibleState.COLLAPSED);
        _super.prototype.shutdown.call(this);
    };
    return VariablesView;
}(viewlet_1.CollapsibleViewletView));
VariablesView.MEMENTO = 'variablesview.memento';
VariablesView = __decorate([
    __param(2, message_1.IMessageService),
    __param(3, contextView_1.IContextMenuService),
    __param(4, telemetry_1.ITelemetryService),
    __param(5, debug_1.IDebugService),
    __param(6, keybinding_1.IKeybindingService),
    __param(7, instantiation_1.IInstantiationService)
], VariablesView);
exports.VariablesView = VariablesView;
var WatchExpressionsView = (function (_super) {
    __extends(WatchExpressionsView, _super);
    function WatchExpressionsView(actionRunner, settings, messageService, contextMenuService, debugService, keybindingService, instantiationService) {
        var _this = _super.call(this, actionRunner, !!settings[WatchExpressionsView.MEMENTO], nls.localize('expressionsSection', "Expressions Section"), messageService, keybindingService, contextMenuService) || this;
        _this.settings = settings;
        _this.debugService = debugService;
        _this.instantiationService = instantiationService;
        _this.toDispose.push(_this.debugService.getModel().onDidChangeWatchExpressions(function (we) {
            // only expand when a new watch expression is added.
            if (we instanceof debugModel_1.Expression) {
                _this.expand();
            }
        }));
        _this.onWatchExpressionsUpdatedScheduler = new async_1.RunOnceScheduler(function () {
            _this.tree.refresh().done(function () {
                return _this.toReveal instanceof debugModel_1.Expression ? _this.tree.reveal(_this.toReveal) : winjs_base_1.TPromise.as(true);
            }, errors.onUnexpectedError);
        }, 50);
        return _this;
    }
    WatchExpressionsView.prototype.renderHeader = function (container) {
        var titleDiv = $('div.title').appendTo(container);
        $('span').text(nls.localize('watch', "Watch")).appendTo(titleDiv);
        _super.prototype.renderHeader.call(this, container);
    };
    WatchExpressionsView.prototype.renderBody = function (container) {
        var _this = this;
        dom.addClass(container, 'debug-watch');
        this.treeContainer = renderViewTree(container);
        var actionProvider = new viewer.WatchExpressionsActionProvider(this.instantiationService);
        this.tree = new treeImpl_1.Tree(this.treeContainer, {
            dataSource: new viewer.WatchExpressionsDataSource(),
            renderer: this.instantiationService.createInstance(viewer.WatchExpressionsRenderer, actionProvider, this.actionRunner),
            accessibilityProvider: new viewer.WatchExpressionsAccessibilityProvider(),
            controller: this.instantiationService.createInstance(viewer.WatchExpressionsController, actionProvider, actions_1.MenuId.DebugWatchContext),
            dnd: this.instantiationService.createInstance(viewer.WatchExpressionsDragAndDrop)
        }, {
            ariaLabel: nls.localize({ comment: ['Debug is a noun in this context, not a verb.'], key: 'watchAriaTreeLabel' }, "Debug Watch Expressions"),
            twistiePixels: twistiePixels
        });
        this.tree.setInput(this.debugService.getModel());
        var addWatchExpressionAction = this.instantiationService.createInstance(debugActions_1.AddWatchExpressionAction, debugActions_1.AddWatchExpressionAction.ID, debugActions_1.AddWatchExpressionAction.LABEL);
        var collapseAction = this.instantiationService.createInstance(viewlet_1.CollapseAction, this.tree, true, 'explorer-action collapse-explorer');
        var removeAllWatchExpressionsAction = this.instantiationService.createInstance(debugActions_1.RemoveAllWatchExpressionsAction, debugActions_1.RemoveAllWatchExpressionsAction.ID, debugActions_1.RemoveAllWatchExpressionsAction.LABEL);
        this.toolBar.setActions(actionBarRegistry_1.prepareActions([addWatchExpressionAction, collapseAction, removeAllWatchExpressionsAction]))();
        this.toDispose.push(this.debugService.getModel().onDidChangeWatchExpressions(function (we) {
            if (!_this.onWatchExpressionsUpdatedScheduler.isScheduled()) {
                _this.onWatchExpressionsUpdatedScheduler.schedule();
            }
            _this.toReveal = we;
        }));
        this.toDispose.push(this.debugService.getViewModel().onDidSelectExpression(function (expression) {
            if (!expression || !(expression instanceof debugModel_1.Expression)) {
                return;
            }
            _this.tree.refresh(expression, false).then(function () {
                _this.tree.setHighlight(expression);
                _this.tree.addOneTimeDisposableListener(events_1.EventType.HIGHLIGHT, function (e) {
                    if (!e.highlight) {
                        _this.debugService.getViewModel().setSelectedExpression(null);
                    }
                });
            }).done(null, errors.onUnexpectedError);
        }));
    };
    WatchExpressionsView.prototype.shutdown = function () {
        this.settings[WatchExpressionsView.MEMENTO] = (this.state === splitview_1.CollapsibleState.COLLAPSED);
        _super.prototype.shutdown.call(this);
    };
    return WatchExpressionsView;
}(viewlet_1.CollapsibleViewletView));
WatchExpressionsView.MEMENTO = 'watchexpressionsview.memento';
WatchExpressionsView = __decorate([
    __param(2, message_1.IMessageService),
    __param(3, contextView_1.IContextMenuService),
    __param(4, debug_1.IDebugService),
    __param(5, keybinding_1.IKeybindingService),
    __param(6, instantiation_1.IInstantiationService)
], WatchExpressionsView);
exports.WatchExpressionsView = WatchExpressionsView;
var CallStackView = (function (_super) {
    __extends(CallStackView, _super);
    function CallStackView(actionRunner, settings, messageService, contextMenuService, telemetryService, debugService, keybindingService, instantiationService) {
        var _this = _super.call(this, actionRunner, !!settings[CallStackView.MEMENTO], nls.localize('callstackSection', "Call Stack Section"), messageService, keybindingService, contextMenuService) || this;
        _this.settings = settings;
        _this.telemetryService = telemetryService;
        _this.debugService = debugService;
        _this.instantiationService = instantiationService;
        // Create scheduler to prevent unnecessary flashing of tree when reacting to changes
        _this.onCallStackChangeScheduler = new async_1.RunOnceScheduler(function () {
            var newTreeInput = _this.debugService.getModel();
            var processes = _this.debugService.getModel().getProcesses();
            if (!_this.debugService.getViewModel().isMultiProcessView() && processes.length) {
                var threads = processes[0].getAllThreads();
                // Only show the threads in the call stack if there is more than 1 thread.
                newTreeInput = threads.length === 1 ? threads[0] : processes[0];
            }
            // Only show the global pause message if we do not display threads.
            // Otherwsie there will be a pause message per thread and there is no need for a global one.
            if (newTreeInput instanceof debugModel_1.Thread && newTreeInput.stoppedDetails) {
                _this.pauseMessageLabel.text(nls.localize('debugStopped', "Paused on {0}", newTreeInput.stoppedDetails.reason));
                if (newTreeInput.stoppedDetails.text) {
                    _this.pauseMessageLabel.title(newTreeInput.stoppedDetails.text);
                }
                newTreeInput.stoppedDetails.reason === 'exception' ? _this.pauseMessageLabel.addClass('exception') : _this.pauseMessageLabel.removeClass('exception');
                _this.pauseMessage.show();
            }
            else {
                _this.pauseMessage.hide();
            }
            (_this.tree.getInput() === newTreeInput ? _this.tree.refresh() : _this.tree.setInput(newTreeInput)).done(function () {
                var stackFrame = _this.debugService.getViewModel().focusedStackFrame;
                if (!stackFrame) {
                    return;
                }
                var thread = stackFrame.thread;
                return _this.tree.expandAll([thread.process, thread]).done(function () {
                    _this.tree.setSelection([stackFrame]);
                    return _this.tree.reveal(stackFrame);
                });
            }, errors.onUnexpectedError);
        }, 50);
        return _this;
    }
    CallStackView.prototype.renderHeader = function (container) {
        var title = $('div.debug-call-stack-title').appendTo(container);
        $('span.title').text(nls.localize('callStack', "Call Stack")).appendTo(title);
        this.pauseMessage = $('span.pause-message').appendTo(title);
        this.pauseMessage.hide();
        this.pauseMessageLabel = $('span.label').appendTo(this.pauseMessage);
        _super.prototype.renderHeader.call(this, container);
    };
    CallStackView.prototype.renderBody = function (container) {
        var _this = this;
        dom.addClass(container, 'debug-call-stack');
        this.treeContainer = renderViewTree(container);
        var actionProvider = this.instantiationService.createInstance(viewer.CallStackActionProvider);
        this.tree = new treeImpl_1.Tree(this.treeContainer, {
            dataSource: this.instantiationService.createInstance(viewer.CallStackDataSource),
            renderer: this.instantiationService.createInstance(viewer.CallStackRenderer),
            accessibilityProvider: this.instantiationService.createInstance(viewer.CallstackAccessibilityProvider),
            controller: this.instantiationService.createInstance(viewer.CallStackController, actionProvider, actions_1.MenuId.DebugCallStackContext)
        }, {
            ariaLabel: nls.localize({ comment: ['Debug is a noun in this context, not a verb.'], key: 'callStackAriaLabel' }, "Debug Call Stack"),
            twistiePixels: twistiePixels
        });
        this.toDispose.push(this.debugService.getModel().onDidChangeCallStack(function () {
            if (!_this.onCallStackChangeScheduler.isScheduled()) {
                _this.onCallStackChangeScheduler.schedule();
            }
        }));
        // Schedule the update of the call stack tree if the viewlet is opened after a session started #14684
        if (this.debugService.state === debug_1.State.Stopped) {
            this.onCallStackChangeScheduler.schedule();
        }
    };
    CallStackView.prototype.shutdown = function () {
        this.settings[CallStackView.MEMENTO] = (this.state === splitview_1.CollapsibleState.COLLAPSED);
        _super.prototype.shutdown.call(this);
    };
    return CallStackView;
}(viewlet_1.CollapsibleViewletView));
CallStackView.MEMENTO = 'callstackview.memento';
CallStackView = __decorate([
    __param(2, message_1.IMessageService),
    __param(3, contextView_1.IContextMenuService),
    __param(4, telemetry_1.ITelemetryService),
    __param(5, debug_1.IDebugService),
    __param(6, keybinding_1.IKeybindingService),
    __param(7, instantiation_1.IInstantiationService)
], CallStackView);
exports.CallStackView = CallStackView;
var BreakpointsView = (function (_super) {
    __extends(BreakpointsView, _super);
    function BreakpointsView(actionRunner, settings, contextMenuService, debugService, keybindingService, instantiationService) {
        var _this = _super.call(this, actionRunner, BreakpointsView.getExpandedBodySize(debugService.getModel().getBreakpoints().length + debugService.getModel().getFunctionBreakpoints().length + debugService.getModel().getExceptionBreakpoints().length), !!settings[BreakpointsView.MEMENTO], nls.localize('breakpointsSection', "Breakpoints Section"), keybindingService, contextMenuService) || this;
        _this.settings = settings;
        _this.debugService = debugService;
        _this.instantiationService = instantiationService;
        _this.toDispose.push(_this.debugService.getModel().onDidChangeBreakpoints(function () { return _this.onBreakpointsChange(); }));
        return _this;
    }
    BreakpointsView.prototype.renderHeader = function (container) {
        var titleDiv = $('div.title').appendTo(container);
        $('span').text(nls.localize('breakpoints', "Breakpoints")).appendTo(titleDiv);
        _super.prototype.renderHeader.call(this, container);
    };
    BreakpointsView.prototype.renderBody = function (container) {
        var _this = this;
        dom.addClass(container, 'debug-breakpoints');
        this.treeContainer = renderViewTree(container);
        var actionProvider = new viewer.BreakpointsActionProvider(this.instantiationService);
        this.tree = new treeImpl_1.Tree(this.treeContainer, {
            dataSource: new viewer.BreakpointsDataSource(),
            renderer: this.instantiationService.createInstance(viewer.BreakpointsRenderer, actionProvider, this.actionRunner),
            accessibilityProvider: this.instantiationService.createInstance(viewer.BreakpointsAccessibilityProvider),
            controller: this.instantiationService.createInstance(viewer.BreakpointsController, actionProvider, actions_1.MenuId.DebugBreakpointsContext),
            sorter: {
                compare: function (tree, element, otherElement) {
                    var first = element;
                    var second = otherElement;
                    if (first instanceof debugModel_1.ExceptionBreakpoint) {
                        return -1;
                    }
                    if (second instanceof debugModel_1.ExceptionBreakpoint) {
                        return 1;
                    }
                    if (first instanceof debugModel_1.FunctionBreakpoint) {
                        return -1;
                    }
                    if (second instanceof debugModel_1.FunctionBreakpoint) {
                        return 1;
                    }
                    if (first.uri.toString() !== second.uri.toString()) {
                        return paths.basename(first.uri.fsPath).localeCompare(paths.basename(second.uri.fsPath));
                    }
                    return first.lineNumber - second.lineNumber;
                }
            }
        }, {
            ariaLabel: nls.localize({ comment: ['Debug is a noun in this context, not a verb.'], key: 'breakpointsAriaTreeLabel' }, "Debug Breakpoints"),
            twistiePixels: twistiePixels
        });
        var debugModel = this.debugService.getModel();
        this.tree.setInput(debugModel);
        this.toDispose.push(this.debugService.getViewModel().onDidSelectFunctionBreakpoint(function (fbp) {
            if (!fbp || !(fbp instanceof debugModel_1.FunctionBreakpoint)) {
                return;
            }
            _this.tree.refresh(fbp, false).then(function () {
                _this.tree.setHighlight(fbp);
                _this.tree.addOneTimeDisposableListener(events_1.EventType.HIGHLIGHT, function (e) {
                    if (!e.highlight) {
                        _this.debugService.getViewModel().setSelectedFunctionBreakpoint(null);
                    }
                });
            }).done(null, errors.onUnexpectedError);
        }));
    };
    BreakpointsView.prototype.getActions = function () {
        return [
            this.instantiationService.createInstance(debugActions_1.AddFunctionBreakpointAction, debugActions_1.AddFunctionBreakpointAction.ID, debugActions_1.AddFunctionBreakpointAction.LABEL),
            this.instantiationService.createInstance(debugActions_1.ToggleBreakpointsActivatedAction, debugActions_1.ToggleBreakpointsActivatedAction.ID, debugActions_1.ToggleBreakpointsActivatedAction.ACTIVATE_LABEL),
            this.instantiationService.createInstance(debugActions_1.RemoveAllBreakpointsAction, debugActions_1.RemoveAllBreakpointsAction.ID, debugActions_1.RemoveAllBreakpointsAction.LABEL)
        ];
    };
    BreakpointsView.prototype.onBreakpointsChange = function () {
        var model = this.debugService.getModel();
        this.expandedBodySize = BreakpointsView.getExpandedBodySize(model.getBreakpoints().length + model.getExceptionBreakpoints().length + model.getFunctionBreakpoints().length);
        if (this.tree) {
            this.tree.refresh();
        }
    };
    BreakpointsView.getExpandedBodySize = function (length) {
        return Math.min(BreakpointsView.MAX_VISIBLE_FILES, length) * 22;
    };
    BreakpointsView.prototype.shutdown = function () {
        this.settings[BreakpointsView.MEMENTO] = (this.state === splitview_1.CollapsibleState.COLLAPSED);
        _super.prototype.shutdown.call(this);
    };
    return BreakpointsView;
}(viewlet_1.AdaptiveCollapsibleViewletView));
BreakpointsView.MAX_VISIBLE_FILES = 9;
BreakpointsView.MEMENTO = 'breakopintsview.memento';
BreakpointsView = __decorate([
    __param(2, contextView_1.IContextMenuService),
    __param(3, debug_1.IDebugService),
    __param(4, keybinding_1.IKeybindingService),
    __param(5, instantiation_1.IInstantiationService)
], BreakpointsView);
exports.BreakpointsView = BreakpointsView;
