import uri from 'vs/base/common/uri';
import { TPromise } from 'vs/base/common/winjs.base';
import Event from 'vs/base/common/event';
import severity from 'vs/base/common/severity';
import { IRange } from 'vs/editor/common/editorCommon';
import { ISuggestion } from 'vs/editor/common/modes';
import { Position } from 'vs/editor/common/core/position';
import * as debug from 'vs/workbench/parts/debug/common/debug';
import { Source } from 'vs/workbench/parts/debug/common/debugSource';
export declare abstract class AbstractOutputElement implements debug.ITreeElement {
    private id;
    private static ID_COUNTER;
    constructor(id?: number);
    getId(): string;
}
export declare class OutputElement extends AbstractOutputElement {
    value: string;
    severity: severity;
    counter: number;
    constructor(value: string, severity: severity);
}
export declare class OutputNameValueElement extends AbstractOutputElement implements debug.IExpression {
    name: string;
    valueObj: any;
    annotation: string;
    private static MAX_CHILDREN;
    constructor(name: string, valueObj: any, annotation?: string);
    readonly value: string;
    readonly hasChildren: boolean;
    getChildren(): TPromise<debug.IExpression[]>;
}
export declare class ExpressionContainer implements debug.IExpressionContainer {
    protected process: debug.IProcess;
    reference: number;
    private id;
    namedVariables: number;
    indexedVariables: number;
    private startOfVariables;
    static allValues: {
        [id: string]: string;
    };
    private static BASE_CHUNK_SIZE;
    valueChanged: boolean;
    private _value;
    constructor(process: debug.IProcess, reference: number, id: string, namedVariables?: number, indexedVariables?: number, startOfVariables?: number);
    getChildren(): TPromise<debug.IExpression[]>;
    getId(): string;
    value: string;
    readonly hasChildren: boolean;
    private fetchVariables(start, count, filter);
    private readonly getChildrenInChunks;
}
export declare class Expression extends ExpressionContainer implements debug.IExpression {
    name: string;
    static DEFAULT_VALUE: string;
    available: boolean;
    type: string;
    constructor(name: string, id?: string);
    evaluate(process: debug.IProcess, stackFrame: debug.IStackFrame, context: string): TPromise<void>;
}
export declare class Variable extends ExpressionContainer implements debug.IExpression {
    parent: debug.IExpressionContainer;
    name: string;
    private _evaluateName;
    type: string;
    available: boolean;
    errorMessage: string;
    private static NOT_PROPERTY_SYNTAX;
    private static ARRAY_ELEMENT_SYNTAX;
    constructor(process: debug.IProcess, parent: debug.IExpressionContainer, reference: number, name: string, _evaluateName: string, value: string, namedVariables: number, indexedVariables: number, type?: string, available?: boolean, startOfVariables?: number);
    readonly evaluateName: string;
    setVariable(value: string): TPromise<any>;
}
export declare class Scope extends ExpressionContainer implements debug.IScope {
    name: string;
    expensive: boolean;
    range: IRange;
    constructor(stackFrame: debug.IStackFrame, name: string, reference: number, expensive: boolean, namedVariables: number, indexedVariables: number, range?: IRange);
}
export declare class StackFrame implements debug.IStackFrame {
    thread: debug.IThread;
    frameId: number;
    source: Source;
    name: string;
    lineNumber: number;
    column: number;
    private scopes;
    constructor(thread: debug.IThread, frameId: number, source: Source, name: string, lineNumber: number, column: number);
    getId(): string;
    getScopes(): TPromise<debug.IScope[]>;
    restart(): TPromise<any>;
}
export declare class Thread implements debug.IThread {
    process: debug.IProcess;
    name: string;
    threadId: number;
    private promisedCallStack;
    private cachedCallStack;
    stoppedDetails: debug.IRawStoppedDetails;
    stopped: boolean;
    constructor(process: debug.IProcess, name: string, threadId: number);
    getId(): string;
    clearCallStack(): void;
    getCallStack(): debug.IStackFrame[];
    /**
     * Queries the debug adapter for the callstack and returns a promise with
     * the stack frames of the callstack.
     * If the thread is not stopped, it returns a promise to an empty array.
     * Only gets the first 20 stack frames. Calling this method consecutive times
     * with getAdditionalStackFrames = true gets the remainder of the call stack.
     */
    fetchCallStack(getAdditionalStackFrames?: boolean): TPromise<debug.IStackFrame[]>;
    private getCallStackImpl(startFrame);
    next(): TPromise<any>;
    stepIn(): TPromise<any>;
    stepOut(): TPromise<any>;
    stepBack(): TPromise<any>;
    continue(): TPromise<any>;
    pause(): TPromise<any>;
    reverseContinue(): TPromise<any>;
}
export declare class Process implements debug.IProcess {
    name: string;
    private _session;
    private threads;
    constructor(name: string, _session: debug.ISession & debug.ITreeElement);
    readonly session: debug.ISession;
    getThread(threadId: number): Thread;
    getAllThreads(): debug.IThread[];
    getId(): string;
    rawUpdate(data: debug.IRawModelUpdate): void;
    clearThreads(removeThreads: boolean, reference?: number): void;
    sourceIsUnavailable(source: Source): void;
    completions(frameId: number, text: string, position: Position, overwriteBefore: number): TPromise<ISuggestion[]>;
}
export declare class Breakpoint implements debug.IBreakpoint {
    uri: uri;
    lineNumber: number;
    enabled: boolean;
    condition: string;
    hitCondition: string;
    verified: boolean;
    idFromAdapter: number;
    message: string;
    private id;
    constructor(uri: uri, lineNumber: number, enabled: boolean, condition: string, hitCondition: string);
    getId(): string;
}
export declare class FunctionBreakpoint implements debug.IFunctionBreakpoint {
    name: string;
    enabled: boolean;
    hitCondition: string;
    private id;
    verified: boolean;
    idFromAdapter: number;
    constructor(name: string, enabled: boolean, hitCondition: string);
    getId(): string;
}
export declare class ExceptionBreakpoint implements debug.IExceptionBreakpoint {
    filter: string;
    label: string;
    enabled: boolean;
    private id;
    constructor(filter: string, label: string, enabled: boolean);
    getId(): string;
}
export declare class Model implements debug.IModel {
    private breakpoints;
    private breakpointsActivated;
    private functionBreakpoints;
    private exceptionBreakpoints;
    private watchExpressions;
    private processes;
    private toDispose;
    private replElements;
    private _onDidChangeBreakpoints;
    private _onDidChangeCallStack;
    private _onDidChangeWatchExpressions;
    private _onDidChangeREPLElements;
    constructor(breakpoints: Breakpoint[], breakpointsActivated: boolean, functionBreakpoints: FunctionBreakpoint[], exceptionBreakpoints: ExceptionBreakpoint[], watchExpressions: Expression[]);
    getId(): string;
    getProcesses(): Process[];
    addProcess(name: string, session: debug.ISession & debug.ITreeElement): Process;
    removeProcess(id: string): void;
    readonly onDidChangeBreakpoints: Event<void>;
    readonly onDidChangeCallStack: Event<void>;
    readonly onDidChangeWatchExpressions: Event<debug.IExpression>;
    readonly onDidChangeReplElements: Event<void>;
    rawUpdate(data: debug.IRawModelUpdate): void;
    clearThreads(id: string, removeThreads: boolean, reference?: number): void;
    getBreakpoints(): Breakpoint[];
    getFunctionBreakpoints(): debug.IFunctionBreakpoint[];
    getExceptionBreakpoints(): debug.IExceptionBreakpoint[];
    setExceptionBreakpoints(data: DebugProtocol.ExceptionBreakpointsFilter[]): void;
    areBreakpointsActivated(): boolean;
    setBreakpointsActivated(activated: boolean): void;
    addBreakpoints(uri: uri, rawData: debug.IRawBreakpoint[]): void;
    removeBreakpoints(toRemove: debug.IBreakpoint[]): void;
    updateBreakpoints(data: {
        [id: string]: DebugProtocol.Breakpoint;
    }): void;
    setEnablement(element: debug.IEnablement, enable: boolean): void;
    enableOrDisableAllBreakpoints(enable: boolean): void;
    addFunctionBreakpoint(functionName: string): void;
    updateFunctionBreakpoints(data: {
        [id: string]: {
            name?: string;
            verified?: boolean;
            id?: number;
            hitCondition?: string;
        };
    }): void;
    removeFunctionBreakpoints(id?: string): void;
    getReplElements(): debug.ITreeElement[];
    addReplExpression(process: debug.IProcess, stackFrame: debug.IStackFrame, name: string): TPromise<void>;
    appendToRepl(output: string | debug.IExpression, severity: severity): void;
    private addReplElement(newElement);
    removeReplExpressions(): void;
    getWatchExpressions(): Expression[];
    addWatchExpression(process: debug.IProcess, stackFrame: debug.IStackFrame, name: string): TPromise<void>;
    renameWatchExpression(process: debug.IProcess, stackFrame: debug.IStackFrame, id: string, newName: string): TPromise<void>;
    evaluateWatchExpressions(process: debug.IProcess, stackFrame: debug.IStackFrame, id?: string): TPromise<void>;
    removeWatchExpressions(id?: string): void;
    moveWatchExpression(id: string, position: number): void;
    sourceIsUnavailable(source: Source): void;
    dispose(): void;
}
