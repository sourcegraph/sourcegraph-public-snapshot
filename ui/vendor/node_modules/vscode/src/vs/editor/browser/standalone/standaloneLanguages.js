/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var winjs_base_1 = require("vs/base/common/winjs.base");
var modesRegistry_1 = require("vs/editor/common/modes/modesRegistry");
var standaloneServices_1 = require("vs/editor/browser/standalone/standaloneServices");
var modes = require("vs/editor/common/modes");
var languageConfiguration_1 = require("vs/editor/common/modes/languageConfiguration");
var position_1 = require("vs/editor/common/core/position");
var range_1 = require("vs/editor/common/core/range");
var async_1 = require("vs/base/common/async");
var monarchCompile_1 = require("vs/editor/common/modes/monarch/monarchCompile");
var monarchLexer_1 = require("vs/editor/common/modes/monarch/monarchLexer");
var languageConfigurationRegistry_1 = require("vs/editor/common/modes/languageConfigurationRegistry");
var token_1 = require("vs/editor/common/core/token");
/**
 * Register information about a new language.
 */
function register(language) {
    modesRegistry_1.ModesRegistry.registerLanguage(language);
}
exports.register = register;
/**
 * Get the information of all the registered languages.
 */
function getLanguages() {
    var result = [];
    result = result.concat(modesRegistry_1.ModesRegistry.getLanguages());
    return result;
}
exports.getLanguages = getLanguages;
/**
 * An event emitted when a language is first time needed (e.g. a model has it set).
 * @event
 */
function onLanguage(languageId, callback) {
    var disposable = standaloneServices_1.StaticServices.modeService.get().onDidCreateMode(function (mode) {
        if (mode.getId() === languageId) {
            // stop listening
            disposable.dispose();
            // invoke actual listener
            callback();
        }
    });
    return disposable;
}
exports.onLanguage = onLanguage;
/**
 * Set the editing configuration for a language.
 */
function setLanguageConfiguration(languageId, configuration) {
    var languageIdentifier = standaloneServices_1.StaticServices.modeService.get().getLanguageIdentifier(languageId);
    if (!languageIdentifier) {
        throw new Error("Cannot set configuration for unknown language " + languageId);
    }
    return languageConfigurationRegistry_1.LanguageConfigurationRegistry.register(languageIdentifier, configuration);
}
exports.setLanguageConfiguration = setLanguageConfiguration;
/**
 * @internal
 */
var TokenizationSupport2Adapter = (function () {
    function TokenizationSupport2Adapter(standaloneColorService, languageIdentifier, actual) {
        this._standaloneColorService = standaloneColorService;
        this._languageIdentifier = languageIdentifier;
        this._actual = actual;
    }
    TokenizationSupport2Adapter.prototype.getInitialState = function () {
        return this._actual.getInitialState();
    };
    TokenizationSupport2Adapter.prototype._toClassicTokens = function (tokens, language, offsetDelta) {
        var result = [];
        for (var i = 0, len = tokens.length; i < len; i++) {
            var t = tokens[i];
            result[i] = new token_1.Token(t.startIndex + offsetDelta, t.scopes, language);
        }
        return result;
    };
    TokenizationSupport2Adapter.prototype.tokenize = function (line, state, offsetDelta) {
        var actualResult = this._actual.tokenize(line, state);
        var tokens = this._toClassicTokens(actualResult.tokens, this._languageIdentifier.language, offsetDelta);
        var endState;
        // try to save an object if possible
        if (actualResult.endState.equals(state)) {
            endState = state;
        }
        else {
            endState = actualResult.endState;
        }
        return new token_1.TokenizationResult(tokens, endState);
    };
    TokenizationSupport2Adapter.prototype._toBinaryTokens = function (tokens, offsetDelta) {
        var languageId = this._languageIdentifier.id;
        var theme = this._standaloneColorService.getTheme();
        var result = [], resultLen = 0;
        for (var i = 0, len = tokens.length; i < len; i++) {
            var t = tokens[i];
            var metadata = theme.match(languageId, t.scopes);
            if (resultLen > 0 && result[resultLen - 1] === metadata) {
                // same metadata
                continue;
            }
            result[resultLen++] = t.startIndex;
            result[resultLen++] = metadata;
        }
        var actualResult = new Uint32Array(resultLen);
        for (var i = 0; i < resultLen; i++) {
            actualResult[i] = result[i];
        }
        return actualResult;
    };
    TokenizationSupport2Adapter.prototype.tokenize2 = function (line, state, offsetDelta) {
        var actualResult = this._actual.tokenize(line, state);
        var tokens = this._toBinaryTokens(actualResult.tokens, offsetDelta);
        var endState;
        // try to save an object if possible
        if (actualResult.endState.equals(state)) {
            endState = state;
        }
        else {
            endState = actualResult.endState;
        }
        return new token_1.TokenizationResult2(tokens, endState);
    };
    return TokenizationSupport2Adapter;
}());
exports.TokenizationSupport2Adapter = TokenizationSupport2Adapter;
/**
 * Set the tokens provider for a language (manual implementation).
 */
function setTokensProvider(languageId, provider) {
    var languageIdentifier = standaloneServices_1.StaticServices.modeService.get().getLanguageIdentifier(languageId);
    if (!languageIdentifier) {
        throw new Error("Cannot set tokens provider for unknown language " + languageId);
    }
    var adapter = new TokenizationSupport2Adapter(standaloneServices_1.StaticServices.standaloneColorService.get(), languageIdentifier, provider);
    return modes.TokenizationRegistry.register(languageId, adapter);
}
exports.setTokensProvider = setTokensProvider;
/**
 * Set the tokens provider for a language (monarch implementation).
 */
function setMonarchTokensProvider(languageId, languageDef) {
    var lexer = monarchCompile_1.compile(languageId, languageDef);
    var adapter = monarchLexer_1.createTokenizationSupport(standaloneServices_1.StaticServices.modeService.get(), standaloneServices_1.StaticServices.standaloneColorService.get(), languageId, lexer);
    return modes.TokenizationRegistry.register(languageId, adapter);
}
exports.setMonarchTokensProvider = setMonarchTokensProvider;
/**
 * Register a reference provider (used by e.g. reference search).
 */
function registerReferenceProvider(languageId, provider) {
    return modes.ReferenceProviderRegistry.register(languageId, provider);
}
exports.registerReferenceProvider = registerReferenceProvider;
/**
 * Register a workspace reference provider (used by e.g. workspace reference search).
 */
function registerWorkspaceReferenceProvider(languageId, provider) {
    return modes.WorkspaceReferenceProviderRegistry.register(languageId, provider);
}
exports.registerWorkspaceReferenceProvider = registerWorkspaceReferenceProvider;
/**
 * Register a rename provider (used by e.g. rename symbol).
 */
function registerRenameProvider(languageId, provider) {
    return modes.RenameProviderRegistry.register(languageId, provider);
}
exports.registerRenameProvider = registerRenameProvider;
/**
 * Register a signature help provider (used by e.g. paremeter hints).
 */
function registerSignatureHelpProvider(languageId, provider) {
    return modes.SignatureHelpProviderRegistry.register(languageId, provider);
}
exports.registerSignatureHelpProvider = registerSignatureHelpProvider;
/**
 * Register a hover provider (used by e.g. editor hover).
 */
function registerHoverProvider(languageId, provider) {
    return modes.HoverProviderRegistry.register(languageId, {
        provideHover: function (model, position, token) {
            var word = model.getWordAtPosition(position);
            return async_1.toThenable(provider.provideHover(model, position, token)).then(function (value) {
                if (!value) {
                    return undefined;
                }
                if (!value.range && word) {
                    value.range = new range_1.Range(position.lineNumber, word.startColumn, position.column, word.endColumn);
                }
                if (!value.range) {
                    value.range = new range_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
                }
                return value;
            });
        }
    });
}
exports.registerHoverProvider = registerHoverProvider;
/**
 * Register a document symbol provider (used by e.g. outline).
 */
function registerDocumentSymbolProvider(languageId, provider) {
    return modes.DocumentSymbolProviderRegistry.register(languageId, provider);
}
exports.registerDocumentSymbolProvider = registerDocumentSymbolProvider;
/**
 * Register a document highlight provider (used by e.g. highlight occurences).
 */
function registerDocumentHighlightProvider(languageId, provider) {
    return modes.DocumentHighlightProviderRegistry.register(languageId, provider);
}
exports.registerDocumentHighlightProvider = registerDocumentHighlightProvider;
/**
 * Register a definition provider (used by e.g. go to definition).
 */
function registerDefinitionProvider(languageId, provider) {
    return modes.DefinitionProviderRegistry.register(languageId, provider);
}
exports.registerDefinitionProvider = registerDefinitionProvider;
/**
 * Register a implementation provider (used by e.g. go to implementation).
 */
function registerImplementationProvider(languageId, provider) {
    return modes.ImplementationProviderRegistry.register(languageId, provider);
}
exports.registerImplementationProvider = registerImplementationProvider;
/**
 * Register a type definition provider (used by e.g. go to type definition).
 */
function registerTypeDefinitionProvider(languageId, provider) {
    return modes.TypeDefinitionProviderRegistry.register(languageId, provider);
}
exports.registerTypeDefinitionProvider = registerTypeDefinitionProvider;
/**
 * Register a code lens provider (used by e.g. inline code lenses).
 */
function registerCodeLensProvider(languageId, provider) {
    return modes.CodeLensProviderRegistry.register(languageId, provider);
}
exports.registerCodeLensProvider = registerCodeLensProvider;
/**
 * Register a code action provider (used by e.g. quick fix).
 */
function registerCodeActionProvider(languageId, provider) {
    return modes.CodeActionProviderRegistry.register(languageId, {
        provideCodeActions: function (model, range, token) {
            var markers = standaloneServices_1.StaticServices.markerService.get().read({ resource: model.uri }).filter(function (m) {
                return range_1.Range.areIntersectingOrTouching(m, range);
            });
            return provider.provideCodeActions(model, range, { markers: markers }, token);
        }
    });
}
exports.registerCodeActionProvider = registerCodeActionProvider;
/**
 * Register a formatter that can handle only entire models.
 */
function registerDocumentFormattingEditProvider(languageId, provider) {
    return modes.DocumentFormattingEditProviderRegistry.register(languageId, provider);
}
exports.registerDocumentFormattingEditProvider = registerDocumentFormattingEditProvider;
/**
 * Register a formatter that can handle a range inside a model.
 */
function registerDocumentRangeFormattingEditProvider(languageId, provider) {
    return modes.DocumentRangeFormattingEditProviderRegistry.register(languageId, provider);
}
exports.registerDocumentRangeFormattingEditProvider = registerDocumentRangeFormattingEditProvider;
/**
 * Register a formatter than can do formatting as the user types.
 */
function registerOnTypeFormattingEditProvider(languageId, provider) {
    return modes.OnTypeFormattingEditProviderRegistry.register(languageId, provider);
}
exports.registerOnTypeFormattingEditProvider = registerOnTypeFormattingEditProvider;
/**
 * Register a link provider that can find links in text.
 */
function registerLinkProvider(languageId, provider) {
    return modes.LinkProviderRegistry.register(languageId, provider);
}
exports.registerLinkProvider = registerLinkProvider;
/**
 * Register a completion item provider (use by e.g. suggestions).
 */
function registerCompletionItemProvider(languageId, provider) {
    var adapter = new SuggestAdapter(provider);
    return modes.SuggestRegistry.register(languageId, {
        triggerCharacters: provider.triggerCharacters,
        provideCompletionItems: function (model, position, token) {
            return adapter.provideCompletionItems(model, position, token);
        },
        resolveCompletionItem: function (model, position, suggestion, token) {
            return adapter.resolveCompletionItem(model, position, suggestion, token);
        }
    });
}
exports.registerCompletionItemProvider = registerCompletionItemProvider;
/**
 * Completion item kinds.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind[CompletionItemKind["Text"] = 0] = "Text";
    CompletionItemKind[CompletionItemKind["Method"] = 1] = "Method";
    CompletionItemKind[CompletionItemKind["Function"] = 2] = "Function";
    CompletionItemKind[CompletionItemKind["Constructor"] = 3] = "Constructor";
    CompletionItemKind[CompletionItemKind["Field"] = 4] = "Field";
    CompletionItemKind[CompletionItemKind["Variable"] = 5] = "Variable";
    CompletionItemKind[CompletionItemKind["Class"] = 6] = "Class";
    CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
    CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
    CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
    CompletionItemKind[CompletionItemKind["Unit"] = 10] = "Unit";
    CompletionItemKind[CompletionItemKind["Value"] = 11] = "Value";
    CompletionItemKind[CompletionItemKind["Enum"] = 12] = "Enum";
    CompletionItemKind[CompletionItemKind["Keyword"] = 13] = "Keyword";
    CompletionItemKind[CompletionItemKind["Snippet"] = 14] = "Snippet";
    CompletionItemKind[CompletionItemKind["Color"] = 15] = "Color";
    CompletionItemKind[CompletionItemKind["File"] = 16] = "File";
    CompletionItemKind[CompletionItemKind["Reference"] = 17] = "Reference";
    CompletionItemKind[CompletionItemKind["Folder"] = 18] = "Folder";
})(CompletionItemKind = exports.CompletionItemKind || (exports.CompletionItemKind = {}));
function convertKind(kind) {
    switch (kind) {
        case CompletionItemKind.Method: return 'method';
        case CompletionItemKind.Function: return 'function';
        case CompletionItemKind.Constructor: return 'constructor';
        case CompletionItemKind.Field: return 'field';
        case CompletionItemKind.Variable: return 'variable';
        case CompletionItemKind.Class: return 'class';
        case CompletionItemKind.Interface: return 'interface';
        case CompletionItemKind.Module: return 'module';
        case CompletionItemKind.Property: return 'property';
        case CompletionItemKind.Unit: return 'unit';
        case CompletionItemKind.Value: return 'value';
        case CompletionItemKind.Enum: return 'enum';
        case CompletionItemKind.Keyword: return 'keyword';
        case CompletionItemKind.Snippet: return 'snippet';
        case CompletionItemKind.Text: return 'text';
        case CompletionItemKind.Color: return 'color';
        case CompletionItemKind.File: return 'file';
        case CompletionItemKind.Reference: return 'reference';
        case CompletionItemKind.Folder: return 'folder';
    }
    return 'property';
}
var SuggestAdapter = (function () {
    function SuggestAdapter(provider) {
        this._provider = provider;
    }
    SuggestAdapter.from = function (item, position, wordStartPos) {
        var suggestion = {
            _actual: item,
            label: item.label,
            insertText: item.label,
            type: convertKind(item.kind),
            detail: item.detail,
            documentation: item.documentation,
            sortText: item.sortText,
            filterText: item.filterText,
            snippetType: 'internal'
        };
        var editRange = item.textEdit ? item.textEdit.range : item.range;
        if (editRange) {
            var isSingleLine = (editRange.startLineNumber === editRange.endLineNumber);
            // invalid text edit
            if (!isSingleLine || editRange.startLineNumber !== position.lineNumber) {
                console.warn('INVALID range, must be single line and on the same line');
                return null;
            }
            // insert the text of the edit and create a dedicated
            // suggestion-container with overwrite[Before|After]
            suggestion.overwriteBefore = position.column - editRange.startColumn;
            suggestion.overwriteAfter = editRange.endColumn - position.column;
        }
        else {
            suggestion.overwriteBefore = position.column - wordStartPos.column;
            suggestion.overwriteAfter = 0;
        }
        if (item.textEdit) {
            suggestion.insertText = item.textEdit.text;
        }
        else if (typeof item.insertText === 'object' && typeof item.insertText.value === 'string') {
            suggestion.insertText = item.insertText.value;
            suggestion.snippetType = 'textmate';
        }
        else if (typeof item.insertText === 'string') {
            suggestion.insertText = item.insertText;
        }
        return suggestion;
    };
    SuggestAdapter.prototype.provideCompletionItems = function (model, position, token) {
        return async_1.toThenable(this._provider.provideCompletionItems(model, position, token)).then(function (value) {
            var result = {
                suggestions: []
            };
            // default text edit start
            var wordStartPos = position;
            var word = model.getWordUntilPosition(position);
            if (word) {
                wordStartPos = new position_1.Position(wordStartPos.lineNumber, word.startColumn);
            }
            var list;
            if (Array.isArray(value)) {
                list = {
                    items: value,
                    isIncomplete: false
                };
            }
            else if (typeof value === 'object' && Array.isArray(value.items)) {
                list = value;
                result.incomplete = list.isIncomplete;
            }
            else if (!value) {
                // undefined and null are valid results
                return undefined;
            }
            else {
                // warn about everything else
                console.warn('INVALID result from completion provider. expected CompletionItem-array or CompletionList but got:', value);
            }
            for (var i = 0; i < list.items.length; i++) {
                var item = list.items[i];
                var suggestion = SuggestAdapter.from(item, position, wordStartPos);
                if (suggestion) {
                    result.suggestions.push(suggestion);
                }
            }
            return result;
        });
    };
    SuggestAdapter.prototype.resolveCompletionItem = function (model, position, suggestion, token) {
        if (typeof this._provider.resolveCompletionItem !== 'function') {
            return winjs_base_1.TPromise.as(suggestion);
        }
        var item = suggestion._actual;
        if (!item) {
            return winjs_base_1.TPromise.as(suggestion);
        }
        return async_1.toThenable(this._provider.resolveCompletionItem(item, token)).then(function (resolvedItem) {
            var wordStartPos = position;
            var word = model.getWordUntilPosition(position);
            if (word) {
                wordStartPos = new position_1.Position(wordStartPos.lineNumber, word.startColumn);
            }
            return SuggestAdapter.from(resolvedItem, position, wordStartPos);
        });
    };
    return SuggestAdapter;
}());
/**
 * @internal
 */
function createMonacoLanguagesAPI() {
    return {
        register: register,
        getLanguages: getLanguages,
        onLanguage: onLanguage,
        // provider methods
        setLanguageConfiguration: setLanguageConfiguration,
        setTokensProvider: setTokensProvider,
        setMonarchTokensProvider: setMonarchTokensProvider,
        registerReferenceProvider: registerReferenceProvider,
        registerWorkspaceReferenceProvider: registerWorkspaceReferenceProvider,
        registerRenameProvider: registerRenameProvider,
        registerCompletionItemProvider: registerCompletionItemProvider,
        registerSignatureHelpProvider: registerSignatureHelpProvider,
        registerHoverProvider: registerHoverProvider,
        registerDocumentSymbolProvider: registerDocumentSymbolProvider,
        registerDocumentHighlightProvider: registerDocumentHighlightProvider,
        registerDefinitionProvider: registerDefinitionProvider,
        registerImplementationProvider: registerImplementationProvider,
        registerTypeDefinitionProvider: registerTypeDefinitionProvider,
        registerCodeLensProvider: registerCodeLensProvider,
        registerCodeActionProvider: registerCodeActionProvider,
        registerDocumentFormattingEditProvider: registerDocumentFormattingEditProvider,
        registerDocumentRangeFormattingEditProvider: registerDocumentRangeFormattingEditProvider,
        registerOnTypeFormattingEditProvider: registerOnTypeFormattingEditProvider,
        registerLinkProvider: registerLinkProvider,
        // enums
        DocumentHighlightKind: modes.DocumentHighlightKind,
        CompletionItemKind: CompletionItemKind,
        SymbolKind: modes.SymbolKind,
        IndentAction: languageConfiguration_1.IndentAction,
    };
}
exports.createMonacoLanguagesAPI = createMonacoLanguagesAPI;
