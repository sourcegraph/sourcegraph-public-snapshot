/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
'use strict';
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var nls = require("vs/nls");
var errors_1 = require("vs/base/common/errors");
var stopwatch_1 = require("vs/base/common/stopwatch");
var timer = require("vs/base/common/timer");
var editorCommon = require("vs/editor/common/editorCommon");
var textModel_1 = require("vs/editor/common/model/textModel");
var tokenIterator_1 = require("vs/editor/common/model/tokenIterator");
var modes_1 = require("vs/editor/common/modes");
var nullMode_1 = require("vs/editor/common/modes/nullMode");
var supports_1 = require("vs/editor/common/modes/supports");
var richEditBrackets_1 = require("vs/editor/common/modes/supports/richEditBrackets");
var modeTransition_1 = require("vs/editor/common/core/modeTransition");
var tokensBinaryEncoding_1 = require("vs/editor/common/model/tokensBinaryEncoding");
var languageConfigurationRegistry_1 = require("vs/editor/common/modes/languageConfigurationRegistry");
var token_1 = require("vs/editor/common/core/token");
var wordHelper_1 = require("vs/editor/common/model/wordHelper");
var Mode = (function () {
    function Mode(languageId) {
        this._languageId = languageId;
    }
    Mode.prototype.getId = function () {
        return this._languageId;
    };
    return Mode;
}());
var ModelTokensChangedEventBuilder = (function () {
    function ModelTokensChangedEventBuilder() {
        this._ranges = [];
    }
    ModelTokensChangedEventBuilder.prototype.registerChangedTokens = function (lineNumber) {
        var ranges = this._ranges;
        var rangesLength = ranges.length;
        var previousRange = rangesLength > 0 ? ranges[rangesLength - 1] : null;
        if (previousRange && previousRange.toLineNumber === lineNumber - 1) {
            // extend previous range
            previousRange.toLineNumber++;
        }
        else {
            // insert new range
            ranges[rangesLength] = {
                fromLineNumber: lineNumber,
                toLineNumber: lineNumber
            };
        }
    };
    ModelTokensChangedEventBuilder.prototype.build = function () {
        if (this._ranges.length === 0) {
            return null;
        }
        return {
            ranges: this._ranges
        };
    };
    return ModelTokensChangedEventBuilder;
}());
var TextModelWithTokens = (function (_super) {
    __extends(TextModelWithTokens, _super);
    function TextModelWithTokens(allowedEventTypes, rawText, languageId) {
        var _this;
        allowedEventTypes.push(editorCommon.EventType.ModelTokensChanged);
        allowedEventTypes.push(editorCommon.EventType.ModelModeChanged);
        _this = _super.call(this, allowedEventTypes, rawText) || this;
        _this._languageId = languageId || nullMode_1.NULL_MODE_ID;
        _this._tokenizationListener = modes_1.TokenizationRegistry.onDidChange(function (e) {
            if (e.languageId !== _this._languageId) {
                return;
            }
            _this._resetTokenizationState();
            _this.emitModelTokensChangedEvent({
                ranges: [{
                        fromLineNumber: 1,
                        toLineNumber: _this.getLineCount()
                    }]
            });
        });
        _this._tokensInflatorMap = null;
        _this._invalidLineStartIndex = 0;
        _this._lastState = null;
        _this._revalidateTokensTimeout = -1;
        _this._resetTokenizationState();
        return _this;
    }
    TextModelWithTokens.prototype.dispose = function () {
        this._tokenizationListener.dispose();
        this._clearTimers();
        this._lastState = null;
        this._tokensInflatorMap = null;
        _super.prototype.dispose.call(this);
    };
    TextModelWithTokens.prototype._shouldAutoTokenize = function () {
        return false;
    };
    TextModelWithTokens.prototype._resetValue = function (newValue) {
        _super.prototype._resetValue.call(this, newValue);
        // Cancel tokenization, clear all tokens and begin tokenizing
        this._resetTokenizationState();
    };
    TextModelWithTokens.prototype._resetTokenizationState = function () {
        this._clearTimers();
        for (var i = 0; i < this._lines.length; i++) {
            this._lines[i].resetTokenizationState();
        }
        this._tokenizationSupport = null;
        if (!this.isTooLargeForHavingAMode()) {
            this._tokenizationSupport = modes_1.TokenizationRegistry.get(this._languageId);
        }
        if (this._tokenizationSupport) {
            var initialState = null;
            try {
                initialState = this._tokenizationSupport.getInitialState();
            }
            catch (e) {
                e.friendlyMessage = TextModelWithTokens.MODE_TOKENIZATION_FAILED_MSG;
                errors_1.onUnexpectedError(e);
                this._tokenizationSupport = null;
            }
            if (initialState) {
                this._lines[0].setState(initialState);
            }
        }
        this._lastState = null;
        this._tokensInflatorMap = new tokensBinaryEncoding_1.TokensInflatorMap(this.getModeId());
        this._invalidLineStartIndex = 0;
        this._beginBackgroundTokenization();
    };
    TextModelWithTokens.prototype._clearTimers = function () {
        if (this._revalidateTokensTimeout !== -1) {
            clearTimeout(this._revalidateTokensTimeout);
            this._revalidateTokensTimeout = -1;
        }
    };
    TextModelWithTokens.prototype._withModelTokensChangedEventBuilder = function (callback) {
        var eventBuilder = new ModelTokensChangedEventBuilder();
        var result = callback(eventBuilder);
        if (!this._isDisposing) {
            var e = eventBuilder.build();
            if (e) {
                this.emit(editorCommon.EventType.ModelTokensChanged, e);
            }
        }
        return result;
    };
    TextModelWithTokens.prototype.getLineTokens = function (lineNumber, inaccurateTokensAcceptable) {
        var _this = this;
        if (inaccurateTokensAcceptable === void 0) { inaccurateTokensAcceptable = false; }
        if (lineNumber < 1 || lineNumber > this.getLineCount()) {
            throw new Error('Illegal value ' + lineNumber + ' for `lineNumber`');
        }
        if (!inaccurateTokensAcceptable) {
            this._withModelTokensChangedEventBuilder(function (eventBuilder) {
                _this._updateTokensUntilLine(eventBuilder, lineNumber, true);
            });
        }
        return this._lines[lineNumber - 1].getTokens(this._tokensInflatorMap);
    };
    TextModelWithTokens.prototype.getMode = function () {
        return new Mode(this._languageId);
    };
    TextModelWithTokens.prototype.getModeId = function () {
        return this.getMode().getId();
    };
    TextModelWithTokens.prototype.setMode = function (languageId) {
        if (this._languageId === languageId) {
            // There's nothing to do
            return;
        }
        var e = {
            oldMode: new Mode(this._languageId),
            newMode: new Mode(languageId)
        };
        this._languageId = languageId;
        // Cancel tokenization, clear all tokens and begin tokenizing
        this._resetTokenizationState();
        this.emitModelTokensChangedEvent({
            ranges: [{
                    fromLineNumber: 1,
                    toLineNumber: this.getLineCount()
                }]
        });
        this._emitModelModeChangedEvent(e);
    };
    TextModelWithTokens.prototype.getModeIdAtPosition = function (_lineNumber, _column) {
        var _this = this;
        if (!this._tokenizationSupport) {
            return this.getModeId();
        }
        var _a = this.validatePosition({ lineNumber: _lineNumber, column: _column }), lineNumber = _a.lineNumber, column = _a.column;
        this._withModelTokensChangedEventBuilder(function (eventBuilder) {
            _this._updateTokensUntilLine(eventBuilder, lineNumber, true);
        });
        var modeTransitions = this._lines[lineNumber - 1].getModeTransitions(this.getModeId());
        var modeTransitionIndex = modeTransition_1.ModeTransition.findIndexInSegmentsArray(modeTransitions, column - 1);
        return modeTransitions[modeTransitionIndex].modeId;
    };
    TextModelWithTokens.prototype._invalidateLine = function (lineIndex) {
        this._lines[lineIndex].isInvalid = true;
        if (lineIndex < this._invalidLineStartIndex) {
            if (this._invalidLineStartIndex < this._lines.length) {
                this._lines[this._invalidLineStartIndex].isInvalid = true;
            }
            this._invalidLineStartIndex = lineIndex;
            this._beginBackgroundTokenization();
        }
    };
    TextModelWithTokens.prototype._beginBackgroundTokenization = function () {
        var _this = this;
        if (this._shouldAutoTokenize() && this._revalidateTokensTimeout === -1) {
            this._revalidateTokensTimeout = setTimeout(function () {
                _this._revalidateTokensTimeout = -1;
                _this._revalidateTokensNow();
            }, 0);
        }
    };
    TextModelWithTokens.prototype._warmUpTokens = function () {
        // Warm up first 100 lines (if it takes less than 50ms)
        var maxLineNumber = Math.min(100, this.getLineCount());
        var toLineNumber = maxLineNumber;
        for (var lineNumber = 1; lineNumber <= maxLineNumber; lineNumber++) {
            var text = this._lines[lineNumber - 1].text;
            if (text.length >= 200) {
                // This line is over 200 chars long, so warm up without it
                toLineNumber = lineNumber - 1;
                break;
            }
        }
        this._revalidateTokensNow(toLineNumber);
        if (this._invalidLineStartIndex < this._lines.length) {
            this._beginBackgroundTokenization();
        }
    };
    TextModelWithTokens.prototype._revalidateTokensNow = function (toLineNumber) {
        var _this = this;
        if (toLineNumber === void 0) { toLineNumber = this._invalidLineStartIndex + 1000000; }
        this._withModelTokensChangedEventBuilder(function (eventBuilder) {
            var t1 = timer.start(timer.Topic.EDITOR, 'backgroundTokenization');
            toLineNumber = Math.min(_this._lines.length, toLineNumber);
            var MAX_ALLOWED_TIME = 20, fromLineNumber = _this._invalidLineStartIndex + 1, tokenizedChars = 0, currentCharsToTokenize = 0, currentEstimatedTimeToTokenize = 0, sw = stopwatch_1.StopWatch.create(false), elapsedTime;
            // Tokenize at most 1000 lines. Estimate the tokenization speed per character and stop when:
            // - MAX_ALLOWED_TIME is reached
            // - tokenizing the next line would go above MAX_ALLOWED_TIME
            for (var lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {
                elapsedTime = sw.elapsed();
                if (elapsedTime > MAX_ALLOWED_TIME) {
                    // Stop if MAX_ALLOWED_TIME is reached
                    toLineNumber = lineNumber - 1;
                    break;
                }
                // Compute how many characters will be tokenized for this line
                currentCharsToTokenize = _this._lines[lineNumber - 1].text.length;
                if (tokenizedChars > 0) {
                    // If we have enough history, estimate how long tokenizing this line would take
                    currentEstimatedTimeToTokenize = (elapsedTime / tokenizedChars) * currentCharsToTokenize;
                    if (elapsedTime + currentEstimatedTimeToTokenize > MAX_ALLOWED_TIME) {
                        // Tokenizing this line will go above MAX_ALLOWED_TIME
                        toLineNumber = lineNumber - 1;
                        break;
                    }
                }
                _this._updateTokensUntilLine(eventBuilder, lineNumber, false);
                tokenizedChars += currentCharsToTokenize;
                // Skip the lines that got tokenized
                lineNumber = Math.max(lineNumber, _this._invalidLineStartIndex + 1);
            }
            elapsedTime = sw.elapsed();
            if (_this._invalidLineStartIndex < _this._lines.length) {
                _this._beginBackgroundTokenization();
            }
            t1.stop();
        });
    };
    TextModelWithTokens.prototype._updateTokensUntilLine = function (eventBuilder, lineNumber, emitEvents) {
        if (!this._tokenizationSupport) {
            this._invalidLineStartIndex = this._lines.length;
            return;
        }
        var linesLength = this._lines.length;
        var endLineIndex = lineNumber - 1;
        var stopLineTokenizationAfter = 1000000000; // 1 billion, if a line is so long, you have other trouble :).
        // Validate all states up to and including endLineIndex
        for (var lineIndex = this._invalidLineStartIndex; lineIndex <= endLineIndex; lineIndex++) {
            var endStateIndex = lineIndex + 1;
            var r = null;
            var text = this._lines[lineIndex].text;
            try {
                // Tokenize only the first X characters
                r = this._tokenizationSupport.tokenize(this._lines[lineIndex].text, this._lines[lineIndex].getState(), 0, stopLineTokenizationAfter);
            }
            catch (e) {
                e.friendlyMessage = TextModelWithTokens.MODE_TOKENIZATION_FAILED_MSG;
                errors_1.onUnexpectedError(e);
            }
            if (r && r.tokens && r.tokens.length > 0) {
                // Cannot have a stop offset before the last token
                r.actualStopOffset = Math.max(r.actualStopOffset, r.tokens[r.tokens.length - 1].startIndex + 1);
            }
            if (r && r.actualStopOffset < text.length) {
                // Treat the rest of the line (if above limit) as one default token
                r.tokens.push(new token_1.Token(r.actualStopOffset, ''));
                // Use as end state the starting state
                r.endState = this._lines[lineIndex].getState();
            }
            if (!r) {
                r = nullMode_1.nullTokenize(this.getModeId(), text, this._lines[lineIndex].getState());
            }
            if (!r.modeTransitions) {
                r.modeTransitions = [];
            }
            if (r.modeTransitions.length === 0) {
                // Make sure there is at least the transition to the top-most mode
                r.modeTransitions.push(new modeTransition_1.ModeTransition(0, this.getModeId()));
            }
            this._lines[lineIndex].setTokens(this._tokensInflatorMap, r.tokens, r.modeTransitions);
            eventBuilder.registerChangedTokens(lineIndex + 1);
            this._lines[lineIndex].isInvalid = false;
            if (endStateIndex < linesLength) {
                if (this._lines[endStateIndex].getState() !== null && r.endState.equals(this._lines[endStateIndex].getState())) {
                    // The end state of this line remains the same
                    var nextInvalidLineIndex = lineIndex + 1;
                    while (nextInvalidLineIndex < linesLength) {
                        if (this._lines[nextInvalidLineIndex].isInvalid) {
                            break;
                        }
                        if (nextInvalidLineIndex + 1 < linesLength) {
                            if (this._lines[nextInvalidLineIndex + 1].getState() === null) {
                                break;
                            }
                        }
                        else {
                            if (this._lastState === null) {
                                break;
                            }
                        }
                        nextInvalidLineIndex++;
                    }
                    this._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, nextInvalidLineIndex);
                    lineIndex = nextInvalidLineIndex - 1; // -1 because the outer loop increments it
                }
                else {
                    this._lines[endStateIndex].setState(r.endState);
                }
            }
            else {
                this._lastState = r.endState;
            }
        }
        this._invalidLineStartIndex = Math.max(this._invalidLineStartIndex, endLineIndex + 1);
    };
    TextModelWithTokens.prototype.emitModelTokensChangedEvent = function (e) {
        if (!this._isDisposing) {
            this.emit(editorCommon.EventType.ModelTokensChanged, e);
        }
    };
    TextModelWithTokens.prototype._emitModelModeChangedEvent = function (e) {
        if (!this._isDisposing) {
            this.emit(editorCommon.EventType.ModelModeChanged, e);
        }
    };
    // Having tokens allows implementing additional helper methods
    TextModelWithTokens.prototype.getWordAtPosition = function (_position) {
        this._assertNotDisposed();
        var position = this.validatePosition(_position);
        var lineContent = this.getLineContent(position.lineNumber);
        if (this._invalidLineStartIndex <= position.lineNumber) {
            // this line is not tokenized
            return wordHelper_1.getWordAtText(position.column, languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(this.getModeId()), lineContent, 0);
        }
        var modeTransitions = this._lines[position.lineNumber - 1].getModeTransitions(this.getModeId());
        var offset = position.column - 1;
        var modeIndex = modeTransition_1.ModeTransition.findIndexInSegmentsArray(modeTransitions, offset);
        var modeStartOffset = modeTransitions[modeIndex].startIndex;
        var modeEndOffset = (modeIndex + 1 < modeTransitions.length ? modeTransitions[modeIndex + 1].startIndex : lineContent.length);
        var modeId = modeTransitions[modeIndex].modeId;
        var result = wordHelper_1.getWordAtText(position.column, languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(modeId), lineContent.substring(modeStartOffset, modeEndOffset), modeStartOffset);
        if (!result && modeIndex > 0 && modeTransitions[modeIndex].startIndex === offset) {
            // The position is right at the beginning of `modeIndex`, so try looking at `modeIndex` - 1 too
            var prevModeStartOffset = modeTransitions[modeIndex - 1].startIndex;
            var prevModeId = modeTransitions[modeIndex - 1].modeId;
            result = wordHelper_1.getWordAtText(position.column, languageConfigurationRegistry_1.LanguageConfigurationRegistry.getWordDefinition(prevModeId), lineContent.substring(prevModeStartOffset, modeStartOffset), prevModeStartOffset);
        }
        return result;
    };
    TextModelWithTokens.prototype.getWordUntilPosition = function (position) {
        var wordAtPosition = this.getWordAtPosition(position);
        if (!wordAtPosition) {
            return {
                word: '',
                startColumn: position.column,
                endColumn: position.column
            };
        }
        return {
            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),
            startColumn: wordAtPosition.startColumn,
            endColumn: position.column
        };
    };
    TextModelWithTokens.prototype.tokenIterator = function (position, callback) {
        var iter = new tokenIterator_1.TokenIterator(this, this.validatePosition(position));
        var result = callback(iter);
        iter._invalidate();
        return result;
    };
    TextModelWithTokens.prototype.findMatchingBracketUp = function (_bracket, _position) {
        var bracket = _bracket.toLowerCase();
        var position = this.validatePosition(_position);
        var modeTransitions = this._lines[position.lineNumber - 1].getModeTransitions(this.getModeId());
        var currentModeIndex = modeTransition_1.ModeTransition.findIndexInSegmentsArray(modeTransitions, position.column - 1);
        var currentMode = modeTransitions[currentModeIndex];
        var currentModeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(currentMode.modeId);
        if (!currentModeBrackets) {
            return null;
        }
        var data = currentModeBrackets.textIsBracket[bracket];
        if (!data) {
            return null;
        }
        return this._findMatchingBracketUp(data, position);
    };
    TextModelWithTokens.prototype.matchBracket = function (position) {
        return this._matchBracket(this.validatePosition(position));
    };
    TextModelWithTokens.prototype._matchBracket = function (position) {
        var lineNumber = position.lineNumber;
        var lineTokens = this._lines[lineNumber - 1].getTokens(this._tokensInflatorMap);
        var lineText = this._lines[lineNumber - 1].text;
        var currentToken = lineTokens.findTokenAtOffset(position.column - 1);
        if (!currentToken) {
            return null;
        }
        var currentModeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(currentToken.modeId);
        // check that the token is not to be ignored
        if (currentModeBrackets && !supports_1.ignoreBracketsInToken(currentToken.standardType)) {
            // limit search to not go before `maxBracketLength`
            var searchStartOffset = Math.max(currentToken.startOffset, position.column - 1 - currentModeBrackets.maxBracketLength);
            // limit search to not go after `maxBracketLength`
            var searchEndOffset = Math.min(currentToken.endOffset, position.column - 1 + currentModeBrackets.maxBracketLength);
            // first, check if there is a bracket to the right of `position`
            var foundBracket = richEditBrackets_1.BracketsUtils.findNextBracketInToken(currentModeBrackets.forwardRegex, lineNumber, lineText, position.column - 1, searchEndOffset);
            if (foundBracket && foundBracket.startColumn === position.column) {
                var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);
                foundBracketText = foundBracketText.toLowerCase();
                var r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText]);
                // check that we can actually match this bracket
                if (r) {
                    return r;
                }
            }
            // it might still be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets
            while (true) {
                var foundBracket_1 = richEditBrackets_1.BracketsUtils.findNextBracketInToken(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                if (!foundBracket_1) {
                    // there are no brackets in this text
                    break;
                }
                // check that we didn't hit a bracket too far away from position
                if (foundBracket_1.startColumn <= position.column && position.column <= foundBracket_1.endColumn) {
                    var foundBracketText = lineText.substring(foundBracket_1.startColumn - 1, foundBracket_1.endColumn - 1);
                    foundBracketText = foundBracketText.toLowerCase();
                    var r = this._matchFoundBracket(foundBracket_1, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText]);
                    // check that we can actually match this bracket
                    if (r) {
                        return r;
                    }
                }
                searchStartOffset = foundBracket_1.endColumn - 1;
            }
        }
        // If position is in between two tokens, try also looking in the previous token
        if (currentToken.hasPrev && currentToken.startOffset === position.column - 1) {
            var prevToken = currentToken.prev();
            var prevModeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(prevToken.modeId);
            // check that previous token is not to be ignored
            if (prevModeBrackets && !supports_1.ignoreBracketsInToken(prevToken.standardType)) {
                // limit search in case previous token is very large, there's no need to go beyond `maxBracketLength`
                var searchStartOffset = Math.max(prevToken.startOffset, position.column - 1 - prevModeBrackets.maxBracketLength);
                var searchEndOffset = currentToken.startOffset;
                var foundBracket = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);
                // check that we didn't hit a bracket too far away from position
                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {
                    var foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1);
                    foundBracketText = foundBracketText.toLowerCase();
                    var r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText]);
                    // check that we can actually match this bracket
                    if (r) {
                        return r;
                    }
                }
            }
        }
        return null;
    };
    TextModelWithTokens.prototype._matchFoundBracket = function (foundBracket, data, isOpen) {
        if (isOpen) {
            var matched = this._findMatchingBracketDown(data, foundBracket.getEndPosition());
            if (matched) {
                return [foundBracket, matched];
            }
        }
        else {
            var matched = this._findMatchingBracketUp(data, foundBracket.getStartPosition());
            if (matched) {
                return [foundBracket, matched];
            }
        }
        return null;
    };
    TextModelWithTokens.prototype._findMatchingBracketUp = function (bracket, position) {
        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));
        var modeId = bracket.modeId;
        var reversedBracketRegex = bracket.reversedRegex;
        var count = -1;
        for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
            var lineTokens = this._lines[lineNumber - 1].getTokens(this._tokensInflatorMap);
            var lineText = this._lines[lineNumber - 1].text;
            var currentToken = void 0;
            var searchStopOffset = void 0;
            if (lineNumber === position.lineNumber) {
                currentToken = lineTokens.findTokenAtOffset(position.column - 1);
                searchStopOffset = position.column - 1;
            }
            else {
                currentToken = lineTokens.lastToken();
                if (currentToken) {
                    searchStopOffset = currentToken.endOffset;
                }
            }
            while (currentToken) {
                if (currentToken.modeId === modeId && !supports_1.ignoreBracketsInToken(currentToken.standardType)) {
                    while (true) {
                        var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(reversedBracketRegex, lineNumber, lineText, currentToken.startOffset, searchStopOffset);
                        if (!r) {
                            break;
                        }
                        var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);
                        hitText = hitText.toLowerCase();
                        if (hitText === bracket.open) {
                            count++;
                        }
                        else if (hitText === bracket.close) {
                            count--;
                        }
                        if (count === 0) {
                            return r;
                        }
                        searchStopOffset = r.startColumn - 1;
                    }
                }
                currentToken = currentToken.prev();
                if (currentToken) {
                    searchStopOffset = currentToken.endOffset;
                }
            }
        }
        return null;
    };
    TextModelWithTokens.prototype._findMatchingBracketDown = function (bracket, position) {
        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));
        var modeId = bracket.modeId;
        var bracketRegex = bracket.forwardRegex;
        var count = 1;
        for (var lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {
            var lineTokens = this._lines[lineNumber - 1].getTokens(this._tokensInflatorMap);
            var lineText = this._lines[lineNumber - 1].text;
            var currentToken = void 0;
            var searchStartOffset = void 0;
            if (lineNumber === position.lineNumber) {
                currentToken = lineTokens.findTokenAtOffset(position.column - 1);
                searchStartOffset = position.column - 1;
            }
            else {
                currentToken = lineTokens.firstToken();
                if (currentToken) {
                    searchStartOffset = currentToken.startOffset;
                }
            }
            while (currentToken) {
                if (currentToken.modeId === modeId && !supports_1.ignoreBracketsInToken(currentToken.standardType)) {
                    while (true) {
                        var r = richEditBrackets_1.BracketsUtils.findNextBracketInToken(bracketRegex, lineNumber, lineText, searchStartOffset, currentToken.endOffset);
                        if (!r) {
                            break;
                        }
                        var hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1);
                        hitText = hitText.toLowerCase();
                        if (hitText === bracket.open) {
                            count++;
                        }
                        else if (hitText === bracket.close) {
                            count--;
                        }
                        if (count === 0) {
                            return r;
                        }
                        searchStartOffset = r.endColumn - 1;
                    }
                }
                currentToken = currentToken.next();
                if (currentToken) {
                    searchStartOffset = currentToken.startOffset;
                }
            }
        }
        return null;
    };
    TextModelWithTokens.prototype.findPrevBracket = function (_position) {
        var position = this.validatePosition(_position);
        var modeId = null;
        var modeBrackets;
        for (var lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {
            var lineTokens = this._lines[lineNumber - 1].getTokens(this._tokensInflatorMap);
            var lineText = this._lines[lineNumber - 1].text;
            var currentToken = void 0;
            var searchStopOffset = void 0;
            if (lineNumber === position.lineNumber) {
                currentToken = lineTokens.findTokenAtOffset(position.column - 1);
                searchStopOffset = position.column - 1;
            }
            else {
                currentToken = lineTokens.lastToken();
                if (currentToken) {
                    searchStopOffset = currentToken.endOffset;
                }
            }
            while (currentToken) {
                if (modeId !== currentToken.modeId) {
                    modeId = currentToken.modeId;
                    modeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(modeId);
                }
                if (modeBrackets && !supports_1.ignoreBracketsInToken(currentToken.standardType)) {
                    var r = richEditBrackets_1.BracketsUtils.findPrevBracketInToken(modeBrackets.reversedRegex, lineNumber, lineText, currentToken.startOffset, searchStopOffset);
                    if (r) {
                        return this._toFoundBracket(modeBrackets, r);
                    }
                }
                currentToken = currentToken.prev();
                if (currentToken) {
                    searchStopOffset = currentToken.endOffset;
                }
            }
        }
        return null;
    };
    TextModelWithTokens.prototype.findNextBracket = function (_position) {
        var position = this.validatePosition(_position);
        var modeId = null;
        var modeBrackets;
        for (var lineNumber = position.lineNumber, lineCount = this.getLineCount(); lineNumber <= lineCount; lineNumber++) {
            var lineTokens = this._lines[lineNumber - 1].getTokens(this._tokensInflatorMap);
            var lineText = this._lines[lineNumber - 1].text;
            var currentToken = void 0;
            var searchStartOffset = void 0;
            if (lineNumber === position.lineNumber) {
                currentToken = lineTokens.findTokenAtOffset(position.column - 1);
                searchStartOffset = position.column - 1;
            }
            else {
                currentToken = lineTokens.firstToken();
                if (currentToken) {
                    searchStartOffset = currentToken.startOffset;
                }
            }
            while (currentToken) {
                if (modeId !== currentToken.modeId) {
                    modeId = currentToken.modeId;
                    modeBrackets = languageConfigurationRegistry_1.LanguageConfigurationRegistry.getBracketsSupport(modeId);
                }
                if (modeBrackets && !supports_1.ignoreBracketsInToken(currentToken.standardType)) {
                    var r = richEditBrackets_1.BracketsUtils.findNextBracketInToken(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, currentToken.endOffset);
                    if (r) {
                        return this._toFoundBracket(modeBrackets, r);
                    }
                }
                currentToken = currentToken.next();
                if (currentToken) {
                    searchStartOffset = currentToken.startOffset;
                }
            }
        }
        return null;
    };
    TextModelWithTokens.prototype._toFoundBracket = function (modeBrackets, r) {
        if (!r) {
            return null;
        }
        var text = this.getValueInRange(r);
        text = text.toLowerCase();
        var data = modeBrackets.textIsBracket[text];
        if (!data) {
            return null;
        }
        return {
            range: r,
            open: data.open,
            close: data.close,
            isOpen: modeBrackets.textIsOpenBracket[text]
        };
    };
    return TextModelWithTokens;
}(textModel_1.TextModel));
TextModelWithTokens.MODE_TOKENIZATION_FAILED_MSG = nls.localize('mode.tokenizationSupportFailed', "The mode has failed while tokenizing the input.");
exports.TextModelWithTokens = TextModelWithTokens;
