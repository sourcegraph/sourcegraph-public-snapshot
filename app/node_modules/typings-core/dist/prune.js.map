{"version":3,"file":"prune.js","sourceRoot":"","sources":["../src/prune.ts"],"names":[],"mappings":"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","sourcesContent":["import { dirname } from 'path'\nimport Promise = require('any-promise')\nimport extend = require('xtend')\nimport { EventEmitter } from 'events'\nimport { Emitter } from './interfaces'\nimport { findConfigFile } from './utils/find'\nimport { readConfig, transformDtsFile, rmdirUntil, unlink, isFile } from './utils/fs'\nimport { normalizeResolutions, getInfoFromDependencyLocation, getDefinitionPath, getDependencyPath } from './utils/path'\nimport { ConfigJson, Dependencies } from './interfaces'\n\nexport interface PruneOptions {\n  cwd: string\n  production?: boolean\n  emitter?: Emitter\n}\n\n/**\n * Prune non-persisted type defintions.\n */\nexport function prune (options: PruneOptions): Promise<void> {\n  const { cwd, production } = options\n  const emitter = options.emitter || new EventEmitter()\n\n  return findConfigFile(cwd)\n    .then(path => {\n      const cwd = dirname(path)\n\n      return readConfig(path)\n        .then(config => {\n          return transformBundles(config, { cwd, production, emitter })\n        })\n    })\n}\n\n/**\n * Read the bundle and remove typings not in config file.\n */\nfunction transformBundles (config: ConfigJson, options: PruneOptions) {\n  const { production } = options\n  const resolutions = normalizeResolutions(config.resolution, options)\n  const dependencies = extend(config.dependencies, config.peerDependencies, production ? {} : config.devDependencies)\n  const globalDependencies = extend(config.globalDependencies, production ? {} : config.globalDevDependencies)\n\n  return Promise.all(Object.keys(resolutions).map(type => {\n    return transformBundle(resolutions[type], type, dependencies, globalDependencies, options)\n  })).then(() => undefined)\n}\n\n/**\n * Transform a bundle file and remove extra dependencies.\n */\nfunction transformBundle (\n  path: string,\n  resolution: string,\n  dependencies: Dependencies,\n  globalDependencies: Dependencies,\n  options: PruneOptions\n) {\n  const { emitter } = options\n  const rmQueue: Array<Promise<void>> = []\n  const bundle = getDefinitionPath(path)\n\n  return isFile(bundle)\n    .then(exists => {\n      // Avoid pruning an un-installed tree.\n      if (!exists) {\n        return\n      }\n\n      return transformDtsFile(bundle, typings => {\n        const infos = typings.map(x => getInfoFromDependencyLocation(x, bundle))\n        const validPaths: string[] = []\n\n        for (const { name, global, location } of infos) {\n          if (global) {\n            if (!globalDependencies.hasOwnProperty(name)) {\n              emitter.emit('prune', { name, global, resolution })\n              rmQueue.push(rmDependency({ name, global, path, emitter }))\n            } else {\n              validPaths.push(location)\n            }\n          } else {\n            if (!dependencies.hasOwnProperty(name)) {\n              emitter.emit('prune', { name, global, resolution })\n              rmQueue.push(rmDependency({ name, global, path, emitter }))\n            } else {\n              validPaths.push(location)\n            }\n          }\n        }\n\n        return validPaths\n      })\n    })\n    .then(() => Promise.all(rmQueue))\n    .then(() => undefined)\n}\n\n/**\n * Remove a dependency.\n */\nexport function rmDependency (options: { name: string, global: boolean, path: string, emitter: Emitter }) {\n  const { path, emitter } = options\n  const { directory, definition, config } = getDependencyPath(options)\n\n  // Remove files and emit warning on ENOENT.\n  function remove (path: string) {\n    return isFile(path)\n      .then(exists => {\n        if (!exists) {\n          emitter.emit('enoent', { path })\n\n          return\n        }\n\n        return unlink(path)\n      })\n  }\n\n  return Promise.all([\n    remove(config),\n    remove(definition)\n  ])\n    .then(() => rmdirUntil(directory, path))\n}\n"]}