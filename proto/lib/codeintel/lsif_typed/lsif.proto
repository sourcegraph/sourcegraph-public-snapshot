// Protobuf schema for the new "LSIF typed" format. See RFC 519 for more details:
// https://docs.google.com/document/d/1bfAZm4K2KUHCMoZiO4qFV7yZmK7wyYxI8MsEL-I6IJg/edit#heading=h.trqab8y0kufp

// Install the `buf` command-line tool to re-generate the code for this file.
// The commands to re-generate the code on macOS:
//   brew tap bufbuild/buf && brew install buf
//   go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
//   buf generate
// See https://buf.build/ for more details.

syntax = "proto3";

package lib.codeintel.lsif_typed;

option go_package = "github.com/sourcegraph/sourcegraph/lib/codeintel/lsif_typed/";

// LsifValue defines a single LSIF value that. An LSIF index is a stream of values.
message LsifValues {
    repeated LsifValue values = 1;
}

message LsifValue {
  oneof value {
    // Metadata about this index. Must appear once (and only once) at the start of this index.
    Metadata metadata = 1;
    // Packages that are either referenced from this index or the packages that are defined by this index.
    Package package = 2;
    Document document = 3;
    // External monikers that are referenced but not defined in this index.
    Moniker moniker = 4;
  }
}

message Metadata {
  enum PositionEncoding {
      POSITION_ENCODING_UNSPECIFIED = 0;
      POSITION_ENCODING_UTF16 = 1;
  }
  ToolInfo toolInfo = 1;
  string projectRoot = 2;
  PositionEncoding positionEncoding = 3;
}

message ToolInfo {
    string name = 1;
    string version = 2;
}

// Position defines a single offset in a source file.
message Position {
  // 0-based line number in the source file. Editors typically use 1-based line
  // numbers so make sure to increment this number before displaying it in a UI.
  // References the last line in the source if this number exceeds the actual number
  // of lines in the source file.
  int32 line = 1;
  // 0-based column number of the line assuming UTF-8 string encoding.
  // References the last character in this line if this number exceeds the
  // actual number of characters in line.
  int32 character = 2;
}

// Range defines the slice of a source file between two offset positions.
message Range {
  // The beginning of this range.
  Position start = 1;
  // The end of this range. Must appear later in the file than the start position.
  Position end = 2;
}

// Moniker defines a symbol, such as a function or an interface.
message Moniker {
  enum Unique {
      UNIQUE_UNSPECIFIED = 0;
      UNIQUE_DOCUMENT = 1;
      UNIQUE_GLOBAL = 2;
  }
  // The identifier of this moniker, which can be referenced from
  // MonikerOccurence. An empty id means this moniker can be ignored.
  // Globally unique monikers must encode the `package_id` in order to
  // permit incremental indexing. Bumping up the version of an external
  // dependency should change moniker IDs that reference symbols from that
  // package.
  string id = 1;
  // Determines whether this moniker is local to a single document or if can be
  // referenced from multiple documents.
  // Document monikers (`Document.monikers`) can be either local or global.
  // Toplevel monikers (`LsifValue.value`) must be global.
  Unique unique = 2;
  // (optional, but strongly recommended) The markdown-formatted documentation
  // for this moniker. This field is repeated to allow different kinds of
  // documentation.  For example, it's nice to include both the signature of a
  // method (parameters and return type) along with the accompanying docstring.
  repeated string markdown_hover = 3;
  // (optional) Links to the original package that defines this moniker to
  // enable navigation across different LSIF indexes (whether they come from
  // different projects or git repositories). This field must be non-empty for
  // toplevel monikers (`LsifValue.value`).
  string package_id = 4;
  // (optional) Monikers that are "implemented" by this moniker. For example,
  // the moniker of a TypeScript or Java class that implements an interface
  // should list the interface here.
  repeated string implementation_monikers = 5;
  // (optional) Monikers that should be included together with this moniker when
  // resolving "find references".  For example, the moniker of a TypeScript or
  // Java method that implements an interface method should list the interface
  // method here.
  repeated string reference_monikers = 6;
}

// MonikerOccurrence describes the appearance of a moniker at a given range in a
// source file.
message MonikerOccurrence {
  enum Role {
    ROLE_UNSPECIFIED = 0;
    ROLE_DEFINITION = 1;
    ROLE_REFERENCE = 2;
  }
  enum Highlight {
      HIGHLIGHT_UNSPECIFIED = 0;
      HIGHLIGHT_STRING_LITERAL = 1;
      HIGHLIGHT_NUMERIC_LITERAL = 2;
      HIGHLIGHT_IDENTIFIER = 3;
      HIGHLIGHT_METHOD_IDENTIFIER = 4;
      HIGHLIGHT_TYPE_IDENTIFIER = 5;
      HIGHLIGHT_TERM_IDENTIFIER = 6;
      HIGHLIGHT_LOCAL_IDENTIFIER = 7;
      HIGHLIGHT_SHADED_IDENTIFIER = 8;
      HIGHLIGHT_PACKAGE_IDENTIFIER = 9;
  }
  // Reference to the `Moniker.id` field.
  string moniker_id = 1;
  // The start/end range where this moniker appears.
  Range range = 2;
  repeated int32 range_compressed = 6;
  // Is this the location where the moniker is defined or referenced?
  Role role = 3;
  // (optional) Markdown-formatted documentation for this specific range.  If
  // empty, the `Moniker.markdown_hover` field is used instead. One example
  // where this field might be useful is when the moniker represents a generic
  // function (with abstract type parameters such as `List<T>`) and at this
  // occurrence we know the exact values (such as `List<String>`).
  repeated string markdown_hover = 4;
  // What syntax highlighting class should be used for this range.
  Highlight highlight = 5;
}

// Document defines information about a particular source file.
message Document {
  // URI-formatted absolute path of the source file on disk (example "file:///path/to/some/file/on/disk.ts").
  string uri = 1;
  // Moniker occurrences that appear in this file.
  repeated MonikerOccurrence occurrences = 2;
  // Monikers that are defined within this document.
  repeated Moniker monikers = 3;
}

// Package defines a publishable artifact such as an npm package, Docker
// container, JVM dependency, or a Cargo crate.
message Package {
  // The unique identifier of this package that can be referenced from
  // `Moniker.package_id`.  This ID is not intended to be displayed to humans,
  // but it's recommended to use a human-readable format to aid with debugging.
  string id = 1;
  // Name of this package, for example "@types/react" or "com.google.guava:guava".
  string name = 2;
  // Version of this package, for example "0.1.0" or "2.1.5".
  string version = 3;
  // Package manager, for example "npm", "maven" or "cargo".
  string manager = 4;
}

