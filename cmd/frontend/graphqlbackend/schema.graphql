#! Run this before committing changes to this file
#! go generate github.com/sourcegraph/sourcegraph/cmd/frontend/graphqlbackend
#! This will happen automatically if you are running ./dev/start.sh
#!
#! Lines that begin with #! are treated as internal comments. They are stripped
#! from the schema before the documentation for each field is generated.
#!
#! See docs/api.md for guidance on schema evolution.
#!
schema {
    query: Query
    mutation: Mutation
}

# Represents a null return value.
type EmptyResponse {
    # A dummy null value.
    alwaysNil: String
}

# An object with an ID.
interface Node {
    # The ID of the node.
    id: ID!
}

# A valid JSON value.
scalar JSONValue

# A string that contains valid JSON, with additional support for //-style comments and trailing commas.
scalar JSONCString

# A mutation.
type Mutation {
    # Creates a list of Changesets of a given repository in a code host (e.g.
    # pull request on GitHub). If a changeset with the given input already
    # exists, it's returned instead of a new entry being added to the database.
    createChangesets(input: [CreateChangesetInput!]!): [ExternalChangeset!]!
    # Adds a list of Changesets to a Campaign.
    # The campaign must not have a campaign plan.
    addChangesetsToCampaign(campaign: ID!, changesets: [ID!]!): Campaign!
    # Create a campaign in a namespace. The newly created campaign is returned.
    createCampaign(input: CreateCampaignInput!): Campaign!
    # Create a campaign plan from patches (in unified diff format) that are computed by the caller.
    #
    # To create the campaign, call createCampaign with the returned CampaignPlan.id in the
    # CreateCampaignInput.plan field.
    createCampaignPlanFromPatches(
        # A list of patches (diffs) to apply to repositories (in new branches) when a campaign is
        # created from this campaign plan.
        patches: [CampaignPlanPatch!]!
    ): CampaignPlan!
    # Updates a campaign.
    updateCampaign(input: UpdateCampaignInput!): Campaign!
    # Retries creating changesets of the campaign plan that could not be successfully created on the code host.
    # Retrying will clear the errors list of a campaign and change its state back to CREATING_CHANGESETS.
    retryCampaign(campaign: ID!): Campaign!
    # Deletes a campaign.
    deleteCampaign(
        campaign: ID!
        # Whether to close the changesets associated with this campaign on their
        # respective codehosts, where "close" means the appropriate final state
        # on the codehost (e.g. "declined" on Bitbucket Server).
        closeChangesets: Boolean = false
    ): EmptyResponse
    # Closes a campaign.
    # Closing a campaign sets the Campaign's ClosedAt timestamp to the current
    # time and, if closeChangesets = true, closes associated changesets on the
    # codehosts.
    closeCampaign(
        campaign: ID!
        # Whether to close the changesets associated with this campaign on their
        # respective codehosts, where "close" means the appropriate final state
        # on the codehost (e.g. "declined" on Bitbucket Server).
        closeChangesets: Boolean = false
    ): Campaign!
    # Publishes the Campaign by turning its changesetPlans into changesets on
    # the codehosts.
    # The Campaign.draft field will be set to false and Campaign.status will
    # update according to the progress of turning the changesetPlans into
    # changesets.
    publishCampaign(campaign: ID!): Campaign!
    # Creates an ExternalChangeset on the codehost asynchronously.
    # The ChangesetPlan has to belong to a CampaignPlan that has been attached
    # to a Campaign. Otherwise an error is returned.
    # Since this is an asynchronous operation, the Campaign.status field can be
    # used to keep track of progress.
    publishChangeset(changesetPlan: ID!): EmptyResponse!
    # Enqueues the given changeset for high-priority syncing.
    syncChangeset(changeset: ID!): EmptyResponse!

    # Updates the user profile information for the user with the given ID.
    #
    # Only the user and site admins may perform this mutation.
    updateUser(user: ID!, username: String, displayName: String, avatarURL: String): EmptyResponse!
    # Creates an organization. The caller is added as a member of the newly created organization.
    #
    # Only authenticated users may perform this mutation.
    createOrganization(name: String!, displayName: String): Org!
    # Updates an organization.
    #
    # Only site admins and any member of the organization may perform this mutation.
    updateOrganization(id: ID!, displayName: String): Org!
    # Deletes an organization. Only site admins may perform this mutation.
    deleteOrganization(organization: ID!): EmptyResponse
    # Adds a external service. Only site admins may perform this mutation.
    addExternalService(input: AddExternalServiceInput!): ExternalService!
    # Updates a external service. Only site admins may perform this mutation.
    updateExternalService(input: UpdateExternalServiceInput!): ExternalService!
    # Delete an external service. Only site admins may perform this mutation.
    deleteExternalService(externalService: ID!): EmptyResponse!
    # DEPRECATED: All repositories are accessible or deleted. To prevent a
    # repository from being accessed on Sourcegraph add it to the external
    # service exclude configuration. This mutation will be removed in 3.6.
    #
    # Enables or disables a repository. A disabled repository is only accessible
    # to site admins and never appears in search results.
    #
    # Only site admins may perform this mutation.
    setRepositoryEnabled(repository: ID!, enabled: Boolean!): EmptyResponse
        @deprecated(reason: "update external service exclude setting.")
    # Tests the connection to a mirror repository's original source repository. This is an
    # expensive and slow operation, so it should only be used for interactive diagnostics.
    #
    # Only site admins may perform this mutation.
    checkMirrorRepositoryConnection(
        # The ID of the existing repository whose mirror to check.
        repository: ID
        # The name of a repository whose mirror to check. If the name is provided, the repository need not be added
        # to the site (but the site configuration must define a code host that knows how to handle the name).
        name: String
    ): CheckMirrorRepositoryConnectionResult!
    # Schedule the mirror repository to be updated from its original source repository. Updating
    # occurs automatically, so this should not normally be needed.
    #
    # Only site admins may perform this mutation.
    updateMirrorRepository(
        # The mirror repository to update.
        repository: ID!
    ): EmptyResponse!
    # DEPRECATED: All repositories are scheduled for updates periodically. This
    # mutation will be removed in 3.6.
    #
    # Schedules all repositories to be updated from their original source
    # repositories. Updating occurs automatically, so this should not normally
    # be needed.
    #
    # Only site admins may perform this mutation.
    updateAllMirrorRepositories: EmptyResponse! @deprecated(reason: "syncer ensures all repositories are up to date.")
    # Creates a new user account.
    #
    # Only site admins may perform this mutation.
    createUser(
        # The new user's username.
        username: String!
        # The new user's optional email address. If given, it is marked as verified.
        email: String
    ): CreateUserResult!
    # Randomize a user's password so that they need to reset it before they can sign in again.
    #
    # Only site admins may perform this mutation.
    randomizeUserPassword(user: ID!): RandomizeUserPasswordResult!
    # Adds an email address to the user's account. The email address will be marked as unverified until the user
    # has followed the email verification process.
    #
    # Only the user and site admins may perform this mutation.
    addUserEmail(user: ID!, email: String!): EmptyResponse!
    # Removes an email address from the user's account.
    #
    # Only the user and site admins may perform this mutation.
    removeUserEmail(user: ID!, email: String!): EmptyResponse!
    # Manually set the verification status of a user's email, without going through the normal verification process
    # (of clicking on a link in the email with a verification code).
    #
    # Only site admins may perform this mutation.
    setUserEmailVerified(user: ID!, email: String!, verified: Boolean!): EmptyResponse!
    # Deletes a user account. Only site admins may perform this mutation.
    #
    # If hard == true, a hard delete is performed. By default, deletes are
    # 'soft deletes' and could theoretically be undone with manual DB commands.
    # If a hard delete is performed, the data is truly removed from the
    # database and deletion can NEVER be undone.
    #
    # Data that is deleted as part of this operation:
    #
    # - All user data (access tokens, email addresses, external account info, survey responses, etc)
    # - Organization membership information (which organizations the user is a part of, any invitations created by or targeting the user).
    # - Sourcegraph extensions published by the user.
    # - User, Organization, or Global settings authored by the user.
    # - Discussion threads and comments created by the user.
    #
    deleteUser(user: ID!, hard: Boolean): EmptyResponse
    # Updates the current user's password. The oldPassword arg must match the user's current password.
    updatePassword(oldPassword: String!, newPassword: String!): EmptyResponse
    # Creates an access token that grants the privileges of the specified user (referred to as the access token's
    # "subject" user after token creation). The result is the access token value, which the caller is responsible
    # for storing (it is not accessible by Sourcegraph after creation).
    #
    # The supported scopes are:
    #
    # - "user:all": Full control of all resources accessible to the user account.
    # - "site-admin:sudo": Ability to perform any action as any other user. (Only site admins may create tokens
    #   with this scope.)
    #
    # Only the user or site admins may perform this mutation.
    createAccessToken(user: ID!, scopes: [String!]!, note: String!): CreateAccessTokenResult!
    # Deletes and immediately revokes the specified access token, specified by either its ID or by the token
    # itself.
    #
    # Only site admins or the user who owns the token may perform this mutation.
    deleteAccessToken(byID: ID, byToken: String): EmptyResponse!
    # Deletes the association between an external account and its Sourcegraph user. It does NOT delete the external
    # account on the external service where it resides.
    #
    # Only site admins or the user who is associated with the external account may perform this mutation.
    deleteExternalAccount(externalAccount: ID!): EmptyResponse!
    # Invite the user with the given username to join the organization. The invited user account must already
    # exist.
    #
    # Only site admins and any organization member may perform this mutation.
    inviteUserToOrganization(organization: ID!, username: String!): InviteUserToOrganizationResult!
    # Accept or reject an existing organization invitation.
    #
    # Only the recipient of the invitation may perform this mutation.
    respondToOrganizationInvitation(
        # The organization invitation.
        organizationInvitation: ID!
        # The response to the invitation.
        responseType: OrganizationInvitationResponseType!
    ): EmptyResponse!
    # Resend the notification about an organization invitation to the recipient.
    #
    # Only site admins and any member of the organization may perform this mutation.
    resendOrganizationInvitationNotification(
        # The organization invitation.
        organizationInvitation: ID!
    ): EmptyResponse!
    # Revoke an existing organization invitation.
    #
    # If the invitation has been accepted or rejected, it may no longer be revoked. After an
    # invitation is revoked, the recipient may not accept or reject it. Both cases yield an error.
    #
    # Only site admins and any member of the organization may perform this mutation.
    revokeOrganizationInvitation(
        # The organization invitation.
        organizationInvitation: ID!
    ): EmptyResponse!
    # Immediately add a user as a member to the organization, without sending an invitation email.
    #
    # Only site admins may perform this mutation. Organization members may use the inviteUserToOrganization
    # mutation to invite users.
    addUserToOrganization(organization: ID!, username: String!): EmptyResponse!
    # Removes a user as a member from an organization.
    #
    # Only site admins and any member of the organization may perform this mutation.
    removeUserFromOrganization(user: ID!, organization: ID!): EmptyResponse
    # Adds or removes a tag on a user.
    #
    # Tags are used internally by Sourcegraph as feature flags for experimental features.
    #
    # Only site admins may perform this mutation.
    setTag(
        # The ID of the user whose tags to set.
        #
        # (This parameter is named "node" to make it easy to support tagging other types of nodes
        # other than users in the future.)
        node: ID!
        # The tag to set.
        tag: String!
        # The desired state of the tag on the user (whether to add or remove): true to add, false to
        # remove.
        present: Boolean!
    ): EmptyResponse!
    # Adds a Phabricator repository to Sourcegraph.
    addPhabricatorRepo(
        # The callsign, for example "MUX".
        callsign: String!
        # The name, for example "github.com/gorilla/mux".
        name: String
        # An alias for name. DEPRECATED: use name instead.
        uri: String
        # The URL to the phabricator instance (e.g. http://phabricator.sgdev.org).
        url: String!
    ): EmptyResponse
    # Resolves a revision for a given diff from Phabricator.
    resolvePhabricatorDiff(
        # The name of the repository that the diff is based on.
        repoName: String!
        # The ID of the diff on Phabricator.
        diffID: ID!
        # The base revision this diff is based on.
        baseRev: String!
        # The raw contents of the diff from Phabricator.
        # Required if Sourcegraph doesn't have a Conduit API token.
        patch: String
        # The description of the diff. This will be used as the commit message.
        description: String
        # The name of author of the diff.
        authorName: String
        # The author's email.
        authorEmail: String
        # When the diff was created.
        date: String
    ): GitCommit
    # Logs a user event.
    logUserEvent(event: UserEvent!, userCookieID: String!): EmptyResponse @deprecated(reason: "use logEvent instead")
    # Logs an event.
    logEvent(
        # The name of the event.
        event: String!
        # The randomly generated unique user ID stored in a browser cookie.
        userCookieID: String!
        # The URL when the event was logged.
        url: String!
        # The source of the event.
        source: EventSource!
        # The additional argument information.
        argument: String
    ): EmptyResponse
    # Sends a test notification for the saved search. Be careful: this will send a notifcation (email and other
    # types of notifications, if configured) to all subscribers of the saved search, which could be bothersome.
    #
    # Only subscribers to this saved search may perform this action.
    sendSavedSearchTestNotification(
        # ID of the saved search.
        id: ID!
    ): EmptyResponse
    # All mutations that update settings (global, organization, and user settings) are under this field.
    #
    # Only the settings subject whose settings are being mutated (and site admins) may perform this mutation.
    #
    # This mutation only affects global, organization, and user settings, not site configuration. For site
    # configuration (which is a separate set of configuration properties from global/organization/user settings),
    # use updateSiteConfiguration.
    settingsMutation(input: SettingsMutationGroupInput!): SettingsMutation
    # DEPRECATED: Use settingsMutation instead. This field is a deprecated alias for settingsMutation and will be
    # removed in a future release.
    configurationMutation(input: SettingsMutationGroupInput!): SettingsMutation
        @deprecated(reason: "use settingsMutation instead")
    # Updates the site configuration. Returns whether or not a restart is required for the update to be applied.
    #
    # Only site admins may perform this mutation.
    updateSiteConfiguration(
        # The last ID of the site configuration that is known by the client, to
        # prevent race conditions. An error will be returned if someone else
        # has already written a new update.
        lastID: Int!
        # A JSON object containing the entire site configuration. The previous site configuration will be replaced
        # with this new value.
        input: String!
    ): Boolean!
    # Manages discussions.
    discussions: DiscussionsMutation
    # Sets whether the user with the specified user ID is a site admin.
    #
    # Only site admins may perform this mutation.
    #!
    #! ðŸš¨ SECURITY: Only trusted users should be given site admin permissions.
    #! Site admins have full access to the site configuration and other
    #! sensitive data, and they can perform destructive actions such as
    #! restarting the site.
    setUserIsSiteAdmin(userID: ID!, siteAdmin: Boolean!): EmptyResponse
    # Reloads the site by restarting the server. This is not supported for all deployment
    # types. This may cause downtime.
    #
    # Only site admins may perform this mutation.
    reloadSite: EmptyResponse
    # Submits a user satisfaction (NPS) survey.
    submitSurvey(input: SurveySubmissionInput!): EmptyResponse
    # Submits a request for a Sourcegraph Enterprise trial license.
    requestTrial(email: String!): EmptyResponse
    # Manages the extension registry.
    extensionRegistry: ExtensionRegistryMutation!
    # Mutations that are only used on Sourcegraph.com.
    #
    # FOR INTERNAL USE ONLY.
    dotcom: DotcomMutation!
    # Creates a saved search.
    createSavedSearch(
        description: String!
        query: String!
        notifyOwner: Boolean!
        notifySlack: Boolean!
        orgID: ID
        userID: ID
    ): SavedSearch!
    # Updates a saved search
    updateSavedSearch(
        id: ID!
        description: String!
        query: String!
        notifyOwner: Boolean!
        notifySlack: Boolean!
        orgID: ID
        userID: ID
    ): SavedSearch!
    # Deletes a saved search
    deleteSavedSearch(id: ID!): EmptyResponse

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # Deletes an LSIF upload.
    deleteLSIFUpload(id: ID!): EmptyResponse

    # Set permissions of a repository with a full set of users by their usernames or emails.
    setRepositoryPermissionsForUsers(
        # The repository that the mutation is applied to.
        repository: ID!
        # A list of usernames or email addresses according to site configuration.
        bindIDs: [String!]!
        # The level of repository permission.
        perm: RepositoryPermission = READ
    ): EmptyResponse!
}

# A patch to apply to a repository (in a new branch) when a campaign is created from the parent
# campaign plan.
input CampaignPlanPatch {
    # The repository that this patch is applied to.
    repository: ID!

    # The base revision in the repository that this patch is based on.
    # Example: "4095572721c6234cd72013fd49dff4fb48f0f8a4"
    baseRevision: String!

    # The reference to the base revision at the time the patch was created.
    # Example: "refs/heads/master"
    baseRef: String!

    # The patch (in unified diff format) to apply.
    #
    # The filenames must not be prefixed (e.g., with 'a/' and 'b/'). Tip: use 'git diff --no-prefix'
    # to omit the prefix.
    patch: String!
}

# Input arguments for creating a campaign.
input CreateCampaignInput {
    # The ID of the namespace where this campaign is defined.
    namespace: ID!

    # The name of the campaign.
    name: String!

    # The description of the campaign as Markdown.
    description: String!

    # The name of the branch that will be created for each changeset on the codehost if the plan attribute is specified.
    # If a branch with the given name already exists a fallback name will be created by adding a count to the end of the branch name until the name doesn't exist. Example: "my-branch-name" becomes "my-branch-name-1".
    # This is required if the plan attribute is specified.
    branch: String

    # An optional reference to a completed campaign plan that was previewed before this mutation.
    # If null, existing changesets can be added manually.
    # If set, no changesets can be added manually, they will be created by Sourcegraph
    # after creating the campaign according to the precomputed campaign plan.
    # Will error if the plan has been purged already and needs to be recreated.
    # Will error if the plan is not completed yet.
    # Using a campaign plan for a campaign will retain it for the lifetime of the campaign and prevents it from being purged.
    plan: ID

    # Whether or not to create the Campaign in draft mode. Default is false.
    # When a Campaign is created in draft mode, its changesetPlans are not
    # created on the codehost, but only when publishing the Campaign.
    draft: Boolean
}

# Input arguments for updating a campaign.
input UpdateCampaignInput {
    # The ID of the campaign to update.
    id: ID!

    # The updated name of the campaign (if non-null).
    name: String

    # The branch name. This is not allowed if the campaign or any individual changesets have already been published.
    branch: String

    # The updated description of the campaign as Markdown (if non-null).
    description: String

    # An optional reference to a completed CampaignPlan that was previewed
    # before updating the Campaign.
    # If set, the Campaign's changesets will be updated to the Changesets of the given CampaignPlan.
    # The Campaign's status will be updated accordingly while possibly
    # new ExternalChangesets are created/updated/closed on the codehosts.
    plan: ID
}

# A preview of changes that will be applied by a campaign.
# It is cached and addressable by its ID for a limited amount of time.
type CampaignPlan implements Node {
    # The unique ID of this campaign plan.
    id: ID!

    # The progress status of generating changesets.
    status: BackgroundProcessStatus!

    # DEPRECATED
    # The proposed patches ("plans") for the changesets that will be created by the campaign.
    changesets(first: Int): ChangesetPlanConnection!
        @deprecated(reason: "This field will be removed in 3.15. Please use changesetPlans instead.")

    # The proposed patches ("plans") for the changesets that will be created by the campaign.
    changesetPlans(first: Int): ChangesetPlanConnection!

    # The URL where the plan can be previewed and a campaign can be created from it.
    previewURL: String!
}

# A paginated list of repository diffs committed to git.
type RepositoryComparisonConnection {
    # A list of repository diffs committed to git.
    nodes: [RepositoryComparison!]!

    # The total number of repository diffs in the connection.
    totalCount: Int!

    # Pagination information.
    pageInfo: PageInfo!
}

# The state a background process can be in.
enum BackgroundProcessState {
    # The background process is processing items.
    PROCESSING
    # The background process attempted processing all items, but some failed.
    ERRORED
    # The background process completed processing all items successfully.
    COMPLETED
    # The background process was canceled.
    CANCELED
}

# Reusable type to report progress of a background process.
type BackgroundProcessStatus {
    # How many items were successfully completed.
    completedCount: Int!

    # How many items are not done yet (including items that errored).
    pendingCount: Int!

    # The state the background process is currently in.
    state: BackgroundProcessState!

    # Messages of errors that occurred since the current run of this process was started.
    errors: [String!]!
}

# A collection of changesets.
type Campaign implements Node {
    # The unique ID for the campaign.
    id: ID!

    # The campaign plan that was used to create this campaign.
    # If null, changesets are added to the campaign manually.
    plan: CampaignPlan

    # The current status of creating or updating the campaigns changesets on
    # the code host.
    status: BackgroundProcessStatus!

    # The namespace where this campaign is defined.
    namespace: Namespace!

    # The name of the campaign.
    name: String!

    # The description as Markdown.
    description: String!

    # The branch of the changesets created by a campaign plan.
    branch: String

    # The user who authored the campaign.
    author: User!

    # Whether the current user can edit or delete this campaign.
    viewerCanAdminister: Boolean!

    # The URL to this campaign.
    url: String!

    # The date and time when the campaign was created.
    createdAt: DateTime!

    # The date and time when the campaign was updated.
    updatedAt: DateTime!

    # The combined diff of all changesets across all repositories, already created on the code host.
    repositoryDiffs(first: Int): RepositoryComparisonConnection!

    # The changesets in this campaign, already created on the code host.
    changesets(
        first: Int
        # Only include changesets with the given state
        state: ChangesetState
        # Only include changesets with the given review state
        reviewState: ChangesetReviewState
        # Only include changesets with the given check state
        checkState: ChangesetCheckState
    ): ExternalChangesetConnection!

    # The changeset counts over time, in 1 day intervals backwards from the point in time given in 'to'.
    changesetCountsOverTime(
        # Only include changeset counts up to this point in time (inclusive).
        # Defaults to createdAt.
        from: DateTime
        # Only include changeset counts up to this point in time (inclusive).
        # Defaults to now.
        to: DateTime
    ): [ChangesetCounts!]!

    # The date and time when the campaign was closed.
    closedAt: DateTime

    # The date and time when the Campaign changed from draft mode to published.
    # If the Campaign has not been published yet (is still in draft mode) this
    # is null.
    # If the Campaign was never in draft mode the value is the same as createdAt.
    publishedAt: DateTime

    # The changesets that will be created on the code host when publishing the
    # Campaign.
    # If the Campaign is a "manual" campaign and doesn't have a CampaignPlan
    # attached, there won't be any nodes returned by this connection
    # When publishing a Campaign, the number of nodes in changesets will
    # increase with each decrease in changesetPlans. The Completed count in the
    # Campaign.status increments with every ChangesetPlan turned into an
    # ExternalChangeset.
    changesetPlans(first: Int): ChangesetPlanConnection!
}

# The counts of changesets in certain states at a specific point in time.
type ChangesetCounts {
    # The point in time these counts were recorded.
    date: DateTime!
    # The total number of changesets.
    total: Int!
    # The number of merged changesets.
    merged: Int!
    # The number of closed changesets.
    closed: Int!
    # The number of open changesets (independent of review state).
    open: Int!
    # The number of changesets that are both open and approved.
    openApproved: Int!
    # The number of changesets that are both open and have requested changes.
    openChangesRequested: Int!
    # The number of changesets that are both open and are pending review.
    openPending: Int!
}

# A list of campaigns.
type CampaignConnection {
    # A list of campaigns.
    nodes: [Campaign!]!

    # The total number of campaigns in the connection.
    totalCount: Int!

    # Pagination information.
    pageInfo: PageInfo!
}

# A Changeset's state
enum ChangesetState {
    OPEN
    CLOSED
    MERGED
    DELETED
}

# The state of a Changeset Review
enum ChangesetReviewState {
    APPROVED
    CHANGES_REQUESTED
    PENDING
    COMMENTED
    DISMISSED
}

# The state of continuous integration checks on a changeset
enum ChangesetCheckState {
    PENDING
    PASSED
    FAILED
}

# The input to the createChangesets mutation.
input CreateChangesetInput {
    # The repository ID that this Changeset belongs to.
    repository: ID!
    # The external ID that uniquely identifies this Changeset in the above repository.
    # Github: PR number
    externalID: String!
}

# Preview of a changeset planned to be created.
type ChangesetPlan {
    # The id of the changeset plan.
    id: ID!

    # The repository changed by the changeset.
    repository: Repository!

    # The diff of the changeset.
    diff: PreviewRepositoryComparison!

    # Whether the ChangesetPlan is enqueued for publication. Default is false.
    # It will be true when:
    # - a Campaign has been created with the CampaignPlan to which this
    # ChangesetPlan belongs
    # - when a Campaign with the CampaignPlan has been published after being in
    # draft mode
    # - when the ChangesetPlan has been individually published through the
    # publishChangeset mutation
    publicationEnqueued: Boolean!
}

# A label attached to a changeset on a codehost, mirrored
type ChangesetLabel {
    # The labels text
    text: String!
    # Label color, defined in hex without the #. E.g., 93ba13
    color: String!
    # Optional descriptive text to support the understandability of the labels meaning
    description: String
}

# A changeset in a code host (e.g. a PR on Github)
type ExternalChangeset implements Node {
    # The unique ID for the changeset.
    id: ID!

    # The external ID that uniquely identifies this ExternalChangeset on the
    # codehost. For example, on GitHub this is the PR number.
    externalID: String!

    # The repository changed by this changeset.
    repository: Repository!

    # The campaigns that have this changeset in them.
    campaigns(first: Int, state: CampaignState): CampaignConnection!

    # The events belonging to this changeset.
    events(first: Int): ChangesetEventConnection!

    # The date and time when the changeset was created.
    createdAt: DateTime!

    # The date and time when the changeset was updated.
    updatedAt: DateTime!

    # The title of the changeset
    title: String!

    # The body of the changeset
    body: String!

    # The state of the changeset
    state: ChangesetState!

    # The labels attached to the changeset on the code host.
    labels: [ChangesetLabel!]!

    # The external URL of the changeset on the code host.
    externalURL: ExternalLink!

    # The review state of this changeset.
    reviewState: ChangesetReviewState!

    # The head of the diff ("new" or "right-hand side").
    head: GitRef!

    # The base of the diff ("old" or "left-hand side").
    base: GitRef!

    # The diff of this changeset.
    # Only returned if the changeset has not been merged or closed.
    diff: RepositoryComparison

    # The state of the continuous integration checks on this changeset.
    # It can be null if no checks have been configured.
    checkState: ChangesetCheckState
}

# A list of changesets.
type ExternalChangesetConnection {
    # A list of changesets.
    nodes: [ExternalChangeset!]!

    # The total number of changesets in the connection.
    totalCount: Int!

    # Pagination information.
    pageInfo: PageInfo!
}

# A list of changesets plans.
type ChangesetPlanConnection {
    # A list of changeset plans.
    nodes: [ChangesetPlan!]!

    # The total number of changeset plans in the connection.
    totalCount: Int!

    # Pagination information.
    pageInfo: PageInfo!
}

# A changeset event in a code host (e.g. a comment on a PR on Github)
type ChangesetEvent implements Node {
    # The unique ID for the changeset event.
    id: ID!

    # The changeset this event belongs to.
    changeset: ExternalChangeset!

    # The date and time when the changeset was created.
    createdAt: DateTime!
}

# A list of changeset events.
type ChangesetEventConnection {
    # A list of changeset events.
    nodes: [ChangesetEvent!]!

    # The total number of changeset events in the connection.
    totalCount: Int!

    # Pagination information.
    pageInfo: PageInfo!
}

# A new external service.
input AddExternalServiceInput {
    # The kind of the external service.
    kind: ExternalServiceKind!
    # The display name of the external service.
    displayName: String!
    # The JSON configuration of the external service.
    config: String!
}

# Fields to update for an existing external service.
input UpdateExternalServiceInput {
    # The id of the external service to update.
    id: ID!
    # The updated display name, if provided.
    displayName: String
    # The updated config, if provided.
    config: String
}

# A selection within a file.
input DiscussionThreadTargetRepoSelectionInput {
    # The line that the selection started on (zero-based, inclusive).
    startLine: Int!

    # The character (not byte) of the start line that the selection began on (zero-based, inclusive).
    startCharacter: Int!

    # The line that the selection ends on (zero-based, exclusive).
    endLine: Int!

    # The character (not byte) of the end line that the selection ended on (zero-based, exclusive).
    endCharacter: Int!

    # The literal textual (UTF-8) lines before the line the selection started
    # on.
    #
    # This is an arbitrary number of lines, and may be zero lines, but typically 3.
    #
    # If null, this information will be gathered from the repository itself
    # automatically. This will result in an error if the selection is invalid or
    # the DiscussionThreadTargetRepoInput specified an invalid path or
    # branch/revision.
    linesBefore: [String!]

    # The literal textual (UTF-8) lines of the selection. i.e. all lines
    # startLine through endLine.
    #
    # If null, this information will be gathered from the repository itself
    # automatically. This will result in an error if the selection is invalid or
    # the DiscussionThreadTargetRepoInput specified an invalid path or
    # branch/revision.
    lines: [String!]

    # The literal textual (UTF-8) lines after the line the selection ended on.
    #
    # This is an arbitrary number of lines, and may be zero lines, but typically 3.
    #
    # If null, this information will be gathered from the repository itself
    # automatically. This will result in an error if the selection is invalid or
    # the DiscussionThreadTargetRepoInput specified an invalid path or
    # branch/revision.
    linesAfter: [String!]
}

# A discussion thread that is centered around:
#
# - A repository.
# - A directory inside a repository.
# - A file inside a repository.
# - A selection inside a file inside a repository.
#
input DiscussionThreadTargetRepoInput {
    # The repository in which the thread was created.
    #
    # One of 'repositoryID', 'repositoryGitCloneURL', or 'repositoryName' must be specified.
    repositoryID: ID

    # The repository in which the thread was created.
    #
    # One of 'repositoryID', 'repositoryGitCloneURL', or 'repositoryName' must be specified.
    repositoryName: String

    # The repository in which the thread was created.
    #
    # One of 'repositoryID', 'repositoryGitCloneURL', or 'repositoryName' must be specified.
    repositoryGitCloneURL: String

    # The path (relative to the repository root) of the file or directory that
    # the thread is referencing, if any. If the path is null, the thread is not
    # talking about a specific path but rather just the repository generally.
    path: String

    # The branch or other human-readable Git ref (e.g. "HEAD~2", but not exact
    # Git revision), that the thread was referencing, if any.
    branch: String

    # The exact Git object ID (OID / 40-character SHA-1 hash) which the thread
    # was referencing, if any.
    revision: GitObjectID

    # The selection that the thread was referencing, if any.
    selection: DiscussionThreadTargetRepoSelectionInput
}

# Describes the creation of a new thread around some target (e.g. a file in a repo).
input DiscussionThreadCreateInput {
    # An explicitly chosen title for the discussion thread. Otherwise, the title
    # will be chosen based on the 'contents' (e.g. the first line).
    title: String

    # The contents of the thread's first comment (i.e. the threads comment).
    contents: String!

    # The target repo of this discussion thread. This is nullable so that in
    # the future more target types may be added.
    targetRepo: DiscussionThreadTargetRepoInput
}

# Describes an update mutation to an existing thread.
input DiscussionThreadUpdateInput {
    # The ID of the thread to update.
    threadID: ID!

    # When non-null, indicates that the thread's title should be updated to the specified value.
    title: String

    # When non-null, indicates that the thread should be archived.
    archive: Boolean

    # When non-null, indicates that the thread should be deleted. Only admins
    # can perform this action.
    delete: Boolean
}

# Describes an update mutation to an existing comment in a thread.
input DiscussionCommentUpdateInput {
    # The ID of the comment to update.
    commentID: ID!

    # When non-null, indicates that the comment's content should be updated. Only site admins and the
    # original author can perform this action.
    contents: String

    # When non-null, indicates that the thread should be deleted. Only admins
    # can perform this action.
    delete: Boolean

    # When non-null, reports the comment with the specified reason.
    #
    # An error will be returned if the comment's canReport field is false.
    report: String

    # When non-null, indicates that the reports on the thread should be
    # cleared. Only admins can perform this action.
    #
    # An error will be returned if the comment's canClearReports field is false.
    clearReports: Boolean
}

# Mutations for discussions.
type DiscussionsMutation {
    # Creates a new thread. Returns the new thread.
    createThread(input: DiscussionThreadCreateInput!): DiscussionThread!

    # Updates an existing thread. Returns the updated thread.
    #
    # Returns null if the thread was deleted.
    updateThread(input: DiscussionThreadUpdateInput!): DiscussionThread

    # Adds a new comment to a thread. Returns the updated thread.
    addCommentToThread(threadID: ID!, contents: String!): DiscussionThread!

    # Updates an existing comment. Returns the updated thread.
    updateComment(input: DiscussionCommentUpdateInput!): DiscussionThread!
}

# Describes options for rendering Markdown.
input MarkdownOptions {
    # TODO(slimsag:discussions): add option for controlling relative links

    # A dummy null value (empty input types are not allowed yet).
    alwaysNil: String
}

# The product sources where events can come from.
enum EventSource {
    WEB
    CODEHOSTINTEGRATION
    BACKEND
}

# Input for Mutation.settingsMutation, which contains fields that all settings (global, organization, and user
# settings) mutations need.
input SettingsMutationGroupInput {
    # The subject whose settings to mutate (organization, user, etc.).
    subject: ID!
    # The ID of the last-known settings known to the client, or null if there is none. This field is used to
    # prevent race conditions when there are concurrent editors.
    lastID: Int
}

# Mutations that update settings (global, organization, or user settings). These mutations are grouped together
# because they:
#
# - are all versioned to avoid race conditions with concurrent editors
# - all apply to a specific settings subject (i.e., a user, an organization, or the whole site)
#
# Grouping them lets us extract those common parameters to the Mutation.settingsMutation field.
type SettingsMutation {
    # Edit a single property in the settings object.
    editSettings(
        # The edit to apply to the settings.
        edit: SettingsEdit!
    ): UpdateSettingsPayload
    # DEPRECATED
    editConfiguration(edit: ConfigurationEdit!): UpdateSettingsPayload
        @deprecated(
            reason: "Use editSettings instead. This field is a deprecated alias for it and will be removed in a future release."
        )
    # Overwrite the existing settings with the new settings.
    overwriteSettings(
        # A JSON object (stringified) of the settings. Trailing commas and "//"-style comments are supported. The
        # entire previous settings value will be overwritten by this new value.
        contents: String!
    ): UpdateSettingsPayload
}

# An edit to a JSON property in a settings JSON object. The JSON property to edit can be nested.
input SettingsEdit {
    # The key path of the property to update.
    #
    # Inserting into an existing array is not yet supported.
    keyPath: [KeyPathSegment!]!
    # The new JSON-encoded value to insert. If the field's value is not set, the property is removed. (This is
    # different from the field's value being the JSON null value.)
    #
    # When the value is a non-primitive type, it must be specified using a GraphQL variable, not an inline literal,
    # or else the GraphQL parser will return an error.
    value: JSONValue
    # Whether to treat the value as a JSONC-encoded string, which makes it possible to perform an edit that
    # preserves (or adds/removes) comments.
    valueIsJSONCEncodedString: Boolean = false
}

# DEPRECATED: This type was renamed to SettingsEdit.
#
# NOTE: GraphQL does not support @deprecated directives on INPUT_FIELD_DEFINITION (input fields).
input ConfigurationEdit {
    # DEPRECATED
    keyPath: [KeyPathSegment!]!
    # DEPRECATED
    value: JSONValue
    # DEPRECATED
    valueIsJSONCEncodedString: Boolean = false
}

# A segment of a key path that locates a nested JSON value in a root JSON value. Exactly one field in each
# KeyPathSegment must be non-null.
#
# For example, in {"a": [0, {"b": 3}]}, the value 3 is located at the key path ["a", 1, "b"].
input KeyPathSegment {
    # The name of the property in the object at this location to descend into.
    property: String
    # The index of the array at this location to descend into.
    index: Int
}

# The payload for SettingsMutation.updateConfiguration.
type UpdateSettingsPayload {
    # An empty response.
    empty: EmptyResponse
}

# The result for Mutation.createAccessToken.
type CreateAccessTokenResult {
    # The ID of the newly created access token.
    id: ID!
    # The secret token value that is used to authenticate API clients. The caller is responsible for storing this
    # value.
    token: String!
}

# The result for Mutation.checkMirrorRepositoryConnection.
type CheckMirrorRepositoryConnectionResult {
    # The error message encountered during the update operation, if any. If null, then
    # the connection check succeeded.
    error: String
}

# The result for Mutation.createUser.
type CreateUserResult {
    # The new user.
    user: User!
    # The reset password URL that the new user must visit to sign into their account. If the builtin
    # username-password authentication provider is not enabled, this field's value is null.
    resetPasswordURL: String
}

# The result for Mutation.randomizeUserPassword.
type RandomizeUserPasswordResult {
    # The reset password URL that the user must visit to sign into their account again. If the builtin
    # username-password authentication provider is not enabled, this field's value is null.
    resetPasswordURL: String
}

# Input for a user satisfaction (NPS) survey submission.
input SurveySubmissionInput {
    # User-provided email address, if there is no currently authenticated user. If there is, this value
    # will not be used.
    email: String
    # User's likelihood of recommending Sourcegraph to a friend, from 0-10.
    score: Int!
    # The answer to "What is the most important reason for the score you gave".
    reason: String
    # The answer to "What can Sourcegraph do to provide a better product"
    better: String
}

# The state of the campaign
enum CampaignState {
    OPEN
    CLOSED
}

# A query.
type Query {
    # The root of the query.
    root: Query! @deprecated(reason: "this will be removed.")
    # Looks up a node by ID.
    node(id: ID!): Node

    # A list of campaigns.
    campaigns(
        # Returns the first n campaigns from the list.
        first: Int
        state: CampaignState
    ): CampaignConnection!

    # Looks up a repository by either name or cloneURL.
    repository(
        # Query the repository by name, for example "github.com/gorilla/mux".
        name: String
        # Query the repository by a Git clone URL (format documented here: https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a)
        # by checking for a code host configuration that matches the clone URL.
        # Will not actually check the code host to see if the repository actually exists.
        cloneURL: String
        # An alias for name. DEPRECATED: use name instead.
        uri: String
    ): Repository
    # Looks up a repository by either name or cloneURL. When the repository does not exist on the server
    # and "disablePublicRepoRedirects" is "false" in the site configuration, it returns a Redirect to
    # an external Sourcegraph URL that may have this repository instead. Otherwise, this query returns
    # null.
    repositoryRedirect(
        # Query the repository by name, for example "github.com/gorilla/mux".
        name: String
        # Query the repository by a Git clone URL (format documented here: https://git-scm.com/docs/git-clone#_git_urls_a_id_urls_a)
        # by checking for a code host configuration that matches the clone URL.
        # Will not actually check the code host to see if the repository actually exists.
        cloneURL: String
    ): RepositoryRedirect
    # Lists all external services.
    externalServices(
        # Returns the first n external services from the list.
        first: Int
    ): ExternalServiceConnection!
    # List all repositories.
    repositories(
        # Returns the first n repositories from the list.
        first: Int
        # Return repositories whose names match the query.
        query: String
        # Return repositories whose names are in the list.
        names: [String!]
        # Include cloned repositories.
        cloned: Boolean = true
        # Include repositories that are currently being cloned.
        cloneInProgress: Boolean = true
        # Include repositories that are not yet cloned and for which cloning is not in progress.
        notCloned: Boolean = true
        # Include repositories that have a text search index.
        indexed: Boolean = true
        # Include repositories that do not have a text search index.
        notIndexed: Boolean = true
        # Sort field.
        orderBy: RepositoryOrderBy = REPOSITORY_NAME
        # Sort direction.
        descending: Boolean = false
    ): RepositoryConnection!
    # Looks up a Phabricator repository by name.
    phabricatorRepo(
        # The name, for example "github.com/gorilla/mux".
        name: String
        # An alias for name. DEPRECATED: use name instead.
        uri: String
    ): PhabricatorRepo
    # The current user.
    currentUser: User
    # Looks up a user by username or email address.
    user(
        # Query the user by username.
        username: String
        # Query the user by verified email address.
        email: String
    ): User
    # List all users.
    users(
        # Returns the first n users from the list.
        first: Int
        # Return users whose usernames or display names match the query.
        query: String
        # Return only users with the given tag.
        tag: String
        # Returns users who have been active in a given period of time.
        activePeriod: UserActivePeriod
    ): UserConnection!
    # Looks up an organization by name.
    organization(name: String!): Org
    # List all organizations.
    organizations(
        # Returns the first n organizations from the list.
        first: Int
        # Return organizations whose names or display names match the query.
        query: String
    ): OrgConnection!
    # Lists discussion threads.
    discussionThreads(
        # Returns the first n threads from the list.
        first: Int
        # Return discussion threads matching the query.
        query: String
        # When present, lists only the thread with this ID.
        #
        # DEPRECATED: use Query#node instead.
        threadID: ID
        # When present, lists only the threads created by this author.
        authorUserID: ID
        # When present, lists only the threads whose target is a repository with this ID.
        #
        # Only one of 'targetRepositoryID', 'targetRepositoryName', or 'targetRepositoryGitCloneURL' may be specified.
        targetRepositoryID: ID
        # When present, lists only the threads whose target is a repository with this name.
        #
        # Only one of 'targetRepositoryID', 'targetRepositoryName', or 'targetRepositoryGitCloneURL' may be specified.
        targetRepositoryName: String
        # When present, lists only the threads whose target is a repository with this Git clone URL.
        #
        # Only one of 'targetRepositoryID', 'targetRepositoryName', or 'targetRepositoryGitCloneURL' may be specified.
        targetRepositoryGitCloneURL: String
        # When present, lists only the threads whose target is a repository with this file path.
        #
        # If the path ends with "/**", any path below that is matched.
        targetRepositoryPath: String
    ): DiscussionThreadConnection!
    # Looks up a discussion thread by its DiscussionThread#idWithoutKind value.
    #
    # To get a discussion thread by its globally unique GraphQL ID, use Query#node.
    discussionThread(idWithoutKind: String!): DiscussionThread
    # Lists discussion comments.
    discussionComments(
        # Returns the first n comments from the list.
        first: Int
        # When present, lists only the comments created by this author.
        authorUserID: ID
    ): DiscussionCommentConnection!
    # Renders Markdown to HTML. The returned HTML is already sanitized and
    # escaped and thus is always safe to render.
    renderMarkdown(markdown: String!, options: MarkdownOptions): String!
    # EXPERIMENTAL: Syntax highlights a code string.
    highlightCode(code: String!, fuzzyLanguage: String!, disableTimeout: Boolean!, isLightTheme: Boolean!): String!
    # Looks up an instance of a type that implements SettingsSubject (i.e., something that has settings). This can
    # be a site (which has global settings), an organization, or a user.
    settingsSubject(id: ID!): SettingsSubject
    # The settings for the viewer. The viewer is either an anonymous visitor (in which case viewer settings is
    # global settings) or an authenticated user (in which case viewer settings are the user's settings).
    viewerSettings: SettingsCascade!
    # DEPRECATED
    viewerConfiguration: ConfigurationCascade! @deprecated(reason: "use viewerSettings instead")
    # The configuration for clients.
    clientConfiguration: ClientConfigurationDetails!
    # Fetch search filter suggestions for autocompletion.
    searchFilterSuggestions: SearchFilterSuggestions!
    # Runs a search.
    search(
        # The version of the search syntax being used.
        # All new clients should use the latest version.
        version: SearchVersion = V1
        # PatternType controls the search pattern type, if and only if it is not specified in the query string using
        # the patternType: field.
        patternType: SearchPatternType
        # The search query (such as "foo" or "repo:myrepo foo").
        query: String = ""

        # (experimental) Sourcegraph 3.9 added support for cursor-based paginated
        # search requests when this field is specified. For details, see
        # https://docs.sourcegraph.com/api/graphql/search
        #
        # When specified, indicates that this request should be paginated and
        # to fetch results starting at this cursor.
        #
        # A future request can be made for more results by passing in the
        # 'SearchResults.pageInfo.endCursor' that is returned.
        after: String

        # (experimental) Sourcegraph 3.9 added support for cursor-based paginated
        # search requests when this field is specified. For details, see
        # https://docs.sourcegraph.com/api/graphql/search
        #
        # When specified, indicates that this request should be paginated and
        # the first N results (relative to the cursor) should be returned. i.e.
        # how many results to return per page. It must be in the range of 0-5000.
        first: Int
    ): Search
    # All saved searches configured for the current user, merged from all configurations.
    savedSearches: [SavedSearch!]!
    # All repository groups for the current user, merged from all configurations.
    repoGroups: [RepoGroup!]!
    # The current site.
    site: Site!
    # Retrieve responses to surveys.
    surveyResponses(
        # Returns the first n survey responses from the list.
        first: Int
    ): SurveyResponseConnection!
    # The extension registry.
    extensionRegistry: ExtensionRegistry!
    # Queries that are only used on Sourcegraph.com.
    #
    # FOR INTERNAL USE ONLY.
    dotcom: DotcomQuery!
    # FOR INTERNAL USE ONLY: Lists all status messages
    statusMessages: [StatusMessage!]!

    # Look up a namespace by ID.
    namespace(id: ID!): Namespace

    # The repositories a user is authorized to access with the given permission.
    # This isnâ€™t defined in the User type because we store permissions for users
    # that donâ€™t yet exist (i.e. late binding). Only one of "username" or "email"
    # is required to identify a user.
    authorizedUserRepositories(
        # The username.
        username: String
        # One of the email addresses.
        email: String
        # Permission that the user has on the repositories.
        perm: RepositoryPermission = READ
        # Number of repositories to return after the given cursor.
        first: Int!
        # Opaque pagination cursor.
        after: String
    ): RepositoryConnection!

    # Returns a list of usernames or emails that have associated pending permissions.
    # The returned list can be used to query authorizedUserRepositories for pending permissions.
    usersWithPendingPermissions: [String!]!
}

# The version of the search syntax.
enum SearchVersion {
    # Search syntax that defaults to regexp search.
    V1
    # Search syntax that defaults to literal search.
    V2
}

# The search pattern type.
enum SearchPatternType {
    literal
    regexp
    structural
}

# Configuration details for the browser extension, editor extensions, etc.
type ClientConfigurationDetails {
    # The list of phabricator/gitlab/bitbucket/etc instance URLs that specifies which pages the content script will be injected into.
    contentScriptUrls: [String!]!
    # Returns details about the parent Sourcegraph instance.
    parentSourcegraph: ParentSourcegraphDetails!
}

# Parent Sourcegraph instance
type ParentSourcegraphDetails {
    # Sourcegraph instance URL.
    url: String!
}

# A search.
type Search {
    # The results.
    results: SearchResults!
    # The suggestions.
    suggestions(first: Int): [SearchSuggestion!]!
    # A subset of results (excluding actual search results) which are heavily
    # cached and thus quicker to query. Useful for e.g. querying sparkline
    # data.
    stats: SearchResultsStats!
}

# Predefined suggestions for search filters when backfill.
type SearchFilterSuggestions {
    # The suggestions for search filter "repogroup:".
    repogroup: [String!]!
    # The suggestions for search filter "repo:".
    repo: [String!]!
}

# A search result.
union SearchResult = FileMatch | CommitSearchResult | Repository | CodemodResult

# An object representing a markdown string.
type Markdown {
    # The raw markdown string.
    text: String!
    # HTML for the rendered markdown string, or null if there is no HTML representation provided.
    # If specified, clients should render this directly.
    html: String!
}

# A search result. Every type of search result, except FileMatch, must implement this interface.
interface GenericSearchResultInterface {
    # URL to an icon that is displayed with every search result.
    icon: String!
    # A markdown string that is rendered prominently.
    label: Markdown!
    # The URL of the result.
    url: String!
    # A markdown string that is rendered less prominently.
    detail: Markdown!
    # A list of matches in this search result.
    matches: [SearchResultMatch!]!
}

# A match in a search result. Matches make up the body content of a search result.
type SearchResultMatch {
    # URL for the individual result match.
    url: String!
    # A markdown string containing the preview contents of the result match.
    body: Markdown!
    # A list of highlights that specify locations of matches of the query in the body. Each highlight is
    # a line number, character offset, and length. Currently, highlights are only displayed on match bodies
    # that are code blocks. If the result body is a code block, exclude the markdown code fence lines in
    # the line and character count. Leave as an empty list if no highlights are available.
    highlights: [Highlight!]!
}

# Search results.
type SearchResults {
    # The results. Inside each SearchResult there may be multiple matches, e.g.
    # a FileMatch may contain multiple line matches.
    results: [SearchResult!]!
    # The total number of matches returned by this search. This is different
    # than the length of the results array in that e.g. a single results array
    # entry may contain multiple matches. For example, the results array may
    # contain two file matches and this field would report 6 ("3 line matches
    # per file") while the length of the results array would report 3
    # ("3 FileMatch results").
    #
    # Typically, 'approximateResultCount', not this field, is shown to users.
    matchCount: Int!
    # DEPRECATED: Renamed to 'matchCount' for less ambiguity.
    resultCount: Int! @deprecated(reason: "renamed to matchCount for less ambiguity")
    # The approximate number of results. This is like the length of the results
    # array, except it can indicate the number of results regardless of whether
    # or not the limit was hit. Currently, this is represented as e.g. "5+"
    # results.
    #
    # This string is typically shown to users to indicate the true result count.
    approximateResultCount: String!
    # Whether or not the results limit was hit.
    #
    # In paginated requests, this field is always false. Use 'pageInfo.hasNextPage' instead.
    limitHit: Boolean!
    # Integers representing the sparkline for the search results.
    sparkline: [Int!]!
    # Repositories that were eligible to be searched.
    repositories: [Repository!]!
    # The number of repositories that were eligible to be searched (for clients
    # that just wish to know how many without querying the, sometimes extremely
    # large, list).
    repositoriesCount: Int!
    # Repositories that were actually searched. Excludes repositories that would have been searched but were not
    # because a timeout or error occurred while performing the search, or because the result limit was already
    # reached.
    #
    # In paginated search requests, this represents the set of repositories searched for the
    # individual paginated request / input cursor and not the global set of repositories that
    # would be searched if further requests were made.
    repositoriesSearched: [Repository!]!
    # Indexed repositories searched. This is a subset of repositoriesSearched.
    indexedRepositoriesSearched: [Repository!]!
    # Repositories that are busy cloning onto gitserver.
    #
    # In paginated search requests, some repositories may be cloning. These are reported here
    # and you may choose to retry the paginated request with the same cursor after they have
    # cloned OR you may simply continue making further paginated requests and choose to skip
    # the cloning repositories.
    cloning: [Repository!]!
    # Repositories or commits that do not exist.
    #
    # In paginated search requests, some repositories may be missing (e.g. if Sourcegraph is
    # aware of them but is temporarily unable to serve them). These are reported here and you
    # may choose to retry the paginated request with the same cursor and they may no longer be
    # missing OR you may simply continue making further paginated requests and choose to skip
    # the missing repositories.
    missing: [Repository!]!
    # Repositories or commits which we did not manage to search in time. Trying
    # again usually will work.
    #
    # In paginated search requests, this field is not relevant.
    timedout: [Repository!]!
    # True if indexed search is enabled but was not available during this search.
    indexUnavailable: Boolean!
    # An alert message that should be displayed before any results.
    alert: SearchAlert
    # The time it took to generate these results.
    elapsedMilliseconds: Int!
    # Dynamic filters generated by the search results
    dynamicFilters: [SearchFilter!]!
    # Pagination information.
    #
    # This field is only applcable when the original request was a paginated one.
    pageInfo: PageInfo!
}

# Statistics about search results.
type SearchResultsStats {
    # The approximate number of results returned.
    approximateResultCount: String!
    # The sparkline.
    sparkline: [Int!]!

    # Statistics about the languages represented in the search results.
    #
    # Known issue: The LanguageStatistics.totalBytes field values are incorrect in the result.
    languages: [LanguageStatistics!]!
}

# A search filter.
type SearchFilter {
    # The value.
    value: String!
    # The string to be displayed in the UI.
    label: String!
    # Number of matches for a given filter.
    count: Int!
    # Whether the results returned are incomplete.
    limitHit: Boolean!
    # The kind of filter. Should be "file" or "repo".
    kind: String!
}

# A programming language.
type Language {
    # Name of the programming language.
    name: String!
}

# A search suggestion.
union SearchSuggestion = Repository | File | Symbol | Language

# A search-related alert message.
type SearchAlert {
    # The title.
    title: String!
    # The description.
    description: String
    # "Did you mean: ____" query proposals
    proposedQueries: [SearchQueryDescription!]
}

# A saved search query, defined in settings.
type SavedSearch implements Node {
    # The unique ID of this saved query.
    id: ID!
    # The description.
    description: String!
    # The query.
    query: String!
    # Whether or not to notify the owner of the saved search via email. This owner is either
    # a single user, or every member of an organization that owns the saved search.
    notify: Boolean!
    # Whether or not to notify on Slack.
    notifySlack: Boolean!
    # The user ID of the owner if the owner is a user.
    userID: ID
    # The organization ID of the owner if the owner is an org.
    orgID: ID
    # The Slack webhook URL associated with this saved search, if any.
    slackWebhookURL: String
}

# A search query description.
type SearchQueryDescription {
    # The description.
    description: String
    # The query.
    query: String!
}

# A group of repositories.
type RepoGroup {
    # The name.
    name: String!
    # The repositories.
    repositories: [String!]!
}

# A diff between two diffable Git objects.
type Diff {
    # The diff's repository.
    repository: Repository!
    # The revision range of the diff.
    range: GitRevisionRange!
}

# A search result that is a Git commit.
type CommitSearchResult implements GenericSearchResultInterface {
    # Base64 data uri to an icon.
    icon: String!
    # A markdown string that is rendered prominently.
    label: Markdown!
    # The URL of the result.
    url: String!
    # A markdown string of that is rendered less prominently.
    detail: Markdown!
    # The result previews of the result.
    matches: [SearchResultMatch!]!
    # The commit that matched the search query.
    commit: GitCommit!
    # The ref names of the commit.
    refs: [GitRef!]!
    # The refs by which this commit was reached.
    sourceRefs: [GitRef!]!
    # The matching portion of the commit message, if any.
    messagePreview: HighlightedString
    # The matching portion of the diff, if any.
    diffPreview: HighlightedString
}

# The result of a code modification query.
type CodemodResult implements GenericSearchResultInterface {
    # URL to an icon that is displayed with every search result.
    icon: String!
    # A markdown string that is rendered prominently.
    label: Markdown!
    # The URL of the result.
    url: String!
    # A markdown string that is rendered less prominently.
    detail: Markdown!
    # A list of matches in this search result.
    matches: [SearchResultMatch!]!
    # The commit whose contents the codemod was run against.
    commit: GitCommit!
    # The raw diff of the modification.
    rawDiff: String!
}

# A search result that is a diff between two diffable Git objects.
type DiffSearchResult {
    # The diff that matched the search query.
    diff: Diff!
    # The matching portion of the diff.
    preview: HighlightedString!
}

# A string that has highlights (e.g, query matches).
type HighlightedString {
    # The full contents of the string.
    value: String!
    # Highlighted matches of the query in the preview string.
    highlights: [Highlight!]!
}

# A highlighted region in a string (e.g., matched by a query).
type Highlight {
    # The 1-indexed line number.
    line: Int!
    # The 1-indexed character on the line.
    character: Int!
    # The length of the highlight, in characters (on the same line).
    length: Int!
}

# A list of external services.
type ExternalServiceConnection {
    # A list of external services.
    nodes: [ExternalService!]!

    # The total number of external services in the connection.
    totalCount: Int!

    # Pagination information.
    pageInfo: PageInfo!
}

# A specific kind of external service.
enum ExternalServiceKind {
    AWSCODECOMMIT
    BITBUCKETCLOUD
    BITBUCKETSERVER
    GITHUB
    GITLAB
    GITOLITE
    PHABRICATOR
    OTHER
}

# A configured external service.
type ExternalService implements Node {
    # The external service's unique ID.
    id: ID!
    # The kind of external service.
    kind: ExternalServiceKind!
    # The display name of the external service.
    displayName: String!
    # The JSON configuration of the external service.
    config: JSONCString!
    # When the external service was created.
    createdAt: DateTime!
    # When the external service was last updated.
    updatedAt: DateTime!
    # This is an optional field that's populated when we ran into errors on the
    # backend side when trying to create/update an ExternalService, but the
    # create/update still succeeded.
    # It is a field on ExternalService instead of a separate thing in order to
    # not break the API and stay backwards compatible.
    warning: String
}

# A list of repositories.
type RepositoryConnection {
    # A list of repositories.
    nodes: [Repository!]!
    # The total count of repositories in the connection. This total count may be larger
    # than the number of nodes in this object when the result is paginated.
    # This requires admin permissions and will return null for all non-admin users.
    #
    # In some cases, the total count can't be computed quickly; if so, it is null. Pass
    # precise: true to always compute total counts even if it takes a while.
    totalCount(precise: Boolean = false): Int
    # Pagination information.
    pageInfo: PageInfo!
}

# A repository is a Git source control repository that is mirrored from some origin code host.
type Repository implements Node & GenericSearchResultInterface {
    # The repository's unique ID.
    id: ID!
    # The repository's name, as a path with one or more components. It conventionally consists of
    # the repository's hostname and path (joined by "/"), minus any suffixes (such as ".git").
    #
    # Examples:
    #
    # - github.com/foo/bar
    # - my-code-host.example.com/myrepo
    # - myrepo
    name: String!
    # DEPRECATED: Use name.
    uri: String! @deprecated(reason: "Use name.")
    # The repository's description.
    description: String!
    # The primary programming language in the repository.
    language: String!
    # DEPRECATED: This field is unused in known clients.
    #
    # The date when this repository was created on Sourcegraph.
    createdAt: DateTime!
    # DEPRECATED: This field is unused in known clients.
    #
    # The date when this repository's metadata was last updated on Sourcegraph.
    updatedAt: DateTime
    # Returns information about the given commit in the repository, or null if no commit exists with the given rev.
    commit(
        # The Git revision specifier (revspec) for the commit.
        rev: String!
        # Optional input revspec used to construct non-canonical URLs and other "friendly" field values. Used by
        # clients that must ensure consistency of revision resolution within a session/request (so they use full
        # SHAs) but also preserve the user input rev (for user friendliness).
        inputRevspec: String
    ): GitCommit
    # Information and status related to mirroring, if this repository is a mirror of another repository (e.g., on
    # some code host). In this case, the remote source repository is external to Sourcegraph and the mirror is
    # maintained by the Sourcegraph site (not the other way around).
    mirrorInfo: MirrorRepositoryInfo!
    # Information about this repository from the external service that it originates from (such as GitHub, GitLab,
    # Phabricator, etc.).
    externalRepository: ExternalRepository
    # Lists all external services which yield this repository.
    externalServices(
        # Returns the first n external services from the list.
        first: Int
    ): ExternalServiceConnection!
    # Whether the repository is currently being cloned.
    cloneInProgress: Boolean! @deprecated(reason: "use Repository.mirrorInfo.cloneInProgress instead")
    # Information about the text search index for this repository, or null if text search indexing
    # is not enabled or supported for this repository.
    textSearchIndex: RepositoryTextSearchIndex
    # The URL to this repository.
    url: String!
    # The URLs to this repository on external services associated with it.
    externalURLs: [ExternalLink!]!
    # The repository's default Git branch (HEAD symbolic ref). If the repository is currently being cloned or is
    # empty, this field will be null.
    defaultBranch: GitRef
    # The repository's Git refs.
    gitRefs(
        # Returns the first n Git refs from the list.
        first: Int
        # Return Git refs whose names match the query.
        query: String
        # Return only Git refs of the given type.
        #
        # Known issue: It is only supported to retrieve Git branch and tag refs, not
        # other Git refs.
        type: GitRefType
        # Ordering for Git refs in the list.
        orderBy: GitRefOrder
        # Ordering is an expensive operation that doesn't scale for lots of
        # references. If this is true we fallback on not ordering. This should
        # never be false in interactive API requests.
        interactive: Boolean = true
    ): GitRefConnection!
    # The repository's Git branches.
    branches(
        # Returns the first n Git branches from the list.
        first: Int
        # Return Git branches whose names match the query.
        query: String
        # Ordering for Git branches in the list.
        orderBy: GitRefOrder
        # Ordering is an expensive operation that doesn't scale for lots of
        # references. If this is true we fallback on not ordering. This should
        # never be false in interactive API requests.
        interactive: Boolean = true
    ): GitRefConnection!
    # The repository's Git tags.
    tags(
        # Returns the first n Git tags from the list.
        first: Int
        # Return Git tags whose names match the query.
        query: String
    ): GitRefConnection!
    # A Git comparison in this repository between a base and head commit.
    comparison(
        # The base of the diff ("old" or "left-hand side"), or "HEAD" if not specified.
        base: String
        # The head of the diff ("new" or "right-hand side"), or "HEAD" if not specified.
        head: String
    ): RepositoryComparison!
    # The repository's contributors.
    contributors(
        # The Git revision range to compute contributors in.
        revisionRange: String
        # The date after which to count contributions.
        after: String
        # Return contributors to files in this path.
        path: String
        # Returns the first n contributors from the list.
        first: Int
    ): RepositoryContributorConnection!
    # Link to another Sourcegraph instance location where this repository is located.
    redirectURL: String @deprecated(reason: "use repositoryRedirect query instead")
    # Whether the viewer has admin privileges on this repository.
    viewerCanAdminister: Boolean!
    # Base64 data uri to an icon.
    icon: String!
    # A markdown string that is rendered prominently.
    label: Markdown!
    # A markdown string of that is rendered less prominently.
    detail: Markdown!
    # The result previews of the result.
    matches: [SearchResultMatch!]!

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # The repository's LSIF uploads.
    lsifUploads(
        # An (optional) search query that searches over the commit and root properties.
        query: String

        # The state of returned uploads.
        state: LSIFUploadState

        # When specified, shows only uploads that are latest for the given repository.
        isLatestForRepo: Boolean

        # When specified, indicates that this request should be paginated and
        # the first N results (relative to the cursor) should be returned. i.e.
        # how many results to return per page. It must be in the range of 0-5000.
        first: Int

        # When specified, indicates that this request should be paginated and
        # to fetch results starting at this cursor.
        #
        # A future request can be made for more results by passing in the
        # 'LSIFUploadConnection.pageInfo.endCursor' that is returned.
        after: String
    ): LSIFUploadConnection!

    # A list of authorized users to access this repository with the given permission.
    # This API currently only returns permissions from the Sourcegraph provider, i.e.
    # "permissions.userMapping" in site configuration.
    authorizedUsers(
        # Permission that the user has on this repository.
        perm: RepositoryPermission = READ
        # Number of users to return after the given cursor.
        first: Int!
        # Opaque pagination cursor.
        after: String
    ): UserConnection!
}

# A reference to another Sourcegraph instance.
type Redirect {
    # The URL of the other Sourcegraph instance.
    url: String!
}

# A repository or a link to another Sourcegraph instance location where this repository may be located.
union RepositoryRedirect = Repository | Redirect

# A URL to a resource on an external service, such as the URL to a repository on its external (origin) code host.
type ExternalLink {
    # The URL to the resource.
    url: String!
    # The type of external service, such as "github", or null if unknown/unrecognized. This is used solely for
    # displaying an icon that represents the service.
    serviceType: String
}

# Information and status about the mirroring of a repository. In this case, the remote source repository
# is external to Sourcegraph and the mirror is maintained by the Sourcegraph site (not the other way
# around).
type MirrorRepositoryInfo {
    # The URL of the remote source repository.
    remoteURL: String!
    # Whether the clone of the repository has begun but not yet completed.
    cloneInProgress: Boolean!
    # A single line of text that contains progress information for the running clone command.
    # The format of the progress text is not specified.
    # It is intended to be displayed directly to a user.
    # e.g.
    # "Receiving objects:  95% (2041/2148), 292.01 KiB | 515.00 KiB/s"
    # "Resolving deltas:   9% (117/1263)"
    cloneProgress: String
    # Whether the repository has ever been successfully cloned.
    cloned: Boolean!
    # When the repository was last successfully updated from the remote source repository..
    updatedAt: DateTime
    # The state of this repository in the update schedule.
    updateSchedule: UpdateSchedule
    # The state of this repository in the update queue.
    updateQueue: UpdateQueue
}

# The state of a repository in the update schedule.
type UpdateSchedule {
    # The interval that was used when scheduling the current due time.
    intervalSeconds: Int!
    # The next time that the repo will be inserted into the update queue.
    due: DateTime!
    # The index of the repo in the schedule.
    index: Int!
    # The total number of repos in the schedule.
    total: Int!
}

# The state of a repository in the update queue.
type UpdateQueue {
    # The index of the repo in the update queue.
    # Updating repos are placed at the end of the queue until they finish updating
    # so don't display this if updating is true.
    index: Int!
    # True if the repo is currently updating.
    updating: Boolean!
    # The total number of repos in the update queue (including updating repos).
    total: Int!
}

# A repository on an external service (such as GitHub, GitLab, Phabricator, etc.).
type ExternalRepository {
    # The repository's ID on the external service.
    #
    # Example: For GitHub, this is the GitHub GraphQL API's node ID for the repository.
    id: String!
    # The type of external service where this repository resides.
    #
    # Example: "github", "gitlab", etc.
    serviceType: String!
    # The particular instance of the external service where this repository resides. Its value is
    # opaque but typically consists of the canonical base URL to the service.
    #
    # Example: For GitHub.com, this is "https://github.com/".
    serviceID: String!
}

# Information about a repository's text search index.
type RepositoryTextSearchIndex {
    # The indexed repository.
    repository: Repository!
    # The status of the text search index, if available.
    status: RepositoryTextSearchIndexStatus
    # Git refs in the repository that are configured for text search indexing.
    refs: [RepositoryTextSearchIndexedRef!]!
}

# The status of a repository's text search index.
type RepositoryTextSearchIndexStatus {
    # The date that the index was last updated.
    updatedAt: DateTime!
    # The byte size of the original content.
    contentByteSize: Int!
    # The number of files in the original content.
    contentFilesCount: Int!
    # The byte size of the index.
    indexByteSize: Int!
    # The number of index shards.
    indexShardsCount: Int!
}

# A Git ref (usually a branch) in a repository that is configured to be indexed for text search.
type RepositoryTextSearchIndexedRef {
    # The Git ref (usually a branch) that is configured to be indexed for text search. To find the specific commit
    # SHA that was indexed, use RepositoryTextSearchIndexedRef.indexedCommit; this field's ref target resolves to
    # the current target, not the target at the time of indexing.
    ref: GitRef!
    # Whether a text search index exists for this ref.
    indexed: Boolean!
    # Whether the text search index is of the current commit for the Git ref. If false, the index is stale.
    current: Boolean!
    # The indexed Git commit (which may differ from the ref's current target if the index is out of date). If
    # indexed is false, this field's value is null.
    indexedCommit: GitObject
}

# A list of Git refs.
type GitRefConnection {
    # A list of Git refs.
    nodes: [GitRef!]!
    # The total count of Git refs in the connection. This total count may be larger
    # than the number of nodes in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# A not-yet-committed preview of a diff on a repository.
type PreviewRepositoryComparison {
    # The repository that this diff is targeting.
    baseRepository: Repository!

    # The preview of the file diffs for each file in the diff.
    fileDiffs(first: Int): PreviewFileDiffConnection!
}

# A list of file diffs that might be applied.
type PreviewFileDiffConnection {
    # A list of file diffs that might be applied.
    nodes: [PreviewFileDiff!]!
    # The total count of file diffs in the connection, if available. This total count may be larger than the number
    # of nodes in this object when the result is paginated.
    totalCount: Int
    # Pagination information.
    pageInfo: PageInfo!
    # The diff stat for the file diffs in this object, which may be a subset of the entire diff if the result is
    # paginated.
    diffStat: DiffStat!
    # The raw diff for the file diffs in this object, which may be a subset of the entire diff if the result is
    # paginated.
    rawDiff: String!
}

# A diff for a single file that has not been applied yet.
# Subset of the FileDiff type.
type PreviewFileDiff {
    # The old (original) path of the file, or null if the file was added.
    oldPath: String
    # The old file, or null if the file was created (oldFile.path == oldPath).
    oldFile: File2
    # The new path of the file if the diff was applied, or null if the file was deleted.
    newPath: String
    # Hunks that were would be changed from old to new.
    hunks: [FileDiffHunk!]!
    # The diff stat for the whole file.
    stat: DiffStat!
    # FOR INTERNAL USE ONLY.
    #
    # An identifier for the file diff that is unique among all other file diffs in the list that
    # contains it.
    internalID: String!
}

# The differences between two concrete Git commits in a repository.
type RepositoryComparison {
    # The repository that is the base (left-hand side) of this comparison.
    baseRepository: Repository!

    # The repository that is the head (right-hand side) of this comparison. Cross-repository
    # comparisons are not yet supported, so this is always equal to
    # RepositoryComparison.baseRepository.
    headRepository: Repository!

    # The range that this comparison represents.
    range: GitRevisionRange!
    # The commits in the comparison range, excluding the base and including the head.
    commits(
        # Return the first n commits from the list.
        first: Int
    ): GitCommitConnection!
    # The file diffs for each changed file.
    fileDiffs(
        # Return the first n file diffs from the list.
        first: Int
    ): FileDiffConnection!
}

# A list of file diffs.
type FileDiffConnection {
    # A list of file diffs.
    nodes: [FileDiff!]!
    # The total count of file diffs in the connection, if available. This total count may be larger than the number
    # of nodes in this object when the result is paginated.
    totalCount: Int
    # Pagination information.
    pageInfo: PageInfo!
    # The diff stat for the file diffs in this object, which may be a subset of the entire diff if the result is
    # paginated.
    diffStat: DiffStat!
    # The raw diff for the file diffs in this object, which may be a subset of the entire diff if the result is
    # paginated.
    rawDiff: String!
}

# A diff for a single file.
type FileDiff {
    # The old (original) path of the file, or null if the file was added.
    oldPath: String
    # The old file, or null if the file was created (oldFile.path == oldPath).
    oldFile: File2
    # The new (changed) path of the file, or null if the file was deleted.
    newPath: String
    # The new file, or null if the file was deleted (newFile.path == newPath).
    newFile: File2
    # The old file (if the file was deleted) and otherwise the new file. This file field is typically used by
    # clients that want to show a "View" link to the file.
    mostRelevantFile: File2!
    # Hunks that were changed from old to new.
    hunks: [FileDiffHunk!]!
    # The diff stat for the whole file.
    stat: DiffStat!
    # FOR INTERNAL USE ONLY.
    #
    # An identifier for the file diff that is unique among all other file diffs in the list that
    # contains it.
    internalID: String!
}

# A changed region ("hunk") in a file diff.
type FileDiffHunk {
    # The range of the old file that the hunk applies to.
    oldRange: FileDiffHunkRange!
    # Whether the old file had a trailing newline.
    oldNoNewlineAt: Boolean!
    # The range of the new file that the hunk applies to.
    newRange: FileDiffHunkRange!
    # The diff hunk section heading, if any.
    section: String
    # The hunk body, with lines prefixed with '-', '+', or ' '.
    body: String!
}

# A hunk range in one side (old/new) of a diff.
type FileDiffHunkRange {
    # The first line that the hunk applies to.
    startLine: Int!
    # The number of lines that the hunk applies to.
    lines: Int!
}

# Statistics about a diff.
type DiffStat {
    # Number of additions.
    added: Int!
    # Number of changes.
    changed: Int!
    # Number of deletions.
    deleted: Int!
}

# A list of contributors to a repository.
type RepositoryContributorConnection {
    # A list of contributors to a repository.
    nodes: [RepositoryContributor!]!
    # The total count of contributors in the connection, if available. This total count may be larger than the
    # number of nodes in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# A contributor to a repository.
type RepositoryContributor {
    # The personal information for the contributor.
    person: Person!
    # The number of contributions made by this contributor.
    count: Int!
    # The repository in which the contributions occurred.
    repository: Repository!
    # Commits by the contributor.
    commits(
        # Return the first n commits.
        first: Int
    ): GitCommitConnection!
}

# A code symbol (e.g., a function, variable, type, class, etc.).
#
# It is derived from DocumentSymbol as defined in the Language Server Protocol (see
# https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_documentSymbol).
type Symbol {
    # The name of the symbol.
    name: String!
    # The name of the symbol that contains this symbol, if any. This field's value is not guaranteed to be
    # structured in such a way that callers can infer a hierarchy of symbols.
    containerName: String
    # The kind of the symbol.
    kind: SymbolKind!
    # The programming language of the symbol.
    language: String!
    # The location where this symbol is defined.
    location: Location!
    # The URL to this symbol (using the input revision specifier, which may not be immutable).
    url: String!
    # The canonical URL to this symbol (using an immutable revision specifier).
    canonicalURL: String!
    # Whether or not the symbol is local to the file it's defined in.
    fileLocal: Boolean!
}

# A location inside a resource (in a repository at a specific commit).
type Location {
    # The file that this location refers to.
    resource: GitBlob!
    # The range inside the file that this location refers to.
    range: Range
    # The URL to this location (using the input revision specifier, which may not be immutable).
    url: String!
    # The canonical URL to this location (using an immutable revision specifier).
    canonicalURL: String!
}

# A range inside a file. The start position is inclusive, and the end position is exclusive.
type Range {
    # The start position of the range (inclusive).
    start: Position!
    # The end position of the range (exclusive).
    end: Position!
}

# A zero-based position inside a file.
type Position {
    # The line number (zero-based) of the position.
    line: Int!
    # The character offset (zero-based) in the line of the position.
    character: Int!
}

# All possible kinds of symbols. This set matches that of the Language Server Protocol
# (https://microsoft.github.io/language-server-protocol/specification#workspace_symbol).
enum SymbolKind {
    UNKNOWN
    FILE
    MODULE
    NAMESPACE
    PACKAGE
    CLASS
    METHOD
    PROPERTY
    FIELD
    CONSTRUCTOR
    ENUM
    INTERFACE
    FUNCTION
    VARIABLE
    CONSTANT
    STRING
    NUMBER
    BOOLEAN
    ARRAY
    OBJECT
    KEY
    NULL
    ENUMMEMBER
    STRUCT
    EVENT
    OPERATOR
    TYPEPARAMETER
}

# A list of symbols.
type SymbolConnection {
    # A list of symbols.
    nodes: [Symbol!]!
    # Pagination information.
    pageInfo: PageInfo!
}

# A Git object ID (SHA-1 hash, 40 hexadecimal characters).
scalar GitObjectID

# A Git ref.
type GitRef implements Node {
    # The globally addressable ID for the Git ref.
    id: ID!
    # The full ref name (e.g., "refs/heads/mybranch" or "refs/tags/mytag").
    name: String!
    # An unambiguous short name for the ref.
    abbrevName: String!
    # The display name of the ref. For branches ("refs/heads/foo"), this is the branch
    # name ("foo").
    #
    # As a special case, for GitHub pull request refs of the form refs/pull/NUMBER/head,
    # this is "#NUMBER".
    displayName: String!
    # The prefix of the ref, either "", "refs/", "refs/heads/", "refs/pull/", or
    # "refs/tags/". This prefix is always a prefix of the ref's name.
    prefix: String!
    # The type of this Git ref.
    type: GitRefType!
    # The object that the ref points to.
    target: GitObject!
    # The associated repository.
    repository: Repository!
    # The URL to this Git ref.
    url: String!
}

# All possible types of Git refs.
enum GitRefType {
    # A Git branch (in refs/heads/).
    GIT_BRANCH
    # A Git tag (in refs/tags/).
    GIT_TAG
    # A Git ref that is neither a branch nor tag.
    GIT_REF_OTHER
}

# Ordering options for Git refs.
enum GitRefOrder {
    # By the authored or committed at date, whichever is more recent.
    AUTHORED_OR_COMMITTED_AT
}

# A Git object.
type GitObject {
    # This object's OID.
    oid: GitObjectID!
    # The abbreviated form of this object's OID.
    abbreviatedOID: String!
    # The commit object, if it is a commit and it exists; otherwise null.
    commit: GitCommit
    # The Git object's type.
    type: GitObjectType!
}

# All possible types of Git objects.
enum GitObjectType {
    # A Git commit object.
    GIT_COMMIT
    # A Git tag object.
    GIT_TAG
    # A Git tree object.
    GIT_TREE
    # A Git blob object.
    GIT_BLOB
    # A Git object of unknown type.
    GIT_UNKNOWN
}

# A Git revspec expression that (possibly) resolves to a Git revision.
type GitRevSpecExpr {
    # The original Git revspec expression.
    expr: String!
    # The Git object that the revspec resolves to, or null otherwise.
    object: GitObject
}

# A Git revspec.
union GitRevSpec = GitRef | GitRevSpecExpr | GitObject

# A Git revision range of the form "base..head" or "base...head". Other revision
# range formats are not supported.
type GitRevisionRange {
    # The Git revision range expression of the form "base..head" or "base...head".
    expr: String!
    # The base (left-hand side) of the range.
    base: GitRevSpec!
    # The base's revspec as an expression.
    baseRevSpec: GitRevSpecExpr!
    # The head (right-hand side) of the range.
    head: GitRevSpec!
    # The head's revspec as an expression.
    headRevSpec: GitRevSpecExpr!
    # The merge-base of the base and head revisions, if this is a "base...head"
    # revision range. If this is a "base..head" revision range, then this field is null.
    mergeBase: GitObject
}

# A Phabricator repository.
type PhabricatorRepo {
    # The canonical repo name (e.g. "github.com/gorilla/mux").
    name: String!
    # An alias for name.
    uri: String! @deprecated(reason: "use name instead")
    # The unique Phabricator identifier for the repo, like "MUX"
    callsign: String!
    # The URL to the phabricator instance (e.g. http://phabricator.sgdev.org)
    url: String!
}

# Pagination information. See https://facebook.github.io/relay/graphql/connections.htm#sec-undefined.PageInfo.
type PageInfo {
    # When paginating forwards, the cursor to continue.
    endCursor: String
    # When paginating forwards, are there more items?
    hasNextPage: Boolean!
}

# A list of Git commits.
type GitCommitConnection {
    # A list of Git commits.
    nodes: [GitCommit!]!
    # The total number of Git commits in the connection. If the GitCommitConnection is paginated
    # (e.g., because a "first" parameter was provided to the field that produced it), this field is
    # null to avoid it taking unexpectedly long to compute the total count. Remove the pagination
    # parameters to obtain a non-null value for this field.
    totalCount: Int
    # Pagination information.
    pageInfo: PageInfo!
}

# Statistics about a language's usage.
type LanguageStatistics {
    # The name of the language.
    name: String!

    # The total bytes in the language.
    totalBytes: Float!

    # The total number of lines in the language.
    totalLines: Int!
}

# A Git commit.
type GitCommit implements Node {
    # The globally addressable ID for this commit.
    id: ID!
    # The repository that contains this commit.
    repository: Repository!
    # This commit's Git object ID (OID), a 40-character SHA-1 hash.
    oid: GitObjectID!
    # The abbreviated form of this commit's OID.
    abbreviatedOID: String!
    # This commit's author.
    author: Signature!
    # This commit's committer, if any.
    committer: Signature
    # The full commit message.
    message: String!
    # The first line of the commit message.
    subject: String!
    # The contents of the commit message after the first line.
    body: String
    # Parent commits of this commit.
    parents: [GitCommit!]!
    # The URL to this commit (using the input revision specifier, which may not be immutable).
    url: String!
    # The canonical URL to this commit (using an immutable revision specifier).
    canonicalURL: String!
    # The URLs to this commit on its repository's external services.
    externalURLs: [ExternalLink!]!
    # The Git tree in this commit at the given path.
    tree(
        # The path of the tree.
        path: String = ""
        # Whether to recurse into sub-trees. If true, it overrides the value of the "recursive" parameter on all of
        # GitTree's fields.
        #
        # DEPRECATED: Use the "recursive" parameter on GitTree's fields instead.
        recursive: Boolean = false
    ): GitTree
    # The Git blob in this commit at the given path.
    blob(path: String!): GitBlob
    # The file at the given path for this commit.
    #
    # See "File" documentation for the difference between this field and the "blob" field.
    file(path: String!): File2
    # Lists the programming languages present in the tree at this commit.
    languages: [String!]!
    # List statistics for each language present in the repository.
    languageStatistics: [LanguageStatistics!]!
    # The log of commits consisting of this commit and its ancestors.
    ancestors(
        # Returns the first n commits from the list.
        first: Int
        # Return commits that match the query.
        query: String
        # Return commits that affect the path.
        path: String
        # Return commits more recent than the specified date.
        after: String
    ): GitCommitConnection!
    # Returns the number of commits that this commit is behind and ahead of revspec.
    behindAhead(revspec: String!): BehindAheadCounts!
    # Symbols defined as of this commit. (All symbols, not just symbols that were newly defined in this commit.)
    symbols(
        # Returns the first n symbols from the list.
        first: Int
        # Return symbols matching the query.
        query: String
        # A list of regular expressions, all of which must match all
        # file paths returned in the list.
        includePatterns: [String!]
    ): SymbolConnection!
}

# A set of Git behind/ahead counts for one commit relative to another.
type BehindAheadCounts {
    # The number of commits behind the other commit.
    behind: Int!
    # The number of commits ahead of the other commit.
    ahead: Int!
}

# A signature.
type Signature {
    # The person.
    person: Person!
    # The date.
    date: String!
}

# A person.
type Person {
    # The name.
    name: String!
    # The email.
    email: String!
    # The name if set; otherwise the email username.
    displayName: String!
    # The avatar URL.
    avatarURL: String!
    # The corresponding user account for this person, if one exists.
    user: User
}

# A Git submodule
type Submodule {
    # The remote repository URL of the submodule.
    url: String!
    # The commit of the submodule.
    commit: String!
    # The path to which the submodule is checked out.
    path: String!
}

# A file, directory, or other tree entry.
interface TreeEntry {
    # The full path (relative to the repository root) of this tree entry.
    path: String!
    # The base name (i.e., file name only) of this tree entry.
    name: String!
    # Whether this tree entry is a directory.
    isDirectory: Boolean!
    # The URL to this tree entry (using the input revision specifier, which may not be immutable).
    url: String!
    # The canonical URL to this tree entry (using an immutable revision specifier).
    canonicalURL: String!
    # The URLs to this tree entry on external services.
    externalURLs: [ExternalLink!]!
    # Symbols defined in this file or directory.
    symbols(
        # Returns the first n symbols from the list.
        first: Int
        # Return symbols matching the query.
        query: String
    ): SymbolConnection!
    # Submodule metadata if this tree points to a submodule
    submodule: Submodule
    # Whether this tree entry is a single child
    isSingleChild(
        # Returns the first n files in the tree.
        first: Int
        # Recurse into sub-trees.
        recursive: Boolean = false
    ): Boolean!
}

# A Git tree in a repository.
type GitTree implements TreeEntry {
    # The full path (relative to the root) of this tree.
    path: String!
    # Whether this tree is the root (top-level) tree.
    isRoot: Boolean!
    # The base name (i.e., last path component only) of this tree.
    name: String!
    # True because this is a directory. (The value differs for other TreeEntry interface implementations, such as
    # File.)
    isDirectory: Boolean!
    # The Git commit containing this tree.
    commit: GitCommit!
    # The repository containing this tree.
    repository: Repository!
    # The URL to this tree (using the input revision specifier, which may not be immutable).
    url: String!
    # The canonical URL to this tree (using an immutable revision specifier).
    canonicalURL: String!
    # The URLs to this tree on external services.
    externalURLs: [ExternalLink!]!
    # Submodule metadata if this tree points to a submodule
    submodule: Submodule
    # A list of directories in this tree.
    directories(
        # Returns the first n files in the tree.
        first: Int
        # Recurse into sub-trees.
        recursive: Boolean = false
    ): [GitTree!]!
    # A list of files in this tree.
    files(
        # Returns the first n files in the tree.
        first: Int
        # Recurse into sub-trees.
        recursive: Boolean = false
    ): [File!]!
    # A list of entries in this tree.
    entries(
        # Returns the first n files in the tree.
        first: Int
        # Recurse into sub-trees. If true, implies recursiveSingleChild.
        recursive: Boolean = false
        # Recurse into sub-trees of single-child directories. If true, we return a flat list of
        # every directory that is a single child, and any directories or files that are
        # nested in a single child.
        recursiveSingleChild: Boolean = false
    ): [TreeEntry!]!
    # Symbols defined in this tree.
    symbols(
        # Returns the first n symbols from the list.
        first: Int
        # Return symbols matching the query.
        query: String
    ): SymbolConnection!
    # Whether this tree entry is a single child
    isSingleChild(
        # Returns the first n files in the tree.
        first: Int
        # Recurse into sub-trees.
        recursive: Boolean = false
    ): Boolean!
}

# A file.
#
# In a future version of Sourcegraph, a repository's files may be distinct from a repository's blobs
# (for example, to support searching/browsing generated files that aren't committed and don't exist
# as Git blobs). Clients should generally use the GitBlob concrete type and GitCommit.blobs (not
# GitCommit.files), unless they explicitly want to opt-in to different behavior in the future.
#
# INTERNAL: This is temporarily named File2 during a migration. Do not refer to the name File2 in
# any API clients as the name will change soon.
interface File2 {
    # The full path (relative to the root) of this file.
    path: String!
    # The base name (i.e., file name only) of this file.
    name: String!
    # False because this is a file, not a directory.
    isDirectory: Boolean!
    # The content of this file.
    content: String!
    # Whether or not it is binary.
    binary: Boolean!
    # The file rendered as rich HTML, or an empty string if it is not a supported
    # rich file type.
    #
    # This HTML string is already escaped and thus is always safe to render.
    richHTML: String!
    # The URL to this file (using the input revision specifier, which may not be immutable).
    url: String!
    # The canonical URL to this file (using an immutable revision specifier).
    canonicalURL: String!
    # The URLs to this file on external services.
    externalURLs: [ExternalLink!]!
    # Highlight the file.
    highlight(
        disableTimeout: Boolean!
        isLightTheme: Boolean!
        # If highlightLongLines is true, lines which are longer than 2000 bytes are highlighted.
        # 2000 bytes is enabled. This may produce a significant amount of HTML
        # which some browsers (such as Chrome, but not Firefox) may have trouble
        # rendering efficiently.
        highlightLongLines: Boolean = false
    ): HighlightedFile!
}

# File is temporarily preserved for backcompat with browser extension search API client code.
type File {
    # The full path (relative to the repository root) of this file.
    path: String!
    # The base name (i.e., file name only) of this file's path.
    name: String!
    # Whether this is a directory.
    isDirectory: Boolean!
    # The URL to this file on Sourcegraph.
    url: String!
    # The repository that contains this file.
    repository: Repository!
}

# A Git blob in a repository.
type GitBlob implements TreeEntry & File2 {
    # The full path (relative to the repository root) of this blob.
    path: String!
    # The base name (i.e., file name only) of this blob's path.
    name: String!
    # False because this is a blob (file), not a directory.
    isDirectory: Boolean!
    # The content of this blob.
    content: String!
    # Whether or not it is binary.
    binary: Boolean!
    # The blob contents rendered as rich HTML, or an empty string if it is not a supported
    # rich file type.
    #
    # This HTML string is already escaped and thus is always safe to render.
    richHTML: String!
    # The Git commit containing this blob.
    commit: GitCommit!
    # The repository containing this Git blob.
    repository: Repository!
    # The URL to this blob (using the input revision specifier, which may not be immutable).
    url: String!
    # The canonical URL to this blob (using an immutable revision specifier).
    canonicalURL: String!
    # The URLs to this blob on its repository's external services.
    externalURLs: [ExternalLink!]!
    # Blame the blob.
    blame(startLine: Int!, endLine: Int!): [Hunk!]!
    # Highlight the blob contents.
    highlight(disableTimeout: Boolean!, isLightTheme: Boolean!, highlightLongLines: Boolean = false): HighlightedFile!
    # Submodule metadata if this tree points to a submodule
    submodule: Submodule
    # Symbols defined in this blob.
    symbols(
        # Returns the first n symbols from the list.
        first: Int
        # Return symbols matching the query.
        query: String
    ): SymbolConnection!
    # Always false, since a blob is a file, not directory.
    isSingleChild(
        # Returns the first n files in the tree.
        first: Int
        # Recurse into sub-trees.
        recursive: Boolean = false
        # Recurse into sub-trees of single-child directories
        recursiveSingleChild: Boolean = false
    ): Boolean!

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # A wrapper around LSIF query methods. If no LSIF upload can be used to answer code
    # intelligence queries for this path-at-revision, this resolves to null.
    lsif: LSIFQueryResolver
}

# A wrapper object around LSIF query methods for a particular path-at-revision. When this node is
# null, no LSIF data is available for containing git blob.
type LSIFQueryResolver {
    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # A list of definitions of the symbol under the given document position.
    definitions(
        # The line on which the symbol occurs (zero-based, inclusive).
        line: Int!

        # The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive).
        character: Int!
    ): LocationConnection

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # A list of references of the symbol under the given document position.
    references(
        # The line on which the symbol occurs (zero-based, inclusive).
        line: Int!

        # The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive).
        character: Int!

        # When specified, indicates that this request should be paginated and
        # to fetch results starting at this cursor.
        #
        # A future request can be made for more results by passing in the
        # 'LocationConnection.pageInfo.endCursor' that is returned.
        after: String

        # When specified, indicates that this request should be paginated and
        # the first N results (relative to the cursor) should be returned. i.e.
        # how many results to return per page.
        first: Int
    ): LocationConnection

    # (experimental) The LSIF API may change substantially in the near future as we
    # continue to adjust it for our use cases. Changes will not be documented in the
    # CHANGELOG during this time.
    # The hover result of the symbol under the given document position.
    hover(
        # The line on which the symbol occurs (zero-based, inclusive).
        line: Int!

        # The character (not byte) of the start line on which the symbol occurs (zero-based, inclusive).
        character: Int!
    ): Hover
}

# A highlighted file.
type HighlightedFile {
    # Whether or not it was aborted.
    aborted: Boolean!
    # The HTML.
    html: String!
}

# A file match.
type FileMatch {
    # The file containing the match.
    #
    # KNOWN ISSUE: This file's "commit" field contains incomplete data.
    #
    # KNOWN ISSUE: This field's type should be File! not GitBlob!.
    file: GitBlob!
    # The repository containing the file match.
    repository: Repository!
    # The revspec of the revision that contains this match. If no revspec was given (such as when no
    # repository filter or revspec is specified in the search query), it is null.
    revSpec: GitRevSpec
    # The resource.
    resource: String! @deprecated(reason: "use the file field instead")
    # The symbols found in this file that match the query.
    symbols: [Symbol!]!
    # The line matches.
    lineMatches: [LineMatch!]!
    # Whether or not the limit was hit.
    limitHit: Boolean!
}

# A line match.
type LineMatch {
    # The preview.
    preview: String!
    # The line number.
    lineNumber: Int!
    # Tuples of [offset, length] measured in characters (not bytes).
    offsetAndLengths: [[Int!]!]!
    # Whether or not the limit was hit.
    limitHit: Boolean!
}

# A hunk.
type Hunk {
    # The startLine.
    startLine: Int!
    # The endLine.
    endLine: Int!
    # The startByte.
    startByte: Int!
    # The endByte.
    endByte: Int!
    # The rev.
    rev: String!
    # The author.
    author: Signature!
    # The message.
    message: String!
    # The commit that contains the hunk.
    commit: GitCommit!
}

# A namespace is a container for certain types of data and settings, such as a user or organization.
interface Namespace {
    # The globally unique ID of this namespace.
    id: ID!

    # The name of this namespace's component. For a user, this is the username. For an organization,
    # this is the organization name.
    namespaceName: String!

    # The URL to this namespace.
    url: String!
}

# A list of users.
type UserConnection {
    # A list of users.
    nodes: [User!]!
    # The total count of users in the connection. This total count may be larger
    # than the number of nodes in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# A user.
type User implements Node & SettingsSubject & Namespace {
    # The unique ID for the user.
    id: ID!
    # The user's username.
    username: String!
    # The user's primary email address.
    #
    # Only the user and site admins can access this field.
    email: String! @deprecated(reason: "use emails instead")
    # The display name chosen by the user.
    displayName: String
    # The URL of the user's avatar image.
    avatarURL: String
    # The URL to the user's profile on Sourcegraph.
    url: String!
    # The URL to the user's settings.
    settingsURL: String
    # The date when the user account was created on Sourcegraph.
    createdAt: DateTime!
    # The date when the user account was last updated on Sourcegraph.
    updatedAt: DateTime
    # Whether the user is a site admin.
    #
    # Only the user and site admins can access this field.
    siteAdmin: Boolean!
    # Whether the user account uses built in auth.
    builtinAuth: Boolean!
    # The latest settings for the user.
    #
    # Only the user and site admins can access this field.
    latestSettings: Settings
    # All settings for this user, and the individual levels in the settings cascade (global > organization > user)
    # that were merged to produce the final merged settings.
    #
    # Only the user and site admins can access this field.
    settingsCascade: SettingsCascade!
    # DEPRECATED
    configurationCascade: ConfigurationCascade!
        @deprecated(
            reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release."
        )
    # The organizations that this user is a member of.
    organizations: OrgConnection!
    # This user's organization memberships.
    organizationMemberships: OrganizationMembershipConnection!
    # Tags associated with the user. These are used for internal site management and feature selection.
    #
    # Only the user and site admins can access this field.
    tags: [String!]!
    # The user's usage statistics on Sourcegraph.
    usageStatistics: UserUsageStatistics!
    # The user's email addresses.
    #
    # Only the user and site admins can access this field.
    emails: [UserEmail!]!
    # The user's access tokens (which grant to the holder the privileges of the user). This consists
    # of all access tokens whose subject is this user.
    #
    # Only the user and site admins can access this field.
    accessTokens(
        # Returns the first n access tokens from the list.
        first: Int
    ): AccessTokenConnection!
    # A list of external accounts that are associated with the user.
    externalAccounts(
        # Returns the first n external accounts from the list.
        first: Int
    ): ExternalAccountConnection!
    # The user's currently active session.
    #
    # Only the currently authenticated user can access this field. Site admins are not able to access sessions for
    # other users.
    session: Session!
    # Whether the viewer has admin privileges on this user. The user has admin privileges on their own user, and
    # site admins have admin privileges on all users.
    viewerCanAdminister: Boolean!
    # Whether the viewer can change the username of this user.
    #
    # The user can change their username unless auth.disableUsernameChanges is set.
    # Site admins can always change the username of any user.
    viewerCanChangeUsername: Boolean!
    # The user's survey responses.
    #
    # Only the user and site admins can access this field.
    surveyResponses: [SurveyResponse!]!
    # The URL to view this user's customer information (for Sourcegraph.com site admins).
    #
    # Only Sourcegraph.com site admins may query this field.
    #
    # FOR INTERNAL USE ONLY.
    urlForSiteAdminBilling: String
    # The unique numeric ID for the user.
    #
    # FOR INTERNAL USE ONLY.
    databaseID: Int!

    # The name of this user namespace's component. For users, this is the username.
    namespaceName: String!
}

# An access token that grants to the holder the privileges of the user who created it.
type AccessToken implements Node {
    # The unique ID for the access token.
    id: ID!
    # The user whose privileges the access token grants.
    subject: User!
    # The scopes that define the allowed set of operations that can be performed using this access token.
    scopes: [String!]!
    # A user-supplied descriptive note for the access token.
    note: String!
    # The user who created the access token. This is either the subject user (if the access token
    # was created by the same user) or a site admin (who can create access tokens for any user).
    creator: User!
    # The date when the access token was created.
    createdAt: DateTime!
    # The date when the access token was last used to authenticate a request.
    lastUsedAt: DateTime
}

# A list of access tokens.
type AccessTokenConnection {
    # A list of access tokens.
    nodes: [AccessToken!]!
    # The total count of access tokens in the connection. This total count may be larger than the number of nodes
    # in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# A list of authentication providers.
type AuthProviderConnection {
    # A list of authentication providers.
    nodes: [AuthProvider!]!
    # The total count of authentication providers in the connection. This total count may be larger than the number of nodes
    # in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# A provider of user authentication, such as an external single-sign-on service (e.g., using OpenID Connect or
# SAML). The provider information in this type is visible to all viewers and does not contain any secret values.
type AuthProvider {
    # The type of the auth provider.
    serviceType: String!
    # An identifier for the service that the auth provider represents.
    serviceID: String!
    # An identifier for the client of the service that the auth provider represents.
    clientID: String!
    # The human-readable name of the provider.
    displayName: String!
    # Whether this auth provider is the builtin username-password auth provider.
    isBuiltin: Boolean!
    # A URL that, when visited, initiates the authentication process for this auth provider.
    authenticationURL: String
}

# A list of external accounts.
type ExternalAccountConnection {
    # A list of external accounts.
    nodes: [ExternalAccount!]!
    # The total count of external accounts in the connection. This total count may be larger than the number of nodes
    # in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# An external account associated with a user.
type ExternalAccount implements Node {
    # The unique ID for the external account.
    id: ID!
    # The user on Sourcegraph.
    user: User!
    # The type of the external service where the external account resides.
    serviceType: String!
    # An identifier for the external service where the external account resides.
    serviceID: String!
    # An identifier for the client of the external service where the external account resides. This distinguishes
    # among multiple authentication providers that access the same service with different parameters.
    clientID: String!
    # An identifier for the external account (typically equal to or derived from the ID on the external service).
    accountID: String!
    # The creation date of this external account on Sourcegraph.
    createdAt: DateTime!
    # The last-updated date of this external account on Sourcegraph.
    updatedAt: DateTime!
    # A URL that, when visited, re-initiates the authentication process.
    refreshURL: String
    # Provider-specific data about the external account.
    #
    # Only site admins may query this field.
    accountData: JSONValue
}

# An active user session.
type Session {
    # Whether the user can sign out of this session on Sourcegraph.
    canSignOut: Boolean!
}

# An organization membership.
type OrganizationMembership {
    # The organization.
    organization: Org!
    # The user.
    user: User!
    # The time when this was created.
    createdAt: DateTime!
    # The time when this was updated.
    updatedAt: DateTime!
}

# A list of organization memberships.
type OrganizationMembershipConnection {
    # A list of organization memberships.
    nodes: [OrganizationMembership!]!
    # The total count of organization memberships in the connection. This total count may be larger than the number
    # of nodes in this object when the result is paginated.
    totalCount: Int!
}

# A user's email address.
type UserEmail {
    # The email address.
    email: String!
    # Whether the email address is the user's primary email address. Currently this is defined as the earliest
    # email address associated with the user, preferring verified emails to unverified emails.
    isPrimary: Boolean!
    # Whether the email address has been verified by the user.
    verified: Boolean!
    # Whether the email address is pending verification.
    verificationPending: Boolean!
    # The user associated with this email address.
    user: User!
    # Whether the viewer has privileges to manually mark this email address as verified (without the user going
    # through the normal verification process). Only site admins have this privilege.
    viewerCanManuallyVerify: Boolean!
}

# A list of organizations.
type OrgConnection {
    # A list of organizations.
    nodes: [Org!]!
    # The total count of organizations in the connection. This total count may be larger
    # than the number of nodes in this object when the result is paginated.
    totalCount: Int!
}

# An organization, which is a group of users.
type Org implements Node & SettingsSubject & Namespace {
    # The unique ID for the organization.
    id: ID!
    # The organization's name. This is unique among all organizations on this Sourcegraph site.
    name: String!
    # The organization's chosen display name.
    displayName: String
    # The date when the organization was created.
    createdAt: DateTime!
    # A list of users who are members of this organization.
    members: UserConnection!
    # The latest settings for the organization.
    #
    # Only organization members and site admins can access this field.
    latestSettings: Settings
    # All settings for this organization, and the individual levels in the settings cascade (global > organization)
    # that were merged to produce the final merged settings.
    #
    # Only organization members and site admins can access this field.
    settingsCascade: SettingsCascade!
    # DEPRECATED
    configurationCascade: ConfigurationCascade!
        @deprecated(
            reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release."
        )
    # A pending invitation for the viewer to join this organization, if any.
    viewerPendingInvitation: OrganizationInvitation
    # Whether the viewer has admin privileges on this organization. Currently, all of an organization's members
    # have admin privileges on the organization.
    viewerCanAdminister: Boolean!
    # Whether the viewer is a member of this organization.
    viewerIsMember: Boolean!
    # The URL to the organization.
    url: String!
    # The URL to the organization's settings.
    settingsURL: String

    # The name of this user namespace's component. For organizations, this is the organization's name.
    namespaceName: String!
}

# The result of Mutation.inviteUserToOrganization.
type InviteUserToOrganizationResult {
    # Whether an invitation email was sent. If emails are not enabled on this site or if the user has no verified
    # email address, an email will not be sent.
    sentInvitationEmail: Boolean!
    # The URL that the invited user can visit to accept or reject the invitation.
    invitationURL: String!
}

# An invitation to join an organization as a member.
type OrganizationInvitation implements Node {
    # The ID of the invitation.
    id: ID!
    # The organization that the invitation is for.
    organization: Org!
    # The user who sent the invitation.
    sender: User!
    # The user who received the invitation.
    recipient: User!
    # The date when this invitation was created.
    createdAt: DateTime!
    # The most recent date when a notification was sent to the recipient about this invitation.
    notifiedAt: DateTime
    # The date when this invitation was responded to by the recipient.
    respondedAt: DateTime
    # The recipient's response to this invitation, or no response (null).
    responseType: OrganizationInvitationResponseType
    # The URL where the recipient can respond to the invitation when pending, or null if not pending.
    respondURL: String
    # The date when this invitation was revoked.
    revokedAt: DateTime
}

# The recipient's possible responses to an invitation to join an organization as a member.
enum OrganizationInvitationResponseType {
    # The invitation was accepted by the recipient.
    ACCEPT
    # The invitation was rejected by the recipient.
    REJECT
}

# An object defining a selection range within e.g. a file.
type DiscussionSelectionRange {
    # The line that the selection started on (zero-based, inclusive).
    startLine: Int!

    # The character (not byte) of the start line that the selection began on (zero-based, inclusive).
    startCharacter: Int!

    # The line that the selection ends on (zero-based, exclusive).
    endLine: Int!

    # The character (not byte) of the end line that the selection ended on (zero-based, exclusive).
    endCharacter: Int!
}

# A selection within a file.
type DiscussionThreadTargetRepoSelection {
    # The line that the selection started on (zero-based, inclusive).
    startLine: Int!

    # The character (not byte) of the start line that the selection began on (zero-based, inclusive).
    startCharacter: Int!

    # The line that the selection ends on (zero-based, exclusive).
    endLine: Int!

    # The character (not byte) of the end line that the selection ended on (zero-based, exclusive).
    endCharacter: Int!

    # The literal textual (UTF-8) lines before the line the selection started
    # on.
    #
    # This is an arbitrary number of lines, and may be zero lines, but typically 3.
    linesBefore: [String!]!

    # The literal textual (UTF-8) lines of the selection. i.e. all lines
    # startLine through endLine.
    lines: [String!]!

    # The literal textual (UTF-8) lines after the line the selection ended on.
    #
    # This is an arbitrary number of lines, and may be zero lines, but typically 3.
    linesAfter: [String!]!
}

# A discussion thread that is centered around:
#
# - A repository.
# - A directory inside a repository.
# - A file inside a repository.
# - A selection inside a file inside a repository.
#
type DiscussionThreadTargetRepo {
    # The repository in which the thread was created.
    repository: Repository!

    # The path (relative to the repository root) of the file or directory that
    # the thread is referencing, if any. If the path is null, the thread is not
    # talking about a specific path but rather just the repository generally.
    path: String

    # The branch or other human-readable Git ref (e.g. "HEAD~2", but not exact
    # Git revision), that the thread was referencing, if any.
    #
    # TODO(slimsag:discussions): Consider renaming this to e.g. "ref" or
    # something else which properly communicates "this can be any Git
    # branch/tag/abbreviated revision/ref *except* an absolute Git revision"
    branch: GitRef

    # The exact revision that the thread was referencing, if any.
    revision: GitRef

    # The selection that the thread was referencing, if any.
    selection: DiscussionThreadTargetRepoSelection

    # Where the path would be relative to the given Git revision specifier
    # (branch/commit/etc). i.e., accounting for file renames, deletions, etc.
    #
    # null is returned if there is no path relative to the specified revision,
    # e.g. if the file was deleted or the path field was null.
    relativePath(rev: String!): String

    # Where the selection would be relative to the given Git revision specifier
    # (branch/commit/etc).
    #
    # The implementation relies on a hueristic which is generally good enough,
    # but under certain circumstances may not be as accurate as e.g. determining
    # this placement by walking through the Git history.
    #
    # If determining the relative placement is not possible (file was renamed
    # or removed, the selection no longer exists in the file, or the hueristic
    # failed) null is returned and it should be assumed the selection does not
    # exist in this revision.
    relativeSelection(rev: String!): DiscussionSelectionRange
}

# The target of a discussion thread. Today, the only possible target is a
# repository. In the future, this may be extended to include other targets such
# as user profiles, extensions, etc. Clients should ignore target types they
# do not understand gracefully.
union DiscussionThreadTarget = DiscussionThreadTargetRepo

# A discussion thread around some target (e.g. a file in a repo).
type DiscussionThread implements Node {
    # The discussion thread ID (globally unique).
    id: ID!

    # The discussion thread ID without its kind, which is globally unique among threads but not
    # among all GraphQL nodes. For example, this is a string like "123" (and DiscussionThread#id is
    # a string like "RGlzY3Vzc2l...").
    idWithoutKind: String!

    # The user who authored this discussion thread.
    author: User!

    # The title of the thread.
    #
    # Note: the contents of the thread (its 'body') is always the first comment
    # in the thread. It is always present, even if the user e.g. input no content.
    title: String!

    # The target of this discussion thread.
    target: DiscussionThreadTarget!

    # The URL at which this thread can be viewed inline (i.e. in the file blob view).
    #
    # This will be null if the thread target is not DiscussionThreadTargetRepo
    # OR if it was created without a path string.
    inlineURL: String

    # The date when the discussion thread was created.
    createdAt: DateTime!

    # The date when the discussion thread was last updated.
    updatedAt: DateTime!

    # The date when the discussion thread was archived (or null if it has not).
    archivedAt: DateTime

    # The comments in the discussion thread.
    comments(
        # Returns the first n comments from the list.
        first: Int
    ): DiscussionCommentConnection!
}

# A comment made within a discussion thread.
type DiscussionComment implements Node {
    # The discussion comment ID (globally unique).
    id: ID!

    # The discussion comment ID without its kind, which is globally unique among comments but not
    # among all GraphQL nodes. For example, this is a string like "123" (and DiscussionComment#id is
    # a string like "RGlzY3Vzc2l...").
    idWithoutKind: String!

    # The discussion thread the comment was made in.
    thread: DiscussionThread!

    # The user who authored this discussion thread.
    author: User!

    # The actual markdown contents of the comment.
    #
    # If the comment was created without any contents (after trimming whitespace)
    # then the title of the thread will be returned.
    contents: String!

    # The markdown contents rendered as an HTML string. It is already sanitized
    # and escaped and thus is always safe to render.
    #
    # If the comment was created without any contents (after trimming whitespace)
    # then the title of the thread will be returned.
    html(options: MarkdownOptions): String!

    # The URL at which this thread can be viewed inline (i.e. in the file blob view).
    #
    # This will be null if the thread was created without a path string.
    inlineURL: String

    # The date when the discussion thread was created.
    createdAt: DateTime!

    # The date when the discussion thread was last updated.
    updatedAt: DateTime!

    # Reports filed by users about this comment. Only admins will receive a non
    # empty list of reports.
    #
    # When discussions.abuseProtection in the site config is set to false, this
    # will always be an empty list.
    reports: [String!]!

    # Whether or not the comment can be reported.
    #
    # This is always false when discussions.abuseProtection in the site config is set to false.
    canReport: Boolean!

    # Whether or not the comment can be deleted.
    canDelete: Boolean!

    # Whether or not the comment can have its reports be cleared.
    #
    # This is always false when discussions.abuseProtection in the site config is set to false.
    canClearReports: Boolean!
}

# A list of discussion threads.
type DiscussionThreadConnection {
    # A list of discussion threads.
    nodes: [DiscussionThread!]!

    # The total count of discussion threads in the connection. This total
    # count may be larger than the number of nodes in this object when the
    # result is paginated.
    totalCount: Int!

    # Pagination information.
    pageInfo: PageInfo!
}

# A list of discussion comments.
type DiscussionCommentConnection {
    # A list of discussion comments.
    nodes: [DiscussionComment!]!

    # The total count of discussion comments in the connection. This total
    # count may be larger than the number of nodes in this object when the
    # result is paginated.
    totalCount: Int!

    # Pagination information.
    pageInfo: PageInfo!
}

# RepositoryOrderBy enumerates the ways a repositories list can be ordered.
enum RepositoryOrderBy {
    REPOSITORY_NAME
    REPO_CREATED_AT # deprecated (use the equivalent REPOSITORY_CREATED_AT)
    REPOSITORY_CREATED_AT
}

# The default settings for the Sourcegraph instance. This is hardcoded in
# Sourcegraph, but may change from release to release.
type DefaultSettings implements SettingsSubject {
    # The opaque GraphQL ID.
    id: ID!
    # The latest default settings (this never changes).
    latestSettings: Settings
    # The URL to the default settings. This URL does not exist because you
    # cannot edit or directly view default settings.
    settingsURL: String
    # Whether the viewer can modify the subject's settings. Always false for
    # default settings.
    viewerCanAdminister: Boolean!
    # The default settings, and the final merged settings.
    #
    # All viewers can access this field.
    settingsCascade: SettingsCascade!
    # DEPRECATED
    configurationCascade: ConfigurationCascade!
        @deprecated(
            reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release."
        )
}

# A site is an installation of Sourcegraph that consists of one or more
# servers that share the same configuration and database.
#
# The site is a singleton; the API only ever returns the single global site.
type Site implements SettingsSubject {
    # The site's opaque GraphQL ID. This is NOT the "site ID" as it is referred to elsewhere;
    # use the siteID field for that. (GraphQL node types conventionally have an id field of type
    # ID! that globally identifies the node.)
    id: ID!
    # The site ID.
    siteID: String!
    # The site's configuration. Only visible to site admins.
    configuration: SiteConfiguration!
    # The site's critical configuration. Only visible to site admins.
    criticalConfiguration: CriticalConfiguration!
    # The site's latest site-wide settings (which are the second-lowest-precedence
    # in the configuration cascade for a user).
    latestSettings: Settings
    # The global settings for this site, and the final merged settings.
    #
    # All viewers can access this field.
    settingsCascade: SettingsCascade!
    # DEPRECATED
    configurationCascade: ConfigurationCascade!
        @deprecated(
            reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release."
        )
    # The URL to the site's settings.
    settingsURL: String
    # Whether the viewer can reload the site (with the reloadSite mutation).
    canReloadSite: Boolean!
    # Whether the viewer can modify the subject's settings.
    viewerCanAdminister: Boolean!
    # A list of all access tokens on this site.
    accessTokens(
        # Returns the first n access tokens from the list.
        first: Int
    ): AccessTokenConnection!
    # A list of all authentication providers. This information is visible to all viewers and does not contain any
    # secret information.
    authProviders: AuthProviderConnection!
    # A list of all user external accounts on this site.
    externalAccounts(
        # Returns the first n external accounts from the list.
        first: Int
        # Include only external accounts associated with this user.
        user: ID
        # Include only external accounts with this service type.
        serviceType: String
        # Include only external accounts with this service ID.
        serviceID: String
        # Include only external accounts with this client ID.
        clientID: String
    ): ExternalAccountConnection!
    # The build version of the Sourcegraph software that is running on this site (of the form
    # NNNNN_YYYY-MM-DD_XXXXX, like 12345_2018-01-01_abcdef).
    buildVersion: String!
    # The product version of the Sourcegraph software that is running on this site.
    productVersion: String!
    # Information about software updates for the version of Sourcegraph that this site is running.
    updateCheck: UpdateCheck!
    # Whether the site needs to be configured to add repositories.
    needsRepositoryConfiguration: Boolean!
    # Whether the site is over the limit for free user accounts, and a warning needs to be shown to all users.
    # Only applies if the site does not have a valid license.
    freeUsersExceeded: Boolean!

    # DEPRECATED: This field is always false and will be removed in future
    # releases. All repositories are enabled by default starting with
    # Sourcegraph 3.4
    #
    # Whether the site has zero access-enabled repositories.
    noRepositoriesEnabled: Boolean!
        @deprecated(reason: "All repositories are enabled by default now. This field is always false.")
    # Alerts to display to the viewer.
    alerts: [Alert!]!
    # BACKCOMPAT: Always returns true.
    hasCodeIntelligence: Boolean!
    # Whether we want to show built-in searches on the saved searches page
    disableBuiltInSearches: Boolean!
    # Whether the server sends emails to users to verify email addresses. If false, then site admins must manually
    # verify users' email addresses.
    sendsEmailVerificationEmails: Boolean!
    # Information about this site's product subscription status.
    productSubscription: ProductSubscriptionStatus!
    # Usage statistics for this site.
    usageStatistics(
        # Days of history (based on current UTC time).
        days: Int
        # Weeks of history (based on current UTC time).
        weeks: Int
        # Months of history (based on current UTC time).
        months: Int
    ): SiteUsageStatistics!
    # (experimental) The extended usage statistics API may change substantially in the near
    # future as we continue to adjust it for our use cases. Changes will not be documented
    # in the CHANGELOG during this time.
    # Usage statistics of code intelligence features.
    codeIntelUsageStatistics(
        # Days of history (based on current UTC time).
        days: Int
        # Weeks of history (based on current UTC time).
        weeks: Int
        # Months of history (based on current UTC time).
        months: Int
    ): CodeIntelUsageStatistics!
}

# The configuration for a site.
type SiteConfiguration {
    # The unique identifier of this site configuration version.
    id: Int!
    # The effective configuration JSON.
    effectiveContents: JSONCString!
    # Messages describing validation problems or usage of deprecated configuration in the configuration JSON.
    # This includes both JSON Schema validation problems and other messages that perform more advanced checks
    # on the configuration (that can't be expressed in the JSON Schema).
    validationMessages: [String!]!
}

# The critical configuration for a site.
type CriticalConfiguration {
    # The unique identifier of this site configuration version.
    id: Int!
    # The effective configuration JSON.
    effectiveContents: JSONCString!
}

# Information about software updates for Sourcegraph.
type UpdateCheck {
    # Whether an update check is currently in progress.
    pending: Boolean!
    # When the last update check was completed, or null if no update check has
    # been completed (or performed) yet.
    checkedAt: DateTime
    # If an error occurred during the last update check, this message describes
    # the error.
    errorMessage: String
    # If an update is available, the version string of the updated version.
    updateVersionAvailable: String
}

# The possible types of alerts (Alert.type values).
enum AlertType {
    INFO
    WARNING
    ERROR
}

# An alert message shown to the viewer.
type Alert {
    # The type of this alert.
    type: AlertType!
    # The message body of this alert. Markdown is supported.
    message: String!
    # If set, this alert is dismissible. After being dismissed, no other alerts with the same
    # isDismissibleWithKey value will be shown. If null, this alert is not dismissible.
    isDismissibleWithKey: String
}

# SettingsSubject is something that can have settings: a site ("global settings", which is different from "site
# configuration"), an organization, or a user.
interface SettingsSubject {
    # The ID.
    id: ID!
    # The latest settings.
    latestSettings: Settings
    # The URL to the settings.
    settingsURL: String
    # Whether the viewer can modify the subject's settings.
    viewerCanAdminister: Boolean!
    # All settings for this subject, and the individual levels in the settings cascade (global > organization > user)
    # that were merged to produce the final merged settings.
    settingsCascade: SettingsCascade!
    # DEPRECATED
    configurationCascade: ConfigurationCascade!
        @deprecated(
            reason: "Use settingsCascade instead. This field is a deprecated alias for it and will be removed in a future release."
        )
}

# The configurations for all of the relevant settings subjects, plus the merged settings.
type SettingsCascade {
    # The other settings subjects that are applied with lower precedence than this subject to
    # form the final merged settings. For example, a user in 2 organizations would have the following
    # settings subjects: site (global settings), org 1, org 2, and the user.
    subjects: [SettingsSubject!]!
    # The effective final merged settings as (stringified) JSON, merged from all of the subjects.
    final: String!
    # DEPRECATED: This field will be removed in a future release.
    #
    # The effective final merged settings, merged from all of the subjects.
    merged: Configuration! @deprecated(reason: "use final instead")
}

# DEPRECATED: Renamed to SettingsCascade.
type ConfigurationCascade {
    # DEPRECATED
    subjects: [SettingsSubject!]! @deprecated(reason: "use SettingsCascade.subjects instead")
    # DEPRECATED
    merged: Configuration! @deprecated(reason: "use SettingsCascade.final instead")
}

# Settings is a version of a configuration settings file.
type Settings {
    # The ID.
    id: Int!
    # The subject that these settings are for.
    subject: SettingsSubject!
    # The author, or null if there is no author or the authoring user was deleted.
    author: User
    # The time when this was created.
    createdAt: DateTime!
    # The stringified JSON contents of the settings. The contents may include "//"-style comments and trailing
    # commas in the JSON.
    contents: JSONCString!
    # DEPRECATED: This field will be removed in a future release.
    #
    # The configuration.
    configuration: Configuration! @deprecated(reason: "use the contents field instead")
}

# DEPRECATED: Use the contents field on the parent type instead. This type will be removed in a future release.
type Configuration {
    # DEPRECATED: This field will be removed in a future release.
    #
    # The raw JSON contents, encoded as a string.
    contents: JSONCString! @deprecated(reason: "use the contents field on the parent type instead")
    # DEPRECATED: This field is always empty. It will be removed in a future release.
    messages: [String!]! @deprecated(reason: "use client-side JSON Schema validation instead")
}

# UserUsageStatistics describes a user's usage statistics.
#
# This information is visible to all viewers.
type UserUsageStatistics {
    # The number of search queries that the user has performed.
    searchQueries: Int!
    # The number of page views that the user has performed.
    pageViews: Int!
    # The number of code intelligence actions that the user has performed.
    codeIntelligenceActions: Int!
    # The number of find-refs actions that the user has performed.
    findReferencesActions: Int!
    # The last time the user was active (any action, any platform).
    lastActiveTime: String
    # The last time the user was active on a code host integration.
    lastActiveCodeHostIntegrationTime: String
}

# A user event.
enum UserEvent {
    PAGEVIEW
    SEARCHQUERY
    CODEINTEL
    CODEINTELREFS
    CODEINTELINTEGRATION
    CODEINTELINTEGRATIONREFS

    # Product stages
    STAGEMANAGE
    STAGEPLAN
    STAGECODE
    STAGEREVIEW
    STAGEVERIFY
    STAGEPACKAGE
    STAGEDEPLOY
    STAGECONFIGURE
    STAGEMONITOR
    STAGESECURE
    STAGEAUTOMATE
}

# A period of time in which a set of users have been active.
enum UserActivePeriod {
    # Since today at 00:00 UTC.
    TODAY
    # Since the latest Monday at 00:00 UTC.
    THIS_WEEK
    # Since the first day of the current month at 00:00 UTC.
    THIS_MONTH
    # All time.
    ALL_TIME
}

# SiteUsageStatistics describes a site's aggregate usage statistics.
#
# This information is visible to all viewers.
type SiteUsageStatistics {
    # Recent daily active users.
    daus: [SiteUsagePeriod!]!
    # Recent weekly active users.
    waus: [SiteUsagePeriod!]!
    # Recent monthly active users.
    maus: [SiteUsagePeriod!]!
}

# SiteUsagePeriod describes a site's usage statistics for a given timespan.
#
# This information is visible to all viewers.
type SiteUsagePeriod {
    # The time when this started.
    startTime: String!
    # The user count.
    userCount: Int!
    # The registered user count.
    registeredUserCount: Int!
    # The anonymous user count.
    anonymousUserCount: Int!
    # The count of registered users that have been active on a code host integration.
    # Excludes anonymous users.
    integrationUserCount: Int!
    # The user count of Sourcegraph products at each stage of the software development lifecycle.
    stages: SiteUsageStages
}

# Aggregate site usage of features by software development lifecycle stage.
type SiteUsageStages {
    # The number of users using management stage features.
    manage: Int!
    # The number of users using planning stage features.
    plan: Int!
    # The number of users using coding stage features.
    code: Int!
    # The number of users using review stage features.
    review: Int!
    # The number of users using verification stage features.
    verify: Int!
    # The number of users using packaging stage features.
    package: Int!
    # The number of users using deployment stage features.
    deploy: Int!
    # The number of users using configuration stage features.
    configure: Int!
    # The number of users using monitoring stage features.
    monitor: Int!
    # The number of users using security stage features.
    secure: Int!
    # The number of users using automation stage features.
    automate: Int!
}

# A site's aggregate usage statistics of code intel features.
#
# This information is visible to all viewers.
type CodeIntelUsageStatistics {
    # Recent daily code intel usage statistics.
    daily: [CodeIntelUsagePeriod!]!
    # Recent weekly code intel usage statistics.
    weekly: [CodeIntelUsagePeriod!]!
    # Recent monthly code intel usage statistics.
    monthly: [CodeIntelUsagePeriod!]!
}

# Usage statistics of code intel features in a given timespan.
#
# This information is visible to all viewers.
type CodeIntelUsagePeriod {
    # The time when this started.
    startTime: DateTime!
    # Recent hover statistics.
    hover: CodeIntelEventCategoryStatistics!
    # Recent definitions statistics.
    definitions: CodeIntelEventCategoryStatistics!
    # Recent references statistics.
    references: CodeIntelEventCategoryStatistics!
}

# Statistics about aparticular family of code intel features in a given timestan.
type CodeIntelEventCategoryStatistics {
    # Recent LSIF-based code intel event statistics.
    lsif: CodeIntelEventStatistics!
    # Recent LSP-based code intel event statistics.
    lsp: CodeIntelEventStatistics!
    # Recent search-based code intel event statistics.
    search: CodeIntelEventStatistics!
}

# Statistics about a particular code intel feature in a given timespan.
type CodeIntelEventStatistics {
    # The number of unique users that performed this event in this timespan.
    usersCount: Int!
    # The total number of events in this timespan.
    eventsCount: Int!
    # Latency percentiles of all events in this timespan.
    eventLatencies: CodeIntelEventLatencies!
}

# A collection of event latencies for a particular event in a given timespan.
type CodeIntelEventLatencies {
    # The 50th percentile latency in this timespan.
    p50: Float!
    # The 90th percentile latency in this timespan.
    p90: Float!
    # The 99th percentile latency in this timespan.
    p99: Float!
}

# A deployment configuration.
type DeploymentConfiguration {
    # The email.
    email: String
    # The site ID.
    siteID: String
}

# A list of survey responses
type SurveyResponseConnection {
    # A list of survey responses.
    nodes: [SurveyResponse!]!
    # The total count of survey responses in the connection. This total count may be larger
    # than the number of nodes in this object when the result is paginated.
    totalCount: Int!
    # The count of survey responses submitted since 30 calendar days ago at 00:00 UTC.
    last30DaysCount: Int!
    # The average score of survey responses in the connection submitted since 30 calendar days ago at 00:00 UTC.
    averageScore: Float!
    # The net promoter score (NPS) of survey responses in the connection submitted since 30 calendar days ago at 00:00 UTC.
    # Return value is a signed integer, scaled from -100 (all detractors) to +100 (all promoters).
    #
    # See https://en.wikipedia.org/wiki/Net_Promoter for explanation.
    netPromoterScore: Int!
}

# An individual response to a user satisfaction (NPS) survey.
type SurveyResponse {
    # The unique ID of the survey response
    id: ID!
    # The user who submitted the survey (if they were authenticated at the time).
    user: User
    # The email that the user manually entered (if they were NOT authenticated at the time).
    email: String
    # User's likelihood of recommending Sourcegraph to a friend, from 0-10.
    score: Int!
    # The answer to "What is the most important reason for the score you gave".
    reason: String
    # The answer to "What can Sourcegraph do to provide a better product"
    better: String
    # The time when this response was created.
    createdAt: DateTime!
}

# Information about this site's product subscription (which enables access to and renewals of a product license).
type ProductSubscriptionStatus {
    # The full name of the product in use, such as "Sourcegraph Enterprise".
    productNameWithBrand: String!
    # The max number of user accounts that have been active on this Sourcegraph site for the current license.
    # If no license is in use, returns zero.
    actualUserCount: Int!
    # The date and time when the max number of user accounts that have been active on this Sourcegraph site for
    # the current license was reached. If no license is in use, returns an empty string.
    actualUserCountDate: String!
    # The number of users allowed. If there is a license, this is equal to ProductLicenseInfo.userCount. Otherwise,
    # it is the user limit for instances without a license, or null if there is no limit.
    maximumAllowedUserCount: Int
    # The number of free users allowed on a site without a license before a warning is shown to all users, or null
    # if a valid license is in use.
    noLicenseWarningUserCount: Int
    # The product license associated with this subscription, if any.
    license: ProductLicenseInfo
}

# Information about this site's product license (which activates certain Sourcegraph features).
type ProductLicenseInfo {
    # The full name of the product that this license is for. To get the product name for the current
    # Sourcegraph site, use ProductSubscriptionStatus.productNameWithBrand instead (to handle cases where there is
    # no license).
    productNameWithBrand: String!
    # Tags indicating the product plan and features activated by this license.
    tags: [String!]!
    # The number of users allowed by this license.
    userCount: Int!
    # The date when this license expires.
    expiresAt: DateTime!
}

# An extension registry.
type ExtensionRegistry {
    # Find an extension by its extension ID (which is the concatenation of the publisher name, a slash ("/"), and the
    # extension name).
    #
    # To find an extension by its GraphQL ID, use Query.node.
    extension(extensionID: String!): RegistryExtension
    # A list of extensions published in the extension registry.
    extensions(
        # Returns the first n extensions from the list.
        first: Int
        # Returns only extensions from this publisher.
        publisher: ID
        # Returns only extensions matching the query.
        #
        # The following keywords are supported:
        #
        # - category:"C" - include only extensions in the given category.
        # - tag:"T" - include only extensions in the given tag.
        #
        # The following keywords are ignored by the server (so that the frontend can post-process the result set to
        # implement the keywords):
        #
        # - #installed - include only installed extensions.
        # - #enabled - include only enabled extensions.
        # - #disabled - include only disabled extensions.
        query: String
        # Include extensions from the local registry.
        local: Boolean = true
        # Include extensions from remote registries.
        remote: Boolean = true
        # Sorts the list of extension results such that the extensions with these IDs are first in the result set.
        #
        # Typically, the client passes the list of added and enabled extension IDs in this parameter so that the
        # results include those extensions first (which is typically what the user prefers).
        prioritizeExtensionIDs: [String!]
    ): RegistryExtensionConnection!
    # A list of publishers with at least 1 extension in the registry.
    publishers(
        # Return the first n publishers from the list.
        first: Int
    ): RegistryPublisherConnection!
    # A list of publishers that the viewer may publish extensions as.
    viewerPublishers: [RegistryPublisher!]!
    # The extension ID prefix for extensions that are published in the local extension registry. This is the
    # hostname (and port, if non-default HTTP/HTTPS) of the Sourcegraph "externalURL" site configuration property.
    #
    # It is null if extensions published on this Sourcegraph site do not have an extension ID prefix.
    #
    # Examples: "sourcegraph.example.com/", "sourcegraph.example.com:1234/"
    localExtensionIDPrefix: String
}

# A publisher of a registry extension.
union RegistryPublisher = User | Org

# A list of publishers of extensions in the registry.
type RegistryPublisherConnection {
    # A list of publishers.
    nodes: [RegistryPublisher!]!
    # The total count of publishers in the connection. This total count may be larger than the number of
    # nodes in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# Mutations for the extension registry.
type ExtensionRegistryMutation {
    # Create a new extension in the extension registry.
    createExtension(
        # The ID of the extension's publisher (a user or organization).
        publisher: ID!
        # The name of the extension.
        name: String!
    ): ExtensionRegistryCreateExtensionResult!
    # Update an extension in the extension registry.
    #
    # Only authorized extension publishers may perform this mutation.
    updateExtension(
        # The extension to update.
        extension: ID!
        # The new name for the extension, or null to leave unchanged.
        name: String
    ): ExtensionRegistryUpdateExtensionResult!
    # Delete an extension from the extension registry.
    #
    # Only authorized extension publishers may perform this mutation.
    deleteExtension(
        # The ID of the extension to delete.
        extension: ID!
    ): EmptyResponse!
    # Publish an extension in the extension registry, creating it (if it doesn't yet exist) or updating it (if it
    # does).
    #
    # This is a helper that wraps multiple other GraphQL mutations to expose a single API for publishing an
    # extension.
    publishExtension(
        # The extension ID of the extension to publish. If a host prefix (e.g., "sourcegraph.example.com/") is
        # needed and it is not included, it is automatically prepended.
        #
        # Examples: "alice/myextension", "acmecorp/myextension"
        extensionID: String!
        # The extension manifest (as JSON).
        manifest: String!
        # The bundled JavaScript source of the extension.
        bundle: String
        # The source map of the extension's JavaScript bundle, if any.
        #
        # The JavaScript bundle's "//# sourceMappingURL=" directive, if any, is ignored. When the bundle is served,
        # the source map provided here is referenced instead.
        sourceMap: String
        # Force publish even if there are warnings (such as invalid JSON warnings).
        force: Boolean = false
    ): ExtensionRegistryCreateExtensionResult!
}

# The result of Mutation.extensionRegistry.createExtension.
type ExtensionRegistryCreateExtensionResult {
    # The newly created extension.
    extension: RegistryExtension!
}

# The result of Mutation.extensionRegistry.updateExtension.
type ExtensionRegistryUpdateExtensionResult {
    # The newly updated extension.
    extension: RegistryExtension!
}

# The result of Mutation.extensionRegistry.publishExtension.
type ExtensionRegistryPublishExtensionResult {
    # The extension that was just published.
    extension: RegistryExtension!
}

# An extension's listing in the extension registry.
type RegistryExtension implements Node {
    # The unique, opaque, permanent ID of the extension. Do not display this ID to the user; display
    # RegistryExtension.extensionID instead (it is friendlier and still unique, but it can be renamed).
    id: ID!
    # The UUID of the extension. This identifies the extension externally (along with the origin). The UUID maps
    # 1-to-1 to RegistryExtension.id.
    uuid: String!
    # The publisher of the extension. If this extension is from a remote registry, the publisher may be null.
    publisher: RegistryPublisher
    # The qualified, unique name that refers to this extension, consisting of the registry name (if non-default),
    # publisher's name, and the extension's name, all joined by "/" (for example, "acme-corp/my-extension-name").
    extensionID: String!
    # The extension ID without the registry name.
    extensionIDWithoutRegistry: String!
    # The name of the extension (not including the publisher's name).
    name: String!
    # The extension manifest, or null if none is set.
    manifest: ExtensionManifest
    # The date when this extension was created on the registry.
    createdAt: DateTime
    # The date when this extension was last updated on the registry (including updates to its metadata only, not
    # publishing new releases).
    updatedAt: DateTime
    # The date when a release of this extension was most recently published, or null if there are no releases.
    publishedAt: DateTime
    # The URL to the extension on this Sourcegraph site.
    url: String!
    # The URL to the extension on the extension registry where it lives (if this is a remote
    # extension). If this extension is local, then this field's value is null.
    remoteURL: String
    # The name of this extension's registry.
    registryName: String!
    # Whether the registry extension is published on this Sourcegraph site.
    isLocal: Boolean!
    # Whether the extension is marked as a work-in-progress extension by the extension author.
    isWorkInProgress: Boolean!
    # Whether the viewer has admin privileges on this registry extension.
    viewerCanAdminister: Boolean!
}

# A description of the extension, how to run or access it, and when to activate it.
type ExtensionManifest {
    # The raw JSON contents of the manifest.
    raw: String!
    # The description specified in the manifest, if any.
    description: String
    # The URL to the bundled JavaScript source code for the extension, if any.
    bundleURL: String
}

# A list of registry extensions.
type RegistryExtensionConnection {
    # A list of registry extensions.
    nodes: [RegistryExtension!]!
    # The total count of registry extensions in the connection. This total count may be larger than the number of
    # nodes in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
    # The URL to this list, or null if none exists.
    url: String
    # Errors that occurred while communicating with remote registries to obtain the list of extensions.
    #
    # In order to be able to return local extensions even when the remote registry is unreachable, errors are
    # recorded here instead of in the top-level GraphQL errors list.
    error: String
}

# A list of locations within a file.
type LocationConnection {
    # A list of locations within a file.
    nodes: [Location!]!

    # Pagination information.
    pageInfo: PageInfo!
}

# Hover range and markdown content.
type Hover {
    # A markdown string containing the contents of the hover.
    markdown: Markdown!

    # The range to highlight.
    range: Range!
}

# The state an LSIF upload can be in.
enum LSIFUploadState {
    # This upload is being processed.
    PROCESSING

    # This upload failed to be processed.
    ERRORED

    # This upload was processed successfully.
    COMPLETED

    # This upload is queued to be processed later.
    QUEUED
}

# Metadata and status about an LSIF upload.
type LSIFUpload implements Node {
    # The ID.
    id: ID!

    # The project for which this upload provides code intelligence.
    projectRoot: GitTree

    # The original 40-character commit commit supplied at upload time.
    inputCommit: String!

    # The original root supplied at upload time.
    inputRoot: String!

    # The original indexer name supplied at upload time.
    inputIndexer: String!

    # The upload's current state.
    state: LSIFUploadState!

    # The time the upload was uploaded.
    uploadedAt: DateTime!

    # The time the upload was processed.
    startedAt: DateTime

    # The time the upload compelted or errored.
    finishedAt: DateTime

    # Metadata about an upload's failure (not set if state is not ERRORED).
    failure: LSIFUploadFailureReason

    # Whether or not this upload provides intelligence for the tip of the default branch. Find reference
    # queries will return symbols from remote repositories only when this property is true. This property
    # is updated asynchronously and is eventually consistent with the git data known by the Sourcegraph
    # instance.
    isLatestForRepo: Boolean!

    # The rank of this upload in the queue. The value of this field is null if the upload has been processed.
    placeInQueue: Int
}

# Metadata about a LSIF upload failure.
type LSIFUploadFailureReason {
    # A summary of the failure.
    summary: String!

    # The stacktrace of the failure.
    stacktrace: String!
}

# A list of LSIF uploads.
type LSIFUploadConnection {
    # A list of LSIF uploads.
    nodes: [LSIFUpload!]!

    # The total number of uploads in this result set.
    totalCount: Int

    # Pagination information.
    pageInfo: PageInfo!
}

# Mutations that are only used on Sourcegraph.com.
#
# FOR INTERNAL USE ONLY.
type DotcomMutation {
    # Set or unset a user's associated billing information.
    #
    # Only Sourcegraph.com site admins may perform this mutation.
    #
    # FOR INTERNAL USE ONLY.
    setUserBilling(
        # The user to update.
        user: ID!
        # The billing customer ID (on the billing system) to associate this user with. If null, the association is
        # removed (i.e., the user is unlinked from the billing customer record).
        billingCustomerID: String
    ): EmptyResponse!
    # Creates new product subscription for an account.
    #
    # Only Sourcegraph.com site admins may perform this mutation.
    #
    # FOR INTERNAL USE ONLY.
    createProductSubscription(
        # The ID of the user (i.e., customer) to whom this product subscription is assigned.
        accountID: ID!
    ): ProductSubscription!
    # Set or unset a product subscription's associated billing system subscription.
    #
    # Only Sourcegraph.com site admins may perform this mutation.
    #
    # FOR INTERNAL USE ONLY.
    setProductSubscriptionBilling(
        # The product subscription to update.
        id: ID!
        # The billing subscription ID (on the billing system) to associate this product subscription with. If null,
        # the association is removed (i.e., the subscription is unlinked from billing).
        billingSubscriptionID: String
    ): EmptyResponse!
    # Generates and signs a new product license and associates it with an existing product subscription. The
    # product license key is signed with Sourcegraph.com's private key and is verifiable with the corresponding
    # public key.
    #
    # Only Sourcegraph.com site admins may perform this mutation.
    #
    # FOR INTERNAL USE ONLY.
    generateProductLicenseForSubscription(
        # The product subscription to associate with the license.
        productSubscriptionID: ID!
        # The license to generate.
        license: ProductLicenseInput!
    ): ProductLicense!
    # Creates a new product subscription and bills the associated payment method.
    #
    # Only Sourcegraph.com authenticated users may perform this mutation.
    #
    # FOR INTERNAL USE ONLY.
    createPaidProductSubscription(
        # The ID of the user (i.e., customer) to whom the product subscription is assigned.
        #
        # Only Sourcegraph.com site admins may perform this mutation for an accountID != the user ID of the
        # authenticated user.
        accountID: ID!
        # The details of the product subscription.
        productSubscription: ProductSubscriptionInput!
        # The token that represents the payment method used to purchase this product subscription.
        paymentToken: String!
    ): CreatePaidProductSubscriptionResult!
    # Updates a new product subscription and credits or debits the associated payment method.
    #
    # Only Sourcegraph.com site admins and the subscription's account owner may perform this
    # mutation.
    #
    # FOR INTERNAL USE ONLY.
    updatePaidProductSubscription(
        # The subscription to update.
        subscriptionID: ID!
        # The updated details of the product subscription. All fields of the input type must be set
        # (i.e., it does not support passing a null value to mean "do not update this field's
        # value").
        update: ProductSubscriptionInput!
        # The token that represents the payment method used to pay for (or receive credit for) this
        # product subscription update.
        paymentToken: String!
    ): UpdatePaidProductSubscriptionResult!
    # Archives an existing product subscription.
    #
    # Only Sourcegraph.com site admins may perform this mutation.
    #
    # FOR INTERNAL USE ONLY.
    archiveProductSubscription(id: ID!): EmptyResponse!
}

# Mutations that are only used on Sourcegraph.com.
#
# FOR INTERNAL USE ONLY.
type DotcomQuery {
    # The product subscription with the given UUID. An error is returned if no such product
    # subscription exists.
    #
    # Only Sourcegraph.com site admins and the account owners of the product subscription may
    # perform this query.
    #
    # FOR INTERNAL USE ONLY.
    productSubscription(uuid: String!): ProductSubscription!
    # A list of product subscriptions.
    #
    # FOR INTERNAL USE ONLY.
    productSubscriptions(
        # Returns the first n product subscriptions from the list.
        first: Int
        # Returns only product subscriptions for the given account.
        #
        # Only Sourcegraph.com site admins may perform this query with account == null.
        account: ID
        # Returns product subscriptions from users with usernames or email addresses that match the query.
        query: String
    ): ProductSubscriptionConnection!
    # The invoice that would be generated for a new or updated subscription. This is used to show
    # users a preview of the credits, debits, and other billing information before creating or
    # updating a subscription.
    #
    # Performing this query does not mutate any data or cause any billing changes to be made.
    previewProductSubscriptionInvoice(
        # The customer account (user) for whom this preview invoice will be generated, or null if there is none.
        account: ID
        # If non-null, preview the invoice for an update to the existing product subscription. The
        # product subscription's billing customer must match the account parameter. If null, preview
        # the invoice for a new subscription.
        subscriptionToUpdate: ID
        # The parameters for the product subscription to preview. All fields of the input type must
        # be set (i.e., it does not support passing a null value to mean "do not update this field's
        # value" when updating an existing subscription).
        productSubscription: ProductSubscriptionInput!
    ): ProductSubscriptionPreviewInvoice!
    # A list of product licenses.
    #
    # Only Sourcegraph.com site admins may perform this query.
    #
    # FOR INTERNAL USE ONLY.
    productLicenses(
        # Returns the first n product subscriptions from the list.
        first: Int
        # Returns only product subscriptions whose license key contains this substring.
        licenseKeySubstring: String
        # Returns only product licenses associated with the given subscription
        productSubscriptionID: ID
    ): ProductLicenseConnection!
    # A list of product pricing plans for Sourcegraph.
    productPlans: [ProductPlan!]!
}

# A product subscription that was created on Sourcegraph.com.
#
# FOR INTERNAL USE ONLY.
type ProductSubscription implements Node {
    # The unique ID of this product subscription.
    id: ID!
    # The unique UUID of this product subscription. Unlike ProductSubscription.id, this does not
    # encode the type and is not a GraphQL node ID.
    uuid: String!
    # A name for the product subscription derived from its ID. The name is not guaranteed to be unique.
    name: String!
    # The user (i.e., customer) to whom this subscription is granted, or null if the account has been deleted.
    account: User
    # The information that determines the price of this subscription, or null if there is no billing
    # information associated with this subscription.
    invoiceItem: ProductSubscriptionInvoiceItem
    # A list of billing-related events related to this product subscription.
    events: [ProductSubscriptionEvent!]!
    # The currently active product license associated with this product subscription, if any.
    activeLicense: ProductLicense
    # A list of product licenses associated with this product subscription.
    #
    # Only Sourcegraph.com site admins may list inactive product licenses (other viewers should use
    # ProductSubscription.activeLicense).
    productLicenses(
        # Returns the first n product licenses from the list.
        first: Int
    ): ProductLicenseConnection!
    # The date when this product subscription was created.
    createdAt: DateTime!
    # Whether this product subscription was archived.
    isArchived: Boolean!
    # The URL to view this product subscription.
    url: String!
    # The URL to view this product subscription in the site admin area.
    #
    # Only Sourcegraph.com site admins may query this field.
    urlForSiteAdmin: String
    # The URL to view this product subscription's billing information (for site admins).
    #
    # Only Sourcegraph.com site admins may query this field.
    urlForSiteAdminBilling: String
}

# A list of product subscriptions.
#
# FOR INTERNAL USE ONLY.
type ProductSubscriptionConnection {
    # A list of product subscriptions.
    nodes: [ProductSubscription!]!
    # The total count of product subscriptions in the connection. This total count may be larger than the number of
    # nodes in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# A preview of an invoice that would be generated for a new or updated product subscription.
#
# FOR INTERNAL USE ONLY.
type ProductSubscriptionPreviewInvoice {
    # The net price for this invoice, in USD cents. If this invoice represents an update to a
    # subscription, this is the difference between the existing price and the updated price.
    price: Int!
    # For updates to existing subscriptions, the effective date for which this preview invoice was
    # calculated, expressed as the number of seconds since the epoch. For new subscriptions, this is
    # null.
    prorationDate: String
    # Whether this invoice requires manual intervention.
    isDowngradeRequiringManualIntervention: Boolean!
    # The "before" state of the product subscription (i.e., the existing subscription), prior to the update that this preview
    # represents, or null if the preview is for a new subscription.
    beforeInvoiceItem: ProductSubscriptionInvoiceItem
    # The "after" state of the product subscription, with the update applied to the subscription.
    # For new subscriptions, this is just the invoice item for the subscription that will be
    # created.
    afterInvoiceItem: ProductSubscriptionInvoiceItem!
}

# An input type that describes a product license to be generated and signed.
#
# FOR INTERNAL USE ONLY.
input ProductLicenseInput {
    # The tags that indicate which features are activated by this license.
    tags: [String!]!
    # The number of users for which this product subscription is valid.
    userCount: Int!
    # The expiration date of this product license, expressed as the number of seconds since the epoch.
    expiresAt: Int!
}

# A product license that was created on Sourcegraph.com.
#
# FOR INTERNAL USE ONLY.
type ProductLicense implements Node {
    # The unique ID of this product license.
    id: ID!
    # The product subscription associated with this product license.
    subscription: ProductSubscription!
    # Information about this product license.
    info: ProductLicenseInfo
    # The license key.
    licenseKey: String!
    # The date when this product license was created.
    createdAt: DateTime!
}

# A list of product licenses.
#
# FOR INTERNAL USE ONLY.
type ProductLicenseConnection {
    # A list of product licenses.
    nodes: [ProductLicense!]!
    # The total count of product licenses in the connection. This total count may be larger than the number of
    # nodes in this object when the result is paginated.
    totalCount: Int!
    # Pagination information.
    pageInfo: PageInfo!
}

# A product pricing plan for Sourcegraph.
#
# FOR INTERNAL USE ONLY.
type ProductPlan {
    # The billing system's unique ID for the plan.
    billingPlanID: String!
    # The unique ID for the product.
    productPlanID: String!
    # The name of the product plan (e.g., "Enterprise Starter"). This is displayed to the user and
    # should be human-readable.
    name: String!
    # The name with the brand (e.g., "Sourcegraph Enterprise Starter").
    nameWithBrand: String!
    # The price (in USD cents) for one user for a year.
    pricePerUserPerYear: Int!
    # The minimum quantity (user count) that can be purchased. Only applies when using tiered pricing.
    minQuantity: Int
    # Defines if the tiering price should be graduated or volume based.
    tiersMode: String!
    # The tiered pricing for the plan.
    planTiers: [PlanTier!]!
}

# The information about a plan's tier.
#
# FOR INTERNAL USE ONLY.
type PlanTier {
    # The per-user amount.
    unitAmount: Int!
    # The maximum number of users that this tier applies to.
    upTo: Int!
    # The base fee that this tier applies to.
    flatAmount: Int!
}

# The information about a product subscription that determines its price.
#
# FOR INTERNAL USE ONLY.
type ProductSubscriptionInvoiceItem {
    # The product plan for the subscription.
    plan: ProductPlan!
    # This subscription's user count.
    userCount: Int!
    # The date when the subscription expires.
    expiresAt: DateTime!
}

# An input type that describes a product subscription to be purchased. Corresponds to
# ProductSubscriptionInvoiceItem.
#
# FOR INTERNAL USE ONLY.
input ProductSubscriptionInput {
    # The billing plan ID for the subscription (ProductPlan.billingPlanID). This also specifies the
    # billing product, because a plan is associated with its product in the billing system.
    billingPlanID: String!
    # This subscription's user count.
    userCount: Int!
}

# The result of Mutation.dotcom.createPaidProductSubscription.
#
# FOR INTERNAL USE ONLY.
type CreatePaidProductSubscriptionResult {
    # The newly created product subscription.
    productSubscription: ProductSubscription!
}

# The result of Mutation.dotcom.updatePaidProductSubscription.
#
# FOR INTERNAL USE ONLY.
type UpdatePaidProductSubscriptionResult {
    # The updated product subscription.
    productSubscription: ProductSubscription!
}

# An event related to a product subscription.
#
# FOR INTERNAL USE ONLY.
type ProductSubscriptionEvent {
    # The unique ID of the event.
    id: String!
    # The date when the event occurred.
    date: String!
    # The title of the event.
    title: String!
    # A description of the event.
    description: String
    # A URL where the user can see more information about the event.
    url: String
}

# FOR INTERNAL USE ONLY: A status message produced when repositories are being
# cloned
type CloningProgress {
    # The message of this status message
    message: String!
}

# FOR INTERNAL USE ONLY: A status message produced when repositories could not
# be synced from an external service
type ExternalServiceSyncError {
    # The message of this status message
    message: String!
    # The external service that failed to sync
    externalService: ExternalService!
}

# FOR INTERNAL USE ONLY: A status message produced when repositories could not
# be synced
type SyncError {
    # The message of this status message
    message: String!
}

# FOR INTERNAL USE ONLY: A status message
union StatusMessage = CloningProgress | ExternalServiceSyncError | SyncError

# An RFC 3339-encoded UTC date string, such as 1973-11-29T21:33:09Z. This value can be parsed into a
# JavaScript Date using Date.parse. To produce this value from a JavaScript Date instance, use
# Date#toISOString.
scalar DateTime

# Different repository permission levels.
enum RepositoryPermission {
    READ
}
