syntax = "proto3";
package sourcegraph;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "sourcegraph.com/sourcegraph/go-diff/diff/diff.proto";
import "sourcegraph.com/sourcegraph/go-vcs/vcs/vcs.proto";
import "sourcegraph.com/sourcegraph/srclib/graph/def.proto";
import "sourcegraph.com/sourcegraph/srclib/graph/ref.proto";
import "sourcegraph.com/sourcegraph/srclib/unit/unit.proto";
import "src.sourcegraph.com/sourcegraph/pkg/vcsclient/vcsclient.proto";
import "sourcegraph.com/sqs/pbtypes/timestamp.proto";
import "sourcegraph.com/sqs/pbtypes/void.proto";
import "sourcegraph.com/sqs/pbtypes/html.proto";
import "src.sourcegraph.com/sourcegraph/pkg/inventory/inventory.proto";
import "github.com/gengo/grpc-gateway/third_party/googleapis/google/api/annotations.proto";

option (gogoproto.goproto_getters_all) = false;
option (gogoproto.unmarshaler_all) = true;
option (gogoproto.marshaler_all) = true;
option (gogoproto.sizer_all) = true;

message Badge {
	string Name = 1;
	string Description = 2;
	string ImageURL = 3;
	string UncountedImageURL = 4;
	string Markdown = 5;
}

// CombinedStatus is the combined status (i.e., incorporating statuses from all
// contexts) of the repository at a specific rev.
message CombinedStatus {
	// Rev is the revision that this status describes. It is set mutually exclusive with CommitID.
	string Rev = 4;

	// CommitID is the full commit ID of the commit this status describes. It is set mutually exclusively with Rev.
	string CommitID = 1;

	// State is the combined status of the repository. Possible values are: failure,
	// pending, or success.
	string State = 2;

	// Statuses are the statuses for each context.
	repeated RepoStatus Statuses = 3;
}

message Counter {
	string Name = 1;
	string Description = 2;
	string ImageURL = 3;
	string UncountedImageURL = 4;
	string Markdown = 5;
}

// ListOptions specifies general pagination options for fetching a list of results.
message ListOptions {
	int32 PerPage = 1 [(gogoproto.moretags) = "url:\",omitempty\""];
	int32 Page = 2 [(gogoproto.moretags) = "url:\",omitempty\""];
}

// ListResponse specifies a general paginated response when fetching a list of results.
message ListResponse {
	// Total is the total number of results in the list.
	int32 Total = 1 [(gogoproto.moretags) = "url:\",omitempty\""];
}

// StreamResponse specifies a paginated response where the total number of results
// that can be returned is too expensive to compute, unbounded, or unknown.
message StreamResponse {
	// HasMore is true if there are more results available after the returned page.
	bool HasMore = 1 [(gogoproto.moretags) = "url:\",omitempty\""];
}

// Changeset stores information about a changeset.
message Changeset {
	// ID is the unique identifier for this changeset, relative to the repository
	// that contains it.
	int64 ID = 1;

	// Title holds a summary about this changeset.
	string Title = 2;

	// Description holds the description for this changeset.
	string Description = 3;

	// Author is the user that initiated this changeset.
	UserSpec Author = 4 [(gogoproto.nullable) = false];

	// DeltaSpec contains information about the base and head spec for this
	// changeset.
	DeltaSpec DeltaSpec = 5 [(gogoproto.nullable) = true];

	// Merged specifies whether this changeset was merged.
	bool Merged = 6;

	// CreatedAt holds the creation time of this changeset.
	pbtypes.Timestamp CreatedAt = 7;

	// ClosedAt holds the time when this changeset was closed or merged.
	pbtypes.Timestamp ClosedAt = 8;
}

// ChangesetReview contains information about a review submitted on a changeset.
message ChangesetReview {
	// ID holds the unique identifier (with reference to the changeset) of the
	// review.
	int64 ID = 1;

	// Body holds the text description of the review.
	string Body = 2;

	// Author is the spec of the user that submitted this review.
	UserSpec Author = 3 [(gogoproto.nullable) = false];

	// CreatedAt is the date at which this review was submitted.
	pbtypes.Timestamp CreatedAt = 4;

	// EditedAt is the last time at which this review was edited. If the review
	// has never been edited, this value will be nil.
	pbtypes.Timestamp EditedAt = 5;

	// Comments holds any inline comments that were submitted along with this
	// review.
	repeated InlineComment Comments = 6 [(gogoproto.nullable) = true];

	// Deleted specifies whether this review has been removed.
	bool Deleted = 7;
}

// ChangesetEvent holds information about an update that occurred on the
// properties of a Changeset.
message ChangesetEvent {
	// Before holds the changeset as it was before the event.
	Changeset Before = 2 [(gogoproto.nullable) = true];

	// After holds the changeset as it became after the event.
	Changeset After = 3 [(gogoproto.nullable) = true];

	// Op holds the update operation that changed the state.
	ChangesetUpdateOp Op = 4;

	// CreatedAt is the date at which the event was created.
	pbtypes.Timestamp CreatedAt = 5;
}

// InlineComment represents a comment made on a line of code. It is uniquely identified
// via Filename + LineNumber + CommitID. In a Changeset, the CommitID might vary
// within the same file based on whether the comment was made on the lines that
// match the pre-index SHA-1 or the lines that match the post-index SHA-1. Pre
// and post index values may differ from Base and Head of the diff.
// For more information on indexes see http://git-scm.com/docs/git-diff-index
message InlineComment {
	// Filename is the name of the file where this comment was made.
	string Filename = 1;

	// LineNumber is the line number relative to the beginning of the file in
	// the specified commit.
	int32 LineNumber = 2;

	// CommitID is the SHA-1 for the post-image of this file, where the comment
	// was placed. The post-image can be deduced from the file entry in the diff
	// that it belong by extracting it's extended header's index entry.
	string CommitID = 3;

	// Author is the user that initiated this changeset.
	UserSpec Author = 4 [(gogoproto.nullable) = false];

	// Body holds the body of this comment.
	string Body = 5;

	// CreatedAt holds the creation date of this comment.
	pbtypes.Timestamp CreatedAt = 6;

	// EditedAt holds the time when this comment was last edited. If no edits occurred,
	// it will be null.
	pbtypes.Timestamp EditedAt = 7;

	// Deleted indicates whether the comment has been deleted.
	bool Deleted = 8;
}

// A Readme represents a formatted "README"-type file in a repository.
message Readme {
	// Path is the relative path of this readme file from the repository root.
	string Path = 1;

	// HTML is the formatted HTML of this readme.
	string HTML = 2;
}

// GitHubRepo holds additional metadata about GitHub repos.
message GitHubRepo {
	int32 Stars = 1;
}

// RepoConfig describes a repository's config. This config is
// Sourcegraph-specific and is persisted locally.
message RepoConfig {
	// Apps is a list of app IDs denoting the applications that are
	// enabled for this repository.
	repeated string Apps = 1;
}

// Repo represents a source code repository.
message Repo {
	// URI is a normalized identifier for this repository based on its primary clone
	// URL. E.g., "github.com/user/repo".
	string URI = 1;

	// Origin is populated for repos fetched via federation or
	// discovery. It is the hostname of the host that owns the repo.
	string Origin = 21;

	// Name is the base name (the final path component) of the repository, typically
	// the name of the directory that the repository would be cloned into. (For
	// example, for git://example.com/foo.git, the name is "foo".)
	string Name = 2;

	// Description is a brief description of the repository.
	string Description = 3;

	// VCS is the short name of the VCS system that this repository uses: "git" or
	// "hg".
	string VCS = 4;

	// HTTPCloneURL is the HTTPS clone URL of the repository (or the HTTP clone URL, if
	// no HTTPS clone URL is available).
	string HTTPCloneURL = 5;

	// SSHCloneURL is the SSH clone URL if the repository, if any.
	string SSHCloneURL = 6;

	// HomepageURL is the URL to the repository's homepage, if any.
	string HomepageURL = 7;

	// HTMLURL is the URL to the repository's main page on the
	// Sourcegraph server.
	string HTMLURL = 22;

	// DefaultBranch is the default VCS branch used (typically "master" for git
	// repositories and "default" for hg repositories).
	string DefaultBranch = 8;

	// Language is the primary programming language used in this repository.
	string Language = 9;

	// Blocked is whether this repo has been blocked by an admin (and
	// will not be returned via the external API).
	bool Blocked = 10;

	// Deprecated repositories are labeled as such and hidden from global search
	// results.
	bool Deprecated = 11;

	// Fork is whether this repository is a fork.
	bool Fork = 12;

	// Mirror indicates whether this repo's canonical location is on
	// another server. Mirror repos track their upstream.
	bool Mirror = 13;

	// Private is whether this repository is private.
	bool Private = 14;

	// CreatedAt is when this repository was created. If it represents an externally
	// hosted (e.g., GitHub) repository, the creation date is when it was created at
	// that origin.
	pbtypes.Timestamp CreatedAt = 15;

	// UpdatedAt is when this repository's metadata was last updated (on its origin if
	// it's an externally hosted repository).
	pbtypes.Timestamp UpdatedAt = 16;

	// PushedAt is when this repository's was last (VCS-)pushed to.
	pbtypes.Timestamp PushedAt = 17;

	// Permissions describes the permissions that the current user (or anonymous users,
	// if there is no current user) is granted to this repository.
	RepoPermissions Permissions = 18;

	GitHubRepo GitHub = 19;
}

message BadgeList {
	repeated Badge Badges = 1;
}

message CounterList {
	repeated Counter Counters = 1;
}

message RepoBadgesCountHitsOp {
	RepoSpec Repo = 1 [(gogoproto.nullable) = false];
	pbtypes.Timestamp Since = 2;
}

message RepoBadgesCountHitsResult {
	int32 Hits = 1;
}

message RepoListOptions {
	string Name = 1 [(gogoproto.moretags) = "url:\",omitempty\""];

	// Specifies a search query for repositories. If specified, then the Sort and
	// Direction options are ignored
	string Query = 2 [(gogoproto.moretags) = "url:\",omitempty\""];

	repeated string URIs = 3 [(gogoproto.moretags) = "url:\",comma,omitempty\""];
	string Sort = 5 [(gogoproto.moretags) = "url:\",omitempty\""];
	string Direction = 6 [(gogoproto.moretags) = "url:\",omitempty\""];
	bool NoFork = 7 [(gogoproto.moretags) = "url:\",omitempty\""];
	string Type = 8 [(gogoproto.moretags) = "url:\",omitempty\""];
	string Owner = 10 [(gogoproto.moretags) = "url:\",omitempty\""];
	ListOptions ListOptions = 11 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

// RepoPermissions describes the possible permissions that a user (or an anonymous
// user) can be granted to a repository.
message RepoPermissions {
	bool Read = 1;
	bool Write = 2;
	bool Admin = 3;
}

// RepoRevSpec specifies a repository at a specific commit (or revision specifier,
// such as a branch, which is resolved on the server side to a specific commit).
//
// Filling in CommitID is an optional optimization. It avoids the need for another
// resolution of Rev. If CommitID is filled in, the "Rev" route variable becomes
// "Rev===CommitID" (e.g., "master===af4cd6"). Handlers can parse this string to
// retrieve the pre-resolved commit ID (e.g., "af4cd6") and still return data that
// constructs URLs using the unresolved revspec (e.g., "master").
//
// Why is it important/useful to pass the resolved commit ID instead of just using
// a revspec everywhere? Consider this case. Your application wants to make a bunch
// of requests for resources relating to "master"; for example, it wants to
// retrieve a source file foo.go at master and all of the definitions and
// references contained in the file. This may consist of dozens of API calls. If
// each API call specified just "master", there would be 2 problems: (1) each API
// call would have to re-resolve "master" to its actual commit ID, which takes a
// lot of extra work; and (2) if the "master" ref changed during the API calls (if
// someone pushed in the middle of the API call, for example), then your
// application would receive data from 2 different commits. The solution is for
// your application to resolve the revspec once and pass both the original revspec
// and the resolved commit ID in all API calls it makes.
//
// And why do we want to preserve the unresolved revspec? In this case, your app
// wants to let the user continue browsing "master". If the API data all referred
// to a specific commit ID, then the user would cease browsing master the next time
// she clicked a link on your app. Preserving the revspec gives the user a choice
// whether to use the absolute commit ID or the revspec (similar to how GitHub lets
// you canonicalize a URL with 'y' but does not default to using the canonical
// URL).
message RepoRevSpec {
	RepoSpec RepoSpec = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
	string Rev = 2;
	string CommitID = 3;
}

// RepoSpec specifies a repository.
message RepoSpec {
	string URI = 1;
}

// RepoStatus is the status of the repository at a specific rev (in a single
// context).
message RepoStatus {
	// State is the current status of the repository. Possible values are: pending,
	// success, error, or failure.
	string State = 2;

	// TargetURL is the URL of the page representing this status. It will be linked
	// from the UI to allow users to see the source of the status.
	string TargetURL = 3;

	// Description is a short, high-level summary of the status.
	string Description = 4;

	// A string label to differentiate this status from the statuses of other systems.
	string Context = 5;

	pbtypes.Timestamp CreatedAt = 6 [(gogoproto.nullable) = false];
	pbtypes.Timestamp UpdatedAt = 7 [(gogoproto.nullable) = false];
}

message RepoStatusesCreateOp {
	RepoRevSpec Repo = 1 [(gogoproto.nullable) = false];
	RepoStatus Status = 2 [(gogoproto.nullable) = false];
}

message RepoList {
	repeated Repo Repos = 1;
}


service RepoBadges {
	// ListBadges lists the available badges for repo.
	rpc ListBadges(RepoSpec) returns (BadgeList) {
		option (google.api.http) = {
			get: "/repo_badges/list_badges"
		};
	};

	// ListCounters lists the available counters for repo.
	rpc ListCounters(RepoSpec) returns (CounterList) {
		option (google.api.http) = {
			get: "/repo_badges/list_counters"
		};
	};

	// RecordHit records a visit to a repo (that will be reflected in
	// its counter).
	rpc RecordHit(RepoSpec) returns (pbtypes.Void) {
		option (google.api.http) = {
			put: "/repo_badges/record_hit"
		};
	};

	// CountHits returns the hit count (optionally in a recent time
	// period).
	rpc CountHits(RepoBadgesCountHitsOp) returns (RepoBadgesCountHitsResult) {
		option (google.api.http) = {
			get: "/repo_badges/count_hits"
		};
	};
}

service RepoStatuses {
	// GetCombined fetches the combined repository status for the given commit.
	rpc GetCombined(RepoRevSpec) returns (CombinedStatus) {
		option (google.api.http) = {
			get: "/repo_statuses"
		};
	};

	// Create creates a repository status for the given commit.
	rpc Create(RepoStatusesCreateOp) returns (RepoStatus) {
		option (google.api.http) = {
			post: "/repo_statuses"
		};
	};
}

// Repos exposes information about and actions on both locally hosted
// and remote repositories.
service Repos {
	// Get fetches a repository.
	rpc Get(RepoSpec) returns (Repo) {
		option (google.api.http) = {
			get: "/repos"
		};
	};

	// List repositories.
	rpc List(RepoListOptions) returns (RepoList) {
		option (google.api.http) = {
			get: "/repos/list"
		};
	};

	// Create creates a new repository.
	rpc Create(ReposCreateOp) returns (Repo) {
		option (google.api.http) = {
			post: "/repos"
		};
	};

	// Update updates a repository.
	rpc Update(ReposUpdateOp) returns (Repo);

	// Delete removes a repository.
	rpc Delete(RepoSpec) returns (pbtypes.Void) {
		option (google.api.http) = {
			delete: "/repos"
		};
	};

	// GetReadme fetches the formatted README file for a repository.
	rpc GetReadme(RepoRevSpec) returns (Readme) {
		option (google.api.http) = {
			get: "/repos/get_readme"
		};
	};

	// GetConfig retrieves the configuration for a repository.
	rpc GetConfig(RepoSpec) returns (RepoConfig) {
		option (google.api.http) = {
			get: "/repos/get_config"
		};
	};

	// TODO(sqs!nodb-ctx): move these to a "VCS" service (not Repos)
	// TODO(slimsag): add google.api.http annotations to these once moved
	rpc GetCommit(RepoRevSpec) returns (vcs.Commit);
	// ListCommits returns the list of commits that span between the revisions
	// specified in the given DeltaSpec. By default, it will return 1 page of
	// commits with a maximum of DefaultPerPage entries. To retrieve all commits
	// the PerPage value can be set to -1.
	rpc ListCommits(ReposListCommitsOp) returns (CommitList);
	rpc ListBranches(ReposListBranchesOp) returns (BranchList);
	rpc ListTags(ReposListTagsOp) returns (TagList);

	// ListCommitters returns the list of authors who have contributed
	// to the main branch of the repo.
	rpc ListCommitters(ReposListCommittersOp) returns (CommitterList);

	// GetSrclibDataVersionForPath searches for the newest commit
	// built by srclib for the given path and commit. If the
	// TreeEntrySpec's Path field refers to a file or directory, the
	// commit log for that path will be consulted and only srclib data
	// versions will be returned that are after the most recent change
	// affecting the path. If the TreeEntrySpec's path is empty (""),
	// the most recently built commit on the TreeEntrySpec's branch
	// (rev) is returned, subject to an implementation-defined maximum
	// depth.
	//
	// Defining this method separately from the methods on Builds let
	// us have this specific behavior and makes it easier to supply
	// srclib data for older versions that is still accurate.
	rpc GetSrclibDataVersionForPath(TreeEntrySpec) returns (SrclibDataVersion);

	// ConfigureApp configures an application for a repository.
	rpc ConfigureApp(RepoConfigureAppOp) returns (pbtypes.Void);

	// GetInventory performs an inventory of the repository's contents
	// at a specific commit. It returns a summary of the programming
	// languages, etc., used by the repository, as evidenced by the
	// repository's files.
	rpc GetInventory(RepoRevSpec) returns (inventory.Inventory);
}

// SrclibDataVersion specifies a srclib store version.
message SrclibDataVersion {
	string CommitID = 1;
	int32 CommitsBehind = 2;
}

message RepoConfigureAppOp {
	// Repo is the repository whose applications are being configured.
	RepoSpec Repo = 1 [(gogoproto.nullable) = false];

	// App is the app ID to enable or disable.
	string App = 2;

	// Enable is true if the app should be enabled and false if it
	// should be disabled.
	bool Enable = 3;
}

// StorageBucket represents the location where keys are stored.
//
// Understanding the name-spacing of storage objects is often helped by
// visualizing the filesystem-backed implementation, which looks like:
//
//  /repo/<Repo>/<AppName>/<Bucket>/<Key>
//  /global/<AppName>/<Bucket>/<Key>
//
message StorageBucket {
	// AppName is the name of the application whose data you are trying to
	// read/write, applications may read and write to each other's data assuming
	// the admin has not restricted such access.
	string AppName = 1;

	// Repo is the repository URI. If specified storage is considered local to the
	// repository. Otherwise it is considered "global" (i.e. shared across all
	// repositories).
	string Repo = 2;

	// Name is the bucket name. In filesystem terminology, a bucket is a 'folder'
	// and an object is a 'file'.
	string Name = 3;
}

// StorageKey is a storage object's key.
message StorageKey {
	// Bucket is the bucket name.
	StorageBucket Bucket = 3;

	// Key is the name of the storage object. In filesystem terminology, this is
	// the 'filename' and thus must be unique against all other key names in the
	// bucket.
	string Key = 4;
}

// StorageValue is the value of a storage object.
message StorageValue {
	// Value is the value of the object.
	bytes Value = 2;
}

// StoragePutOp is the parameters for putting an object into storage.
message StoragePutOp {
	// Key is the key of the object to put into storage.
	StorageKey Key = 1 [(gogoproto.nullable) = false];

	// Value is the value of the object.
	bytes Value = 2;
}

// StorageExists is the result from checking if a storage object exists within
// a bucket.
message StorageExists {
	bool Exists = 1;
}

// StorageList is the result from listing all the keys in a storage bucket.
message StorageList {
	repeated string Keys = 1;
}

// Storage provides applications with storage mechanisms. It is a simple key /
// value store.
service Storage {
	// Get gets the value of a storage object.
	//
	// If the specified object does not exist, a NotFound error is returned.
	rpc Get(StorageKey) returns (StorageValue) {
		option (google.api.http) = {
			get: "/storage"
		};
	}

	// Put puts an object into storage overwriting the old object (if any).
	rpc Put(StoragePutOp) returns (pbtypes.Void) {
		option (google.api.http) = {
			put: "/storage"
		};
	}

	// PutNoOverwrite puts an object into storage, returning a AlreadyExists error
	// if the object already exists.
	rpc PutNoOverwrite(StoragePutOp) returns (pbtypes.Void) {
		option (google.api.http) = {
			put: "/storage"
		};
	}

	// Delete deletes the specific storage object or, if no key is specified, all
	// objects in the bucket.
	//
	// If the given key or bucket does not exist, this function is no-op.
	rpc Delete(StorageKey) returns (pbtypes.Void) {
		option (google.api.http) = {
			delete: "/storage"
		};
	}

	// Exists tells if the given key exists in the bucket or not.
	//
	// If the object does not exist, no error is returned, only exists=false is
	// returned.
	rpc Exists(StorageKey) returns (StorageExists) {
		option (google.api.http) = {
			get: "/storage/exists"
		};
	}

	// List lists all objects in the bucket. It ignores the 'key' field of the
	// storage name parameter.
	//
	// If the bucket does not exist, no error is returned, only an empty list is
	// returned.
	rpc List(StorageKey) returns (StorageList) {
		option (google.api.http) = {
			get: "/storage/list"
		};
	}
}

service Changesets {
	// Create creates a new Changeset and returns it, populating
	// its fields, such as ID and CreatedAt.
	rpc Create(ChangesetCreateOp) returns (Changeset);

	// Get returns the changeset by RepoSpec and ID.
	rpc Get(ChangesetSpec) returns (Changeset);

	// List lists changesets for a repository.
	rpc List(ChangesetListOp) returns (ChangesetList);

	// Update updates a changeset's fields and returns the
	// update event. If no update occurred, it returns nil.
	rpc Update(ChangesetUpdateOp) returns (ChangesetEvent);

	// Merge merges the head branch of a changeset into its base branch and
	// pushes the resulting merged base. It returns the resulting update event.
	// If no merge occurred, it returns nil.
	rpc Merge(ChangesetMergeOp) returns (ChangesetEvent);

	// UpdateAffected updates all changesets which may be affected
	// by new commits to a branch and returns the list of update
	// events for all affected changesets.
	rpc UpdateAffected(ChangesetUpdateAffectedOp) returns (ChangesetEventList);

	// CreateReview creates a new Review and returns it, populating
	// its fields, such as ID and CreatedAt.
	rpc CreateReview(ChangesetCreateReviewOp) returns (ChangesetReview);

	// ListReviews returns all reviews for a given changeset.
	rpc ListReviews(ChangesetListReviewsOp) returns (ChangesetReviewList);

	// ListEvents returns all the events that occurred on a given changeset.
	rpc ListEvents(ChangesetSpec) returns (ChangesetEventList);
}

message ReposCreateOp {
	// URI is the desired URI of the new repository.
	string URI = 1;

	// VCS is the desired VCS type of the new repository (only "git"
	// is currently supported).
	string VCS = 2;

	// CloneURL is the clone URL of the repository for mirrored
	// repositories. If blank, a new hosted repository is created
	// (i.e., a repo whose origin is on the server). If Mirror is
	// true, a clone URL must be provided.
	string CloneURL = 3;

	// Mirror is a boolean value indicating whether the newly created
	// repository should be a mirror. Mirror repositories are
	// periodically updated to track their upstream (which is
	// specified using the CloneURL field of this message).
	bool Mirror = 4;

	// Private is whether this repository is private.
	bool Private = 5;

	// Description is the description of the repository.
	string Description = 6;

	// Language is the primary programming language of the repository.
	string Language = 7;
}

// ReposUpdateOp is an operation to update a repository's metadata.
message ReposUpdateOp {
	// Repo is the repository to update.
	RepoSpec Repo = 1 [(gogoproto.nullable) = false];

	// Description is the new description of the repository. If empty,
	// the description is not changed.
	string Description = 2;

	// Language is the new primary programming language of the
	// repository. If empty, the language is not changed.
	string Language = 3;
};

message ReposListCommitsOp {
	RepoSpec Repo = 1 [(gogoproto.nullable) = false];
	RepoListCommitsOptions Opt = 2;
}

message RepoListCommitsOptions {
	string Head = 1 [(gogoproto.moretags) = "url:\",omitempty\""];
	string Base = 2 [(gogoproto.moretags) = "url:\",omitempty\""];
	ListOptions ListOptions = 3 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
	string Path = 4 [(gogoproto.moretags) = "url:\",omitempty\""];
	bool RefreshCache = 5 [(gogoproto.moretags) = "url:\",omitempty\""];
}

message CommitList {
	repeated vcs.Commit Commits = 1;
	StreamResponse StreamResponse = 2 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message ReposListBranchesOp {
	RepoSpec Repo = 1 [(gogoproto.nullable) = false];
	RepoListBranchesOptions Opt = 2;
}

message RepoListBranchesOptions {
	bool IncludeCommit = 4;
	string BehindAheadBranch = 5;
	string ContainsCommit = 6;
	ListOptions ListOptions = 3 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message BranchList {
	repeated vcs.Branch Branches = 1;
	StreamResponse StreamResponse = 2 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message ReposListTagsOp {
	RepoSpec Repo = 1 [(gogoproto.nullable) = false];
	RepoListTagsOptions Opt = 2;
}

message ReposListCommittersOp {
	RepoSpec Repo = 1 [(gogoproto.nullable) = false];
	RepoListCommittersOptions Opt = 2;
}

message RepoListCommittersOptions {
	string Rev = 1;
	ListOptions ListOptions = 2 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message CommitterList {
	repeated vcs.Committer Committers = 1;
	StreamResponse StreamResponse = 2 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message ChangesetCreateOp {
	RepoSpec Repo = 1 [(gogoproto.nullable) = false];
	Changeset Changeset = 2;
}

message ChangesetCreateReviewOp {
	RepoSpec Repo = 1 [(gogoproto.nullable) = false];
	int64 ChangesetID = 2;
	ChangesetReview Review = 3;
}

message ChangesetListReviewsOp {
	RepoSpec Repo = 1 [(gogoproto.nullable) = false];
	int64 ChangesetID = 2;
}

message ChangesetSpec {
	RepoSpec Repo = 1 [(gogoproto.nullable) = false];
	int64 ID = 2;
}

message ChangesetUpdateOp {
	// Repo holds the RepoSpec where the Changeset to be updated is located.
	RepoSpec Repo = 1 [(gogoproto.nullable) = false];

	// ID holds the ID of the changeset that is to be updated.
	int64 ID = 2;

	// Title, if non-empty, will be set as the new title of the changeset.
	string Title = 3;

	// Description, if specified, will become the new description of the changeset.
	string Description = 4;

	// Open, if true, will set the changeset's ClosedAt value to nil.
	bool Open = 5;

	// Close, if true, will set the ClosedAt date.
	bool Close = 6;

	// Merged, if true, will update the changeset to indicate that it was priorly
	// merged.
	bool Merged = 7;

	// Author is the user that initiated this event.
	UserSpec Author = 8 [(gogoproto.nullable) = false];
}

message ChangesetMergeOp {
	// Repo holds the RepoSpec where the Changeset to be merged is located.
	RepoSpec Repo = 1 [(gogoproto.nullable) = false];

	// ID holds the ID of the changeset that is to be merged.
	int64 ID = 2;

	// Message is a text template used to generate a message for the commit of
	// the resulting merge operation. Any of the fields from the changeset are
	// available to use in the template.
	string Message = 3;

	// Squash, if true, will squash the commits of the head branch into a
	// single commit prior to merging.
	bool Squash = 4;
}

message ChangesetUpdateAffectedOp {
	// Repo holds the RepoSpec which received a commit.
	RepoSpec Repo = 1 [(gogoproto.nullable) = false];

	// Branch is the name of the branch which was pushed to.
	string Branch = 2;

	// Last is the SHA1 of the last commit on the branch.
	string Last = 3;

	// Commit is the SHA1 of the tip of the newly pushed commits on the branch.
	string Commit = 4;

	// ForcePush is whether or not the branch was force pushed to.
	bool ForcePush = 5;
}

message RepoListTagsOptions {
	ListOptions ListOptions = 3 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message TagList {
	repeated vcs.Tag Tags = 1;
	StreamResponse StreamResponse = 2 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message MirrorReposRefreshVCSOp {
	reserved 2;

	RepoSpec Repo = 1 [(gogoproto.nullable) = false];
}

// VCSCredentials for authentication during communication with VCS remotes.
message VCSCredentials {
	// Pass is the password provided to the VCS.
	string Pass = 1;
}

// MirrorRepos handles operations related to maintaining mirrors on
// Sourcegraph of repositories hosted elsewhere.
service MirrorRepos {
	// Refresh fetches the newest VCS data from the repo's origin.
	rpc RefreshVCS(MirrorReposRefreshVCSOp) returns (pbtypes.Void) {
		option (google.api.http) = {
			put: "/mirror_repos"
		};
	};
}

// MirroredRepoSSHKeys stores repository SSH keys (e.g., to access
// private repos on some external origin that we mirror).
service MirroredRepoSSHKeys {
	rpc Create(MirroredRepoSSHKeysCreateOp) returns (pbtypes.Void) {
		option (google.api.http) = {
			post: "/mirrored_repo_ssh_keys"
		};
	};

	rpc Get(RepoSpec) returns (SSHPrivateKey) {
		option (google.api.http) = {
			get: "/mirrored_repo_ssh_keys"
		};
	};

	rpc Delete(RepoSpec) returns (pbtypes.Void) {
		option (google.api.http) = {
			delete: "/mirrored_repo_ssh_keys"
		};
	};
}

message MirroredRepoSSHKeysCreateOp {
	RepoSpec Repo = 1 [(gogoproto.nullable) = false];
	SSHPrivateKey Key = 2 [(gogoproto.nullable) = false];
}

// An SSHPrivateKey is an SSH key used to access a repository.
message SSHPrivateKey {
	// PEM is the encoded key.
	bytes PEM = 2;
}


// A Build represents a scheduled, completed, or failed repository analysis and
// import job.
//
// A build is composed of many tasks. The worker that is responsible for a build or
// task determines whether a task failure causes the whole build to fail. (Keep
// reading to see how we determine who is responsible for a build or task.) There
// is no single kind of worker; currently there are 2 things that could be
// considered workers because they build builds or perform tasks: the builders on
// Sourcegraph.com, and anyone who runs `src push` locally.
//
// Each task has logs associated with it, and each task can be associated with a
// single source unit (or not).
//
// Builds have a Queue bool field. If a process creates a build that
// has Queue=true, that means that it relinquishes responsibility for
// it; some other queue workers (on the server, for example) will
// dequeue and complete it. If Queue=false, then the process that
// created it is responsible for completing it. The only exception to
// this is that after a certain timeout (on the order of 45 minutes),
// started but unfinished builds are marked as failed.
//
// Builds and tasks are simple "build"ing blocks (no pun intended) with simple
// behavior. As we encounter new requirements for the build system, they may
// evolve.
message Build {
	// Repo is the URI of the repository this build is for.
	string Repo = 1;

	// ID is the numeric ID of the build. It is up to the
	// implementation to decide whether it is sequential within the
	// repo or globally unique across all repos.
	uint64 ID = 2;

	// CommitID is the full resolved commit ID to build.
	string CommitID = 3;

	// Branch, if set, is the name of the VCS branch on which this
	// commit was built. Commits may be configured to be built in
	// different ways depending on the branch the build was started on
	// (e.g., a release branch may trigger additional deployment
	// actions). A single commit can exist on any number of branches.
	//
	// A build is recommended to be associated with either a branch or
	// a tag because it is not generally possible to fetch a specific
	// commit from a Git repository; you can only fetch a refspec
	// (branch, tag, etc.). During CI we want to avoid needing to
	// clone *all* branches just to find the specific commit we
	// need. If the branch or tag is specified, we can do a fetch of a
	// specific refspec; otherwise we need to fetch all branches,
	// which makes CI much slower. And Git servers do not let you
	// request a single commit (although this is changing; see
	// http://stackoverflow.com/a/30701724, but it is still disabled
	// by default for apparently good reasons).
	string Branch = 14;

	// Tag, if set, is the name of the VCS tag associated with this
	// commit. See Branch for more information. A single commit can
	// have any number of tags.
	string Tag = 15;

	pbtypes.Timestamp CreatedAt = 4 [(gogoproto.nullable) = false];
	pbtypes.Timestamp StartedAt = 5;
	pbtypes.Timestamp EndedAt = 6;
	pbtypes.Timestamp HeartbeatAt = 7;
	bool Success = 8;
	bool Failure = 9;

	// Killed is true if this build's worker didn't exit on its own accord. It is
	// generally set when no heartbeat has been received within a certain interval. If
	// Killed is true, then Failure must also always be set to true. Unqueued builds
	// are never killed for lack of a heartbeat.
	bool Killed = 10;

	// Host is the hostname of the machine that is working on this build.
	string Host = 11;

	bool Purged = 12;
	BuildConfig BuildConfig = 13 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

// BuildConfig configures a repository build.
message BuildConfig {
	// Queue is whether this build should be enqueued. If enqueued, any worker may
	// begin running this build. If not enqueued, it is up to the client to run the
	// build and update it accordingly.
	bool Queue = 2;

	// Priority of the build in the queue (higher numbers mean the build is dequeued
	// sooner).
	int32 Priority = 4;

	// BuilderConfig is the actual .drone.yml config file that was
	// used to run this build in CI. It reflects all automatic
	// additions/changes made by the worker (i.e., it is not
	// necessarily the same .drone.yml config file as the one in the
	// repository).
	string BuilderConfig = 16;
}

// BuildGetLogOptions specifies options for build log API methods.
message BuildGetLogOptions {
	// MinID indicates that only log entries whose monotonically increasing ID is
	// greater than MinID should be returned.
	//
	// To "tail -f" or watch a log for updates, set each subsequent request's MinID to
	// the MaxID of the previous request.
	string MinID = 1;
}

message BuildListOptions {
	bool Queued = 1 [(gogoproto.moretags) = "url:\",omitempty\""];
	bool Active = 2 [(gogoproto.moretags) = "url:\",omitempty\""];
	bool Ended = 3 [(gogoproto.moretags) = "url:\",omitempty\""];
	bool Succeeded = 4 [(gogoproto.moretags) = "url:\",omitempty\""];
	bool Failed = 5 [(gogoproto.moretags) = "url:\",omitempty\""];
	bool Purged = 6 [(gogoproto.moretags) = "url:\",omitempty\""];
	string Repo = 7 [(gogoproto.moretags) = "url:\",omitempty\""];
	string CommitID = 8 [(gogoproto.moretags) = "url:\",omitempty\""];
	string Sort = 9 [(gogoproto.moretags) = "url:\",omitempty\""];
	string Direction = 10 [(gogoproto.moretags) = "url:\",omitempty\""];
	ListOptions ListOptions = 11 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message ChangesetListOp {
	string Repo = 1;

	// Open, when true, will only return open changesets.
	bool Open = 2;

	// Closed, when true, will only return closed changeset.
	bool Closed = 3;

	// Head, if set, will restrict the returned list to only changesets
	// that have this branch as head.
	string Head = 4;

	// Base, when set, will restrict the list to changesets that have this
	// branch as a base.
	string Base = 5;
	ListOptions ListOptions = 11 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

// A BuildSpec uniquely identifies a build.
message BuildSpec {
	// Repo is the repository associated with the build.
	RepoSpec Repo = 1 [(gogoproto.nullable) = false];

	// ID is the numeric ID of the build. It is up to the
	// implementation to decide whether it is sequential within the
	// repo or globally unique across all repos' builds.
	uint64 ID = 2;
}

// A BuildTask represents an individual step of a build.
//
// See the documentation for Build for more information about how builds and tasks
// relate to each other.
message BuildTask {
	// ID is the numeric ID of the task. It is up to the
	// implementation to decide whether it is sequential within the
	// build or globally unique across all builds.
	uint64 ID = 1;

	// Build specifies the build associated with this task.
	BuildSpec Build = 2 [(gogoproto.nullable) = false];

	// ParentID, if non-zero, indicates that this task's parent is the
	// task (in the same build) with the given ID. A ParentID of zero
	// means that this is a top-level task.
	uint64 ParentID = 3;

	// Label describes the task (e.g., Code Intelligence).
	string Label = 4;

	// CreatedAt is when this task was initially created.
	pbtypes.Timestamp CreatedAt = 5 [(gogoproto.nullable) = false];

	// StartedAt is when this task's execution began.
	pbtypes.Timestamp StartedAt = 6;

	// EndedAt is when this task's execution ended (whether because it succeeded or
	// failed).
	pbtypes.Timestamp EndedAt = 7;

	// Success is whether this task's execution succeeded.
	bool Success = 8;

	// Failure is whether this task's execution failed.
	bool Failure = 9;

	// Skipped is whether this task's execution was skipped.
	bool Skipped = 10;

	// Warnings is whether this task produced warnings. Tasks with
	// warnings are not displayed as "green". The warnings are
	// contained in the task logs.
	bool Warnings = 11;
}

message BuildTaskListOptions {
	ListOptions ListOptions = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

// A BuildUpdate contains updated information to update on an existing build.
message BuildUpdate {
	pbtypes.Timestamp StartedAt = 1;
	pbtypes.Timestamp EndedAt = 2;
	pbtypes.Timestamp HeartbeatAt = 3;
	string Host = 4;
	bool Success = 5;
	bool Purged = 6;
	bool Failure = 7;
	bool Killed = 8;
	int32 Priority = 9;
	string BuilderConfig = 10;
}

message BuildList {
	repeated Build Builds = 1;
	StreamResponse StreamResponse = 2 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message BuildsCreateOp {
	RepoSpec Repo = 1 [(gogoproto.nullable) = false];

	// CommitID is the full commit ID of the commit to build. It is
	// required.
	string CommitID = 2;

	// Branch, if specified, indicates that this build's commit is on
	// the given branch. If Branch is set, Tag must be empty.
	string Branch = 3;

	// Tag, if specified, indicates that this build's commit has the
	// given tag. If Tag is set, Branch must be empty.
	string Tag = 4;

	BuildConfig Config = 5 [(gogoproto.nullable) = false];
}

message BuildsUpdateOp {
	BuildSpec Build = 1 [(gogoproto.nullable) = false];
	BuildUpdate Info = 2 [(gogoproto.nullable) = false];
}

message BuildsListBuildTasksOp {
	BuildSpec Build = 1 [(gogoproto.nullable) = false];
	BuildTaskListOptions Opt = 2;
}

message BuildTaskList {
	repeated BuildTask BuildTasks = 1;
}

message ChangesetReviewList {
	repeated ChangesetReview Reviews = 1;
}

message ChangesetList {
	repeated Changeset Changesets = 1;
}

message ChangesetEventList {
	repeated ChangesetEvent Events = 1;
}

message BuildsCreateTasksOp {
	BuildSpec Build = 1 [(gogoproto.nullable) = false];
	repeated BuildTask Tasks = 2;
}

message BuildsUpdateTaskOp {
	TaskSpec Task = 1 [(gogoproto.nullable) = false];
	TaskUpdate Info = 2 [(gogoproto.nullable) = false];
}

message BuildsGetTaskLogOp {
	TaskSpec Task = 1 [(gogoproto.nullable) = false];
	BuildGetLogOptions Opt = 2;
}

message BuildsDequeueNextOp {
}

// EmailAddr is an email address associated with a user.
message EmailAddr {
	// the email address (case-insensitively compared in the DB and API)
	string Email = 1;

	// whether this email address has been verified
	bool Verified = 2;

	// indicates this is the user's primary email (only 1 email can be primary per user)
	bool Primary = 3;

	// whether Sourcegraph inferred via public data that this is an email for the user
	bool Guessed = 4;

	// indicates that this email should not be associated with the user (even if guessed in the future)
	bool Blacklisted = 5;
}

message LogEntries {
	string MaxID = 1;
	repeated string Entries = 2;
}

message Org {
	User User = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message OrgListMembersOptions {
	ListOptions ListOptions = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

// OrgSpec specifies an organization. At least one of Email, Login, and UID must be
// nonempty.
message OrgSpec {
	string Org = 1;
	int32 UID = 2;
}

message OrgsListMembersOp {
	OrgSpec Org = 1 [(gogoproto.nullable) = false];
	OrgListMembersOptions Opt = 2;
}

message UserList {
	repeated User Users = 1;
}

message UserCount {
	int32 Count = 1;
}

// A Person represents either a registered user or a committer to a repository
// (typically when their commit email can't be resolved to a user).
message Person {
	// PersonSpec is an identifier for the person. If the person was resolved to a
	// user, then both Login and UID are set. Otherwise only Email is set, and it may
	// be obfuscated (to protect privacy).
	PersonSpec PersonSpec = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];

	// FullName is the (possibly empty) full name of the person.
	string FullName = 2;

	// AvatarURL is the URL to the user's avatar image.
	string AvatarURL = 3;
}

// PersonSpec specifies a person. At least one of Email, Login, and UID must be
// nonempty.
message PersonSpec {
	// Email is a person's email address. It may be obfuscated (to protect privacy).
	string Email = 1;

	// Login is a user's login.
	string Login = 2;

	// UID is a user's UID.
	int32 UID = 3;
}

message TaskSpec {
	BuildSpec Build = 1 [(gogoproto.nullable) = false];
	uint64 ID = 2;
}

// A TaskUpdate contains updated information to update on an existing task.
message TaskUpdate {
	pbtypes.Timestamp StartedAt = 1;
	pbtypes.Timestamp EndedAt = 2;
	bool Success = 3;
	bool Failure = 4;
	bool Skipped = 5;
	bool Warnings = 6;
}

// User represents a registered user.
message User {
	// UID is the numeric primary key for a user.
	int32 UID = 1;

	// Login is the user's username.
	string Login = 2;

	// Domain is the host that the user originates from. If empty, it
	// is assumed to be the domain of the server.
	string Domain = 3;

	// Name is the (possibly empty) full name of the user.
	string Name = 4;

	// IsOrganization is whether this user represents an organization.
	bool IsOrganization = 5;

	// AvatarURL is the URL to an avatar image specified by the user.
	string AvatarURL = 6;

	// Location is the user's physical location.
	string Location = 7;

	// Company is the user's company.
	string Company = 8;

	// HomepageURL is the user's homepage or blog URL.
	string HomepageURL = 9;

	// Disabled is whether the user account is disabled.
	bool Disabled = 10;

	// Admin is whether the user is a site admin for the site named by
	// the Domain field.
	bool Admin = 12;

	// Write is whether the user has write access for the site named by
	// the Domain field.
	bool Write = 13;

	// RegisteredAt is the date that the user registered. If the user has not
	// registered (i.e., we have processed their repos but they haven't signed into
	// Sourcegraph), it is null.
	pbtypes.Timestamp RegisteredAt = 11;
}

// UserSpec specifies a user. At least one of Login and UID must be
// nonempty.
message UserSpec {
	// Login is a user's login.
	string Login = 1;

	// UID is a user's UID.
	int32 UID = 2;

	// Domain is the host that the user originates from. If empty, it
	// is assumed to be the domain of the server.
	string Domain = 3;
}

// UsersListOptions specifies options for the UsersService.List method.
message UsersListOptions {
	// Query filters the results to only those whose logins match. The search algorithm
	// is an implementation detail (currently it is a prefix match).
	string Query = 1 [(gogoproto.moretags) = "url:\",omitempty\""];

	string Sort = 2 [(gogoproto.moretags) = "url:\",omitempty\""];
	string Direction = 3 [(gogoproto.moretags) = "url:\",omitempty\""];
	ListOptions ListOptions = 4 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message OrgsListOp {
	UserSpec Member = 1 [(gogoproto.nullable) = false];
	ListOptions ListOptions = 2 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message EmailAddrList {
	repeated EmailAddr EmailAddrs = 1;
}

message OrgList {
	repeated Org Orgs = 1;
}


// BuildsService communicates with the build-related endpoints in the Sourcegraph
// API.
service Builds {
	// Get fetches a build.
	rpc Get(BuildSpec) returns (Build) {
		option (google.api.http) = {
			get: "/builds"
		};
	};

	// GetRepoBuild returns the build for the repo at the given exact
	// commit or branch head commit.
	//
	// NOTE: Previously, this method looked at the build and commit
	// history to find the "best recent build." This method no longer
	// implements that functionality. Refer to
	// Repos.GetSrclibDataVersionForPath.
	rpc GetRepoBuild(RepoRevSpec) returns (Build) {
		option (google.api.http) = {
			get: "/builds/get_repo_build"
		};
	};

	// List builds.
	rpc List(BuildListOptions) returns (BuildList) {
		option (google.api.http) = {
			get: "/builds/list"
		};
	};

	// Create a new build. The build will run asynchronously (Create does not wait for
	// it to return. To monitor the build's status, use Get.)
	rpc Create(BuildsCreateOp) returns (Build) {
		option (google.api.http) = {
			post: "/builds"
		};
	};

	// Update updates information about a build and returns the build after the update
	// has been applied.
	rpc Update(BuildsUpdateOp) returns (Build) {
		option (google.api.http) = {
			put: "/builds/update"
		};
	};

	// ListBuildTasks lists the tasks associated with a build.
	rpc ListBuildTasks(BuildsListBuildTasksOp) returns (BuildTaskList) {
		option (google.api.http) = {
			get: "/builds/list_build_tasks"
		};
	};

	// CreateTasks creates tasks associated with a build and returns them with their
	// TID fields set.
	rpc CreateTasks(BuildsCreateTasksOp) returns (BuildTaskList) {
		option (google.api.http) = {
			post: "/builds/create_tasks"
		};
	};

	// UpdateTask updates a task associated with a build.
	rpc UpdateTask(BuildsUpdateTaskOp) returns (BuildTask) {
		option (google.api.http) = {
			put: "/builds/update_task"
		};
	};

	// GetTaskLog gets log entries associated with a task.
	rpc GetTaskLog(BuildsGetTaskLogOp) returns (LogEntries) {
		option (google.api.http) = {
			get: "/builds/get_task_log"
		};
	};

	// DequeueNext returns the next queued build and marks it as
	// having started (atomically). If there are no builds in the
	// queue, a NotFound error is returned.
	rpc DequeueNext(BuildsDequeueNextOp) returns (Build) {
		option (google.api.http) = {
			get: "/builds/dequeue_next"
		};
	};
}

// OrgsService communicates with the organizations-related endpoints in the
// Sourcegraph API.
service Orgs {
	// Get fetches an organization.
	rpc Get(OrgSpec) returns (Org) {
		option (google.api.http) = {
			get: "/orgs"
		};
	};

	// List lists organizations that a user is a member of.
	rpc List(OrgsListOp) returns (OrgList) {
		option (google.api.http) = {
			get: "/orgs/list"
		};
	};

	// ListMembers lists members of an organization.
	rpc ListMembers(OrgsListMembersOp) returns (UserList) {
		option (google.api.http) = {
			get: "/orgs/list_members"
		};
	};
}

// PeopleService communicates with the people-related endpoints in the Sourcegraph
// API.
service People {
	// Get gets a person. If an email is provided and it resolves to a registered user,
	// information about that user is returned. Otherwise a transient person is created
	// and returned.
	rpc Get(PersonSpec) returns (Person) {
		option (google.api.http) = {
			get: "/people"
		};
	};
}

// Accounts communicates with the account-related endpoints in the
// Sourcegraph API.
//
// For each account, there is also a corresponding user, but there is
// not an account for every user. This is because users may represent
// accounts on external services that Sourcegraph doesn't manage (and
// can't create/update information about).
service Accounts {
	// Create creates a new user account.
	rpc Create(NewAccount) returns (UserSpec) {
		option (google.api.http) = {
			post: "/accounts/create"
		};
	};

	// RequestPasswordReset stores a password reset token in the database, to
	// later verify the authenticity of a user using CheckResetToken
	rpc RequestPasswordReset(PersonSpec) returns (PendingPasswordReset) {
		option (google.api.http) = {
			post: "/accounts/request_password_reset"
		};
	};

	// CheckResetToken verifies a password reset token is authentic and valid
	rpc ResetPassword(NewPassword) returns (pbtypes.Void) {
		option (google.api.http) = {
			post: "/accounts/reset_password"
		};
	};

	// Update profile of existing account.
	rpc Update(User) returns (pbtypes.Void) {
		option (google.api.http) = {
			post: "/accounts/update"
		};
	};

	// Invite creates a pending invite and notifies the recipient via email.
	rpc Invite(AccountInvite) returns (PendingInvite) {
		option (google.api.http) = {
			post: "/accounts/invite"
		};
	};

	// AcceptInvite uses a pending invite to create a new user account.
	rpc AcceptInvite(AcceptedInvite) returns (UserSpec) {
		option (google.api.http) = {
			post: "/accounts/accept_invite"
		};
	};

	// ListInvites lists the pending invites on this server.
	rpc ListInvites(pbtypes.Void) returns (AccountInviteList) {
		option (google.api.http) = {
			post: "/accounts/list_invites"
		};
	};

	// DeleteInvite deletes an existing invite.
	rpc DeleteInvite(InviteSpec) returns (pbtypes.Void) {
		option (google.api.http) = {
			post: "/accounts/delete_invite"
		};
	};

	// Delete deletes a user account from this server.
	rpc Delete(PersonSpec) returns (pbtypes.Void) {
		option (google.api.http) = {
			post: "/accounts/delete"
		};
	};
}

message PasswordResetToken {
	// token is the hard to guess token that allows a user to set a new password.
	string Token = 1;
}

message PendingPasswordReset {
	// Link is the URL for resetting password using this token.
	// It is set in the response only if the request was made
	// by an admin user.
	string Link = 1;

	// Token is the hard to guess token that allows a user to
	// set a new password.
	// It is set in the response only if the request was made
	// by an admin user.
	PasswordResetToken Token = 2;

	// EmailSent is set if the password reset link was emailed to
	// the user.
	bool EmailSent = 3;

	// Login is the login name of user for whom this request is created.
	string Login = 4;
}

message NewPassword {
	// password is the new password for the user who requested the password reset
	// token.
	string Password = 1;

	PasswordResetToken Token = 2;
}

message NewAccount {
	// Login is the desired login for the new user account.
	string Login = 1;

	// Email is the primary email address for the new user account.
	string Email = 2;

	// Password is the password for the new user account.
	string Password = 3;

	// UID is the desired UID for the new user account.
	int32 UID = 4;
}

message AccountInvite {
	// Email is the primary email address for the new user account.
	string Email = 1;

	// Write, if set, will grant write access to the user.
	bool Write = 2;

	// Admin, if set, will grant admin access to the user.
	bool Admin = 3;
}

// An InviteSpec specifies an existing invite.
message InviteSpec {
	// Email is the email address for which the invite was generated.
	string Email = 1;
}

message PendingInvite {
	// Link is the URL for signing up using this invite.
	string Link = 1;

	// Token identifies the pending invite.
	string Token = 2;

	// EmailSent is set if the invite link was emailed to the user.
	bool EmailSent = 3;
}

message AccountInviteList {
	repeated AccountInvite Invites = 1;
}

message AcceptedInvite {
	// Account holds the desired account details.
	NewAccount Account = 1;

	// Token identifies the pending invite.
	string Token = 2;
}

// UsersService communicates with the users-related endpoints in the Sourcegraph
// API.
service Users {
	// Get fetches a user.
	rpc Get(UserSpec) returns (User) {
		option (google.api.http) = {
			get: "/users"
		};
	};

	// GetWithEmail fetches a user by their primary email.
	rpc GetWithEmail(EmailAddr) returns (User) {
		option (google.api.http) = {
			get: "/users/by_email"
		};
	};

	// ListEmails returns a list of a user's email addresses.
	rpc ListEmails(UserSpec) returns (EmailAddrList) {
		option (google.api.http) = {
			get: "/users/list_emails"
		};
	};

	// List users.
	rpc List(UsersListOptions) returns (UserList) {
		option (google.api.http) = {
			get: "/users/list"
		};
	};

	// Count returns the number of users signed up on this instance.
	rpc Count(pbtypes.Void) returns (UserCount) {
		option (google.api.http) = {
			get: "/users/count"
		};
	};
}

message SSHKeyList {
	repeated SSHPublicKey SSHKeys = 1 [(gogoproto.nullable) = false];
}

// UserKeys manages SSH public keys per user.
service UserKeys {
	// AddKey adds an SSH public key for the user, enabling them to use git over SSH.
	//
	// The ID field of SSHPublicKey will be ignored by this method.
	rpc AddKey(SSHPublicKey) returns (pbtypes.Void);

	// LookupUser looks up a user based on the given public key.
	//
	// The ID and Name fields of SSHPublicKey will be ignored by this method.
	rpc LookupUser(SSHPublicKey) returns (UserSpec);

	// DeleteKey deletes the user's SSH public key given an ID or name.
	rpc DeleteKey(SSHPublicKey) returns (pbtypes.Void);

	// ListKeys lists the user's SSH public keys
	rpc ListKeys(pbtypes.Void) returns (SSHKeyList);

	// DeleteAllKeys delets all of the user's SSH public keys
	rpc DeleteAllKeys(pbtypes.Void) returns (pbtypes.Void);
}

// Auth manages authentication and authorization (via OAuth2).
service Auth {
	// GetAuthorizationCodeGrant gets an OAuth2 authorization code
	// grant from the server that can be traded in for an access token
	// by calling GetAccessToken. See
	// https://tools.ietf.org/html/rfc6749#section-4.1 for more
	// information.
	rpc GetAuthorizationCode(AuthorizationCodeRequest) returns (AuthorizationCode);

	// GetAccessToken requests the server to issue an access token
	// using the credentials provided in the AccessTokenRequest.
	//
	// If this call is requesting an access token for a
	// client_credentials grant (i.e., the access token would identify
	// the client, not any specific user), then the request must not
	// be authenticated. If the call is requesting an access token to
	// identify a user, the request must be authenticated using the
	// client's credentials.
	//
	// If the credentials are invalid, grpc.PermissionDenied is
	// returned.
	rpc GetAccessToken(AccessTokenRequest) returns (AccessTokenResponse);

	// Identify describes the currently authenticated user and/or
	// client (if any). It is akin to "whoami".
	rpc Identify(pbtypes.Void) returns (AuthInfo) {
		option (google.api.http) = {
			get: "/auth/identify"
		};
	};
}

// SSHPublicKey that users to authenticate with for SSH git access.
message SSHPublicKey {
	// Key is the serialized key data in SSH wire format, with the name prefix.
	bytes Key = 1;

	// Name is the name of the SSH key.
	string Name = 2;

	// ID is the ID of the SSH key.
	uint64 ID = 3;
}

// AuthorizationCodeRequest: see
// https://tools.ietf.org/html/rfc6749#section-4.1.1.
message AuthorizationCodeRequest {
	string ResponseType = 1;
	string ClientID = 2;
	string RedirectURI = 3;
	repeated string Scope = 4;

	// UID is the UID of the user who will be presented with the code.
	int32 UID = 5;
}

// AuthorizationCode represents an access token request using the
// authorization_code OAuth2 grant type. See
// http://tools.ietf.org/html/rfc6749#section-4.1.3 for more
// information.
//
// The client_id field is not set in this message; it is taken from
// the authenticated client for the request (which must exist).
message AuthorizationCode {
	string Code = 1;
	string RedirectURI = 2;
}

// LoginCredentials is the information a user submits to log in.
message LoginCredentials {
	// Login is the user's claimed login.
	string Login = 1;

	// Password is the password (possibly) corresponding to the login.
	string Password = 2;

	// In the future we can add 2FA tokens, etc., here.
}

// BearerJWT is a Bearer JSON Web Token, which is used for client
// authentication during an authentication grant. See
// https://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer-12#section-2.1
// for more information.
message BearerJWT {
	// Assertion is a JWT.
	string Assertion = 1;
}

// AccessTokenRequest contains the information necessary to
// request an OAuth2 access token. It supports a subset of
// authorization grant types specified in
// http://tools.ietf.org/html/rfc6749#section-4.
message AccessTokenRequest {
	// See http://tools.ietf.org/html/rfc6749#section-1.3 for more
	// information on OAuth2 authorization grant types.
	oneof authorization_grant {
		AuthorizationCode AuthorizationCode = 1;
		LoginCredentials ResourceOwnerPassword = 2;
		BearerJWT BearerJWT = 3;
	}

	// TokenURL is the token endpoint URL on the OAuth2 authorization
	// server that the client is requesting an access token from.
	string TokenURL = 9;

	repeated string Scope = 17;
}

// AccessTokenResponse is a successful access token response. See
// http://tools.ietf.org/html/rfc6749#section-5.1 for more
// information.
message AccessTokenResponse {
	string AccessToken = 1;
	string TokenType = 2;
	int32 ExpiresInSec = 3; // optional
	string RefreshToken = 4; // optional
	repeated string Scope = 5; // optional if equal to the requested scope
}

// AuthInfo describes the currently authenticated client and/or user
// (if any).
message AuthInfo {
	// ClientID is the client ID of the currently authenticated
	// client. If a user is authenticated using an access token,
	// ClientID is the client ID of the registered client that the
	// access token was granted to.
	string ClientID = 1;

	// UID is the UID of the currently authenticated user (if any).
	int32 UID = 2;

	// Domain is the domain of the currently authenticated user (if
	// any), or blank if the user account was registered on the
	// current server.
	string Domain = 3;

	// Login is the login of the currently authenticated user (if any).
	string Login = 4;

	// Write is set if the user (if any) has write access on this server.
	bool Write = 5;

	// Admin is set if the user (if any) has admin access on this server.
	bool Admin = 6;

	// Scopes represent the permissions granted to the authenticated
	// user (if any).
	repeated string Scopes = 7;
}

message AuthorshipInfo {
	string AuthorEmail = 1;
	pbtypes.Timestamp LastCommitDate = 2 [(gogoproto.nullable) = false];

	// LastCommitID is the commit ID of the last commit that this author made to the
	// thing that this info describes.
	string LastCommitID = 3;
}

// Def is a code def returned by the Sourcegraph API.
message Def {
	graph.Def Def = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
	pbtypes.HTML DocHTML = 2;
	graph.DefFormatStrings FmtStrings = 3;
}

message DefAuthor {
	int32 UID = 1;
	string Email = 2;
	DefAuthorship DefAuthorship = 3 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message DefAuthorship {
	AuthorshipInfo AuthorshipInfo = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];

	// Exported is whether the def is exported.
	bool Exported = 2;

	int32 Bytes = 3;
	double BytesProportion = 4;
}

message DefClient {
	int32 UID = 1;
	string Email = 2;
	AuthorshipInfo AuthorshipInfo = 3 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];

	// UseCount is the number of times this person referred to the def.
	int32 UseCount = 4;
}

// A DefDelta represents a single definition that was changed. It has fields for
// the before (Base) and after (Head) versions. If both Base and Head are non-nil,
// then the def was changed from base to head. Otherwise, one of the fields being
// nil means that the def did not exist in that revision (e.g., it was added or
// deleted from base to head).
message DefDelta {
	// the def in the base commit (if nil, this def was added in the head)
	Def Base = 1;

	// the def in the head commit (if nil, this def was deleted in the head)
	Def Head = 2;
}

// DefGetOptions specifies options for DefsService.Get.
message DefGetOptions {
	bool Doc = 1 [(gogoproto.moretags) = "url:\",omitempty\""];
}

// DefListAuthorsOptions specifies options for DefsService.ListAuthors.
message DefListAuthorsOptions {
	ListOptions ListOptions = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

// DefListClientsOptions specifies options for DefsService.ListClients.
message DefListClientsOptions {
	ListOptions ListOptions = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

// DefListExamplesOptions specifies options for DefsService.ListExamples.
message DefListExamplesOptions {
	bool Formatted = 1 [(gogoproto.moretags) = "url:\",omitempty\""];

	// Filter by a specific Repo URI
	string Repo = 2 [(gogoproto.moretags) = "url:\",omitempty\""];

	// TokenizedSource requests that the source code be returned as a tokenized data
	// structure rather than an (annotated) string.
	//
	// This is useful when the client wants to take full control of rendering and
	// manipulating the contents.
	bool TokenizedSource = 3 [(gogoproto.moretags) = "url:\",omitempty\""];

	ListOptions ListOptions = 4 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

// DefListOptions specifies options for DefsService.List.
message DefListOptions {
	string Name = 1 [(gogoproto.moretags) = "url:\",omitempty\""];

	// Specifies a search query for defs. If specified, then the Sort and Direction
	// options are ignored
	string Query = 2 [(gogoproto.moretags) = "url:\",omitempty\""];

	// ByteStart and ByteEnd will restrict the results to only definitions that overlap
	// with the specified start and end byte offsets. This filter is only applied if
	// both values are set.
	uint32 ByteStart = 3;

	// ByteStart and ByteEnd will restrict the results to only definitions that overlap
	// with the specified start and end byte offsets. This filter is only applied if
	// both values are set.
	uint32 ByteEnd = 4;

	// DefKeys, if set, will return the definitions that match the given DefKey
	repeated graph.DefKey DefKeys = 5;

	// RepoRevs constrains the results to a set of repository revisions (given by their
	// URIs plus an optional "@" and a revision specifier). For example,
	// "repo.com/foo@revspec".
	repeated string RepoRevs = 6 [(gogoproto.moretags) = "url:\",omitempty,comma\""];

	string UnitType = 7 [(gogoproto.moretags) = "url:\",omitempty\""];
	string Unit = 8 [(gogoproto.moretags) = "url:\",omitempty\""];
	string Path = 9 [(gogoproto.moretags) = "url:\",omitempty\""];

	// Files, if specified, will restrict the results to only defs defined in the
	// specified file.
	repeated string Files = 10 [(gogoproto.moretags) = "url:\",omitempty\""];

	// FilePathPrefix, if specified, will restrict the results to only defs defined in
	// files whose path is underneath the specified prefix.
	string FilePathPrefix = 11 [(gogoproto.moretags) = "url:\",omitempty\""];

	repeated string Kinds = 12 [(gogoproto.moretags) = "url:\",omitempty,comma\""];
	bool Exported = 13 [(gogoproto.moretags) = "url:\",omitempty\""];
	bool Nonlocal = 14 [(gogoproto.moretags) = "url:\",omitempty\""];

	// IncludeTest is whether the results should include definitions in test files.
	bool IncludeTest = 15 [(gogoproto.moretags) = "url:\",omitempty\""];

	// Enhancements
	bool Doc = 16 [(gogoproto.moretags) = "url:\",omitempty\""];

	bool Fuzzy = 17 [(gogoproto.moretags) = "url:\",omitempty\""];

	// Sorting
	string Sort = 18 [(gogoproto.moretags) = "url:\",omitempty\""];

	string Direction = 19 [(gogoproto.moretags) = "url:\",omitempty\""];

	// Paging
	ListOptions ListOptions = 20 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message DefListRefsOptions {
	bool Authorship = 1 [(gogoproto.moretags) = "url:\",omitempty\""];
	string Repo = 2 [(gogoproto.moretags) = "url:\",omitempty\""];
	ListOptions ListOptions = 3 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

// DefSpec specifies a def.
message DefSpec {
	string Repo = 1;
	string CommitID = 2;
	string UnitType = 3;
	string Unit = 4;
	string Path = 5;
}

message DefsGetOp {
	DefSpec Def = 1 [(gogoproto.nullable) = false];
	DefGetOptions Opt = 2;
}

message DefList {
	repeated Def Defs = 1;
	ListResponse ListResponse = 2 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message DefsListRefsOp {
	DefSpec Def = 1 [(gogoproto.nullable) = false];
	DefListRefsOptions Opt = 2;
}

message RefList {
	repeated Ref Refs = 1;
	StreamResponse StreamResponse = 2 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message DefsListExamplesOp {
	DefSpec Def = 1 [(gogoproto.nullable) = false];
	// If set, source code in the examples will be linked to this branch, rather
	// than to the commit ID.
	string Rev = 2;
	DefListExamplesOptions Opt = 3;
}

message ExampleList {
	repeated Example Examples = 1;
	StreamResponse StreamResponse = 2 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message DefsListAuthorsOp {
	DefSpec Def = 1 [(gogoproto.nullable) = false];
	DefListAuthorsOptions Opt = 2;
}

message DefsListClientsOp {
	DefSpec Def = 1 [(gogoproto.nullable) = false];
	DefListClientsOptions Opt = 2;
}

// Delta represents the difference between two commits (possibly in 2 separate
// repositories).
message Delta {
	RepoRevSpec Base = 1 [(gogoproto.nullable) = false];
	RepoRevSpec Head = 2 [(gogoproto.nullable) = false];
	vcs.Commit BaseCommit = 3;
	vcs.Commit HeadCommit = 4;
	Repo BaseRepo = 5;
	Repo HeadRepo = 6;
}

// DeltaAffectedPerson describes a person (registered user or committer email
// address) that is affected by a delta. It includes fields for the person affected
// as well as the defs that are the reason why we consider them to be affected.
//
// The person's relationship to the Defs depends on what method returned this
// DeltaAffectedPerson. If it was returned by a method that lists authors, then the
// Defs are definitions that the Person committed. If it was returned by a method
// that lists clients (a.k.a users), then the Defs are definitions that the Person
// uses.
message DeltaAffectedPerson {
	// the affected person
	Person Person = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];

	// the defs they authored or use (the reason why they're affected)
	repeated Def Defs = 2;
}

// DeltaDefs describes definitions added/changed/deleted in a delta.
message DeltaDefs {
	// added/changed/deleted defs
	repeated DefDelta Defs = 1;

	// overall diffstat (not subject to pagination)
	diff.Stat DiffStat = 2 [(gogoproto.nullable) = false];
}

// FileDiff holds data about a diff, and additionally stores extended
// information about its hunks.
message FileDiff {
	diff.FileDiff FileDiff = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
	repeated Hunk FileDiffHunks = 2;
	// PreImage is the CommitID at which this file was before the change occurred.
	string PreImage = 3 [(gogoproto.jsontag) = ",omitempty"];
	// PostImage is the CommitID at which this file was after the change occurred.
	string PostImage = 4 [(gogoproto.jsontag) = ",omitempty"];
	// Stat contains statistics about additions and deletions to this diff.
	diff.Stat Stats = 5 [(gogoproto.nullable) = false];
}

// Hunk holds data about a hunk in a diff.
message Hunk {
	diff.Hunk Hunk = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];

	// LinePrefixes holds a string where each character's index corresponds
	// to a line in the BodySource, and its value reflects whether the line
	// is an addition, deletion, or change ('+', '-', ' ').
	string LinePrefixes = 2;

	// BaseSource holds the source code for the original hunk, having all
	// lines starting from the original line down to the end of the hunk.
	SourceCode BaseSource = 3;

	// HeadSource contains the source code for the new hunk, holding
	// all consecutive lines from the start to the end.
	SourceCode HeadSource = 4;

	// BodySource contains the source code for the Hunk body and is a mix
	// of both additions and deletions.
	SourceCode BodySource = 5;
}

// DeltaFiles describes files added/changed/deleted in a delta.
message DeltaFiles {
	repeated FileDiff FileDiffs = 1;
	Delta Delta = 2;
	diff.Stat Stats = 3 [(gogoproto.nullable) = false];

	// OverThreshold will be true when the source code contents of the diff
	// have not been tokenized and linked. This occurs when the 'MaxSize'
	// limit in DeltaListFilesOptions has been met.
	bool OverThreshold = 4;
}

// DeltaFilter specifies criteria by which to filter results from DeltaListXxx
// methods.
message DeltaFilter {
	string Unit = 1 [(gogoproto.moretags) = "url:\",omitempty\""];
	string UnitType = 2 [(gogoproto.moretags) = "url:\",omitempty\""];
}

// DeltaListAffectedAuthorsOptions specifies options for ListAffectedAuthors.
message DeltaListAffectedAuthorsOptions {
	DeltaFilter DeltaFilter = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
	ListOptions ListOptions = 2 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

// DeltaListAffectedClientsOptions specifies options for ListAffectedClients.
message DeltaListAffectedClientsOptions {
	DeltaFilter DeltaFilter = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
	ListOptions ListOptions = 2 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

// DeltaListDefsOptions specifies options for ListDefs.
message DeltaListDefsOptions {
	DeltaFilter DeltaFilter = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
	ListOptions ListOptions = 2 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

// DeltaListFilesOptions specifies options for ListFiles.
message DeltaListFilesOptions {
	// Formatted is whether the files should have their contents code-formatted
	// (syntax-highlighted and reference-linked) if they contain code.
	bool Formatted = 1 [(gogoproto.moretags) = "url:\",omitempty\""];

	// Filter filters the list of returned files to those whose name matches Filter.
	string Filter = 2 [(gogoproto.moretags) = "url:\",omitempty\""];

	// Tokenized, when set, will tokenize the whole source code
	// contained in the diff, returning 3 versions for each hunk: Head
	// revision, Base revision and Hunk body. For more information,
	// see sourcegraph.Hunk.
	bool Tokenized = 3 [(gogoproto.moretags) = "url:\",omitempty\""];

	// MaxSize stores the maximum number of bytes that will be accepted for tokenizing
	// the diff. If the size of the diff exceeds this value, the returned structure
	// will not contain the linked and tokenized source code.
	// This option is useful when one wishes to present the data in a browser and it
	// may be too large for that. DeltaFiles structure size can be up to 4 times the
	// size of the raw diff when tokenized and linked.
	int32 MaxSize = 4 [(gogoproto.moretags) = "url:\",omitempty\""];

	DeltaFilter DeltaFilter = 5 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

// DeltaListUnitsOptions specifies options for ListUnits.
message DeltaListUnitsOptions {
}

// A DeltaSpec specifies a delta.
message DeltaSpec {
	RepoRevSpec Base = 1 [(gogoproto.nullable) = false];
	RepoRevSpec Head = 2 [(gogoproto.nullable) = false];
}

message DeltasListUnitsOp {
	DeltaSpec Ds = 1 [(gogoproto.nullable) = false];
	DeltaListUnitsOptions Opt = 2;
}

message UnitDeltaList {
	repeated UnitDelta UnitDeltas = 1;
}

message DeltasListDefsOp {
	DeltaSpec Ds = 1 [(gogoproto.nullable) = false];
	DeltaListDefsOptions Opt = 2;
}

message DeltasListFilesOp {
	DeltaSpec Ds = 1 [(gogoproto.nullable) = false];
	DeltaListFilesOptions Opt = 2;
}

message DeltasListAffectedAuthorsOp {
	DeltaSpec Ds = 1 [(gogoproto.nullable) = false];
	DeltaListAffectedAuthorsOptions Opt = 2;
}

message DeltaAffectedPersonList {
	repeated DeltaAffectedPerson DeltaAffectedPersons = 1;
}

message DeltasListAffectedClientsOp {
	DeltaSpec Ds = 1 [(gogoproto.nullable) = false];
	DeltaListAffectedClientsOptions Opt = 2;
}

// Example is a usage example of a def.
message Example {
	graph.Ref Ref = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];

	// SrcHTML is the formatted HTML source code of the example, with links to
	// definitions.
	string SrcHTML = 2;

	// SourceCode contains the parsed source for this example, if requested via
	// DefListExamplesOptions.
	SourceCode SourceCode = 3;

	// The line that the given example starts on
	int32 StartLine = 4;

	// The line that the given example ends on
	int32 EndLine = 5;

	// Error is whether an error occurred while fetching this example.
	bool Error = 6;

	// If the example has been requested by revision name (ie. branch, tag), this
	// value will be set.
	string Rev = 7 [(gogoproto.jsontag) = ",omitempty"];
}

// FormatResult contains information about and warnings from the formatting
// operation (if Formatted is true in the options).
message FormatResult {
	// TooManyRefs indicates that the file being formatted exceeded the maximum number
	// of refs that are linked. Only the first NumRefs refs are linked.
	bool TooManyRefs = 1;

	// NumRefs is the number of refs that were linked in this file. If the total number
	// of refs in the file exceeds the (server-defined) limit, NumRefs is capped at the
	// limit.
	int32 NumRefs = 2;

	// LineStartByteOffsets is the byte offset of each line's first byte.
	repeated int32 LineStartByteOffsets = 3;
}

message MarkdownData {
	bytes Rendered = 1;
	Checklist Checklist = 2;
}

message MarkdownOpt {
	bool EnableCheckboxes = 1;
}

message MarkdownRequestBody {
	bytes Markdown = 1;
	MarkdownOpt MarkdownOpt = 2 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message MarkdownRenderOp {
	bytes Markdown = 1;
	MarkdownOpt Opt = 2 [(gogoproto.nullable) = false];
}

message Ref {
	graph.Ref Ref = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
	AuthorshipInfo Authorship = 2;
}

// RepoTreeGetOptions specifies options for (RepoTreeService).Get.
message RepoTreeGetOptions {
	// Formatted is whether the specified entry, if it's a file, should have its
	// Contents code-formatted using HTML.
	bool Formatted = 1;

	// HighlightStrings is a list of fixed strings that should be wrapped in a <span
	// class="highlight"> in the returned HTML. It only takes effect if Formatted is
	// true.
	repeated string HighlightStrings = 2;

	// TokenizedSource requests that the source code be returned as a tokenized data
	// structure rather than an (annotated) string.
	//
	// This is useful when the client wants to take full control of rendering and
	// manipulating the contents.
	bool TokenizedSource = 3 [(gogoproto.moretags) = "url:\",omitempty\""];

	bool ContentsAsString = 4 [(gogoproto.moretags) = "url:\",omitempty\""];

	vcsclient.GetFileOptions GetFileOptions = 5 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message RepoTreeSearchOptions {
	vcs.SearchOptions SearchOptions = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
	bool Formatted = 2;
}

// A RepoTreeSearchResult is a tree search result that includes the repo and rev it
// came from.
message RepoTreeSearchResult {
	vcs.SearchResult SearchResult = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
	RepoRevSpec RepoRev = 2 [(gogoproto.nullable) = false];
}

message RepoTreeGetOp {
	TreeEntrySpec Entry = 1 [(gogoproto.nullable) = false];
	RepoTreeGetOptions Opt = 2;
}

message RepoTreeSearchOp {
	RepoRevSpec Rev = 1 [(gogoproto.nullable) = false];
	RepoTreeSearchOptions Opt = 2;
}

message RepoTreeListOp {
	RepoRevSpec Rev = 1 [(gogoproto.nullable) = false];
}

message RepoTreeListResult {
	repeated string Files = 1;
}

message VCSSearchResultList {
	repeated vcs.SearchResult SearchResults = 1;
	ListResponse ListResponse = 2 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message TokenSearchOptions {
	string Query = 1 [(gogoproto.moretags) = "url:\"q\" schema:\"q\""];
	RepoRevSpec RepoRev = 2 [(gogoproto.nullable) = false];
	ListOptions ListOptions = 3 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message TextSearchOptions {
	string Query = 1 [(gogoproto.moretags) = "url:\"q\" schema:\"q\""];
	RepoRevSpec RepoRev = 2 [(gogoproto.nullable) = false];
	ListOptions ListOptions = 3 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

// SourceCode contains a snippet of code with linked and classed tokens, along with
// other information about the contents.
//
// This data structure is useful when one desires to take full control of rendering
// and manipulating the contents of the requested TreeEntry or snippet, rather than
// dealing with an (annotated) string or parsing text. To obtain this structure in
// the TreeEntry, TokenizedSource must be set to "true" in the RepoTreeGetOptions.
message SourceCode {
	// Lines contains all the lines of the contained code snippet.
	repeated SourceCodeLine Lines = 1;

	int32 NumRefs = 2;
	bool TooManyRefs = 3;
}

// SourceCodeLine contains all tokens on this line along with other information
// such as byte offsets in original source.
message SourceCodeLine {
	// StartByte and EndByte are the start and end offsets in bytes, in the original
	// file.
	int32 StartByte = 1;

	int32 EndByte = 2;

	// Tokens contains any tokens that may be on this line, including whitespace. New
	// lines ('\n') are not present.
	repeated SourceCodeToken Tokens = 3;
}

// SourceCodeToken contains information about a code token.
message SourceCodeToken {
	// Start and end byte offsets in original file.
	int32 StartByte = 1 [(gogoproto.jsontag) = "-"];

	int32 EndByte = 2 [(gogoproto.jsontag) = "-"];

	// If the token is a reference URL contains the DefKey-based URLs for all the
	// definitions at this position.
	repeated string URL = 3 [(gogoproto.jsontag) = ",omitempty"];

	// IsDef specifies whether the token is a definition.
	bool IsDef = 4 [(gogoproto.jsontag) = ",omitempty"];

	// Class specifies the token type as per
	// [google-code-prettify](https://code.google.com/p/google-code-prettify/).
	// All tokens except Whitespace will have this field.
	string Class = 5 [(gogoproto.jsontag) = ",omitempty"];

	// ExtraClasses may additionally contain other classes for this token, such as
	// for example highlighting in a diff.
	string ExtraClasses = 6 [(gogoproto.jsontag) = ",omitempty"];

	// Label is non-whitespace HTML encoded source code.
	string Label = 7;
}

// TreeEntry is a file or directory in a repository, with additional feedback from
// the formatting operation (if Formatted is true in the options).
message TreeEntry {
	vcsclient.TreeEntry TreeEntry = 1 [(gogoproto.embed) = true, (gogoproto.jsontag) = ""];
	vcsclient.FileRange FileRange = 2 [(gogoproto.embed) = true, (gogoproto.jsontag) = ""];
	string ContentsString = 3;

	// SourceCode is set when TokenizedSource is enabled in RepoTreeGetOptions.
	SourceCode SourceCode = 4;

	// FormatResult is only set if this TreeEntry is a file.
	FormatResult FormatResult = 5;
}

message TreeEntrySpec {
	RepoRevSpec RepoRev = 1 [(gogoproto.nullable) = false];
	string Path = 2;
}

// A UnitDelta represents a single source unit that was changed. It has fields for
// the before (Base) and after (Head) versions. If both Base and Head are non-nil,
// then the unit was changed from base to head. Otherwise, one of the fields being
// nil means that the unit did not exist in that revision (e.g., it was added or
// deleted from base to head).
message UnitDelta {
	unit.RepoSourceUnit Base = 1;
	unit.RepoSourceUnit Head = 2;
}

// UnitListOptions specifies options for UnitsService.List.
message UnitListOptions {
	// RepoRevs constrains the results to a set of repository revisions (given by their
	// URIs plus an optional "@" and a revision specifier). For example,
	// "repo.com/foo@revspec".
	repeated string RepoRevs = 1 [(gogoproto.moretags) = "url:\",omitempty,comma\""];

	string UnitType = 2 [(gogoproto.moretags) = "url:\",omitempty\""];
	string Unit = 3 [(gogoproto.moretags) = "url:\",omitempty\""];

	// NameQuery specifies a full-text search query over the unit name.
	string NameQuery = 4 [(gogoproto.moretags) = "url:\",omitempty\""];

	// Query specifies a full-text search query over the repo URI, unit name, and unit
	// data.
	string Query = 5 [(gogoproto.moretags) = "url:\",omitempty\""];

	// Paging
	ListOptions ListOptions = 6 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

// UnitSpec specifies a source unit.
message UnitSpec {
	RepoRevSpec RepoRevSpec = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
	string UnitType = 2;
	string Unit = 3;
}

message RepoSourceUnitList {
	repeated unit.RepoSourceUnit Units = 1;
}

message DefAuthorList {
	repeated DefAuthor DefAuthors = 1;
}

message DefClientList {
	repeated DefClient DefClients = 1;
}

// DefsService communicates with the def- and graph-related endpoints in the
// Sourcegraph API.
service Defs {
	// Get fetches a def.
	rpc Get(DefsGetOp) returns (Def) {
		option (google.api.http) = {
			get: "/defs/get"
		};
	};

	// List defs.
	rpc List(DefListOptions) returns (DefList) {
		option (google.api.http) = {
			get: "/defs/list"
		};
	};

	// ListRefs lists references to def.
	rpc ListRefs(DefsListRefsOp) returns (RefList) {
		option (google.api.http) = {
			get: "/defs/list_refs"
		};
	};

	// ListExamples lists examples for def.
	rpc ListExamples(DefsListExamplesOp) returns (ExampleList) {
		option (google.api.http) = {
			get: "/defs/list_examples"
		};
	};

	// ListExamples lists people who committed parts of def's definition.
	rpc ListAuthors(DefsListAuthorsOp) returns (DefAuthorList) {
		option (google.api.http) = {
			get: "/defs/list_authors"
		};
	};

	// ListClients lists people who use def in their code.
	rpc ListClients(DefsListClientsOp) returns (DefClientList) {
		option (google.api.http) = {
			get: "/defs/list_clients"
		};
	};
}

// DeltasService interacts with the delta-related endpoints of the Sourcegraph API.
// A delta is all of the changes between two commits, possibly from two different
// repositories. It includes the usual file diffs as well as definition-level
// diffs, affected author/repo impact information, etc.
service Deltas {
	// Get fetches a summary of a delta.
	rpc Get(DeltaSpec) returns (Delta) {
		option (google.api.http) = {
			get: "/deltas/get"
		};
	};

	// ListUnits lists units added/changed/deleted in a delta.
	rpc ListUnits(DeltasListUnitsOp) returns (UnitDeltaList) {
		option (google.api.http) = {
			get: "/deltas/list_units"
		};
	};

	// ListDefs lists definitions added/changed/deleted in a delta.
	rpc ListDefs(DeltasListDefsOp) returns (DeltaDefs) {
		option (google.api.http) = {
			get: "/deltas/list_defs"
		};
	};

	// ListFiles fetches the file diff for a delta.
	rpc ListFiles(DeltasListFilesOp) returns (DeltaFiles) {
		option (google.api.http) = {
			get: "/deltas/list_files"
		};
	};

	// ListAffectedAuthors lists authors whose code is added/deleted/changed in a
	// delta.
	rpc ListAffectedAuthors(DeltasListAffectedAuthorsOp) returns (DeltaAffectedPersonList) {
		option (google.api.http) = {
			get: "/deltas/list_affected_authors"
		};
	};

	// ListAffectedClients lists clients whose code is affected by a delta.
	rpc ListAffectedClients(DeltasListAffectedClientsOp) returns (DeltaAffectedPersonList) {
		option (google.api.http) = {
			get: "/deltas/list_affected_clients"
		};
	};
}

service Markdown {
	rpc Render(MarkdownRenderOp) returns (MarkdownData) {
		option (google.api.http) = {
			get: "/markdown/render"
		};
	};
}

// RepoTreeService communicates with the Sourcegraph API endpoints that fetch file
// and directory entries in repositories.
service RepoTree {
	rpc Get(RepoTreeGetOp) returns (TreeEntry) {
		option (google.api.http) = {
			get: "/repo_tree"
		};
	};

	rpc Search(RepoTreeSearchOp) returns (VCSSearchResultList) {
		option (google.api.http) = {
			post: "/repo_tree/search"
		};
	};

	// List returns a list of all the files in the repo tree at
	// the given revision.
	rpc List(RepoTreeListOp) returns (RepoTreeListResult) {
		option (google.api.http) = {
			post: "/repo_tree/list"
		};
	};
}

// SearchService communicates with the search-related endpoints in the Sourcegraph
// API.
service Search {
	// SearchTokens searches the index of tokens.
	rpc SearchTokens(TokenSearchOptions) returns (DefList) {
		option (google.api.http) = {
			post: "/search/tokens"
		};
	};

	// SearchText searches the content of files in the repo tree.
	rpc SearchText(TextSearchOptions) returns (VCSSearchResultList) {
		option (google.api.http) = {
			post: "/search/text"
		};
	};
}

// UnitsService communicates with the source unit-related endpoints in the
// Sourcegraph API.
service Units {
	// Get fetches a unit.
	rpc Get(UnitSpec) returns (unit.RepoSourceUnit) {
		option (google.api.http) = {
			get: "/units"
		};
	};

	// List units.
	rpc List(UnitListOptions) returns (RepoSourceUnitList) {
		option (google.api.http) = {
			get: "/units/list"
		};
	};
}

message Checklist {
	// number of tasks to be done (unchecked)
	int32 Todo = 1;

	// number of tasks that are done (checked)
	int32 Done = 2;
}

message FileToken {
	string Path = 1;
	vcsclient.TreeEntry Entry = 2;
}
// Meta provides meta-information about Sourcegraph.
service Meta {
	// Status returns status information from the server's point of
	// view.
	rpc Status(pbtypes.Void) returns (ServerStatus) {
		option (google.api.http) = {
			get: "/meta/status"
		};
	};

	// Config returns the server's configuration.
	rpc Config(pbtypes.Void) returns (ServerConfig) {
		option (google.api.http) = {
			get: "/meta/config"
		};
	};
}

// ServerStatus describes the server's status.
message ServerStatus {
	// Info contains arbitrary human-readable status information about
	// the server.
	string Info = 1;
}

// ServerConfig describes the server's configuration.
//
// DEV NOTE: There is some overlap with Go CLI flag structs. In the
// future we may consolidate these.
message ServerConfig {
	// Version is the version of Sourcegraph that this server is
	// running.
	string Version = 1;

	// AppURL is the base URL of the user-facing web application
	// (e.g., "https://sourcegraph.com").
	string AppURL = 2;

	// FederationRootURL is the --fed.root-url CLI flag's value. It is
	// the URL of the federation root server, or blank if this server
	// is itself a federation root (in which case IsFederationRoot is
	// true).
	string FederationRootURL = 5;

	// IsFederationRoot is whether this server is itself a federation
	// root. If true, then FederationRootURL is empty.
	bool IsFederationRoot = 6;

	// IDKey is the server's identity key (ID key).
	string IDKey = 7;

	// AllowAnonymousReaders is whether anonymous (unauthenticated)
	// users may perform "read" operations, such as viewing
	// repositories.
	bool AllowAnonymousReaders = 9;

	// AuthSource is which mode of authentication is set up on the
	// server (local|oauth|ldap).
	string AuthSource = 10;
}

// A RegisteredClient is a registered API client.
//
// Many fields correspond to those listed at
// http://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata.
//
// It's called RegisteredClient instead of Client to avoid a name
// conflict with the existing Client (Go) type.
message RegisteredClient {
	// ID is a unique identifier for this client.
	string ID = 1;

	// RedirectURIs is a list of allowed redirect URIs.
	repeated string RedirectURIs = 2;

	// ClientName is the name of the client to be presented to the
	// end-user.
	string ClientName = 3;

	// LogoURI is a URL to this client's logo.
	string LogoURI = 4;

	// ClientURI is a URL to this client's homepage.
	string ClientURI = 5;

	// JWKS is the client's JSON Web Key Set. It contains the client's
	// public keys, if any.
	string JWKS = 6;

	// ClientSecret is the secret value that authenticates the
	// client. It may be empty (e.g., if JWKS keys are used for
	// authentication instead).
	string ClientSecret = 7;

	// Description is a human-readable description of this API client
	// that's shown to the user during, e.g., OAuth2 authentication.
	string Description = 8;

	// Meta holds arbitrary metadata about this API client. The
	// structure is defined by the API client and is opaque to the
	// server.
	map<string, string> Meta = 9;

	// RegisteredClientType describes this client's type.
	RegisteredClientType Type = 10;

	// CreatedAt is when this API client's record was created.
	pbtypes.Timestamp CreatedAt = 11 [(gogoproto.nullable) = false];

	// UpdatedAt is when this API client's record was last updated.
	pbtypes.Timestamp UpdatedAt = 12 [(gogoproto.nullable) = false];
}

// RegisteredClientType is the set of kinds of clients.
enum RegisteredClientType {
	// Any is any type of API client. It should only be used when
	// listing and not actually set on a RegisteredClient object.
	Any = 0;

	// Other is all other kinds of clients that are not
	// SourcegraphServers.
	Other = 1;

	// SourcegraphServer indicates this client is a Sourcegraph server
	// instance.
	SourcegraphServer = 2;
}

// A RegisteredClientSpec uniquely identifies a RegisteredClient.
message RegisteredClientSpec {
	// ID is the client's ID.
	string ID = 1;
}

// A RegisteredClientCredentials authenticates a RegisteredClient.
message RegisteredClientCredentials {
	// ID is the client's ID.
	string ID = 1;

	// Secret is the client's secret.
	string Secret = 2;
}

// RegisteredClientListOptions configures a call to
// RegisteredClients.List.
message RegisteredClientListOptions {
	RegisteredClientType Type = 1;
	ListOptions ListOptions = 2 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

// RegisteredClientList holds a list of clients.
message RegisteredClientList {
	repeated RegisteredClient Clients = 1;
	StreamResponse StreamResponse = 2 [(gogoproto.nullable) = false, (gogoproto.embed) = true, (gogoproto.jsontag) = ""];
}

message UserPermissions {
	// UID is a user's UID.
	int32 UID = 1;

	// ClientID is the ID of the client whose whitelist is to
	// be fetched and/or modified.
	string ClientID = 2;

	// Read is true if the user has read permissions on the client.
	bool Read = 3;

	// Write is true if the user has write permissions on the client.
	bool Write = 4;

	// Admin is true if the user should be considered an admin on
	// the client.
	bool Admin = 5;
}

message UserPermissionsList {
	repeated UserPermissions UserPermissions = 1;
}

message UserPermissionsOptions {
	RegisteredClientSpec ClientSpec = 1;

	int32 UID = 2;
}

// RegisteredClients manages registered API clients.
//
// The server may check authorization for methods that retrieve or
// fetch API client records (e.g., only allowing authenticated calls
// with a client's own credentials to get or modify it).
//
// Like the RegisteredClient message type, it's called
// RegisteredClients instead of Clients to avoid a name conflict with
// the existing Client (Go) type.
service RegisteredClients {
	// Get retrieves an API client's record given its client ID.
	rpc Get(RegisteredClientSpec) returns (RegisteredClient);

	// GetCurrent is equivalent to a call to Get with the client ID of
	// the currently authenticated client.
	rpc GetCurrent(pbtypes.Void) returns (RegisteredClient);

	// Create registers an API client.
	rpc Create(RegisteredClient) returns (RegisteredClient);

	// Update modifies an API client's record. The RegisteredClient
	// arg's ID must be set (to specify which client to update). Its
	// Secret field is ignored (the secret may not be updated after
	// creation).
	rpc Update(RegisteredClient) returns (pbtypes.Void);

	// Delete removes an API client. Immediately after deletion, it
	// may no longer be used.
	rpc Delete(RegisteredClientSpec) returns (pbtypes.Void);

	// List enumerates API clients according to the options.
	rpc List(RegisteredClientListOptions) returns (RegisteredClientList);

	// Get the permissions of the user on the specified client.
	rpc GetUserPermissions(UserPermissionsOptions) returns (UserPermissions);

	// Set the permissions of the user on the specified client.
	rpc SetUserPermissions(UserPermissions) returns (pbtypes.Void);

	// List the permissions of all users that are registered on this client.
	rpc ListUserPermissions(RegisteredClientSpec) returns (UserPermissionsList);
}

// TelemetryType is the format MetricsSnapshot.TelemetryData is encoded in
enum TelemetryType {
	// PrometheusDelimited0dot0dot4 indicates the metrics can be decoded using
	// Prometheus 0.0.4 delimited protobuf format
	PrometheusDelimited0dot0dot4 = 0;
}

// MetricsSnapshots encodes
message MetricsSnapshot {
	// Type is the encoding of TelemetryData
	TelemetryType Type = 1;

	// TelemetryData is the encoded metrics
	bytes TelemetryData = 2;
}

// UserEvent encodes any user initiated event on the local instance.
message UserEvent {
	string Type = 1;

	int32 UID = 2;

	string ClientID = 3;

	string Service = 4;

	string Method = 5;

	string Result = 6;

	// CreatedAt holds the time when this event was logged.
	pbtypes.Timestamp CreatedAt = 7;

	string Message = 8;

	// Version holds the release version of the Sourcegraph binary.
	string Version = 9;

	// URL holds the http request url.
	string URL = 10;
}

// UserEventList is a list of user events logged on this instance.
message UserEventList {
	repeated UserEvent Events = 1;
}

// GraphUplink interfaces with the metric collectors.
service GraphUplink {
	// Push sends the latest metrics to the upstream instance
	rpc Push(MetricsSnapshot) returns (pbtypes.Void);

	// PushEvents flushes the local event logs to the upstream
	// instance
	rpc PushEvents(UserEventList) returns (pbtypes.Void);
}

// Event is any action logged on a Sourcegraph instance.
message Event {
	// Type specifies the action type, eg. "AccountCreate" or "AddRepo".
	string Type = 1;

	// UserID is the unique identifier of a user on a Sourcegraph instance.
	// It is constructed as "login@short-client-id", where short-client-id
	// is the first 6 characters of this sourcegraph instance's public key
	// fingerprint (i.e. it's ClientID).
	string UserID = 2;

	// DeviceID is the unique identifier of an anonymous user on a Sourcegraph
	// instance.
	string DeviceID = 3;

	// ClientID is this Sourcegraph instance's public key fingerprint.
	string ClientID = 4;

	// Timestamp records the instant when this event was logged.
	pbtypes.Timestamp Timestamp = 5;

	// UserProperties holds metadata relating to user who performed this
	// action, eg. "Email".
	map<string, string> UserProperties = 6;

	// EventProperties holds metadata relating to the action logged by
	// this event, eg. for "AddRepo" event, a property is "Source" which
	// specifies if the repo is local or mirrored.
	map<string, string> EventProperties = 7;
}

// EventList is a list of logged Sourcegraph events.
message EventList {
	// Events holds the list of events.
	repeated Event Events = 1;

	// Version holds the release version of the Sourcegraph binary.
	string Version = 2;

	// AppURL holds the base URL of the Sourcegraph app.
	string AppURL = 3;
}

// NotifyGenericEvent describes an action being done against an object. For
// example reviewing a changeset.
message NotifyGenericEvent {
	// Actor is the User who did the action
	UserSpec Actor = 1;

	// Recipients is who should be notified of the action
	repeated UserSpec Recipients = 2;

	// ActionType example: "reviewed"
	string ActionType = 3;

	// ActionContent example: "Please add tests for the new functionality"
	string ActionContent = 4;

	// ObjectID example: 71
	int64 ObjectID = 5;

	// ObjectRepo example: "gorilla/mux"
	string ObjectRepo = 6;

	// ObjectType example: "changeset"
	string ObjectType = 7;

	// ObjectTitle example: "search: Simplify tokenizer"
	string ObjectTitle = 8;

	// ObjectURL example: "https://src.sourcegraph.com/sourcegraph/.changesets/71"
	string ObjectURL = 9;

	// SlackMsg, if present, will override the Slack message for this event.
	string SlackMsg = 10;

	// EmailHTML, if present, will override the notification email body for this event.
	string EmailHTML = 11;

	// NoEmail turns off the email notification for this event.
	bool NoEmail = 13;
}

// Notify service
service Notify {
	// GenericEvent will notify recipients of an event which happened
	rpc GenericEvent(NotifyGenericEvent) returns (pbtypes.Void);
}
