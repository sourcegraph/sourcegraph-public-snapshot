package sourcegraph

import (
	"encoding/base64"
	"strings"

	"sourcegraph.com/sourcegraph/go-diff/diff"
	"sourcegraph.com/sourcegraph/go-sourcegraph/spec"
	"sourcegraph.com/sourcegraph/srclib/store"
	"sourcegraph.com/sourcegraph/srclib/unit"
)

// RouteVars returns the route variables for generating URLs to the
// delta specified by this DeltaSpec.
func (s DeltaSpec) RouteVars() map[string]string {
	m := s.Base.RouteVars()

	if s.Base.RepoSpec == s.Head.RepoSpec {
		m["DeltaHeadResolvedRev"] = s.Head.ResolvedRevString()
	} else {
		m["DeltaHeadResolvedRev"] = encodeCrossRepoRevSpecForDeltaHeadResolvedRev(s.Head)
	}
	return m
}

func encodeCrossRepoRevSpecForDeltaHeadResolvedRev(rr RepoRevSpec) string {
	return base64.URLEncoding.EncodeToString([]byte(rr.RepoSpec.SpecString())) + ":" + rr.ResolvedRevString()
}

// UnmarshalDeltaSpec marshals a map containing route variables
// generated by (*DeltaSpec).RouteVars() and returns the
// equivalent DeltaSpec struct.
func UnmarshalDeltaSpec(routeVars map[string]string) (DeltaSpec, error) {
	s := DeltaSpec{}

	rr, err := UnmarshalRepoRevSpec(routeVars)
	if err != nil {
		return DeltaSpec{}, err
	}
	s.Base = rr

	dhr := routeVars["DeltaHeadResolvedRev"]
	if i := strings.Index(dhr, ":"); i != -1 {
		// base repo != head repo
		repoPCB64, revPC := dhr[:i], dhr[i+1:]

		repoPC, err := base64.URLEncoding.DecodeString(repoPCB64)
		if err != nil {
			return DeltaSpec{}, err
		}

		rev, commitID, err := spec.ParseResolvedRev(revPC)
		if err != nil {
			return DeltaSpec{}, err
		}

		s.Head = RepoRevSpec{RepoSpec: RepoSpec{URI: string(repoPC)}, Rev: rev, CommitID: commitID}
	} else {
		rev, commitID, err := spec.ParseResolvedRev(dhr)
		if err != nil {
			return DeltaSpec{}, err
		}

		s.Head = RepoRevSpec{RepoSpec: rr.RepoSpec, Rev: rev, CommitID: commitID}
	}
	return s, nil
}

func (d *Delta) DeltaSpec() DeltaSpec {
	return DeltaSpec{
		Base: d.Base,
		Head: d.Head,
	}
}

// BaseAndHeadBuildsSuccessful returns true iff both the base and head
// builds are present and ended successfully.
func (d *Delta) BaseAndHeadBuildsSuccessful() bool {
	return d.BaseBuild != nil && d.BaseBuild.Success && d.HeadBuild != nil && d.HeadBuild.Success
}

// Added is whether this represents an added source unit (not present
// in base, present in head).
func (ud UnitDelta) Added() bool { return ud.Base == nil && ud.Head != nil }

// Changed is whether this represents a changed source unit (present
// in base, present in head).
func (ud UnitDelta) Changed() bool { return ud.Base != nil && ud.Head != nil }

// Deleted is whether this represents a deleted source unit (present
// in base, not present in head).
func (ud UnitDelta) Deleted() bool { return ud.Base != nil && ud.Head == nil }

type UnitDeltas []*UnitDelta

func (v UnitDeltas) Len() int      { return len(v) }
func (v UnitDeltas) Swap(i, j int) { v[i], v[j] = v[j], v[i] }
func (v UnitDeltas) Less(i, j int) bool {
	a, b := v[i], v[j]
	return (a.Added() && b.Added() && deltaUnitLess(a.Head, b.Head)) || (a.Changed() && b.Changed() && deltaUnitLess(a.Head, b.Head)) || (a.Deleted() && b.Deleted() && deltaUnitLess(a.Base, b.Base)) || (a.Added() && !b.Added()) || (a.Changed() && !b.Added() && !b.Changed())
}

func deltaUnitLess(a, b *unit.RepoSourceUnit) bool {
	return a.UnitType < b.UnitType || (a.UnitType == b.UnitType && a.Unit < b.Unit)
}

func (f DeltaFilter) DefFilters() []store.DefFilter {
	if f.UnitType != "" && f.Unit != "" {
		return []store.DefFilter{store.ByUnits(unit.ID2{Type: f.UnitType, Name: f.Unit})}
	}
	return nil
}

// Added is whether this represents an added def (not present in base,
// present in head).
func (dd DefDelta) Added() bool { return dd.Base == nil && dd.Head != nil }

// Changed is whether this represents a changed def (present in base,
// present in head).
func (dd DefDelta) Changed() bool { return dd.Base != nil && dd.Head != nil }

// Deleted is whether this represents a deleted def (present in base,
// not present in head).
func (dd DefDelta) Deleted() bool { return dd.Base != nil && dd.Head == nil }

func (v DeltaDefs) Len() int      { return len(v.Defs) }
func (v DeltaDefs) Swap(i, j int) { v.Defs[i], v.Defs[j] = v.Defs[j], v.Defs[i] }
func (v DeltaDefs) Less(i, j int) bool {
	a, b := v.Defs[i], v.Defs[j]
	return (a.Added() && b.Added() && deltaDefLess(a.Head, b.Head)) || (a.Changed() && b.Changed() && deltaDefLess(a.Head, b.Head)) || (a.Deleted() && b.Deleted() && deltaDefLess(a.Base, b.Base)) || (a.Added() && !b.Added()) || (a.Changed() && !b.Added() && !b.Changed())
}

func deltaDefLess(a, b *Def) bool {
	return a.UnitType < b.UnitType || (a.UnitType == b.UnitType && a.Unit < b.Unit) || (a.UnitType == b.UnitType && a.Unit == b.Unit && a.Path < b.Path)
}

// DiffStat returns a diffstat that is the sum of all of the files'
// diffstats.
func (d *DeltaFiles) DiffStat() diff.Stat {
	ds := diff.Stat{}
	for _, fd := range d.FileDiffs {
		st := fd.Stat()
		ds.Added += st.Added
		ds.Changed += st.Changed
		ds.Deleted += st.Deleted
	}
	return ds
}
