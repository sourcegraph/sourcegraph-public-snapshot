package apptoken

import (
	"context"
	"encoding/json"
	"os"
	"path/filepath"

	"github.com/sourcegraph/sourcegraph/internal/conf/deploy"
	"github.com/sourcegraph/sourcegraph/internal/database"
	"github.com/sourcegraph/sourcegraph/internal/singleprogram"
	"github.com/sourcegraph/sourcegraph/internal/version"
	"github.com/sourcegraph/sourcegraph/lib/errors"
)

// Name for the "note" field of the token. Note that the token is created as an
// internal token, it's not visible in the UI anyway.
const appTokenName = "App Autogenerated Token"

// Scope string for the generated app token. This is used both during creation
// and also during validation of an existing saved token to ensure that it has
// the required scope.
const appTokenScope = "user:all"

// Name of the token file within the app config dir
const appTokenFileName = "app.json"

type AppTokenFilePayload struct {
	// Token prefixed with "sgp_"
	Token string `json:"token"`

	// The localhost API endpoint of App
	// Example: "http://localhost:3080"
	Endpoint string `json:"endpoint"`

	// App version string
	// Example: "2023.06.16"
	Version string `json:"version"`
}

// Checks if the app token file exists in the config dir and contains a valid
// token. If not, it will generate a new token and create a new app token file.
func CreateAppTokenFileIfNotExists(ctx context.Context, db database.DB, uid int32) error {
	if !deploy.IsApp() {
		return errors.New("can only be called in App")
	}
	configDir, err := singleprogram.SetupAppConfigDir()
	if err != nil {
		return errors.Wrap(err, "Could not get config dir")
	}
	appPayloadFilePath := filepath.Join(configDir, appTokenFileName)
	existingAccessTokenPresent := isExistingAppTokenPresent(ctx, db, appPayloadFilePath, uid)
	if existingAccessTokenPresent {
		return nil
	}

	return createAppTokenFile(ctx, db, appPayloadFilePath, uid)
}

// Attempts to read the app token file and checks if the token is valid,
// returning true if a valid token was found. Returns false if reading the file
// or validating the token fails.
func isExistingAppTokenPresent(ctx context.Context, db database.DB, appTokenFilePath string, uid int32) bool {
	fileContents, err := os.ReadFile(appTokenFilePath)
	if err != nil {
		return false
	}

	var payload AppTokenFilePayload
	err = json.Unmarshal(fileContents, &payload)
	if err != nil {
		return false
	}

	// Validate the token to confirm that it will be accepted by the API.
	subjectUserId, err := db.AccessTokens().Lookup(ctx, payload.Token,
		database.TokenLookupOpts{RequiredScope: appTokenScope})
	if err != nil {
		return false
	}
	if subjectUserId != uid {
		return false
	}

	return true
}

// Generate a new app token and write it to the app token file. Will overwrite
// if the file already exists.
func createAppTokenFile(ctx context.Context, db database.DB, appTokenFilePath string, uid int32) error {
	_, token, err := db.AccessTokens().CreateInternal(ctx, uid, []string{appTokenScope}, appTokenName, uid)
	if err != nil {
		return err
	}

	payload := AppTokenFilePayload{
		Token:    token,
		Endpoint: "http://localhost:3080", // TODO: we could use ExternalUrl() but it gives us https://sourcegraph.test:3443/ and we want the localhost port
		Version:  version.Version(),
	}

	appTokenFileBody, err := json.Marshal(payload)
	if err != nil {
		return err
	}

	err = os.WriteFile(appTokenFilePath, appTokenFileBody, 0o644)
	if err != nil {
		return err
	}

	return nil
}
