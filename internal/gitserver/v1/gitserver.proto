syntax = "proto3";

package gitserver.v1;

import "google/protobuf/timestamp.proto";

option go_package = "github.com/sourcegraph/sourcegraph/internal/gitserver/v1";

// GitserverRepositoryService exposes operations to be performed by
// repo-updater. These methods are not meant to be used by other services, and
// should be considered an implementation detail of gitserver.
service GitserverRepositoryService {
  // DeleteRepository deletes a repository on disk if it exists.
  // If it doesn't, an error is returned.
  rpc DeleteRepository(DeleteRepositoryRequest) returns (DeleteRepositoryResponse) {}
  // FetchRepository fetches a repository from a remote. If the repository is
  // not yet cloned, it will be cloned. Otherwise, it will be updated.
  rpc FetchRepository(FetchRepositoryRequest) returns (FetchRepositoryResponse) {
    option idempotency_level = IDEMPOTENT;
  }
  // ListRepositories returns a list of all repositories on disk.
  rpc ListRepositories(ListRepositoriesRequest) returns (ListRepositoriesResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
}

message ListRepositoriesRequest {
  // page_size is the maximum number of repositories to return in a single response.
  // Must be > 0 and should be chosen so that the maximum gRPC message size is not
  // exceeded.
  uint32 page_size = 1;
  // page_token is a token that can be used to request the next page of repositories.
  string page_token = 2;
}

message ListRepositoriesResponse {
  // GitRepository represents a git repository on disk.
  message GitRepository {
    // path is the absolute path to the repository on disk, minus the data dir prefix,
    // usually /data/repos.
    bytes path = 1;
    // name is the name of the repository as gitserver infers it. This may not match
    // a repository name in the database because we have a poor reverse mapping from
    // path to name at the moment.
    string name = 2;
  }
  repeated GitRepository repositories = 1;
  // next_page_token is the token to use to request the next page of repositories.
  // Pass it to page_token in ListRepositoriesRequest to get the next page.
  // If this is empty, there are no more repositories to return.
  string next_page_token = 2;
}

message DeleteRepositoryRequest {
  // repo_name is the name of the repo to delete.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
}

message DeleteRepositoryResponse {}

message FetchRepositoryRequest {
  // repo_name is the name of the repo to fetch.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
}

message FetchRepositoryResponse {
  // last_fetched is the time the repository was last fetched.
  google.protobuf.Timestamp last_fetched = 1;
  // last_changed is the time the repository was last changed.
  google.protobuf.Timestamp last_changed = 2;
}

service GitserverService {
  rpc CreateCommitFromPatchBinary(stream CreateCommitFromPatchBinaryRequest) returns (CreateCommitFromPatchBinaryResponse) {}
  rpc DiskInfo(DiskInfoRequest) returns (DiskInfoResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // GetObject returns the object with the given OID in the given repository.
  //
  // If the object is not found, an error with a RevisionNotFoundPayload is
  // returned.
  //
  // If the given repo is not cloned, it will be enqueued for cloning and a
  // NotFound error will be returned, with a RepoNotFoundPayload in the details.
  rpc GetObject(GetObjectRequest) returns (GetObjectResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  rpc IsRepoCloneable(IsRepoCloneableRequest) returns (IsRepoCloneableResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  rpc ListGitolite(ListGitoliteRequest) returns (ListGitoliteResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  rpc Search(SearchRequest) returns (stream SearchResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // Archive creates an archive for the given treeish in the given format.
  // If paths are specified, only those paths are included in the archive.
  //
  // If subrepo permissions are enabled for the repo, no archive will be created
  // for non-internal actors and an unimplemented error will be returned. We can
  // currently not filter parts of the archive, so this would be considered
  // leaking information.
  //
  // If the given treeish does not exist, an error with a
  // RevisionNotFoundPayload is returned.
  //
  // If the given paths are not found in the given treeish, an error with a FileNotFoundPayload
  // is returned.
  //
  // If the given repo is not cloned, it will be enqueued for cloning and a NotFound
  // error will be returned, with a RepoNotFoundPayload in the details.
  rpc Archive(ArchiveRequest) returns (stream ArchiveResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  rpc RepoCloneProgress(RepoCloneProgressRequest) returns (RepoCloneProgressResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  rpc IsPerforcePathCloneable(IsPerforcePathCloneableRequest) returns (IsPerforcePathCloneableResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  rpc CheckPerforceCredentials(CheckPerforceCredentialsRequest) returns (CheckPerforceCredentialsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  rpc PerforceUsers(PerforceUsersRequest) returns (PerforceUsersResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  rpc PerforceProtectsForUser(PerforceProtectsForUserRequest) returns (PerforceProtectsForUserResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  rpc PerforceProtectsForDepot(PerforceProtectsForDepotRequest) returns (PerforceProtectsForDepotResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  rpc PerforceGroupMembers(PerforceGroupMembersRequest) returns (PerforceGroupMembersResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  rpc IsPerforceSuperUser(IsPerforceSuperUserRequest) returns (IsPerforceSuperUserResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  rpc PerforceGetChangelist(PerforceGetChangelistRequest) returns (PerforceGetChangelistResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // MergeBase returns the merge base commit sha for the specified revspecs.
  // If no common merge base exists, an empty string is returned.
  //
  // If the given repo is not cloned, it will be enqueued for cloning and a
  // NotFound error will be returned, with a RepoNotFoundPayload in the details.
  rpc MergeBase(MergeBaseRequest) returns (MergeBaseResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // Blame runs a blame operation on the specified file. It returns a stream of
  // hunks as they are found. The --incremental flag is used on the git CLI
  // level to achieve this behavior.
  //
  // If the given path is not found, an error with a FileNotFoundPayload is returned.
  //
  // If the given repo is not cloned, it will be enqueued for cloning and a NotFound
  // error will be returned, with a RepoNotFoundPayload in the details.
  rpc Blame(BlameRequest) returns (stream BlameResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // DefaultBranch resolves HEAD to ref name and current commit SHA it points
  // to. If HEAD points to an empty branch, it returns an error with a
  // RevisionNotFoundPayload.
  //
  // If the given repo is not cloned, it will be enqueued for cloning and a
  // NotFound error will be returned, with a RepoNotFoundPayload in the details.
  rpc DefaultBranch(DefaultBranchRequest) returns (DefaultBranchResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // ReadFile gets a file from the repo ODB and streams the contents back.
  //
  // If the given path is not found, an error with a FileNotFoundPayload is returned.
  //
  // If the given repo is not cloned, it will be enqueued for cloning and a NotFound
  // error will be returned, with a RepoNotFoundPayload in the details.
  rpc ReadFile(ReadFileRequest) returns (stream ReadFileResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // GetCommit gets a commit from the repo ODB.
  //
  // If the commit is not found, an error with a RevisionNotFoundPayload is
  // returned.
  //
  // If the given repo is not cloned, it will be enqueued for cloning and a
  // NotFound error will be returned, with a RepoNotFoundPayload in the details.
  rpc GetCommit(GetCommitRequest) returns (GetCommitResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // ResolveRevision resolves a given revspec-ish to a commit SHA.
  // If passed a commit sha, the endpoint will also verify that the commit
  // exists.
  //
  // If the revision cannot be resolved an error with RevisionNotFoundPayload is
  // returned.
  //
  // Under the hood, this endpoint currently uses git rev-parse to resolve the
  // revspec, but we forbid certain revspecs (like HEAD) to avoid leaking
  // existence files, and to avoid running very expensive rev-parse operations.
  // Assume only the following are supported:
  // - Symbolic refs
  // - All refs under refs/, including tags
  // - Commit hashes
  // - Abbreviated commit hashes
  //
  // If the given repo is not cloned, it will be enqueued for cloning and a
  // NotFound error will be returned, with a RepoNotFoundPayload in the details.
  rpc ResolveRevision(ResolveRevisionRequest) returns (ResolveRevisionResponse) {
    option idempotency_level = IDEMPOTENT;
  }
  // ListRefs returns a list of all the refs known to the repository, this
  // includes heads, tags, and other potential refs, but filters can be applied.
  //
  // The refs are ordered in the following order:
  // HEAD first, if part of the result set.
  // The rest will be ordered by creation date, in descending order, i.e.,
  // newest first. If two resources are created at the same timestamp, the
  // records are ordered alphabetically.
  //
  // If the given repo is not cloned, it will be enqueued for cloning and a
  // NotFound error will be returned, with a RepoNotFoundPayload in the details.
  rpc ListRefs(ListRefsRequest) returns (stream ListRefsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // RevAtTime looks up the OID of the nearest ancestor of `spec` that has a
  // commit time before the given time. To simplify the logic, it only follows
  // the first parent of merge commits to linearize the commit history. The
  // intent is to return the state of a branch at a given time.
  //
  // If the revision cannot be resolved an error with RevisionNotFoundPayload is
  // returned.
  //
  // If the revision exists, but there is no commit in its ancestry before
  // the requested time, an empty string is returned for the commit SHA.
  rpc RevAtTime(RevAtTimeRequest) returns (RevAtTimeResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // RawDiff returns the raw git diff for the given range.
  // Diffs returned from this function will have the following settings applied:
  // - 3 lines of context
  // - No a/ b/ prefixes
  // - Rename detection
  //
  // If either base or head are not found, an error with a
  // RevisionNotFoundPayload is returned.
  //
  // If the given repo is not cloned, it will be enqueued for cloning and a
  // NotFound error will be returned, with a RepoNotFoundPayload in the details.
  rpc RawDiff(RawDiffRequest) returns (stream RawDiffResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // ContributorCounts returns the number of commits grouped by commit author.
  //
  // If the given repo is not cloned, it will be enqueued for cloning and a
  // NotFound error will be returned, with a RepoNotFoundPayload in the details.
  rpc ContributorCounts(ContributorCountsRequest) returns (ContributorCountsResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // FirstEverCommit returns the first commit ever made to the repository.
  //
  // If the given repository is empty, an error with a RevisionNotFoundPayload
  // is returned.
  rpc FirstEverCommit(FirstEverCommitRequest) returns (FirstEverCommitResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // BehindAhead returns the behind/ahead commit counts information for the
  // symmetric difference left...right (both Git revspecs).
  //
  // Behind is the number of commits that are solely reachable in "left" but not
  // "right". Ahead is the number of commits that are solely reachable in
  // "right" but not "left".
  //
  //  For the example, given the graph below, BehindAhead("A", "B") would return
  //  {Behind: 3, Ahead: 2}.
  //
  //       y---b---b  branch B
  //      / \ /
  //     /   .
  //    /   / \
  //   o---x---a---a---a  branch A
  //
  // If either left or right are the empty string (""), the HEAD commit is
  // implicitly used.
  //
  // If one of the two given revspecs does not exist, an error with a
  // RevisionNotFoundPayload is is returned.
  //
  // If the given repo is not cloned, it will be enqueued for cloning and a
  // NotFound error will be returned, with a RepoNotFoundPayload in the details.
  rpc BehindAhead(BehindAheadRequest) returns (BehindAheadResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }

  // ChangedFiles returns the list of files that have been added, modified, or
  // deleted in the entire repository between the two given <tree-ish>
  // identifiers (e.g., commit, branch, tag).
  //
  // - Renamed files are represented as a deletion of the old path and an
  // addition of the new path.
  // - No copy detection is performed.
  // - The only file status codes returned are 'A' (added), 'M' (modified), or
  // 'D' (deleted).
  //
  // If `base` is omitted, the parent of `head` is used as the base.
  //
  // If either the `base` or `head` <tree-ish> id does not exist, an error with
  // a `RevisionNotFoundPayload` is returned.
  rpc ChangedFiles(ChangedFilesRequest) returns (stream ChangedFilesResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // Stat returns a FileInfo describing the named file descriptor at the given commit.
  // Stat supports submodules, symlinks, directories and files.
  //
  // If the commit does not exist, an error with RevisionNotFoundPayload is
  // returned.
  //
  // If the given path is not found, an error with a FileNotFoundPayload is returned.
  //
  // If the given repo is not cloned, it will be enqueued for cloning and a NotFound
  // error will be returned, with a RepoNotFoundPayload in the details.
  rpc Stat(StatRequest) returns (StatResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // ReadDir returns a list of FileInfos describing the files and subdirectories
  // in the given directory.
  //
  // If the commit does not exist, an error with RevisionNotFoundPayload is
  // returned.
  //
  // If the given path is not found, an error with a FileNotFoundPayload is returned.
  //
  // If the given repo is not cloned, it will be enqueued for cloning and a NotFound
  // error will be returned, with a RepoNotFoundPayload in the details.
  rpc ReadDir(ReadDirRequest) returns (stream ReadDirResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // CommitLog returns all commits matching the options. The commits are gathered
  // with `git-log`.
  // If one of the given ranges doesn't exist, an error with a ReversionNotFoundPayload
  // is returned.
  rpc CommitLog(CommitLogRequest) returns (stream CommitLogResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
  // MergeBaseOctopus returns the octopus merge base commit sha for the specified
  // revspecs.
  // If no common merge base exists, an empty string is returned.
  // See the following diagrams from git-merge-base docs on what octopus merge bases
  // are:
  // Given three commits A, B, and C, MergeBaseOctopus(A, B, C) will compute the
  // best common ancestor of all commits.
  // For example, with this topology:
  //            o---o---o---o---C
  //           /
  //          /   o---o---o---B
  //         /   /
  //     ---2---1---o---o---o---A
  // The result of MergeBaseOctopus(A, B, C) is 2, because 2 is the
  // best common ancestor of all commits.
  //
  // If the given repo is not cloned, it will be enqueued for cloning and a
  // NotFound error will be returned, with a RepoNotFoundPayload in the details.
  rpc MergeBaseOctopus(MergeBaseOctopusRequest) returns (MergeBaseOctopusResponse) {
    option idempotency_level = NO_SIDE_EFFECTS;
  }
}

message CommitLogRequest {
  // repo_name is the name of the repo to run the blame operation in.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
  // Ranges to include in the git log (revspec, "A..B", "A...B", etc.).
  // At least one range, or all_refs must be specified.
  repeated bytes ranges = 3;
  // If true, all refs are searched for commits.
  // Must not be true when ranges are given.
  bool all_refs = 4;
  // After is an optional parameter to specify the earliest commit to consider.
  google.protobuf.Timestamp after = 5;
  // Before is an optional parameter to specify the latest commit to consider.
  google.protobuf.Timestamp before = 6;
  // MaxCommits is an optional parameter to specify the maximum number of commits
  // to return. If max_commits is 0, all commits that match the criteria will be
  // returned.
  uint32 max_commits = 7;
  // Skip is an optional parameter to specify the number of commits to skip.
  // This can be used to implement a poor mans pagination.
  uint32 skip = 8;
  // When finding commits to include, follow only the first parent commit upon
  // seeing a merge commit. This option can give a better overview when viewing
  // the evolution of a particular topic branch, because merges into a topic
  // branch tend to be only about adjusting to updated upstream from time to time,
  // and this option allows you to ignore the individual commits brought in to
  // your history by such a merge.
  bool follow_only_first_parent = 9;
  // If true, the modified_files field in the GetCommitResponse will be
  // populated.
  bool include_modified_files = 10;
  enum CommitLogOrder {
    // Uses the default ordering of git log: in reverse chronological order.
    // See https://git-scm.com/docs/git-log#_commit_ordering for more details.
    COMMIT_LOG_ORDER_UNSPECIFIED = 0;
    // Show no parents before all of its children are shown, but otherwise show commits
    // in the commit timestamp order.
    // See https://git-scm.com/docs/git-log#_commit_ordering for more details.
    COMMIT_LOG_ORDER_COMMIT_DATE = 1;
    // Show no parents before all of its children are shown, and avoid showing commits
    // on multiple lines of history intermixed.
    // See https://git-scm.com/docs/git-log#_commit_ordering for more details.
    COMMIT_LOG_ORDER_TOPO_DATE = 2;
  }
  CommitLogOrder order = 11;
  // Include only commits whose commit message contains this substring.
  bytes message_query = 12;
  // include only commits whose author matches this.
  bytes author_query = 13;
  // include only commits that touch this file path.
  bytes path = 14;
  // Follow the history of the path beyond renames, only effective when used with
  // `path`.
  bool follow_path_renames = 15;
}

message CommitLogResponse {
  repeated GetCommitResponse commits = 1;
}

message ContributorCountsRequest {
  // repo_name is the name of the repo to run the blame operation in.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
  // Optional range to limit the commits inspected. If not given, all commits
  // are considered. This can either be a revspec, which will be interpreted as
  // "every commit since root until this commit", or a range, with either .. or
  // ... separator.
  bytes range = 3;
  // After is an optional parameter to specify the earliest commit to consider
  // in the aggregation. If not specified, all commits will be returned.
  google.protobuf.Timestamp after = 4;
  // path can optionally be specified to limit the commits to a single path.
  // If not specified, the commits will be returned for all paths.
  // Path can also be a path prefix, for example cmd/gitserver/.
  bytes path = 5;
}

message ContributorCount {
  GitSignature author = 1;
  int32 count = 2;
}

message ContributorCountsResponse {
  repeated ContributorCount counts = 1;
}

message RawDiffRequest {
  // repo_name is the name of the repo to run the blame operation in.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
  // The base spec to resolve. I.e., HEAD, deadbeefdeadbeefdeadbeefdeadbeef, or
  // refs/heads/main.
  bytes base_rev_spec = 3;
  // The head spec to resolve. I.e., HEAD, deadbeefdeadbeefdeadbeefdeadbeef, or
  // refs/heads/main.
  bytes head_rev_spec = 4;
  enum ComparisonType {
    COMPARISON_TYPE_UNSPECIFIED = 0;
    // Corresponds to the BASE..HEAD syntax that only returns any commits that
    // are in HEAD but not in BASE.
    COMPARISON_TYPE_ONLY_IN_HEAD = 1;
    // Corresponds to the BASE...HEAD syntax that returns any commits that are
    // not in both BASE and HEAD.
    COMPARISON_TYPE_INTERSECTION = 2;
  }
  // comparison_type is the type of comparison to perform. If unspecified, will
  // fall back to COMPARISON_TYPE_INTERSECTION.
  ComparisonType comparison_type = 5;
  // paths is a list of paths to filter the diff to. If empty, all paths are
  // diffed.
  repeated bytes paths = 6;
  // inter_hunk_context specifies the number of lines to consider for fusing hunks
  // together. I.e., when set to 5 and between 2 hunks there are at most 5 lines,
  // the 2 hunks will be fused together into a single chunk.
  //
  // The default for this is 3.
  optional uint32 inter_hunk_context = 7;
  // context_lines specifies the number of lines of context to show around added/removed
  // lines.
  // This is the number of lines that will be shown before and after each line that
  // has been added/removed. If inter_hunk_context is not zero, the context will still
  // be fused together with other hunks if they meet the threshold.
  //
  // The default for this is 3.
  optional uint32 context_lines = 8;
}

message RawDiffResponse {
  // chunk is the raw diff chunk.
  bytes chunk = 1;
}

message ListRefsRequest {
  // repo_name is the name of the repo to run the blame operation in.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
  // If true, only heads are returned. Can be combined with tags_only.
  bool heads_only = 3;
  // If true, only tags are returned. Can be combined with heads_only.
  bool tags_only = 4;
  // If set, only return refs that point at the given commit sha. Multiple
  // values will be ORed together.
  repeated string points_at_commit = 5;
  // If set, only return refs that contain the given commit sha.
  optional string contains_sha = 6;
}

message ListRefsResponse {
  repeated GitRef refs = 1;
}

message GitRef {
  // ref_name is the unabbreviated name of the reference, i.e., refs/heads/main,
  // or refs/tags/1.0.
  bytes ref_name = 1;
  // short_ref_name is the abbreviated name of the reference, if unambiguous.
  // I.e., main, or 1.0.
  bytes short_ref_name = 2;
  // target_commit is the hash of the commit the reference is currently pointing
  // at. For a head reference, this is the commit the head is currently pointing
  // at. For a tag, this is the commit that the tag is attached to.
  string target_commit = 3;
  // ref_oid is the full object ID of the reference. For a head reference and
  // a lightweight tag, this value is the same as target_commit. For annotated
  // tags, it is the object ID of the tag.
  string ref_oid = 4;
  // created_at is the timestamp when the ref was created or modified last.
  google.protobuf.Timestamp created_at = 5;
  enum RefType {
    REF_TYPE_UNSPECIFIED = 0;
    REF_TYPE_BRANCH = 1;
    REF_TYPE_TAG = 2;
  }
  // ref_type is the type of the reference. Non-tag references will be of
  // type branch. I.e., refs/pull/123/head will be a branch as well.
  RefType ref_type = 6;
  // is_head is true if the reference is the HEAD reference.
  bool is_head = 7;
}

message StatRequest {
  // repo_name is the name of the repo to run the blame operation in.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
  // The commit at which we want to stat the file.
  string commit_sha = 3;
  // The path to the file to stat.
  bytes path = 4;
}

message StatResponse {
  FileInfo file_info = 1;
}

message ReadDirRequest {
  // repo_name is the name of the repo to run the blame operation in.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
  // The commit at which we want to read the directory.
  string commit_sha = 3;
  // The path to the directory to read. Empty means root.
  optional bytes path = 4;
  // recursive indicates whether to read the directory recursively. The default is false.
  bool recursive = 5;
}

message ReadDirResponse {
  repeated FileInfo file_info = 1;
}

message GitSubmodule {
  // URL is the submodule repository clone URL.
  string url = 1;
  // Path is the path of the submodule relative to the repository root.
  bytes path = 2;
  // CommitSHA is the pinned commit ID of the submodule (in the submodule repository's
  // commit ID space).
  string commit_sha = 3;
}

message FileInfo {
  // The file name, relative to the repository root.
  bytes name = 1;
  // The file size.
  int64 size = 2;
  // The file mode.
  uint32 mode = 3;
  // The blob OID in the git ODB.
  string blob_oid = 4;
  // If this FileInfo describes a submodule, this field will be populated.
  optional GitSubmodule submodule = 5;
}

message ResolveRevisionRequest {
  // repo_name is the name of the repo to run the blame operation in.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
  // The rev spec to resolve. I.e., HEAD, deadbeefdeadbeefdeadbeefdeadbeef, or
  // refs/heads/main.
  bytes rev_spec = 3;
  // ensure_revision tries to ensure that the revision is present in the repo by
  // triggering a git fetch if it is not present. It's not guaranteed that
  // a revision exists in the repo after this call, if it really doesn't exist.
  // This can slow down the response time significantly, only use it if you have
  // good reason to do so.
  optional bool ensure_revision = 4;
}

message ResolveRevisionResponse {
  // commit is the commit SHA of the resolved revision.
  string commit_sha = 1;
}

message RevAtTimeRequest {
  // repo_name is the name of the repo to run the operation in.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;

  // rev_spec is the starting revision for the search. We iterate
  // through its --first-parent ancestors looking for the first ancestor
  // that has a committer time before `time`.
  //
  // e.g., HEAD, deadbeefdeadbeefdeadbeefdeadbeef, or refs/heads/main.
  bytes rev_spec = 3;

  // time is the timestamp we are looking for commits before
  google.protobuf.Timestamp time = 4;
}

message RevAtTimeResponse {
  // commit is the commit SHA of the resolved revision.
  string commit_sha = 1;
}

message GetCommitRequest {
  // repo_name is the name of the repo to run the blame operation in.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
  string commit = 3;
  // If true, the modified_files field in the GetCommitResponse will be
  // populated.
  bool include_modified_files = 4;
}

message GetCommitResponse {
  GitCommit commit = 1;
  // Contains the list of files the commit modified.
  // NOTE: Only populated if include_modified_files in the GetCommitRequest is
  // true.
  repeated bytes modified_files = 2;
}

message GitCommit {
  string oid = 1;
  GitSignature author = 2;
  GitSignature committer = 3;
  bytes message = 4;
  repeated string parents = 5;
}

message GitSignature {
  bytes name = 1;
  bytes email = 2;
  google.protobuf.Timestamp date = 3;
}

message BlameRequest {
  reserved 6, 7;
  reserved "start_line", "end_line";

  // repo_name is the name of the repo to run the blame operation in.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
  // commit is the commit sha to start the blame operation at.
  string commit = 3;
  bytes path = 4;
  bool ignore_whitespace = 5;
  optional BlameRange range = 8;
}

message BlameRange {
  uint32 start_line = 1;
  uint32 end_line = 2;
}

message BlameResponse {
  BlameHunk hunk = 1;
}

message BlameHunk {
  uint32 start_line = 1;
  uint32 end_line = 2;
  uint32 start_byte = 3;
  uint32 end_byte = 4;
  string commit = 5;
  BlameAuthor author = 6;
  string message = 7;
  string filename = 8;
  optional PreviousCommit previous_commit = 9;
}

message BlameAuthor {
  bytes name = 1;
  string email = 2;
  google.protobuf.Timestamp date = 3;
}

message PreviousCommit {
  string commit = 1;
  string filename = 2;
}

message DefaultBranchRequest {
  // repo_name is the name of the repo to get the default branch for.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
  bool short_ref = 3;
}

message DefaultBranchResponse {
  string ref_name = 1;
  string commit = 2;
}

message ReadFileRequest {
  // repo_name is the name of the repo to get the default branch for.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
  string commit = 3;
  bytes path = 4;
}

message ReadFileResponse {
  bytes data = 1;
}

// DiskInfoRequest is a empty request for the DiskInfo RPC.
message DiskInfoRequest {}

// DiskInfoResponse contains the results of the DiskInfo RPC request.
message DiskInfoResponse {
  // free_space is the amount of space avaialable on a gitserver instance.
  uint64 free_space = 1;

  // total_space is the total amount of space on a gitserver instance.
  uint64 total_space = 2;

  // percent_used is the percent of disk space used on a gitserver instance.
  float percent_used = 3;
}

message PatchCommitInfo {
  // messages are the commit messages to be used for the commit
  repeated string messages = 1;
  // author_name is the name of the author to be used for the commit
  string author_name = 2;
  // author_email is the email of the author to be used for the commit
  string author_email = 3;
  // committer_name is the name of the committer to be used for the commit
  string committer_name = 4;
  // committer_email is the email of the committer to be used for the commit
  string committer_email = 5;
  // author_date is the date of the author to be used for the commit
  google.protobuf.Timestamp date = 6;
}

message PushConfig {
  // remote_url is the git remote URL to which to push the commits.
  // The URL needs to include HTTP basic auth credentials if no
  // unauthenticated requests are allowed by the remote host.
  string remote_url = 1;
  // private_key is used when the remote URL uses scheme `ssh`. If set,
  // this value is used as the content of the private key. Needs to be
  // set in conjunction with a passphrase.
  string private_key = 2;
  // passphrase is the passphrase to decrypt the private key. It is required
  // when passing PrivateKey.
  string passphrase = 3;
}

// CreateCommitFromPatchBinaryRequest is the request information needed for
// creating the simulated staging area git object for a repo.
message CreateCommitFromPatchBinaryRequest {
  message Metadata {
    // repo is the name of the repo to be updated
    string repo = 1;
    // base_commit is the revision that the staging area object is based on
    string base_commit = 2;
    // target_ref is the ref that will be created for this patch
    string target_ref = 3;
    reserved "unique_ref";
    reserved 4;
    // commit_info is the information to be used for the commit
    PatchCommitInfo commit_info = 5;
    // push_config is the configuration to be used for pushing the commit
    PushConfig push = 6;
    reserved "git_apply_args";
    reserved 7;
    // push_ref is the optional override for the ref that is pushed to
    optional string push_ref = 8;
    // Indicates that the filenames in patch are not prefixed with the usual a/
    // and b/ prefixes.
    bool patch_filenames_no_prefix = 9;
  }

  message Patch {
    // data is the diff contents to be used to create the staging area revision
    bytes data = 1;
  }

  oneof payload {
    Metadata metadata = 1;
    Patch patch = 2;
  }
}

message CreateCommitFromPatchError {
  // repository_name is the name of the repository that the error occurred on
  string repository_name = 1;
  // internal_error is the error that occurred on the server
  string internal_error = 2;
  // command is the git command that was attempted
  string command = 3;
  // combined_output is the combined stderr and stdout from running the command
  string combined_output = 4;
}

// CreateCommitFromPatchBinaryResponse is the response type returned after
// creating a commit from a patch
message CreateCommitFromPatchBinaryResponse {
  reserved 2;
  reserved "error";

  // rev is the tag that the staging object can be found at
  string rev = 1;
  // changelistid is the Perforce changelist id
  string changelist_id = 3;
}

message RepoNotFoundPayload {
  string repo = 1;
  bool clone_in_progress = 2;
  string clone_progress = 3;
}

message RevisionNotFoundPayload {
  string repo = 1;
  string spec = 2;
}

message FileNotFoundPayload {
  string repo = 1;
  string commit = 2;
  bytes path = 3;
}

message SearchRequest {
  // repo is the name of the repo to be searched
  string repo = 1;
  // revisions is the list of git revision to be searched. They are all passed
  // to the same underlying git command, so the searched commits will be the
  // union of all revisions listed.
  repeated RevisionSpecifier revisions = 2;
  // limit is a limit on the number of search results returned. Additional
  // results will be ignored.
  int64 limit = 3;
  // include_diff specifies whether the full diff should be included on the
  // result messages. This can be expensive, so is disabled by default.
  bool include_diff = 4;
  // include_modified specifies whether to include the list of modified files
  // in the search results. This can be expensive, so is disabled by default.
  bool include_modified_files = 5;
  // query is a tree of filters to apply to commits being searched.
  QueryNode query = 6;
}

message RevisionSpecifier {
  // RevSpec is a revision range specifier suitable for passing to git. See
  // the manpage gitrevisions(7).
  string rev_spec = 1;
  reserved 2;
  reserved 3;
}

// AuthorMatchesNode is a predicate that matches if the author's name or email
// address matches the regex pattern.
message AuthorMatchesNode {
  string expr = 1;
  bool ignore_case = 2;
}

// CommitterMatchesNode is a predicate that matches if the author's name or
// email address matches the regex pattern.
message CommitterMatchesNode {
  string expr = 1;
  bool ignore_case = 2;
}

// CommitBeforeNode is a predicate that matches if the commit is before the
// given date
message CommitBeforeNode {
  google.protobuf.Timestamp timestamp = 1;
}

// CommitAfterNode is a predicate that matches if the commit is after the given
// date
message CommitAfterNode {
  google.protobuf.Timestamp timestamp = 1;
}

// MessageMatchesNode is a predicate that matches if the commit message matches
// the provided regex pattern.
message MessageMatchesNode {
  string expr = 1;
  bool ignore_case = 2;
}

// DiffMatchesNode is a a predicate that matches if any of the lines changed by
// the commit match the given regex pattern.
message DiffMatchesNode {
  string expr = 1;
  bool ignore_case = 2;
}

// DiffModifiesFileNode is a predicate that matches if the commit modifies any
// files that match the given regex pattern.
message DiffModifiesFileNode {
  string expr = 1;
  bool ignore_case = 2;
}

// BooleanNode is a predicate that will either always match or never match
message BooleanNode {
  bool value = 1;
}

enum OperatorKind {
  OPERATOR_KIND_UNSPECIFIED = 0;
  OPERATOR_KIND_AND = 1;
  OPERATOR_KIND_OR = 2;
  OPERATOR_KIND_NOT = 3;
}

message OperatorNode {
  OperatorKind kind = 1;
  repeated QueryNode operands = 2;
}

message QueryNode {
  oneof value {
    AuthorMatchesNode author_matches = 1;
    CommitterMatchesNode committer_matches = 2;
    CommitBeforeNode commit_before = 3;
    CommitAfterNode commit_after = 4;
    MessageMatchesNode message_matches = 5;
    DiffMatchesNode diff_matches = 6;
    DiffModifiesFileNode diff_modifies_file = 7;
    BooleanNode boolean = 8;
    OperatorNode operator = 9;
  }
}

message SearchResponse {
  oneof message {
    CommitMatch match = 1;
    bool limit_hit = 2;
  }
}

message CommitMatch {
  message Signature {
    string name = 1;
    string email = 2;
    google.protobuf.Timestamp date = 3;
  }

  message MatchedString {
    string content = 1;
    repeated Range ranges = 2;
  }

  // TODO move this into a shared package
  message Range {
    Location start = 1;
    Location end = 2;
  }

  message Location {
    uint32 offset = 1;
    uint32 line = 2;
    uint32 column = 3;
  }

  // oid is the 40-character, hex-encoded commit hash
  string oid = 1;
  Signature author = 2;
  Signature committer = 3;
  // parents is the list of commit hashes for this commit's parents
  repeated string parents = 4;
  repeated string refs = 5;
  repeated string source_refs = 6;
  // message is the commits message and a list of ranges that match
  // the search query.
  MatchedString message = 7;
  // diff is the diff between this commit and its first parent.
  // May be unset if `include_diff` was not specified in the request.
  MatchedString diff = 8;
  // modified_files is the list of files modified by this commit compared
  // to its first parent. May be unset if `include_modified_files` is not
  // specified in the request.
  repeated string modified_files = 9;
}

enum ArchiveFormat {
  ARCHIVE_FORMAT_UNSPECIFIED = 0;
  ARCHIVE_FORMAT_ZIP = 1;
  ARCHIVE_FORMAT_TAR = 2;
}

// ArchiveRequest is set of parameters for the Archive RPC.
message ArchiveRequest {
  // repo is the name of the repo to be archived.
  string repo = 1;
  // treeish is the tree or commit to produce an archive for.
  string treeish = 2;
  // format is the format of the resulting archive (either ZIP or TAR).
  ArchiveFormat format = 3;
  // paths is the list of paths to include in the archive. If empty, all
  // paths are included.
  repeated bytes paths = 4;
}

// ArchiveResponse is the response from the Archive RPC that returns a chunk of
// the archive.
message ArchiveResponse {
  bytes data = 1;
}

// IsRepoCloneableRequest is a request to check if a repository is cloneable.
message IsRepoCloneableRequest {
  // repo is the name of the repo to check.
  string repo = 1;
}

// IsRepoCloneableResponse is the response from the IsCloneable RPC.
message IsRepoCloneableResponse {
  // cloneable is true if the repository is cloneable.
  bool cloneable = 1;
  // cloned is true if the repository was cloned in the past.
  bool cloned = 2;
  // reason is why the repository is not cloneable.
  string reason = 3;
}

// RepoCloneProgressRequest is a request for information about the clone
// progress of multiple repositories on gitserver.
message RepoCloneProgressRequest {
  reserved 1;
  reserved "repos";

  // repo_name is the name of the repo to get the progress for.
  string repo_name = 2;
}

// RepoCloneProgressResponse is the response to a repository clone progress
// request.
message RepoCloneProgressResponse {
  // clone_in_progress is whether the repository is currently being cloned
  bool clone_in_progress = 1;
  // clone_progress is a progress message from the running clone command.
  string clone_progress = 2;
  // cloned is whether the repository has been cloned successfully
  bool cloned = 3;
}

// ListGitoliteRequest is a request to list all repositories in gitolite.
message ListGitoliteRequest {
  // host is the hostname of the gitolite instance
  string gitolite_host = 1;
}

// GitoliteRepo is a repository in gitolite.
message GitoliteRepo {
  // name is the name of the repository
  string name = 1;
  // url is the URL of the repository
  string url = 2;
}

// ListGitoliteResponse is the response from the ListGitolite RPC.
message ListGitoliteResponse {
  // repos is the list of repositories in gitolite
  repeated GitoliteRepo repos = 1;
}

// GetObjectRequest is a request to get a git object.
message GetObjectRequest {
  // repo is the name of the repo to get the object from.
  string repo = 1;
  // object_name is the name of the object to get.
  string object_name = 2;
}

// GetObjectResponse is the response from the GetObject RPC.
message GetObjectResponse {
  // object is the git object.
  GitObject object = 1;
}

// GitObject is a git object.
message GitObject {
  enum ObjectType {
    OBJECT_TYPE_UNSPECIFIED = 0;
    OBJECT_TYPE_COMMIT = 1;
    OBJECT_TYPE_TAG = 2;
    OBJECT_TYPE_TREE = 3;
    OBJECT_TYPE_BLOB = 4;
  }
  // id is the object id.
  bytes id = 1;
  // type is the type of the object.
  ObjectType type = 2;
}

// IsPerforcePathCloneableRequest is the request to check if a Perforce path is
// cloneable.
message IsPerforcePathCloneableRequest {
  PerforceConnectionDetails connection_details = 1;
  string depot_path = 2;
}

// IsPerforcePathCloneableResponse is the response from checking if a Perforce
// path is cloneable.
message IsPerforcePathCloneableResponse {}

// CheckPerforceCredentialsRequest is the request to check if given Perforce
// credentials are valid.
message CheckPerforceCredentialsRequest {
  PerforceConnectionDetails connection_details = 1;
}

// IsPerforcePathCloneableResponse is the response from checking if given
// Perforce credentials are valid.
message CheckPerforceCredentialsResponse {}

// PerforceConnectionDetails holds all the details required to talk to a
// Perforce server.
message PerforceConnectionDetails {
  string p4port = 1;
  string p4user = 2;
  string p4passwd = 3;
}

// PerforceGetChangelistRequest is used to retrieve information about a specific
// Perforce changelist.
message PerforceGetChangelistRequest {
  PerforceConnectionDetails connection_details = 1;
  string changelist_id = 2;
}

// PerforceGetChangelistResponse returns information about the requested
// changelist.
message PerforceGetChangelistResponse {
  PerforceChangelist changelist = 1;
}

// PerforceChangelist represents a changelist in Perforce.
message PerforceChangelist {
  // PerforceChangelistState is the valid state values of a Perforce changelist.
  enum PerforceChangelistState {
    PERFORCE_CHANGELIST_STATE_UNSPECIFIED = 0;
    PERFORCE_CHANGELIST_STATE_SUBMITTED = 1;
    PERFORCE_CHANGELIST_STATE_PENDING = 2;
    PERFORCE_CHANGELIST_STATE_SHELVED = 3;
    // Perforce doesn't actually return a state for closed changelists, so this
    // is one we use to indicate the changelist is closed.
    PERFORCE_CHANGELIST_STATE_CLOSED = 4;
  }
  string id = 1;
  google.protobuf.Timestamp creation_date = 2;
  PerforceChangelistState state = 3;
  string author = 4;
  string title = 5;
  string message = 6;
}

// IsPerforceSuperUserRequest can be used to check if a given Perforce user is a
// super user.
message IsPerforceSuperUserRequest {
  PerforceConnectionDetails connection_details = 1;
}

// IsPerforceSuperUserResponse is the response from checking if a given Perforce
// user is a super user.
// No fields here, returning an error means "no".
message IsPerforceSuperUserResponse {}

// PerforceProtectsForDepotRequest requests all the protections that apply to
// the given depot.
message PerforceProtectsForDepotRequest {
  PerforceConnectionDetails connection_details = 1;
  string depot = 2;
}

// PerforceProtectsForDepotResponse returns all the protections that apply to
// the given depot.
message PerforceProtectsForDepotResponse {
  repeated PerforceProtect protects = 1;
}

// PerforceProtectsForUserRequest requests all the protections that apply to the
// given user.
message PerforceProtectsForUserRequest {
  PerforceConnectionDetails connection_details = 1;
  string username = 2;
}

// PerforceProtectsForUserResponse returns all the protections that apply to the
// given user.
message PerforceProtectsForUserResponse {
  repeated PerforceProtect protects = 1;
}

// PerforceProtect is a single line definition of a protection in Perforce.
message PerforceProtect {
  string level = 1;
  string entity_type = 2;
  string entity_name = 3;
  string match = 4;
  bool is_exclusion = 5;
  string host = 6;
}

// PerforceGroupMembersRequest requests the members of the given Perforce group.
message PerforceGroupMembersRequest {
  PerforceConnectionDetails connection_details = 1;
  string group = 2;
}

// PerforceGroupMembersResponse returns the members of the requested Perforce
// group.
message PerforceGroupMembersResponse {
  repeated string usernames = 1;
}

// PerforceUsersRequest lists all the users known to the Perforce server.
message PerforceUsersRequest {
  PerforceConnectionDetails connection_details = 1;
}

// PerforceUsersResponse contains the list of users known by the server.
message PerforceUsersResponse {
  repeated PerforceUser users = 1;
}

// PerforceUser is a representation of a user account in Perforce.
message PerforceUser {
  string username = 1;
  string email = 2;
}

// MergeBaseRequest is a request to find the merge base of two revspecs.
message MergeBaseRequest {
  // repo_name is the name of the repo to get the merge base for.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
  // base is a revspec, for now, we allow non-utf8 revspecs.
  bytes base = 3;
  // head is a revspec, for now, we allow non-utf8 revspecs.
  bytes head = 4;
}

// MergeBaseResponse is the response from finding the merge base of two
// revspecs.
message MergeBaseResponse {
  string merge_base_commit_sha = 1;
}

// MergeBaseOctopusRequest is a request to find the octopus merge base of revspecs.
message MergeBaseOctopusRequest {
  // repo_name is the name of the repo to get the octopus merge base for.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
  // revspecs are the revspecs to consider for merge-base. For now, we allow non-utf8
  // revspecs.
  repeated bytes revspecs = 3;
}

// MergeBaseOctopusResponse is the response from finding the octopus merge base of
// the given revspecs.
message MergeBaseOctopusResponse {
  string merge_base_commit_sha = 1;
}

// FirstEverCommitRequest is a request to get the first ever commit in a repo.
message FirstEverCommitRequest {
  // repo_name is the name of the repo to get the first ever commit for.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
}

// FirstEverCommitResponse is the response from getting the first ever commit in
// a repo.
message FirstEverCommitResponse {
  GitCommit commit = 1;
}

message BehindAheadRequest {
  // repo_name is the name of the repo to get the behind/ahead information for.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
  // left is a revspec that we'll take the symmetric difference against.
  // for now, we allow non-utf8 revspecs.
  bytes left = 3;
  // right is a revspec that we'll take the symmetric difference against.
  // for now, we allow non-utf8 revspecs.
  bytes right = 4;
}

message BehindAheadResponse {
  // behind is the number of commits that are solely reachable in "left" but not
  // "right".
  uint32 behind = 1;
  // ahead is the number of commits that are solely reachable in "right" but not
  // "left".
  uint32 ahead = 2;
}

message ChangedFilesRequest {
  // repo_name is the name of the repo to get the changed files for.
  // Note: We use field ID 2 here to reserve 1 for a future repo int32 field.
  string repo_name = 2;
  // base is a <tree-ish> id, for now, we allow non-utf8 revspecs.
  //
  // If base is empty, the parent of the head is used.
  optional bytes base = 3;
  // head is a <tree-ish> id, for now, we allow non-utf8 revspecs.
  bytes head = 4;
}

message ChangedFilesResponse {
  repeated ChangedFile files = 1;
}

message ChangedFile {
  // path is the file path of the file that the status is for.
  bytes path = 1;
  // status is the status of the path.
  enum Status {
    STATUS_UNSPECIFIED = 0;
    STATUS_ADDED = 1;
    STATUS_MODIFIED = 2;
    STATUS_DELETED = 3;
    STATUS_TYPE_CHANGED = 4;
  }
  Status status = 2;
}
