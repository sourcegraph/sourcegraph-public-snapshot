// Code generated by go-mockgen 1.3.7; DO NOT EDIT.
//
// This file was generated by running `sg generate` (or `go-mockgen`) at the root of
// this repository. To add additional mocks to this or another package, add a new entry
// to the mockgen.yaml file in the root of this repository.

package dependencies

import (
	"context"
	"sync"
	"time"

	api "github.com/sourcegraph/sourcegraph/internal/api"
	store "github.com/sourcegraph/sourcegraph/internal/codeintel/autoindexing/internal/store"
	shared2 "github.com/sourcegraph/sourcegraph/internal/codeintel/autoindexing/shared"
	dependencies "github.com/sourcegraph/sourcegraph/internal/codeintel/dependencies"
	shared "github.com/sourcegraph/sourcegraph/internal/codeintel/dependencies/shared"
	shared1 "github.com/sourcegraph/sourcegraph/internal/codeintel/uploads/shared"
	database "github.com/sourcegraph/sourcegraph/internal/database"
	types "github.com/sourcegraph/sourcegraph/internal/types"
)

// MockDependenciesService is a mock implementation of the
// DependenciesService interface (from the package
// github.com/sourcegraph/sourcegraph/internal/codeintel/autoindexing/internal/background/dependencies)
// used for unit testing.
type MockDependenciesService struct {
	// InsertPackageRepoRefsFunc is an instance of a mock function object
	// controlling the behavior of the method InsertPackageRepoRefs.
	InsertPackageRepoRefsFunc *DependenciesServiceInsertPackageRepoRefsFunc
	// ListPackageRepoFiltersFunc is an instance of a mock function object
	// controlling the behavior of the method ListPackageRepoFilters.
	ListPackageRepoFiltersFunc *DependenciesServiceListPackageRepoFiltersFunc
}

// NewMockDependenciesService creates a new mock of the DependenciesService
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockDependenciesService() *MockDependenciesService {
	return &MockDependenciesService{
		InsertPackageRepoRefsFunc: &DependenciesServiceInsertPackageRepoRefsFunc{
			defaultHook: func(context.Context, []shared.MinimalPackageRepoRef) (r0 []shared.PackageRepoReference, r1 []shared.PackageRepoRefVersion, r2 error) {
				return
			},
		},
		ListPackageRepoFiltersFunc: &DependenciesServiceListPackageRepoFiltersFunc{
			defaultHook: func(context.Context, dependencies.ListPackageRepoRefFiltersOpts) (r0 []shared.PackageRepoFilter, r1 bool, r2 error) {
				return
			},
		},
	}
}

// NewStrictMockDependenciesService creates a new mock of the
// DependenciesService interface. All methods panic on invocation, unless
// overwritten.
func NewStrictMockDependenciesService() *MockDependenciesService {
	return &MockDependenciesService{
		InsertPackageRepoRefsFunc: &DependenciesServiceInsertPackageRepoRefsFunc{
			defaultHook: func(context.Context, []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error) {
				panic("unexpected invocation of MockDependenciesService.InsertPackageRepoRefs")
			},
		},
		ListPackageRepoFiltersFunc: &DependenciesServiceListPackageRepoFiltersFunc{
			defaultHook: func(context.Context, dependencies.ListPackageRepoRefFiltersOpts) ([]shared.PackageRepoFilter, bool, error) {
				panic("unexpected invocation of MockDependenciesService.ListPackageRepoFilters")
			},
		},
	}
}

// NewMockDependenciesServiceFrom creates a new mock of the
// MockDependenciesService interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockDependenciesServiceFrom(i DependenciesService) *MockDependenciesService {
	return &MockDependenciesService{
		InsertPackageRepoRefsFunc: &DependenciesServiceInsertPackageRepoRefsFunc{
			defaultHook: i.InsertPackageRepoRefs,
		},
		ListPackageRepoFiltersFunc: &DependenciesServiceListPackageRepoFiltersFunc{
			defaultHook: i.ListPackageRepoFilters,
		},
	}
}

// DependenciesServiceInsertPackageRepoRefsFunc describes the behavior when
// the InsertPackageRepoRefs method of the parent MockDependenciesService
// instance is invoked.
type DependenciesServiceInsertPackageRepoRefsFunc struct {
	defaultHook func(context.Context, []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error)
	hooks       []func(context.Context, []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error)
	history     []DependenciesServiceInsertPackageRepoRefsFuncCall
	mutex       sync.Mutex
}

// InsertPackageRepoRefs delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDependenciesService) InsertPackageRepoRefs(v0 context.Context, v1 []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error) {
	r0, r1, r2 := m.InsertPackageRepoRefsFunc.nextHook()(v0, v1)
	m.InsertPackageRepoRefsFunc.appendCall(DependenciesServiceInsertPackageRepoRefsFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// InsertPackageRepoRefs method of the parent MockDependenciesService
// instance is invoked and the hook queue is empty.
func (f *DependenciesServiceInsertPackageRepoRefsFunc) SetDefaultHook(hook func(context.Context, []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertPackageRepoRefs method of the parent MockDependenciesService
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *DependenciesServiceInsertPackageRepoRefsFunc) PushHook(hook func(context.Context, []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DependenciesServiceInsertPackageRepoRefsFunc) SetDefaultReturn(r0 []shared.PackageRepoReference, r1 []shared.PackageRepoRefVersion, r2 error) {
	f.SetDefaultHook(func(context.Context, []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DependenciesServiceInsertPackageRepoRefsFunc) PushReturn(r0 []shared.PackageRepoReference, r1 []shared.PackageRepoRefVersion, r2 error) {
	f.PushHook(func(context.Context, []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error) {
		return r0, r1, r2
	})
}

func (f *DependenciesServiceInsertPackageRepoRefsFunc) nextHook() func(context.Context, []shared.MinimalPackageRepoRef) ([]shared.PackageRepoReference, []shared.PackageRepoRefVersion, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DependenciesServiceInsertPackageRepoRefsFunc) appendCall(r0 DependenciesServiceInsertPackageRepoRefsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// DependenciesServiceInsertPackageRepoRefsFuncCall objects describing the
// invocations of this function.
func (f *DependenciesServiceInsertPackageRepoRefsFunc) History() []DependenciesServiceInsertPackageRepoRefsFuncCall {
	f.mutex.Lock()
	history := make([]DependenciesServiceInsertPackageRepoRefsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DependenciesServiceInsertPackageRepoRefsFuncCall is an object that
// describes an invocation of method InsertPackageRepoRefs on an instance of
// MockDependenciesService.
type DependenciesServiceInsertPackageRepoRefsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []shared.MinimalPackageRepoRef
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared.PackageRepoReference
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 []shared.PackageRepoRefVersion
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DependenciesServiceInsertPackageRepoRefsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DependenciesServiceInsertPackageRepoRefsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// DependenciesServiceListPackageRepoFiltersFunc describes the behavior when
// the ListPackageRepoFilters method of the parent MockDependenciesService
// instance is invoked.
type DependenciesServiceListPackageRepoFiltersFunc struct {
	defaultHook func(context.Context, dependencies.ListPackageRepoRefFiltersOpts) ([]shared.PackageRepoFilter, bool, error)
	hooks       []func(context.Context, dependencies.ListPackageRepoRefFiltersOpts) ([]shared.PackageRepoFilter, bool, error)
	history     []DependenciesServiceListPackageRepoFiltersFuncCall
	mutex       sync.Mutex
}

// ListPackageRepoFilters delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockDependenciesService) ListPackageRepoFilters(v0 context.Context, v1 dependencies.ListPackageRepoRefFiltersOpts) ([]shared.PackageRepoFilter, bool, error) {
	r0, r1, r2 := m.ListPackageRepoFiltersFunc.nextHook()(v0, v1)
	m.ListPackageRepoFiltersFunc.appendCall(DependenciesServiceListPackageRepoFiltersFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// ListPackageRepoFilters method of the parent MockDependenciesService
// instance is invoked and the hook queue is empty.
func (f *DependenciesServiceListPackageRepoFiltersFunc) SetDefaultHook(hook func(context.Context, dependencies.ListPackageRepoRefFiltersOpts) ([]shared.PackageRepoFilter, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ListPackageRepoFilters method of the parent MockDependenciesService
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *DependenciesServiceListPackageRepoFiltersFunc) PushHook(hook func(context.Context, dependencies.ListPackageRepoRefFiltersOpts) ([]shared.PackageRepoFilter, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *DependenciesServiceListPackageRepoFiltersFunc) SetDefaultReturn(r0 []shared.PackageRepoFilter, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, dependencies.ListPackageRepoRefFiltersOpts) ([]shared.PackageRepoFilter, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *DependenciesServiceListPackageRepoFiltersFunc) PushReturn(r0 []shared.PackageRepoFilter, r1 bool, r2 error) {
	f.PushHook(func(context.Context, dependencies.ListPackageRepoRefFiltersOpts) ([]shared.PackageRepoFilter, bool, error) {
		return r0, r1, r2
	})
}

func (f *DependenciesServiceListPackageRepoFiltersFunc) nextHook() func(context.Context, dependencies.ListPackageRepoRefFiltersOpts) ([]shared.PackageRepoFilter, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *DependenciesServiceListPackageRepoFiltersFunc) appendCall(r0 DependenciesServiceListPackageRepoFiltersFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// DependenciesServiceListPackageRepoFiltersFuncCall objects describing the
// invocations of this function.
func (f *DependenciesServiceListPackageRepoFiltersFunc) History() []DependenciesServiceListPackageRepoFiltersFuncCall {
	f.mutex.Lock()
	history := make([]DependenciesServiceListPackageRepoFiltersFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// DependenciesServiceListPackageRepoFiltersFuncCall is an object that
// describes an invocation of method ListPackageRepoFilters on an instance
// of MockDependenciesService.
type DependenciesServiceListPackageRepoFiltersFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 dependencies.ListPackageRepoRefFiltersOpts
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared.PackageRepoFilter
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c DependenciesServiceListPackageRepoFiltersFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c DependenciesServiceListPackageRepoFiltersFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// MockExternalServiceStore is a mock implementation of the
// ExternalServiceStore interface (from the package
// github.com/sourcegraph/sourcegraph/internal/codeintel/autoindexing/internal/background/dependencies)
// used for unit testing.
type MockExternalServiceStore struct {
	// ListFunc is an instance of a mock function object controlling the
	// behavior of the method List.
	ListFunc *ExternalServiceStoreListFunc
	// UpsertFunc is an instance of a mock function object controlling the
	// behavior of the method Upsert.
	UpsertFunc *ExternalServiceStoreUpsertFunc
}

// NewMockExternalServiceStore creates a new mock of the
// ExternalServiceStore interface. All methods return zero values for all
// results, unless overwritten.
func NewMockExternalServiceStore() *MockExternalServiceStore {
	return &MockExternalServiceStore{
		ListFunc: &ExternalServiceStoreListFunc{
			defaultHook: func(context.Context, database.ExternalServicesListOptions) (r0 []*types.ExternalService, r1 error) {
				return
			},
		},
		UpsertFunc: &ExternalServiceStoreUpsertFunc{
			defaultHook: func(context.Context, ...*types.ExternalService) (r0 error) {
				return
			},
		},
	}
}

// NewStrictMockExternalServiceStore creates a new mock of the
// ExternalServiceStore interface. All methods panic on invocation, unless
// overwritten.
func NewStrictMockExternalServiceStore() *MockExternalServiceStore {
	return &MockExternalServiceStore{
		ListFunc: &ExternalServiceStoreListFunc{
			defaultHook: func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error) {
				panic("unexpected invocation of MockExternalServiceStore.List")
			},
		},
		UpsertFunc: &ExternalServiceStoreUpsertFunc{
			defaultHook: func(context.Context, ...*types.ExternalService) error {
				panic("unexpected invocation of MockExternalServiceStore.Upsert")
			},
		},
	}
}

// NewMockExternalServiceStoreFrom creates a new mock of the
// MockExternalServiceStore interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockExternalServiceStoreFrom(i ExternalServiceStore) *MockExternalServiceStore {
	return &MockExternalServiceStore{
		ListFunc: &ExternalServiceStoreListFunc{
			defaultHook: i.List,
		},
		UpsertFunc: &ExternalServiceStoreUpsertFunc{
			defaultHook: i.Upsert,
		},
	}
}

// ExternalServiceStoreListFunc describes the behavior when the List method
// of the parent MockExternalServiceStore instance is invoked.
type ExternalServiceStoreListFunc struct {
	defaultHook func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error)
	hooks       []func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error)
	history     []ExternalServiceStoreListFuncCall
	mutex       sync.Mutex
}

// List delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockExternalServiceStore) List(v0 context.Context, v1 database.ExternalServicesListOptions) ([]*types.ExternalService, error) {
	r0, r1 := m.ListFunc.nextHook()(v0, v1)
	m.ListFunc.appendCall(ExternalServiceStoreListFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the List method of the
// parent MockExternalServiceStore instance is invoked and the hook queue is
// empty.
func (f *ExternalServiceStoreListFunc) SetDefaultHook(hook func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// List method of the parent MockExternalServiceStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ExternalServiceStoreListFunc) PushHook(hook func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ExternalServiceStoreListFunc) SetDefaultReturn(r0 []*types.ExternalService, r1 error) {
	f.SetDefaultHook(func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ExternalServiceStoreListFunc) PushReturn(r0 []*types.ExternalService, r1 error) {
	f.PushHook(func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error) {
		return r0, r1
	})
}

func (f *ExternalServiceStoreListFunc) nextHook() func(context.Context, database.ExternalServicesListOptions) ([]*types.ExternalService, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ExternalServiceStoreListFunc) appendCall(r0 ExternalServiceStoreListFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ExternalServiceStoreListFuncCall objects
// describing the invocations of this function.
func (f *ExternalServiceStoreListFunc) History() []ExternalServiceStoreListFuncCall {
	f.mutex.Lock()
	history := make([]ExternalServiceStoreListFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ExternalServiceStoreListFuncCall is an object that describes an
// invocation of method List on an instance of MockExternalServiceStore.
type ExternalServiceStoreListFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 database.ExternalServicesListOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []*types.ExternalService
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ExternalServiceStoreListFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ExternalServiceStoreListFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// ExternalServiceStoreUpsertFunc describes the behavior when the Upsert
// method of the parent MockExternalServiceStore instance is invoked.
type ExternalServiceStoreUpsertFunc struct {
	defaultHook func(context.Context, ...*types.ExternalService) error
	hooks       []func(context.Context, ...*types.ExternalService) error
	history     []ExternalServiceStoreUpsertFuncCall
	mutex       sync.Mutex
}

// Upsert delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockExternalServiceStore) Upsert(v0 context.Context, v1 ...*types.ExternalService) error {
	r0 := m.UpsertFunc.nextHook()(v0, v1...)
	m.UpsertFunc.appendCall(ExternalServiceStoreUpsertFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the Upsert method of the
// parent MockExternalServiceStore instance is invoked and the hook queue is
// empty.
func (f *ExternalServiceStoreUpsertFunc) SetDefaultHook(hook func(context.Context, ...*types.ExternalService) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Upsert method of the parent MockExternalServiceStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ExternalServiceStoreUpsertFunc) PushHook(hook func(context.Context, ...*types.ExternalService) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ExternalServiceStoreUpsertFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, ...*types.ExternalService) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ExternalServiceStoreUpsertFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, ...*types.ExternalService) error {
		return r0
	})
}

func (f *ExternalServiceStoreUpsertFunc) nextHook() func(context.Context, ...*types.ExternalService) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ExternalServiceStoreUpsertFunc) appendCall(r0 ExternalServiceStoreUpsertFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ExternalServiceStoreUpsertFuncCall objects
// describing the invocations of this function.
func (f *ExternalServiceStoreUpsertFunc) History() []ExternalServiceStoreUpsertFuncCall {
	f.mutex.Lock()
	history := make([]ExternalServiceStoreUpsertFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ExternalServiceStoreUpsertFuncCall is an object that describes an
// invocation of method Upsert on an instance of MockExternalServiceStore.
type ExternalServiceStoreUpsertFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []*types.ExternalService
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c ExternalServiceStoreUpsertFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ExternalServiceStoreUpsertFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// MockGitserverRepoStore is a mock implementation of the GitserverRepoStore
// interface (from the package
// github.com/sourcegraph/sourcegraph/internal/codeintel/autoindexing/internal/background/dependencies)
// used for unit testing.
type MockGitserverRepoStore struct {
	// GetByNamesFunc is an instance of a mock function object controlling
	// the behavior of the method GetByNames.
	GetByNamesFunc *GitserverRepoStoreGetByNamesFunc
}

// NewMockGitserverRepoStore creates a new mock of the GitserverRepoStore
// interface. All methods return zero values for all results, unless
// overwritten.
func NewMockGitserverRepoStore() *MockGitserverRepoStore {
	return &MockGitserverRepoStore{
		GetByNamesFunc: &GitserverRepoStoreGetByNamesFunc{
			defaultHook: func(context.Context, ...api.RepoName) (r0 map[api.RepoName]*types.GitserverRepo, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockGitserverRepoStore creates a new mock of the
// GitserverRepoStore interface. All methods panic on invocation, unless
// overwritten.
func NewStrictMockGitserverRepoStore() *MockGitserverRepoStore {
	return &MockGitserverRepoStore{
		GetByNamesFunc: &GitserverRepoStoreGetByNamesFunc{
			defaultHook: func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error) {
				panic("unexpected invocation of MockGitserverRepoStore.GetByNames")
			},
		},
	}
}

// NewMockGitserverRepoStoreFrom creates a new mock of the
// MockGitserverRepoStore interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockGitserverRepoStoreFrom(i GitserverRepoStore) *MockGitserverRepoStore {
	return &MockGitserverRepoStore{
		GetByNamesFunc: &GitserverRepoStoreGetByNamesFunc{
			defaultHook: i.GetByNames,
		},
	}
}

// GitserverRepoStoreGetByNamesFunc describes the behavior when the
// GetByNames method of the parent MockGitserverRepoStore instance is
// invoked.
type GitserverRepoStoreGetByNamesFunc struct {
	defaultHook func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error)
	hooks       []func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error)
	history     []GitserverRepoStoreGetByNamesFuncCall
	mutex       sync.Mutex
}

// GetByNames delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockGitserverRepoStore) GetByNames(v0 context.Context, v1 ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error) {
	r0, r1 := m.GetByNamesFunc.nextHook()(v0, v1...)
	m.GetByNamesFunc.appendCall(GitserverRepoStoreGetByNamesFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetByNames method of
// the parent MockGitserverRepoStore instance is invoked and the hook queue
// is empty.
func (f *GitserverRepoStoreGetByNamesFunc) SetDefaultHook(hook func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetByNames method of the parent MockGitserverRepoStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *GitserverRepoStoreGetByNamesFunc) PushHook(hook func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *GitserverRepoStoreGetByNamesFunc) SetDefaultReturn(r0 map[api.RepoName]*types.GitserverRepo, r1 error) {
	f.SetDefaultHook(func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *GitserverRepoStoreGetByNamesFunc) PushReturn(r0 map[api.RepoName]*types.GitserverRepo, r1 error) {
	f.PushHook(func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error) {
		return r0, r1
	})
}

func (f *GitserverRepoStoreGetByNamesFunc) nextHook() func(context.Context, ...api.RepoName) (map[api.RepoName]*types.GitserverRepo, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *GitserverRepoStoreGetByNamesFunc) appendCall(r0 GitserverRepoStoreGetByNamesFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of GitserverRepoStoreGetByNamesFuncCall
// objects describing the invocations of this function.
func (f *GitserverRepoStoreGetByNamesFunc) History() []GitserverRepoStoreGetByNamesFuncCall {
	f.mutex.Lock()
	history := make([]GitserverRepoStoreGetByNamesFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// GitserverRepoStoreGetByNamesFuncCall is an object that describes an
// invocation of method GetByNames on an instance of MockGitserverRepoStore.
type GitserverRepoStoreGetByNamesFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is a slice containing the values of the variadic arguments
	// passed to this method invocation.
	Arg1 []api.RepoName
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 map[api.RepoName]*types.GitserverRepo
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation. The variadic slice argument is flattened in this array such
// that one positional argument and three variadic arguments would result in
// a slice of four, not two.
func (c GitserverRepoStoreGetByNamesFuncCall) Args() []interface{} {
	trailing := []interface{}{}
	for _, val := range c.Arg1 {
		trailing = append(trailing, val)
	}

	return append([]interface{}{c.Arg0}, trailing...)
}

// Results returns an interface slice containing the results of this
// invocation.
func (c GitserverRepoStoreGetByNamesFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockIndexEnqueuer is a mock implementation of the IndexEnqueuer interface
// (from the package
// github.com/sourcegraph/sourcegraph/internal/codeintel/autoindexing/internal/background/dependencies)
// used for unit testing.
type MockIndexEnqueuer struct {
	// QueueAutoIndexJobsFunc is an instance of a mock function object
	// controlling the behavior of the method QueueAutoIndexJobs.
	QueueAutoIndexJobsFunc *IndexEnqueuerQueueAutoIndexJobsFunc
	// QueueAutoIndexJobsForPackageFunc is an instance of a mock function
	// object controlling the behavior of the method
	// QueueAutoIndexJobsForPackage.
	QueueAutoIndexJobsForPackageFunc *IndexEnqueuerQueueAutoIndexJobsForPackageFunc
}

// NewMockIndexEnqueuer creates a new mock of the IndexEnqueuer interface.
// All methods return zero values for all results, unless overwritten.
func NewMockIndexEnqueuer() *MockIndexEnqueuer {
	return &MockIndexEnqueuer{
		QueueAutoIndexJobsFunc: &IndexEnqueuerQueueAutoIndexJobsFunc{
			defaultHook: func(context.Context, int, string, string, bool, bool) (r0 []shared1.AutoIndexJob, r1 error) {
				return
			},
		},
		QueueAutoIndexJobsForPackageFunc: &IndexEnqueuerQueueAutoIndexJobsForPackageFunc{
			defaultHook: func(context.Context, shared.MinimialVersionedPackageRepo) (r0 error) {
				return
			},
		},
	}
}

// NewStrictMockIndexEnqueuer creates a new mock of the IndexEnqueuer
// interface. All methods panic on invocation, unless overwritten.
func NewStrictMockIndexEnqueuer() *MockIndexEnqueuer {
	return &MockIndexEnqueuer{
		QueueAutoIndexJobsFunc: &IndexEnqueuerQueueAutoIndexJobsFunc{
			defaultHook: func(context.Context, int, string, string, bool, bool) ([]shared1.AutoIndexJob, error) {
				panic("unexpected invocation of MockIndexEnqueuer.QueueAutoIndexJobs")
			},
		},
		QueueAutoIndexJobsForPackageFunc: &IndexEnqueuerQueueAutoIndexJobsForPackageFunc{
			defaultHook: func(context.Context, shared.MinimialVersionedPackageRepo) error {
				panic("unexpected invocation of MockIndexEnqueuer.QueueAutoIndexJobsForPackage")
			},
		},
	}
}

// NewMockIndexEnqueuerFrom creates a new mock of the MockIndexEnqueuer
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockIndexEnqueuerFrom(i IndexEnqueuer) *MockIndexEnqueuer {
	return &MockIndexEnqueuer{
		QueueAutoIndexJobsFunc: &IndexEnqueuerQueueAutoIndexJobsFunc{
			defaultHook: i.QueueAutoIndexJobs,
		},
		QueueAutoIndexJobsForPackageFunc: &IndexEnqueuerQueueAutoIndexJobsForPackageFunc{
			defaultHook: i.QueueAutoIndexJobsForPackage,
		},
	}
}

// IndexEnqueuerQueueAutoIndexJobsFunc describes the behavior when the
// QueueAutoIndexJobs method of the parent MockIndexEnqueuer instance is
// invoked.
type IndexEnqueuerQueueAutoIndexJobsFunc struct {
	defaultHook func(context.Context, int, string, string, bool, bool) ([]shared1.AutoIndexJob, error)
	hooks       []func(context.Context, int, string, string, bool, bool) ([]shared1.AutoIndexJob, error)
	history     []IndexEnqueuerQueueAutoIndexJobsFuncCall
	mutex       sync.Mutex
}

// QueueAutoIndexJobs delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockIndexEnqueuer) QueueAutoIndexJobs(v0 context.Context, v1 int, v2 string, v3 string, v4 bool, v5 bool) ([]shared1.AutoIndexJob, error) {
	r0, r1 := m.QueueAutoIndexJobsFunc.nextHook()(v0, v1, v2, v3, v4, v5)
	m.QueueAutoIndexJobsFunc.appendCall(IndexEnqueuerQueueAutoIndexJobsFuncCall{v0, v1, v2, v3, v4, v5, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the QueueAutoIndexJobs
// method of the parent MockIndexEnqueuer instance is invoked and the hook
// queue is empty.
func (f *IndexEnqueuerQueueAutoIndexJobsFunc) SetDefaultHook(hook func(context.Context, int, string, string, bool, bool) ([]shared1.AutoIndexJob, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// QueueAutoIndexJobs method of the parent MockIndexEnqueuer instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *IndexEnqueuerQueueAutoIndexJobsFunc) PushHook(hook func(context.Context, int, string, string, bool, bool) ([]shared1.AutoIndexJob, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *IndexEnqueuerQueueAutoIndexJobsFunc) SetDefaultReturn(r0 []shared1.AutoIndexJob, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, bool, bool) ([]shared1.AutoIndexJob, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *IndexEnqueuerQueueAutoIndexJobsFunc) PushReturn(r0 []shared1.AutoIndexJob, r1 error) {
	f.PushHook(func(context.Context, int, string, string, bool, bool) ([]shared1.AutoIndexJob, error) {
		return r0, r1
	})
}

func (f *IndexEnqueuerQueueAutoIndexJobsFunc) nextHook() func(context.Context, int, string, string, bool, bool) ([]shared1.AutoIndexJob, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *IndexEnqueuerQueueAutoIndexJobsFunc) appendCall(r0 IndexEnqueuerQueueAutoIndexJobsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of IndexEnqueuerQueueAutoIndexJobsFuncCall
// objects describing the invocations of this function.
func (f *IndexEnqueuerQueueAutoIndexJobsFunc) History() []IndexEnqueuerQueueAutoIndexJobsFuncCall {
	f.mutex.Lock()
	history := make([]IndexEnqueuerQueueAutoIndexJobsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// IndexEnqueuerQueueAutoIndexJobsFuncCall is an object that describes an
// invocation of method QueueAutoIndexJobs on an instance of
// MockIndexEnqueuer.
type IndexEnqueuerQueueAutoIndexJobsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 bool
	// Arg5 is the value of the 6th argument passed to this method
	// invocation.
	Arg5 bool
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared1.AutoIndexJob
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c IndexEnqueuerQueueAutoIndexJobsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4, c.Arg5}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c IndexEnqueuerQueueAutoIndexJobsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// IndexEnqueuerQueueAutoIndexJobsForPackageFunc describes the behavior when
// the QueueAutoIndexJobsForPackage method of the parent MockIndexEnqueuer
// instance is invoked.
type IndexEnqueuerQueueAutoIndexJobsForPackageFunc struct {
	defaultHook func(context.Context, shared.MinimialVersionedPackageRepo) error
	hooks       []func(context.Context, shared.MinimialVersionedPackageRepo) error
	history     []IndexEnqueuerQueueAutoIndexJobsForPackageFuncCall
	mutex       sync.Mutex
}

// QueueAutoIndexJobsForPackage delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockIndexEnqueuer) QueueAutoIndexJobsForPackage(v0 context.Context, v1 shared.MinimialVersionedPackageRepo) error {
	r0 := m.QueueAutoIndexJobsForPackageFunc.nextHook()(v0, v1)
	m.QueueAutoIndexJobsForPackageFunc.appendCall(IndexEnqueuerQueueAutoIndexJobsForPackageFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// QueueAutoIndexJobsForPackage method of the parent MockIndexEnqueuer
// instance is invoked and the hook queue is empty.
func (f *IndexEnqueuerQueueAutoIndexJobsForPackageFunc) SetDefaultHook(hook func(context.Context, shared.MinimialVersionedPackageRepo) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// QueueAutoIndexJobsForPackage method of the parent MockIndexEnqueuer
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *IndexEnqueuerQueueAutoIndexJobsForPackageFunc) PushHook(hook func(context.Context, shared.MinimialVersionedPackageRepo) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *IndexEnqueuerQueueAutoIndexJobsForPackageFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, shared.MinimialVersionedPackageRepo) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *IndexEnqueuerQueueAutoIndexJobsForPackageFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, shared.MinimialVersionedPackageRepo) error {
		return r0
	})
}

func (f *IndexEnqueuerQueueAutoIndexJobsForPackageFunc) nextHook() func(context.Context, shared.MinimialVersionedPackageRepo) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *IndexEnqueuerQueueAutoIndexJobsForPackageFunc) appendCall(r0 IndexEnqueuerQueueAutoIndexJobsForPackageFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// IndexEnqueuerQueueAutoIndexJobsForPackageFuncCall objects describing the
// invocations of this function.
func (f *IndexEnqueuerQueueAutoIndexJobsForPackageFunc) History() []IndexEnqueuerQueueAutoIndexJobsForPackageFuncCall {
	f.mutex.Lock()
	history := make([]IndexEnqueuerQueueAutoIndexJobsForPackageFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// IndexEnqueuerQueueAutoIndexJobsForPackageFuncCall is an object that
// describes an invocation of method QueueAutoIndexJobsForPackage on an
// instance of MockIndexEnqueuer.
type IndexEnqueuerQueueAutoIndexJobsForPackageFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 shared.MinimialVersionedPackageRepo
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c IndexEnqueuerQueueAutoIndexJobsForPackageFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c IndexEnqueuerQueueAutoIndexJobsForPackageFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// MockReposStore is a mock implementation of the ReposStore interface (from
// the package
// github.com/sourcegraph/sourcegraph/internal/codeintel/autoindexing/internal/background/dependencies)
// used for unit testing.
type MockReposStore struct {
	// ListMinimalReposFunc is an instance of a mock function object
	// controlling the behavior of the method ListMinimalRepos.
	ListMinimalReposFunc *ReposStoreListMinimalReposFunc
}

// NewMockReposStore creates a new mock of the ReposStore interface. All
// methods return zero values for all results, unless overwritten.
func NewMockReposStore() *MockReposStore {
	return &MockReposStore{
		ListMinimalReposFunc: &ReposStoreListMinimalReposFunc{
			defaultHook: func(context.Context, database.ReposListOptions) (r0 []types.MinimalRepo, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockReposStore creates a new mock of the ReposStore interface.
// All methods panic on invocation, unless overwritten.
func NewStrictMockReposStore() *MockReposStore {
	return &MockReposStore{
		ListMinimalReposFunc: &ReposStoreListMinimalReposFunc{
			defaultHook: func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error) {
				panic("unexpected invocation of MockReposStore.ListMinimalRepos")
			},
		},
	}
}

// NewMockReposStoreFrom creates a new mock of the MockReposStore interface.
// All methods delegate to the given implementation, unless overwritten.
func NewMockReposStoreFrom(i ReposStore) *MockReposStore {
	return &MockReposStore{
		ListMinimalReposFunc: &ReposStoreListMinimalReposFunc{
			defaultHook: i.ListMinimalRepos,
		},
	}
}

// ReposStoreListMinimalReposFunc describes the behavior when the
// ListMinimalRepos method of the parent MockReposStore instance is invoked.
type ReposStoreListMinimalReposFunc struct {
	defaultHook func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error)
	hooks       []func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error)
	history     []ReposStoreListMinimalReposFuncCall
	mutex       sync.Mutex
}

// ListMinimalRepos delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockReposStore) ListMinimalRepos(v0 context.Context, v1 database.ReposListOptions) ([]types.MinimalRepo, error) {
	r0, r1 := m.ListMinimalReposFunc.nextHook()(v0, v1)
	m.ListMinimalReposFunc.appendCall(ReposStoreListMinimalReposFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ListMinimalRepos
// method of the parent MockReposStore instance is invoked and the hook
// queue is empty.
func (f *ReposStoreListMinimalReposFunc) SetDefaultHook(hook func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ListMinimalRepos method of the parent MockReposStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *ReposStoreListMinimalReposFunc) PushHook(hook func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *ReposStoreListMinimalReposFunc) SetDefaultReturn(r0 []types.MinimalRepo, r1 error) {
	f.SetDefaultHook(func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *ReposStoreListMinimalReposFunc) PushReturn(r0 []types.MinimalRepo, r1 error) {
	f.PushHook(func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error) {
		return r0, r1
	})
}

func (f *ReposStoreListMinimalReposFunc) nextHook() func(context.Context, database.ReposListOptions) ([]types.MinimalRepo, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *ReposStoreListMinimalReposFunc) appendCall(r0 ReposStoreListMinimalReposFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of ReposStoreListMinimalReposFuncCall objects
// describing the invocations of this function.
func (f *ReposStoreListMinimalReposFunc) History() []ReposStoreListMinimalReposFuncCall {
	f.mutex.Lock()
	history := make([]ReposStoreListMinimalReposFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// ReposStoreListMinimalReposFuncCall is an object that describes an
// invocation of method ListMinimalRepos on an instance of MockReposStore.
type ReposStoreListMinimalReposFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 database.ReposListOptions
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []types.MinimalRepo
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c ReposStoreListMinimalReposFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c ReposStoreListMinimalReposFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockUploadService is a mock implementation of the UploadService interface
// (from the package
// github.com/sourcegraph/sourcegraph/internal/codeintel/autoindexing/internal/background/dependencies)
// used for unit testing.
type MockUploadService struct {
	// GetUploadByIDFunc is an instance of a mock function object
	// controlling the behavior of the method GetUploadByID.
	GetUploadByIDFunc *UploadServiceGetUploadByIDFunc
	// ReferencesForUploadFunc is an instance of a mock function object
	// controlling the behavior of the method ReferencesForUpload.
	ReferencesForUploadFunc *UploadServiceReferencesForUploadFunc
}

// NewMockUploadService creates a new mock of the UploadService interface.
// All methods return zero values for all results, unless overwritten.
func NewMockUploadService() *MockUploadService {
	return &MockUploadService{
		GetUploadByIDFunc: &UploadServiceGetUploadByIDFunc{
			defaultHook: func(context.Context, int) (r0 shared1.Upload, r1 bool, r2 error) {
				return
			},
		},
		ReferencesForUploadFunc: &UploadServiceReferencesForUploadFunc{
			defaultHook: func(context.Context, int) (r0 shared1.PackageReferenceScanner, r1 error) {
				return
			},
		},
	}
}

// NewStrictMockUploadService creates a new mock of the UploadService
// interface. All methods panic on invocation, unless overwritten.
func NewStrictMockUploadService() *MockUploadService {
	return &MockUploadService{
		GetUploadByIDFunc: &UploadServiceGetUploadByIDFunc{
			defaultHook: func(context.Context, int) (shared1.Upload, bool, error) {
				panic("unexpected invocation of MockUploadService.GetUploadByID")
			},
		},
		ReferencesForUploadFunc: &UploadServiceReferencesForUploadFunc{
			defaultHook: func(context.Context, int) (shared1.PackageReferenceScanner, error) {
				panic("unexpected invocation of MockUploadService.ReferencesForUpload")
			},
		},
	}
}

// NewMockUploadServiceFrom creates a new mock of the MockUploadService
// interface. All methods delegate to the given implementation, unless
// overwritten.
func NewMockUploadServiceFrom(i UploadService) *MockUploadService {
	return &MockUploadService{
		GetUploadByIDFunc: &UploadServiceGetUploadByIDFunc{
			defaultHook: i.GetUploadByID,
		},
		ReferencesForUploadFunc: &UploadServiceReferencesForUploadFunc{
			defaultHook: i.ReferencesForUpload,
		},
	}
}

// UploadServiceGetUploadByIDFunc describes the behavior when the
// GetUploadByID method of the parent MockUploadService instance is invoked.
type UploadServiceGetUploadByIDFunc struct {
	defaultHook func(context.Context, int) (shared1.Upload, bool, error)
	hooks       []func(context.Context, int) (shared1.Upload, bool, error)
	history     []UploadServiceGetUploadByIDFuncCall
	mutex       sync.Mutex
}

// GetUploadByID delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockUploadService) GetUploadByID(v0 context.Context, v1 int) (shared1.Upload, bool, error) {
	r0, r1, r2 := m.GetUploadByIDFunc.nextHook()(v0, v1)
	m.GetUploadByIDFunc.appendCall(UploadServiceGetUploadByIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the GetUploadByID method
// of the parent MockUploadService instance is invoked and the hook queue is
// empty.
func (f *UploadServiceGetUploadByIDFunc) SetDefaultHook(hook func(context.Context, int) (shared1.Upload, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetUploadByID method of the parent MockUploadService instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *UploadServiceGetUploadByIDFunc) PushHook(hook func(context.Context, int) (shared1.Upload, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *UploadServiceGetUploadByIDFunc) SetDefaultReturn(r0 shared1.Upload, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (shared1.Upload, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *UploadServiceGetUploadByIDFunc) PushReturn(r0 shared1.Upload, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (shared1.Upload, bool, error) {
		return r0, r1, r2
	})
}

func (f *UploadServiceGetUploadByIDFunc) nextHook() func(context.Context, int) (shared1.Upload, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *UploadServiceGetUploadByIDFunc) appendCall(r0 UploadServiceGetUploadByIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of UploadServiceGetUploadByIDFuncCall objects
// describing the invocations of this function.
func (f *UploadServiceGetUploadByIDFunc) History() []UploadServiceGetUploadByIDFuncCall {
	f.mutex.Lock()
	history := make([]UploadServiceGetUploadByIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// UploadServiceGetUploadByIDFuncCall is an object that describes an
// invocation of method GetUploadByID on an instance of MockUploadService.
type UploadServiceGetUploadByIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 shared1.Upload
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c UploadServiceGetUploadByIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c UploadServiceGetUploadByIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// UploadServiceReferencesForUploadFunc describes the behavior when the
// ReferencesForUpload method of the parent MockUploadService instance is
// invoked.
type UploadServiceReferencesForUploadFunc struct {
	defaultHook func(context.Context, int) (shared1.PackageReferenceScanner, error)
	hooks       []func(context.Context, int) (shared1.PackageReferenceScanner, error)
	history     []UploadServiceReferencesForUploadFuncCall
	mutex       sync.Mutex
}

// ReferencesForUpload delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockUploadService) ReferencesForUpload(v0 context.Context, v1 int) (shared1.PackageReferenceScanner, error) {
	r0, r1 := m.ReferencesForUploadFunc.nextHook()(v0, v1)
	m.ReferencesForUploadFunc.appendCall(UploadServiceReferencesForUploadFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the ReferencesForUpload
// method of the parent MockUploadService instance is invoked and the hook
// queue is empty.
func (f *UploadServiceReferencesForUploadFunc) SetDefaultHook(hook func(context.Context, int) (shared1.PackageReferenceScanner, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// ReferencesForUpload method of the parent MockUploadService instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *UploadServiceReferencesForUploadFunc) PushHook(hook func(context.Context, int) (shared1.PackageReferenceScanner, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *UploadServiceReferencesForUploadFunc) SetDefaultReturn(r0 shared1.PackageReferenceScanner, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (shared1.PackageReferenceScanner, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *UploadServiceReferencesForUploadFunc) PushReturn(r0 shared1.PackageReferenceScanner, r1 error) {
	f.PushHook(func(context.Context, int) (shared1.PackageReferenceScanner, error) {
		return r0, r1
	})
}

func (f *UploadServiceReferencesForUploadFunc) nextHook() func(context.Context, int) (shared1.PackageReferenceScanner, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *UploadServiceReferencesForUploadFunc) appendCall(r0 UploadServiceReferencesForUploadFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of UploadServiceReferencesForUploadFuncCall
// objects describing the invocations of this function.
func (f *UploadServiceReferencesForUploadFunc) History() []UploadServiceReferencesForUploadFuncCall {
	f.mutex.Lock()
	history := make([]UploadServiceReferencesForUploadFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// UploadServiceReferencesForUploadFuncCall is an object that describes an
// invocation of method ReferencesForUpload on an instance of
// MockUploadService.
type UploadServiceReferencesForUploadFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 shared1.PackageReferenceScanner
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c UploadServiceReferencesForUploadFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c UploadServiceReferencesForUploadFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// MockPackageReferenceScanner is a mock implementation of the
// PackageReferenceScanner interface (from the package
// github.com/sourcegraph/sourcegraph/internal/codeintel/uploads/shared)
// used for unit testing.
type MockPackageReferenceScanner struct {
	// CloseFunc is an instance of a mock function object controlling the
	// behavior of the method Close.
	CloseFunc *PackageReferenceScannerCloseFunc
	// NextFunc is an instance of a mock function object controlling the
	// behavior of the method Next.
	NextFunc *PackageReferenceScannerNextFunc
}

// NewMockPackageReferenceScanner creates a new mock of the
// PackageReferenceScanner interface. All methods return zero values for all
// results, unless overwritten.
func NewMockPackageReferenceScanner() *MockPackageReferenceScanner {
	return &MockPackageReferenceScanner{
		CloseFunc: &PackageReferenceScannerCloseFunc{
			defaultHook: func() (r0 error) {
				return
			},
		},
		NextFunc: &PackageReferenceScannerNextFunc{
			defaultHook: func() (r0 shared1.PackageReference, r1 bool, r2 error) {
				return
			},
		},
	}
}

// NewStrictMockPackageReferenceScanner creates a new mock of the
// PackageReferenceScanner interface. All methods panic on invocation,
// unless overwritten.
func NewStrictMockPackageReferenceScanner() *MockPackageReferenceScanner {
	return &MockPackageReferenceScanner{
		CloseFunc: &PackageReferenceScannerCloseFunc{
			defaultHook: func() error {
				panic("unexpected invocation of MockPackageReferenceScanner.Close")
			},
		},
		NextFunc: &PackageReferenceScannerNextFunc{
			defaultHook: func() (shared1.PackageReference, bool, error) {
				panic("unexpected invocation of MockPackageReferenceScanner.Next")
			},
		},
	}
}

// NewMockPackageReferenceScannerFrom creates a new mock of the
// MockPackageReferenceScanner interface. All methods delegate to the given
// implementation, unless overwritten.
func NewMockPackageReferenceScannerFrom(i shared1.PackageReferenceScanner) *MockPackageReferenceScanner {
	return &MockPackageReferenceScanner{
		CloseFunc: &PackageReferenceScannerCloseFunc{
			defaultHook: i.Close,
		},
		NextFunc: &PackageReferenceScannerNextFunc{
			defaultHook: i.Next,
		},
	}
}

// PackageReferenceScannerCloseFunc describes the behavior when the Close
// method of the parent MockPackageReferenceScanner instance is invoked.
type PackageReferenceScannerCloseFunc struct {
	defaultHook func() error
	hooks       []func() error
	history     []PackageReferenceScannerCloseFuncCall
	mutex       sync.Mutex
}

// Close delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockPackageReferenceScanner) Close() error {
	r0 := m.CloseFunc.nextHook()()
	m.CloseFunc.appendCall(PackageReferenceScannerCloseFuncCall{r0})
	return r0
}

// SetDefaultHook sets function that is called when the Close method of the
// parent MockPackageReferenceScanner instance is invoked and the hook queue
// is empty.
func (f *PackageReferenceScannerCloseFunc) SetDefaultHook(hook func() error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Close method of the parent MockPackageReferenceScanner instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *PackageReferenceScannerCloseFunc) PushHook(hook func() error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *PackageReferenceScannerCloseFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func() error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *PackageReferenceScannerCloseFunc) PushReturn(r0 error) {
	f.PushHook(func() error {
		return r0
	})
}

func (f *PackageReferenceScannerCloseFunc) nextHook() func() error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *PackageReferenceScannerCloseFunc) appendCall(r0 PackageReferenceScannerCloseFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of PackageReferenceScannerCloseFuncCall
// objects describing the invocations of this function.
func (f *PackageReferenceScannerCloseFunc) History() []PackageReferenceScannerCloseFuncCall {
	f.mutex.Lock()
	history := make([]PackageReferenceScannerCloseFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// PackageReferenceScannerCloseFuncCall is an object that describes an
// invocation of method Close on an instance of MockPackageReferenceScanner.
type PackageReferenceScannerCloseFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c PackageReferenceScannerCloseFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c PackageReferenceScannerCloseFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// PackageReferenceScannerNextFunc describes the behavior when the Next
// method of the parent MockPackageReferenceScanner instance is invoked.
type PackageReferenceScannerNextFunc struct {
	defaultHook func() (shared1.PackageReference, bool, error)
	hooks       []func() (shared1.PackageReference, bool, error)
	history     []PackageReferenceScannerNextFuncCall
	mutex       sync.Mutex
}

// Next delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockPackageReferenceScanner) Next() (shared1.PackageReference, bool, error) {
	r0, r1, r2 := m.NextFunc.nextHook()()
	m.NextFunc.appendCall(PackageReferenceScannerNextFuncCall{r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the Next method of the
// parent MockPackageReferenceScanner instance is invoked and the hook queue
// is empty.
func (f *PackageReferenceScannerNextFunc) SetDefaultHook(hook func() (shared1.PackageReference, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// Next method of the parent MockPackageReferenceScanner instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *PackageReferenceScannerNextFunc) PushHook(hook func() (shared1.PackageReference, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *PackageReferenceScannerNextFunc) SetDefaultReturn(r0 shared1.PackageReference, r1 bool, r2 error) {
	f.SetDefaultHook(func() (shared1.PackageReference, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *PackageReferenceScannerNextFunc) PushReturn(r0 shared1.PackageReference, r1 bool, r2 error) {
	f.PushHook(func() (shared1.PackageReference, bool, error) {
		return r0, r1, r2
	})
}

func (f *PackageReferenceScannerNextFunc) nextHook() func() (shared1.PackageReference, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *PackageReferenceScannerNextFunc) appendCall(r0 PackageReferenceScannerNextFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of PackageReferenceScannerNextFuncCall objects
// describing the invocations of this function.
func (f *PackageReferenceScannerNextFunc) History() []PackageReferenceScannerNextFuncCall {
	f.mutex.Lock()
	history := make([]PackageReferenceScannerNextFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// PackageReferenceScannerNextFuncCall is an object that describes an
// invocation of method Next on an instance of MockPackageReferenceScanner.
type PackageReferenceScannerNextFuncCall struct {
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 shared1.PackageReference
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c PackageReferenceScannerNextFuncCall) Args() []interface{} {
	return []interface{}{}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c PackageReferenceScannerNextFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// MockStore is a mock implementation of the Store interface (from the
// package
// github.com/sourcegraph/sourcegraph/internal/codeintel/autoindexing/internal/store)
// used for unit testing.
type MockStore struct {
	// GetIndexConfigurationByRepositoryIDFunc is an instance of a mock
	// function object controlling the behavior of the method
	// GetIndexConfigurationByRepositoryID.
	GetIndexConfigurationByRepositoryIDFunc *StoreGetIndexConfigurationByRepositoryIDFunc
	// GetInferenceScriptFunc is an instance of a mock function object
	// controlling the behavior of the method GetInferenceScript.
	GetInferenceScriptFunc *StoreGetInferenceScriptFunc
	// GetLastIndexScanForRepositoryFunc is an instance of a mock function
	// object controlling the behavior of the method
	// GetLastIndexScanForRepository.
	GetLastIndexScanForRepositoryFunc *StoreGetLastIndexScanForRepositoryFunc
	// GetQueuedRepoRevFunc is an instance of a mock function object
	// controlling the behavior of the method GetQueuedRepoRev.
	GetQueuedRepoRevFunc *StoreGetQueuedRepoRevFunc
	// InsertDependencyIndexingJobFunc is an instance of a mock function
	// object controlling the behavior of the method
	// InsertDependencyIndexingJob.
	InsertDependencyIndexingJobFunc *StoreInsertDependencyIndexingJobFunc
	// InsertJobsFunc is an instance of a mock function object controlling
	// the behavior of the method InsertJobs.
	InsertJobsFunc *StoreInsertJobsFunc
	// IsQueuedFunc is an instance of a mock function object controlling the
	// behavior of the method IsQueued.
	IsQueuedFunc *StoreIsQueuedFunc
	// IsQueuedRootIndexerFunc is an instance of a mock function object
	// controlling the behavior of the method IsQueuedRootIndexer.
	IsQueuedRootIndexerFunc *StoreIsQueuedRootIndexerFunc
	// MarkRepoRevsAsProcessedFunc is an instance of a mock function object
	// controlling the behavior of the method MarkRepoRevsAsProcessed.
	MarkRepoRevsAsProcessedFunc *StoreMarkRepoRevsAsProcessedFunc
	// QueueRepoRevFunc is an instance of a mock function object controlling
	// the behavior of the method QueueRepoRev.
	QueueRepoRevFunc *StoreQueueRepoRevFunc
	// RepositoryExceptionsFunc is an instance of a mock function object
	// controlling the behavior of the method RepositoryExceptions.
	RepositoryExceptionsFunc *StoreRepositoryExceptionsFunc
	// RepositoryIDsWithConfigurationFunc is an instance of a mock function
	// object controlling the behavior of the method
	// RepositoryIDsWithConfiguration.
	RepositoryIDsWithConfigurationFunc *StoreRepositoryIDsWithConfigurationFunc
	// SetConfigurationSummaryFunc is an instance of a mock function object
	// controlling the behavior of the method SetConfigurationSummary.
	SetConfigurationSummaryFunc *StoreSetConfigurationSummaryFunc
	// SetInferenceScriptFunc is an instance of a mock function object
	// controlling the behavior of the method SetInferenceScript.
	SetInferenceScriptFunc *StoreSetInferenceScriptFunc
	// SetRepositoryExceptionsFunc is an instance of a mock function object
	// controlling the behavior of the method SetRepositoryExceptions.
	SetRepositoryExceptionsFunc *StoreSetRepositoryExceptionsFunc
	// TopRepositoriesToConfigureFunc is an instance of a mock function
	// object controlling the behavior of the method
	// TopRepositoriesToConfigure.
	TopRepositoriesToConfigureFunc *StoreTopRepositoriesToConfigureFunc
	// TruncateConfigurationSummaryFunc is an instance of a mock function
	// object controlling the behavior of the method
	// TruncateConfigurationSummary.
	TruncateConfigurationSummaryFunc *StoreTruncateConfigurationSummaryFunc
	// UpdateIndexConfigurationByRepositoryIDFunc is an instance of a mock
	// function object controlling the behavior of the method
	// UpdateIndexConfigurationByRepositoryID.
	UpdateIndexConfigurationByRepositoryIDFunc *StoreUpdateIndexConfigurationByRepositoryIDFunc
	// WithTransactionFunc is an instance of a mock function object
	// controlling the behavior of the method WithTransaction.
	WithTransactionFunc *StoreWithTransactionFunc
}

// NewMockStore creates a new mock of the Store interface. All methods
// return zero values for all results, unless overwritten.
func NewMockStore() *MockStore {
	return &MockStore{
		GetIndexConfigurationByRepositoryIDFunc: &StoreGetIndexConfigurationByRepositoryIDFunc{
			defaultHook: func(context.Context, int) (r0 shared2.IndexConfiguration, r1 bool, r2 error) {
				return
			},
		},
		GetInferenceScriptFunc: &StoreGetInferenceScriptFunc{
			defaultHook: func(context.Context) (r0 string, r1 error) {
				return
			},
		},
		GetLastIndexScanForRepositoryFunc: &StoreGetLastIndexScanForRepositoryFunc{
			defaultHook: func(context.Context, int) (r0 *time.Time, r1 error) {
				return
			},
		},
		GetQueuedRepoRevFunc: &StoreGetQueuedRepoRevFunc{
			defaultHook: func(context.Context, int) (r0 []store.RepoRev, r1 error) {
				return
			},
		},
		InsertDependencyIndexingJobFunc: &StoreInsertDependencyIndexingJobFunc{
			defaultHook: func(context.Context, int, string, time.Time) (r0 int, r1 error) {
				return
			},
		},
		InsertJobsFunc: &StoreInsertJobsFunc{
			defaultHook: func(context.Context, []shared1.AutoIndexJob) (r0 []shared1.AutoIndexJob, r1 error) {
				return
			},
		},
		IsQueuedFunc: &StoreIsQueuedFunc{
			defaultHook: func(context.Context, int, string) (r0 bool, r1 error) {
				return
			},
		},
		IsQueuedRootIndexerFunc: &StoreIsQueuedRootIndexerFunc{
			defaultHook: func(context.Context, int, string, string, string) (r0 bool, r1 error) {
				return
			},
		},
		MarkRepoRevsAsProcessedFunc: &StoreMarkRepoRevsAsProcessedFunc{
			defaultHook: func(context.Context, []int) (r0 error) {
				return
			},
		},
		QueueRepoRevFunc: &StoreQueueRepoRevFunc{
			defaultHook: func(context.Context, int, string) (r0 error) {
				return
			},
		},
		RepositoryExceptionsFunc: &StoreRepositoryExceptionsFunc{
			defaultHook: func(context.Context, int) (r0 bool, r1 bool, r2 error) {
				return
			},
		},
		RepositoryIDsWithConfigurationFunc: &StoreRepositoryIDsWithConfigurationFunc{
			defaultHook: func(context.Context, int, int) (r0 []shared1.RepositoryWithAvailableIndexers, r1 int, r2 error) {
				return
			},
		},
		SetConfigurationSummaryFunc: &StoreSetConfigurationSummaryFunc{
			defaultHook: func(context.Context, int, int, map[string]shared1.AvailableIndexer) (r0 error) {
				return
			},
		},
		SetInferenceScriptFunc: &StoreSetInferenceScriptFunc{
			defaultHook: func(context.Context, string) (r0 error) {
				return
			},
		},
		SetRepositoryExceptionsFunc: &StoreSetRepositoryExceptionsFunc{
			defaultHook: func(context.Context, int, bool, bool) (r0 error) {
				return
			},
		},
		TopRepositoriesToConfigureFunc: &StoreTopRepositoriesToConfigureFunc{
			defaultHook: func(context.Context, int) (r0 []shared1.RepositoryWithCount, r1 error) {
				return
			},
		},
		TruncateConfigurationSummaryFunc: &StoreTruncateConfigurationSummaryFunc{
			defaultHook: func(context.Context, int) (r0 error) {
				return
			},
		},
		UpdateIndexConfigurationByRepositoryIDFunc: &StoreUpdateIndexConfigurationByRepositoryIDFunc{
			defaultHook: func(context.Context, int, []byte) (r0 error) {
				return
			},
		},
		WithTransactionFunc: &StoreWithTransactionFunc{
			defaultHook: func(context.Context, func(tx store.Store) error) (r0 error) {
				return
			},
		},
	}
}

// NewStrictMockStore creates a new mock of the Store interface. All methods
// panic on invocation, unless overwritten.
func NewStrictMockStore() *MockStore {
	return &MockStore{
		GetIndexConfigurationByRepositoryIDFunc: &StoreGetIndexConfigurationByRepositoryIDFunc{
			defaultHook: func(context.Context, int) (shared2.IndexConfiguration, bool, error) {
				panic("unexpected invocation of MockStore.GetIndexConfigurationByRepositoryID")
			},
		},
		GetInferenceScriptFunc: &StoreGetInferenceScriptFunc{
			defaultHook: func(context.Context) (string, error) {
				panic("unexpected invocation of MockStore.GetInferenceScript")
			},
		},
		GetLastIndexScanForRepositoryFunc: &StoreGetLastIndexScanForRepositoryFunc{
			defaultHook: func(context.Context, int) (*time.Time, error) {
				panic("unexpected invocation of MockStore.GetLastIndexScanForRepository")
			},
		},
		GetQueuedRepoRevFunc: &StoreGetQueuedRepoRevFunc{
			defaultHook: func(context.Context, int) ([]store.RepoRev, error) {
				panic("unexpected invocation of MockStore.GetQueuedRepoRev")
			},
		},
		InsertDependencyIndexingJobFunc: &StoreInsertDependencyIndexingJobFunc{
			defaultHook: func(context.Context, int, string, time.Time) (int, error) {
				panic("unexpected invocation of MockStore.InsertDependencyIndexingJob")
			},
		},
		InsertJobsFunc: &StoreInsertJobsFunc{
			defaultHook: func(context.Context, []shared1.AutoIndexJob) ([]shared1.AutoIndexJob, error) {
				panic("unexpected invocation of MockStore.InsertJobs")
			},
		},
		IsQueuedFunc: &StoreIsQueuedFunc{
			defaultHook: func(context.Context, int, string) (bool, error) {
				panic("unexpected invocation of MockStore.IsQueued")
			},
		},
		IsQueuedRootIndexerFunc: &StoreIsQueuedRootIndexerFunc{
			defaultHook: func(context.Context, int, string, string, string) (bool, error) {
				panic("unexpected invocation of MockStore.IsQueuedRootIndexer")
			},
		},
		MarkRepoRevsAsProcessedFunc: &StoreMarkRepoRevsAsProcessedFunc{
			defaultHook: func(context.Context, []int) error {
				panic("unexpected invocation of MockStore.MarkRepoRevsAsProcessed")
			},
		},
		QueueRepoRevFunc: &StoreQueueRepoRevFunc{
			defaultHook: func(context.Context, int, string) error {
				panic("unexpected invocation of MockStore.QueueRepoRev")
			},
		},
		RepositoryExceptionsFunc: &StoreRepositoryExceptionsFunc{
			defaultHook: func(context.Context, int) (bool, bool, error) {
				panic("unexpected invocation of MockStore.RepositoryExceptions")
			},
		},
		RepositoryIDsWithConfigurationFunc: &StoreRepositoryIDsWithConfigurationFunc{
			defaultHook: func(context.Context, int, int) ([]shared1.RepositoryWithAvailableIndexers, int, error) {
				panic("unexpected invocation of MockStore.RepositoryIDsWithConfiguration")
			},
		},
		SetConfigurationSummaryFunc: &StoreSetConfigurationSummaryFunc{
			defaultHook: func(context.Context, int, int, map[string]shared1.AvailableIndexer) error {
				panic("unexpected invocation of MockStore.SetConfigurationSummary")
			},
		},
		SetInferenceScriptFunc: &StoreSetInferenceScriptFunc{
			defaultHook: func(context.Context, string) error {
				panic("unexpected invocation of MockStore.SetInferenceScript")
			},
		},
		SetRepositoryExceptionsFunc: &StoreSetRepositoryExceptionsFunc{
			defaultHook: func(context.Context, int, bool, bool) error {
				panic("unexpected invocation of MockStore.SetRepositoryExceptions")
			},
		},
		TopRepositoriesToConfigureFunc: &StoreTopRepositoriesToConfigureFunc{
			defaultHook: func(context.Context, int) ([]shared1.RepositoryWithCount, error) {
				panic("unexpected invocation of MockStore.TopRepositoriesToConfigure")
			},
		},
		TruncateConfigurationSummaryFunc: &StoreTruncateConfigurationSummaryFunc{
			defaultHook: func(context.Context, int) error {
				panic("unexpected invocation of MockStore.TruncateConfigurationSummary")
			},
		},
		UpdateIndexConfigurationByRepositoryIDFunc: &StoreUpdateIndexConfigurationByRepositoryIDFunc{
			defaultHook: func(context.Context, int, []byte) error {
				panic("unexpected invocation of MockStore.UpdateIndexConfigurationByRepositoryID")
			},
		},
		WithTransactionFunc: &StoreWithTransactionFunc{
			defaultHook: func(context.Context, func(tx store.Store) error) error {
				panic("unexpected invocation of MockStore.WithTransaction")
			},
		},
	}
}

// NewMockStoreFrom creates a new mock of the MockStore interface. All
// methods delegate to the given implementation, unless overwritten.
func NewMockStoreFrom(i store.Store) *MockStore {
	return &MockStore{
		GetIndexConfigurationByRepositoryIDFunc: &StoreGetIndexConfigurationByRepositoryIDFunc{
			defaultHook: i.GetIndexConfigurationByRepositoryID,
		},
		GetInferenceScriptFunc: &StoreGetInferenceScriptFunc{
			defaultHook: i.GetInferenceScript,
		},
		GetLastIndexScanForRepositoryFunc: &StoreGetLastIndexScanForRepositoryFunc{
			defaultHook: i.GetLastIndexScanForRepository,
		},
		GetQueuedRepoRevFunc: &StoreGetQueuedRepoRevFunc{
			defaultHook: i.GetQueuedRepoRev,
		},
		InsertDependencyIndexingJobFunc: &StoreInsertDependencyIndexingJobFunc{
			defaultHook: i.InsertDependencyIndexingJob,
		},
		InsertJobsFunc: &StoreInsertJobsFunc{
			defaultHook: i.InsertJobs,
		},
		IsQueuedFunc: &StoreIsQueuedFunc{
			defaultHook: i.IsQueued,
		},
		IsQueuedRootIndexerFunc: &StoreIsQueuedRootIndexerFunc{
			defaultHook: i.IsQueuedRootIndexer,
		},
		MarkRepoRevsAsProcessedFunc: &StoreMarkRepoRevsAsProcessedFunc{
			defaultHook: i.MarkRepoRevsAsProcessed,
		},
		QueueRepoRevFunc: &StoreQueueRepoRevFunc{
			defaultHook: i.QueueRepoRev,
		},
		RepositoryExceptionsFunc: &StoreRepositoryExceptionsFunc{
			defaultHook: i.RepositoryExceptions,
		},
		RepositoryIDsWithConfigurationFunc: &StoreRepositoryIDsWithConfigurationFunc{
			defaultHook: i.RepositoryIDsWithConfiguration,
		},
		SetConfigurationSummaryFunc: &StoreSetConfigurationSummaryFunc{
			defaultHook: i.SetConfigurationSummary,
		},
		SetInferenceScriptFunc: &StoreSetInferenceScriptFunc{
			defaultHook: i.SetInferenceScript,
		},
		SetRepositoryExceptionsFunc: &StoreSetRepositoryExceptionsFunc{
			defaultHook: i.SetRepositoryExceptions,
		},
		TopRepositoriesToConfigureFunc: &StoreTopRepositoriesToConfigureFunc{
			defaultHook: i.TopRepositoriesToConfigure,
		},
		TruncateConfigurationSummaryFunc: &StoreTruncateConfigurationSummaryFunc{
			defaultHook: i.TruncateConfigurationSummary,
		},
		UpdateIndexConfigurationByRepositoryIDFunc: &StoreUpdateIndexConfigurationByRepositoryIDFunc{
			defaultHook: i.UpdateIndexConfigurationByRepositoryID,
		},
		WithTransactionFunc: &StoreWithTransactionFunc{
			defaultHook: i.WithTransaction,
		},
	}
}

// StoreGetIndexConfigurationByRepositoryIDFunc describes the behavior when
// the GetIndexConfigurationByRepositoryID method of the parent MockStore
// instance is invoked.
type StoreGetIndexConfigurationByRepositoryIDFunc struct {
	defaultHook func(context.Context, int) (shared2.IndexConfiguration, bool, error)
	hooks       []func(context.Context, int) (shared2.IndexConfiguration, bool, error)
	history     []StoreGetIndexConfigurationByRepositoryIDFuncCall
	mutex       sync.Mutex
}

// GetIndexConfigurationByRepositoryID delegates to the next hook function
// in the queue and stores the parameter and result values of this
// invocation.
func (m *MockStore) GetIndexConfigurationByRepositoryID(v0 context.Context, v1 int) (shared2.IndexConfiguration, bool, error) {
	r0, r1, r2 := m.GetIndexConfigurationByRepositoryIDFunc.nextHook()(v0, v1)
	m.GetIndexConfigurationByRepositoryIDFunc.appendCall(StoreGetIndexConfigurationByRepositoryIDFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// GetIndexConfigurationByRepositoryID method of the parent MockStore
// instance is invoked and the hook queue is empty.
func (f *StoreGetIndexConfigurationByRepositoryIDFunc) SetDefaultHook(hook func(context.Context, int) (shared2.IndexConfiguration, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetIndexConfigurationByRepositoryID method of the parent MockStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *StoreGetIndexConfigurationByRepositoryIDFunc) PushHook(hook func(context.Context, int) (shared2.IndexConfiguration, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetIndexConfigurationByRepositoryIDFunc) SetDefaultReturn(r0 shared2.IndexConfiguration, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (shared2.IndexConfiguration, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetIndexConfigurationByRepositoryIDFunc) PushReturn(r0 shared2.IndexConfiguration, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (shared2.IndexConfiguration, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreGetIndexConfigurationByRepositoryIDFunc) nextHook() func(context.Context, int) (shared2.IndexConfiguration, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetIndexConfigurationByRepositoryIDFunc) appendCall(r0 StoreGetIndexConfigurationByRepositoryIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// StoreGetIndexConfigurationByRepositoryIDFuncCall objects describing the
// invocations of this function.
func (f *StoreGetIndexConfigurationByRepositoryIDFunc) History() []StoreGetIndexConfigurationByRepositoryIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetIndexConfigurationByRepositoryIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetIndexConfigurationByRepositoryIDFuncCall is an object that
// describes an invocation of method GetIndexConfigurationByRepositoryID on
// an instance of MockStore.
type StoreGetIndexConfigurationByRepositoryIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 shared2.IndexConfiguration
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetIndexConfigurationByRepositoryIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetIndexConfigurationByRepositoryIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreGetInferenceScriptFunc describes the behavior when the
// GetInferenceScript method of the parent MockStore instance is invoked.
type StoreGetInferenceScriptFunc struct {
	defaultHook func(context.Context) (string, error)
	hooks       []func(context.Context) (string, error)
	history     []StoreGetInferenceScriptFuncCall
	mutex       sync.Mutex
}

// GetInferenceScript delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) GetInferenceScript(v0 context.Context) (string, error) {
	r0, r1 := m.GetInferenceScriptFunc.nextHook()(v0)
	m.GetInferenceScriptFunc.appendCall(StoreGetInferenceScriptFuncCall{v0, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetInferenceScript
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreGetInferenceScriptFunc) SetDefaultHook(hook func(context.Context) (string, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetInferenceScript method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreGetInferenceScriptFunc) PushHook(hook func(context.Context) (string, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetInferenceScriptFunc) SetDefaultReturn(r0 string, r1 error) {
	f.SetDefaultHook(func(context.Context) (string, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetInferenceScriptFunc) PushReturn(r0 string, r1 error) {
	f.PushHook(func(context.Context) (string, error) {
		return r0, r1
	})
}

func (f *StoreGetInferenceScriptFunc) nextHook() func(context.Context) (string, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetInferenceScriptFunc) appendCall(r0 StoreGetInferenceScriptFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetInferenceScriptFuncCall objects
// describing the invocations of this function.
func (f *StoreGetInferenceScriptFunc) History() []StoreGetInferenceScriptFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetInferenceScriptFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetInferenceScriptFuncCall is an object that describes an invocation
// of method GetInferenceScript on an instance of MockStore.
type StoreGetInferenceScriptFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 string
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetInferenceScriptFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetInferenceScriptFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetLastIndexScanForRepositoryFunc describes the behavior when the
// GetLastIndexScanForRepository method of the parent MockStore instance is
// invoked.
type StoreGetLastIndexScanForRepositoryFunc struct {
	defaultHook func(context.Context, int) (*time.Time, error)
	hooks       []func(context.Context, int) (*time.Time, error)
	history     []StoreGetLastIndexScanForRepositoryFuncCall
	mutex       sync.Mutex
}

// GetLastIndexScanForRepository delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) GetLastIndexScanForRepository(v0 context.Context, v1 int) (*time.Time, error) {
	r0, r1 := m.GetLastIndexScanForRepositoryFunc.nextHook()(v0, v1)
	m.GetLastIndexScanForRepositoryFunc.appendCall(StoreGetLastIndexScanForRepositoryFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// GetLastIndexScanForRepository method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreGetLastIndexScanForRepositoryFunc) SetDefaultHook(hook func(context.Context, int) (*time.Time, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetLastIndexScanForRepository method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreGetLastIndexScanForRepositoryFunc) PushHook(hook func(context.Context, int) (*time.Time, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetLastIndexScanForRepositoryFunc) SetDefaultReturn(r0 *time.Time, r1 error) {
	f.SetDefaultHook(func(context.Context, int) (*time.Time, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetLastIndexScanForRepositoryFunc) PushReturn(r0 *time.Time, r1 error) {
	f.PushHook(func(context.Context, int) (*time.Time, error) {
		return r0, r1
	})
}

func (f *StoreGetLastIndexScanForRepositoryFunc) nextHook() func(context.Context, int) (*time.Time, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetLastIndexScanForRepositoryFunc) appendCall(r0 StoreGetLastIndexScanForRepositoryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetLastIndexScanForRepositoryFuncCall
// objects describing the invocations of this function.
func (f *StoreGetLastIndexScanForRepositoryFunc) History() []StoreGetLastIndexScanForRepositoryFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetLastIndexScanForRepositoryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetLastIndexScanForRepositoryFuncCall is an object that describes an
// invocation of method GetLastIndexScanForRepository on an instance of
// MockStore.
type StoreGetLastIndexScanForRepositoryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 *time.Time
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetLastIndexScanForRepositoryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetLastIndexScanForRepositoryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreGetQueuedRepoRevFunc describes the behavior when the
// GetQueuedRepoRev method of the parent MockStore instance is invoked.
type StoreGetQueuedRepoRevFunc struct {
	defaultHook func(context.Context, int) ([]store.RepoRev, error)
	hooks       []func(context.Context, int) ([]store.RepoRev, error)
	history     []StoreGetQueuedRepoRevFuncCall
	mutex       sync.Mutex
}

// GetQueuedRepoRev delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) GetQueuedRepoRev(v0 context.Context, v1 int) ([]store.RepoRev, error) {
	r0, r1 := m.GetQueuedRepoRevFunc.nextHook()(v0, v1)
	m.GetQueuedRepoRevFunc.appendCall(StoreGetQueuedRepoRevFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the GetQueuedRepoRev
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreGetQueuedRepoRevFunc) SetDefaultHook(hook func(context.Context, int) ([]store.RepoRev, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// GetQueuedRepoRev method of the parent MockStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreGetQueuedRepoRevFunc) PushHook(hook func(context.Context, int) ([]store.RepoRev, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreGetQueuedRepoRevFunc) SetDefaultReturn(r0 []store.RepoRev, r1 error) {
	f.SetDefaultHook(func(context.Context, int) ([]store.RepoRev, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreGetQueuedRepoRevFunc) PushReturn(r0 []store.RepoRev, r1 error) {
	f.PushHook(func(context.Context, int) ([]store.RepoRev, error) {
		return r0, r1
	})
}

func (f *StoreGetQueuedRepoRevFunc) nextHook() func(context.Context, int) ([]store.RepoRev, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreGetQueuedRepoRevFunc) appendCall(r0 StoreGetQueuedRepoRevFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreGetQueuedRepoRevFuncCall objects
// describing the invocations of this function.
func (f *StoreGetQueuedRepoRevFunc) History() []StoreGetQueuedRepoRevFuncCall {
	f.mutex.Lock()
	history := make([]StoreGetQueuedRepoRevFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreGetQueuedRepoRevFuncCall is an object that describes an invocation
// of method GetQueuedRepoRev on an instance of MockStore.
type StoreGetQueuedRepoRevFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []store.RepoRev
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreGetQueuedRepoRevFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreGetQueuedRepoRevFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreInsertDependencyIndexingJobFunc describes the behavior when the
// InsertDependencyIndexingJob method of the parent MockStore instance is
// invoked.
type StoreInsertDependencyIndexingJobFunc struct {
	defaultHook func(context.Context, int, string, time.Time) (int, error)
	hooks       []func(context.Context, int, string, time.Time) (int, error)
	history     []StoreInsertDependencyIndexingJobFuncCall
	mutex       sync.Mutex
}

// InsertDependencyIndexingJob delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) InsertDependencyIndexingJob(v0 context.Context, v1 int, v2 string, v3 time.Time) (int, error) {
	r0, r1 := m.InsertDependencyIndexingJobFunc.nextHook()(v0, v1, v2, v3)
	m.InsertDependencyIndexingJobFunc.appendCall(StoreInsertDependencyIndexingJobFuncCall{v0, v1, v2, v3, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// InsertDependencyIndexingJob method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreInsertDependencyIndexingJobFunc) SetDefaultHook(hook func(context.Context, int, string, time.Time) (int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertDependencyIndexingJob method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreInsertDependencyIndexingJobFunc) PushHook(hook func(context.Context, int, string, time.Time) (int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreInsertDependencyIndexingJobFunc) SetDefaultReturn(r0 int, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, time.Time) (int, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreInsertDependencyIndexingJobFunc) PushReturn(r0 int, r1 error) {
	f.PushHook(func(context.Context, int, string, time.Time) (int, error) {
		return r0, r1
	})
}

func (f *StoreInsertDependencyIndexingJobFunc) nextHook() func(context.Context, int, string, time.Time) (int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreInsertDependencyIndexingJobFunc) appendCall(r0 StoreInsertDependencyIndexingJobFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreInsertDependencyIndexingJobFuncCall
// objects describing the invocations of this function.
func (f *StoreInsertDependencyIndexingJobFunc) History() []StoreInsertDependencyIndexingJobFuncCall {
	f.mutex.Lock()
	history := make([]StoreInsertDependencyIndexingJobFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreInsertDependencyIndexingJobFuncCall is an object that describes an
// invocation of method InsertDependencyIndexingJob on an instance of
// MockStore.
type StoreInsertDependencyIndexingJobFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 time.Time
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 int
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreInsertDependencyIndexingJobFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreInsertDependencyIndexingJobFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreInsertJobsFunc describes the behavior when the InsertJobs method of
// the parent MockStore instance is invoked.
type StoreInsertJobsFunc struct {
	defaultHook func(context.Context, []shared1.AutoIndexJob) ([]shared1.AutoIndexJob, error)
	hooks       []func(context.Context, []shared1.AutoIndexJob) ([]shared1.AutoIndexJob, error)
	history     []StoreInsertJobsFuncCall
	mutex       sync.Mutex
}

// InsertJobs delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) InsertJobs(v0 context.Context, v1 []shared1.AutoIndexJob) ([]shared1.AutoIndexJob, error) {
	r0, r1 := m.InsertJobsFunc.nextHook()(v0, v1)
	m.InsertJobsFunc.appendCall(StoreInsertJobsFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the InsertJobs method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreInsertJobsFunc) SetDefaultHook(hook func(context.Context, []shared1.AutoIndexJob) ([]shared1.AutoIndexJob, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// InsertJobs method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreInsertJobsFunc) PushHook(hook func(context.Context, []shared1.AutoIndexJob) ([]shared1.AutoIndexJob, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreInsertJobsFunc) SetDefaultReturn(r0 []shared1.AutoIndexJob, r1 error) {
	f.SetDefaultHook(func(context.Context, []shared1.AutoIndexJob) ([]shared1.AutoIndexJob, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreInsertJobsFunc) PushReturn(r0 []shared1.AutoIndexJob, r1 error) {
	f.PushHook(func(context.Context, []shared1.AutoIndexJob) ([]shared1.AutoIndexJob, error) {
		return r0, r1
	})
}

func (f *StoreInsertJobsFunc) nextHook() func(context.Context, []shared1.AutoIndexJob) ([]shared1.AutoIndexJob, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreInsertJobsFunc) appendCall(r0 StoreInsertJobsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreInsertJobsFuncCall objects describing
// the invocations of this function.
func (f *StoreInsertJobsFunc) History() []StoreInsertJobsFuncCall {
	f.mutex.Lock()
	history := make([]StoreInsertJobsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreInsertJobsFuncCall is an object that describes an invocation of
// method InsertJobs on an instance of MockStore.
type StoreInsertJobsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []shared1.AutoIndexJob
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared1.AutoIndexJob
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreInsertJobsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreInsertJobsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreIsQueuedFunc describes the behavior when the IsQueued method of the
// parent MockStore instance is invoked.
type StoreIsQueuedFunc struct {
	defaultHook func(context.Context, int, string) (bool, error)
	hooks       []func(context.Context, int, string) (bool, error)
	history     []StoreIsQueuedFuncCall
	mutex       sync.Mutex
}

// IsQueued delegates to the next hook function in the queue and stores the
// parameter and result values of this invocation.
func (m *MockStore) IsQueued(v0 context.Context, v1 int, v2 string) (bool, error) {
	r0, r1 := m.IsQueuedFunc.nextHook()(v0, v1, v2)
	m.IsQueuedFunc.appendCall(StoreIsQueuedFuncCall{v0, v1, v2, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the IsQueued method of
// the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreIsQueuedFunc) SetDefaultHook(hook func(context.Context, int, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// IsQueued method of the parent MockStore instance invokes the hook at the
// front of the queue and discards it. After the queue is empty, the default
// hook function is invoked for any future action.
func (f *StoreIsQueuedFunc) PushHook(hook func(context.Context, int, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreIsQueuedFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreIsQueuedFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string) (bool, error) {
		return r0, r1
	})
}

func (f *StoreIsQueuedFunc) nextHook() func(context.Context, int, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreIsQueuedFunc) appendCall(r0 StoreIsQueuedFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreIsQueuedFuncCall objects describing
// the invocations of this function.
func (f *StoreIsQueuedFunc) History() []StoreIsQueuedFuncCall {
	f.mutex.Lock()
	history := make([]StoreIsQueuedFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreIsQueuedFuncCall is an object that describes an invocation of method
// IsQueued on an instance of MockStore.
type StoreIsQueuedFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreIsQueuedFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreIsQueuedFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreIsQueuedRootIndexerFunc describes the behavior when the
// IsQueuedRootIndexer method of the parent MockStore instance is invoked.
type StoreIsQueuedRootIndexerFunc struct {
	defaultHook func(context.Context, int, string, string, string) (bool, error)
	hooks       []func(context.Context, int, string, string, string) (bool, error)
	history     []StoreIsQueuedRootIndexerFuncCall
	mutex       sync.Mutex
}

// IsQueuedRootIndexer delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) IsQueuedRootIndexer(v0 context.Context, v1 int, v2 string, v3 string, v4 string) (bool, error) {
	r0, r1 := m.IsQueuedRootIndexerFunc.nextHook()(v0, v1, v2, v3, v4)
	m.IsQueuedRootIndexerFunc.appendCall(StoreIsQueuedRootIndexerFuncCall{v0, v1, v2, v3, v4, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the IsQueuedRootIndexer
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreIsQueuedRootIndexerFunc) SetDefaultHook(hook func(context.Context, int, string, string, string) (bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// IsQueuedRootIndexer method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreIsQueuedRootIndexerFunc) PushHook(hook func(context.Context, int, string, string, string) (bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreIsQueuedRootIndexerFunc) SetDefaultReturn(r0 bool, r1 error) {
	f.SetDefaultHook(func(context.Context, int, string, string, string) (bool, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreIsQueuedRootIndexerFunc) PushReturn(r0 bool, r1 error) {
	f.PushHook(func(context.Context, int, string, string, string) (bool, error) {
		return r0, r1
	})
}

func (f *StoreIsQueuedRootIndexerFunc) nextHook() func(context.Context, int, string, string, string) (bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreIsQueuedRootIndexerFunc) appendCall(r0 StoreIsQueuedRootIndexerFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreIsQueuedRootIndexerFuncCall objects
// describing the invocations of this function.
func (f *StoreIsQueuedRootIndexerFunc) History() []StoreIsQueuedRootIndexerFuncCall {
	f.mutex.Lock()
	history := make([]StoreIsQueuedRootIndexerFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreIsQueuedRootIndexerFuncCall is an object that describes an
// invocation of method IsQueuedRootIndexer on an instance of MockStore.
type StoreIsQueuedRootIndexerFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 string
	// Arg4 is the value of the 5th argument passed to this method
	// invocation.
	Arg4 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreIsQueuedRootIndexerFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3, c.Arg4}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreIsQueuedRootIndexerFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreMarkRepoRevsAsProcessedFunc describes the behavior when the
// MarkRepoRevsAsProcessed method of the parent MockStore instance is
// invoked.
type StoreMarkRepoRevsAsProcessedFunc struct {
	defaultHook func(context.Context, []int) error
	hooks       []func(context.Context, []int) error
	history     []StoreMarkRepoRevsAsProcessedFuncCall
	mutex       sync.Mutex
}

// MarkRepoRevsAsProcessed delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) MarkRepoRevsAsProcessed(v0 context.Context, v1 []int) error {
	r0 := m.MarkRepoRevsAsProcessedFunc.nextHook()(v0, v1)
	m.MarkRepoRevsAsProcessedFunc.appendCall(StoreMarkRepoRevsAsProcessedFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// MarkRepoRevsAsProcessed method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreMarkRepoRevsAsProcessedFunc) SetDefaultHook(hook func(context.Context, []int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// MarkRepoRevsAsProcessed method of the parent MockStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreMarkRepoRevsAsProcessedFunc) PushHook(hook func(context.Context, []int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreMarkRepoRevsAsProcessedFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, []int) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreMarkRepoRevsAsProcessedFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, []int) error {
		return r0
	})
}

func (f *StoreMarkRepoRevsAsProcessedFunc) nextHook() func(context.Context, []int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreMarkRepoRevsAsProcessedFunc) appendCall(r0 StoreMarkRepoRevsAsProcessedFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreMarkRepoRevsAsProcessedFuncCall
// objects describing the invocations of this function.
func (f *StoreMarkRepoRevsAsProcessedFunc) History() []StoreMarkRepoRevsAsProcessedFuncCall {
	f.mutex.Lock()
	history := make([]StoreMarkRepoRevsAsProcessedFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreMarkRepoRevsAsProcessedFuncCall is an object that describes an
// invocation of method MarkRepoRevsAsProcessed on an instance of MockStore.
type StoreMarkRepoRevsAsProcessedFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 []int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreMarkRepoRevsAsProcessedFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreMarkRepoRevsAsProcessedFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreQueueRepoRevFunc describes the behavior when the QueueRepoRev method
// of the parent MockStore instance is invoked.
type StoreQueueRepoRevFunc struct {
	defaultHook func(context.Context, int, string) error
	hooks       []func(context.Context, int, string) error
	history     []StoreQueueRepoRevFuncCall
	mutex       sync.Mutex
}

// QueueRepoRev delegates to the next hook function in the queue and stores
// the parameter and result values of this invocation.
func (m *MockStore) QueueRepoRev(v0 context.Context, v1 int, v2 string) error {
	r0 := m.QueueRepoRevFunc.nextHook()(v0, v1, v2)
	m.QueueRepoRevFunc.appendCall(StoreQueueRepoRevFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the QueueRepoRev method
// of the parent MockStore instance is invoked and the hook queue is empty.
func (f *StoreQueueRepoRevFunc) SetDefaultHook(hook func(context.Context, int, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// QueueRepoRev method of the parent MockStore instance invokes the hook at
// the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreQueueRepoRevFunc) PushHook(hook func(context.Context, int, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreQueueRepoRevFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, string) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreQueueRepoRevFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, string) error {
		return r0
	})
}

func (f *StoreQueueRepoRevFunc) nextHook() func(context.Context, int, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreQueueRepoRevFunc) appendCall(r0 StoreQueueRepoRevFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreQueueRepoRevFuncCall objects
// describing the invocations of this function.
func (f *StoreQueueRepoRevFunc) History() []StoreQueueRepoRevFuncCall {
	f.mutex.Lock()
	history := make([]StoreQueueRepoRevFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreQueueRepoRevFuncCall is an object that describes an invocation of
// method QueueRepoRev on an instance of MockStore.
type StoreQueueRepoRevFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreQueueRepoRevFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreQueueRepoRevFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreRepositoryExceptionsFunc describes the behavior when the
// RepositoryExceptions method of the parent MockStore instance is invoked.
type StoreRepositoryExceptionsFunc struct {
	defaultHook func(context.Context, int) (bool, bool, error)
	hooks       []func(context.Context, int) (bool, bool, error)
	history     []StoreRepositoryExceptionsFuncCall
	mutex       sync.Mutex
}

// RepositoryExceptions delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) RepositoryExceptions(v0 context.Context, v1 int) (bool, bool, error) {
	r0, r1, r2 := m.RepositoryExceptionsFunc.nextHook()(v0, v1)
	m.RepositoryExceptionsFunc.appendCall(StoreRepositoryExceptionsFuncCall{v0, v1, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the RepositoryExceptions
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreRepositoryExceptionsFunc) SetDefaultHook(hook func(context.Context, int) (bool, bool, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepositoryExceptions method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreRepositoryExceptionsFunc) PushHook(hook func(context.Context, int) (bool, bool, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreRepositoryExceptionsFunc) SetDefaultReturn(r0 bool, r1 bool, r2 error) {
	f.SetDefaultHook(func(context.Context, int) (bool, bool, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreRepositoryExceptionsFunc) PushReturn(r0 bool, r1 bool, r2 error) {
	f.PushHook(func(context.Context, int) (bool, bool, error) {
		return r0, r1, r2
	})
}

func (f *StoreRepositoryExceptionsFunc) nextHook() func(context.Context, int) (bool, bool, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreRepositoryExceptionsFunc) appendCall(r0 StoreRepositoryExceptionsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreRepositoryExceptionsFuncCall objects
// describing the invocations of this function.
func (f *StoreRepositoryExceptionsFunc) History() []StoreRepositoryExceptionsFuncCall {
	f.mutex.Lock()
	history := make([]StoreRepositoryExceptionsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreRepositoryExceptionsFuncCall is an object that describes an
// invocation of method RepositoryExceptions on an instance of MockStore.
type StoreRepositoryExceptionsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 bool
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 bool
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreRepositoryExceptionsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreRepositoryExceptionsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreRepositoryIDsWithConfigurationFunc describes the behavior when the
// RepositoryIDsWithConfiguration method of the parent MockStore instance is
// invoked.
type StoreRepositoryIDsWithConfigurationFunc struct {
	defaultHook func(context.Context, int, int) ([]shared1.RepositoryWithAvailableIndexers, int, error)
	hooks       []func(context.Context, int, int) ([]shared1.RepositoryWithAvailableIndexers, int, error)
	history     []StoreRepositoryIDsWithConfigurationFuncCall
	mutex       sync.Mutex
}

// RepositoryIDsWithConfiguration delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) RepositoryIDsWithConfiguration(v0 context.Context, v1 int, v2 int) ([]shared1.RepositoryWithAvailableIndexers, int, error) {
	r0, r1, r2 := m.RepositoryIDsWithConfigurationFunc.nextHook()(v0, v1, v2)
	m.RepositoryIDsWithConfigurationFunc.appendCall(StoreRepositoryIDsWithConfigurationFuncCall{v0, v1, v2, r0, r1, r2})
	return r0, r1, r2
}

// SetDefaultHook sets function that is called when the
// RepositoryIDsWithConfiguration method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreRepositoryIDsWithConfigurationFunc) SetDefaultHook(hook func(context.Context, int, int) ([]shared1.RepositoryWithAvailableIndexers, int, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// RepositoryIDsWithConfiguration method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreRepositoryIDsWithConfigurationFunc) PushHook(hook func(context.Context, int, int) ([]shared1.RepositoryWithAvailableIndexers, int, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreRepositoryIDsWithConfigurationFunc) SetDefaultReturn(r0 []shared1.RepositoryWithAvailableIndexers, r1 int, r2 error) {
	f.SetDefaultHook(func(context.Context, int, int) ([]shared1.RepositoryWithAvailableIndexers, int, error) {
		return r0, r1, r2
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreRepositoryIDsWithConfigurationFunc) PushReturn(r0 []shared1.RepositoryWithAvailableIndexers, r1 int, r2 error) {
	f.PushHook(func(context.Context, int, int) ([]shared1.RepositoryWithAvailableIndexers, int, error) {
		return r0, r1, r2
	})
}

func (f *StoreRepositoryIDsWithConfigurationFunc) nextHook() func(context.Context, int, int) ([]shared1.RepositoryWithAvailableIndexers, int, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreRepositoryIDsWithConfigurationFunc) appendCall(r0 StoreRepositoryIDsWithConfigurationFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreRepositoryIDsWithConfigurationFuncCall
// objects describing the invocations of this function.
func (f *StoreRepositoryIDsWithConfigurationFunc) History() []StoreRepositoryIDsWithConfigurationFuncCall {
	f.mutex.Lock()
	history := make([]StoreRepositoryIDsWithConfigurationFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreRepositoryIDsWithConfigurationFuncCall is an object that describes
// an invocation of method RepositoryIDsWithConfiguration on an instance of
// MockStore.
type StoreRepositoryIDsWithConfigurationFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared1.RepositoryWithAvailableIndexers
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 int
	// Result2 is the value of the 3rd result returned from this method
	// invocation.
	Result2 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreRepositoryIDsWithConfigurationFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreRepositoryIDsWithConfigurationFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1, c.Result2}
}

// StoreSetConfigurationSummaryFunc describes the behavior when the
// SetConfigurationSummary method of the parent MockStore instance is
// invoked.
type StoreSetConfigurationSummaryFunc struct {
	defaultHook func(context.Context, int, int, map[string]shared1.AvailableIndexer) error
	hooks       []func(context.Context, int, int, map[string]shared1.AvailableIndexer) error
	history     []StoreSetConfigurationSummaryFuncCall
	mutex       sync.Mutex
}

// SetConfigurationSummary delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) SetConfigurationSummary(v0 context.Context, v1 int, v2 int, v3 map[string]shared1.AvailableIndexer) error {
	r0 := m.SetConfigurationSummaryFunc.nextHook()(v0, v1, v2, v3)
	m.SetConfigurationSummaryFunc.appendCall(StoreSetConfigurationSummaryFuncCall{v0, v1, v2, v3, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// SetConfigurationSummary method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreSetConfigurationSummaryFunc) SetDefaultHook(hook func(context.Context, int, int, map[string]shared1.AvailableIndexer) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SetConfigurationSummary method of the parent MockStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreSetConfigurationSummaryFunc) PushHook(hook func(context.Context, int, int, map[string]shared1.AvailableIndexer) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreSetConfigurationSummaryFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, int, map[string]shared1.AvailableIndexer) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreSetConfigurationSummaryFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, int, map[string]shared1.AvailableIndexer) error {
		return r0
	})
}

func (f *StoreSetConfigurationSummaryFunc) nextHook() func(context.Context, int, int, map[string]shared1.AvailableIndexer) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreSetConfigurationSummaryFunc) appendCall(r0 StoreSetConfigurationSummaryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreSetConfigurationSummaryFuncCall
// objects describing the invocations of this function.
func (f *StoreSetConfigurationSummaryFunc) History() []StoreSetConfigurationSummaryFuncCall {
	f.mutex.Lock()
	history := make([]StoreSetConfigurationSummaryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreSetConfigurationSummaryFuncCall is an object that describes an
// invocation of method SetConfigurationSummary on an instance of MockStore.
type StoreSetConfigurationSummaryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 int
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 map[string]shared1.AvailableIndexer
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreSetConfigurationSummaryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreSetConfigurationSummaryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreSetInferenceScriptFunc describes the behavior when the
// SetInferenceScript method of the parent MockStore instance is invoked.
type StoreSetInferenceScriptFunc struct {
	defaultHook func(context.Context, string) error
	hooks       []func(context.Context, string) error
	history     []StoreSetInferenceScriptFuncCall
	mutex       sync.Mutex
}

// SetInferenceScript delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) SetInferenceScript(v0 context.Context, v1 string) error {
	r0 := m.SetInferenceScriptFunc.nextHook()(v0, v1)
	m.SetInferenceScriptFunc.appendCall(StoreSetInferenceScriptFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the SetInferenceScript
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreSetInferenceScriptFunc) SetDefaultHook(hook func(context.Context, string) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SetInferenceScript method of the parent MockStore instance invokes the
// hook at the front of the queue and discards it. After the queue is empty,
// the default hook function is invoked for any future action.
func (f *StoreSetInferenceScriptFunc) PushHook(hook func(context.Context, string) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreSetInferenceScriptFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, string) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreSetInferenceScriptFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, string) error {
		return r0
	})
}

func (f *StoreSetInferenceScriptFunc) nextHook() func(context.Context, string) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreSetInferenceScriptFunc) appendCall(r0 StoreSetInferenceScriptFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreSetInferenceScriptFuncCall objects
// describing the invocations of this function.
func (f *StoreSetInferenceScriptFunc) History() []StoreSetInferenceScriptFuncCall {
	f.mutex.Lock()
	history := make([]StoreSetInferenceScriptFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreSetInferenceScriptFuncCall is an object that describes an invocation
// of method SetInferenceScript on an instance of MockStore.
type StoreSetInferenceScriptFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 string
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreSetInferenceScriptFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreSetInferenceScriptFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreSetRepositoryExceptionsFunc describes the behavior when the
// SetRepositoryExceptions method of the parent MockStore instance is
// invoked.
type StoreSetRepositoryExceptionsFunc struct {
	defaultHook func(context.Context, int, bool, bool) error
	hooks       []func(context.Context, int, bool, bool) error
	history     []StoreSetRepositoryExceptionsFuncCall
	mutex       sync.Mutex
}

// SetRepositoryExceptions delegates to the next hook function in the queue
// and stores the parameter and result values of this invocation.
func (m *MockStore) SetRepositoryExceptions(v0 context.Context, v1 int, v2 bool, v3 bool) error {
	r0 := m.SetRepositoryExceptionsFunc.nextHook()(v0, v1, v2, v3)
	m.SetRepositoryExceptionsFunc.appendCall(StoreSetRepositoryExceptionsFuncCall{v0, v1, v2, v3, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// SetRepositoryExceptions method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreSetRepositoryExceptionsFunc) SetDefaultHook(hook func(context.Context, int, bool, bool) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// SetRepositoryExceptions method of the parent MockStore instance invokes
// the hook at the front of the queue and discards it. After the queue is
// empty, the default hook function is invoked for any future action.
func (f *StoreSetRepositoryExceptionsFunc) PushHook(hook func(context.Context, int, bool, bool) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreSetRepositoryExceptionsFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, bool, bool) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreSetRepositoryExceptionsFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, bool, bool) error {
		return r0
	})
}

func (f *StoreSetRepositoryExceptionsFunc) nextHook() func(context.Context, int, bool, bool) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreSetRepositoryExceptionsFunc) appendCall(r0 StoreSetRepositoryExceptionsFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreSetRepositoryExceptionsFuncCall
// objects describing the invocations of this function.
func (f *StoreSetRepositoryExceptionsFunc) History() []StoreSetRepositoryExceptionsFuncCall {
	f.mutex.Lock()
	history := make([]StoreSetRepositoryExceptionsFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreSetRepositoryExceptionsFuncCall is an object that describes an
// invocation of method SetRepositoryExceptions on an instance of MockStore.
type StoreSetRepositoryExceptionsFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 bool
	// Arg3 is the value of the 4th argument passed to this method
	// invocation.
	Arg3 bool
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreSetRepositoryExceptionsFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2, c.Arg3}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreSetRepositoryExceptionsFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreTopRepositoriesToConfigureFunc describes the behavior when the
// TopRepositoriesToConfigure method of the parent MockStore instance is
// invoked.
type StoreTopRepositoriesToConfigureFunc struct {
	defaultHook func(context.Context, int) ([]shared1.RepositoryWithCount, error)
	hooks       []func(context.Context, int) ([]shared1.RepositoryWithCount, error)
	history     []StoreTopRepositoriesToConfigureFuncCall
	mutex       sync.Mutex
}

// TopRepositoriesToConfigure delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) TopRepositoriesToConfigure(v0 context.Context, v1 int) ([]shared1.RepositoryWithCount, error) {
	r0, r1 := m.TopRepositoriesToConfigureFunc.nextHook()(v0, v1)
	m.TopRepositoriesToConfigureFunc.appendCall(StoreTopRepositoriesToConfigureFuncCall{v0, v1, r0, r1})
	return r0, r1
}

// SetDefaultHook sets function that is called when the
// TopRepositoriesToConfigure method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreTopRepositoriesToConfigureFunc) SetDefaultHook(hook func(context.Context, int) ([]shared1.RepositoryWithCount, error)) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// TopRepositoriesToConfigure method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreTopRepositoriesToConfigureFunc) PushHook(hook func(context.Context, int) ([]shared1.RepositoryWithCount, error)) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreTopRepositoriesToConfigureFunc) SetDefaultReturn(r0 []shared1.RepositoryWithCount, r1 error) {
	f.SetDefaultHook(func(context.Context, int) ([]shared1.RepositoryWithCount, error) {
		return r0, r1
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreTopRepositoriesToConfigureFunc) PushReturn(r0 []shared1.RepositoryWithCount, r1 error) {
	f.PushHook(func(context.Context, int) ([]shared1.RepositoryWithCount, error) {
		return r0, r1
	})
}

func (f *StoreTopRepositoriesToConfigureFunc) nextHook() func(context.Context, int) ([]shared1.RepositoryWithCount, error) {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreTopRepositoriesToConfigureFunc) appendCall(r0 StoreTopRepositoriesToConfigureFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreTopRepositoriesToConfigureFuncCall
// objects describing the invocations of this function.
func (f *StoreTopRepositoriesToConfigureFunc) History() []StoreTopRepositoriesToConfigureFuncCall {
	f.mutex.Lock()
	history := make([]StoreTopRepositoriesToConfigureFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreTopRepositoriesToConfigureFuncCall is an object that describes an
// invocation of method TopRepositoriesToConfigure on an instance of
// MockStore.
type StoreTopRepositoriesToConfigureFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 []shared1.RepositoryWithCount
	// Result1 is the value of the 2nd result returned from this method
	// invocation.
	Result1 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreTopRepositoriesToConfigureFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreTopRepositoriesToConfigureFuncCall) Results() []interface{} {
	return []interface{}{c.Result0, c.Result1}
}

// StoreTruncateConfigurationSummaryFunc describes the behavior when the
// TruncateConfigurationSummary method of the parent MockStore instance is
// invoked.
type StoreTruncateConfigurationSummaryFunc struct {
	defaultHook func(context.Context, int) error
	hooks       []func(context.Context, int) error
	history     []StoreTruncateConfigurationSummaryFuncCall
	mutex       sync.Mutex
}

// TruncateConfigurationSummary delegates to the next hook function in the
// queue and stores the parameter and result values of this invocation.
func (m *MockStore) TruncateConfigurationSummary(v0 context.Context, v1 int) error {
	r0 := m.TruncateConfigurationSummaryFunc.nextHook()(v0, v1)
	m.TruncateConfigurationSummaryFunc.appendCall(StoreTruncateConfigurationSummaryFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// TruncateConfigurationSummary method of the parent MockStore instance is
// invoked and the hook queue is empty.
func (f *StoreTruncateConfigurationSummaryFunc) SetDefaultHook(hook func(context.Context, int) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// TruncateConfigurationSummary method of the parent MockStore instance
// invokes the hook at the front of the queue and discards it. After the
// queue is empty, the default hook function is invoked for any future
// action.
func (f *StoreTruncateConfigurationSummaryFunc) PushHook(hook func(context.Context, int) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreTruncateConfigurationSummaryFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreTruncateConfigurationSummaryFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int) error {
		return r0
	})
}

func (f *StoreTruncateConfigurationSummaryFunc) nextHook() func(context.Context, int) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreTruncateConfigurationSummaryFunc) appendCall(r0 StoreTruncateConfigurationSummaryFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreTruncateConfigurationSummaryFuncCall
// objects describing the invocations of this function.
func (f *StoreTruncateConfigurationSummaryFunc) History() []StoreTruncateConfigurationSummaryFuncCall {
	f.mutex.Lock()
	history := make([]StoreTruncateConfigurationSummaryFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreTruncateConfigurationSummaryFuncCall is an object that describes an
// invocation of method TruncateConfigurationSummary on an instance of
// MockStore.
type StoreTruncateConfigurationSummaryFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreTruncateConfigurationSummaryFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreTruncateConfigurationSummaryFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreUpdateIndexConfigurationByRepositoryIDFunc describes the behavior
// when the UpdateIndexConfigurationByRepositoryID method of the parent
// MockStore instance is invoked.
type StoreUpdateIndexConfigurationByRepositoryIDFunc struct {
	defaultHook func(context.Context, int, []byte) error
	hooks       []func(context.Context, int, []byte) error
	history     []StoreUpdateIndexConfigurationByRepositoryIDFuncCall
	mutex       sync.Mutex
}

// UpdateIndexConfigurationByRepositoryID delegates to the next hook
// function in the queue and stores the parameter and result values of this
// invocation.
func (m *MockStore) UpdateIndexConfigurationByRepositoryID(v0 context.Context, v1 int, v2 []byte) error {
	r0 := m.UpdateIndexConfigurationByRepositoryIDFunc.nextHook()(v0, v1, v2)
	m.UpdateIndexConfigurationByRepositoryIDFunc.appendCall(StoreUpdateIndexConfigurationByRepositoryIDFuncCall{v0, v1, v2, r0})
	return r0
}

// SetDefaultHook sets function that is called when the
// UpdateIndexConfigurationByRepositoryID method of the parent MockStore
// instance is invoked and the hook queue is empty.
func (f *StoreUpdateIndexConfigurationByRepositoryIDFunc) SetDefaultHook(hook func(context.Context, int, []byte) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// UpdateIndexConfigurationByRepositoryID method of the parent MockStore
// instance invokes the hook at the front of the queue and discards it.
// After the queue is empty, the default hook function is invoked for any
// future action.
func (f *StoreUpdateIndexConfigurationByRepositoryIDFunc) PushHook(hook func(context.Context, int, []byte) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreUpdateIndexConfigurationByRepositoryIDFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, int, []byte) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreUpdateIndexConfigurationByRepositoryIDFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, int, []byte) error {
		return r0
	})
}

func (f *StoreUpdateIndexConfigurationByRepositoryIDFunc) nextHook() func(context.Context, int, []byte) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreUpdateIndexConfigurationByRepositoryIDFunc) appendCall(r0 StoreUpdateIndexConfigurationByRepositoryIDFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of
// StoreUpdateIndexConfigurationByRepositoryIDFuncCall objects describing
// the invocations of this function.
func (f *StoreUpdateIndexConfigurationByRepositoryIDFunc) History() []StoreUpdateIndexConfigurationByRepositoryIDFuncCall {
	f.mutex.Lock()
	history := make([]StoreUpdateIndexConfigurationByRepositoryIDFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreUpdateIndexConfigurationByRepositoryIDFuncCall is an object that
// describes an invocation of method UpdateIndexConfigurationByRepositoryID
// on an instance of MockStore.
type StoreUpdateIndexConfigurationByRepositoryIDFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 int
	// Arg2 is the value of the 3rd argument passed to this method
	// invocation.
	Arg2 []byte
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreUpdateIndexConfigurationByRepositoryIDFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1, c.Arg2}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreUpdateIndexConfigurationByRepositoryIDFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}

// StoreWithTransactionFunc describes the behavior when the WithTransaction
// method of the parent MockStore instance is invoked.
type StoreWithTransactionFunc struct {
	defaultHook func(context.Context, func(tx store.Store) error) error
	hooks       []func(context.Context, func(tx store.Store) error) error
	history     []StoreWithTransactionFuncCall
	mutex       sync.Mutex
}

// WithTransaction delegates to the next hook function in the queue and
// stores the parameter and result values of this invocation.
func (m *MockStore) WithTransaction(v0 context.Context, v1 func(tx store.Store) error) error {
	r0 := m.WithTransactionFunc.nextHook()(v0, v1)
	m.WithTransactionFunc.appendCall(StoreWithTransactionFuncCall{v0, v1, r0})
	return r0
}

// SetDefaultHook sets function that is called when the WithTransaction
// method of the parent MockStore instance is invoked and the hook queue is
// empty.
func (f *StoreWithTransactionFunc) SetDefaultHook(hook func(context.Context, func(tx store.Store) error) error) {
	f.defaultHook = hook
}

// PushHook adds a function to the end of hook queue. Each invocation of the
// WithTransaction method of the parent MockStore instance invokes the hook
// at the front of the queue and discards it. After the queue is empty, the
// default hook function is invoked for any future action.
func (f *StoreWithTransactionFunc) PushHook(hook func(context.Context, func(tx store.Store) error) error) {
	f.mutex.Lock()
	f.hooks = append(f.hooks, hook)
	f.mutex.Unlock()
}

// SetDefaultReturn calls SetDefaultHook with a function that returns the
// given values.
func (f *StoreWithTransactionFunc) SetDefaultReturn(r0 error) {
	f.SetDefaultHook(func(context.Context, func(tx store.Store) error) error {
		return r0
	})
}

// PushReturn calls PushHook with a function that returns the given values.
func (f *StoreWithTransactionFunc) PushReturn(r0 error) {
	f.PushHook(func(context.Context, func(tx store.Store) error) error {
		return r0
	})
}

func (f *StoreWithTransactionFunc) nextHook() func(context.Context, func(tx store.Store) error) error {
	f.mutex.Lock()
	defer f.mutex.Unlock()

	if len(f.hooks) == 0 {
		return f.defaultHook
	}

	hook := f.hooks[0]
	f.hooks = f.hooks[1:]
	return hook
}

func (f *StoreWithTransactionFunc) appendCall(r0 StoreWithTransactionFuncCall) {
	f.mutex.Lock()
	f.history = append(f.history, r0)
	f.mutex.Unlock()
}

// History returns a sequence of StoreWithTransactionFuncCall objects
// describing the invocations of this function.
func (f *StoreWithTransactionFunc) History() []StoreWithTransactionFuncCall {
	f.mutex.Lock()
	history := make([]StoreWithTransactionFuncCall, len(f.history))
	copy(history, f.history)
	f.mutex.Unlock()

	return history
}

// StoreWithTransactionFuncCall is an object that describes an invocation of
// method WithTransaction on an instance of MockStore.
type StoreWithTransactionFuncCall struct {
	// Arg0 is the value of the 1st argument passed to this method
	// invocation.
	Arg0 context.Context
	// Arg1 is the value of the 2nd argument passed to this method
	// invocation.
	Arg1 func(tx store.Store) error
	// Result0 is the value of the 1st result returned from this method
	// invocation.
	Result0 error
}

// Args returns an interface slice containing the arguments of this
// invocation.
func (c StoreWithTransactionFuncCall) Args() []interface{} {
	return []interface{}{c.Arg0, c.Arg1}
}

// Results returns an interface slice containing the results of this
// invocation.
func (c StoreWithTransactionFuncCall) Results() []interface{} {
	return []interface{}{c.Result0}
}
